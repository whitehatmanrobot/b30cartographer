ling the service multiple times until
        /// no new data is available. Operations may occur during iteration of the returned enumerable.
        /// </summary>
        /// <returns>The set of all notifications retrieved, in order of retrieval</returns>
        private IEnumerable<Notification> LoadAllNotificationsStream()
        {
            string lastID = null;
            List<Notification> data = null;

            //We do some magic with the yield keyword here so that we can return
            //an enumeration that is the aggregation of multiple service calls. What happens is
            //that when retrieving the first item, we call GetNotifications and get the first batch.
            //Each iteration on our IEnumerable will return the next item from that batch. When we 
            //run out of items, we call GetNotifications again and keep going with a new batch.
            do
            {
                try
                {
                    data = null;
                    data = NotificationService.GetNotifications(_user.Authentication.TitleID, 
                        null, lastID, null, _user.Authentication, _serviceConfig);
                }
                catch (Exception e)
                {
                    NotificationTrace.TraceEvent(TraceEventType.Error, 0, "Problem loading notifications: " + e.ToString());
                }

                if (data != null)
                {
                    foreach (var entry in data)
                    {
                        lastID = entry.Id;
                        yield return entry;
                    }
                }

            } while(data != null && data.Count > 0);
        }
        #endregion

        #region Processing
        /// <summary>
        /// Reads through a stream of notifications, updating our cache and queuing events
        /// </summary>
        /// <param name="stream"></param>
        /// <param name="isFullStream">Whether the stream contains 'all' available notifications. Necessary
        /// to correctly process removals.</param>
        private void ProcessNewNotifications(IEnumerable<Notification> stream, bool isFullStream)
        {
            List<string> streamData = new List<string>();

            //Go through the stream and update our cache with the data. The iteration may
            //cause service calls that retrieve more data.
            foreach (var item in stream)
            {
                //Add/update local cache
                AddNotification(item);

                //Store the IDs of the retrieved notifications
                //so that we can figure out what is missing
                streamData.Add(item.Id);
            }

            //We can only tell if data is missing if we're looking through the
            //whole stream
            if (isFullStream && (_notificationRemoved != null))
            {
                List<string> toRemove;
                lock (_cacheLock)
                {
                    //Find all notifications in the local cache that don't
                    //exist in the new stream data
                    toRemove = (from kvp in _notifCache
                                    where streamData.Contains(kvp.Key) == false
                                    select kvp.Key).ToList();
                }

                    foreach (var id in toRemove)
                    {
                        RemoveNotification(id);
                    }
            }
        }
        #endregion

        #region Cache Operations
        /// <summary>
        /// Adds a notification to the local cache, or replaces any existing
        /// notification with the same ID, and queues corresponding events
        /// </summary>
        /// <param name="notification"></param>
        private void AddNotification(Notification notification)
        {
            //Update the local cache
            lock (_cacheLock)
            {
                bool isNew = !_notifCache.ContainsKey(notification.Id);
                _notifCache[notification.Id] = notification;

                _eventQueue.Enqueue(delegate()
                {
                    if (isNew)
                        OnNotificationAdded(notification);
                    else
                        OnNotificationUpdated(notification);
                });
            }            
        }

        /// <summary>
        /// Removes the notification from the local cache and queues
        /// the corresponding events
        /// </summary>
        /// <param name="notification"></param>
        private void RemoveNotification(Notification notification)
        {
            //Update the local cache
            lock (_cacheLock)
            {
                if (_notifCache.ContainsKey(notification.Id))
                {
                    //Do the remove
                    _notifCache.Remove(notification.Id);

                    _eventQueue.Enqueue(delegate()
                    {
                        OnNotificationRemoved(notification);
                    });
                }
            }
        }

        /// <summary>
        /// Removes the notification from the local cache and queues
        /// the corresponding events
        /// </summary>
        /// <param name="id">The ID of the notification to remove</param>
        private void RemoveNotification(string id)
        {
            //Update the local cache
            lock (_cacheLock)
            {
                Notification msg;
                if (_notifCache.TryGetValue(id, out msg))
                {
                    //Do the remove
                    _notifCache.Remove(id);

                    _eventQueue.Enqueue(delegate()
                    {
                        OnNotificationRemoved(msg);
                    });
                }
            }
        }
        #endregion

        #endregion



        #region Public Interface


        #region Service Operations

        /// <summary>
        /// Loads in a subset of the notifications from the server, blocking the calling thread until
        /// the operation is completed. If another operation is in progress, this method will wait
        /// until it has completed.
        /// </summary>
        public void LoadNotificationsChunk(string lastID, int maxCount)
        {
            //Prevent other operations occuring at the same time
            //We don't need conflicting updates
            lock (_operationLock)
            {
                NotificationTrace.TraceInformation("Loading up to {0} notifications, starting at {1}", maxCount, lastID);
                var data = NotificationService.GetNotifications(null, null, lastID, maxCount, _user.Authentication, _serviceConfig);
                ProcessNewNotifications(data, false);
            }
        }

        /// <summary>
        /// Loads in all available notifications from the server, blocking the calling thread until
        /// the operation is completed. If another operation is in progress, this method will wait
        /// until it has completed.
        /// </summary>
        public void LoadAllNotifications()
        {
            //Prevent other operations occuring at the same time
            //We don't need conflicting updates
            lock (_operationLock)
            {
                NotificationTrace.TraceInformation("Loading all available notifications");
                var data = LoadAllNotificationsStream();
                ProcessNewNotifications(data, true);
            }
        }


        /// <summary>
        /// Deletes a notification, blocking the calling thread until the operation is completed.
        /// If another operation is in progress, this method will wait until it has completed.
        /// </summary>
        /// <param name="notification">The notification to delete</param>
        public void Delete(Notification notification)
        {
            //Prevent other operations occuring at the same time.
            //We don't want a load operation caching old data just after we do a delete
            lock (_operationLock)
            {
                //Perform the delete on the server
                NotificationService.DeleteNotification(notification, _user.Authentication, _serviceConfig);

                //If the service supported getting data on a specific notification, we might verify it was deleted here

                //Remove it from our local cache and raise events
                RemoveNotification(notification);
            }
        }

        #endregion

        #region Auto-load

        /// <summary>
        /// Gets whether we are currently set to auto-load notifications
        /// at a set interval
        /// </summary>
        public bool IsAutoLoadEnabled
        {
            get { return _autoLoader.Enabled; }
        }

        /// <summary>
        /// Gets/sets the minimum interval the auto-loader is set to poll the notifications service
        /// </summary>
        public TimeSpan AutoLoadInterval
        {
            get { return _autoLoader.Interval; }
            set { _autoLoader.Interval = value; }
        }

        /// <summary>
        /// Starts a background thread to automatically load notifications at the specified interval
        /// </summary>
        /// <param name="interval">The minimum interval between loads</param>
        public void StartAutoLoad(TimeSpan interval)
        {
            _autoLoader.StartAutoLoad(interval);
        }

        /// <summary>
        /// Stops auto loading notifications
        /// </summary>
        public void StopAutoLoad()
        {
            _autoLoader.StopAutoLoad();
        }
        #endregion

        #region Cache Lookup
        /// <summary>
        /// Gets a copy of the current local cache
        /// </summary>
        /// <returns></returns>
        public ICollection<Notification> GetAllNotifications()
        {
            lock (_cacheLock)
            {
                return _notifCache.Values.ToList();
            }
        }

        /// <summary>
        /// Checks whether a notification with the given ID exists in the local cache
        /// </summary>
        /// <param name="notification">The notification whose ID we are looking for</param>
        /// <returns>True if it exists in the cache, false otherwise.</returns>
        public bool ContainsNotification(Notification notification)
        {
            lock (_cacheLock)
            {
                return _notifCache.ContainsKey(notification.Id);
            }
        }
        #endregion

        #endregion


        #region Event Raising
        private void OnNotificationRemoved(Notification notification)
        {
            _notificationRemoved.Raise(this, new NotificationEventArgs(notification));
        }
        private void OnNotificationAdded(Notification notification)
        {
            _notificationAdded.Raise(this, new NotificationEventArgs(notification));
        }
        private void OnNotificationUpdated(Notification notification)
        {
            _notificationUpdated.Raise(this, new NotificationEventArgs(notification));
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardFramework\Cache\SessionStoreCustom.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using OneCardFramework;
using OneCardFramework.Configuration;
using OneCardFramework.Extensions;
using OneCardFramework.Game;
using OneCardFramework.Services;
using AsyncMultiplayer.SessionCommon;

namespace OneCardFramework.Cache
{
    public class SessionStoreCustom<TConfig, TGame> : SessionStoreBase
        where TConfig : GameConfig
        where TGame : class, IGame
    {
        Func<TConfig, byte[]> _gameInitializer;
        Func<GameSession, TGame> _gameBuilder;

        public SessionStoreCustom(User user, MultiplayerServiceConfig config,
            Func<TConfig, byte[]> gameInitializer, Func<GameSession, TGame> gameBuilder)
            : base(user, config)
        {
            _gameInitializer = gameInitializer;
            _gameBuilder = gameBuilder;
        }

        public override bool SupportsConfig(Type configType)
        {
            Type ourType = typeof(TConfig);

            //We support a config if it is covariant
            return ourType == configType || configType.IsSubclassOf(ourType);
        }

        public override bool SupportsGame(Type gameType)
        {
            Type ourType = typeof(TGame);

            //We support a game if it is contravariant
            return ourType == gameType || ourType.IsSubclassOf(gameType);
        }


        protected override CreationData InitializeSession(object config)
        {
            TConfig gameConfig = config as TConfig;

            CreationData cd = new CreationData();
            cd.DisplayName = gameConfig.DisplayName;
            cd.CanRemoveEmptySeats = gameConfig.CanRemoveEmptySeats;
            cd.ReservedSeatsAvailable = gameConfig.ReservedSeatsAvailable;
            cd.TotalSeatsAvailable = gameConfig.TotalSeatsAvailable;
            cd.Variant = gameConfig.Variant;
            cd.InactivityWarning = gameConfig.InactivityWarning;
            cd.SessionParameters = _gameInitializer(gameConfig);

            return cd;
        }

        protected override IGame LoadGame(GameSession session)
        {
            return _gameBuilder(session);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardFramework\Cache\SessionStoreBase.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using OneCardFramework;
using OneCardFramework.Configuration;
using OneCardFramework.Extensions;
using OneCardFramework.Game;
using OneCardFramework.Services;
using AsyncMultiplayer.SessionCommon;
using System.Diagnostics;
using OneCardFramework.Events;

namespace OneCardFramework.Cache
{
    /// <summary>
    /// Provides a thread-safe local cache of data from the online session service. Specific implementation
    /// must be provided for creating and loading actual games
    /// </summary>
    public abstract class SessionStoreBase : ISessionSystem
    {
        public static readonly TraceSource SessionTrace = new TraceSource("OneCardFramework.Cache.SessionTrace", SourceLevels.Verbose);

        #region Events
        public event EventHandler<SessionSummaryEventArgs> SummaryAdded
        {
            //Use weak events
            add { _summaryAdded += value.MakeWeak(n => _summaryAdded -= n); }
            remove { EventManager.Remove(ref _summaryAdded, value); }
        }
        private EventHandler<SessionSummaryEventArgs> _summaryAdded;

        public event EventHandler<SessionSummaryEventArgs> SummaryUpdated
        {
            //Use weak events
            add { _summaryUpdated += value.MakeWeak(n => _summaryUpdated -= n); }
            remove { EventManager.Remove(ref _summaryUpdated, value); }
        }
        private EventHandler<SessionSummaryEventArgs> _summaryUpdated;

        public event EventHandler<SessionSummaryEventArgs> SummaryRemoved
        {
            //Use weak events
            add { _summaryRemoved += value.MakeWeak(n => _summaryRemoved -= n); }
            remove { EventManager.Remove(ref _summaryRemoved, value); }
        }
        private EventHandler<SessionSummaryEventArgs> _summaryRemoved;

        public event EventHandler<SessionDetailEventArgs> DetailAdded
        {
            //Use weak events
            add { _detailAdded += value.MakeWeak(n => _detailAdded -= n); }
            remove { EventManager.Remove(ref _detailAdded, value); }
        }
        private EventHandler<SessionDetailEventArgs> _detailAdded;

        public event EventHandler<SessionDetailEventArgs> DetailUpdated
        {
            //Use weak events
            add { _detailUpdated += value.MakeWeak(n => _detailUpdated -= n); }
            remove { EventManager.Remove(ref _detailUpdated, value); }
        }
        private EventHandler<SessionDetailEventArgs> _detailUpdated;

        public event EventHandler<SessionDetailEventArgs> DetailRemoved
        {
            //Use weak events
            add { _detailRemoved += value.MakeWeak(n => _detailRemoved -= n); }
            remove { EventManager.Remove(ref _detailRemoved, value); }
        }
        private EventHandler<SessionDetailEventArgs> _detailRemoved;

        public event EventHandler<GameEventArgs> PlayRequested
        {
            //Use weak events
            add { _playRequested += value.MakeWeak(n => _playRequested -= n); }
            remove { EventManager.Remove(ref _playRequested, value); }
        }
        private EventHandler<GameEventArgs> _playRequested;

        public event EventHandler<GameEventArgs> GameAdded
        {
            //Use weak events
            add { _gameAdded += value.MakeWeak(n => _gameAdded -= n); }
            remove { EventManager.Remove(ref _gameAdded, value); }
        }
        private EventHandler<GameEventArgs> _gameAdded;

        public event EventHandler<GameEventArgs> GameRemoved
        {
            //Use weak events
            add { _gameRemoved += value.MakeWeak(n => _gameRemoved -= n); }
            remove { EventManager.Remove(ref _gameRemoved, value); }
        }
        private EventHandler<GameEventArgs> _gameRemoved;
        #endregion

        public bool IsLoadingSummaries { get; private set; }
        private readonly object _loadingSummariesLock;

        private Dictionary<string, SessionEntry> _summariesCache;
        private Dictionary<string, SessionState> _detailsCache;
        private Dictionary<string, GameSession> _fullSessionCache;
        private Dictionary<string, IGame> _gameCache;

        private OperationQueue _eventQueue;

        private User _user;
        private MultiplayerServiceConfig _serviceConfig;


        protected SessionStoreBase(User user, MultiplayerServiceConfig config)
        {
            _user = user;
            _serviceConfig = config;

            _summariesCache = new Dictionary<string, SessionEntry>();
            _detailsCache = new Dictionary<string, SessionState>();
            _fullSessionCache = new Dictionary<string, GameSession>();
            _gameCache = new Dictionary<string, IGame>();

            _loadingSummariesLock = new object();
            _eventQueue = new OperationQueue("SessionStore Events");
        }
        

        #region Helpers

        /// <summary>
        /// Gets a stream of all available session summaries, calling the service multiple times until
        /// no new data is available. Operations may during iteration over the returned enumerable.
        /// </summary>
        /// <returns>The set of all summaries retrieved, in order of retrieval</returns>
        private IEnumerable<SessionEntry> LoadAllSummariesStream()
        {
            string lastID = null;
            SessionEntry[] summaries = null;

            //We do some magic with the yield keyword here so that we can return
            //an enumeration that is the aggregation of multiple service calls. What happens is
            //that when retrieving the first item, we call GetNotifications and get the first batch.
            //Each iteration on our IEnumerable will return the next item from that batch. When we 
            //run out of items, we call GetNotifications again and keep going with a new batch.
            do
            {
                try
                {
                    summaries = null;
                    summaries = SessionService.ViewSessionSummaries(null, lastID, null, 
                        ShowSessionType.All, _user.Authentication, _serviceConfig);
                }
                catch (Exception e)
                {
                    SessionTrace.TraceEvent(TraceEventType.Error, 0, "Problem loading session summaries: {0}", e.ToString());
                    throw;
                }

                if (summaries != null)
                {
                    foreach (var entry in summaries)
                    {
                        lastID = entry.SessionID;
                        yield return entry;
                    }
                }

            } while (summaries != null && summaries.Length > 0);
        }

        /// <summary>
        /// Reads a stream of session summaries, updating the local cache and
        /// firing events as necessary
        /// </summary>
        /// <param name="dataStream"></param>
        /// <param name="isFullStream"></param>
        private void ProcessNewSummaries(IEnumerable<SessionEntry> dataStream, bool isFullStream)
        {
            List<string> newData = new List<string>();

            foreach (var newSummary in dataStream)
            {
                //Add/update our local cache and raise events
                AddSummary(newSummary);

                //Store the IDs of the retrieved summaries
                //so that we can figure out what is missing
                newData.Add(newSummary.SessionID);
            }

            //We can only tell if data is missing if we're looking through the
            //whole stream
            if (isFullStream && (_summaryRemoved != null || _detailRemoved != null))
            {
                List<string> toRemove;
                lock (_summariesCache)
                {
                    //Find all summaries in the local cache that don't
                    //exist in the new stream data
                    toRemove = (from kvp in _summariesCache
                                where newData.Contains(kvp.Key) == false
                                select kvp.Key).ToList();
                }

                foreach (var sessionID in toRemove)
                {
                    RemoveSummary(sessionID);
                    RemoveDetail(sessionID);
                }
            }
        }
        #endregion


        #region Session Info Logic

        /// <summary>
        /// Loads all available summaries from the online service, adding/updating/removing
        /// from the local cache. If we are already loading summaries, this operation
        /// will be skipped.
        /// </summary>
        public void LoadAllSummaries()
        {
            lock (_loadingSummariesLock)
            {
                if (IsLoadingSummaries)
                    return;

                IsLoadingSummaries = true;
            }
            try
            {
                ProcessNewSummaries(LoadAllSummariesStream(), true);
            }
            finally
            {
                IsLoadingSummaries = false;
            }
        }

        /// <summary>
        /// Loads a subset of available summaries from the online service. If we are already loading
        /// summaries in some manner, this operation will be skipped.
        /// </summary>
        /// <param name="lastID"></param>
        /// <param name="maxCount"></param>
        public void LoadSummariesChunk(string lastID, int maxCount)
        {
            lock (_loadingSummariesLock)
            {
                if (IsLoadingSummaries)
                    return;

                IsLoadingSummaries = true;
            }
            try
            {
                var summaries = SessionService.ViewSessionSummaries(null, lastID, maxCount, ShowSessionType.All, _user.Authentication, _serviceConfig);
                ProcessNewSummaries(summaries, false);
            }
            finally
            {
                IsLoadingSummaries = false;
            }
        }

        /// <summary>
        /// Gets a collection of all summaries in the local cache
        /// </summary>
        /// <param name="refresh">True to force a re-load of all summaries</param>
        /// <returns></returns>
        public ICollection<SessionEntry> GetAllSummaries(bool refresh)
        {
            if (refresh)
                LoadAllSummaries();

            lock (_summariesCache)
            {
                return _summariesCache.Values.ToList();
            }
        }

        /// <summary>
        /// Retreives the detailed state of the session with the given ID.
        /// If not cached locally, it will be downloaded.
        /// </summary>
        /// <param name="sessionID">The session to retrieve</param>
        /// <param name="refresh">True to force a download of new state data</param>
        /// <returns>The retrieved session state</returns>
        public SessionState GetDetail(string sessionID, bool refresh)
        {
            SessionState cachedState;

            lock (_detailsCache)
            {
                //If we have a cached version and they don't want to force a refresh,
                //we can just return the cached state.
                if (!refresh && _detailsCache.TryGetValue(sessionID, out cachedState))
                    return cachedState;
            }

            //Download the new state. If this fails, we will get an exception, bubble it
            //up, and not perform any changes to the cache
            cachedState = SessionService.ViewSession(sessionID, _user.Authentication, _serviceConfig);

            //Cache the new data
            AddDetail(cachedState);

            return cachedState;
        }

        #endregion


        #region Game Session Logic

        /// <summary>
        /// Checks whether we support a configuration object of a given type
        /// </summary>
        /// <param name="type">The type of the configuration object</param>
        /// <returns>True if supported. False otherwise.</returns>
        public abstract bool SupportsConfig(Type type);

        /// <summary>
        /// Creates a game session using the supplied config
        /// </summary>
        /// <param name="config">The object to use for configuration</param>
        /// <returns>The session ID of the created session</returns>
        /// <exception cref="NotSupportedException">Thrown if the supplied configuration is not a supported type</exception>
        public string CreateSession(object config)
        {
            if (!SupportsConfig(config.GetType()))
                throw new NotSupportedException("Configuration type not supported");

            //Use the concrete implementation to construct the initialization data
            CreationData cd = InitializeSession(config);

            //Create the session on the server and a local wrapper to monitor it
            GameSession createdSession = GameSession.Create(_user, _serviceConfig, cd);

            lock (_fullSessionCache)
            {
                _fullSessionCache.Add(createdSession.SessionID, createdSession);

                //_eventQueue.Enqueue(() => OnSessionCreated(createdSession));
            }

            return createdSession.SessionID;
        }

        /// <summary>
        /// Must be implemented by child classes to supply the initialization data necessary for
        /// creating a session
        /// </summary>
        /// <param name="config">A configuration object of a type validated by SupportsConfig</param>
        /// <returns>Session initialization data</returns>
        protected abstract CreationData InitializeSession(object config);

        /// <summary>
        /// Checks whether we support a game of the given type. Should be implemented by child classes.
        /// </summary>
        /// <param name="type"></param>
        /// <returns></returns>
        public abstract bool SupportsGame(Type type);

        /// <summary>
        /// Acquires the game instance for the session with the given ID. If the game
        /// is not cached, this will load the game from online data and cache it.
        /// </summary>
        /// <param name="sessionID"></param>
        /// <returns></returns>
        public IGame AcquireGame(string sessionID)
        {
            //If we have the game cached, just use that
            IGame cachedGame;
            lock (_gameCache)
            {
                if (_gameCache.TryGetValue(sessionID, out cachedGame))
                    return cachedGame;
            }

            //Try to find a cached GameSession instance we can use to build the game
            GameSession cachedSession;
            lock (_fullSessionCache)
            {
                if (false == _fullSessionCache.TryGetValue(sessionID, out cachedSession))
                {
                    //No luck with the cache, download the session
                    cachedSession = GameSession.Load(_user, _serviceConfig, sessionID);
                    _fullSessionCache.Add(sessionID, cachedSession);

                    //_eventQueue.Enqueue(() => OnSessionLoaded(cachedSession));
                }
            }

            //Build the game through the concrete implementation
            IGame loadedGame = LoadGame(cachedSession);
            lock (_gameCache)
            {
                _gameCache.Add(sessionID, loadedGame);

                _eventQueue.Enqueue(() => OnGameAdded(loadedGame));
            }

            return loadedGame;
        }

        /// <summary>
        /// Must be implemented by child classes to create a new game instance from online session data
        /// </summary>
        /// <param name="session">The local mirror of the online data</param>
        /// <returns></returns>
        protected abstract IGame LoadGame(GameSession session);


        /// <summary>
        /// Joins a game session in whatever seat is available
        /// </summary>
        /// <param name="sessionID">The ID of the session to join</param>
        public void JoinSession(string sessionID)
        {
            JoinSession(sessionID, 0, null);
        }

        /// <summary>
        /// Joins a game session in a specific seat and caches a local mirror
        /// of the created session
        /// </summary>
        /// <param name="sessionID">The ID of the session to join</param>
        /// <param name="seatIndex">The index of the seat to join into</param>
        /// <param name="seatParameters"></param>
        public void JoinSession(string sessionID, int seatIndex, byte[] seatParameters)
        {
            JoinData jd = new JoinData();
            jd.SessionID = sessionID;
            jd.SeatIndex = seatIndex;
            jd.SeatParameters = seatParameters;

            //Join the session. If this fails, we will get an exception, bubble it
            //up, and not perform any changes to the cache
            GameSession joinedSession = GameSession.Join(_user, _serviceConfig, jd);

            lock (_fullSessionCache)
            {
                _fullSessionCache.Add(sessionID, joinedSession);

                //_eventQueue.Enqueue(() => OnSessionJoined(joinedSession));
            }
        }

        /// <summary>
        /// Requests that we want to play a certain game. Will acquire the
        /// game and notify listeners that play has been requested.
        /// </summary>
        /// <param name="sessionID"></param>
        public void RequestPlay(string sessionID)
        {
            IGame game = AcquireGame(sessionID);

            OnPlayRequested(game);
        }

        /// <summary>
        /// Requests to leave the specified session, optionally notifying the game
        /// for that session that the leave is occuring (allowing it to do last-minute cleanup)
        /// </summary>
        /// <param name="sessionID"></param>
        /// <param name="notifyGame">True to notify the game, which may involve re-aquiring it. 
        /// If acquisition fails, the leave will still occur</param>
        public void RequestLeave(string sessionID, bool notifyGame)
        {
            IGame cachedGame = null;

            if (notifyGame)
            {
                lock (_gameCache) { _gameCache.TryGetValue(sessionID, out cachedGame); }

                if (cachedGame == null)
                {
                    try
                    {
                        cachedGame = AcquireGame(sessionID);
                    }
                    catch (Exception e)
                    {
                        SessionTrace.TraceEvent(TraceEventType.Error, 0, "Error loading game to notify prior to LeaveSession. Error: " + e.ToString());
                        SessionTrace.TraceInformation("Continuing with leave operation");
                    }
                }
            }

            if (cachedGame != null)
                cachedGame.NotifyPreLeave();

            //This operation may fail and throw an exception, in which case we will let it bubble up
            //and not remove the item from our cache (since it probably didn't get removed on the service).
            SessionService.LeaveSession(sessionID, _user.Authentication, _serviceConfig);

            if (cachedGame != null)
                cachedGame.NotifyPostLeave();


            RemoveSummary(sessionID);
            RemoveDetail(sessionID);
            RemoveGameSession(sessionID);
            RemoveGame(sessionID);            
        }


        #region Cache Operations

        private void AddSummary(SessionEntry summary)
        {
            //Add/update our cache
            lock (_summariesCache)
            {
                bool isUpdate = _summariesCache.ContainsKey(summary.SessionID);
                _summariesCache[summary.SessionID] = summary;

                if (isUpdate)
                    _eventQueue.Enqueue(() => OnSummaryUpdated(summary));
                else
                    _eventQueue.Enqueue(() => OnSummaryAdded(summary));
            }            
        }

        private void AddDetail(SessionState detail)
        {
            //Add/update our cache
            lock (_detailsCache)
            {
                bool isUpdate = _detailsCache.ContainsKey(detail.SessionID);
                _detailsCache[detail.SessionID] = detail;

                //Queue up our events for the changes to the cache
                if (isUpdate)
                    _eventQueue.Enqueue(() => OnDetailUpdated(detail));
                else
                    _eventQueue.Enqueue(() => OnDetailAdded(detail));
            }
        }

        private void RemoveSummary(string sessionID)
        {
            SessionEntry cachedSummary;
            lock (_summariesCache)
            {
                _summariesCache.TryGetValue(sessionID, out cachedSummary);
                if (cachedSummary != null)
                {
                    _summariesCache.Remove(sessionID);
                    _eventQueue.Enqueue(() => OnSummaryRemoved(cachedSummary));
                }
            }
        }

        private void RemoveDetail(string sessionID)
        {
            SessionState cachedDetail;
            lock (_detailsCache)
            {
                _detailsCache.TryGetValue(sessionID, out cachedDetail);
                if (cachedDetail != null)
                {
                    _detailsCache.Remove(sessionID);
                    _eventQueue.Enqueue(() => OnDetailRemoved(cachedDetail));
                }
            }
        }

        private void RemoveGameSession(string sessionID)
        {
            GameSession cachedSession;
            lock (_fullSessionCache)
            { 
                _fullSessionCache.TryGetValue(sessionID, out cachedSession);
                if (cachedSession != null)
                {
                    _fullSessionCache.Remove(sessionID);
                    //_eventQueue.Enqueue(() => OnGameSessionRemoved(cachedSession));
                }
            }
        }

        private void RemoveGame(string sessionID)
        {
            IGame cachedGame;
            lock (_gameCache)
            {
                _gameCache.TryGetValue(sessionID, out cachedGame);
                if (cachedGame != null)
                {
                    _gameCache.Remove(sessionID);
                    _eventQueue.Enqueue(() => OnGameRemoved(cachedGame));
                }
            }
        }

        #endregion

        #endregion

        #region Event Firing
        private void OnSummaryAdded(SessionEntry summary)
        {
            _summaryAdded.Raise(this, new SessionSummaryEventArgs(summary));
        }

        private void OnSummaryUpdated(SessionEntry summary)
        {
            _summaryUpdated.Raise(this, new SessionSummaryEventArgs(summary));
        }

        private void OnSummaryRemoved(SessionEntry summary)
        {
            _summaryRemoved.Raise(this, new SessionSummaryEventArgs(summary));
        }

        private void OnDetailAdded(SessionState detail)
        {
            _detailAdded.Raise(this, new SessionDetailEventArgs(detail));
        }

        private void OnDetailUpdated(SessionState detail)
        {
            _detailUpdated.Raise(this, new SessionDetailEventArgs(detail));
        }

        private void OnDetailRemoved(SessionState detail)
        {
            _detailRemoved.Raise(this, new SessionDetailEventArgs(detail));
        }

        private void OnPlayRequested(IGame game)
        {
            _playRequested.Raise(this, new GameEventArgs(game));
        }
        private void OnGameAdded(IGame game)
        {
            _gameAdded.Raise(this, new GameEventArgs(game));
        }
        private void OnGameRemoved(IGame game)
        {
            _gameRemoved.Raise(this, new GameEventArgs(game));
        }
        #endregion
    }


    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardFramework\Configuration\ApplicationConfiguration.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml.Serialization;
using System.IO;

namespace OneCardFramework.Configuration
{
    /// <summary>
    /// Helper for storing application config data as a single XML file
    /// </summary>
    [Serializable]
    [XmlRoot("ApplicationConfiguration", IsNullable = false)]
    public class ApplicationConfiguration
    {
        public ServicesConfiguration[] ServiceConfigEntries;
        public UserConfiguration[] UserProfiles;

        public static ApplicationConfiguration LoadFromFile(string pathToFile)
        {
            XmlSerializer serializer = new XmlSerializer(typeof(ApplicationConfiguration));
            using(FileStream stream = File.OpenRead(pathToFile)){
                return (ApplicationConfiguration)serializer.Deserialize(stream);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardFramework\Cache\OperationQueue.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Diagnostics;

namespace OneCardFramework.Cache
{
    /// <summary>
    /// Provides the ability to queue actions that are consumed and executed
    /// in order on a background thread.
    /// </summary>
    public class OperationQueue : IDisposable
    {
        /// <summary>
        /// An identifier for the queue
        /// </summary>
        public string Name { get; private set; }

        private Queue<Action> _operationQueue;
        private AutoResetEvent _eventsAvailable;
        private IAsyncResult _consumerThread;
        private bool _isDisposed;

        /// <summary>
        /// Creates the queue and sets up a worker to automatically process
        /// queued actions on a background thread
        /// </summary>
        /// <param name="name">An optional identifier for this queue</param>
        public OperationQueue(string name)
        {
            Name = name;

            _operationQueue = new Queue<Action>();
            _eventsAvailable = new AutoResetEvent(false);
            _isDisposed = false;

            //Startup consumer thread
            Action consumer = new Action(QueueConsumer);
            _consumerThread = consumer.BeginInvoke(null, null);
        }

        /// <summary>
        /// Queues an action to be executed on a background thread
        /// </summary>
        /// <param name="action"></param>
        public void Enqueue(Action action)
        {
            if (_isDisposed)
                return;

            lock (_operationQueue)
            {
                _operationQueue.Enqueue(action);
                //Let Consumer thread know more data is available
                _eventsAvailable.Set();
            }
        }

        /// <summary>
        /// Fires all actions in the queue synchronously
        /// </summary>
        public void FirePendingActions()
        {
            lock (_operationQueue)
            {
                while (_operationQueue.Count > 0)
                {
                    Action action = _operationQueue.Dequeue();
                    action();
                }
            }
        }

        /// <summary>
        /// Helper for consuming actions from the queue and firing them off. 
        /// This should be run in a worker thread.
        /// </summary>
        private void QueueConsumer()
        {
            while (false == _isDisposed)
            {
                //Wait until data is available
                _eventsAvailable.WaitOne();

                FirePendingActions();
            }
        }

        /// <summary>
        /// Ceases all activity and disposes of the background worker
        /// </summary>
        public void Dispose()
        {
            _isDisposed = true;
            _eventsAvailable.Set();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardFramework\Cache\User.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using OneCardFramework.Extensions;
using OneCardFramework.Services;
using System.Diagnostics;
using OneCardFramework.Configuration;
using System.Threading;

namespace OneCardFramework.Cache
{
    /// <summary>
    /// Stores information about a user, including authentication credentials
    /// </summary>
    public class User
    {
        #region Events

        /// <summary>
        /// Fires when a change in authentication means this user has been signed in
        /// and can use our services
        /// </summary>
        public event EventHandler SignedIn;

        /// <summary>
        /// Fires when a change in authentication means this user has been signed out
        /// and can no longer use our services 
        /// </summary>
        public event EventHandler SignedOut;

        #endregion

        /// <summary>
        /// Gets the username of this user
        /// </summary>
        public string Username
        {
            get { return _username; }
        }
        private string _username;

        /// <summary>
        /// Gets the password of this user if stored, or null if it is not available
        /// </summary>
        public string Password
        {
            get { return _password; }
        }
        private string _password;


        /// <summary>
        /// Gets the current authentication ticket
        /// </summary>
        public TicketData Authentication
        {
            get
            {
                _authLock.EnterReadLock();
                try
                {
                    return _ticket;
                }
                finally
                {
                    _authLock.ExitReadLock();
                }
            }
        }
        private AuthenticationConfig _authConfig;
        private TicketData _ticket;
        private ReaderWriterLockSlim _authLock = new ReaderWriterLockSlim(LockRecursionPolicy.NoRecursion);
        
        /// <summary>
        /// Checks whether, at this moment, the user is considered logged in
        /// </summary>
        public bool IsLoggedIn
        { 
            get
            {
                TicketData ticket = Authentication;
                return ticket != null && ticket.IsExpired == false;
            }
        }



        internal User(string username, string password, AuthenticationConfig config)
        {
            _username = username;
            _password = password;
            _authConfig = config;

            SignIn();
        }


        /// <summary>
        /// Authenticates this user using the stored credentials
        /// </summary>
        public void SignIn()
        {
            //Grab the new ticket
            TicketData newTicket = AuthenticationService.Authenticate(_username, _password, _authConfig);

            //Validate the new ticket
            if (newTicket == null)
                throw new ApplicationException("Ticket provided by the authentication service was invalid");

            UpdateAuthentication(newTicket);
        }

        public void SignOut()
        {
            UpdateAuthentication(null);
        }


        private void UpdateAuthentication(TicketData newTicket)
        {
            TicketData curTicket;

            //Replace the ticket with the new one
            _authLock.EnterWriteLock();
            try
            {
                curTicket = _ticket;

                if (newTicket == curTicket)
                    throw new ArgumentException("Supplied ticket is the same as the existing one", "newTicket");
                if (curTicket != null && newTicket != null)
                    curTicket.VerifyValidReplacement(newTicket);

                AuthenticationService.Tracer.TraceInformation("Updating authentication ticket for user {0}", Username);

                _ticket = newTicket;
            }
            finally { _authLock.ExitWriteLock(); }


            //Fire events if necessary
            if (newTicket != null)
            {
                if((curTicket == null || curTicket.IsExpired) && !newTicket.IsExpired)
                    OnSignedIn();
            }
            else
            {
                if((newTicket == null) || (!curTicket.IsExpired && newTicket.IsExpired))
                    OnSignedOut();
            }
        }


        #region Event Raising
        private void OnSignedIn()
        {
            AuthenticationService.Tracer.TraceInformation("Signed in user {0}", Username);
            SignedIn.Raise(this, EventArgs.Empty);
        }

        private void OnSignedOut()
        {
            AuthenticationService.Tracer.TraceInformation("Signed out user {0}", Username);
            SignedOut.Raise(this, EventArgs.Empty);
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardFramework\Configuration\ServiceConfiguration.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml.Serialization;

namespace OneCardFramework.Configuration
{
    /// <summary>
    /// Contains configuration information for interacting with online services
    /// </summary>
    [Serializable]
    [XmlRoot("ServicesConfiguration", IsNullable = false)]
    public class ServicesConfiguration : ICloneable
    {
        /// <summary>
        /// The custom unique name for this configuration
        /// </summary>
        [XmlAttribute()]
        public string Name { get; set; }

        /// <summary>
        /// The environment this configuration targets
        /// </summary>
        [XmlAttribute()]
        public string Environment { get; set; }


        //Authentication Config
        public AuthenticationConfig AuthenticationConfiguration { get; set; }

        //Services config
        public MultiplayerServiceConfig MultiplayerServicesConfiguration { get; set; }


        public override string ToString()
        {
            return Name + " (" + Environment + ")";
        }


        #region ICloneable
        public virtual ServicesConfiguration Clone()
        {
            return (ServicesConfiguration)MemberwiseClone();
        }

        object ICloneable.Clone()
        {
            return this.Clone();
        }
        #endregion
    }

    [Serializable]
    public class AuthenticationConfig : ICloneable
    {
        //Note: Using const requires recompilation of all dependent libraries to
        //update their values, as the values are directly injected into code.
        //Static readonly retains usages as variables, permitting a recompile
        //of this library to automatically update all dependents.
        public static readonly string RPSTokenHeader = "Authorization"; //The header to use when injecting the RPS ticket into a request 
        public static readonly string RPSTokenPreamble = "WLID1.0 t=";
        public static readonly string UserTokenHeader = "X-Authorization"; //The header to use when injecting the UserToken into a request
        public static readonly string UserTokenPreamble = "XBL1.0 x=";
        public static readonly string PartnerTokenHeader = "X-PartnerAuthorization"; //The header to use when injecting the PartnerToken into a request
        public static readonly string PartnerTokenPreamble = "XBL1.0 x=";

        public string LiveID_DnsName { get; set; }
        public string LiveID_Policy { get; set; }
        public string LiveID_Env { get; set; }

        public uint TitleID { get; set; }
        public string TitleVersion { get; set; }
        public string ClientVersion { get; set; }
        public string PlatformID { get; set; }
        public string DeviceID { get; set; }
        public string CertThumbprint { get; set; }
        public string StsUrl { get; set; }
        public string AudienceUrl { get; set; }

        public TimeSpan TicketLifetime { get; set; }

        public AuthenticationConfig()
        {
            TicketLifetime = TimeSpan.FromHours(1);
        }

        #region ICloneable
        public virtual AuthenticationConfig Clone()
        {
            return (AuthenticationConfig)MemberwiseClone();
        }

        object ICloneable.Clone()
        {
            return this.Clone();
        }
        #endregion
    }

    /// <summary>
    /// Stores configuration data for the multiplayer services, such as the end-point URLs
    /// </summary>
    [Serializable]
    public class MultiplayerServiceConfig : ICloneable
    {
        public static readonly string LocaleHeader = "X-Locale";
        public static readonly string PlatformTypeHeader = "X-Platform-Type";

        public string SessionServiceUrl { get; set; }
        public string GameStateServiceUrl { get; set; }
        public string NotificationServiceUrl { get; set; }

        public string Locale { get; set; }
        public string PlatformType { get; set; }
        public string RequestContentType  { get; set; }

        public MultiplayerServiceConfig()
        {
            RequestContentType = "application/xml";
        }

        #region ICloneable
        public virtual MultiplayerServiceConfig Clone()
        {
            return (MultiplayerServiceConfig)MemberwiseClone();
        }

        object ICloneable.Clone()
        {
            return this.Clone();
        }
        #endregion
    }



    public class ServicesConfigurationEventArgs : EventArgs
    {
        public ServicesConfiguration Config { get; private set; }

        public ServicesConfigurationEventArgs(ServicesConfiguration config)
        {
            Config = config;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardFramework\Configuration\UserConfiguration.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml.Serialization;

namespace OneCardFramework.Configuration
{
    /// <summary>
    /// Contains basic configuration data for a user account
    /// </summary>
    [Serializable]
    [XmlRoot("UserConfiguration", IsNullable = false)]
    public class UserConfiguration
    {
        [XmlAttribute()]
        public string Username { get; set; }

        [XmlAttribute()]
        public string Password { get; set; }

        /// <summary>
        /// A comma-separated list of the environments the user is valid for
        /// </summary>
        [XmlAttribute()]
        public string Environments { get; set; }

        public override string ToString()
        {
            return Username;
        }
    }

    public class UserConfigurationEventArgs : EventArgs
    {
        public UserConfiguration Data { get; private set; }

        public UserConfigurationEventArgs(UserConfiguration data)
        {
            Data = data;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardFramework\Events\EventManager.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using OneCardFramework.Extensions;
using OneCardFramework.Events;

namespace OneCardFramework.Events
{
    /// <summary>
    /// Provides helper methods for eventing -- in particular, cleanup for weak event handlers
    /// </summary>
    public static class EventManager
    {
        /// <summary>
        /// Removes the first instance of the given event handler from the chain, making sure to examine
        /// the internals of weak handlers
        /// </summary>
        /// <param name="handlerChain">The delegate storing the invocation list. This will be replaced with an
        /// updated list</param>
        /// <param name="toRemove">The handler to remove</param>
        public static void Remove(ref EventHandler handlerChain, EventHandler toRemove)
        {
            if (toRemove == null)
                return;

            //If the handler we are removing is weak, we can just yank it out. If it's not,
            //we have to do extra checking because our chain might contain weak handlers
            //that wrap (and thus hide) the handler we want to remove.
            if (toRemove.Target is IWeakEventHandler)
            {
                handlerChain = (EventHandler)Delegate.Remove(handlerChain, toRemove);
            }
            else
            {
                Delegate[] allHandlers = handlerChain.GetInvocationList();

                foreach (EventHandler handler in allHandlers)
                {
                    //Check to see if the handler is actually the Invoke method of a weak event handler.
                    //If it is, we need to examine the weak wrapper to get the actual handler it points to,
                    //and see if that matches the item we are removing
                    IWeakEventHandler weakWrapper = handler.Target as IWeakEventHandler;

                    if (weakWrapper != null && weakWrapper.IsWrapper(toRemove))
                    {
                        //The wrapper's internals match the supplied delegate
                        handlerChain = (EventHandler)Delegate.Remove(handlerChain, toRemove);
                        break;
                    }
                    else if (handler == toRemove)
                    {
                        //A direct match
                        handlerChain = (EventHandler)Delegate.Remove(handlerChain, toRemove);
                        break;
                    }
                }
            }
        }

        /// <summary>
        /// Removes the first instance of the given event handler from the chain, making sure to examine
        /// the internals of weak handlers
        /// </summary>
        /// <param name="handlerChain">The delegate storing the invocation list. This will be replaced with an
        /// updated list</param>
        /// <param name="toRemove">The handler to remove</param>
        public static void Remove<TArgs>(ref EventHandler<TArgs> handlerChain, EventHandler<TArgs> toRemove)
            where TArgs : EventArgs
        {
            if (toRemove == null)
                return;

            //If the handler we are removing is weak, we can just yank it out. If it's not,
            //we have to do extra checking because our chain might contain weak handlers
            //that wrap (and thus hide) the handler we want to remove.
            if (toRemove.Target is IWeakEventHandler)
            {
                handlerChain = (EventHandler<TArgs>)Delegate.Remove(handlerChain, toRemove);
            }
            else
            {
                Delegate[] allHandlers = handlerChain.GetInvocationList();

                foreach (EventHandler<TArgs> handler in allHandlers)
                {
                    //Check to see if the handler is actually the Invoke method of a weak event handler.
                    //If it is, we need to examine the weak wrapper to get the actual handler it points to,
                    //and see if that matches the item we are removing
                    IWeakEventHandler<TArgs> weakWrapper = handler.Target as IWeakEventHandler<TArgs>;

                    if (weakWrapper != null && weakWrapper.IsWrapper(toRemove))
                    {
                        //The wrapper's internals match the supplied delegate
                        handlerChain = (EventHandler<TArgs>)Delegate.Remove(handlerChain, toRemove);
                        break;
                    }
                    else if (handler == toRemove)
                    {
                        //A direct match
                        handlerChain = (EventHandler<TArgs>)Delegate.Remove(handlerChain, toRemove);
                        break;
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardFramework\Extensions\StateExtensions.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using AsyncMultiplayer.SessionCommon;

namespace OneCardFramework.Extensions
{
    public static class StateExtensions
    {
        public static bool IsMyTurn(this SessionState state)
        {
            return state.ActorSeat.Value == state.State.ActiveSeatIndex;
        }

        public static bool IsOwner(this SessionState state)
        {
            return state.ActorSeat.Value == state.OwnerSeatIndex;
        }

        public static int GetPlayerCount(this SessionState state)
        {
            return state.Seats.Length;
        }


        /// <summary>
        /// Gets the SeatInfo for the given player index from the current session state
        /// </summary>
        /// <param name="state"></param>
        /// <param name="index"></param>
        /// <returns></returns>
        public static SeatInfo GetSeatFromIndex(this SessionState state, int index)
        {
            return Array.Find(state.Seats, (SeatInfo seat) => seat.Index == index);
        }

        /// <summary>
        /// Retrieves a unique identifier for the given player seat
        /// </summary>
        /// <param name="state"></param>
        /// <param name="playerSeatIndex"></param>
        /// <returns></returns>
        public static string GetUid(this SessionState state, int playerSeatIndex)
        {
            SeatInfo mySeat = state.Seats.First((SeatInfo s) => s.Index == playerSeatIndex);
            return mySeat.Profile.PublicToken;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardFramework\Extensions\EventExtensions.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Linq.Expressions;
using System.ComponentModel;
using OneCardFramework.Events;
using System.Reflection;

namespace OneCardFramework.Extensions
{
    public static class EventExtensions
    {
        /// <summary>
        /// Raises an event after checking for subscribers
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="handler"></param>
        /// <param name="sender"></param>
        /// <param name="args"></param>
        public static void Raise(this EventHandler handler, object sender, EventArgs args)
        {
            if (handler != null)
            {
                handler(sender, args);
            }
        }

        /// <summary>
        /// Raises an event after checking for subscribers
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="handler"></param>
        /// <param name="sender"></param>
        /// <param name="args"></param>
        public static void Raise<T>(this EventHandler<T> handler, object sender, T args) where T : EventArgs
        {
            if (handler != null)
            {
                handler(sender, args);
            }
        }


        /// <summary>
        /// Generates a weak-reference version of an event handler. If the handler is already weak,
        /// this will just return a reference to that same weak handler.
        /// </summary>
        /// <typeparam name="TArgs"></typeparam>
        /// <param name="handler"></param>
        /// <param name="unregister">A callback function used to unregister the weak handler
        /// from the subscription service when the object that created the handler is GC'd</param>
        /// <returns>An EventHandler referring to the created WeakEventHandler internals</returns>
        public static EventHandler<TArgs> MakeWeak<TArgs>(this EventHandler<TArgs> handler, 
            UnregisterCallback<TArgs> unregister)
            where TArgs : EventArgs
        {
            //If we've already got a weak handler, just use it
            if (handler.Method.DeclaringType.IsGenericType &&
                handler.Method.DeclaringType.GetGenericTypeDefinition() == typeof(WeakEventHandler<,>))
                return handler;

            Type weakHandlerType = typeof(WeakEventHandler<,>).MakeGenericType(handler.Method.DeclaringType, typeof(TArgs));
            IWeakEventHandler<TArgs> weh = (IWeakEventHandler<TArgs>)Activator.CreateInstance(weakHandlerType, handler, unregister);
            return weh.AsEventHandler();
        }

        /// <summary>
        /// Generates a weak-reference version of an event handler
        /// </summary>
        /// <param name="handler"></param>
        /// <param name="unregister">A callback function used to unregister the weak handler
        /// from the subscription service when the object that created the handler is GC'd</param>
        /// <returns>An EventHandler referring to the created WeakEventHandler internals</returns>
        public static EventHandler MakeWeak(this EventHandler handler,
            UnregisterCallback unregister)
        {
            //If we've already got a weak handler, just use it
            if (handler.Method.DeclaringType.IsGenericType &&
                handler.Method.DeclaringType.GetGenericTypeDefinition() == typeof(WeakEventHandler<>))
                return handler;

            Type weakHandlerType = typeof(WeakEventHandler<>).MakeGenericType(handler.Method.DeclaringType); 
            IWeakEventHandler weh = (IWeakEventHandler)Activator.CreateInstance(weakHandlerType, handler, unregister);
            return weh.AsEventHandler();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardFramework\Events\IWeakEventHandler.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace OneCardFramework.Events
{
    public delegate void UnregisterCallback(EventHandler handler);
    public delegate void UnregisterCallback<TArgs>(EventHandler<TArgs> handler) where TArgs : EventArgs;

    internal interface IWeakEventHandler
    {
        /// <summary>
        /// Attempts to invoke the handler on the weakly referenced object.
        /// If the object has been GC'd, we will attempt to unsubscribe from the event.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="args"></param>
        void Invoke(object sender, EventArgs args);

        /// <summary>
        /// Checks whether this weak event handler is a wrapper around
        /// the supplied handler.
        /// </summary>
        /// <param name="handler"></param>
        /// <returns>True if we are wrapping the supplied handler. False otherwise.</returns>
        bool IsWrapper(EventHandler handler);

        /// <summary>
        /// The internal handler (Invoke)
        /// </summary>
        EventHandler AsEventHandler();
    }

    internal interface IWeakEventHandler<TArgs>
        where TArgs : EventArgs
    {
        /// <summary>
        /// Attempts to invoke the handler on the weakly referenced object.
        /// If the object has been GC'd, we will attempt to unsubscribe from the event.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="args"></param>
        void Invoke(object sender, TArgs args);

        /// <summary>
        /// Checks whether this weak event handler is a wrapper around
        /// the supplied handler.
        /// </summary>
        /// <param name="handler"></param>
        /// <returns>True if we are wrapping the supplied handler. False otherwise.</returns>
        bool IsWrapper(EventHandler<TArgs> handler);

        /// <summary>
        /// The internal handler (Invoke)
        /// </summary>
        EventHandler<TArgs> AsEventHandler();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardFramework\Events\WeakEventHandler.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Linq.Expressions;
using System.Diagnostics;
using OneCardFramework.Extensions;

namespace OneCardFramework.Events
{
    /// <summary>
    /// Provides the ability to subscribe to events with a weak reference, permitting loose
    /// coupling between subscriber and subscription service.
    /// <remarks>Designed by Dustin Campbell, http://diditwith.net, Creative Commons Attribution 3.0 United States</remarks>
    /// </summary>
    /// <example>
    /// someEvent += new EventHandler(handler).MakeWeak(h => someEvent -= h);
    /// </example>
    /// <typeparam name="TSubscriber">The type of object making the subscription</typeparam>
    public class WeakEventHandler<TSubscriber> : IWeakEventHandler
        where TSubscriber : class
    {
        private delegate void OpenEventHandler(TSubscriber targetObj, object sender, EventArgs args);

        private WeakReference _targetReference;
        private EventHandler _eventHandler;
        private OpenEventHandler _method;
        private UnregisterCallback _unregister;

        public WeakEventHandler(EventHandler eventHandler, UnregisterCallback unregister)
        {
            //Handle case where eventHandler is already weak
            if (eventHandler.Method.DeclaringType.IsGenericType &&
                eventHandler.Method.DeclaringType.GetGenericTypeDefinition() == typeof(WeakEventHandler<>))
                throw new ArgumentException("Event handler is already weak", "eventHandler");

            //Handle case where eventHandler is anonymous (it might not be tied to an object instance, which means it will get collected right away)
            if (eventHandler.Method.DeclaringType.IsAnonymous())
                Trace.TraceWarning("Generating a WeakEventHandler to wrap a possibly anonymous method");


            //Maintain a weak reference to the object we are subscribing to
            _targetReference = new WeakReference(eventHandler.Target);

            //Create an open delegate that we can plug our reference into later
            _method = (OpenEventHandler)Delegate.CreateDelegate(typeof(OpenEventHandler), null, eventHandler.Method);
            _eventHandler = Invoke;
            _unregister = unregister;
        }

        public void Invoke(object sender, EventArgs args)
        {
            TSubscriber target = (TSubscriber)_targetReference.Target;

            if (target != null)
            {
                //Subscriber object still exists. Call the open delegate,
                //passing in the instance we are calling it on
                _method(target, sender, args);
            }
            else if (_unregister != null)
            {
                //Subscriber has been garbage collected. Unhook this event handler.
                _unregister(_eventHandler);
                _unregister = null;
            }
        }

        /// <summary>
        /// Checks whether this weak event handler is a wrapper around
        /// the supplied handler.
        /// </summary>
        /// <param name="handler"></param>
        /// <returns>True if we are wrapping the supplied handler. False otherwise.</returns>
        public bool IsWrapper(EventHandler handler)
        {
            //We are wrapping if the referenced objects and methods match
            if (_method.Method == handler.Method)
            {
                TSubscriber target = (TSubscriber)_targetReference.Target;

                return (target != null) && target == handler.Target;
            }
            return false;
        }

        public EventHandler AsEventHandler()
        {
            //Return our wrapper method, Invoke
            return _eventHandler;
        }

        public static implicit operator EventHandler(WeakEventHandler<TSubscriber> weakHandler)
        {
            //Return our wrapper method, Invoke
            return weakHandler.AsEventHandler();
        }
    }


    /// <summary>
    /// Provides the ability to subscribe to events with a weak reference, permitting loose
    /// coupling between subscriber and subscription service.
    /// <remarks>Designed by Dustin Campbell, http://diditwith.net, Creative Commons Attribution 3.0 United States</remarks>
    /// </summary>
    /// <example>
    /// someEvent += new EventHandler(handler).MakeWeak(h => someEvent -= h);
    /// </example>
    /// <typeparam name="TSubscriber">The type of object making the subscription</typeparam>
    /// <typeparam name="TArgs">The type of EventArgs to use</typeparam>
    public class WeakEventHandler<TSubscriber, TArgs> : IWeakEventHandler<TArgs>
        where TSubscriber : class
        where TArgs : EventArgs
    {
        private delegate void OpenEventHandler(TSubscriber targetObj, object sender, TArgs args);

        private WeakReference _targetReference;
        private EventHandler<TArgs> _eventHandler;
        private OpenEventHandler _method;
        private UnregisterCallback<TArgs> _unregister;

        public WeakEventHandler(EventHandler<TArgs> eventHandler, UnregisterCallback<TArgs> unregister)
        {
            //Handle case where eventHandler is already weak
            if (eventHandler.Method.DeclaringType.IsGenericType &&
                eventHandler.Method.DeclaringType.GetGenericTypeDefinition() == typeof(WeakEventHandler<,>))
                throw new ArgumentException("Event handler is already weak", "eventHandler");

            //Handle case where eventHandler is anonymous (it might not be tied to an object instance, which means it will get collected right away)
            if (eventHandler.Method.DeclaringType.IsAnonymous())
                Trace.TraceWarning("Generating a WeakEventHandler to wrap a possibly anonymous method");

            _targetReference = new WeakReference(eventHandler.Target);
            _method = (OpenEventHandler)Delegate.CreateDelegate(typeof(OpenEventHandler), null, eventHandler.Method);
            _eventHandler = Invoke;
            _unregister = unregister;
        }

        public void Invoke(object sender, TArgs args)
        {
            TSubscriber target = (TSubscriber)_targetReference.Target;

            if (target != null)
            {
                //Subscriber object still exists. Call its handler.
                _method(target, sender, args);
            }
            else if (_unregister != null)
            {
                //Subscriber has been garbage collected. Unhook this event handler.
                _unregister(_eventHandler);
                _unregister = null;
            }
        }

        /// <summary>
        /// Checks whether this weak event handler is a wrapper around
        /// the supplied handler.
        /// </summary>
        /// <param name="handler"></param>
        /// <returns>True if we are wrapping the supplied handler. False otherwise.</returns>
        public bool IsWrapper(EventHandler<TArgs> handler)
        {
            //We are wrapping if the referenced objects and methods match
            if (_method.Method == handler.Method)
            {
                TSubscriber target = (TSubscriber)_targetReference.Target;

                return (target != null) && target == handler.Target;
            }
            return false;
        }

        public EventHandler<TArgs> AsEventHandler()
        {
            //Return our wrapper method, Invoke
            return _eventHandler;
        }

        public static implicit operator EventHandler<TArgs>(WeakEventHandler<TSubscriber, TArgs> weakHandler)
        {
            //Return our wrapper method, Invoke
            return weakHandler.AsEventHandler();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardFramework\Extensions\TypeExtensions.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Runtime.CompilerServices;

namespace OneCardFramework.Extensions
{
    public static class TypeExtensions
    {
        /// <summary>
        /// Attempts to determine whether a type is anonymous. Not guaranteed to work, as
        /// there is no formal specification for any unique features
        /// </summary>
        /// <param name="type"></param>
        /// <returns>True if the type is probably anonymous. False otherwise.</returns>
        public static bool IsAnonymous(this Type type)
        {
            return (type.IsSealed &&
                    type.IsNested &&
                    (type.Name.Contains("AnonymousType") || type.Name.Contains("DisplayClass")) && 
                    type.GetCustomAttributes(typeof(CompilerGeneratedAttribute), false).Length != 0);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardFramework\Game\IGame.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace OneCardFramework.Game
{
    public interface IGame
    {
        void NotifyPreLeave();
        void NotifyPostLeave();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardFramework\Extensions\WebExtensions.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Net;
using System.Xml;
using System.Runtime.Serialization;

namespace OneCardFramework.Extensions
{
    public static class WebExtensions
    {
        /// <summary>
        /// Writes the given data into the request's data stream and closes it
        /// </summary>
        /// <param name="request"></param>
        /// <param name="data"></param>
        public static void WriteAllData(this WebRequest request, byte[] data)
        {
            using (Stream stream = request.GetRequestStream())
            {
                stream.Write(data, 0, data.Length);
                stream.Close();
            }
        }

        /// <summary>
        /// Reads the data out of the response stream as a string and closes the stream.
        /// </summary>
        /// <param name="response"></param>
        /// <returns>The string representation of the stream data</returns>
        public static string ReadAllData(this WebResponse response, Encoding encoding)
        {
            string responseData;

            using (StreamReader reader = new StreamReader(response.GetResponseStream(), encoding))
            {
                responseData = reader.ReadToEnd();
            }

            return responseData;
        }

        /// <summary>
        /// Reads the data out of the response stream as a data contract object and closes the stream
        /// </summary>
        /// <typeparam name="T">The type of object we are attempting to generate from the stream</typeparam>
        /// <param name="response">The server response whose stream contains the serialized object</param>
        /// <returns>The deserialized object</returns>
        public static T ReadAsDataContract<T>(this WebResponse response)
        {
            return (T)ReadAsDataContract(response, typeof(T));
        }

        /// <summary>
        /// Reads the data out of the response stream as a data contract object and closes the stream
        /// </summary>
        /// <param name="response">The server response whose stream contains the serialized object</param>
        /// <param name="contractType">The type of object we are attempting to generate from the stream</param>
        /// <returns>The deserialized object</returns>
        public static object ReadAsDataContract(this WebResponse response, Type contractType)
        {
            object output;

            using (Stream stream = response.GetResponseStream())
            {
                DataContractSerializer serializer = new DataContractSerializer(contractType);
                output = serializer.ReadObject(stream);
            }

            return output;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardFramework\Game\IndexChangedEventArgs.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace OneCardFramework.Game
{
    /// <summary>
    /// Represents a change in a player's seat index
    /// </summary>
    public class IndexChangedEventArgs : EventArgs
    {
        public int OldIndex { get; private set; }
        public int NewIndex { get; private set; }

        public IndexChangedEventArgs(int oldIndex, int newIndex)
        {
            OldIndex = oldIndex;
            NewIndex = newIndex;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardFramework\Game\GameConfig.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using AsyncMultiplayer.SessionCommon;

namespace OneCardFramework.Game
{
    /// <summary>
    /// Provides an extensible point of contact for configuring game creation
    /// </summary>
    public class GameConfig
    {
        public string DisplayName { get; set; }

        public int Variant { get; set; }

        public bool CanRemoveEmptySeats { get; set; }
        public int TotalSeatsAvailable { get; set; }
        public int ReservedSeatsAvailable { get; set; }

        public InactivityWarningBehavior InactivityWarning { get; set; }

        public GameConfig()
        {
            InactivityWarning = new InactivityWarningBehavior();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardFramework\Game\SeatChangedEventArgs.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using AsyncMultiplayer.SessionCommon;

namespace OneCardFramework.Game
{
    /// <summary>
    /// Represents a change in the seat object associated with a certain seat index
    /// </summary>
    public class SeatChangedEventArgs : EventArgs
    {
        public SeatInfo OldSeat { get; private set; }
        public SeatInfo NewSeat { get; private set; }

        public SeatChangedEventArgs(SeatInfo oldSeat, SeatInfo newSeat)
        {
            OldSeat = oldSeat;
            NewSeat = newSeat;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardFramework\Game\SeatEventArgs.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using AsyncMultiplayer.SessionCommon;

namespace OneCardFramework.Game
{
    public class SeatEventArgs : EventArgs
    {
        public SeatInfo Seat { get; private set; }
        public SeatEventArgs(SeatInfo seat)
        {
            Seat = seat;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardFramework\Game\GameSession.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using AsyncMultiplayer.SessionCommon;
using AsyncMultiplayer.NotificationService;
using System.ComponentModel;
using System.Diagnostics;
using OneCardFramework.Services;
using OneCardFramework.Configuration;
using OneCardFramework.Extensions;
using OneCardFramework.Events;
using OneCardFramework.Cache;

namespace OneCardFramework.Game
{
    /// <summary>
    /// Represents an online game session. Provides rich state information, eventing for state changes, and methods 
    /// for getting/setting game data.
    /// </summary>
    public sealed class GameSession
    {
        #region Public Interface

        #region Properties

        /// <summary>
        /// Gets the current session state. This object should NOT be modified (doing so may cause undocumented behavior for GameSession).
        /// </summary>
        public SessionState SessionState
        {
            get
            {
                _stateLock.EnterReadLock();
                try
                {
                    return _sessionState;
                }
                finally { _stateLock.ExitReadLock(); }
            }
        }
        private volatile SessionState _sessionState;

        /// <summary>
        /// Gets the current game data.
        /// </summary>
        public byte[] GameState
        {
            get
            {
                _stateLock.EnterReadLock();
                try
                {
                    return _gameState;
                }
                finally { _stateLock.ExitReadLock(); }
            }
        }
        private volatile byte[] _gameState;

        /// <summary>
        /// Gets whether it is currently our turn, as determined by ActorSeat and ActiveSeatIndex
        /// </summary>
        public bool IsMyTurn
        {
            get;
            private set;
        }

        /// <summary>
        /// Gets whether we are the owner of the session, as determined by ActorSeat and OwnerIndex
        /// </summary>
        public bool IsOwner
        {
            get;
            private set;
        }

        /// <summary>
        /// Gets whether the game is over, as determined by IsCompleted
        /// </summary>
        public bool IsGameOver
        {
            get;
            private set;
        }

        /// <summary>
        /// Gets our seat index, as determined by ActorSeat
        /// </summary>
        public int MySeatIndex
        {
            get;
            private set;
        }

        public string MyUid
        {
            get;
            private set;
        }

        public int ActiveSeatIndex
        {
            get;
            private set;
        }

        public int OwnerSeatIndex
        {
            get;
            private set;
        }

        public int PlayerCount
        {
            get;
            private set;
        }

        public string SessionID
        {
            get;
            private set;
        }
        #endregion

        #region Events
        /// <summary>
        /// Fired when the session is updated with new data from the server
        /// </summary>
        public event EventHandler<SessionUpdatedEventArgs> Updated
        {
            //Use weak events
            add { _updated += value.MakeWeak(n => _updated -= n); }
            remove { EventManager.Remove(ref _updated, value); }
        }
        private EventHandler<SessionUpdatedEventArgs> _updated;

        /// <summary>
        /// Fired when a player leaves the session
        /// </summary>
        public event EventHandler<SeatEventArgs> PlayerLeft
        {
            //Use weak events
            add { _playerLeft += value.MakeWeak(n => _playerLeft -= n); }
            remove { EventManager.Remove(ref _playerLeft, value); }
        }
        private EventHandler<SeatEventArgs> _playerLeft;

        /// <summary>
        /// Fired when a player enters the session
        /// </summary>
        public event EventHandler<SeatEventArgs> PlayerJoined
        {
            //Use weak events
            add { _playerJoined += value.MakeWeak(n => _playerJoined -= n); }
            remove { EventManager.Remove(ref _playerJoined, value); }
        }
        private EventHandler<SeatEventArgs> _playerJoined;

        /// <summary>
        /// Fired when a change in the Owner seat index is detected
        /// </summary>
        public event EventHandler<IndexChangedEventArgs> OwnerIndexChanged
        {
            //Use weak events
            add { _ownerIndexChanged += value.MakeWeak(n => _ownerIndexChanged -= n); }
            remove { EventManager.Remove(ref _ownerIndexChanged, value); }
        }
        private EventHandler<IndexChangedEventArgs> _ownerIndexChanged;

        /// <summary>
        /// Fired when the actual seat considered the Owner changes
        /// </summary>
        public event EventHandler<SeatChangedEventArgs> OwnerSeatChanged
        {
            //Use weak events
            add { _ownerSeatChanged += value.MakeWeak(n => _ownerSeatChanged -= n); }
            remove { EventManager.Remove(ref _ownerSeatChanged, value); }
        }
        private EventHandler<SeatChangedEventArgs> _ownerSeatChanged;

        /// <summary>
        /// Fires when a change in the Active seat index is detected
        /// </summary>
        public event EventHandler<IndexChangedEventArgs> ActiveIndexChanged
        {
            //Use weak events
            add { _activeIndexChanged += value.MakeWeak(n => _activeIndexChanged -= n); }
            remove { EventManager.Remove(ref _activeIndexChanged, value); }
        }
        private EventHandler<IndexChangedEventArgs> _activeIndexChanged;

        /// <summary>
        /// Fired when the actual seat considered Active changes
        /// </summary>
        public event EventHandler<SeatChangedEventArgs> ActiveSeatChanged
        {
            //Use weak events
            add { _activeSeatChanged += value.MakeWeak(n => _activeSeatChanged -= n); }
            remove { EventManager.Remove(ref _activeSeatChanged, value); }
        }
        private EventHandler<SeatChangedEventArgs> _activeSeatChanged;

        /// <summary>
        /// Fired when a change in session state signals that the game has ended
        /// </summary>
        public event EventHandler GameEnded
        {
            //Use weak events
            add { _gameEnded += value.MakeWeak(n => _gameEnded -= n); }
            remove { EventManager.Remove(ref _gameEnded, value); }
        }
        private EventHandler _gameEnded;
        #endregion

        #endregion


        private User _user;
        private MultiplayerServiceConfig _serviceConfig;

        private readonly ReaderWriterLockSlim _stateLock = new ReaderWriterLockSlim(LockRecursionPolicy.NoRecursion);//NoRecursion until we find a need
        private Queue<Action> _pendingEvents = new Queue<Action>();
        private volatile bool _isLoading = false;

        #region Construction and Initialization

        /// <summary>
        /// Constructs a game session using the supplied initial state. This will NOT perform any service operations
        /// such as Create or Join. Generally, you should use the static factory methods to ensure proper behavior.
        /// </summary>
        /// <param name="user">The user the session is tied to</param>
        /// <param name="config"></param>
        /// <param name="initialSessionState">The initial session state. Cannot be null.</param>
        /// <param name="initialGameState">The initial game state blog. Can be null.</param>
        public GameSession(User user, MultiplayerServiceConfig config, SessionState initialSessionState, byte[] initialGameState)
        {
            if (user == null)
                throw new ArgumentNullException("user");
            if (config == null)
                throw new ArgumentNullException("config");
            if (initialSessionState == null)
                throw new ArgumentNullException("initialSessionState");

            this._user = user;
            this._serviceConfig = config;

            UpdateStateCache(initialSessionState, initialGameState);
        }


        /// <summary>
        /// Creates a new game session on the server and constructs a local GameSession instance to mirror it.
        /// Involves calling CreateSession and GetGameState.
        /// </summary>
        /// <param name="user">The user the session is tied to</param>
        /// <param name="config">The configuration to use for service operations</param>
        /// <param name="cd">The initial settings for creating the session</param>
        /// <returns>A new GameSession instance</returns>
        public static GameSession Create(User user, MultiplayerServiceConfig config, CreationData cd)
        {
            SessionState sessionState = SessionService.CreateSession(cd, user.Authentication, config);
            FullGameState gameState = GameStateService.GetGameState(sessionState.SessionID, user.Authentication, config);
            sessionState.State = gameState.GameStateInfo;

            return new GameSession(user, config, sessionState, gameState.GameData);
        }

        /// <summary>
        /// Joins an existing game session on the server and constructs a local GameSession instance to mirror it.
        /// Involves calling JoinSession and GetGameState.
        /// </summary>
        /// <param name="user">The user the session is tied to</param>
        /// <param name="config">The configuration to use for service operations</param>
        /// <param name="jd">The settings for joining the session</param>
        /// <returns>A new GameSession instance</returns>
        public static GameSession Join(User user, MultiplayerServiceConfig config, JoinData jd)
        {
            SessionState sessionState = SessionService.JoinSession(jd, user.Authentication, config);
            FullGameState gameState = GameStateService.GetGameState(sessionState.SessionID, user.Authentication, config);
            sessionState.State = gameState.GameStateInfo;

            return new GameSession(user, config, sessionState, gameState.GameData);
        }

        /// <summary>
        /// Loads the data from a game session existing on the server and constructs a local GameSession instance to mirror it.
        /// Involves calling ViewSession and GetGameState.
        /// </summary>
        /// <param name="user">The user the session is tied to</param>
        /// <param name="config">The configuration to use for service operations</param>
        /// <param name="sessionID">The ID of the session to load</param>
        /// <returns>A new GameSession instance</returns>
        public static GameSession Load(User user, MultiplayerServiceConfig config, string sessionID)
        {
            SessionState sessionState = SessionService.ViewSession(sessionID, user.Authentication, config);
            FullGameState gameState = GameStateService.GetGameState(sessionState.SessionID, user.Authentication, config);
            sessionState.State = gameState.GameStateInfo;

            return new GameSession(user, config, sessionState, gameState.GameData);           
        }

        #endregion
        


        /// <summary>
        /// Polls the server for new state and fires off events as necessary. SessionState and GameState will be replaced
        /// with references to new data.
        /// </summary>       
        public void Update()
        {
            if (_isLoading)
                return;

            _stateLock.EnterWriteLock();
            try
            {
                _isLoading = true;
                //Acquire new state data
                SessionState onlineSessionState = SessionService.ViewSession(_sessionState.SessionID, _user.Authentication, _serviceConfig);
                FullGameState onlineGameState = GameStateService.GetGameState(_sessionState.SessionID, _user.Authentication, _serviceConfig);
                //Copy the newer GameState data over to SessionState
                onlineSessionState.State = onlineGameState.GameStateInfo;

                SessionState lastSessionState = _sessionState;
                SessionState currentSessionState = onlineSessionState;
                byte[] currentGameState = onlineGameState.GameData;

                //Validate session data
                VerifySessionConsistency(lastSessionState, currentSessionState);

                //Update our state cache
                UpdateStateCache(currentSessionState, currentGameState);

                //Queue up any necessary events
                HandleStateChanges(lastSessionState, currentSessionState, currentGameState);                
            }
            finally
            {
                _stateLock.ExitWriteLock();
                _isLoading = false;
            }

            //We queue events so that they propagate in the correct order regardless
            //of threaded calls to Update
            lock (_pendingEvents)
            {
                while (_pendingEvents.Count > 0)
                    _pendingEvents.Dequeue()();
            }
        }


        private static void VerifySessionConsistency(SessionState oldState, SessionState newState)
        {
            Debug.Assert(oldState.ActorSeat.Value == newState.ActorSeat.Value, "My seat index should not change");
            Debug.Assert(oldState.GameID == newState.GameID, "GameID should not change");
            Debug.Assert(oldState.SessionID == newState.SessionID, "SessionID should not change");
            Debug.Assert(oldState.Variant == newState.Variant, "Variant should not change");

            string oldUid = oldState.GetUid(oldState.ActorSeat.Value);
            string newUid = newState.GetUid(newState.ActorSeat.Value);
            Debug.Assert(oldUid == newUid, "My UID should not change");
        }

        private void UpdateStateCache(SessionState newSessionState, byte[] newGameState)
        {
            _sessionState = newSessionState;
            _gameState = newGameState;

            SessionID = newSessionState.SessionID;
            MySeatIndex = newSessionState.ActorSeat.Value;
            ActiveSeatIndex = newSessionState.State.ActiveSeatIndex;
            OwnerSeatIndex = newSessionState.OwnerSeatIndex;

            IsMyTurn = MySeatIndex == ActiveSeatIndex;
            IsOwner = MySeatIndex == OwnerSeatIndex;
            IsGameOver = newSessionState.State.IsComplete;
            MyUid = newSessionState.GetUid(MySeatIndex);
            PlayerCount = newSessionState.GetPlayerCount();
        }

        private void HandleStateChanges(SessionState oldState, SessionState newState, byte[] newGameState)
        {
            //----------------------------------------------------------------------------
            //Check for changes in session state, such as players leaving and joining, and queue
            //up their respective events
            SeatInfo[] oldSeats = oldState.Seats;
            SeatInfo[] curSeats = newState.Seats;

            SeatIdentityComparer comparer = SeatIdentityComparer.Instance;
            IEnumerable<SeatInfo> left = (from s in oldSeats where !curSeats.Contains(s, comparer) select s);
            IEnumerable<SeatInfo> joined = (from s in curSeats where !oldSeats.Contains(s, comparer) select s);

            int oldActiveIndex = oldState.State.ActiveSeatIndex;
            int newActiveIndex = newState.State.ActiveSeatIndex;
            SeatInfo oldActiveSeat = oldState.GetSeatFromIndex(oldActiveIndex);
            SeatInfo newActiveSeat = newState.GetSeatFromIndex(newActiveIndex);

            int oldOwnerIndex = oldState.OwnerSeatIndex;
            int newOwnerIndex = newState.OwnerSeatIndex;
            SeatInfo oldOwnerSeat = oldState.GetSeatFromIndex(oldOwnerIndex);
            SeatInfo newOwnerSeat = newState.GetSeatFromIndex(newOwnerIndex);

            bool justClosed = !oldState.IsClosed && newState.IsClosed;
            bool justCompleted = !oldState.State.IsComplete && newState.State.IsComplete;

            string sessionID = SessionID;
            lock (_pendingEvents)
            {
                //Fire event for session data being updated
                _pendingEvents.Enqueue(delegate()
                {
                    Trace.TraceInformation("Session updated - {0}", sessionID);
                    OnUpdated(newState, newGameState);
                });

                //Fire event for each player who left
                foreach (SeatInfo seat in left)
                {
                    _pendingEvents.Enqueue(delegate()
                    {
                        Trace.TraceInformation("Player '{0}' left session {1}", seat.DisplayName, sessionID);
                        OnPlayerLeft(seat);
                    });
                }

                //Fire event for each player who joined
                foreach (SeatInfo seat in joined)
                {
                    _pendingEvents.Enqueue(delegate()
                    {
                        Trace.TraceInformation("Player '{0}' joined session {1}", seat.DisplayName, sessionID);
                        OnPlayerJoined(seat);
                    });
                }

                //Fire event for change in owner seat index
                if (newOwnerIndex != oldOwnerIndex)
                {
                    _pendingEvents.Enqueue(delegate()
                    {
                        Trace.TraceInformation("Session owner index changed from {0} to {1} for session {2}",
                            oldOwnerIndex,
                            newOwnerIndex,
                            sessionID);
                        OnOwnerIndexChanged(oldOwnerIndex, newOwnerIndex);
                    });
                }

                //Fire event for change in owner seat data
                if (comparer.Equals(newOwnerSeat, oldOwnerSeat) == false)
                {
                    _pendingEvents.Enqueue(delegate()
                    {
                        Trace.TraceInformation("Session owner seat changed from {0} to {1} for session {2}", 
                            (oldOwnerSeat == null) ? null : oldOwnerSeat.DisplayName, 
                            (newOwnerSeat == null) ? null : newOwnerSeat.DisplayName,
                            sessionID);
                        OnOwnerSeatChanged(oldOwnerSeat, newOwnerSeat);
                    });
                }

                //Fire event for change in active seat index
                if (newActiveIndex != oldActiveIndex)
                {
                    _pendingEvents.Enqueue(delegate()
                    {
                        Trace.TraceInformation("Active seat index changed from {0} to {1} for session {2}", 
                            oldActiveIndex, 
                            newActiveIndex,
                            sessionID);
                        OnActiveIndexChanged(oldActiveIndex, newActiveIndex);
                    });
                }

                //Fire event for change in active seat data
                if (comparer.Equals(oldActiveSeat, newActiveSeat) == false)
                {
                    _pendingEvents.Enqueue(delegate()
                    {
                        Trace.TraceInformation("Active seat changed from {0} to {1} for session {2}", 
                            (oldActiveSeat == null) ? null : oldActiveSeat.DisplayName, 
                            (newActiveSeat == null) ? null : newActiveSeat.DisplayName,
                            sessionID);
                        OnActiveSeatChanged(oldActiveSeat, newActiveSeat);
                    });
                }

                //Fire event for the game ending
                if (justCompleted)
                {
                    _pendingEvents.Enqueue(delegate()
                    {
                        Trace.TraceInformation("Game Ended for session {0}", sessionID);
                        OnGameEnded();
                    });
                }
            }
        }





        /// <summary>
        /// Saves the current state of the game to the server. This operation is
        /// only valid when it is our turn.
        /// </summary>
        public void CommitGameState(byte[] gameState)
        {            
            ModifiableGameState state = new ModifiableGameState();
            state.ActiveSeatIndex = SessionState.State.ActiveSeatIndex;
            state.GameData = gameState;

            _stateLock.EnterReadLock();
            try
            {
                Debug.Assert(IsMyTurn, "It is not our turn");
                Debug.Assert(!IsGameOver, "The game is completed");
                Debug.Assert(_user.IsLoggedIn, "The user is not logged in");

                //Set state on server
                GameStateService.PutGameState(_sessionState.SessionID, state, _user.Authentication, _serviceConfig);
            }
            finally { _stateLock.ExitReadLock(); }

            //Retrieve new state
            Update();
        }

        /// <summary>
        /// Ends the current turn, passing control to another player. This operation is
        /// only valid when it is our turn.
        /// </summary>
        /// <param name="nextPlayerIndex"></param>
        public void EndTurn(byte[] gameState, int nextPlayerIndex)
        {            
            ModifiableGameState state = new ModifiableGameState();
            state.ActiveSeatIndex = nextPlayerIndex;
            state.GameData = gameState;

            _stateLock.EnterReadLock();
            try
            {
                Debug.Assert(IsMyTurn, "It is not our turn");
                Debug.Assert(!IsGameOver, "The game is completed");
                Debug.Assert(_user.IsLoggedIn, "The user is not logged in");

                //Set state on server
                GameStateService.PutGameState(_sessionState.SessionID, state, _user.Authentication, _serviceConfig);
            }
            finally { _stateLock.ExitReadLock(); }

            //Retrieve new state
            Update();
        }

        /// <summary>
        /// Ends a game and commits the results to the server
        /// </summary>
        /// <param name="winningSeats">The seat indexes of the winning players and should receive You Won notifications</param>
        /// <param name="losingSeats">The seat indexes of the losing players and should receive You Lose notifications</param>
        /// <param name="tieSeats">The seat indexes of the players who tied and should receive Tied notifications</param>
        /// <param name="gameOverSeats">The seat indexes of players who should receive GameOver notifications</param>
        public void EndGame(int[] winningSeats, int[] losingSeats, int[] tieSeats, int[] gameOverSeats)
        {            
            GameResults results = new GameResults();

            //These properties set who gets what kinds of notifications
            results.WinningSeatIndexes = winningSeats;
            results.LosingSeatIndexes = losingSeats;
            results.GameOverSeatIndexes = gameOverSeats;
            results.TierSeatIndexes = tieSeats;

            //This property sets leaderboard data
            //results.Results = null;

            _stateLock.EnterReadLock();
            try
            {
                Debug.Assert(!IsGameOver, "The game is completed");
                Debug.Assert(_user.IsLoggedIn, "The user is not logged in");

                //Set state on server
                GameStateService.PostGameEnd(_sessionState.SessionID, results, _user.Authentication, _serviceConfig);
            }
            finally { _stateLock.ExitReadLock(); }

            //Retrieve new state
            Update();
        }

        /// <summary>
        /// Changes a session's configuration
        /// </summary>
        /// <param name="newSettings"></param>
        public void ModifySession(ModificationData newSettings)
        {
            _stateLock.EnterReadLock();
            try
            {
                Debug.Assert(!IsGameOver, "The game is completed");
                Debug.Assert(_user.IsLoggedIn, "The user is not logged in");

                SessionService.ModifySession(_sessionState.SessionID, newSettings, _user.Authentication, _serviceConfig);
            }
            finally { _stateLock.ExitReadLock(); }

            //Retrieve new state
            Update();
        }

        /// <summary>
        /// Uses PostGameAction to send a nudge notification to the active player
        /// </summary>
        public void NudgeActiveUser()
        {
            GameAction nudge = new GameAction();
            nudge.ActionType = GameActionType.UserNudge;

            _stateLock.EnterReadLock();
            try
            {
                Debug.Assert(_user.IsLoggedIn, "The user is not logged in");

                GameStateService.PostGameAction(_sessionState.SessionID, nudge, _user.Authentication, _serviceConfig);
            }
            finally { _stateLock.ExitReadLock(); }
        }

        /// <summary>
        /// Uses SendInvite to send an invitation notification to the specified players
        /// </summary>
        /// <param name="recipients"></param>
        /// <param name="message"></param>
        /// <param name="makeFriends">True to also make the invite a friend request</param>
        public void SendInvite(string recipients, string message, bool makeFriends)
        {
            InviteRequest request = new InviteRequest();
            request.Recipients = recipients;
            request.Data = message;
            request.FriendRequest = makeFriends;
            request.SessionId = this.SessionID;

            Debug.Assert(_user.IsLoggedIn, "The user is not logged in");
            NotificationService.SendInvite(request, _user.Authentication, _serviceConfig);
        }




        #region Event Firing

        private void OnGameEnded()
        {
            _gameEnded.Raise(this, EventArgs.Empty);
        }

        private void OnPlayerLeft(SeatInfo seat)
        {
            _playerLeft.Raise(this, new SeatEventArgs(seat));
        }

        private void OnPlayerJoined(SeatInfo seat)
        {
            _playerJoined.Raise(this, new SeatEventArgs(seat));
        }

        private void OnOwnerIndexChanged(int oldOwner, int newOwner)
        {
            _ownerIndexChanged.Raise(this, new IndexChangedEventArgs(oldOwner, newOwner));
        }

        private void OnOwnerSeatChanged(SeatInfo oldOwner, SeatInfo newOwner)
        {
            _ownerSeatChanged.Raise(this, new SeatChangedEventArgs(oldOwner, newOwner));
        }

        private void OnActiveIndexChanged(int oldActive, int newActive)
        {
            _activeIndexChanged.Raise(this, new IndexChangedEventArgs(oldActive, newActive));
        }
        
        private void OnActiveSeatChanged(SeatInfo oldActive, SeatInfo newActive)
        {
            _activeSeatChanged.Raise(this, new SeatChangedEventArgs(oldActive, newActive));
        }

        private void OnUpdated(SessionState sessionState, byte[] gameState)
        {
            _updated.Raise(this, new SessionUpdatedEventArgs(sessionState, gameState));
        }
        #endregion



        /// <summary>
        /// Helper for comparing SeatInfo objects for equality using their PublicToken data
        /// </summary>
        private class SeatIdentityComparer : IEqualityComparer<SeatInfo>
        {
            public static readonly SeatIdentityComparer Instance = new SeatIdentityComparer();

            public bool Equals(SeatInfo x, SeatInfo y)
            {
                if (x == null && y == null)
                    return true;

                if ((x == null && y != null) || (x != null && y == null))
                    return false;

                return x.Profile.PublicToken.Equals(y.Profile.PublicToken);
            }

            public int GetHashCode(SeatInfo obj)
            {
                return obj.Profile.GetHashCode();
            }
        }
    }

    /// <summary>
    /// Contains the new data generated by a session update
    /// </summary>
    public class SessionUpdatedEventArgs : EventArgs
    {
        /// <summary>
        /// The new session state
        /// </summary>
        public readonly SessionState SessionState;

        /// <summary>
        /// The new game state
        /// </summary>
        public readonly byte[] GameState;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="sessionState">The new session state</param>
        /// <param name="gameState">The new game state</param>
        public SessionUpdatedEventArgs(SessionState sessionState, byte[] gameState)
        {
            SessionState = sessionState;
            GameState = gameState;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardFramework\Services\GameStateService.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using AsyncMultiplayer.SessionCommon;
using System.Net;
using System.IO;
using System.Diagnostics;
using OneCardFramework.Configuration;
using System.Collections.Specialized;

namespace OneCardFramework.Services
{
    /// <summary>
    /// Provides a client-side interface for interacting with the GameStateService API. All static methods
    /// are threadsafe unless specified otherwise.
    /// </summary>
    public static class GameStateService
    {
        /// <summary>
        /// Default diagnostic tracing source used for GameStateService operations
        /// </summary>
        public static readonly TraceSource Tracer = new TraceSource(typeof(GameStateService).FullName, SourceLevels.All);

        /// <summary>
        /// Diagnostic tracing source used for the web traffic of GameStateService operations
        /// </summary>
        public static readonly TraceSource WebTracer = new TraceSource(typeof(GameStateService).FullName + ".Web", SourceLevels.Verbose);

        /// <summary>
        /// Retrieves the current state of a game session
        /// </summary>
        /// <param name="sessionID"></param>
        /// <param name="auth"></param>
        /// <param name="config"></param>
        /// <returns></returns>
        public static FullGameState GetGameState(string sessionID, TicketData auth, MultiplayerServiceConfig config)
        {
            string serviceUri = config.GameStateServiceUrl;
            string gameID = auth.TitleID.ToString();
            string uri = string.Format("{0}GameState/{1}/{2}", serviceUri, sessionID, gameID);
            string method = "GET";
            byte[] data = null;

            Tracer.TraceInformation("Calling GetGameState for game '{0}', session '{1}'", gameID, sessionID);
            string response = SendGameStateRequest(uri, method, data, null, auth, config);

            return SerializationHelper.DeserializeDataContract<FullGameState>(response);
        }

        /// <summary>
        /// Saves the state of a game session to the server, replacing any existing data
        /// </summary>
        /// <param name="sessionID"></param>
        /// <param name="state"></param>
        /// <param name="auth"></param>
        /// <param name="config"></param>
        public static void PutGameState(string sessionID, ModifiableGameState state, TicketData auth, MultiplayerServiceConfig config)
        {
            string serviceUri = config.GameStateServiceUrl;
            string gameID = auth.TitleID.ToString();
            string uri = string.Format("{0}GameState/{1}/{2}", serviceUri, sessionID, gameID);
            string method = "PUT";
            string data = SerializationHelper.SerializeDataContract(state);

            Tracer.TraceInformation("Calling PutGameState for game '{0}', session '{1}'", gameID, sessionID);
            string response = SendGameStateRequest(uri, method, Encoding.UTF8.GetBytes(data), data, auth, config);
        }

        /// <summary>
        /// Posts the results of a game session, signifying that it has been completed.
        /// </summary>
        /// <param name="sessionID"></param>
        /// <param name="results"></param>
        /// <param name="auth"></param>
        /// <param name="config"></param>
        public static void PostGameEnd(string sessionID, GameResults results, TicketData auth, MultiplayerServiceConfig config)
        {
            string gameID = auth.TitleID.ToString();
            string serviceUri = config.GameStateServiceUrl;
            string uri = string.Format("{0}GameState/{1}/{2}", serviceUri, sessionID, gameID);
            string method = "POST";
            string data = SerializationHelper.SerializeDataContract(results);

            Tracer.TraceInformation("Calling PostGameState for game '{0}', session '{1}'", gameID, sessionID);
            string response = SendGameStateRequest(uri, method, Encoding.UTF8.GetBytes(data), data, auth, config);
        }

        /// <summary>
        /// Posts an action to the server
        /// </summary>
        /// <param name="sessionID"></param>
        /// <param name="action"></param>
        /// <param name="auth"></param>
        /// <param name="config"></param>
        public static void PostGameAction(string sessionID, GameAction action, TicketData auth, MultiplayerServiceConfig config)
        {
            string gameID = auth.TitleID.ToString();
            string serviceUri = config.GameStateServiceUrl;
            string uri = string.Format("{0}GameAction/{1}/{2}", serviceUri, sessionID, gameID.ToString());
            string method = "POST";
            string data = SerializationHelper.SerializeDataContract(action);

            Tracer.TraceInformation("Calling PostGameAction for game '{0}', session '{1}'", gameID, sessionID);
            string response = SendGameStateRequest(uri, method, Encoding.UTF8.GetBytes(data), data, auth, config);
        }


        /// <summary>
        /// Sends a game state service web request and reads the reply as a string. If the server returns
        /// an error code, an exception will be thrown.
        /// </summary>
        /// <param name="uri"></param>
        /// <param name="method"></param>
        /// <param name="data"></param>
        /// <param name="contentMessage">An optional string version of the data content, used for diagnostics</param>
        /// <param name="auth">Authentication information necessary for communicating with the service</param>
        /// <param name="config"></param>
        /// <returns>The service response as a string</returns>
        private static string SendGameStateRequest(string uri, string method, byte[] data, string contentMessage, TicketData auth, MultiplayerServiceConfig config)
        {
            NameValueCollection headers = new NameValueCollection();
            headers.Add(AuthenticationConfig.PartnerTokenHeader, AuthenticationConfig.PartnerTokenPreamble + auth.PartnerToken);
            headers.Add(MultiplayerServiceConfig.LocaleHeader, config.Locale);
            headers.Add(MultiplayerServiceConfig.PlatformTypeHeader, config.PlatformType);

            return WebHelper.ExecuteServiceRequest(uri, method, headers, config.RequestContentType, data, contentMessage, WebTracer);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardFramework\Services\ServiceException.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Net;
using System.Runtime.Serialization;
using System.Xml.Serialization;


namespace OneCardFramework.Services
{
    /// <summary>
    /// Represents an exception that occurred within one of the multiplayer services, containing
    /// information specifying to the cause of the error
    /// </summary>
    public class ServiceException : Exception
    {
        public string ApiName { get; private set; }
        public string ErrorMessage { get; private set; }
        public uint LIVEnErrorCode { get; private set; }

        /// <summary>
        /// Creates an exception representing an error that occurred within one of the multiplayer services
        /// </summary>
        /// <param name="msg">The parsed error response from the server</param>
        /// <param name="innerException"></param>
        public ServiceException(ServiceErrorMessage msg, Exception innerException)
            : base(msg.ErrorMessage, innerException)
        {
            ApiName = msg.ApiName;
            ErrorMessage = msg.ErrorMessage;
            LIVEnErrorCode = msg.LIVEnErrorCode;
        }

        public override string ToString()
        {
            return base.ToString() + Environment.NewLine + string.Format("API: {0}, Code: {1}", ApiName, LIVEnErrorCode);
        }
    }

    /// <summary>
    /// Stores the contents of error messages returned by the multiplayer services
    /// </summary>
    [DataContract(Name = "ServiceErrorMessage", Namespace = "http://schemas.datacontract.org/2004/07/Leet.Core.Utils")]
    [XmlRoot(Namespace="http://schemas.datacontract.org/2004/07/Leet.Core.Utils", IsNullable=false)]
    [Serializable]
    public class ServiceErrorMessage
    {
        public ServiceErrorMessage() { }

        [DataMember]
        public string ApiName { get; set; }

        [DataMember]
        public string ErrorMessage { get; set; }

        [DataMember]
        public uint LIVEnErrorCode { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardFramework\Services\NotificationService.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Net;
using System.IO;
using System.Diagnostics;
using AsyncMultiplayer.NotificationService;
using System.Collections.Specialized;
using OneCardFramework.Configuration;

namespace OneCardFramework.Services
{
    /// <summary>
    /// Provides a client-side interface for interacting with the NotificationService API. All static methods
    /// are threadsafe unless specified otherwise.
    /// </summary>
    public static class NotificationService
    {        
        /// <summary>
        /// Default diagnostic tracing source used for NotificationService operations
        /// </summary>
        public static readonly TraceSource Tracer = new TraceSource(typeof(NotificationService).FullName, SourceLevels.All);

        /// <summary>
        /// Diagnostic tracing source used for the web traffic of NotificationService operations
        /// </summary>
        public static readonly TraceSource WebTracer = new TraceSource(typeof(NotificationService).FullName + ".Web", SourceLevels.Verbose);

        /// <summary>
        /// Sends an invite to another person.
        /// </summary>
        /// <param name="invite">Configuration for the invite. TitleID is automatically set based on authentication.</param>
        /// <param name="auth">Authorization data for the sender</param>
        /// <param name="config"></param>
        public static void SendInvite(InviteRequest invite, TicketData auth, MultiplayerServiceConfig config)
        {
            //Overwrite any attempt to mismatch the gameID values between the config and the ticket
            invite.GameId = auth.TitleID;

            string gameID = auth.TitleID.ToString();
            string serviceUri = config.NotificationServiceUrl;
            string uri = string.Format("{0}invite/", serviceUri);
            string method = "POST";
            string data = SerializationHelper.SerializeDataContract(invite);

            Tracer.TraceInformation("Calling SendInvite for game '{0}', session '{1}', recipients '{2}', friend request {3}, message: {4}", gameID, invite.SessionId, invite.Recipients, invite.FriendRequest, invite.Data);
            string response = SendNotificationsRequest(uri, method, Encoding.UTF8.GetBytes(data), data, auth, config);
        }


        /// <summary>
        /// Retrieves notifications for the user using the server's default configurations
        /// </summary>
        /// <param name="auth"></param>
        /// <param name="config"></param>
        /// <returns></returns>
        public static NotificationList GetNotifications(TicketData auth, MultiplayerServiceConfig config)
        {
            string serviceUri = config.NotificationServiceUrl;
            string uri = serviceUri;
            string method = "GET";
            byte[] data = null;
            string contentMessage = null;

            Tracer.TraceInformation("Calling GetNotifications for player {0}", auth.Username);
            string response = SendNotificationsRequest(uri, method, data, contentMessage, auth, config);

            return SerializationHelper.DeserializeDataContract<NotificationList>(response);
        }

        /// <summary>
        /// Retrieves a filtered set of notifications for a user, in order of newest to oldest
        /// </summary>
        /// <param name="gameID"></param>
        /// <param name="variant">Optional filter for game variant</param>
        /// <param name="lastID">Optional. If specified, only notifications dated after this notification will be retrieved</param>
        /// <param name="count">Optional. Restricts the maximum number of results returned.</param>
        /// <param name="auth"></param>
        /// <param name="config"></param>
        /// <returns></returns>
        public static NotificationList GetNotifications(uint? gameID, int? variant, string lastID, int? count, TicketData auth, MultiplayerServiceConfig config)
        {
            Dictionary<string, object> parameters = new Dictionary<string,object>();
            parameters.Add("gameID", gameID);
            parameters.Add("variant", variant);
            parameters.Add("last", lastID);
            parameters.Add("count", count);

            string serviceUri = config.NotificationServiceUrl;
            string uri = serviceUri + WebHelper.BuildQueryString(parameters, false);
            string method = "GET";
            byte[] data = null;
            string contentMessage = null;

            Tracer.TraceInformation("Calling GetNotifications for player {0}, filtered", auth.Username);
            string response = SendNotificationsRequest(uri, method, data, contentMessage, auth, config);

            return SerializationHelper.DeserializeDataContract<NotificationList>(response);
        }

        /// <summary>
        /// Removes the given notification from the online store
        /// </summary>
        /// <param name="notification">The notification to delete</param>
        /// <param name="auth"></param>
        /// <param name="config"></param>
        public static void DeleteNotification(Notification notification, TicketData auth, MultiplayerServiceConfig config)
        {
            DeleteNotification(notification.Id, auth, config);
        }

        /// <summary>
        /// Removes the notification with the given ID from the online store
        /// </summary>
        /// <param name="id">The ID of the notification to remove</param>
        /// <param name="auth"></param>
        /// <param name="config"></param>
        public static void DeleteNotification(string id, TicketData auth, MultiplayerServiceConfig config)
        {
            string serviceUri = config.NotificationServiceUrl;
            string uri = string.Format("{0}delete/?notification={1}", serviceUri, id);
            string method = "DELETE";
            byte[] data = null;
            string contentMessage = null;

            Tracer.TraceInformation("Calling DeleteNotification for notification {0}", id);
            string response = SendNotificationsRequest(uri, method, data, contentMessage, auth, config);
        }


        /// <summary>
        /// Sends a notification service web request and reads the reply as a string. If the server returns
        /// an error code, an exception will be thrown.
        /// </summary>
        /// <param name="uri"></param>
        /// <param name="method"></param>
        /// <param name="data"></param>
        /// <param name="contentMessage">An optional string version of the data content, used for diagnostics</param>
        /// <param name="auth">Authentication information necessary for communicating with the service</param>
        /// <param name="config"></param>
        /// <returns></returns>
        private static string SendNotificationsRequest(string uri, string method, byte[] data, string contentMessage, TicketData auth, MultiplayerServiceConfig config)
        {
            NameValueCollection headers = new NameValueCollection();
            headers.Add(AuthenticationConfig.UserTokenHeader, AuthenticationConfig.UserTokenPreamble + auth.UserToken);
            headers.Add(MultiplayerServiceConfig.LocaleHeader, config.Locale);
            headers.Add(MultiplayerServiceConfig.PlatformTypeHeader, config.PlatformType);

            return WebHelper.ExecuteServiceRequest(uri, method, headers, config.RequestContentType, data, contentMessage, WebTracer);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardFramework\Services\SessionService.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using AsyncMultiplayer.SessionCommon;
using System.Net;
using System.IO;
using System.Diagnostics;
using OneCardFramework.Configuration;
using System.Collections.Specialized;

namespace OneCardFramework.Services
{
    /// <summary>
    /// Provides a client interface for interacting with the online session service. All static methods
    /// are threadsafe unless specified otherwise.
    /// </summary>
    public static class SessionService
    {
        /// <summary>
        /// Default diagnostic tracing source used for SessionService operations
        /// </summary>
        public static readonly TraceSource Tracer = new TraceSource(typeof(SessionService).FullName, SourceLevels.All);

        /// <summary>
        /// Diagnostic tracing source used for the web traffic of SessionService operations
        /// </summary>
        public static readonly TraceSource WebTracer = new TraceSource(typeof(SessionService).FullName + ".Web", SourceLevels.Verbose);

        /// <summary>
        /// Creates an online game session
        /// </summary>
        /// <param name="creationData">Configuration for creating the session</param>
        /// <param name="auth">Authentication information necessary for communicating with the service</param>
        /// <param name="config"></param>
        /// <returns>The state of the created session</returns>
        public static SessionState CreateSession(CreationData creationData, TicketData auth, MultiplayerServiceConfig config)
        {
            if (creationData == null || auth == null || config == null)
                throw new ArgumentNullException();

            //Overwrite any attempt to mismatch the gameID values between the config and the ticket
            creationData.GameID = auth.TitleID;

            string serviceUri = config.SessionServiceUrl;
            string uri = string.Format("{0}game/{1}", serviceUri, auth.TitleID);
            string method = "POST";
            string data = SerializationHelper.SerializeDataContract(creationData);

            Tracer.TraceEvent(TraceEventType.Information, 0, "Calling CreateSession for game '{0}'", creationData.GameID);
            string response = SendSessionRequest(uri, method, Encoding.UTF8.GetBytes(data), data, auth, config);

            return SerializationHelper.DeserializeDataContract<SessionState>(response);
        }

        /// <summary>
        /// Joins an online game session
        /// </summary>
        /// <param name="joinData">Configuration for joining the session</param>
        /// <param name="auth">Authentication information necessary for communicating with the service</param>
        /// <param name="config"></param>
        /// <returns>The current session state</returns>
        public static SessionState JoinSession(JoinData joinData, TicketData auth, MultiplayerServiceConfig config)
        {
            if (joinData == null || auth == null || config == null)
                throw new ArgumentNullException();

            //Overwrite any attempt to mismatch the gameID values between the config and the ticket
            joinData.GameID = auth.TitleID;

            string serviceUri = config.SessionServiceUrl;
            string uri = string.Format("{0}session/{1}", serviceUri, joinData.SessionID);
            string method = "POST";
            string data = SerializationHelper.SerializeDataContract(joinData);

            Tracer.TraceEvent(TraceEventType.Information, 0, "Calling JoinSession for game '{0}', session '{1}'", joinData.GameID, joinData.SessionID);
            string response = SendSessionRequest(uri, method, Encoding.UTF8.GetBytes(data), data, auth, config);

            return SerializationHelper.DeserializeDataContract<SessionState>(response);
        }

        /// <summary>
        /// Makes modifications to an existing session
        /// </summary>
        /// <param name="sessionID"></param>
        /// <param name="modifyData"></param>
        /// <param name="auth">Authentication information necessary for communicating with the service</param>
        /// <param name="config"></param>
        public static void ModifySession(string sessionID, ModificationData modifyData, TicketData auth, MultiplayerServiceConfig config)
        {
            if (modifyData == null || auth == null || config == null)
                throw new ArgumentNullException();

            string gameID = auth.TitleID.ToString();
            string serviceUri = config.SessionServiceUrl;
            string uri = string.Format("{0}session/{1}/{2}", serviceUri, sessionID, gameID);
            string method = "PUT";
            string data = SerializationHelper.SerializeDataContract(modifyData);

            Tracer.TraceEvent(TraceEventType.Information, 0, "Calling ModifySession for game '{0}', session '{1}'", gameID, sessionID);
            string response = SendSessionRequest(uri, method, Encoding.UTF8.GetBytes(data), data, auth, config);
        }

        /// <summary>
        /// Removes a user from a session
        /// </summary>
        /// <param name="sessionID"></param>
        /// <param name="config"></param>
        /// <param name="auth">Authentication information necessary for communicating with the service</param>
        public static void LeaveSession(string sessionID, TicketData auth, MultiplayerServiceConfig config)
        {
            if (auth == null || config == null)
                throw new ArgumentNullException();

            string gameID = auth.TitleID.ToString();
            string serviceUri = config.SessionServiceUrl;
            string uri = string.Format("{0}session/{1}/{2}", serviceUri, sessionID, gameID);
            string method = "DELETE";
            byte[] data = null;

            Tracer.TraceEvent(TraceEventType.Information, 0, "Calling LeaveSession for game '{0}', session '{1}'", gameID, sessionID);
            string response = SendSessionRequest(uri, method, data, null, auth, config);
        }


        /// <summary>
        /// Gets the current state of a session (does not include game state) 
        /// </summary>
        /// <param name="sessionID"></param>
        /// <param name="auth">Authentication information necessary for communicating with the service</param>
        /// <param name="config"></param>
        /// <returns>The current session state</returns>
        public static SessionState ViewSession(string sessionID, TicketData auth, MultiplayerServiceConfig config)
        {
            if (auth == null || config == null)
                throw new ArgumentNullException();

            string gameID = auth.TitleID.ToString();
            string serviceUri = config.SessionServiceUrl;
            string uri = string.Format("{0}session/{1}/{2}", serviceUri, sessionID, gameID);
            string method = "GET";
            byte[] data = null;

            Tracer.TraceEvent(TraceEventType.Information, 0, "Calling ViewSession for game '{0}', session '{1}'", gameID, sessionID);
            string response = SendSessionRequest(uri, method, data, null, auth, config);

            return SerializationHelper.DeserializeDataContract<SessionState>(response);
        }


        /// <summary>
        /// Gets a list of online sessions for this game that the user is a participant in
        /// </summary>
        /// <param name="typeFilter"></param>
        /// <param name="auth">Authentication information necessary for communicating with the service</param>
        /// <param name="config"></param>
        /// <returns>The set of session summaries returned by the server</returns>
        public static SessionEntry[] ViewSessionSummaries(ShowSessionType typeFilter, TicketData auth, MultiplayerServiceConfig config)
        {
            return ViewSessionSummaries(auth.TitleID, null, null, null, typeFilter, auth, config);
        }

        /// <summary>
        /// Gets a list of online sessions for this game that the user is a participant in
        /// </summary>
        /// <param name="variant"></param>
        /// <param name="lastSession"></param>
        /// <param name="maxCount"></param>
        /// <param name="typeFilter"></param>
        /// <param name="auth">Authentication information necessary for communicating with the service</param>
        /// <param name="config"></param>
        /// <returns></returns>
        public static SessionEntry[] ViewSessionSummaries(int? variant, string lastSession, int? maxCount, ShowSessionType typeFilter, TicketData auth, MultiplayerServiceConfig config)
        {
            return ViewSessionSummaries(auth.TitleID, variant, lastSession, maxCount, typeFilter, auth, config);
        }

        /// <summary>
        /// Gets a list of online sessions the user is a participant in
        /// </summary>
        /// <param name="gameID">Optional filter for the game to search within</param>
        /// <param name="variant">Optional filter for specific game variant</param>
        /// <param name="lastSession">Optional filter for the last session in a previous lookup. Results will begin after the specified session ID.</param>
        /// <param name="maxCount">Optional filter for the maximum number of results to return</param>
        /// <param name="typeFilter">Filter for the types of sessions to look for</param>
        /// <param name="auth">Authentication information necessary for communicating with the service</param>
        /// <param name="config"></param>
        /// <returns>A list of online sessions filtered as appropriate</returns>
        public static SessionEntry[] ViewSessionSummaries(uint? gameID, int? variant, string lastSession, int? maxCount, ShowSessionType typeFilter, TicketData auth, MultiplayerServiceConfig config)
        {
            if (auth == null || config == null)
                throw new ArgumentNullException();

            Dictionary<string, object> parameters = new Dictionary<string, object>();
            parameters.Add("game", gameID);
            parameters.Add("variant", variant);
            parameters.Add("lastSession", lastSession);
            parameters.Add("maxCount", maxCount);
            parameters.Add("showSessionType", typeFilter);

            string serviceUri = config.SessionServiceUrl;
            string uri = string.Format("{0}game{1}", serviceUri, WebHelper.BuildQueryString(parameters, false));
            string method = "GET";
            byte[] data = null;

            Tracer.TraceEvent(TraceEventType.Information, 0, "Calling ViewSessionSummaries, filtered");
            string response = SendSessionRequest(uri, method, data, null, auth, config);

            return SerializationHelper.DeserializeDataContract<SessionEntry[]>(response);
        }
        
        
        /// <summary>
        /// Sends a session service web request and reads the reply as a string. If the server returns
        /// an error code, an exception will be thrown.
        /// </summary>
        /// <param name="uri"></param>
        /// <param name="method"></param>
        /// <param name="data"></param>
        /// <param name="contentMessage">An optional string version of the data content, used for diagnostics</param>
        /// <param name="auth">Authentication information necessary for communicating with the service</param>
        /// <param name="config"></param>
        /// <returns>The service response as a string</returns>
        private static string SendSessionRequest(string uri, string method, byte[] data, string contentMessage, TicketData auth, MultiplayerServiceConfig config)
        {
            NameValueCollection headers = new NameValueCollection();
            headers.Add(AuthenticationConfig.PartnerTokenHeader, AuthenticationConfig.PartnerTokenPreamble + auth.PartnerToken);
            headers.Add(MultiplayerServiceConfig.LocaleHeader, config.Locale);
            headers.Add(MultiplayerServiceConfig.PlatformTypeHeader, config.PlatformType);

            return WebHelper.ExecuteServiceRequest(uri, method, headers, config.RequestContentType, data, contentMessage, WebTracer);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardFramework\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("OneCardFramework")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("2c63c44c-039f-4ec5-861f-eb21fa08f49f")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
//[assembly: AssemblyVersion("1.0.0.0")]
//[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardFramework\Services\WebProtocolException.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Net;

namespace OneCardFramework.Services
{
    /// <summary>
    /// Represents a WebException generated by a protocol error, whose
    /// response has been read out as a string -- thus, the response's
    /// data stream has been closed.
    /// </summary>
    public class WebProtocolException : WebException
    {
        /// <summary>
        /// The data retrieved from the response
        /// </summary>
        public string ResponseData { get; private set; }

        /// <summary>
        /// Creates an exception representing a WebException generated by a protocol error
        /// </summary>
        /// <param name="responseData">The content of the WebException's response as a string</param>
        /// <param name="exception">The original WebException</param>
        public WebProtocolException(string responseData, WebException exception)
            : base(exception.Message, exception.InnerException, exception.Status, exception.Response)
        {
            ResponseData = responseData;
        }

        public override string ToString()
        {
            return base.ToString() + Environment.NewLine + "Error Reponse: " + ResponseData;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardFramework\Services\AuthenticationService.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using Microsoft.DeviceServices.Utility;
using System.Net;
using System.Net.Security;
using System.IdentityModel.Selectors;
using System.IdentityModel.Tokens;
using System.ServiceModel.Security;
using System.Security.Cryptography.X509Certificates;
using System.Security.Authentication;
using System.IO;
using System.Xml;
using System.Xml.Linq;
using System.Xml.XPath;
using System.Collections.ObjectModel;
using System.Net.Sockets;
using System.Security.Permissions;
using System.Diagnostics;
using System.ComponentModel;
using OneCardFramework.Configuration;
using OneCardFramework.Cache;
using System.Reflection;

namespace OneCardFramework.Services
{
    /// <summary>
    /// Helper for performing authentication. Assume all static methods are thread-safe unless otherwise declared.
    /// </summary>
    public static class AuthenticationService
    {
        /// <summary>
        /// The STS service URL  template for user tickets
        /// </summary>
        private static readonly string SecurityTicketQuery = "/GetSecurityTicket?platformType={platformId}&titleId={titleId}&titleVersion={titleVersion}&clientVersion={clientVersion}&deviceId={deviceId}";

        /// <summary>
        /// The STS service URL template for partner tickets
        /// </summary>
        private static readonly string PartnerSecurityTicketQuery = "/GetPartnerSecurityTicket?xuid={xuid}&titleId={titleId}&titleVersion={titleVersion}&audience={audience}";


        /// <summary>
        /// Default diagnostic tracing source used for AuthenticationService operations
        /// </summary>
        public static readonly TraceSource Tracer = new TraceSource(typeof(AuthenticationService).FullName, SourceLevels.All);

        /// <summary>
        /// Diagnostic tracing source used for the web traffic of AuthenticationService operations
        /// </summary>
        public static readonly TraceSource WebTracer = new TraceSource(typeof(AuthenticationService).FullName + ".Web", SourceLevels.Verbose);



        /// <summary>
        /// Creates and signs in a user that stores authentication data and provides functionality for signing in and out.
        /// </summary>
        /// <param name="username"></param>
        /// <param name="password"></param>
        /// <param name="config"></param>
        /// <returns>The created user, signed in</returns>
        public static User CreateUser(string username, string password, AuthenticationConfig config)
        {
            return new User(username, password, config);
        }



        /// <summary>
        /// Authenticates with the necessary services to get the tokens used
        /// in communicating with the Multiplayer APIs. Blocks the current thread until completion.
        /// </summary>
        /// <param name="username">Live ID username</param>
        /// <param name="password">Live ID password</param>
        /// <param name="config">Configuration data for authentication</param>
        /// <returns>A collection of tokens returned by the different authentication systems. The ticket is
        /// only valid for the specific user and service configuration</returns>
        /// <exception cref="ArgumentNullException">Thrown if config is null</exception>
        public static TicketData Authenticate(string username, string password, AuthenticationConfig config)
        {
            if (config == null)
                throw new ArgumentNullException("config");

            Tracer.TraceEvent(TraceEventType.Information, 0, "Starting authentication procedure for '{0}'", username);
            Tracer.TraceEvent(TraceEventType.Information, 0, "Retrieving RPS ticket for '{0}'", username);

            //Authentication first requires getting a ticket from
            //Windows Live ID

            Stopwatch stopwatch = Stopwatch.StartNew();
            string rpsTicket = LiveIDClient.GetLoginTicket(
                                    username,
                                    password,
                                    config.LiveID_DnsName,
                                    config.LiveID_Policy,
                                    config.LiveID_Env);
            stopwatch.Stop();

            if (rpsTicket == null)
                throw new ApplicationException("Failed to get Windows Live ID (RPS) ticket");

            rpsTicket = rpsTicket.Substring(2); //Remove "t="
            Tracer.TraceEvent(TraceEventType.Information, 0, "Acquired RPS ticket for '{0}' in {1}ms", username, stopwatch.ElapsedMilliseconds);
            Tracer.TraceEvent(TraceEventType.Verbose, 0, "RPSTicket: {0}", rpsTicket);

            //Once we have the WLID ticket, we use it to get the User and Partner tokens
            //from STS. Note that there are also different STS systems (WebSTS vs. Platform STS).
            Tracer.TraceEvent(TraceEventType.Information, 0, "Retrieving user token for '{0}'", username);
            string userToken = GetUserToken(rpsTicket, config);
            Tracer.TraceEvent(TraceEventType.Information, 0, "Acquired user token for {0}", username);
            Tracer.TraceEvent(TraceEventType.Verbose, 0, "UserToken: {0}", userToken);

            Tracer.TraceEvent(TraceEventType.Information, 0, "Retrieving partner token for '{0}'", username);
            string partnerToken = GetPartnerToken(userToken, config);
            Tracer.TraceEvent(TraceEventType.Information, 0, "Acquired partner token for {0}", username);
            Tracer.TraceEvent(TraceEventType.Verbose, 0, "PartnerToken: {0}", partnerToken);

            TicketData ticket = new TicketData(username, rpsTicket, userToken, partnerToken, config.TitleID, config.TicketLifetime);
            Tracer.TraceEvent(TraceEventType.Information, 0, 
                "Created authentication ticket for {0} at {1}. Expires at {2}", username, ticket.CreationDate, ticket.ExpirationDate);

            ticket.Expired += (sender, args) => Tracer.TraceEvent(TraceEventType.Warning, 0, "Ticket for {0} has expired", ((TicketData)sender).Username);

            return ticket;
        }

        /// <summary>
        /// Queries the STS service to get the Saml User Token
        /// </summary>
        /// <param name="rpsTicket">A Windows Live ID ticket</param>
        /// <param name="config"></param>
        /// <returns>The Saml User Token in XML form</returns>
        private static string GetUserToken(string rpsTicket, AuthenticationConfig config)
        {
            //Fill in our config values for calling the STS service
            string uri =  config.StsUrl + (SecurityTicketQuery
                .Replace("{platformId}", config.PlatformID)
                .Replace("{titleId}", config.TitleID.ToString())
                .Replace("{titleVersion}", config.TitleVersion)
                .Replace("{clientVersion}", config.ClientVersion)
                .Replace("{deviceId}", config.DeviceID));
                        
            //Create an HTTP request to get our STS token
            HttpWebRequest request = (HttpWebRequest)HttpWebRequest.Create(uri);

            //Add the WLID authorization info
            request.Headers.Add(AuthenticationConfig.RPSTokenHeader, AuthenticationConfig.RPSTokenPreamble + rpsTicket);
            
            //Process further and get the server response
            return GetSecurityToken(request, config);
        }

        /// <summary>
        /// Queries the STS service to get the Saml Partner Token
        /// </summary>
        /// <param name="userToken">A Saml XML user token</param>
        /// <param name="config"></param>
        /// <returns>The Saml Partner Token in XML form</returns>
        private static string GetPartnerToken(string userToken, AuthenticationConfig config)
        {
            string xuid = GetXuidFromUserToken(userToken);

            string uri = config.StsUrl + (PartnerSecurityTicketQuery
                .Replace("{xuid}", xuid)
                .Replace("{titleId}", config.TitleID.ToString())
                .Replace("{titleVersion}", config.TitleVersion)
                .Replace("{audience}", Uri.EscapeDataString(config.AudienceUrl)));

            //Create an HTTP request to get our STS token
            HttpWebRequest request = (HttpWebRequest)HttpWebRequest.Create(uri);

            //Add the User Token authorization info
            request.Headers.Add(AuthenticationConfig.UserTokenHeader, AuthenticationConfig.UserTokenPreamble + userToken);
            
            //Process further and get the server response
            return GetSecurityToken(request, config);
        }

        /// <summary>
        /// Helper for adding any necessary client certificates, performing the request,
        /// and parsing the output of STS queries.
        /// </summary>
        /// <param name="request"></param>
        /// <param name="config"></param>
        /// <returns></returns>
        private static string GetSecurityToken(HttpWebRequest request, AuthenticationConfig config)
        {
            //If we're using SSL, we need to include the SSL client certificate
            if (request.RequestUri.Scheme == "https" && string.IsNullOrEmpty(config.CertThumbprint) == false)
            {
                Tracer.TraceEvent(TraceEventType.Information, 0, "Using https. Attaching certificate to request.");

                X509Store certStore = new X509Store(StoreName.My, StoreLocation.LocalMachine);
                certStore.Open(OpenFlags.ReadOnly | OpenFlags.OpenExistingOnly);
                X509Certificate cert = certStore.Certificates.Find(X509FindType.FindByThumbprint, config.CertThumbprint, false)[0];
                certStore.Close();

                //We have to do some weird hack to get certs to actually work
                //CertificateHack(cert, config.StsUrl);

                request.ClientCertificates.Add(cert);

                Tracer.TraceEvent(TraceEventType.Information, 0, "Attached cert: {0}", cert.Subject);
            }

            string response = WebHelper.ExecuteServiceRequest(request, null, WebTracer);

            return GetSamlData(response);
        }


        /// <summary>
        /// Hack necessary to get our client certificate to actually work when using https
        /// </summary>
        /// <param name="cert"></param>
        /// <param name="stsUrl"></param>
        [Obsolete]
        private static void CertificateHack(X509Certificate cert, string stsUrl)
        {
            Uri uri = new Uri(stsUrl);

            RemoteCertificateValidationCallback remoteValidation =
                delegate(object sender, X509Certificate remoteCert, X509Chain chain, SslPolicyErrors errors)
                {
                    return true;
                };

            LocalCertificateSelectionCallback localValidation =
                delegate(object sender, string targetHost, X509CertificateCollection localCerts,
                    X509Certificate remoteCert, string[] acceptableIssuers)
                {
                    return cert;
                };

            try
            {
                ServicePointManager.ServerCertificateValidationCallback += remoteValidation;

                using (TcpClient tcp = new TcpClient(uri.Host, uri.Port))
                {
                    using (SslStream ssl = new SslStream(tcp.GetStream(), false, remoteValidation, localValidation))
                    {
                        ssl.AuthenticateAsClient(
                            uri.Host, 
                            new X509CertificateCollection(new X509Certificate[]{ cert }), 
                            SslProtocols.Default,
                            false);

                        HttpWebRequest request = (HttpWebRequest)WebRequest.Create(uri);
                        StringBuilder sb = new StringBuilder();
                        sb.Append(request.Method);
                        sb.Append(" ");
                        sb.Append(request.RequestUri.PathAndQuery);
                        sb.Append(" ");
                        sb.Append("HTTP/" + request.ProtocolVersion);
                        sb.AppendLine();
                        sb.AppendLine("Host: " + request.RequestUri.Host + ":" + request.RequestUri.Port);
                        if(request.ContentLength != -1)
                            sb.AppendLine("Content-Length: " + request.ContentLength);
                        foreach (string header in request.Headers)
                            sb.AppendLine(header);
                        sb.AppendLine();

                        string headers = sb.ToString();
                        byte[] data = Encoding.UTF8.GetBytes(headers);

                        ssl.Write(data);
                        ssl.Flush();
                        //ssl.Read(new byte[1], 0, 1);
                    }
                }
            }
            finally
            {
                ServicePointManager.ServerCertificateValidationCallback -= remoteValidation;
            }
        }




        /// <summary>
        /// Retrieves the Saml XML data from an STS HTTP response
        /// </summary>
        /// <param name="stsServiceResponse"></param>
        /// <returns></returns>
        private static string GetSamlData(string stsServiceResponse)
        {
            try
            {
                XDocument stsResponse = XDocument.Parse(stsServiceResponse);
                return stsResponse.Descendants().Where(n => n.Name.LocalName == "string").ElementAt(0).Value;
            }
            catch
            {
                throw new InvalidDataException("The STS response data was invalid.");
            }
        }

        /// <summary>
        /// Extracts the Xuid from an STS Saml token
        /// </summary>
        /// <param name="stsToken"></param>
        /// <returns></returns>
        private static string GetXuidFromUserToken(string userToken)
        {
            using (StringReader reader = new StringReader(userToken))
            {
                XPathDocument doc = new XPathDocument(reader);
                XPathNavigator nav = doc.CreateNavigator();
                XmlNamespaceManager nsManager = new XmlNamespaceManager(nav.NameTable);
                nsManager.AddNamespace("saml", "urn:oasis:names:tc:SAML:1.0:assertion");

                XPathNavigator xuidNode = nav.SelectSingleNode(@"//saml:Attribute[@AttributeName='Xuid0']/saml:AttributeValue", nsManager);

                if (xuidNode == null)
                    throw new InvalidDataException("Xuid could not be found");

                return xuidNode.InnerXml;
            }
        }


        /// <summary>
        /// Installs a certificate to the LocalMachine/My store.
        /// </summary>
        /// <param name="x509CertPath">The path to the certificate file</param>
        /// <param name="password">The certificate password</param>
        public static void InstallCertificate(string x509CertPath, string password)
        {
            if (!File.Exists(x509CertPath))
                throw new FileNotFoundException("Could not file the certificate file", x509CertPath);

            X509Store certStore = new X509Store(StoreName.My, StoreLocation.LocalMachine);
            certStore.Open(OpenFlags.ReadWrite);

            X509Certificate2 cert = new X509Certificate2(x509CertPath, password);
            certStore.Add(cert);

            certStore.Close();
        }

        /// <summary>
        /// Installs default certificates using an external batch file
        /// </summary>
        public static void InstallDefaultCertificates()
        {
            TimeSpan waitTime = TimeSpan.FromSeconds(10);
            string frameworkFile = Assembly.GetExecutingAssembly().Location;
            string certsFolder = Path.Combine(Path.GetDirectoryName(frameworkFile), "Certificates");
            string installer = Path.GetFullPath(Path.Combine(certsFolder, "installcert.bat"));

            ProcessStartInfo startInfo = new ProcessStartInfo();
            startInfo.UseShellExecute = true;
            startInfo.Verb = "runas";
            startInfo.FileName = installer;

            Process p = Process.Start(startInfo);
            p.WaitForExit((int)waitTime.TotalMilliseconds);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\Commanding\DelegateCommand.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows.Input;
using System.ComponentModel;
using OneCardGUI.Framework;
using OneCardFramework;
using OneCardFramework.Extensions;
using System.Linq.Expressions;
using OneCardFramework.Events;

namespace OneCardGUI.Commanding
{
    /// <summary>
    /// An ICommand implementation that forwards execution to supplied delegates
    /// and allows for easy listening to other objects property changes
    /// </summary>
    public class DelegateCommand : ICommand
    {
        private Action _executeMethod;
        private Func<bool> _canExecuteMethod;
        private bool _autoRequery;

        public bool AutoRequery
        {
            get { return _autoRequery; }
        }

        public DelegateCommand(Action exec, Func<bool> canExec, bool autoRequery)
        {
            _executeMethod = exec;
            _canExecuteMethod = canExec;
            _autoRequery = autoRequery;
        }

        /// <summary>
        /// Checks whether the command can be executed
        /// </summary>
        /// <returns></returns>
        public bool CanExecute()
        {
            return (_canExecuteMethod != null) ? _canExecuteMethod() : true;
        }

        /// <summary>
        /// Invokes the command
        /// </summary>
        public void Execute()
        {
            _executeMethod();
        }

        bool ICommand.CanExecute(object parameter)
        {
            return CanExecute();
        }

        void ICommand.Execute(object parameter)
        {
            Execute();
        }

        /// <summary>
        /// Fired whenever the value of CanExecute may have changed. Uses
        /// weak events internally.
        /// </summary>
        public event EventHandler CanExecuteChanged
        {
            add
            {
                if (_autoRequery)
                {
                    CommandManager.RequerySuggested += value;
                }
                //Use weak events.
                //Delegates are immutable, so we can't defer the callback to
                //a helper class
                _canExecuteChanged += value.MakeWeak(h => _canExecuteChanged -= h);
            }

            remove
            {
                if (_autoRequery)
                {
                    CommandManager.RequerySuggested -= value;
                }
                //If someone asks to remove their handler, we have to do
                //some extra work since we wrapped it in a weak handler
                EventManager.Remove(ref _canExecuteChanged, value);
            }
        }
        private EventHandler _canExecuteChanged;


        /// <summary>
        /// Allows an external caller to raise the CanExecuteChanged event
        /// </summary>
        public void RaiseCanExecuteChanged()
        {
            OnCanExecuteChanged();
        }

        protected virtual void OnCanExecuteChanged()
        {
            _canExecuteChanged.Raise(this, EventArgs.Empty);
        }



        /// <summary>
        /// Sets the command to listen to changes to the given property and check whether
        /// it can be executed when a change occurs. INotifyPropertyChanged must be correctly implemented
        /// on the target object for this to work.
        /// </summary>
        /// <typeparam name="TObserved">The type of the object whose property we are observing</typeparam>
        /// <typeparam name="TProperty">The type of the property we are observing</typeparam>
        /// <param name="command">The command that will listen for property changes</param>
        /// <param name="observedObject">The object we are observing changes to</param>
        /// <param name="propertyExpression">An expression returning the property that we are observing</param>
        /// <returns>The original (now modifed) command, to allow for simple method chaining</returns>
        public DelegateCommand ListenOn<TObserved,TProperty>( 
            TObserved observedObject, Expression<Func<TObserved, TProperty>> propertyExpression)
            where TObserved : INotifyPropertyChanged
        {
            string propertyName = NotifyChangedHelper.GetPropertyName(propertyExpression);
            Action raiseChanged = () => this.RaiseCanExecuteChanged();

            observedObject.PropertyChanged += delegate(object sender, PropertyChangedEventArgs args)
            {
                if (args.PropertyName == propertyName)
                    raiseChanged.ExecuteOnUI();
            };

            return this;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardFramework\Services\TicketData.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using OneCardFramework.Configuration;
using OneCardFramework.Extensions;
using System.Timers;

namespace OneCardFramework.Services
{
    /// <summary>
    /// Stores authentication data for various services. Valid only for the specific game and service configuration
    /// used to create it.
    /// <remarks>This class is immutable</remarks>
    /// </summary>
    public sealed class TicketData
    {
        internal readonly string RPSTicket;
        internal readonly string UserToken;
        internal readonly string PartnerToken;

        /// <summary>
        /// The unique identifier for the game this ticket was issued for
        /// </summary>
        public readonly uint TitleID;

        /// <summary>
        /// The unique name for the user this ticket was issued for
        /// </summary>
        public readonly string Username;

        /// <summary>
        /// The creation date for this ticket, in UTC time
        /// </summary>
        public readonly DateTime CreationDate;

        /// <summary>
        /// The amount of time this ticket is valid for use with online services
        /// </summary>
        public readonly TimeSpan Lifetime;

        /// <summary>
        /// Gets the expiration date for this ticket, in UTC time
        /// </summary>
        public DateTime ExpirationDate
        {
            get { return CreationDate + Lifetime; }
        }

        /// <summary>
        /// Gets the amount of time left until this ticket is no longer valid
        /// </summary>
        public TimeSpan TimeToExpiration
        {
            get { return IsExpired ? TimeSpan.Zero : ExpirationDate - DateTime.UtcNow; }
        }

        /// <summary>
        /// Gets whether this ticket is expired and thus no longer valid for use with online services. This
        /// is based on the current time.
        /// </summary>
        public bool IsExpired
        {
            get { return isExpired; }
        }
        private bool isExpired = false;

        /// <summary>
        /// Fired when the ticket becomes expired. Occurs on a background thread.
        /// </summary>
        public event EventHandler Expired;


        private Timer timer; //Used for monitoring ticket expiry

        internal TicketData(string username, string rpsTicket, string userToken, string partnerToken, uint titleID, TimeSpan lifetime)
        {
            Username = username;
            RPSTicket = rpsTicket;
            UserToken = userToken;
            PartnerToken = partnerToken;
            TitleID = titleID;

            Lifetime = lifetime;
            CreationDate = DateTime.UtcNow;

            timer = new Timer(Lifetime.TotalMilliseconds);
            timer.Elapsed += RaiseExpiration;
            timer.Start();
        }

        private void RaiseExpiration(object sender, ElapsedEventArgs e)
        {
            isExpired = true;

            Expired.Raise(this, EventArgs.Empty);

            if(timer != null)
                timer.Dispose();
            timer = null;
        }


        /// <summary>
        /// Verifies that a new ticket is a valid, updated replacement for this ticket,
        /// and throws exceptions if it is not.
        /// </summary>
        /// <param name="newTicket"></param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <exception cref="ArgumentException"></exception>
        public void VerifyValidReplacement(TicketData newTicket)
        {
            if (newTicket == null)
                throw new ArgumentNullException("newTicket");

            if (newTicket.IsExpired)
                throw new ArgumentException("Supplied ticket is expired");

            if (this.Username != newTicket.Username)
                throw new ArgumentException("New ticket is for a different user");

            if (this.TitleID != newTicket.TitleID)
                throw new ArgumentException("New ticket has a different TitleID");

            if (newTicket == this)
                throw new ArgumentException("New ticket is this ticket");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\App.xaml.cs ===
﻿using System;
using System.Windows;
using System.Diagnostics;
using OneCardGUI.Framework;
using OneCardGUI.ViewModel;
using OneCardGUI.View;

namespace OneCardGUI
{
    /// <summary>
    /// Interaction logic for App.xaml
    /// </summary>
    public partial class App : Application
    {
        public App()
        {
            Startup += Application_Startup;
            Exit += Application_Exit;

            DispatcherUnhandledException += ExceptionCatchAll;

            InitializeComponent();
        }


        private void Application_Startup(object sender, StartupEventArgs e)
        {
            Console.WriteLine("App Startup");
            Debug.WriteLine("***** Application_Startup *****");

            string path = @"Content/Config.xml";

            Execute.InitializeWithDispatcher(this.Dispatcher);

            MainWindowView window = new MainWindowView();
            MainWindowViewModel viewModel = new MainWindowViewModel(path, this.Dispatcher);

            //When the main view model requests to close, 
            //close the window
            EventHandler handler = null;
            handler = delegate
            {
                viewModel.CloseRequested -= handler;
                window.Close();
            };
            viewModel.CloseRequested += handler;

            window.DataContext = viewModel;
            window.Show();
        }
        
        private void Application_Exit(object sender, ExitEventArgs e)
        {
            Debug.WriteLine("***** Application_Exit *****");
        }



        private void ExceptionCatchAll(object sender, System.Windows.Threading.DispatcherUnhandledExceptionEventArgs args)
        {
            //Last chance to handle exceptions before they push out of the app
            Exception e = args.Exception;

            //Show pretty dialog and let the user choose to either ignore the error
            //or break into the debugger
            ErrorWindow window = new ErrorWindow();
            window.DataContext = e;
            bool? result = window.ShowDialog();

            if (result == null || result == false)
                args.Handled = true;
            else
            {
                Debugger.Launch();
                Debugger.Break();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\Commanding\RelayCommand.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows.Input;

namespace OneCardGUI.Commanding
{
    /// <summary>
    /// Simple ICommand implementation using delegates
    /// </summary>
    public class RelayCommand : ICommand
    {
        private Action<object> executor;
        private Func<object, bool> validator;

        /// <summary>
        /// Creates an ICommand that delegates its operations to the supplied functions
        /// </summary>
        /// <param name="exec">The function to run when the command executes</param>
        /// <param name="canExec">The function to use to determine whether the command can be executed</param>
        public RelayCommand(Action<object> exec, Func<object, bool> canExec)
        {
            if (exec == null)
                throw new ArgumentNullException("exec");
            if (canExec == null)
                throw new ArgumentNullException("canExec");

            executor = exec;
            validator = canExec;
        }



        #region ICommand Members

        public bool CanExecute(object parameter)
        {
            return validator(parameter);
        }

        event EventHandler ICommand.CanExecuteChanged
        {
            add { CommandManager.RequerySuggested += value; }
            remove { CommandManager.RequerySuggested -= value; }
        }

        public void Execute(object parameter)
        {
            executor(parameter);
        }

        public void ForceRefresh()
        {
            CommandManager.InvalidateRequerySuggested();
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\Converters\EnumBoolConverter.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows.Data;
using System.Windows;

namespace OneCardGUI.Converters
{
    public class EnumBoolConverter : IValueConverter
    {
        #region IValueConverter Members

        /// <summary>
        /// Converts from the binding data source (i.e. our backend)  to something the binding target (i.e. the UI) can use
        /// </summary>
        /// <param name="value">The data coming from the source</param>
        /// <param name="targetType">The type in the UI we are converting to</param>
        /// <param name="parameter">The parameter passed to the converter in the UI</param>
        /// <param name="culture"></param>
        /// <returns></returns>
        public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            var paramString = parameter as string;
            Type enumType = value.GetType();

            if (value == null || paramString == null)
                return DependencyProperty.UnsetValue;
            
            //We return a boolean representing whether our parameter string,
            //when converted to the target enum type, matches the incoming value
            object paramValue = Enum.Parse(enumType, paramString);
            return paramValue.Equals(value);
        }

        /// <summary>
        /// Converts from the binding target (i.e. the UI) to something the data source (i.e. our backend) can use
        /// </summary>
        /// <param name="value">The data coming from the target (UI)</param>
        /// <param name="targetType">The type we are converting to (i.e. our backend type)</param>
        /// <param name="parameter">The parameter passed to the converter in the UI</param>
        /// <param name="culture"></param>
        /// <returns></returns>
        public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            var paramString = parameter as string;
            if (value == null || paramString == null)
                return DependencyProperty.UnsetValue;

            return Enum.Parse(targetType, paramString);
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\Controls\LoadingWheel.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;
using System.ComponentModel;

namespace OneCardGUI.Controls
{
    /// <summary>
    /// Follow steps 1a or 1b and then 2 to use this custom control in a XAML file.
    ///
    /// Step 1a) Using this custom control in a XAML file that exists in the current project.
    /// Add this XmlNamespace attribute to the root element of the markup file where it is 
    /// to be used:
    ///
    ///     xmlns:MyNamespace="clr-namespace:OneCardGUI.Controls"
    ///
    ///
    /// Step 1b) Using this custom control in a XAML file that exists in a different project.
    /// Add this XmlNamespace attribute to the root element of the markup file where it is 
    /// to be used:
    ///
    ///     xmlns:MyNamespace="clr-namespace:OneCardGUI.Controls;assembly=OneCardGUI.Controls"
    ///
    /// You will also need to add a project reference from the project where the XAML file lives
    /// to this project and Rebuild to avoid compilation errors:
    ///
    ///     Right click on the target project in the Solution Explorer and
    ///     "Add Reference"->"Projects"->[Browse to and select this project]
    ///
    ///
    /// Step 2)
    /// Go ahead and use your control in the XAML file.
    ///
    ///     <MyNamespace:LoadingWheel/>
    ///
    /// </summary>
    [Description("Represents a custom control meant to indicate that an operation is loading")]
    public class LoadingWheel : Control
    {
        public static readonly DependencyProperty IsLoadingProperty =
            DependencyProperty.Register("IsLoading", typeof(bool), typeof(LoadingWheel));

        public static readonly DependencyProperty AnimationSpeedProperty =
            DependencyProperty.Register("AnimationSpeed", typeof(double), typeof(LoadingWheel));

        public static readonly DependencyProperty FrameRateProperty =
            DependencyProperty.Register("FrameRate", typeof(int?), typeof(LoadingWheel));


        public bool IsLoading
        {
            get { return (bool)GetValue(IsLoadingProperty); }
            set { SetValue(IsLoadingProperty, value); }
        }

        public double AnimationSpeed
        {
            get { return (double)GetValue(AnimationSpeedProperty); }
            set { SetValue(AnimationSpeedProperty, value); }
        }

        public int? FrameRate
        {
            get { return (int)GetValue(FrameRateProperty); }
            set { SetValue(FrameRateProperty, value); }
        }


        static LoadingWheel()
        {
            DefaultStyleKeyProperty.OverrideMetadata(typeof(LoadingWheel), new FrameworkPropertyMetadata(typeof(LoadingWheel)));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\Framework\Execute.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows.Threading;
using System.Threading;

namespace OneCardGUI.Framework
{
    /// <summary>
    /// Helper class for controlling action execution
    /// </summary>
    public static class Execute
    {
        private static Action<Action> _executor = (action) => action();
        private static Action<Action, DispatcherPriority> _priExecutor = (action, priority) => action();
        
        /// <summary>
        /// Configures our system to use the given Dispatcher when attempting to execute
        /// actions on the UI thread
        /// </summary>
        /// <param name="dispatcher">The dispatcher controlling the UI thread</param>
        public static void InitializeWithDispatcher(Dispatcher dispatcher)
        {
            _executor = delegate(Action action)
            {
                if (dispatcher.Thread == Thread.CurrentThread)
                    action();
                else
                    dispatcher.BeginInvoke(action);
            };

            _priExecutor = delegate(Action action, DispatcherPriority priority)
            {
                if (dispatcher.Thread == Thread.CurrentThread)
                    dispatcher.Invoke(action, priority);
                else
                    dispatcher.BeginInvoke(action, priority);
            };
        }

        /// <summary>
        /// Execute an action on the UI thread
        /// </summary>
        /// <param name="action"></param>
        public static void ExecuteOnUI(this Action action)
        {
            _executor(action);
        }

        /// <summary>
        /// Execute an action on the UI thread with the given priority
        /// </summary>
        /// <param name="action"></param>
        /// <param name="priority"></param>
        public static void ExecuteOnUI(this Action action, DispatcherPriority priority)
        {
            _priExecutor(action, priority);
        }

        /// <summary>
        /// Executes an action asyncronously, catching any exceptions and propagating
        /// them to the UI thread
        /// </summary>
        /// <param name="action"></param>
        public static void ExecuteAsyncCatchUI(this Action action)
        {
            Action asyncOp = delegate()
            {
                try
                {
                    action();
                }
                catch (Exception e)
                {
                    Action uiAction = delegate()
                    {
                        throw e;
                    };
                    uiAction.ExecuteOnUI();
                }
            };
            asyncOp.BeginInvoke(null, null);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\View\AllSessionsView.xaml.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;

namespace OneCardGUI.View
{
    /// <summary>
    /// Interaction logic for AllSessionsView.xaml
    /// </summary>
    public partial class AllSessionsView : UserControl
    {
        public AllSessionsView()
        {
            InitializeComponent();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Resources;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Windows;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("OneCardGUI")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

//In order to begin building localizable applications, set 
//<UICulture>CultureYouAreCodingWith</UICulture> in your .csproj file
//inside a <PropertyGroup>.  For example, if you are using US english
//in your source files, set the <UICulture> to en-US.  Then uncomment
//the NeutralResourceLanguage attribute below.  Update the "en-US" in
//the line below to match the UICulture setting in the project file.

//[assembly: NeutralResourcesLanguage("en-US", UltimateResourceFallbackLocation.Satellite)]


[assembly: ThemeInfo(
    ResourceDictionaryLocation.None, //where theme specific resource dictionaries are located
    //(used if a resource is not found in the page, 
    // or application resource dictionaries)
    ResourceDictionaryLocation.SourceAssembly //where the generic resource dictionary is located
    //(used if a resource is not found in the page, 
    // app, or any theme specific resource dictionaries)
)]


// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\Properties\Settings.Designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace OneCardGUI.Properties {
    
    
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "10.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {
        
        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
        
        public static Settings Default {
            get {
                return defaultInstance;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\View\CreateSessionView.xaml.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;

namespace OneCardGUI.View
{
    /// <summary>
    /// Interaction logic for CreateSessionView.xaml
    /// </summary>
    public partial class CreateSessionView : UserControl
    {
        public CreateSessionView()
        {
            InitializeComponent();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\Framework\NotifyChangedHelper.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Linq.Expressions;
using System.ComponentModel;
using System.Reflection;

namespace OneCardGUI.Framework
{
    public static class NotifyChangedHelper
    {
        /// <summary>
        /// Extracts the property referred to in an expression
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <typeparam name="TProperty"></typeparam>
        /// <param name="expression"></param>
        /// <returns></returns>
        public static string GetPropertyName<T, TProperty>(Expression<Func<T, TProperty>> expression)
            where T : INotifyPropertyChanged
        {
            if (expression == null)
                throw new ArgumentNullException("expression");

            var lambda = expression as LambdaExpression;
            MemberExpression memberExpression = null;
            if (lambda.Body is UnaryExpression)
            {
                var unaryExpression = lambda.Body as UnaryExpression;
                memberExpression = unaryExpression.Operand as MemberExpression;
            }
            else
            {
                memberExpression = lambda.Body as MemberExpression;
            }

            if (memberExpression == null)
                throw new ArgumentException("Please provide a lambda expression like 'n => n.PropertyName'");

            MemberInfo memberInfo = memberExpression.Member;
            
            if (string.IsNullOrEmpty(memberInfo.Name))
                throw new ArgumentException("'expression' did not provide a property name");

            return memberInfo.Name;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\Properties\Resources.Designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace OneCardGUI.Properties {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("OneCardGUI.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\View\ErrorWindow.xaml.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Shapes;

namespace OneCardGUI.View
{
    /// <summary>
    /// Interaction logic for ErrorWindow.xaml
    /// </summary>
    public partial class ErrorWindow : Window
    {
        public ErrorWindow()
        {
            InitializeComponent();
        }

        private void Ignore_Click(object sender, RoutedEventArgs e)
        {
            DialogResult = false;
        }

        private void Debug_Click(object sender, RoutedEventArgs e)
        {
            DialogResult = true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\View\GameSeatView.xaml.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;

namespace OneCardGUI.View
{
    /// <summary>
    /// Interaction logic for GameSeatView.xaml
    /// </summary>
    public partial class GameSeatView : UserControl
    {
        public GameSeatView()
        {
            InitializeComponent();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\View\MainMenuView.xaml.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;

namespace OneCardGUI.View
{
    /// <summary>
    /// Interaction logic for MainMenuView.xaml
    /// </summary>
    public partial class MainMenuView : UserControl
    {
        public MainMenuView()
        {
            InitializeComponent();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\View\NotificationPopupView.xaml.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;

using AsyncMultiplayer.NotificationService;

namespace OneCardGUI.View
{
    /// <summary>
    /// Interaction logic for NotificationPopup.xaml
    /// </summary>
    public partial class NotificationPopupView : UserControl
    {
        public NotificationPopupView()
        {
            InitializeComponent();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\View\MainWindowView.xaml.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;
using System.Windows.Media.Animation;
using OneCardGUI.ViewModel;

namespace OneCardGUI.View
{
    /// <summary>
    /// Interaction logic for MainWindow.xaml
    /// </summary>
    public partial class MainWindowView : Window
    {
        private Storyboard _showPopupStoryboard;
        private Storyboard _keepPopupStoryboard;
        private Storyboard _hidePopupStoryboard;
        

        public MainWindowView()
        {
            InitializeComponent();

            ContentRegion.SizeChanged += new SizeChangedEventHandler(ContentRegion_Changed);
            ContentRegion.LayoutUpdated += new EventHandler(ContentRegion_Changed);

            Loaded += new RoutedEventHandler(MainWindowView_Loaded);
        }

        void MainWindowView_Loaded(object sender, RoutedEventArgs e)
        {
            _showPopupStoryboard = (Storyboard)this.Resources["ShowPopupStory"];
            _keepPopupStoryboard = (Storyboard)this.Resources["KeepPopupStory"];
            _hidePopupStoryboard = (Storyboard)this.Resources["HidePopupStory"];
        }


        #region Window State
        public void Minimize()
        {
            WindowState = System.Windows.WindowState.Minimized;
        }

        public void Maximize()
        {
            WindowState = System.Windows.WindowState.Maximized;
        }

        private void DragWindow(object sender, MouseButtonEventArgs e)
        {
            DragMove();
        }

        private void MinimizeWindow(object sender, RoutedEventArgs e)
        {
            Minimize();
        }

        private void CloseWindow(object sender, RoutedEventArgs e)
        {
            Close();
        }
        #endregion


        #region Popup Notifier Animation

        void ContentRegion_Changed(object sender, EventArgs e)
        {
            MovePopupBox();
        }

        private void MovePopupBox()
        {
            GeneralTransform contentTransform = ContentRegion.TransformToAncestor(this);
            Point contentBR = contentTransform.Transform(new Point(ContentRegion.ActualWidth, ContentRegion.ActualHeight));


            PopupRegion.Margin = new Thickness(
                ContentRegion.ActualWidth - PopupRegion.ActualWidth + 25,
                contentBR.Y, 0, 0);
        }

        private void PopupItem_DataContextChanged(object sender, DependencyPropertyChangedEventArgs e)
        {
            if (e.NewValue != null)
            {
                _showPopupStoryboard.Begin(PopupRegion, HandoffBehavior.SnapshotAndReplace);
            }
            else
            {
                _showPopupStoryboard.Stop(PopupRegion);
                _keepPopupStoryboard.Stop(PopupRegion);
                _hidePopupStoryboard.Stop(PopupRegion);
            }
        }

        private void ShowPopup_Completed(object sender, EventArgs e)
        {
            _keepPopupStoryboard.Begin(PopupRegion, HandoffBehavior.SnapshotAndReplace);
        }

        private void KeepPopup_Completed(object sender, EventArgs e)
        {
            _hidePopupStoryboard.SpeedRatio = 1;
            _hidePopupStoryboard.Begin(PopupRegion, HandoffBehavior.SnapshotAndReplace);
        }

        private void HidePopup_Completed(object sender, EventArgs e)
        {
            ClosePopup();
        }

        private void ClosePopup_Click(object sender, RoutedEventArgs e)
        {
            _showPopupStoryboard.Stop(PopupRegion);
            _keepPopupStoryboard.Stop(PopupRegion);
            _hidePopupStoryboard.Stop(PopupRegion);

            _hidePopupStoryboard.SpeedRatio = 2;
            _hidePopupStoryboard.Begin(PopupRegion, HandoffBehavior.SnapshotAndReplace);
        }

        private void ClosePopup()
        {
            PopupItemViewModel vm = PopupItem.DataContext as PopupItemViewModel;
            if (vm != null)
            {
                vm.CloseCommand.Execute(null);
            }
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\View\SeatView.xaml.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;

namespace OneCardGUI.View
{
    /// <summary>
    /// Interaction logic for UserInfoPane.xaml
    /// </summary>
    public partial class SeatView : UserControl
    {
        public SeatView()
        {
            InitializeComponent();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\View\OneCardGameView.xaml.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;

using OneCardGUI.ViewModel;

namespace OneCardGUI.View
{
    /// <summary>
    /// Interaction logic for OneCardGameView.xaml
    /// </summary>
    public partial class OneCardGameView : UserControl
    {
        public OneCardGameView()
        {
            InitializeComponent();
        }

        private void btnInvite_Click(object sender, RoutedEventArgs e)
        {
            ShowInvite();
        }

        private void btnInviteSend_Click(object sender, RoutedEventArgs e)
        {
            SendInvite();
            HideInvite();
        }

        private void btnInviteCancel_Click(object sender, RoutedEventArgs e)
        {
            HideInvite();
        }


        private void SendInvite()
        {
            OneCardGameViewModel vm = this.DataContext as OneCardGameViewModel;

            if (vm != null)
            {
                vm.SendInvite(inviteRecipients.Text, inviteMessage.Text, inviteSendFriendRequest.IsChecked.Value);
            }
        }


        private void ShowInvite()
        {
            InviteDialog.Visibility = System.Windows.Visibility.Visible;
            inviteRecipients.Focus();
        }

        private void HideInvite()
        {
            InviteDialog.Visibility = System.Windows.Visibility.Collapsed;

            inviteRecipients.Text = string.Empty;
            inviteMessage.Text = string.Empty;
            inviteSendFriendRequest.IsChecked = false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\View\ServiceConfigurationsView.xaml.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;

namespace OneCardGUI.View
{
    /// <summary>
    /// Interaction logic for ServiceConfigurationsView.xaml
    /// </summary>
    public partial class ServiceConfigurationsView : UserControl
    {
        public ServiceConfigurationsView()
        {
            InitializeComponent();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\View\ServiceExceptionView.xaml.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;

namespace OneCardGUI.View
{
    /// <summary>
    /// Interaction logic for ServiceExceptionView.xaml
    /// </summary>
    public partial class ServiceExceptionView : UserControl
    {
        public ServiceExceptionView()
        {
            InitializeComponent();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\View\SessionDetailView.xaml.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;
using System.Diagnostics;

namespace OneCardGUI.View
{
	/// <summary>
    /// Interaction logic for SessionDetailView.xaml
	/// </summary>
	public partial class SessionDetailView : UserControl
	{
		public SessionDetailView()
		{
			this.InitializeComponent();
		}

        private void Button_Error(object sender, ValidationErrorEventArgs e)
        {
            Trace.WriteLine("Button has exception");
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\View\SignInView.xaml.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;

namespace OneCardGUI.View
{
    /// <summary>
    /// Interaction logic for SignInView.xaml
    /// </summary>
    public partial class SignInView : UserControl
    {
        public SignInView()
        {
            InitializeComponent();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\View\SessionSummaryView.xaml.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;

namespace OneCardGUI.View
{
	/// <summary>
	/// Interaction logic for SessionSummary.xaml
	/// </summary>
	public partial class SessionSummaryView : UserControl
	{
        public SessionSummaryView()
		{
			InitializeComponent();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\View\TraceView.xaml.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;

namespace OneCardGUI.View
{
    /// <summary>
    /// Interaction logic for TraceView.xaml
    /// </summary>
    public partial class TraceView : UserControl
    {
        public TraceView()
        {
            InitializeComponent();

            MainText.PreviewTextInput += MainText_PreviewTextChanged;
            MainText.TextChanged += MainText_TextChanged;
        }

        int selectionIndex = 0;

        private void MainText_PreviewTextChanged(object sender, TextCompositionEventArgs e)
        {
            selectionIndex = MainText.SelectionStart;
        }

        private void MainText_TextChanged(object sender, TextChangedEventArgs e)
        {
            
            //if (false == (MainText.IsFocused || MainText.IsMouseOver ||
            //              MainTextScroll.IsFocused || MainTextScroll.IsMouseOver ||
            //              MainTextRegion.IsFocused || MainTextRegion.IsMouseOver))
                //MainTextScroll.ScrollToEnd();
            //MainText.ScrollToLine(selectionIndex);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\ViewModel\AllNotificationsViewModel.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Collections.ObjectModel;
using OneCardFramework;
using OneCardFramework.Game;
using OneCardFramework.Services;
using OneCardFramework.Configuration;
using AsyncMultiplayer.NotificationService;
using OneCardFramework.Cache;
using OneCardGUI.Framework;
using System.Diagnostics;
using OneCardGUI.Commanding;
using System.Windows.Input;

namespace OneCardGUI.ViewModel
{
    /// <summary>
    /// Stores a collection of view models representing the notifications in the local
    /// cache, updating based on changes to the cache
    /// </summary>
    public class AllNotificationsViewModel : ViewModelBase
    {
        #region Public Interface

        /// <summary>
        /// A collection of view models representing the current set of notifications
        /// stored in the local cache
        /// </summary>
        public ReadOnlyObservableCollection<NotificationViewModel> CurrentNotifications
        {
            get { return _notificationsReadOnly; }
        }
        private ReadOnlyObservableCollection<NotificationViewModel> _notificationsReadOnly;
        private ObservableCollection<NotificationViewModel> _notifications;

        #endregion

        private INotificationSystem _notificationSystem;
        private ISessionSystem _sessionSystem;


        public AllNotificationsViewModel(INotificationSystem notifSystem, ISessionSystem sessionSystem)
        {
            if (notifSystem == null)
                throw new ArgumentNullException("notifSystem");
            if (sessionSystem == null)
                throw new ArgumentNullException("sessionSystem");

            _notificationSystem = notifSystem;
            _sessionSystem = sessionSystem;

            _notifications = new ObservableCollection<NotificationViewModel>();
            _notificationsReadOnly = new ReadOnlyObservableCollection<NotificationViewModel>(_notifications);

            //Grab everything in the cache and start listening for changes
            foreach (Notification n in _notificationSystem.GetAllNotifications())
            {
                AddNotification(n);
            }
            _notificationSystem.NotificationAdded += HandleNotificationAdded;
            _notificationSystem.NotificationRemoved += HandleNotificationRemoved;
        }

        protected override void OnDispose()
        {
            _notificationSystem.NotificationAdded -= HandleNotificationAdded;
            _notificationSystem.NotificationRemoved -= HandleNotificationRemoved;

            base.OnDispose();
        }


        #region Event Handling
        private void HandleNotificationAdded(object sender, NotificationEventArgs args)
        {
            //Make sure we execute the operation on the UI thread
            Action op = delegate
            {
                AddNotification(args.Notification);
            };
            op.ExecuteOnUI();
        }

        private void HandleNotificationRemoved(object sender, NotificationEventArgs args)
        {
            //Make sure we execute the operation on the UI thread
            Action op = delegate()
            {
                RemoveNotification(args.Notification);
            };
            op.ExecuteOnUI();
        }
        #endregion

        #region Helpers
        /// <summary>
        /// Generates a view model to wrap a notification and adds it to our set. Must
        /// be called on the UI thread.
        /// </summary>
        /// <param name="notification"></param>
        private void AddNotification(Notification notification)
        {
            NotificationViewModel newViewModel;

            if (notification is InvitationNotification)
                newViewModel = new InviteNotificationViewModel(notification, _notificationSystem, _sessionSystem);
            else
                newViewModel = new NotificationViewModel(notification, _notificationSystem, _sessionSystem);

            _notifications.Add(newViewModel);
        }

        /// <summary>
        /// Removes the first view model containing a notification matching the one supplied
        /// (Matches based on ID). Must be called on the UI thread.
        /// </summary>
        /// <param name="notification"></param>
        private void RemoveNotification(Notification notification)
        {
            var toRemove = _notifications.FirstOrDefault(cur => cur.Id == notification.Id);
            if (toRemove != null)
                _notifications.Remove(toRemove);
        }
        #endregion



        public bool IsRefreshing
        {
            get { return _isRefreshing; }
            set { _isRefreshing = value; OnPropertyChanged("IsRefreshing"); }
        }
        private bool _isRefreshing;


        public ICommand RefreshCommand
        {
            get
            {
                if (_refreshCommand == null)
                    _refreshCommand = new DelegateCommand(
                        () => Refresh(),
                        () => CanRefresh,
                        false).ListenOn(this, vm => vm.IsRefreshing);
                return _refreshCommand;
            }
        }
        private DelegateCommand _refreshCommand;


        public bool CanRefresh
        {
            get { return IsRefreshing == false; }
        }

        public void Refresh()
        {
            IsRefreshing = true;

            Action asyncOp = delegate
            {
                _notificationSystem.LoadAllNotifications();
                IsRefreshing = false;
            };
            asyncOp.BeginInvoke(null, null);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\ViewModel\GameSeatViewModel.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using AsyncMultiplayer.SessionCommon;
using OneCardFramework.Game;
using OneCardGUI.Commanding;
using System.Windows.Input;

namespace OneCardGUI.ViewModel
{
    public class GameSeatViewModel : SeatViewModel
    {
        public bool IsActivePlayer
        {
            get { return _session.ActiveSeatIndex == Index; }
        }

        public bool IsOwner
        {
            get { return _session.OwnerSeatIndex == Index; }
        }


        private GameSession _session;

        public GameSeatViewModel(SeatInfo seat, GameSession session)
            : base(seat)
        {
            _session = session;

            _session.ActiveIndexChanged += HandleActiveIndexChanged;
            _session.OwnerIndexChanged += HandleOwnerIndexChanged;
        }

        #region Event Handlers

        private void HandleActiveIndexChanged(object sender, IndexChangedEventArgs args)
        {
            OnPropertyChanged("IsActivePlayer");
        }

        private void HandleOwnerIndexChanged(object sender, IndexChangedEventArgs args)
        {
            OnPropertyChanged("IsOwner");
        }

        #endregion

        #region Commands

        public ICommand NudgeCommand
        {
            get
            {
                if (_nudgeCommand == null)
                    _nudgeCommand = new DelegateCommand(
                            () => Nudge(),
                            () => CanNudge,
                            false
                        ).ListenOn(this, obj => obj.IsActivePlayer);
                return _nudgeCommand;
            }
        }
        private DelegateCommand _nudgeCommand;

        #endregion

        public bool CanNudge
        {
            get { return IsActivePlayer; }
        }

        public void Nudge()
        {
            _session.NudgeActiveUser();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\ViewModel\CreateOneCardSessionViewModel.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using OneCardFramework.Game;
using OneCardFramework.Extensions;
using OneCard.Game;
using OneCardFramework.Cache;
using OneCardGUI.Commanding;
using System.Windows.Input;

using AsyncMultiplayer.SessionCommon;

namespace OneCardGUI.ViewModel
{
    public class CreateOneCardSessionViewModel : ScreenViewModel
    {
        #region Published Properties
        public string SessionName
        {
            get { return _gameConfig.DisplayName; }
            set { _gameConfig.DisplayName = value; OnPropertyChanged("SessionName"); }
        }

        public int NumPlayers
        {
            get { return _gameConfig.TotalSeatsAvailable; }
            set { _gameConfig.TotalSeatsAvailable = value; OnPropertyChanged("NumPlayers"); }
        }

        public int Variant
        {
            get { return _gameConfig.Variant; }
            set { _gameConfig.Variant = value; OnPropertyChanged("Variant"); }
        }

        public int InactivityWarningInterval
        {
            get { return _gameConfig.InactivityWarning.Interval; }
            set { _gameConfig.InactivityWarning.Interval = value; OnPropertyChanged("InactivityWarningInterval"); }
        }
                
        public int InactivityMaxNudges
        {
            get { return _gameConfig.InactivityWarning.MaxNumberOfNudges; }
            set { _gameConfig.InactivityWarning.MaxNumberOfNudges = value; OnPropertyChanged("InactivityMaxNudges"); }
        }

        public InactivityWarningAction InactivityAction
        {
            get { return _gameConfig.InactivityWarning.Action; }
            set { _gameConfig.InactivityWarning.Action = value; OnPropertyChanged("InactivityAction"); }
        }
        #endregion

        private OneCardConfig _gameConfig;
        private ISessionSystem _sessionSystem;


        public CreateOneCardSessionViewModel(ScreenConductor screenConductor, ISessionSystem sessionSystem)
            : base(screenConductor)
        {
            _sessionSystem = sessionSystem;
            _gameConfig = new OneCardConfig();

            //Set some defaults
            _gameConfig.InactivityWarning.Interval = 1;
            _gameConfig.InactivityWarning.MaxNumberOfNudges = 3;
            _gameConfig.InactivityWarning.Action = InactivityWarningAction.WarnOnly;
            _gameConfig.TotalSeatsAvailable = 4;
            _gameConfig.CanRemoveEmptySeats = true;
        }

        #region Commands

        public ICommand CreateSessionCommand
        {
            get
            {
                if (_createSessionCommand == null)
                    _createSessionCommand = new RelayCommand(param => CreateSession(), param => CanCreateSession);
                return _createSessionCommand;
            }
        }
        private ICommand _createSessionCommand;

        #endregion

        public bool CanCreateSession
        {
            get { return _sessionSystem.SupportsConfig(_gameConfig.GetType()); }
        }

        public void CreateSession()
        {
            string sessionID = _sessionSystem.CreateSession(_gameConfig);

            //Remove this menu from the history
            this.GoBack();

            _sessionSystem.RequestPlay(sessionID);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\ViewModel\InviteNotificationViewModel.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using AsyncMultiplayer.NotificationService;
using OneCardFramework.Cache;
using OneCardGUI.Framework;

namespace OneCardGUI.ViewModel
{
    /// <summary>
    /// A view model for an individual invitation-type notification
    /// </summary>
    public class InviteNotificationViewModel : NotificationViewModel
    {
        public bool IsFriendRequest
        {
            get { return _invite.FriendRequest; }
        }

        InvitationNotification _invite;

        public InviteNotificationViewModel(Notification notification, INotificationSystem notifSystem, ISessionSystem sessionSystem)
            : base(notification, notifSystem, sessionSystem)
        {
            if ((notification is InvitationNotification) == false)
                throw new ArgumentException("Notification is not an Invite", "notification");

            _invite = (InvitationNotification)notification;
            _sessionSystem = sessionSystem;
        }


        public override void Apply(Notification newNotification)
        {
            if ((newNotification is InvitationNotification) == false)
                throw new ArgumentException("Notification is not an Invite", "notification");

            _invite = (InvitationNotification)newNotification;

            base.Apply(newNotification);
        }

        #region Actions

        public bool CanJoinGame()
        {
            return true;
        }

        public void JoinGame()
        {
            Action asyncOp = delegate
            {
                _sessionSystem.JoinSession(_invite.SessionId);
            };
            asyncOp.ExecuteAsyncCatchUI();
        }


        public override void Play()
        {
            Action asyncOp = delegate
            {
                _sessionSystem.JoinSession(_invite.SessionId);
                _sessionSystem.RequestPlay(_invite.SessionId);
            };
            asyncOp.ExecuteAsyncCatchUI();
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\ViewModel\AllSessionsViewModel.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Collections.ObjectModel;
using OneCardGUI.Commanding;
using System.Windows.Input;
using OneCardFramework.Cache;
using OneCardGUI.Framework;
using AsyncMultiplayer.SessionCommon;

namespace OneCardGUI.ViewModel
{
    public class AllSessionsViewModel : ScreenViewModel
    {
        #region Public Interface
        public ReadOnlyObservableCollection<SessionSummaryViewModel> SessionSummaries
        {
            get { return _summariesReadOnly; }
        }
        private ReadOnlyObservableCollection<SessionSummaryViewModel> _summariesReadOnly;
        private ObservableCollection<SessionSummaryViewModel> _summaries;

        public SessionSummaryViewModel SelectedSessionSummary
        {
            get { return _selectedSessionSummary; }
            set
            {
                if (value != _selectedSessionSummary)
                {
                    _selectedSessionSummary = value;
                    OnPropertyChanged("SelectedSessionSummary");

                    //Change our detail info to match the new selection
                    if (_selectedSessionSummary != null)
                        SelectDetail(_selectedSessionSummary.SessionID);
                    else
                        SelectedSessionDetail = null;
                }
            }
        }
        private SessionSummaryViewModel _selectedSessionSummary;

        public SessionDetailViewModel SelectedSessionDetail
        {
            get { return _selectedSessionDetail; }
            private set
            {
                if (value != _selectedSessionDetail)
                {
                    _selectedSessionDetail = value;
                    OnPropertyChanged("SelectedSessionDetail");
                }
            }
        }
        private SessionDetailViewModel _selectedSessionDetail;
        #endregion

        private ISessionSystem _sessionSystem;
        private Dictionary<string, SessionDetailViewModel> _sessionDetails;

        public AllSessionsViewModel(ScreenConductor conductor, ISessionSystem system)
            : base(conductor)
        {
            _sessionSystem = system;

            _sessionDetails = new Dictionary<string, SessionDetailViewModel>();
            _summaries = new ObservableCollection<SessionSummaryViewModel>();
            _summariesReadOnly = new ReadOnlyObservableCollection<SessionSummaryViewModel>(_summaries);

            var currentSummaries = system.GetAllSummaries(false);
            foreach (SessionEntry entry in currentSummaries)
            {
                AddSummary(entry);
            }
            _sessionSystem.SummaryAdded += HandleSummaryAdded;
            _sessionSystem.SummaryRemoved += HandleSummaryRemoved;
            _sessionSystem.DetailRemoved += HandleDetailRemoved;
        }

        protected override void OnDispose()
        {
            base.OnDispose();
            
            _sessionSystem.SummaryAdded -= HandleSummaryAdded;
            _sessionSystem.SummaryRemoved -= HandleSummaryRemoved;
            _sessionSystem.DetailRemoved -= HandleDetailRemoved;
        }

        #region Session System Event Handlers

        private void HandleSummaryAdded(object sender, SessionSummaryEventArgs args)
        {
            Action op = delegate
            {
                AddSummary(args.Summary);
            };
            op.ExecuteOnUI();
        }

        private void HandleSummaryRemoved(object sender, SessionSummaryEventArgs args)
        {
            Action op = delegate
            {
                var toRemove = _summaries.FirstOrDefault(x => x.SessionID == args.Summary.SessionID);
                if (toRemove != null)
                {
                    _summaries.Remove(toRemove);

                    if (SelectedSessionSummary == toRemove)
                        SelectedSessionSummary = null;
                }
            };
            op.ExecuteOnUI();
        }

        private void HandleDetailRemoved(object sender, SessionDetailEventArgs args)
        {
            Action op = delegate
            {
                SessionDetailViewModel detail;

                if (_sessionDetails.TryGetValue(args.Detail.SessionID, out detail))
                {
                    _sessionDetails.Remove(args.Detail.SessionID);

                    if (SelectedSessionDetail == detail)
                        SelectedSessionDetail = null;
                }
            };
            op.ExecuteOnUI();
        }

        #endregion



        private void AddSummary(SessionEntry summary)
        {
            _summaries.Add(new SessionSummaryViewModel(summary, _sessionSystem));
        }



        private void SelectDetail(string sessionID)
        {
            SessionDetailViewModel detail = null;

            if (!string.IsNullOrEmpty(sessionID) && _sessionDetails.TryGetValue(sessionID, out detail) == false)
            {
                detail = new SessionDetailViewModel(_selectedSessionSummary.SessionID, _sessionSystem);
                _sessionDetails.Add(sessionID, detail);
            }

            SelectedSessionDetail = detail;
        }


        #region Commands

        public ICommand RefreshCommand
        {
            get
            {
                if (_refreshCommand == null)
                    _refreshCommand = new DelegateCommand(
                        () => Refresh(),
                        () => CanRefresh, 
                        true);

                return _refreshCommand;
            }
        }
        private DelegateCommand _refreshCommand;

        #endregion

        public bool CanRefresh
        {
            get { return _sessionSystem.IsLoadingSummaries == false; }
        }

        public void Refresh()
        {
            Action op = delegate
            {
                _sessionSystem.LoadAllSummaries();
                Action updateUI = () =>_refreshCommand.RaiseCanExecuteChanged();
                updateUI.ExecuteOnUI();
            };
            op.BeginInvoke(null, null);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\ViewModel\MainMenuViewModel.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using OneCardFramework.Cache;
using System.Windows.Input;
using OneCardGUI.Commanding;

namespace OneCardGUI.ViewModel
{
    public class MainMenuViewModel : ViewModelBase
    {
        private ScreenConductor _screenConductor;
        private ISessionSystem _sessionSystem;
        private INotificationSystem _notifSystem;

        public MainMenuViewModel(ScreenConductor conductor, INotificationSystem notifSystem, 
            ISessionSystem sessionSystem)
        {
            _screenConductor = conductor;
            _notifSystem = notifSystem;
            _sessionSystem = sessionSystem;

            _allNotifications = new AllNotificationsViewModel(notifSystem, sessionSystem);
        }


        public AllNotificationsViewModel AllNotifications
        {
            get { return _allNotifications; }
        }
        private AllNotificationsViewModel _allNotifications;

        #region Commands
        public ICommand CreateOneCardSessionCommand
        {
            get
            {
                if (_createOneCardSessionCommand == null)
                    _createOneCardSessionCommand = new RelayCommand(param => CreateOneCardSession(), param => true);
                return _createOneCardSessionCommand;
            }
        }
        private ICommand _createOneCardSessionCommand;

        public ICommand ViewSessionsCommand
        {
            get
            {
                if (_viewSessionsCommand == null)
                    _viewSessionsCommand = new RelayCommand(param => ViewSessions(), param => true);
                return _viewSessionsCommand;
            }
        }
        private ICommand _viewSessionsCommand;
        #endregion


        public void CreateOneCardSession()
        {
            var createScreen = new CreateOneCardSessionViewModel(_screenConductor, _sessionSystem);
            _screenConductor.SetActive(createScreen);
        }

        public void ViewSessions()
        {
            var sessionsScreen = new AllSessionsViewModel(_screenConductor, _sessionSystem);
            _screenConductor.SetActive(sessionsScreen);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\ViewModel\GameSessionViewModel.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using OneCardFramework.Game;
using OneCardFramework.Cache;
using AsyncMultiplayer.SessionCommon;
using System.Collections.ObjectModel;
using OneCardGUI.Framework;
using System.Windows.Input;
using OneCardGUI.Commanding;

namespace OneCardGUI.ViewModel
{
    public class GameSessionViewModel : ScreenViewModel
    {
        public ReadOnlyObservableCollection<GameSeatViewModel> Players
        {
            get { return _playersReadOnly; }
        }
        private ReadOnlyObservableCollection<GameSeatViewModel> _playersReadOnly;
        protected ObservableCollection<GameSeatViewModel> _players;


        public SessionDetailViewModel SessionDetail
        {
            get;
            protected set;
        }

        public ModifySessionViewModel ModifySessionViewModel
        {
            get;
            protected set;
        }

        public bool IsGameOver
        {
            get { return _session.IsGameOver; }
        }

        public bool IsMyTurn
        {
            get { return _session.IsMyTurn && !_session.IsGameOver; }
        }


        private ISessionSystem _sessionSystem;
        private GameSession _session;
        private AutoLoader _sessionAutoLoader;



        public GameSessionViewModel(ScreenConductor conductor, GameSession session, ISessionSystem sessionSystem)
            : base(conductor)
        {
            _session = session;
            _sessionSystem = sessionSystem;


            SessionDetail = new SessionDetailViewModel(_session.SessionState, _sessionSystem);
            ModifySessionViewModel = new ModifySessionViewModel(_session);

            _session.PlayerLeft += HandlePlayerLeft;
            _session.PlayerJoined += HandlePlayerJoined;
            _session.Updated += HandleSessionUpdated;

            _sessionAutoLoader = new AutoLoader("Game Session AutoLoader", delegate
            {
                _session.Update();
            });


            _players = new ObservableCollection<GameSeatViewModel>();
            _playersReadOnly = new ReadOnlyObservableCollection<GameSeatViewModel>(_players);
            foreach (var seat in _session.SessionState.Seats)
            {
                AddPlayer(seat);
            }
        }

        protected virtual void AddPlayer(SeatInfo player)
        {
            _players.Add(new GameSeatViewModel(player, _session));
        }

        protected virtual void RemovePlayer(SeatInfo player)
        {
            var found = _players.FirstOrDefault(p => p.Seat.Profile.PublicToken == player.Profile.PublicToken);

            if (found != null)
                _players.Remove(found);
        }

        #region Event Handlers

        private void HandlePlayerJoined(object sender, SeatEventArgs args)
        {
            Action uiAction = delegate
            {
                AddPlayer(args.Seat);
            };
            uiAction.ExecuteOnUI();
        }

        private void HandlePlayerLeft(object sender, SeatEventArgs args)
        {
            Action uiAction = delegate
            {
                RemovePlayer(args.Seat);
            };
            uiAction.ExecuteOnUI();
        }

        private void HandleSessionUpdated(object sender, EventArgs args)
        {
            Action uiAction = delegate
            {
                SessionDetail.Refresh(_session.SessionState);
                NotifyAllProperties();
            };
            uiAction.ExecuteOnUI();
        }
        #endregion



        public override void NotifyActive()
        {
            base.NotifyActive();

            _sessionAutoLoader.StartAutoLoad(TimeSpan.FromSeconds(7));
        }

        public override void NotifyHidden()
        {
            base.NotifyHidden();

            _sessionAutoLoader.StopAutoLoad();
        }



        #region Refresh
        public ICommand RefreshGameCommand
        {
            get
            {
                if (_refreshGameCommand == null)
                    _refreshGameCommand = new RelayCommand(param => RefreshGame(), param => CanRefreshGame);
                return _refreshGameCommand;
            }
        }
        private ICommand _refreshGameCommand;

        public bool IsRefreshing
        {
            get { return _isRefreshing; }
            set { _isRefreshing = value; OnPropertyChanged("IsRefreshing"); }
        }
        private bool _isRefreshing;

        public bool CanRefreshGame
        {
            get { return _isRefreshing == false; }
        }

        public void RefreshGame()
        {
            Action asyncOp = delegate
            {
                try
                {
                    _session.Update();
                }
                finally { IsRefreshing = false; }
            };
            asyncOp.ExecuteAsyncCatchUI();
        }
        #endregion

        #region Invite

        public void SendInvite(string recipients, string message, bool makeFriends)
        {
            Action asyncOp = delegate
            {
                _session.SendInvite(recipients, message, makeFriends);
            };
            asyncOp.ExecuteAsyncCatchUI();
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\ViewModel\MainWindowViewModel.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;
using OneCardFramework.Configuration;
using OneCardFramework.Game;
using OneCard.Game;
using OneCardFramework.Services;
using OneCardGUI.Framework;
using OneCardFramework.Cache;
using System.Threading;
using System.Windows;
using System.Windows.Threading;
using AsyncMultiplayer.NotificationService;
using System.Windows.Input;
using OneCardGUI.Commanding;

namespace OneCardGUI.ViewModel
{
    public class MainWindowViewModel : WorkspaceViewModel
    {
        public ScreenConductor Conductor
        {
            get { return _screenConductor; }
        }

        public TraceViewModel TraceSystem
        {
            get { return _traceSystem; }
        }

        public PopupNotifierViewModel PopupNotifier
        {
            get { return _notifier; }
        }

        public User ActiveUser
        {
            get { return _user; }
            private set { _user = value; OnPropertyChanged("ActiveUser"); }
        }
        private User _user;

        private ScreenConductor _screenConductor;
        private TraceViewModel _traceSystem;
        private PopupNotifierViewModel _notifier;
        private ConfigurationStore _configStore;
        private List<object> _eventHandlers = new List<object>();

        private TimeSpan _notificationsInterval = TimeSpan.FromSeconds(15);



        public MainWindowViewModel(string pathToConfig, Dispatcher dispatcher)
        {
            _configStore = new ConfigurationStore(pathToConfig);
            _screenConductor = new ScreenConductor();
            _traceSystem = new TraceViewModel();
            _notifier = new PopupNotifierViewModel(dispatcher);


            //Start with required sign in dialog
            SignInViewModel signInViewModel = new SignInViewModel(_configStore);
            signInViewModel.SignInCompleted += HandleSignIn;
            Conductor.SetActive(signInViewModel);
        }






        private void HandleSignIn(object sender, SignInCompletedEventArgs args)
        {
            _eventHandlers.Clear();

            ActiveUser = args.SignedInUser;
            ServicesConfiguration config = args.Configuration;
            MultiplayerServiceConfig multiplayerConfig = config.MultiplayerServicesConfiguration;

            //Create our local caches based on the user and config
            NotificationStore notificationSystem = new NotificationStore(ActiveUser, multiplayerConfig);
            ISessionSystem sessionSystem = new SessionStoreCustom<OneCardConfig, OneCardGame>(ActiveUser, multiplayerConfig, OneCardGame.GameInitializer, OneCardGame.GameBuilder);
            
            sessionSystem.PlayRequested += HandlePlayRequested;

            //Load session data in the background
            
            Action loadSummariesAsync = delegate
            {
                Trace.TraceInformation("Loading inital set of session summaries asynchronously");
                sessionSystem.LoadAllSummaries();
            };
            loadSummariesAsync.ExecuteAsyncCatchUI();

            //Startup notifications auto-loader
            Action loadNotificationsAsync = delegate
            {
                Trace.WriteLine("Loading inital set of notifications asynchronously");
                notificationSystem.LoadAllNotifications();
                SetupNotifier(notificationSystem, sessionSystem); //Do this after initial load to prevent a bazillion popups
            };
            loadNotificationsAsync.ExecuteAsyncCatchUI();
            notificationSystem.StartAutoLoad(_notificationsInterval);
            
            //Show main menu
            Conductor.ClearAll();
            GC.Collect();
            Conductor.SetActive(new MainMenuViewModel(_screenConductor, notificationSystem, sessionSystem));
        }


        private void SetupNotifier(INotificationSystem notifSystem, ISessionSystem sessionSystem)
        {
            Trace.TraceInformation("Linking notifications system to UI notifier");

            //Once we've imported the majority of notifications (so we don't have endless popups), 
            //set notifier to queue up data from the notifications store
            EventHandler<NotificationEventArgs> addedHandler = delegate(object system, NotificationEventArgs nArgs)
            {
                Notification notification = nArgs.Notification;
                NotificationViewModel viewModel;
                if (notification.Type == Notification.NotificationType.Invitation)
                    viewModel = new InviteNotificationViewModel(notification, notifSystem, sessionSystem);
                else
                    viewModel = new NotificationViewModel(notification, notifSystem, sessionSystem);
                _notifier.QueueItem(viewModel);
            };
            EventHandler<NotificationEventArgs> removedHandler = delegate(object system, NotificationEventArgs nArgs)
            {
                _notifier.RemoveItem(vm => ((NotificationViewModel)vm).Id == nArgs.Notification.Id);
            };

            notifSystem.NotificationAdded += addedHandler;
            notifSystem.NotificationRemoved += removedHandler;

            //Store the anonynous delegates so they don't get garbage collected
            _eventHandlers.Add(addedHandler);
            _eventHandlers.Add(removedHandler);
        }



        private void HandlePlayRequested(object sender, GameEventArgs args)
        {
            ISessionSystem system = (ISessionSystem)sender;

            //Marshal to UI thread
            Action op = delegate
            {
                Trace.TraceInformation("A play was requested for {0}", args.Game.ToString());

                if (args.Game is OneCardGame)
                {
                    //Remove any other game screen from the screen list and add our new one
                    Conductor.RemoveAll(curScreen => curScreen is OneCardGameViewModel);
                    Conductor.SetActive(new OneCardGameViewModel(_screenConductor, system, (OneCardGame)args.Game));
                }
            };
            op.ExecuteOnUI();
        }

        #region Change User

        public ICommand ChangeUserCommand
        {
            get
            {
                if (_changeUserCommand == null)
                    _changeUserCommand = new DelegateCommand(
                        () => RequestChangeUser(),
                        () => CanChangeUser,
                        true);

                return _changeUserCommand;
            }
        }
        private ICommand _changeUserCommand;

        public bool CanChangeUser
        {
            //Still buggy atm. Need to shutdown existing background threads when we change.
            get { return false; }//!Conductor.ContainsAny(screen => screen is SignInViewModel); }
        }

        public void RequestChangeUser()
        {
            Trace.TraceWarning("Requesting to change users...");

            //Start with required sign in dialog
            SignInViewModel signInViewModel = new SignInViewModel(_configStore);
            signInViewModel.SignInCompleted += HandleSignIn;
            signInViewModel.CloseRequested += delegate { Conductor.GoBack(); };
            Conductor.SetActive(signInViewModel);
        }
        #endregion

        #region Install Certificates

        public ICommand InstallCertsCommand
        {
            get
            {
                if (_installCertsCommand == null)
                    _installCertsCommand = new DelegateCommand(
                        () => InstallCertificates(),
                        () => true,
                        false);
                return _installCertsCommand;
            }
        }
        private ICommand _installCertsCommand;

        public void InstallCertificates()
        {
            AuthenticationService.InstallDefaultCertificates();
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\ViewModel\ModifySessionViewModel.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using OneCardFramework.Game;
using AsyncMultiplayer.SessionCommon;
using System.Windows.Input;
using OneCardGUI.Commanding;

namespace OneCardGUI.ViewModel
{
    public class ModifySessionViewModel : ViewModelBase
    {
        #region Published Properties
        public string SessionName
        {
            get { return _settings.DisplayName; }
            set { _settings.DisplayName = value; OnPropertyChanged("SessionName"); }
        }

        public int TotalSeatsAvailable
        {
            get { return _settings.TotalSeatsAvailable; }
            set { _settings.TotalSeatsAvailable = value; OnPropertyChanged("TotalSeatsAvailable"); }
        }

        public int ReservedSeatsAvailable
        {
            get { return _settings.ReservedSeatsAvailable; }
            set { _settings.ReservedSeatsAvailable = value; OnPropertyChanged("ReservedSeatsAvailable"); }
        }

        public bool CanRemoveEmptySeats
        {
            get { return _settings.CanRemoveEmptySeats; }
            set { _settings.CanRemoveEmptySeats = value; OnPropertyChanged("CanRemoveEmptySeats"); }
        }

        public bool IsFriendsOnly
        {
            get { return _settings.IsFriendsOnly; }
            set { _settings.IsFriendsOnly = value; OnPropertyChanged("IsFriendsOnly"); }
        }

        public int InactivityWarningInterval
        {
            get { return _settings.InactivityWarning.Interval; }
            set { _settings.InactivityWarning.Interval = value; OnPropertyChanged("InactivityWarningInterval"); }
        }

        public int InactivityMaxNudges
        {
            get { return _settings.InactivityWarning.MaxNumberOfNudges; }
            set { _settings.InactivityWarning.MaxNumberOfNudges = value; OnPropertyChanged("InactivityMaxNudges"); }
        }

        public InactivityWarningAction InactivityAction
        {
            get { return _settings.InactivityWarning.Action; }
            set { _settings.InactivityWarning.Action = value; OnPropertyChanged("InactivityAction"); }
        }
        #endregion

        private ModificationData _settings;
        private GameSession _session;



        public ModifySessionViewModel(GameSession session)
        {
            _settings = new ModificationData();
            _settings.InactivityWarning = new InactivityWarningBehavior();
            _session = session;

            FillSettings();
        }

        /// <summary>
        /// Fills our view model state with the current session data
        /// </summary>
        private void FillSettings()
        {
            SessionState curState = _session.SessionState;
            SessionName = curState.DisplayName;
            TotalSeatsAvailable = curState.SeatsAvailable;
            ReservedSeatsAvailable = curState.ReservedSeatsAvailable;
            CanRemoveEmptySeats = curState.CanRemoveEmptySeats;
            InactivityWarningInterval = curState.InactivityWarning.Interval;
            InactivityAction = curState.InactivityWarning.Action;
            InactivityMaxNudges = curState.InactivityWarning.MaxNumberOfNudges;

            //How do we check IsFriendsOnly?
        }


        public ICommand ResetCommand
        {
            get
            {
                if (_resetCommand == null)
                    _resetCommand = new DelegateCommand(
                        () => FillSettings(),
                        () => true,
                        false);
                return _resetCommand;
            }
        }
        private ICommand _resetCommand;

        public ICommand SaveCommand
        {
            get
            {
                if (_saveCommand == null)
                    _saveCommand = new DelegateCommand(
                        () => Save(),
                        () => CanSave,
                        false);
                return _saveCommand;
            }
        }
        private ICommand _saveCommand;

        public bool CanSave
        {
            get { return true; }
        }

        public void Save()
        {
            _session.ModifySession(_settings);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\ViewModel\NotificationViewModel.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using AsyncMultiplayer.NotificationService;
using System.Xml.Serialization;
using System.Xml;
using System.Windows.Input;
using OneCardFramework;
using OneCardFramework.Cache;
using System.Diagnostics;
using OneCardGUI.Commanding;
using System.ComponentModel;
using OneCardGUI.Framework;
using System.Reflection;

namespace OneCardGUI.ViewModel
{
    /// <summary>
    /// A view model for an individual notification
    /// </summary>
    public class NotificationViewModel : ViewModelBase
    {
        protected Notification _notification;
        protected INotificationSystem _notifSystem;
        protected ISessionSystem _sessionSystem;

        public NotificationViewModel(Notification notification, INotificationSystem notifSystem, ISessionSystem sessionSystem)
        {
            _notifSystem = notifSystem;
            _sessionSystem = sessionSystem;

            Apply(notification);
        }

        #region Properties

        public string Id { get { return _notification.Id; } }
        public uint GameId { get { return _notification.GameId; } }
        public string GameDisplayName { get { return _notification.GameDisplayName; } }

        public Notification.NotificationType Type { get { return _notification.Type; } }
        public string TypeDisplayName { get { return _notification.TypeDisplayName; } }
        public Notification.NotificationCategory Category { get { return _notification.Category; } }

        public DateTime SentTime { get { return _notification.SentTime; } }
        public DateTime DeliveredTime { get { return _notification.DeliveredTime ; } }
        public DateTime ExpirationTime { get { return _notification.ExpirationTime; } }

        public string DataBlob { get { return _notification.DataBlob; } }
        public bool IsUserVisible { get { return _notification.IsUserVisible; } }
        public Notification.NotificationStatus Status { get { return _notification.Status; } }
        public int SupportedPlatform { get { return _notification.SupportedPlatform; } }
        public string UserId { get { return _notification.UserId; } }

        public string Url { get { return _notification.Url; } }
        public GameImageComposite[] Images { get; private set; }
        public AsyncMultiplayer.NotificationService.UserInfo From { get; private set; }

        #endregion

        /// <summary>
        /// Updates this view model with the data from the supplied notification
        /// and notifies on all properties
        /// </summary>
        /// <param name="newNotification"></param>
        public virtual void Apply(Notification newNotification)
        {
            _notification = newNotification;
            Images = ParseImages(_notification);
            From = ParseSender(_notification);

            //Easier than trying to track each property individually
            NotifyAllProperties();
        }


        #region Commands

        public ICommand DeleteCommand
        {
            get
            {
                if (_deleteCommand == null)
                    _deleteCommand = new RelayCommand(param => Delete(), param => CanDelete);
                return _deleteCommand;
            }
        }
        private ICommand _deleteCommand;

        public ICommand PlayCommand
        {
            get
            {
                if (_playCommand == null)
                    _playCommand = new RelayCommand(param => Play(), param => CanPlay);
                return _playCommand;
            }
        }
        private ICommand _playCommand;

        #endregion

        #region Actions
        public bool CanDelete
        {
            get { return _notifSystem.ContainsNotification(_notification); }
        }

        public void Delete()
        {
            Action asyncOp = delegate
            {
                _notifSystem.Delete(_notification);
            };
            asyncOp.ExecuteAsyncCatchUI();
        }

        public virtual bool CanPlay
        {
            get
            {
                //We don't really know if we can play, since we might not have the session
                //data cached. Easier just to try to play and find out.
                return true;
            } 
        }

        public virtual void Play()
        {
            Action asyncOp = delegate
            {
                _sessionSystem.RequestPlay(_notification.SessionId);
            };
            asyncOp.ExecuteAsyncCatchUI();
        }
        #endregion

        #region Parsing Helpers
        public static GameImageComposite[] ParseImages(Notification notification)
        {
            if (string.IsNullOrEmpty(notification.Images))
                return null;

            try
            {
                return SerializationHelper.DeserializeXml<GameImageComposite[]>(notification.Images);
            }
            catch (Exception)
            {
                Trace.TraceError("Error parsing notification 'Images' data");
            }
            return null;
        }

        public static UserInfo ParseSender(Notification notification)
        {
            if (string.IsNullOrEmpty(notification.From))
                return null;

            try
            {
                return SerializationHelper.DeserializeDataContract<AsyncMultiplayer.NotificationService.UserInfo>(notification.From);
            }
            catch (Exception e)
            {
                Trace.TraceError("Error parsing notification 'From' data: {0}" + e.ToString());
            }
            return null;
        }
        #endregion
    }

    [Serializable]
    public class GameImageComposite
    {
        public string ImageUrl { get; set; }
        public int Width { get; set; }
        public int Height { get; set; }
        public string ImageType { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\ViewModel\OneCardCardViewModel.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using OneCard.Game;

namespace OneCardGUI.ViewModel
{
    public class OneCardCardViewModel
    {
        public string ImagePath
        {
            get;
            private set;
        }

        public string AbilityShortText
        {
            get;
            private set;
        }
        
        private PlayingCard _card;
        private OneCardGame _game;

        public OneCardCardViewModel(PlayingCard card, OneCardGame game)
        {
            _card = card;
            _game = game;

            ImagePath = GetImagePath(card);

            var ability = game.GetCardAbility(card);
            var attackPower = game.GetAttackPower(card);
            AbilityShortText = game.GetCardAbilityStringShort(ability) + ((attackPower > 0) ? " " + attackPower : "");
        }

        public bool IsWrapper(PlayingCard card)
        {
            return _card == card;
        }

        public bool CanPlay
        {
            get { return _game.IsValidPlay(_card); }
        }

        public void Play()
        {
            _game.PlayCard(_card);
        }

        public override string ToString()
        {
            return _card.ToString();
        }


        private static string GetImagePath(PlayingCard card)
        {
            string baseDir = "../Content/Cards/";

            if(card.Facing == FaceDirection.FaceDown)
                return baseDir + "cardSkin.png";

            string suit = GetSuitLetters(card.Suit);
            string value = GetValueLetter(card.Value);

            return baseDir + suit + value + ".gif";
        }

        private static string GetValueLetter(FaceValue faceValue)
        {
            switch (faceValue)
            {
                case FaceValue.Ace:
                    return "1";
                case FaceValue.King:
                    return "k";
                case FaceValue.Queen:
                    return "q";
                case FaceValue.Jack:
                    return "j";
                
                default:
                    return "" + (int)faceValue;
            }
        }

        private static string GetSuitLetters(Suit suit)
        {
            return suit.ToString().Substring(0, 2);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\ViewModel\OneCardGameViewModel.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Collections.ObjectModel;
using OneCard.Game;
using OneCardFramework.Cache;
using OneCardFramework.Game;
using System.Windows.Input;
using OneCardGUI.Commanding;
using AsyncMultiplayer.SessionCommon;
using System.Windows;
using System.ComponentModel;
using OneCardGUI.Framework;
using System.Reflection;

namespace OneCardGUI.ViewModel
{
    public class OneCardGameViewModel : GameSessionViewModel
    {
        #region Exposed Properties
        public ReadOnlyObservableCollection<OneCardCardViewModel> MyHand
        {
            get { return _myHandReadOnly; }
        }
        private ReadOnlyObservableCollection<OneCardCardViewModel> _myHandReadOnly;
        private ObservableCollection<OneCardCardViewModel> _myHand;

        public OneCardCardViewModel SelectedCard
        {
            get { return _selectedCard; }
            set { _selectedCard = value; 
                OnPropertyChanged("SelectedCard");
                OnPropertyChanged("CanPlaySelectedCard");
            }
        }
        private OneCardCardViewModel _selectedCard;

        /// <summary>
        /// The current discard pile. Sorted from bottom to top.
        /// </summary>
        public ReadOnlyObservableCollection<OneCardCardViewModel> DiscardPile
        {
            get { return _discardPileReadOnly; }
        }
        private ReadOnlyObservableCollection<OneCardCardViewModel> _discardPileReadOnly;
        private ObservableCollection<OneCardCardViewModel> _discardPile;


        public OneCardCardViewModel TopDiscard
        {
            get { return (_discardPile.Count > 0) ? _discardPile[_discardPile.Count - 1] : null; }
        }

        public int AttackOnUs
        {
            get { return _game.AttackOnUs; }
        }

        /// <summary>
        /// Am I the winner?
        /// </summary>
        public bool IsWinner
        {
            get { return _game.IsWinner && _game.Session.IsGameOver; }
        }

        /// <summary>
        /// Am I a loser?
        /// </summary>
        public bool IsLoser
        {
            get { return !_game.IsWinner && _game.Session.IsGameOver; }
        }

        #endregion


        private OneCardGame _game;

        public OneCardGameViewModel(ScreenConductor conductor, ISessionSystem sessionSystem, OneCardGame game)
            : base(conductor, game.Session, sessionSystem)
        {
            _game = game;

            _game.CardDrawn += HandleCardDrawn;
            _game.CardPlayed += HandleCardPlayed;
            _game.Updated += HandleGameUpdated;

            InitializeCollections();
            UpdateCollections();
        }


        #region Collection Operations

        private void InitializeCollections()
        {
            _discardPile = new ObservableCollection<OneCardCardViewModel>();
            _discardPileReadOnly = new ReadOnlyObservableCollection<OneCardCardViewModel>(_discardPile);
            _discardPile.CollectionChanged += delegate { OnPropertyChanged("TopDiscard"); };

            _myHand = new ObservableCollection<OneCardCardViewModel>();
            _myHandReadOnly = new ReadOnlyObservableCollection<OneCardCardViewModel>(_myHand);
        }

        private void UpdateCollections()
        {
            _discardPile.Clear();
            foreach (var card in _game.DiscardPile)
            {
                _discardPile.Add(new OneCardCardViewModel(card, _game));
            }

            _myHand.Clear();
            foreach (var card in _game.MyHand)
            {
                _myHand.Add(new OneCardCardViewModel(card, _game));
            }
        }

        

        #endregion

        #region Event Handlers


        private void HandleCardPlayed(object sender, CardEventArgs args)
        {
            Action uiAction = delegate
            {
                OneCardCardViewModel vm = _myHand.FirstOrDefault(cardVM => cardVM.IsWrapper(args.Card));
                if (vm == null)
                    vm = new OneCardCardViewModel(args.Card, _game);
                else
                    _myHand.Remove(vm);

                _discardPile.Add(vm);

                NotifyAllProperties();
            };
            uiAction.ExecuteOnUI();
        }

        private void HandleCardDrawn(object sender, CardEventArgs args)
        {
            Action uiAction = delegate
            {
                _myHand.Add(new OneCardCardViewModel(args.Card, _game));


                NotifyAllProperties();
            };
            uiAction.ExecuteOnUI();
        }

        private void HandleGameUpdated(object sender, EventArgs args)
        {
            Action uiAction = delegate
            {
                UpdateCollections();
                NotifyAllProperties();
            };
            uiAction.ExecuteOnUI();
        }
        #endregion


        #region Win Now

        public ICommand WinNowCommand
        {
            get
            {
                if (_winNowCommand == null)
                    _winNowCommand = new RelayCommand(param => WinNow(), param => CanWinNow);
                return _winNowCommand;
            }
        }
        private ICommand _winNowCommand;

        public bool CanWinNow
        {
            get { return true; }
        }

        public void WinNow()
        {
            Action asyncOp = delegate
            {
                _game.Session.EndGame(new int[] { _game.Session.MySeatIndex }, null, null, null);
            };
            asyncOp.ExecuteAsyncCatchUI();
        }

        #endregion


        #region Play Card

        public ICommand PlaySelectedCardCommand
        {
            get
            {
                if (_playSelectedCardCommand == null)
                    _playSelectedCardCommand = new DelegateCommand(
                        () => PlaySelectedCard(),
                        () => CanPlaySelectedCard,
                        true).ListenOn(this, vm => vm.SelectedCard);
                return _playSelectedCardCommand;
            }
        }
        private ICommand _playSelectedCardCommand;

        public bool CanPlaySelectedCard
        {
            get { return _selectedCard != null && _selectedCard.CanPlay; }
        }

        public void PlaySelectedCard()
        {
            _selectedCard.Play();
        }

        #endregion


        #region Draw Card

        public ICommand DrawCardCommand
        {
            get
            {
                if (_drawCardCommand == null)
                    _drawCardCommand = new RelayCommand(param => DrawCard(), param => CanDrawCard);
                return _drawCardCommand;
            }
        }
        private ICommand _drawCardCommand;

        public bool CanDrawCard
        {
            get { return _game.Session.IsMyTurn; }
        }

        public void DrawCard()
        {
            _game.DrawCard();
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\ViewModel\ServiceConfigurationViewModel.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ComponentModel;
using OneCard;
using OneCardFramework.Services;
using OneCardFramework.Configuration;

namespace OneCardGUI.ViewModel
{
    public class ServiceConfigurationViewModel : WorkspaceViewModel
    {


        private ServicesConfiguration _config;

        public ServiceConfigurationViewModel(ServicesConfiguration config, ConfigurationStore store)
        {
            _config = config;
        }


        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\ViewModel\ScreenConductorViewModel.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace OneCardGUI.ViewModel
{
    public class ScreenConductor : ViewModelBase
    {
        #region Properties
        /// <summary>
        /// The current "top" screen
        /// </summary>
        public object ActiveScreen
        {
            get { return _activeScreen; }
            private set
            {
                if (_activeScreen != value)
                {
                    ScreenViewModel oldView = _activeScreen as ScreenViewModel;
                    ScreenViewModel newView = value as ScreenViewModel;

                    if (oldView != null)
                        oldView.NotifyHidden();
                    if (newView != null)
                        newView.NotifyActive();

                    _activeScreen = value;
                    OnPropertyChanged("ActiveScreen");
                }
            }
        }
        private object _activeScreen;

        /// <summary>
        /// The number of screens currently stored
        /// </summary>
        public int ScreenCount
        {
            get { return _history.Count; }
        }
        #endregion

        private List<object> _history = new List<object>();





        /// <summary>
        /// Goes back to the previous screen in the history
        /// </summary>
        public void GoBack()
        {
            if (_history.Count > 1)
            {
                _history.RemoveAt(_history.Count - 1);
                ActiveScreen = _history[_history.Count - 1];
            }
        }

        /// <summary>
        /// Sets a new active screen, pushing the previous active
        /// into history
        /// </summary>
        /// <param name="screen"></param>
        public void SetActive(object screen)
        {
            if (screen == null)
                throw new ArgumentNullException();

            if (ActiveScreen != screen)
            {
                _history.Add(screen);
                ActiveScreen = screen;
            }
        }

        /// <summary>
        /// Clears the screen history, leaving only the active screen
        /// </summary>
        public void ClearHistory()
        {
            _history.Clear();
            if(ActiveScreen != null)
                _history.Add(ActiveScreen);
        }

        /// <summary>
        /// Removes all screens, including the active screen
        /// </summary>
        public void ClearAll()
        {
            _history.Clear();
            ActiveScreen = null;
        }

        /// <summary>
        /// Removes the newest instance of the given screen within
        /// the system, unless it is the only screen left.
        /// </summary>
        /// <param name="screen"></param>
        public void RemoveNewestInstance(object screen)
        {
            if (_history.Count == 1)
                return;

            for (int i = _history.Count - 1; i >= 0; i--)
            {
                if (_history[i] == screen)
                {
                    _history.RemoveAt(i);
                    break;
                }
            }

            //Make sure our ActiveScreen is updated if the top screen changed
            ActiveScreen = _history[_history.Count - 1];
        }

        /// <summary>
        /// Removes all instances of the given screen from the system
        /// </summary>
        /// <param name="screen"></param>
        public void RemoveAllInstances(object screen)
        {
            RemoveAll(cur => cur == screen);
        }

        /// <summary>
        /// Removes all screens that match the supplied predicate
        /// </summary>
        /// <param name="predicate">Predicate for selcting screens to remove. Should return true
        /// to remove the object that it matches</param>
        public void RemoveAll(Predicate<object> predicate)
        {
            for (int i = _history.Count - 1; i >= 0; i--)
            {
                if (predicate(_history[i]))
                    _history.RemoveAt(i);
            }

            //Make sure our ActiveScreen is updated if the top screen changed
            ActiveScreen = (_history.Count > 0) ? _history[_history.Count - 1] : null;
        }

        public bool Contains(object obj)
        {
            return ContainsAny(cur => cur == obj);
        }

        public bool ContainsAny(Predicate<object> predicate)
        {
            foreach (var screen in _history)
            {
                if (predicate(screen))
                    return true;
            }
            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\ViewModel\ScreenViewModel.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows.Input;
using OneCardGUI.Commanding;

namespace OneCardGUI.ViewModel
{
    public abstract class ScreenViewModel : ViewModelBase
    {
        protected ScreenConductor _screenConductor;


        protected ScreenViewModel(ScreenConductor conductor)
        {
            _screenConductor = conductor;
        }

        #region Commands

        public ICommand GoBackCommand
        {
            get
            {
                if (_goBackCommand == null)
                    _goBackCommand = new RelayCommand(param => GoBack(), param => CanGoBack);

                return _goBackCommand;
            }
        }
        private ICommand _goBackCommand;

        #endregion


        public virtual bool CanGoBack
        {
            get { return true; }
        }

        public virtual void GoBack()
        {
            _screenConductor.GoBack();
            Dispose();
        }


        public bool IsActive
        {
            get { return _isActive; }
            private set { _isActive = value; OnPropertyChanged("IsActive"); }
        }
        private bool _isActive;

        /// <summary>
        /// Should be called to notify a screen that it is being displayed
        /// </summary>
        public virtual void NotifyActive()
        {
            IsActive = true;
        }

        /// <summary>
        /// Should be called to notify a screen that it has been hidden/put away
        /// </summary>
        public virtual void NotifyHidden()
        {
            IsActive = false;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\ViewModel\PopupNotifierViewModel.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using OneCardFramework.Cache;
using System.Collections.ObjectModel;
using OneCardGUI.Commanding;
using System.Windows.Input;
using OneCardFramework.Extensions;
using System.Windows.Threading;
using OneCardGUI.Framework;
using System.Windows.Media.Animation;

namespace OneCardGUI.ViewModel
{
    public class PopupItemViewModel : ViewModelBase
    {
        public event EventHandler CloseRequested;

        public object Content { get; private set; }

        public TimeSpan Lifetime { get; private set; }
        

        public PopupItemViewModel(object content, TimeSpan lifetime)
        {
            Content = content;
            Lifetime = lifetime;
        }

        public ICommand CloseCommand
        {
            get
            {
                if (_closeCommand == null)
                    _closeCommand = new DelegateCommand(
                        () => Close(),
                        () => CanClose,
                        false);
                return _closeCommand;
            }
        }
        private DelegateCommand _closeCommand;

        public bool CanClose
        {
            get { return true; }
        }

        public void Close()
        {
            CloseRequested.Raise(this, EventArgs.Empty);
        }
    }

    /// <summary>
    /// Provides a system for queueing view models to be shown as popups. The active popup
    /// will remain active until a Close is requested.
    /// </summary>
    public class PopupNotifierViewModel : ViewModelBase
    {
        public PopupItemViewModel ActiveItem
        {
            get { return _activeItem; }
            private set { _activeItem = value; OnPropertyChanged("ActiveItem"); }
        }
        private PopupItemViewModel _activeItem;

        public TimeSpan DefaultLifetime
        {
            get { return _defaultLifetime; }
            private set { _defaultLifetime = value; OnPropertyChanged("DefaultLifetime"); }
        }
        private TimeSpan _defaultLifetime;


        private List<PopupItemViewModel> _queue;

        public PopupNotifierViewModel(Dispatcher dispatcher)
        {
            _queue = new List<PopupItemViewModel>();
        }


        private void HandleCloseRequested(object sender, EventArgs args)
        {
            PopupItemViewModel popup = (PopupItemViewModel)sender;

            RemovePopup(popup);
        }

        private void RemovePopup(PopupItemViewModel popup)
        {
            if (ActiveItem == popup)
            {
                //Active item is always at the front of the queue
                _queue.RemoveAt(0);
                ActiveItem = null;

                //If we have another item in the queue, move it to active
                if (_queue.Count > 0)
                {
                    ActiveItem = _queue[0];
                }
            }
            else
            {
                _queue.Remove(popup);
            }
        }




        /// <summary>
        /// Queues an object to be displayed for the maximum lifetime
        /// </summary>
        /// <param name="content"></param>
        public void QueueItem(object content)
        {
            QueueItem(content, DefaultLifetime);
        }

        /// <summary>
        /// Queues an object to be displayed for the given lifetime
        /// </summary>
        /// <param name="content"></param>
        /// <param name="lifetime"></param>
        public void QueueItem(object content, TimeSpan lifetime)
        {
            PopupItemViewModel popup = new PopupItemViewModel(content, lifetime);
            popup.CloseRequested += HandleCloseRequested;

            Action uiAction = delegate
            {
                _queue.Add(popup);

                if (_queue.Count == 1)
                {
                    ActiveItem = popup;
                }
            };
            uiAction.ExecuteOnUI();
        }

        /// <summary>
        /// Forcibly removes items from our queue
        /// </summary>
        /// <param name="removePredicate">The predicate used to examine each element. It will be passed
        /// the content that was originally queued. If it returns true, we will remove the element.</param>
        public void RemoveItem(Func<object, bool> removePredicate)
        {
            Action uiAction = delegate
            {
                for (int i = _queue.Count - 1; i >= 0; i--)
                {
                    PopupItemViewModel current = _queue[i];

                    if (removePredicate(current.Content))
                    {
                        RemovePopup(current);
                    }
                }
            };
            uiAction.ExecuteOnUI();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\ViewModel\SeatViewModel.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using AsyncMultiplayer.SessionCommon;
using System.Reflection;
using Leet.Core.Platforms;

namespace OneCardGUI.ViewModel
{
    public class SeatViewModel : ViewModelBase
    {
        public string DisplayName
        {
            get { return _seat.DisplayName;}
        }

        public int Index
        {
            get { return _seat.Index; }
        }

        public string DisplayPicUrl
        {
            get { return _seat.DisplayPicURL; }
        }

        public string DisplayPicSmallUrl
        {
            get { return _seat.DisplayPicSmallURL; }
        }

        public bool IsAI
        {
            get { return _seat.IsAI; }
        }

        public PlatformType PlatformType
        {
            get { return _seat.PlatformType; }
        }

        public string Locale
        {
            get { return _seat.Locale; }
        }



        public SeatInfo Seat
        {
            get { return _seat; }
        }

        private SeatInfo _seat;

        public SeatViewModel(SeatInfo seat)
        {
            _seat = seat;
        }

        public void Refresh(SeatInfo newData)
        {
            _seat = newData;

            foreach (PropertyInfo info in this.GetType().GetProperties())
            {
                OnPropertyChanged(info.Name);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\ViewModel\SessionDetailViewModel.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using AsyncMultiplayer.SessionCommon;
using OneCardFramework.Cache;
using System.Reflection;
using System.Windows.Input;
using OneCardGUI.Commanding;
using System.Collections.ObjectModel;
using OneCardGUI.Framework;

namespace OneCardGUI.ViewModel
{
    public class SessionDetailViewModel : ViewModelBase
    {
        #region SessionState Members
        public string DisplayName
        {
            get { return _sessionState.DisplayName; }
        }
        public string SessionID
        {
            get { return _sessionState.SessionID; }
        }
        public uint GameID
        {
            get { return _sessionState.GameID; }
        }
        public int Variant
        {
            get { return _sessionState.Variant; }
        }
        public int? ActorSeat
        {
            get { return _sessionState.ActorSeat; }
        }
        public bool CanRemoveEmptySeats
        {
            get { return _sessionState.CanRemoveEmptySeats; }
        }
        public SessionType Category
        {
            get { return _sessionState.Category; }
        }
        public DateTime CreationTime
        {
            get { return _sessionState.CreationTime; }
        }
        public bool IsClosed
        {
            get { return _sessionState.IsClosed; }
        }
        public bool IsWarningSent
        {
            get { return _sessionState.IsWarningSent; }
        }
        public int NumberOfNudgesSent
        {
            get { return _sessionState.NumberOfNudgesSent; }
        }
        public int OwnerSeatIndex
        {
            get { return _sessionState.OwnerSeatIndex; }
        }
        public int ReservedSeatsAvailable
        {
            get { return _sessionState.ReservedSeatsAvailable; }
        }
        public int SeatsAvailable
        {
            get { return _sessionState.SeatsAvailable; }
        }
        public int? ActiveSeatIndex
        {
            get { return (_sessionState.State != null) ? _sessionState.State.ActiveSeatIndex : (int?)null; }
        }
        public DateTime? LastModified
        {
            get { return (_sessionState.State != null) ? _sessionState.State.LastModified : (DateTime?)null; }
        }
        public bool? IsComplete
        {
            get { return (_sessionState.State != null) ? _sessionState.State.IsComplete : (bool?)null; }
        }
        public ReadOnlyObservableCollection<SeatViewModel> Seats
        {
            get { return _seatsReadOnly; }
        }
        private ReadOnlyObservableCollection<SeatViewModel> _seatsReadOnly;
        private ObservableCollection<SeatViewModel> _seats;
        #endregion


        private volatile SessionState _sessionState;
        private ISessionSystem _system;


        public SessionDetailViewModel(SessionState state, ISessionSystem system)
        {
            _sessionState = state;
            _system = system;

            _seats = new ObservableCollection<SeatViewModel>();
            _seatsReadOnly = new ReadOnlyObservableCollection<SeatViewModel>(_seats);
        }

        public SessionDetailViewModel(string sessionID, ISessionSystem system)
        {
            _sessionState = new SessionState();
            _system = system;

            Refresh(sessionID);
        }

        #region Commands
        public ICommand RefreshCommand
        {
            get
            {
                if (_refreshCommand == null)
                    _refreshCommand = new DelegateCommand(
                        () => Refresh(),
                        () => CanRefresh,
                        true).ListenOn(this, obj => obj.IsLoading);
                return _refreshCommand;
            }
        }
        private ICommand _refreshCommand;

        public ICommand PlayCommand
        {
            get
            {
                if (_playCommand == null)
                    _playCommand = new RelayCommand(param => Play(), param => CanPlay);
                return _playCommand;
            }
        }
        private ICommand _playCommand;

        public ICommand LeaveCommand
        {
            get
            {
                if (_leaveCommand == null)
                    _leaveCommand = new RelayCommand(param => Leave(), param => CanLeave);
                return _leaveCommand;
            }
        }
        private ICommand _leaveCommand;
        #endregion



        public bool IsLoading
        {
            get { return _isLoading; }
            private set { _isLoading = value; OnPropertyChanged("IsLoading"); }
        }
        private volatile bool _isLoading;


        public bool CanRefresh
        {
            get { return _system != null && !IsLoading; }
        }

        public void Refresh()
        {
            Refresh(_sessionState.SessionID);
        }

        public void Refresh(string sessionID)
        {
            if (IsLoading)
                return;

            //Run the refresh asynchronously
            if (_system != null)
            {
                IsLoading = true;
                Action op = delegate
                {
                    try
                    {
                        SessionState state = _system.GetDetail(sessionID, true);
                        Refresh(state);
                    }
                    finally
                    {
                        IsLoading = false;
                    }
                };
                op.ExecuteAsyncCatchUI();
            }
        }

        public void Refresh(SessionState newState)
        {
            _sessionState = newState;

            //Everything changed
            foreach (PropertyInfo info in this.GetType().GetProperties())
            {
                OnPropertyChanged(info.Name);
            }
            IsLoading = false;
            CommandManager.InvalidateRequerySuggested();
        }


        public bool CanPlay
        {
            //We can only play if a game is still active, but for testing purposes we'll let people do whatever
            get { return _system != null; }
        }

        public void Play()
        {
            Action asyncOp = delegate
            {
                _system.RequestPlay(_sessionState.SessionID);
            };
            asyncOp.ExecuteAsyncCatchUI();
        }


        public bool CanLeave
        {
            //We can only leave if a game is still active, but for testing purposes we'll let people do whatever
            get { return _system != null; }
        }

        public void Leave()
        {
            Action asyncOp = delegate
            {
                _system.RequestLeave(_sessionState.SessionID, true);
            };
            asyncOp.ExecuteAsyncCatchUI();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\ViewModel\SessionSummaryViewModel.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using AsyncMultiplayer.SessionCommon;
using OneCardFramework;
using OneCardFramework.Cache;
using System.Windows.Input;
using OneCardGUI.Commanding;
using System.Reflection;

namespace OneCardGUI.ViewModel
{
    public class SessionSummaryViewModel : ViewModelBase
    {
        public bool IsSelected
        {
            get { return _isSelected; }
            set {
                if (value != _isSelected)
                {
                    _isSelected = value;
                    OnPropertyChanged("IsSelected");
                }
            }
        }
        private bool _isSelected;


        #region Summary Members
        public string DisplayName
        {
            get { return _summary.DisplayName; }
        }
        public DateTime CreationDate
        {
            get { return _summary.CreationDate; }
        }
        public bool IsComplete
        {
            get { return _summary.IsComplete; }
        }
        public string SessionID
        {
            get { return _summary.SessionID; }
        }
        public uint GameID
        {
            get { return _summary.GameID; }
        }
        public int Variant
        {
            get { return _summary.Variant; }
        }
        public DateTime LastModified
        {
            get { return _summary.LastModified; }
        }
        public SeatViewModel LastModifiedBy
        {
            get
            {
                if (_lastModifiedBy == null)
                    _lastModifiedBy = new SeatViewModel(_summary.LastModifiedBy);
                return _lastModifiedBy;
            }
        }
        private SeatViewModel _lastModifiedBy;
        public byte[] SessionParameters
        {
            get { return _summary.SessionParameters; }
        }
        #endregion


        private SessionEntry _summary;
        private ISessionSystem _system;


        public SessionSummaryViewModel(SessionEntry summary, ISessionSystem system)
        {
            _summary = summary;
            _system = system;
        }



        #region Commands
        public ICommand LeaveCommand
        {
            get
            {
                if (_leaveCommand == null)
                    _leaveCommand = new DelegateCommand(() => Leave(), () => CanLeave, false);
                return _leaveCommand;
            }
        }
        private ICommand _leaveCommand;

        public ICommand PlayCommand
        {
            get
            {
                if (_playCommand == null)
                    _playCommand = new DelegateCommand(() => Play(), () => CanPlay, false);
                return _playCommand;
            }
        }
        private ICommand _playCommand;
        #endregion


        public void Refresh(SessionEntry newData)
        {
            _summary = newData;

            //Everything changed
            foreach (PropertyInfo info in this.GetType().GetProperties())
            {
                OnPropertyChanged(info.Name);
            }
        }

        public bool CanPlay
        {
            //We can only play if a game is still active, but for testing purposes we'll let people do whatever
            get { return true;  }
        }

        public void Play()
        {
            Action asyncOp = delegate
            {
                //Open this session and it's game
                _system.RequestPlay(_summary.SessionID);
            };
            asyncOp.BeginInvoke(null, null);
        }

        public bool CanLeave
        {
            //We can only leave if a game is still active, but for testing purposes we'll let people do whatever
            get { return true; }
        }

        public void Leave()
        {
            Action asyncOp = delegate
            {
                _system.RequestLeave(_summary.SessionID, true);
            };
            asyncOp.BeginInvoke(null, null);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\ViewModel\SignInViewModel.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using OneCardFramework;
using OneCardFramework.Configuration;
using System.Collections.ObjectModel;
using System.Windows.Input;
using System.ComponentModel;
using OneCardGUI.Commanding;
using OneCardFramework.Extensions;
using OneCardFramework.Services;
using OneCardFramework.Game;
using OneCard.Game;
using System.Diagnostics;
using OneCardFramework.Cache;
using OneCardGUI.Framework;

namespace OneCardGUI.ViewModel
{
    public class SignInViewModel : WorkspaceViewModel
    {

        #region Service Configuration

        public ReadOnlyObservableCollection<ServicesConfiguration> ServiceConfigurations
        {
            get { return _serviceConfigsReadOnly; }
        }
        private ReadOnlyObservableCollection<ServicesConfiguration> _serviceConfigsReadOnly;
        private ObservableCollection<ServicesConfiguration> _serviceConfigs;

        public ReadOnlyObservableCollection<UserConfiguration> AvailableUserConfigurations
        {
            get { return _userConfigsReadOnly; }
        }
        private ReadOnlyObservableCollection<UserConfiguration> _userConfigsReadOnly;
        private ObservableCollection<UserConfiguration> _userConfigs;

        public ServicesConfiguration SelectedServiceConfig
        {
            get { return _selectedServiceConfig; }
            set
            {
                _selectedServiceConfig = value;
                base.OnPropertyChanged("SelectedServiceConfig");

                //Find users available for the specific environment
                RebuildUserList();
            }
        }
        private ServicesConfiguration _selectedServiceConfig;

        public object SelectedUser
        {
            get
            {
                return _selectedUser;
            }
            set
            {
                //We do some magic so that our combobox works correctly
                UserConfiguration config = value as UserConfiguration;
                if (config != null)
                {
                    _selectedUser = config.Username;
                    SelectedUserPassword = config.Password;
                }
                else
                {
                    _selectedUser = value as string;
                }

                base.OnPropertyChanged("SelectedUser");
            }
        }
        private string _selectedUser;

        public string SelectedUserPassword
        {
            get { return _selectedUserPassword; }
            set
            {
                _selectedUserPassword = value;
                base.OnPropertyChanged("SelectedUserPassword");
            }
        }
        private string _selectedUserPassword;

        #endregion

        #region Events
        public event EventHandler<SignInCompletedEventArgs> SignInCompleted;
        public event EventHandler SignInFailed;
        #endregion

        private ConfigurationStore _configStore;


        public SignInViewModel(ConfigurationStore store)
        {
            DisplayName = "Sign In";
            _configStore = store;
            
            CreateCollections();

            _configStore.ConfigurationAdded += HandleServiceConfigAdded;
            _configStore.ConfigurationRemoved += HandleServiceConfigRemoved;
        }

        protected override void OnDispose()
        {
            _configStore.ConfigurationAdded -= HandleServiceConfigAdded;
            _configStore.ConfigurationRemoved -= HandleServiceConfigRemoved;

            base.OnDispose();
        }

        #region Configuration Handling

        private void CreateCollections()
        {
            var initialServiceConfigs = _configStore.GetServiceConfigs();

            _serviceConfigs = new ObservableCollection<ServicesConfiguration>(initialServiceConfigs);
            _serviceConfigsReadOnly = new ReadOnlyObservableCollection<ServicesConfiguration>(_serviceConfigs);
            _userConfigs = new ObservableCollection<UserConfiguration>();
            _userConfigsReadOnly = new ReadOnlyObservableCollection<UserConfiguration>(_userConfigs);

            if (_serviceConfigs.Count > 0)
                SelectedServiceConfig = _serviceConfigs[0];

            RebuildUserList();
        }


        private void HandleServiceConfigAdded(object sender, ServicesConfigurationEventArgs args)
        {
            _serviceConfigs.Add(args.Config);
        }
        private void HandleServiceConfigRemoved(object sender, ServicesConfigurationEventArgs args)
        {
            _serviceConfigs.Remove(args.Config);

            RebuildUserList();
        }

        private void RebuildUserList()
        {
            _userConfigs.Clear();
            _userConfigs.Add(new UserConfiguration()); //Hack to add empty item

            if (SelectedServiceConfig != null)
            {
                var userData = _configStore.GetUserConfigs();

                foreach (var user in userData)
                {
                    if (user.Environments.Contains(SelectedServiceConfig.Environment))
                        _userConfigs.Add(user);
                }
            }

            SelectedUser = _userConfigs[0];
        }

        #endregion

        #region Commands

        public ICommand SignInCommand
        {
            get
            {
                if (_signInCommand == null)
                {
                    _signInCommand = new DelegateCommand(
                        () => this.SignIn(),
                        () => this.CanSignIn,
                        true)
                        .ListenOn(this, obj => obj.IsBusy);
                }
                return _signInCommand;
            }
        }
        private ICommand _signInCommand;

        public ICommand CancelSignInCommand
        {
            get
            {
                if (_cancelSignInCommand == null)
                {
                    _cancelSignInCommand = new DelegateCommand(
                        () => this.CancelSignIn(),
                        () => this.CanCancelSignIn,
                        true).ListenOn(this, obj => obj.IsBusy); ;
                }
                return _cancelSignInCommand;
            }
        }
        private ICommand _cancelSignInCommand;

        #endregion

        #region Sign In

        public bool IsBusy
        {
            get { return _isBusy; }
            set { _isBusy = value; OnPropertyChanged("IsBusy"); }
        }
        private bool _isBusy;


        public bool CanSignIn
        {
            get
            {
                return
                    SelectedServiceConfig != null &&
                    !string.IsNullOrEmpty(_selectedUser) &&
                    !IsBusy;
            }
        }

        /// <summary>
        /// Attempts to sign in using the current service configuration, username and password
        /// </summary>
        public void SignIn()
        {
            ServicesConfiguration serviceConfig = SelectedServiceConfig;

            IsBusy = true;

            Action asyncOp = delegate
            {
                try
                {
                    User user = AuthenticationService.CreateUser(
                        _selectedUser,
                        _selectedUserPassword,
                        serviceConfig.AuthenticationConfiguration);

                    OnSignInCompleted(user, serviceConfig);
                }
                catch (Exception e)
                {
                    Trace.TraceError("Error encountered during sign in: " + e.ToString());
                    OnSignInFailed();
                }
                finally
                {
                    IsBusy = false;
                }
            };
            asyncOp.BeginInvoke(null, null);
        }

        public bool CanCancelSignIn
        {
            get { return !IsBusy; }
        }

        public void CancelSignIn()
        {
            RequestClose();
        }

        #region Event Firing
        protected virtual void OnSignInCompleted(User user, ServicesConfiguration config)
        {
            Action op = delegate
            {
                SignInCompleted.Raise(this, new SignInCompletedEventArgs(user, config));
            };
            op.ExecuteOnUI();
        }
        protected virtual void OnSignInFailed()
        {
            Action op = delegate
            {
                SignInFailed.Raise(this, EventArgs.Empty);
            };
            op.ExecuteOnUI();
        }
        #endregion
        #endregion
    }

    public class SignInCompletedEventArgs : EventArgs
    {
        public User SignedInUser { get; private set; }
        public ServicesConfiguration Configuration { get; private set; }

        public SignInCompletedEventArgs(User user, ServicesConfiguration config)
        {
            SignedInUser = user;
            Configuration = config;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\ViewModel\WorkspaceViewModel.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using OneCardFramework.Extensions;
using OneCardGUI.Commanding;
using System.Windows.Input;

namespace OneCardGUI.ViewModel
{
    /// <summary>
    /// Represents a cohesive space for work that can request to be closed
    /// </summary>
    public abstract class WorkspaceViewModel : ViewModelBase
    {
        public string DisplayName { get; protected set; }

        public event EventHandler CloseRequested;


        protected WorkspaceViewModel() { }




        #region Commands

        public ICommand CloseCommand
        {
            get
            {
                if (_closeCommand == null)
                    _closeCommand = new RelayCommand(param => RequestClose(), param => true);

                return _closeCommand;
            }
        }
        private ICommand _closeCommand;

        #endregion


        public void RequestClose()
        {
            OnRequestClose();
        }

        protected virtual void OnRequestClose()
        {
            CloseRequested.Raise(this, EventArgs.Empty);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ParseTrx\ParseTrx\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("ParseTrx")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("ParseTrx")]
[assembly: AssemblyCopyright("Copyright © Microsoft 2009")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("9d1e82fa-4941-4907-8cc5-da2d7604b469")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ParseTrx\ParseTrx\Program.cs ===
﻿using System;
using System.Configuration;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Linq;
using System.Text;
using System.IO;
using System.Xml;
using System.Net.Mail;

namespace ParseTrx
{

    public class TestResult
    {
        public string name;
        public IndividualResult[] IndividualResults;
        public string runUser;
        public Counters counters;

        public TestResult()
        {
            name = "";
            IndividualResults = null;
            runUser = "";
        }

        public TestResult(string Name, IndividualResult[] results, string RunUser, Counters counterIn)
        {
            name = Name;
            IndividualResults = results;
            runUser = RunUser;
            counters = counterIn;
        }

        public Counters TestResultCounters
        { get { return this.counters; } }
    }

    public struct Counters
    {
        public string finalOutcome;
        public int totaltests;
        public int testspassed;
        public int testsfailed;
        public int inconclusive;
        public float percentagePass;
    }

    public class IndividualResult
    {
        public string testName;
        public string outcome;
        public string output;
        public string message;

        public IndividualResult()
        {
            testName = "";
            outcome = "";
            output = "";
            message = "";
        }
        public IndividualResult(string TestName, string Outcome, string Output, string Message)
        {
            testName = TestName;
            outcome = Outcome;
            output = Output;
            message = Message;
        }
    }

    public class ParsingEngine
    {
        public FileStream GetFileStream(string filePath)
        {
            if (!File.Exists(filePath))
            {
                Console.WriteLine("File not found");
                return null;
            }
            FileStream stream = File.OpenRead(filePath);
            return stream;
        }

        public TestResult LoadTestResults(FileStream stream)
        {
            XmlDocument doc = new XmlDocument();
            TestResult tres = new TestResult();
            try
            {
                doc.Load(stream);

                XmlNode testrunnode = doc.GetElementsByTagName("TestRun")[0];
                tres.name = testrunnode.Attributes["name"].InnerText;
                tres.runUser = testrunnode.Attributes["runUser"].InnerText;
                tres.counters = GetResultCounts(doc);
                tres.IndividualResults = PopulateIndividualResults(doc, tres.counters.totaltests);
            }
            catch (Exception ex)
            {
                Console.WriteLine("Error parsing xml. Message returned was: \n " + ex.Message + "\nStack trace: " + ex.StackTrace);
                return null;
            }
            stream.Close();
            return tres;
        }

        public IndividualResult[] PopulateIndividualResults(XmlDocument doc, int count)
        {
            IndividualResult[] indvresults = new IndividualResult[count];
            XmlNodeList resultNodes = doc.GetElementsByTagName("UnitTestResult");

            for (int i = 0; i < indvresults.Length; i++)
            {
                string testname = resultNodes[i].Attributes["testName"].InnerText;
                string outcome = resultNodes[i].Attributes["outcome"].InnerText;
                string message = null;
                string output = "Not found";
                if (outcome == "Passed")
                {
                    message = "";
                }
                else
                {
                    try
                    { message = resultNodes[i].ChildNodes[0].InnerText; }
                    catch
                    {
                        message = "Failure information could not be retrieved";
                    }
                }
                
                indvresults[i] = new IndividualResult(testname, outcome, output, message);
            }
            return indvresults;
        }

        public Counters GetResultCounts(XmlDocument doc)
        {
            XmlNode resultsum = doc.GetElementsByTagName("ResultSummary")[0];
            Counters c = new Counters();

            XmlNode counternode = doc.GetElementsByTagName("Counters")[0];
            c.finalOutcome = resultsum.Attributes["outcome"].Value;
            c.totaltests = Convert.ToInt32(counternode.Attributes["total"].InnerText);
            c.testspassed = Convert.ToInt32(counternode.Attributes["passed"].InnerText);
            c.testsfailed = Convert.ToInt32(counternode.Attributes["failed"].InnerText);
            c.inconclusive = c.totaltests - (c.testspassed + c.testsfailed);
            c.percentagePass = ((float)c.testspassed / c.totaltests) * 100;

            return c;
        }
    }

    class ConsoleApp
    {
        /// <summary>
        /// Originally created by amathes. Modified for use with trx files.
        /// </summary>

        static string fileName;
        static string mailTo;
        static string mailFrom;
        static string mailSubject;
        static string addInfo;
        static ParsingEngine parsingEngine;

        static void Main(string[] args)
        {
            
            if (ProcessArgs(args))
            {
                ConsoleApp.parsingEngine = new ParsingEngine();

                try
                {
                    FileStream fs = ConsoleApp.parsingEngine.GetFileStream(fileName);
                    TestResult tr = ConsoleApp.parsingEngine.LoadTestResults(fs);
                    Counters ct = tr.TestResultCounters;
                    mailSubject = mailSubject + String.Format(" -{0}% Passed", ((int)ct.percentagePass).ToString());
                    string body = CreateReport.GenerateMailBody(tr,addInfo);
                    CreateReport.SendMail(body, mailSubject, mailTo, mailFrom, fileName);

                }
                catch (Exception ex)
                {
                    Console.WriteLine(ex.ToString());
                }
            }
            else
            {
                Console.WriteLine("Usage: ParseTrx.exe -trx <vsts logfile> -to <to> -from <from> -subj <subject> -add <additionalInformation>");
            }
        }
        private static bool ProcessArgs(string[] args)
        {
            bool ret = false;
            bool invalidArgFound = false;
            int i = 0;

            if (args.Length > 0)
            {
                while ((i < args.Length) && !invalidArgFound)
                {
                    switch (args[i])
                    {
                        case "-trx":
                            ConsoleApp.fileName = args[++i];
                            break;
                        case "-to":
                            ConsoleApp.mailTo = args[++i];
                            break;
                        case "-from":
                            ConsoleApp.mailFrom = args[++i];
                            break;
                        case "-subj":
                            ConsoleApp.mailSubject = args[++i];
                            break;
                        case "-add":
                            ConsoleApp.addInfo = args[++i];
                            break;
                        default:
                            invalidArgFound = true;
                            break;
                    }
                    i++;
                }
                if (!invalidArgFound)
                {
                    ret = true;
                }
            }
            return ret;
        }

    }

    class CreateReport
    {
        /// <summary>
        /// Originally created by amathes. Modified for use with trx files.
        /// </summary>

        const string DEFAULT_EMAIL_DOMAIN = "microsoft.com";
        const string smtpHost = "smtphost.redmond.corp.microsoft.com";

        public static void SendMail(string body, string subject, string toAddress, string fromAddress, string attachment)
        {
            string from = fromAddress;
            string to = toAddress;

            if (!from.Contains("@"))
            {
                from = from + "@" + DEFAULT_EMAIL_DOMAIN;
            }
            if (!to.Contains("@"))
            {
                to = to + "@" + DEFAULT_EMAIL_DOMAIN;
            }

            MailMessage mailMessage = new MailMessage(from, to, subject, body);
            mailMessage.IsBodyHtml = true;
            try
            {
                mailMessage.Attachments.Add(new Attachment(attachment));
            }
            catch
            {
                Console.WriteLine("Attachment failed");
            }

            SmtpClient smtpClient = new SmtpClient(smtpHost);
            smtpClient.Credentials = System.Net.CredentialCache.DefaultNetworkCredentials;

            try
            {
                Console.Write("Sending report to " + toAddress + "...");
                smtpClient.Send(mailMessage);
                Console.WriteLine("done!");
            }
            catch (Exception ex)
            {
                throw new Exception("Failed to send email to " + toAddress, ex);
            }
        }

        public static string GenerateMailBody(TestResult results,string addInfo)
        {
            const string TESTSPASSED_PLACEHOLDER = "#TESTSPASSED#";
            const string TESTSFAILED_PLACEHOLDER = "#TESTSFAILED#";
            const string TESTSBLOCKED_PLACEHOLDER = "#TESTSBLOCKED#";
            const string ADDINFO_PLACEHOLDER = "#ADDITIONAL_INFO#";
            const string FEATURESTATS_PLACEHOLDER = "#FEATURESTATS#";
            const string styleInfo = @"<style type=""text/css"">" +
                                     "table{font-family: tahoma;font-size: 11px;background-color: #FCFCF5;border: 1px #ccc solid;border-collapse: collapse;}" +
                                     "td.headstyle{ text-align: center;background-color: #CCF4F4;border: 1px #ccc solid;font-family: tahoma;font-size: 12px;padding: .6em; border: 1px #ccc solid; }" +
                                     "td.leftdatastyle{ text-align: left;background-color: #FCFCF5;border: 1px #ccc solid;font-family: tahoma;font-size: 11px;padding: .6em; border: 1px #ccc solid; }" +
                                     "td.centerdatastyle{ text-align: center;background-color: #FCFCF5;border: 1px #ccc solid;font-family: tahoma;font-size: 11px;padding: .6em; border: 1px #ccc solid; }" +
                                     "td,th{padding: .4em; border: 1px #ccc solid;}" +
                                     "</style>";

            string bodyTemplate = "<head><body><font face=tahoma size=2>" +
                                  styleInfo +
                                  "<b><u>Summary</u></b><br>" +
                                  TESTSPASSED_PLACEHOLDER + " tests passed<br>" +
                                  TESTSFAILED_PLACEHOLDER + " tests failed<br>" +
                                  TESTSBLOCKED_PLACEHOLDER + "  tests blocked<br><br>" +
                                  FEATURESTATS_PLACEHOLDER + "<b><u>Additional Information</b></u><br><br>"+
                                  ADDINFO_PLACEHOLDER+
                                  "</font></body></html>";

            string ret = bodyTemplate;

            ret = ret.Replace(TESTSPASSED_PLACEHOLDER, results.counters.testspassed.ToString());
            ret = ret.Replace(TESTSFAILED_PLACEHOLDER, results.counters.testsfailed.ToString());
            ret = ret.Replace(TESTSBLOCKED_PLACEHOLDER, results.counters.inconclusive.ToString());
            
            string featureStatsTable = CreateFeatureStatsTable(results.IndividualResults);
            ret = ret.Replace(FEATURESTATS_PLACEHOLDER, featureStatsTable);
            ret = ret.Replace(ADDINFO_PLACEHOLDER, CreateAddInfoText(addInfo));
            return ret;
        }

        private static string CreateAddInfoText(string addInfo)
        {
            string ret = "";

            if (!String.IsNullOrEmpty(addInfo))
            {
                //this will act as the default value.  it will be replaced only if the string works as a path to a text file.
                ret = addInfo;

                //try to interpret supplInfo as a file and read it as text.  if this doesn't work, use it as literal text (the default value from above).
                string addInfoFilePath = Environment.ExpandEnvironmentVariables(addInfo);
                if (File.Exists(addInfoFilePath))
                {
                    ret = File.ReadAllText(addInfoFilePath);
                }

            }
            return ret;
        }

        private static string CreateFeatureStatsTable(IndividualResult[] results)
        {
            string featureStatsTable = "";
            string featureStatsRowTemplate = "";
            featureStatsRowTemplate = @"<tr><td class=""leftdatastyle"">{0}</td><td class=""centerdatastyle"">{1}</td><td class=""leftdatastyle"">{2}</td></tr>";
            featureStatsTable = "<b><u>Feature Stats</u></b><br>";
            featureStatsTable += "<table border=\"1\">";
            featureStatsTable += @"<tr><td class=""headstyle"">Test Name</td class=""headstyle""><td class=""headstyle"">Outcome</td><td class=""headstyle"">Message</td></tr>";
            foreach (IndividualResult result in results)
            {
                if (result.outcome == "Failed")
                {
                    result.testName = "<font color=red>" + result.testName + "</font>";
                    result.outcome = "<font color=red>" + result.outcome + "</font>";
                }
                featureStatsTable += string.Format(featureStatsRowTemplate,
                    result.testName,
                    result.outcome,
                    result.message
                    );
            }
            featureStatsTable += "</table><br><br>";
            return featureStatsTable;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\ViewModel\TraceViewModel.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;

using OneCardGUI.Framework;
using System.Collections.ObjectModel;

namespace OneCardGUI.ViewModel
{
    public class TraceSourceViewModel : ViewModelBase
    {
        public string Name
        {
            get {
                return _source.Name.Replace("OneCardFramework", "OCF");
            }
        }

        public bool IsEnabled
        {
            get { return _isEnabled; }
            set
            {
                if (value == _isEnabled)
                    return;

                if (value)
                    _source.Listeners.Add(_listener);
                else
                    _source.Listeners.Remove(_listener);

                _isEnabled = value;
                OnPropertyChanged("IsEnabled");
            }
        }
        private bool _isEnabled = false;


        /// <summary>
        /// Gets/sets the verbosity of tracing
        /// </summary>
        public SourceLevels Level
        {
            get { return _source.Switch.Level; }
            set { _source.Switch.Level = value; OnPropertyChanged("Level"); }
        }


        private TraceSource _source;
        private TraceListener _listener;

        public TraceSourceViewModel(TraceSource source, TraceListener listener, bool enable)
        {
            _source = source;
            _listener = listener;

            IsEnabled = enable;
        }
    }

    public class TraceViewModel : ViewModelBase
    {
        public string TraceText
        {
            get { return _traceText; }
            private set
            {
                _traceText = value;
                OnPropertyChanged("TraceText");
            }
        }
        private string _traceText;


        private TextBoxTraceListener _listener;


        public ObservableCollection<TraceSourceViewModel> Sources
        {
            get;
            private set;
        }



        public TraceViewModel()
        {
            _listener = new TextBoxTraceListener(this);
            Sources = new ObservableCollection<TraceSourceViewModel>();

            Trace.Listeners.Add(_listener);
            //Sources.Add(new TraceSourceViewModel("Trace", _listener, true);
            //Sources.Add(new TraceSourceViewModel("Debug", _listener, true);

            Sources.Add(new TraceSourceViewModel(OneCardFramework.Services.AuthenticationService.Tracer, _listener, true));
            Sources.Add(new TraceSourceViewModel(OneCardFramework.Services.GameStateService.Tracer, _listener, true));
            Sources.Add(new TraceSourceViewModel(OneCardFramework.Services.NotificationService.Tracer, _listener, true));
            Sources.Add(new TraceSourceViewModel(OneCardFramework.Services.SessionService.Tracer, _listener, true));

            Sources.Add(new TraceSourceViewModel(OneCardFramework.Cache.NotificationStore.NotificationTrace, _listener, true));
            Sources.Add(new TraceSourceViewModel(OneCardFramework.Cache.SessionStoreBase.SessionTrace, _listener, true));

            Sources.Add(new TraceSourceViewModel(OneCardFramework.WebHelper.Tracer, _listener, false));
            Sources.Add(new TraceSourceViewModel(OneCardFramework.Services.AuthenticationService.WebTracer, _listener, false));
            Sources.Add(new TraceSourceViewModel(OneCardFramework.Services.GameStateService.WebTracer, _listener, false));
            Sources.Add(new TraceSourceViewModel(OneCardFramework.Services.NotificationService.WebTracer, _listener, false));
            Sources.Add(new TraceSourceViewModel(OneCardFramework.Services.SessionService.WebTracer, _listener, false));
        }




        private class TextBoxTraceListener : TraceListener
        {
            private StringBuilder _traceBuilder = new StringBuilder();
            private TraceViewModel vm;

            public TextBoxTraceListener(TraceViewModel vm)
            {
                this.vm = vm;
            }

            public override void Write(string message)
            {
                _traceBuilder.Append(message);
            }

            public override void WriteLine(string message)
            {
                _traceBuilder.AppendLine(message);
                Flush();
            }
            public override void Flush()
            {
                base.Flush();

                string text = _traceBuilder.ToString();
                Action op = delegate
                {
                    vm.TraceText = text;
                };
                op.ExecuteOnUI();
            }
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\OneCard\OneCardGUI\ViewModel\ViewModelBase.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ComponentModel;
using System.Diagnostics;
using OneCardGUI.Framework;
using System.Reflection;

namespace OneCardGUI.ViewModel
{
    /// <summary>
    /// Base class for creating custom view models.
    /// 
    /// <remarks>View models often subscribe to events
    /// on long-living Model objects, so Dispose should be called when done using a 
    /// view model to prevent memory leaks.</remarks>
    /// </summary>
    public abstract class ViewModelBase : INotifyPropertyChanged, IDisposable
    {
        protected ViewModelBase()
        {

        }


        private PropertyInfo[] allProperties;

        /// <summary>
        /// Uses reflection to raise the PropertyChanged event for all
        /// properties of this instance
        /// </summary>
        protected virtual void NotifyAllProperties()
        {
            if (allProperties == null)
                allProperties = GetType().GetProperties();

            foreach (var prop in allProperties)
            {
                OnPropertyChanged(prop.Name);
            }
        }
        
        #region INotifyPropertyChanged Members

        public event PropertyChangedEventHandler PropertyChanged;

        /// <summary>
        /// Fires the PropertyChanged event for the specified property on the UI thread
        /// </summary>
        /// <param name="property"></param>
        protected virtual void OnPropertyChanged(string property)
        {
            this.VerifyPropertyName(property);

            Action op = delegate
            {
                var handler = PropertyChanged;
                if (handler != null)
                    handler(this, new PropertyChangedEventArgs(property));
            };
            op.ExecuteOnUI();
        }

        #endregion

        #region Debugging Aides

        /// <summary>
        /// Gets/sets whether to throw an exception when verifying property
        /// names, or just Debug.Fail.
        /// </summary>
        protected virtual bool ThrowOnInvalidPropertyName { get; set; }

        /// <summary>
        /// Helper for ensuring we keep all string references to properties up-to-date. Uses
        /// reflection to verify the property with the specified name exists as a member of this
        /// class. Only called in DEBUG mode.
        /// </summary>
        /// <param name="propertyName"></param>
        [Conditional("DEBUG")]
        [DebuggerStepThrough]
        public void VerifyPropertyName(string propertyName)
        {
            //Verify that the specified property exists on this object
            if (TypeDescriptor.GetProperties(this)[propertyName] == null)
            {
                string msg = "Invalid property name: " + propertyName;

                if (this.ThrowOnInvalidPropertyName)
                    throw new Exception(propertyName);
                else
                    Debug.Fail(msg);
            }
        }

        #endregion

        #region IDisposable Members

        public bool IsDisposed { get; private set; }

        public void Dispose()
        {
            if (IsDisposed)
                return;

            IsDisposed = true;

            this.OnDispose();
        }

        /// <summary>
        /// Performs cleanup operations. Implementations should
        /// cleanup an event subscriptions here.
        /// </summary>
        protected virtual void OnDispose() { }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\SerializerExtension\SerializerExtension.cs ===
﻿//------------------------------------------------------------------------------------
// Description:
//  Class used to extend serialization functionality
//
// <Copyright> Copyright (C) Microsoft Corporation.  All rights reserved. </Copyright>
//------------------------------------------------------------------------------------
namespace Infrastructure.Test
{
    using System;
    using System.IO;
    using System.Runtime.Serialization;
    using System.Runtime.Serialization.Json;
    using System.Text;
    using System.Xml;
    using System.Xml.Serialization;

    /// <summary>
    /// Use SerializerExtension to extend serializable class  so that
    /// the class can (de)serialize objects to and from various 
    /// formats: xml, json.
    /// </summary>
    [DataContract]
    [XmlRoot]
    public class SerializerExtension : SerializerExtensionBase
    {
        /// <summary>
        /// Member for XMLInput
        /// </summary>
        [IgnoreDataMember]
        [XmlIgnore]
        private string xmlInputMember = string.Empty;
        
        /// <summary>
        /// Stores any elements not specified
        /// </summary>
        [XmlAnyElement]
        public object[] OtherChildElements
        {
            get;
            set;
        }

        /// <summary>
        /// Stores text found in the text node
        /// </summary>
        [XmlText]
        public string TextNode 
        { 
            get; 
            set; 
        }

        /// <summary>
        /// Gets or sets the XML Input used to create the XML Response
        /// </summary>        
        [IgnoreDataMember]
        [XmlIgnore]
        public string XMLInput
        {
            get
            {
                return this.xmlInputMember;
            }
            set
            {
                if (value == null)
                {
                    throw new ArgumentNullException();
                }

                this.xmlInputMember = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\SerializerExtension\SerializerExtensionOrdered.cs ===
﻿//------------------------------------------------------------------------------------
// Description:
//  Class used to extend serialization functionality
//
// <Copyright> Copyright (C) Microsoft Corporation.  All rights reserved. </Copyright>
//------------------------------------------------------------------------------------
namespace Infrastructure.Test
{
    using System;
    using System.IO;
    using System.Runtime.Serialization;
    using System.Runtime.Serialization.Json;
    using System.Text;
    using System.Xml;
    using System.Xml.Serialization;

    /// <summary>
    /// SerializerExtension which contain an ordered element
    /// </summary>
    public class SerializerExtensionOrdered : SerializerExtensionBase
    {
        /// <summary>
        /// Member for XMLInput
        /// </summary>
        [IgnoreDataMember]
        [XmlIgnore]
        private string xmlInputMember = string.Empty;

        /// <summary>
        /// Stores any elements not specified
        /// </summary>
        [XmlAnyElement(Order = 1)]
        public object[] OtherChildElements
        {
            get;
            set;
        }

        /// <summary>
        /// Stores text found in the text node
        /// </summary>
        [XmlText]
        public string TextNode
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the XML Input used to create the XML Response
        /// </summary>        
        [IgnoreDataMember]
        [XmlIgnore]
        public string XMLInput
        {
            get
            {
                return this.xmlInputMember;
            }
            set
            {
                if (value == null)
                {
                    throw new ArgumentNullException();
                }

                this.xmlInputMember = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\SerializerExtension\SerializerExtensionBase.cs ===
﻿//------------------------------------------------------------------------------------
// Description:
//  Class used to extend serialization functionality
//
// <Copyright> Copyright (C) Microsoft Corporation.  All rights reserved. </Copyright>
//------------------------------------------------------------------------------------
namespace Infrastructure.Test
{
    using System;
    using System.IO;
    using System.Runtime.Serialization;
    using System.Runtime.Serialization.Json;
    using System.Text;
    using System.Xml;
    using System.Xml.Serialization;

    /// <summary>
    /// Use SerializerExtension to extend serializable class  so that
    /// the class can (de)serialize objects to and from various 
    /// formats: xml, json.
    /// </summary>
    [DataContract]
    [XmlRoot]
    public class SerializerExtensionBase
    {
        /// <summary>
        /// XML Seralizer
        /// </summary>
        protected XmlSerializer XS
        {
            get;
            set;
        }

        /// <summary>
        /// Namespace for xml
        /// </summary>
        [IgnoreDataMember]
        [XmlNamespaceDeclarations]
        public XmlSerializerNamespaces Xmlns
        {
            get;
            set;
        }

        /// <summary>
        /// Deserializes a xml string into an object
        /// </summary>
        /// <typeparam name="T">Object type to deserialize to</typeparam>
        /// <param name="xmlString">Xml string</param>
        /// <returns>Deserialized xml stream as an object</returns>
        public static T DeserializeDataContract<T>(string xmlString)
        {
            DataContractSerializer dcjs = new DataContractSerializer(typeof(T));
            using (MemoryStream mStream = new MemoryStream(System.Text.Encoding.UTF8.GetBytes(xmlString)))
            {
                T obj = (T)dcjs.ReadObject(mStream);
                return obj;
            }
        }

        /// <summary>
        /// Deserializes a xml stream into an object
        /// </summary>
        /// <typeparam name="T">Object type to deserialize to</typeparam>
        /// <param name="xmlStream">Xml Stream</param>
        /// <returns>Deserialized xml stream as an object</returns>
        /// <exception cref="System.InvalidOperationException">
        ///    An error occurred during deserialization. 
        ///    The original exception is available
        ///    using the System.Exception.InnerException property.
        /// </exception>   
        public static T DeserializeXml<T>(Stream xmlStream)
        {
            XmlSerializer serializer = new XmlSerializer(typeof(T));
            return (T)serializer.Deserialize(xmlStream);
        }

        /// <summary>
        /// Deserialize an xml string into an object (use this if xml may contain control characters)
        /// </summary>
        /// <typeparam name="T">Object type to deserialize to</typeparam>
        /// <param name="xmlTextReader">Xml text reader</param>
        /// <returns>Deserialized xml string as an object</returns>
        /// <exception cref="System.InvalidOperationException">
        ///    An error occurred during deserialization. 
        ///    The original exception is available
        ///    using the System.Exception.InnerException property.
        /// </exception>      
        public static T DeserializeXml<T>(XmlTextReader xmlTextReader)
        {
            XmlSerializer serializer = new XmlSerializer(typeof(T));
            
            // Set to false to prevent control characters in stream from throwing exception
            xmlTextReader.Normalization = false;

            return (T)serializer.Deserialize(xmlTextReader);
        }

        /// <summary>
        /// Deserializes a xml string into an object
        /// </summary>
        /// <typeparam name="T">Object type to deserialize to</typeparam>
        /// <param name="xmlString">Xml string</param>
        /// <returns>Deserialized xml string as an object</returns>
        /// <exception cref="System.InvalidOperationException">
        ///    An error occurred during deserialization. 
        ///    The original exception is available
        ///    using the System.Exception.InnerException property.
        /// </exception>         
        public static T DeserializeXml<T>(string xmlString)
        {
            try
            {
                MemoryStream ms = new MemoryStream(Encoding.UTF8.GetBytes(xmlString));
                ms.Position = 0;

                T obj = DeserializeXml<T>(ms);
                ms.Close();

                return obj;
            }
            catch (Exception exc)
            {
                throw new Exception("Failed to be able to DeserializeXml this xml: \r\n-[" + xmlString + "]-", exc);
            }
        }

        /// <summary>
        /// Deserialize JSON stream into an object
        /// </summary>
        /// <typeparam name="T">Object type to deserialize to</typeparam>
        /// <param name="jsonStream">JSON stream</param>
        /// <returns>Deserialized JSON to an object</returns>
        public static T DeserializeJSON<T>(Stream jsonStream)
        {
            // Reset the stream position to after the byte mark order
            // JSON serializer doesn't handle byte order marks in stream
            // due to unicode encoding schemes.
            SkipUnicodeBOM(jsonStream);
            
            DataContractJsonSerializer jser = new DataContractJsonSerializer(typeof(T));
            T obj = (T)jser.ReadObject(jsonStream);
            return obj;
        }

        /// <summary>
        /// Deserialize JSON string into an object
        /// </summary>
        /// <typeparam name="T">Object type to deserialize to</typeparam>
        /// <param name="jsonString">JSON string</param>
        /// <returns>Deserialized JSON string to an object</returns>
        public static T DeserializeJSON<T>(string jsonString)
        {
            MemoryStream ms = new MemoryStream(Encoding.UTF8.GetBytes(jsonString));
            ms.Position = 0;

            T obj = DeserializeJSON<T>(ms);
            ms.Close();
            
            return obj;
        }

        /// <summary>
        /// Generic serializer
        /// </summary>
        /// <typeparam name="T">Object type to serialize</typeparam>
        /// <param name="serializeObj">Object to serlaize</param>
        /// <param name="fileName">File name to output to</param>
        public static void SerializeToXml<T>(T serializeObj, string fileName)
        {
            XmlSerializer serializer = new XmlSerializer(typeof(T));

            using (Stream fileStream = new FileStream(fileName, FileMode.Create, FileAccess.Write, FileShare.None))
            {
                serializer.Serialize(fileStream, serializeObj);
                fileStream.Close();
            }
        }

        /// <summary>
        /// Converts object to xml string representation
        /// </summary>
        /// <returns>Serialized object as an XML string</returns>
        public virtual string SerializeToXmlString()
        {
            return SerializeToXmlString(true);
        }

        /// <summary>
        /// Converts object to xml string representation
        /// </summary>
        /// <param name="formatPretty">Format the output with indents and spacing</param>
        /// <returns>Serialized object as an XML string</returns>
        public virtual string SerializeToXmlString(bool formatPretty)
        {
            XmlQualifiedName[] ns = null;

            if (this.Xmlns != null)
            {
                ns = this.Xmlns.ToArray();
            }

            return this.SerializeToXmlString(ns, null, null, formatPretty);
        }

        /// <summary>
        /// Serialize the object to an xml using customize name spaces in output.
        /// </summary>        
        /// <param name="nameSpaces">Collection of prefix + namespace to include in xml</param>
        /// <param name="overrides">Overrides for xmlattributes</param>
        /// <param name="encoding">Encoding format</param>
        /// <param name="formatPretty">Format the output with indents and spacing</param>
        /// <returns>Serialized object as an XML string</returns>
        public virtual string SerializeToXmlString(XmlQualifiedName[] nameSpaces, XmlAttributeOverrides overrides, Encoding encoding, bool formatPretty)
        {
            XmlTextWriter writer;
            string output = string.Empty;
            MemoryStream ms = new MemoryStream();
            XmlSerializerNamespaces ns = new XmlSerializerNamespaces();

            if (XS == null)
            {
                if (overrides != null)
                {
                    XS = new XmlSerializer(this.GetType(), overrides);
                }
                else
                {
                    XS = new XmlSerializer(this.GetType());
                }
            }

            // Set the default encoding to UTF8
            if (encoding == null)
            {
                encoding = Encoding.UTF8;
            }

            // Setup the writer to output the xml text
            writer = new XmlTextWriter(ms, encoding);

            if (formatPretty)
            {    
                writer.Indentation = 4;
                writer.IndentChar = ' ';
                writer.Formatting = Formatting.Indented;
            }

            if (nameSpaces == null || nameSpaces.Length == 0)
            {
                // Use a special custom writer class to omit namespace
                // properties no namespace is specified if specified
                writer = new XmlCustomWriter(ms, encoding);
            }
            else
            {
                // Load each namespace
                foreach (XmlQualifiedName nameSpace in nameSpaces)
                {
                    ns.Add(nameSpace.Name, nameSpace.Namespace);
                }
            }

            XS.Serialize(writer, this, ns);
            writer.Flush();

            // Read the stream and save to string
            ms.Position = 0;
            using (StreamReader sr = new StreamReader(ms))
            {
                output = sr.ReadToEnd();
            }

            return output.ToString();
        }

        /// <summary>
        /// Converts object, via a DataContractSerializer, to xml string representation
        /// </summary>
        /// <returns>Serialized object as an XML string</returns>
        public string DataContractSerializeToXmlString()
        {
            string output = string.Empty;
            using (MemoryStream mStream = new MemoryStream())

            using (StreamReader reader = new StreamReader(mStream))
            {
                DataContractSerializer dcs = new DataContractSerializer(this.GetType());

                dcs.WriteObject(mStream, this);
                mStream.Position = 0;

                output = reader.ReadToEnd();

                return output;
            }
        }

        /// <summary>
        /// Converts object to JSON string
        /// </summary>
        /// <returns>Object as a JSON string</returns>
        public virtual string SerializeToJSON()
        {
            DataContractJsonSerializer jser = new DataContractJsonSerializer(this.GetType());
            
            MemoryStream ms = new MemoryStream();
            jser.WriteObject(ms, this);

            return Encoding.UTF8.GetString(ms.ToArray());
        }

        /// <summary>
        /// Returns the xml in a document object
        /// </summary>
        /// <returns>Object as an XmlDocment</returns>
        public XmlDocument ToXmlDocument()
        {
            XmlDocument doc = new XmlDocument();
            doc.LoadXml(this.SerializeToXmlString());
            return doc;
        }

        /// <summary>
        /// Skips the unicode byte order mark found in the stream for UTF-8, UTF-16, UTF-32
        /// </summary>
        /// <param name="fs">Stream containing unicode text</param>
        private static void SkipUnicodeBOM(Stream fs)
        {
            byte[] mark = new byte[4];

            fs.Position = 0;
            int readBytes = fs.Read(mark, 0, mark.Length);
            
            if (readBytes == 0)
            {
                throw new Exception("Error reading stream");
            }

            if (mark[0] == 239 && mark[1] == 187 && mark[2] == 191)
            {
                // EF BB BF - UTF8
                fs.Position = 3;
            }
            else if (mark[0] == 254 && mark[1] == 255)
            {
                // FE FF - UTF16 (Big Endian)
                fs.Position = 2;
            }
            else if (mark[0] == 254 && mark[1] == 255)
            {
                // FF FE - UTF16 (Little Endian) else it is FF FE - UTF32 (Big Endian)
                if (mark[2] != 0 && mark[3] != 0)
                {
                    fs.Position = 2;
                }
            }
            else if (mark[0] == 0 && mark[1] == 0 && mark[2] == 254 && mark[3] == 255)
            {
                // FE FF - UTF32 (Big Endian & Little Endian)
            }
            else
            {
                fs.Position = 0;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\SerializerExtension\Properties\AssemblyInfo.cs ===
﻿//------------------------------------------------------------------------------------
// Description:
// 
//
// <Copyright> Copyright (C) Microsoft Corporation.  All rights reserved. </Copyright>
//------------------------------------------------------------------------------------
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("SerializerExentension")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
// [assembly: AssemblyCompany("MS")]
// [assembly: AssemblyProduct("SerializerExentension")]
// [assembly: AssemblyCopyright("Copyright © MS 2008")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("671bb201-da94-4fa0-a64d-3ac829874379")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
// [assembly: AssemblyVersion("1.0.0.0")]
// [assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\SerializerExtension\XmlCustomWriter.cs ===
﻿//------------------------------------------------------------------------------------
// Description:
//  Allows for better control of writing xml files.
//
// <Copyright> Copyright (C) Microsoft Corporation.  All rights reserved. </Copyright>
//------------------------------------------------------------------------------------
namespace Infrastructure.Test
{
    using System;
    using System.IO;
    using System.Text;
    using System.Xml;

    /// <summary>
    /// Used XmlCustomWriter allows for better control of the output xml 
    /// default settings are:
    ///  - uses indents
    ///  - indents are four spaces
    ///  - name space is skipped
    /// </summary>
    public class XmlCustomWriter : XmlTextWriter
    {
        /// <summary>
        /// Flag to skip namespace
        /// </summary>
        private bool skipNameSpace = false;

        /// <summary>
        /// Flag used whether to use the name space or not
        /// </summary>
        private bool useNameSpace = false;

        /// <summary>
        /// Initializes a new instance of the XmlCustomWriter class.
        /// </summary>
        /// <param name="w">the text writer</param>
        public XmlCustomWriter(TextWriter w)
            : base(w)
        {
            this.SetWriteSettings();
        }

        /// <summary>
        /// Initializes a new instance of the XmlCustomWriter class
        /// </summary>
        /// <param name="w">the Stream</param>
        /// <param name="encoding">Encoding type</param>
        public XmlCustomWriter(Stream w, Encoding encoding)
            : base(w, encoding)
        {
            this.SetWriteSettings();
        }

        /// <summary>
        /// Initializes a new instance of the XmlCustomWriter class
        /// </summary>
        /// <param name="filename">the File name</param>
        /// <param name="encoding">Encoding type</param>
        public XmlCustomWriter(string filename, Encoding encoding) :
            base(new FileStream(filename, FileMode.Create, FileAccess.Write, FileShare.None), encoding)
        {
            this.SetWriteSettings();
        }

        /// <summary>
        /// Gets or sets a value indicating whether to use namespace and namespace prefix or not
        /// </summary>
        public bool UseNameSpace
        {
            get
            {
                return this.useNameSpace;
            }

            set
            {
                this.useNameSpace = value;
            }
        }

        /// <summary>
        /// Override the start attribute write event
        /// </summary>
        /// <param name="prefix">Prefix of attribute</param>
        /// <param name="localName">Local name of attribute</param>
        /// <param name="ns">Namespace of attribute</param>
        public override void WriteStartAttribute(string prefix, string localName, string ns)
        {
            // Doesn't remove "xmlns=" but will remove proper formatted xmlns:name=namespace
            if (this.useNameSpace == false && prefix == "xmlns" && 
                (localName == "xsd" || localName == "xsi" || localName == "xmlns"))
            {
                this.skipNameSpace = true;
                return;
            }

            // If prefix is empty don't set namespace string
            if (String.IsNullOrEmpty(prefix))
            {
                ns = String.Empty;
            }
            
            base.WriteStartAttribute(prefix, localName, ns);
        }

        /// <summary>
        /// Override the write string event
        /// </summary>
        /// <param name="text">Text to write</param>
        public override void WriteString(string text)
        {
            if (this.skipNameSpace)
            {
                return;
            }

            base.WriteString(text);
        }

        /// <summary>
        /// Ovveride the write end attribute event
        /// </summary>
        public override void WriteEndAttribute()
        {
            if (this.skipNameSpace)
            {
                // Reset the flag
                this.skipNameSpace = false;
                return;
            }

            base.WriteEndAttribute();
        }

        /// <summary>
        /// Overrides the start event of writing a start element
        /// </summary>
        /// <param name="prefix">Prefix is ignored</param>
        /// <param name="localName">Local name</param>
        /// <param name="ns">name space</param>
        public override void WriteStartElement(string prefix, string localName, string ns)
        {
            if (this.useNameSpace == false)
            {
                ns = string.Empty;
            }

            base.WriteStartElement(prefix, localName, ns);
        }
         
        /// <summary>
        /// Sets the write settings
        /// </summary>
        private void SetWriteSettings()
        {
            Formatting = Formatting.Indented;
            Indentation = 4;
            IndentChar = ' ';
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\SerializerExtension\Unit Tests\Tree.cs ===
﻿//------------------------------------------------------------------------------------
// Description:
//  Sample object that is serializable
//
// <Copyright> Copyright (C) Microsoft Corporation.  All rights reserved. </Copyright>
//------------------------------------------------------------------------------------
namespace Infrastructure.Test
{
    using System;
    using System.Collections.Generic;
    using System.Xml.Serialization;
    
    /// <summary>
    /// Wrapper class due to stylecop 
    /// </summary>
    public class SerializeExample
    {
        /// <summary>
        /// The object tree correlates with the "root" element in the xml.
        /// </summary>
        [XmlRoot(ElementName = "root")]
        public partial class Tree : SerializerExtension
        {
            /// <summary>
            /// This represents the "branches" tag element in the xml
            /// </summary>
            [XmlElement(ElementName = "branches")]
            public Branches Branches { get; set; }
        }

        /// <summary>
        /// Branches element
        /// </summary>
        [XmlRoot(ElementName = "branches")]
        public partial class Branches : SerializerExtension
        {
            /// <summary>
            /// This represents all the "branch" tag elements in the xml
            /// </summary>
            [XmlElement(ElementName = "branch")]
            public List<Branch> Branch { get; set; }
        }

        /// <summary>
        /// Branch element
        /// </summary>
        [XmlRoot(ElementName = "branch")]
        public partial class Branch : SerializerExtension
        {
            /// <summary>
            /// Diameter object - ignore it so it doesn't get output to an xmlelement
            /// </summary>
            [XmlIgnore]
            public Diameter DiameterObj { get; set; }

            /// <summary>
            /// This represents all the "leaf" tag elements in the xml.
            /// </summary>
            [XmlElement(ElementName = "leaf")]
            public List<Leaf> Leaves { get; set; }

            /// <summary>
            /// Gets or sets the diameter object and assigns the attribute value of diameter
            /// to the diameter object
            /// </summary>
            [XmlAttribute(AttributeName = "diameter")]
            public string Diameter
            {
                get
                {
                    if (this.DiameterObj == null)
                    {
                        return null;
                    }

                    return this.DiameterObj.Value;
                }

                set
                {
                    if (this.DiameterObj == null)
                    {
                        this.DiameterObj = new Diameter(value);
                    }
                }
            }
        }

        /// <summary>
        /// Diameter class
        /// </summary>
        [XmlType]
        public partial class Diameter : SerializerExtension
        {
            /// <summary>
            /// Diameter value
            /// </summary>
            private string diameter;

            /// <summary>
            /// Initializes a new instance of the Diameter class.
            /// </summary>
            public Diameter()
            {
            }

            /// <summary>
            /// Initializes a new instance of the Diameter class. Constructor with value
            /// </summary>
            /// <param name="value">the new value</param>
            public Diameter(string value)
            {
                this.diameter = value;
            }

            /// <summary>
            /// Gets or sets the value of a private memeber 
            /// </summary>
            [XmlAttribute(AttributeName = "diameter")]
            public string Value
            {
                get
                {
                    return this.diameter;
                }

                set
                {
                    this.diameter = value;
                }
            }

            /// <summary>
            /// Generates random value for diameter between
            /// 8 and 21
            /// </summary>
            public void GenerateRandom()
            {
                Random rnd = new Random();

                this.diameter = rnd.Next(8, 21).ToString();
            }
        }

        /// <summary>
        /// The Leaf node
        /// </summary>
        [XmlRoot(ElementName = "leaf")]
        public partial class Leaf : SerializerExtension
        {
            /// <summary>
            /// Initializes a new instance of the Leaf class.
            /// </summary>
            public Leaf()
            {
            }

            /// <summary>
            /// Initializes a new instance of the Leaf class. Constructor with color
            /// </summary>
            /// <param name="color">string value of color</param>
            public Leaf(string color)
            {
                this.Color = color;
            }

            /// <summary>
            /// This represents the "color" attribute in the leaf element.
            /// </summary>
            [XmlAttribute(AttributeName = "color")]
            public string Color { get; set; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\IResult.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LiveN.Test.Services
{
    /// <summary>
    /// 
    /// </summary>
    public interface IResult
    {
        /// <summary>
        /// 
        /// </summary>
        TimeSpan Latency
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        bool Passed
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        Exception Error
        {
            get;
            set;
        }
        
        /// <summary>
        /// 
        /// </summary>
        void Start();        

        /// <summary>
        /// 
        /// </summary>
        void Stop();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\SerializerExtension\Unit Tests\SerializerUnitTests.cs ===
﻿//------------------------------------------------------------------------------------
// Description:
//  Unit test for the SerializerExention class
//
// <Copyright> Copyright (C) Microsoft Corporation.  All rights reserved. </Copyright>
//------------------------------------------------------------------------------------
namespace Infrastructure.Test
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Reflection;
    using System.Text;
    using System.Xml;
    using System.Xml.XPath;
    using Microsoft.VisualStudio.TestTools.UnitTesting;
    using Branch = Infrastructure.Test.SerializeExample.Branch;
    using Leaf = Infrastructure.Test.SerializeExample.Leaf;
    using Tree = Infrastructure.Test.SerializeExample.Tree;
    
    /// <summary>
    /// Gzip Unit Tests
    /// </summary>
    [TestClass]
    public class SerializerExtensionUnitTests
    {
        /// <summary>
        /// Gets the Sample1.xml stream
        /// </summary>
        public Stream Sample1XmlStream
        {
            get
            {
                return Assembly.GetExecutingAssembly().GetManifestResourceStream("Infrastructure.Test.SerializerExtension.Unit_Tests.Data.Sample1.xml");
            }
        }

        /// <summary>
        /// Gets the Sampe1JSON.txt stream
        /// </summary>
        public Stream Sample1JSONStream
        {
            get
            {
                return Assembly.GetExecutingAssembly().GetManifestResourceStream("Infrastructure.Test.SerializerExtension.Unit_Tests.Data.Sample1.json");
            }
        }

        /// <summary>
        /// Create test gzip files
        /// </summary>
        [TestInitialize()]
        public void TestInitialize()
        {
        }

        /// <summary>
        /// See Unit Test Description
        /// </summary>
        [TestMethod]
        [Owner("rsnyder")]
        [Description("Simply loads the xml into an object tree that defines the xml")]
        public void DeserializeXml()
        {
            Tree t = SerializerExtension.DeserializeXml<Tree>(this.Sample1XmlStream);
            Assert.AreEqual(t.Branches.Branch.Count, 3, "Number of branches the tree has");
        }

        /// <summary>
        /// See Unit Test Description
        /// </summary>
        [TestMethod]
        [Owner("rsnyder")]
        [Description("Simply loads the xml into an object tree that defines the xml")]
        public void OutputXmlString()
        {
            Tree t = SerializerExtension.DeserializeXml<Tree>(this.Sample1XmlStream);
            Branch newBranch = new Branch();
            newBranch.Leaves = new List<Leaf>();
            newBranch.Leaves.Add(new Leaf("violet"));
            newBranch.Leaves.Add(new Leaf("orange"));
            newBranch.Leaves.Add(new Leaf("black"));
            t.Branches.Branch.Add(newBranch);

            // Verify that the new branch is in the XML.
            XmlDocument doc = new XmlDocument();
            doc.LoadXml(t.SerializeToXmlString());
            XmlNodeList branches = doc.GetElementsByTagName("branch");
            Assert.AreEqual(branches.Count, 4, "New branch should be inserted");
            Assert.AreEqual(branches[3].ChildNodes.Count, 3, "Should be three leaves");
            Assert.IsNotNull(doc.SelectSingleNode("/root/branches/branch/leaf[@color='orange']"), "Second leaf should be orange");
        }

        /// <summary>
        /// See Unit Test Description
        /// </summary>
        [TestMethod]
        [Owner("rsnyder")]
        [Description("Simply loads the xml into an object tree and output to JSON")]
        public void ReadJSONString()
        {
            Tree t = SerializerExtension.DeserializeJSON<Tree>(this.Sample1JSONStream);
            Assert.AreEqual(3, t.Branches.Branch.Count, "Number of branches should be 3");
        }

        /// <summary>
        /// See Unit Test Description
        /// </summary>
        [TestMethod]
        [Owner("rsnyder")]
        [Description("Simply loads the xml into an object tree and output to JSON")]
        public void OutputJSONString()
        {
            Tree t = SerializerExtension.DeserializeXml<Tree>(this.Sample1XmlStream);
            string json = t.SerializeToJSON();

            Assert.AreEqual("{\"Branches\":{\"Branch\":[{\"Diameter\":\"9\",\"DiameterObj\":{\"Value\":\"9\"},\"Leaves\":[{\"Color\":\"green\"},{\"Color\":\"red\"},{\"Color\":\"yellow\"}]},{\"Diameter\":\"5\",\"DiameterObj\":{\"Value\":\"5\"},\"Leaves\":[{\"Color\":\"yellow\"}]},{\"Diameter\":\"5\",\"DiameterObj\":{\"Value\":\"5\"},\"Leaves\":[]}]}}", json);
        }

        /// <summary>
        /// See Unit Test Description
        /// </summary>
        [TestMethod]
        [Owner("rsnyder")]
        [Description("Adds another branch element")]
        public void AddingElement()
        {
            Tree t = SerializerExtension.DeserializeXml<Tree>(this.Sample1XmlStream);
            Branch newBranch = new Branch();
            newBranch.Leaves = new List<Leaf>();
            newBranch.Leaves.Add(new Leaf("violet"));
            newBranch.Leaves.Add(new Leaf("orange"));
            newBranch.Leaves.Add(new Leaf("black"));
            t.Branches.Branch.Add(newBranch);

            // Verify that the new branch is in the XML.
            Tree r = SerializerExtension.DeserializeXml<Tree>(t.SerializeToXmlString(null, null, Encoding.UTF8, true));
            Assert.AreEqual(r.Branches.Branch.Count, 4, "Should have a fourth branch");
        }

        /// <summary>
        /// See Unit Test Description
        /// </summary>
        [TestMethod]
        [Owner("rsnyder")]
        [Description("Removes the second branch element")]
        public void RemovingElement()
        {
            Tree t = SerializerExtension.DeserializeXml<Tree>(this.Sample1XmlStream);
            t.Branches.Branch[1] = null;

            // Verify that the new branch is in the XML.
            Tree r = SerializerExtension.DeserializeXml<Tree>(t.SerializeToXmlString(null, null, Encoding.UTF8, true));
            Assert.AreEqual(r.Branches.Branch.Count, 2, "Should have a fourth branch");
        }

        /// <summary>
        /// See Unit Test Description
        /// </summary>
        [TestMethod]
        [Owner("rsnyder")]
        [Description("Uses a customize extended methods to set value")]
        public void ChangeAttributeValueViaMethod()
        {
            Tree t = SerializerExtension.DeserializeXml<Tree>(this.Sample1XmlStream);
            t.Branches.Branch[1].DiameterObj.GenerateRandom();

            // Verify that the new branch is in the XML.
            Tree r = SerializerExtension.DeserializeXml<Tree>(t.SerializeToXmlString(null, null, Encoding.UTF8, true));
            Assert.IsTrue(Int32.Parse(r.Branches.Branch[1].DiameterObj.Value) >= 8, "Random value should be greater than 8");
        }

        /// <summary>
        /// See Unit Test Description
        /// </summary>
        [TestMethod]
        [Owner("rsnyder")]
        [Description("Changes an attribute value")]
        public void ChangeAttributeValue()
        {
            Tree t = SerializerExtension.DeserializeXml<Tree>(this.Sample1XmlStream);
            t.Branches.Branch[1].Leaves[0].Color = "Wierd";

            // Verify that the new branch is in the XML.
            Tree r = SerializerExtension.DeserializeXml<Tree>(t.SerializeToXmlString(null, null, Encoding.UTF8, true));
            Assert.AreEqual(r.Branches.Branch[1].Leaves[0].Color, "Wierd", "Color should be set to wierd");
        }

        /// <summary>
        /// See Unit Test Description
        /// </summary>
        [TestMethod]
        [Owner("rsnyder")]
        [Description("Changes an attribute value")]
        public void RemoveAttribute()
        {
            Tree t = SerializerExtension.DeserializeXml<Tree>(this.Sample1XmlStream);
            t.Branches.Branch[1].Leaves[0].Color = null;

            // Verify that the new branch is in the XML.
            Tree r = SerializerExtension.DeserializeXml<Tree>(t.SerializeToXmlString(null, null, Encoding.UTF8, true));
            Assert.AreEqual(r.Branches.Branch[1].Leaves[0].Color, null, "Color should not be present");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Multiplayer.Common")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("Multiplayer.Common")]
[assembly: AssemblyCopyright("Copyright © Microsoft 2010")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("eb4fc335-0427-4444-aaba-bf05f00b2552")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\MonitoringBlock.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Reflection;
using System.Diagnostics;

using LiveN.Test.Framework.Configuration;

namespace LiveN.Test.Services
{
    public delegate void TestStarted(TestInfo testInfo, MonitoringBlock sender);
    public delegate void TestCompleted(TestInfo testInfo, IResult result, MonitoringBlock sender);
    
    /// <summary>
    /// 
    /// </summary>
    public abstract class MonitoringBlock
    {
         public MonitoringBlock(string environment)
        {
            LiveN.Test.Framework.Configuration.EnvironmentElement envSettings = LiveN.Test.Framework.Configuration.Config.EnvironmentSettings.Environments[environment];

            if (envSettings == null)
            {
                throw new ApplicationException(String.Format("No environment settings found for '{0}.'", environment));
            }
            
            this.Environment = envSettings;
        }

        public LiveN.Test.Framework.Configuration.EnvironmentElement Environment
        {
            get;
            protected set;
        }

        public abstract string Name
        {
            get;
        }

        public abstract string FullName
        {
            get;
        }

        /// <summary>
        /// Used to indicate left-to-right (more stable to less stable) ordering of areas in the environment gadget and verifier tool UI.
        /// </summary>
        public virtual int Priority
        {
            get
            {
                return 1;
            }
        }

        public event TestStarted TestStarted;

        public event TestCompleted TestCompleted;

        public abstract List<IResult> RunTests();

        public abstract List<TestInfo> GetTestNames();

        protected virtual void StartTest(TestInfo testInfo)
        {
            if (this.TestStarted != null)
                this.TestStarted(testInfo, this);
        }

        protected virtual void EndTest(TestInfo testInfo, IResult result)
        {
            if (this.TestCompleted != null)
                this.TestCompleted(testInfo, result, this);
        }

        protected TestInfo GetTestInfo()
        {
            StackTrace stackTrace = new StackTrace();
            for (int i = 0; i < stackTrace.FrameCount; i++)
            {
                StackFrame frame = stackTrace.GetFrame(i);
                MethodBase method = frame.GetMethod();
                TestInfo testInfo = GetTestInfoFromMethod(method);
                if (testInfo != null)
                    return testInfo;
            }

            return null;
        }

        protected List<TestInfo> GetMonitoringTests()
        {
            List<TestInfo> tests = new List<TestInfo>();
            Type monitoringBlockClass = this.GetType();

            MethodInfo[] methods = monitoringBlockClass.GetMethods(BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance);
            for (int i = 0; i < methods.Length; i++)
            {
                TestInfo testInfo = GetTestInfoFromMethod(methods[i]);
                if (testInfo != null)
                    tests.Add(testInfo);
            }

            return tests;
        }

        private TestInfo GetTestInfoFromMethod(MethodBase method)
        {
            object[] attributes = method.GetCustomAttributes(typeof(MonitoringTest), false);
            if (attributes.Length > 0)
            {
                MonitoringTest test = attributes[0] as MonitoringTest;
                return new TestInfo() { Name = test.Name, Id = test.Id };
            }

            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\MonitoringTest.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LiveN.Test.Services
{
    /// <summary>
    /// 
    /// </summary>
    [AttributeUsage(AttributeTargets.Method, AllowMultiple=false)]
    public class MonitoringTest: Attribute
    {
        /// <summary>
        /// 
        /// </summary>
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string Id
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\Result.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LiveN.Test.Services
{
    /// <summary>
    /// 
    /// </summary>
    public class Result<T>: IResult
    {
        DateTime start;

        /// <summary>
        /// 
        /// </summary>
        public TimeSpan Latency
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public T ReturnValue
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public bool Passed
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public Exception Error
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public void Start()
        {
            this.start = DateTime.Now;
        }

        /// <summary>
        /// 
        /// </summary>
        public void Stop()
        {
            if(this.start != DateTime.MinValue)
                this.Latency = DateTime.Now.Subtract(this.start);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\PDLCServices_MonitoringBlock.cs ===
﻿using System;
using System.Reflection;
using System.Diagnostics;
using System.Configuration;
using System.Collections.Generic;

using LiveNew.Test;

using PDLC.Tests;
using LiveN.Test.Services;

using AsyncMultiplayer.NotificationService;

namespace LiveN.Test.Services
{
    public class PDLCServices_MonitoringBlock : MonitoringBlock
    {
        /// <summary>
        /// The Environment that your tests should run against
        /// </summary>
        private EnvironmentElement runEnvironment;

        /// <summary>
        /// Class containing all the Gadget Tests for PDLC
        /// </summary>
        private GadgetTests gadgetTests = new GadgetTests(); 

        public PDLCServices_MonitoringBlock(string environmentName)
            : base(environmentName)
        {
            //TODO RobStartHere: FIX: Temp Hack in order to get the Gadget tool to work. As it uses different names then all other configuration files. Fix that tool
            switch (environmentName)
            {
                case "Dev":

                    environmentName = "le-xblob-dev02";

                    Trace.WriteLine("****DEV Environment is set to Xblob; " + environmentName + "*****");

                    break;

                case "TEST":

                    environmentName = "TestNet";
                    break;

                case "CERT":

                    environmentName = "CertNet";
                    break;

                case "PART":

                    environmentName = "PartnerNet";
                    break;

                case "PROD":

                    environmentName = "Production";
                    break;
            }

            // Set the Selected Environment based off the Selected Base Environment
            runEnvironment = CurrentEnvironmentSettings.AllEnvironmentSettings.Environments[environmentName];
        }

        /// <summary>
        /// Name used within the Tab
        /// </summary>
        public override string Name
        {
            get { return "PDLCServices"; }
        }

        /// <summary>
        /// Name used within the Tab Hover over text
        /// </summary>
        public override string FullName
        {
            get { return "PDLCServices"; }
        }

        /// <summary>
        /// Set the priority order of th tab
        /// </summary>
        public override int Priority
        {
            get
            {
                return 9;
            }
        }

        /// <summary>
        /// Gets all the test names contained within the test suite
        /// </summary>
        /// <returns></returns>
        public override List<TestInfo> GetTestNames()
        {
            return GetMonitoringTests();
        }

        /// <summary>
        /// Run all tests within this test suite.
        /// </summary>
        /// <returns>List of test resutls</returns>
        public override List<IResult> RunTests()
        {
            List<IResult> results = new List<IResult>();

            // Set up the environment to represent the User Selected Environment
            gadgetTests.SelectedEnvironment = runEnvironment;

            results.Add(this.ConsumeAssets());
            results.Add(this.GamerContext());
            results.Add(this.GetAssets());
            results.Add(this.GetPointsBalance());
            results.Add(this.GetReceipts_Unsigned());
            results.Add(this.GetReceipts_Signed());
            results.Add(this.Purchase());
            results.Add(this.VerifyToken());

            return results;
        }

        [MonitoringTest(Name = "GamerContext", Id = "B0680ABD-5A2C-4804-A1A4-E7635D778600")]
        private Result<bool> GamerContext()
        {
            TestInfo testInfo = GetTestInfo();
            Result<bool> result = new Result<bool>();

            try
            {
                Trace.WriteLine("***** GamerContext STARTED");

                result.Start();
                StartTest(testInfo);

                gadgetTests.GadgetTests_GamerContext();

                result.ReturnValue = result.Passed = true;
            }
            catch (Exception e)
            {
                result.ReturnValue = result.Passed = false;
                result.Error = e;

                Trace.WriteLine("GamerContext Exception: \r\n" + e.ToString());
            }
            finally
            {
                result.Stop();
                EndTest(testInfo, result);

                Trace.WriteLine("***** GamerContext FINISHED. Took " + result.Latency.TotalMilliseconds + "ms.");
            }

            return result;
        }

        [MonitoringTest(Name = "GetAssets", Id = "B0680ABD-5A2C-4804-A1A4-E7635D778601")]
        private Result<bool> GetAssets()
        {
            TestInfo testInfo = GetTestInfo();
            Result<bool> result = new Result<bool>();

            try
            {
                Trace.WriteLine("***** GetAssets STARTED");

                result.Start();
                StartTest(testInfo);

                gadgetTests.GadgetTests_GetAssets();

                result.ReturnValue = result.Passed = true;
            }
            catch (Exception e)
            {
                result.ReturnValue = result.Passed = false;
                result.Error = e;

                Trace.WriteLine("GetAssets Exception: \r\n" + e.ToString());
            }
            finally
            {
                result.Stop();
                EndTest(testInfo, result);

                Trace.WriteLine("***** GetAssets FINISHED. Took " + result.Latency.TotalMilliseconds + "ms.");
            }

            return result;
        }

        [MonitoringTest(Name = "GetPointsBalance", Id = "B0680ABD-5A2C-4804-A1A4-E7635D778602")]
        private Result<bool> GetPointsBalance()
        {
            TestInfo testInfo = GetTestInfo();
            Result<bool> result = new Result<bool>();

            try
            {
                Trace.WriteLine("***** GetPointsBalance STARTED");

                result.Start();
                StartTest(testInfo);

                gadgetTests.GadgetTests_GetPointsBalance();

                result.ReturnValue = result.Passed = true;
            }
            catch (Exception e)
            {
                result.ReturnValue = result.Passed = false;
                result.Error = e;

                Trace.WriteLine("GetPointsBalance Exception: \r\n" + e.ToString());
            }
            finally
            {
                result.Stop();
                EndTest(testInfo, result);

                Trace.WriteLine("***** GetPointsBalance FINISHED. Took " + result.Latency.TotalMilliseconds + "ms.");
            }

            return result;
        }

        [MonitoringTest(Name = "GetReceipts_Unsigned", Id = "B0680ABD-5A2C-4804-A1A4-E7635D778603")]
        private Result<bool> GetReceipts_Unsigned()
        {
            TestInfo testInfo = GetTestInfo();
            Result<bool> result = new Result<bool>();

            try
            {
                Trace.WriteLine("***** GetReceipts_Unsigned STARTED");

                result.Start();
                StartTest(testInfo);

                gadgetTests.GadgetTests_GetReceiptsUnsigned();

                result.ReturnValue = result.Passed = true;
            }
            catch (Exception e)
            {
                result.ReturnValue = result.Passed = false;
                result.Error = e;

                Trace.WriteLine("GetReceipts_Unsigned Exception: \r\n" + e.ToString());
            }
            finally
            {
                result.Stop();
                EndTest(testInfo, result);

                Trace.WriteLine("***** GetReceipts_Unsigned FINISHED. Took " + result.Latency.TotalMilliseconds + "ms.");
            }

            return result;
        }

        [MonitoringTest(Name = "GetReceipts_Signed", Id = "B0680ABD-5A2C-4804-A1A4-E7635D778693")]
        private Result<bool> GetReceipts_Signed()
        {
            TestInfo testInfo = GetTestInfo();
            Result<bool> result = new Result<bool>();

            try
            {
                Trace.WriteLine("***** GetReceipts_Signed STARTED");

                result.Start();
                StartTest(testInfo);

                gadgetTests.GadgetTests_GetReceiptsSigned();

                result.ReturnValue = result.Passed = true;
            }
            catch (Exception e)
            {
                result.ReturnValue = result.Passed = false;
                result.Error = e;

                Trace.WriteLine("GetReceipts_Signed Exception: \r\n" + e.ToString());
            }
            finally
            {
                result.Stop();
                EndTest(testInfo, result);

                Trace.WriteLine("***** GetReceipts_Signed FINISHED. Took " + result.Latency.TotalMilliseconds + "ms.");
            }

            return result;
        }

        [MonitoringTest(Name = "Purchase", Id = "B0680ABD-5A2C-4804-A1A4-E7635D778604")]
        private Result<bool> Purchase()
        {
            TestInfo testInfo = GetTestInfo();
            Result<bool> result = new Result<bool>();

            try
            {
                Trace.WriteLine("***** Purchase STARTED");

                result.Start();
                StartTest(testInfo);

                gadgetTests.GadgetTests_Purchase();

                result.ReturnValue = result.Passed = true;
            }
            catch (Exception e)
            {
                result.ReturnValue = result.Passed = false;
                result.Error = e;

                Trace.WriteLine("Purchase Exception: \r\n" + e.ToString());
            }
            finally
            {
                result.Stop();
                EndTest(testInfo, result);

                Trace.WriteLine("***** Purchase FINISHED. Took " + result.Latency.TotalMilliseconds + "ms.");
            }

            return result;
        }

        [MonitoringTest(Name = "VerifyToken", Id = "B0680ABD-5A2C-4804-A1A4-E7635D778605")]
        private Result<bool> VerifyToken()
        {
            TestInfo testInfo = GetTestInfo();
            Result<bool> result = new Result<bool>();

            try
            {
                Trace.WriteLine("***** VerifyToken STARTED");

                result.Start();
                StartTest(testInfo);

                gadgetTests.GadgetTests_VerifyToken();

                result.ReturnValue = result.Passed = true;
            }
            catch (Exception e)
            {
                result.ReturnValue = result.Passed = false;
                result.Error = e;

                Trace.WriteLine("VerifyToken Exception: \r\n" + e.ToString());
            }
            finally
            {
                result.Stop();
                EndTest(testInfo, result);

                Trace.WriteLine("***** VerifyToken FINISHED. Took " + result.Latency.TotalMilliseconds + "ms.");
            }

            return result;
        }

        [MonitoringTest(Name = "ConsumeAssets", Id = "B0680ABD-5A2C-4804-A1A4-E7635D778606")]
        private Result<bool> ConsumeAssets()
        {
            TestInfo testInfo = GetTestInfo();
            Result<bool> result = new Result<bool>();

            try
            {
                Trace.WriteLine("***** ConsumeAssets STARTED");

                result.Start();
                StartTest(testInfo);

                gadgetTests.GadgetTests_ConsumeAssets();

                result.ReturnValue = result.Passed = true;
            }
            catch (Exception e)
            {
                result.ReturnValue = result.Passed = false;
                result.Error = e;

                Trace.WriteLine("ConsumeAssets Exception: \r\n" + e.ToString());
            }
            finally
            {
                result.Stop();
                EndTest(testInfo, result);

                Trace.WriteLine("***** ConsumeAssets FINISHED. Took " + result.Latency.TotalMilliseconds + "ms.");
            }

            return result;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\PrereqMonitoringBlock.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;
using System.IO;
using LiveN.Test.Common;
using LiveN.Test.Framework.Authorization;
using LiveN.Test.Framework.Configuration;
using LiveN.Test.Services.Multiplayer;

namespace LiveN.Test.Services
{
    /// <summary>
    /// 
    /// </summary>
    public class PrereqMonitoringBlock: MonitoringBlock
    {
        private ServiceBaseUtil serviceUtil;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="environment"></param>
        public PrereqMonitoringBlock(string environment): base(environment)
        {
            //NOTE: need to create an instance of ServiceBaseUtil (or dervied class)
            //      to be able to use the static Auth cache
            this.serviceUtil = new ServiceBaseUtil(
                this.Environment.StsSettings.StsUrl,
                this.Environment.StsSettings.ClientCertSubject,
                this.Environment.WindowsLiveIDSettings.LiveIdServiceTarget,
                this.Environment.WindowsLiveIDSettings.Policy,
                this.Environment.WindowsLiveIDSettings.Environment,
                this.Environment.StsSettings.TitleId,
                this.Environment.StsSettings.TitleVersion,
                this.Environment.StsSettings.PlatformType,
                this.Environment.StsSettings.ClientVersion,
                string.Empty
                );
        }

        /// <summary>
        /// 
        /// </summary>
        public override string Name
        {
            get { return "Authentication"; }
        }

        /// <summary>
        /// 
        /// </summary>
        public override string FullName
        {
            get { return "Authentication Prerequisites"; }
        }

        /// <summary>
        /// 
        /// </summary>
        public override int Priority
        {
            get
            {
                return 0;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public override List<TestInfo> GetTestNames()
        {
            return GetMonitoringTests();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public override List<IResult> RunTests()
        {
            List<IResult> results = new List<IResult>();

            results.Add(VerifyClientCertificate());
            if (results[0].Passed)
            {
                results.Add(VerifyWlidLogin());
                if (results[1].Passed)
                {
                    results.Add(GetStsUserToken());
                    if (results[2].Passed)
                    {
                        results.Add(GetStsPartnerToken());                   
                    }
                }
            }

            return results;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        [MonitoringTest(Name = "Verify Client Certificate", Id = "B038E354-40E2-4DC2-8460-A4CDC6E807EE")]
        private IResult VerifyClientCertificate()
        {
            Result<bool> result = new Result<bool>();
            TestInfo testInfo = GetTestInfo();

            try
            {
                StartTest(testInfo);
                TraceEx.TraceStart("Starting client certificate validation...");
                string certPath = this.Environment.StsSettings.ClientCertPath;
                if (!Path.IsPathRooted(certPath)) //if it's an relative file path, combine w/ the current directory
                    certPath = Path.Combine(Utility.CurrentDirectory, certPath);

                result.Start();
                Authorization.InstallClientCertificateBySubject(certPath, this.Environment.StsSettings.ClientCertSubject, this.Environment.StsSettings.ClientCertPassword, "Platform STS");
                result.ReturnValue = result.Passed = true;
                Trace.TraceInformation("Successfully validated WP7 client certificate with subject CN={0}", this.Environment.StsSettings.ClientCertSubject);
            }
            catch (Exception e)
            {
                result.Error = e;
                ServiceBaseUtil.TraceError(ServiceError.PrereqClientCertificate, e, "Error validating that the required STS client certificate is installed/available");
            }
            finally
            {
                result.Stop();
                TraceEx.TraceStop("Completed client certificate validation.  Took {0}ms.", result.Latency.TotalMilliseconds);
                EndTest(testInfo, result);
            }

            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        [MonitoringTest(Name = "Verify WLID / IDCRL", Id = "301DBED9-EC7C-4DB3-A6EB-BAE06BC2C1D2")]
        private IResult VerifyWlidLogin()
        {
            Result<bool> result = new Result<bool>();
            TestInfo testInfo = GetTestInfo();

            try
            {
                StartTest(testInfo);
                TraceEx.TraceStart("Starting IDCRL/Windows Live ID prereq check validation...");
                result.Start();
                string loginTicket = this.serviceUtil.AuthorizationCache.GetLoginTicket(
                    this.Environment.UserSettings[0].Membername,
                    this.Environment.UserSettings[0].Password,
                    this.serviceUtil.LiveIdServiceTarget,
                    this.serviceUtil.Policy,
                    this.serviceUtil.Environment);
                result.ReturnValue = result.Passed = true;
                TraceEx.TraceVerbose("RPS ticket={0}", loginTicket);
                Trace.TraceInformation("Verified that {0} can login via IDCRL/Windows Live ID.", this.Environment.UserSettings[0].Membername);
            }
            catch (Exception e)
            {
                result.Error = e;
                ServiceBaseUtil.TraceError(ServiceError.PrereqIdcrl, e, "Unable to get RPS ticket for {0}.  Verify the username and password are correct", this.Environment.UserSettings[0].Membername);
            }
            finally
            {
                result.Stop();
                TraceEx.TraceStop("Completed IDCRL/Windows Live ID validation.  Took {0}ms.", result.Latency.TotalMilliseconds);
                EndTest(testInfo, result);
            }

            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        [MonitoringTest(Name = "Verify STS User Token", Id = "1231AB7D-5A9A-4117-BA73-3A95AED0A35C")]
        private Result<bool> GetStsUserToken()
        {
            Result<bool> result = new Result<bool>();
            TestInfo testInfo = GetTestInfo();

            try
            {
                StartTest(testInfo);
                TraceEx.TraceStart("Starting STS User Token prereq check validation...");
                result.Start();
                string userToken = this.serviceUtil.AuthorizationCache.GetUserToken(
                                        this.Environment.UserSettings[0].Membername,
                                        this.Environment.UserSettings[0].Password,
                                        this.serviceUtil.LiveIdServiceTarget,
                                        this.serviceUtil.Policy,
                                        this.serviceUtil.Environment,
                                        this.Environment.StsSettings.PlatformType,
                                        this.Environment.StsSettings.TitleId,
                                        this.Environment.StsSettings.TitleVersion,
                                        this.Environment.StsSettings.ClientVersion);
                TraceEx.TraceVerbose("STS User Token={0}", userToken);

                //if this is a machine token, the user doesn't have an XBL account
                if (!Authorization.IsUserSecurityToken(userToken))
                {
                    TraceEx.TraceError((int)ServiceError.PrereqVerifyXblUser, "The platform STS service returned a Machine token for {0}; this user does not have an Xbox Live account.", this.Environment.UserSettings[0].Membername);
                    result.ReturnValue = false;
                }
                Trace.TraceInformation("Verified that {0} can obtain an STS user token.", this.Environment.UserSettings[0].Membername);
                result.ReturnValue = result.Passed = true;
            }
            catch (Exception e)
            {
                result.Error = e;
                ServiceBaseUtil.TraceError(ServiceError.PrereqStsUserToken, e, "Unable to get an STS user token for {0}, with title ID {1} and title version {2}.", 
                    this.Environment.UserSettings[0].Membername,
                    this.Environment.StsSettings.TitleId,
                    this.Environment.StsSettings.TitleVersion);
            }
            finally
            {
                result.Stop();
                TraceEx.TraceStop("Completed STS user token validation.  Took {0}ms.", result.Latency.TotalMilliseconds);
                EndTest(testInfo, result);
            }

            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        [MonitoringTest(Name = "Verify STS Partner Token", Id = "8BA5C836-59E2-4A57-8271-EFF2E844BC87")]
        public Result<bool> GetStsPartnerToken()
        {
            Result<bool> result = new Result<bool>();
            TestInfo testInfo = GetTestInfo();

            try
            {
                StartTest(testInfo);
                TraceEx.TraceStart("Starting STS Partner Token prereq check validation...");
                result.Start();
                string userToken = this.serviceUtil.AuthorizationCache.GetUserToken(
                                        this.Environment.UserSettings[0].Membername,
                                        this.Environment.UserSettings[0].Password,
                                        this.serviceUtil.LiveIdServiceTarget,
                                        this.serviceUtil.Policy,
                                        this.serviceUtil.Environment,
                                        this.Environment.StsSettings.PlatformType,
                                        this.Environment.StsSettings.TitleId,
                                        this.Environment.StsSettings.TitleVersion,
                                        this.Environment.StsSettings.ClientVersion);
                string partnerToken = this.serviceUtil.AuthorizationCache.GetPartnerToken(
                                        userToken,
                                        this.Environment.StsSettings.TitleId,
                                        this.Environment.StsSettings.TitleVersion,
                                        this.Environment.StsSettings.AudienceUri_MultiPlayer);
                result.ReturnValue = result.Passed = true;
                TraceEx.TraceVerbose("STS Partner Token={0}", partnerToken);
                Trace.TraceInformation("Verified that {0} can obtain an STS partner token.", this.Environment.UserSettings[0].Membername);
            }
            catch (Exception e)
            {
                result.Error = e;
                ServiceBaseUtil.TraceError(ServiceError.PrereqStsPartnerToken, e, "Unable to get an STS partner token for {0}, with title ID {1}, title version {2} and audience Uri {3}",
                    this.Environment.UserSettings[0].Membername,
                    this.Environment.StsSettings.TitleId,
                    this.Environment.StsSettings.TitleVersion,
                    this.Environment.StsSettings.AudienceUri_MultiPlayer);
            }
            finally
            {
                result.Stop();
                TraceEx.TraceStop("Completed STS Partner Token validation.  Took {0}ms.", result.Latency.TotalMilliseconds);
                EndTest(testInfo, result);
            }

            return result;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\ServiceErrorMessage.cs ===
﻿using System;
using System.Xml;
using LiveN.Test.Common;

namespace LiveN.Test.Services
{
    /// <summary>
    /// 
    /// </summary>
    public class ServiceErrorMessage
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="responseXml"></param>
        public ServiceErrorMessage(string responseXml)
        {
            ParseServiceError(responseXml);
        }

        /// <summary>
        /// 
        /// </summary>
        public string ErrorMessage
        {
            get;
            private set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string ErrorCode
        {
            get;
            private set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string ApiName
        {
            get;
            private set;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="xml"></param>
        private void ParseServiceError(string xml)
        {
            try
            {
                XmlDocumentEx errorXml = new XmlDocumentEx(xml, true);
                XmlNode temp = errorXml.SelectSingleNode("dfltns:ServiceErrorMessage/dfltns:ErrorMessage", errorXml.NamespaceManager);
                if (temp != null)
                    this.ErrorMessage = temp.InnerText;

                temp = errorXml.SelectSingleNode("dfltns:ServiceErrorMessage/dfltns:LIVEnErrorCode", errorXml.NamespaceManager);
                if (temp != null)
                    this.ErrorCode = temp.InnerText;

                temp = errorXml.SelectSingleNode("dfltns:ServiceErrorMessage/dfltns:ApiName", errorXml.NamespaceManager);
                if (temp != null)
                    this.ApiName = temp.InnerText;
            }
            catch
            {

            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\TestInfo.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LiveN.Test.Services
{
    /// <summary>
    /// 
    /// </summary>
    public class TestInfo
    {
        /// <summary>
        /// 
        /// </summary>
        public string Name
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string Id
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\LiveConnect\LiveConnectMonitoringBlock.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;
using System.Net;
using System.ServiceModel;
using System.ServiceModel.Description;
using System.ServiceModel.Security;
using System.Security.Cryptography.X509Certificates;
using System.IO;
using LiveN.Test.Common;
using LiveN.Test.Common.Web;
using LiveN.Test.Framework;
using LiveConnectWeb;
using LiveN.Test.Framework.Authorization;

namespace LiveN.Test.Services.LiveConnect
{
    /// <summary>
    /// 
    /// </summary>
    public enum SocialNetwork : ushort
    {
        WindowsLiveSpaces = 1,
        Facebook,
        Twitter,
    }

    /// <summary>
    /// 
    /// </summary>
    public class LiveConnectMonitoringBlock: MonitoringBlock
    {
        private static char[] BadSnuidChars = "<>:\",\\".ToCharArray();

        /// <summary>
        /// 
        /// </summary>
        /// <param name="environment"></param>
        public LiveConnectMonitoringBlock(string environment)
            : base(environment)
        {
           
        }

        /// <summary>
        /// 
        /// </summary>
        public override string Name
        {
            get { return "LiveConnect"; }
        }

        /// <summary>
        /// 
        /// </summary>
        public override string FullName
        {
            get { return "LiveConnect (Directory + Authentication)"; }
        }

        /// <summary>
        /// 
        /// </summary>
        public override int Priority
        {
            get
            {
                return 10;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public override List<TestInfo> GetTestNames()
        {
            return GetMonitoringTests();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public override List<IResult> RunTests()
        {
            List<IResult> results = new List<IResult>();

            string player1 = this.Environment.UserSettings[0].Membername;
            string player1Password = this.Environment.UserSettings[0].Password;

            results.Add(VerifyClientCertificate());
            if (!results[0].Passed)
                return results; //no client cert?  we're done here...

            //11/9/10 - PJL: temporarily commenting out as there are intermittent proxy/networking issues w/ the smoke page.
            //results.Add(SmokeTest());
            results.Add(DirectoryTestSts());
            results.Add(DirectoryTestCert());
            results.Add(AuthenticationTestSts());
            results.Add(AuthenticationTestCert());
            results.Add(TwitterAuthenticationTest());

            return results;
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        [MonitoringTest(Name = "Verify Client Certificate", Id = "3E71A6E4-C44A-4463-97D4-6CAB4B7E336C")]
        private IResult VerifyClientCertificate()
        {
            Result<bool> result = new Result<bool>();
            TestInfo testInfo = GetTestInfo();

            try
            {
                StartTest(testInfo);
                TraceEx.TraceStart("Starting client certificate validation...");
                string certPath = this.Environment.LiveConnectSettings.CertificatePath;
                if (!Path.IsPathRooted(certPath)) //if it's an relative file path, combine w/ the current directory
                    certPath = Path.Combine(Utility.CurrentDirectory, certPath);

                result.Start();
                LiveN.Test.Framework.Authorization.Authorization.InstallClientCertificateBySubject(certPath, this.Environment.LiveConnectSettings.CertificateSubject, this.Environment.LiveConnectSettings.CertificatePassword, "LiveConnect");
                result.ReturnValue = result.Passed = true;
                Trace.TraceInformation("Successfully verified LiveConnect client certificate with subject CN={0}", this.Environment.LiveConnectSettings.CertificateSubject);
            }
            catch (Exception e)
            {
                result.Error = e;
                TraceEx.TraceError("Error validating that the required LiveConnect certificate is installed/available: {0}", e.Message);
            }
            finally
            {
                result.Stop();
                TraceEx.TraceStop("Completed client certificate validation.  Took {0}ms.", result.Latency.TotalMilliseconds);
                EndTest(testInfo, result);
            }

            return result;
        }

        /// <summary>
        /// 11/9/10 - PJL: temporarily commenting out as there are intermittent proxy/networking issues w/ the smoke page.
        /// </summary>
        /// <returns></returns>
        //[MonitoringTest(Name = "Smoke Page", Id = "A02D7FC8-E850-4729-AFF1-CC6C6F2D889F")]
        private Result<bool> SmokeTest()
        {
            Result<bool> result = new Result<bool>();
            TestInfo testInfo = GetTestInfo();

            try
            {
                TraceEx.TraceStart("Starting LiveConnect Smoke Page Validation.");
                StartTest(testInfo);
                IsValidEnvironment();   //make sure we're running against a valid environment

                result.Start();                
                TraceEx.TraceVerbose("Verifying LiveConnect smoke page at: {0}", this.Environment.LiveConnectSettings.SmokePageUrl);

                BasicHttpRequest httpRequest = new BasicHttpRequest(this.Environment.LiveConnectSettings.SmokePageUrl);
                httpRequest.BaseHttpRequest.Timeout = 10000;    //fairly low time out; this page should render in less then 200ms...
                string responseHtml = httpRequest.GetResponse();
                TraceEx.TraceVerbose(httpRequest.HttpResponse.ToTraceString(httpRequest.Response));
                if (httpRequest.HttpResponse.StatusCode != HttpStatusCode.OK)
                    throw new ApplicationException(httpRequest.HttpResponse.ToTraceString(httpRequest.Response));

                result.Passed = result.ReturnValue = true;
                Trace.TraceInformation("Successfully verified LiveConnect Smoke Page.");
            }
            catch (Exception e)
            {
                result.Error = e;
                TraceEx.TraceError("Error verifying LiveConnect smoke page:\r\n\r\n{0}", e);
            }
            finally
            {
                result.Stop();
                TraceEx.TraceStop("Finished LiveConnect Smoke Page Validation.  Took {0}ms.", result.Latency.TotalMilliseconds);
                EndTest(testInfo, result);                
            }

            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        [MonitoringTest(Name = "Directory Service - STS Auth", Id = "CB69B668-7BD0-4215-AB58-2CE073E15C2F")]
        private Result<bool> DirectoryTestSts()
        {
            Result<bool> result = null;
            TestInfo testInfo = GetTestInfo();

            try
            {
                StartTest(testInfo);
                result = DirectoryTest(false);
            }
            finally
            {
                EndTest(testInfo, result);
            }

            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        [MonitoringTest(Name = "Directory Service - Certificate Auth", Id = "58CD100E-59E5-4E62-A96C-314FAF6600A3")]
        private Result<bool> DirectoryTestCert()
        {
            Result<bool> result = null;
            TestInfo testInfo = GetTestInfo();

            try
            {
                StartTest(testInfo);
                result = DirectoryTest(true);
            }
            finally
            {
                EndTest(testInfo, result);
            }

            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        private Result<bool> DirectoryTest(bool useCertAuth)
        {
            Result<bool> result = new Result<bool>();
            string authText = useCertAuth ? "certificate" : "STS";
            
            try
            {
                TraceEx.TraceStart("Starting LiveConnect Directory tests, using {0} authentication.", authText);
                IsValidEnvironment();   //make sure we're running against a valid environment
                
                LiveDirectoryClient directoryClient = new LiveDirectoryClient(useCertAuth ? "LiveDirectoryCert" : "LiveDirectorySts");
                
                try
                {
                    directoryClient.Endpoint.Address = new EndpointAddress(useCertAuth ? this.Environment.LiveConnectSettings.CertEndpoint.ToString() : this.Environment.LiveConnectSettings.StsEndpoint.ToString());
                    
                    SNUserInfo userInfo = new SNUserInfo();
                    userInfo.SNUserID = "VerifierTest-" + Utility.GenerateRandomString(10, BadSnuidChars);
                    userInfo.GamerTag = Utility.GenerateRandomString(10);
                    userInfo.XUID = Utility.GenerateRandomUInt64();
                    userInfo.Visibility = Visibility.Everyone;

                    if (useCertAuth)
                    {
                        //configure the client to use a client certificate
                        directoryClient.ClientCredentials.ClientCertificate.SetCertificate(
                            StoreLocation.LocalMachine,
                            StoreName.My,
                            X509FindType.FindBySubjectName,
                            this.Environment.LiveConnectSettings.CertificateSubject);
                    }
                    else
                    {
                        //configure the client to use a generated STS token
                        StsTokenParameters stsParameters = new StsTokenParameters() { Xuid = userInfo.XUID, TitleId = NetworkToTitleID((ushort)SocialNetwork.Facebook) };
                        StsToken tokenGenerator = new StsToken(this.Environment.LiveConnectSettings.CertificateSubject);
                        string stsToken = tokenGenerator.GenerateConsoleToken(stsParameters);
                        
                        directoryClient.ChannelFactory.Endpoint.Behaviors.RemoveAll<ClientCredentials>();
                        directoryClient.ChannelFactory.Endpoint.Behaviors.Add(new StsClientCredentials(stsToken));
                    }

                    result.Start();                    
                    TraceEx.TraceVerbose("Opening WCF channel to Live Connect Directory Endpoint \"{0}\", at {1}...", directoryClient.Endpoint.Name, directoryClient.Endpoint.Address.Uri);
                    directoryClient.Open();
                    TraceEx.TraceVerbose("Calling SetSNUserInfo with UserID={0}, XUID={1}, GamerTag={2}, Visibility={3}, Network=Facebook",
                                                userInfo.SNUserID,
                                                userInfo.XUID,
                                                userInfo.GamerTag,
                                                userInfo.Visibility);
                    directoryClient.SetSNUserInfo((ushort)SocialNetwork.Facebook, userInfo);

                    TraceEx.TraceVerbose("Calling GetSNUserInfoBySNUId with UserID={0}, Network=Facebook", userInfo.SNUserID);
                    SNUserInfo actualUserInfo = directoryClient.GetSNUserInfoBySNUId((ushort)SocialNetwork.Facebook, userInfo.SNUserID);
                    if (userInfo.SNUserID != actualUserInfo.SNUserID)
                        throw new ApplicationException(String.Format("SNUserInfo returned from GetSNUserInfoBySNUId does not match the original value; expected SNUserID {0}, got {1}.", userInfo.SNUserID, actualUserInfo.SNUserID));
                    if (userInfo.GamerTag != actualUserInfo.GamerTag)
                        throw new ApplicationException(String.Format("SNUserInfo returned from GetSNUserInfoBySNUId does not match the original value; expected GamerTag {0}, got {1}.", userInfo.GamerTag, actualUserInfo.GamerTag));
                    if (userInfo.XUID != actualUserInfo.XUID)
                        throw new ApplicationException(String.Format("SNUserInfo returned from GetSNUserInfoBySNUId does not match the original value; expected XUID {0}, got {1}.", userInfo.XUID, actualUserInfo.XUID));
                    if (userInfo.Visibility != actualUserInfo.Visibility)
                        throw new ApplicationException(String.Format("SNUserInfo returned from GetSNUserInfoBySNUId does not match the original value; expected Visibility {0}, got {1}.", userInfo.Visibility, actualUserInfo.Visibility));

                    TraceEx.TraceVerbose("Calling GetSNUserInfoByXUID with XUID={0}, Network=Facebook", userInfo.XUID);
                    actualUserInfo = directoryClient.GetSNUserInfoByXUID((ushort)SocialNetwork.Facebook, userInfo.XUID);
                    if (userInfo.SNUserID != actualUserInfo.SNUserID)
                        throw new ApplicationException(String.Format("SNUserInfo returned from GetSNUserInfoByXUID does not match the original value; expected SNUserID {0}, got {1}.", userInfo.SNUserID, actualUserInfo.SNUserID));
                    if (userInfo.GamerTag != actualUserInfo.GamerTag)
                        throw new ApplicationException(String.Format("SNUserInfo returned from GetSNUserInfoByXUID does not match the original value; expected GamerTag {0}, got {1}.", userInfo.GamerTag, actualUserInfo.GamerTag));
                    if (userInfo.XUID != actualUserInfo.XUID)
                        throw new ApplicationException(String.Format("SNUserInfo returned from GetSNUserInfoByXUID does not match the original value; expected XUID {0}, got {1}.", userInfo.XUID, actualUserInfo.XUID));
                    if (userInfo.Visibility != actualUserInfo.Visibility)
                        throw new ApplicationException(String.Format("SNUserInfo returned from GetSNUserInfoByXUID does not match the original value; expected Visibility {0}, got {1}.", userInfo.Visibility, actualUserInfo.Visibility));

                    TraceEx.TraceVerbose("Calling GetSNUserInfos with UserID={0}, Network=Facebook", userInfo.SNUserID);
                    SNUserInfo[] actualUserInfos = directoryClient.GetSNUserInfos((ushort)SocialNetwork.Facebook, new string[] { userInfo.SNUserID });
                    if (actualUserInfos.Length != 1)
                        throw new ApplicationException(String.Format("Expected GetSNUserInfos to return 1 user, but got {0}", actualUserInfos.Length));
                    if (userInfo.SNUserID != actualUserInfos[0].SNUserID)
                        throw new ApplicationException(String.Format("SNUserInfo returned from GetSNUserInfos does not match the original value; expected SNUserID {0}, got {1}.", userInfo.SNUserID, actualUserInfos[0].SNUserID));
                    if (userInfo.GamerTag != actualUserInfos[0].GamerTag)
                        throw new ApplicationException(String.Format("SNUserInfo returned from GetSNUserInfos does not match the original value; expected GamerTag {0}, got {1}.", userInfo.GamerTag, actualUserInfos[0].GamerTag));
                    if (userInfo.XUID != actualUserInfos[0].XUID)
                        throw new ApplicationException(String.Format("SNUserInfo returned from GetSNUserInfos does not match the original value; expected XUID {0}, got {1}.", userInfo.XUID, actualUserInfos[0].XUID));
                    if (userInfo.Visibility != actualUserInfos[0].Visibility)
                        throw new ApplicationException(String.Format("SNUserInfo returned from GetSNUserInfos does not match the original value; expected Visibility {0}, got {1}.", userInfo.Visibility, actualUserInfos[0].Visibility));

                    TraceEx.TraceVerbose("Calling RemoveSNUserInfo with XUID={0}, Network=Facebook", userInfo.XUID);
                    directoryClient.RemoveSNUserInfo((ushort)SocialNetwork.Facebook, userInfo.XUID);
                }
                finally
                {
                    directoryClient.CloseConnection();
                }                

                result.Passed = result.ReturnValue = true;
                Trace.TraceInformation("Successfully validated Live Connect Directory service, using {0} authentication.", authText);
            }
            catch (Exception e)
            {
                result.Error = e;
                HandleError("Directory service", useCertAuth, e);
            }
            finally
            {
                result.Stop();
                TraceEx.TraceStop("Finished LiveConnect Directory tests, using {0} authentication.  Took {1}ms.", authText, result.Latency.TotalMilliseconds);
            }

            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        [MonitoringTest(Name = "Authentication Service - STS Auth", Id = "02D8FFA1-7C96-4D41-909E-BB0C0541B4C9")]
        private Result<bool> AuthenticationTestSts()
        {
            Result<bool> result = null;
            TestInfo testInfo = GetTestInfo();

            try
            {
                StartTest(testInfo);
                result = AuthenticationTest(false);
            }
            finally
            {
                EndTest(testInfo, result);
            }

            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        [MonitoringTest(Name = "Authentication Service - Certificate Auth", Id = "15A237B3-7F24-43F8-A2EE-1466233865ED")]
        private Result<bool> AuthenticationTestCert()
        {
            Result<bool> result = null;
            TestInfo testInfo = GetTestInfo();

            try
            {
                StartTest(testInfo);
                result = AuthenticationTest(true);
            }
            finally
            {
                EndTest(testInfo, result);
            }

            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        private Result<bool> AuthenticationTest(bool useCertAuth)
        {
            Result<bool> result = new Result<bool>();
            string authText = useCertAuth ? "certificate" : "STS";
            
            try
            {
                TraceEx.TraceStart("Starting LiveConnect Authentication tests, using {0} authentication.", authText);
                IsValidEnvironment();   //make sure we're running against a valid environment

                LiveAuthenticationClient authClient = new LiveAuthenticationClient(useCertAuth ? "LiveAuthenticationCert" : "LiveAuthenticationSts");

                try
                {
                    authClient.Endpoint.Address = new EndpointAddress(useCertAuth ? this.Environment.LiveConnectSettings.CertEndpoint.ToString() : this.Environment.LiveConnectSettings.StsEndpoint.ToString());

                    SNUserInfo userInfo = new SNUserInfo();
                    userInfo.SNUserID = "VerifierTest-" + Utility.GenerateRandomString(10, BadSnuidChars);
                    userInfo.GamerTag = Utility.GenerateRandomString(10);
                    userInfo.XUID = Utility.GenerateRandomUInt64();
                    userInfo.Visibility = Visibility.Everyone;

                    string deviceId = Utility.GenerateRandomUInt64().ToString();

                    SNAuthInfo authInfo = new SNAuthInfo();
                    authInfo.SNUserID = userInfo.SNUserID;
                    authInfo.Token = Utility.GenerateRandomString(150);

                    if (useCertAuth)
                    {
                        //configure the client to use a client certificate
                        authClient.ClientCredentials.ClientCertificate.SetCertificate(
                            StoreLocation.LocalMachine,
                            StoreName.My,
                            X509FindType.FindBySubjectName,
                            this.Environment.LiveConnectSettings.CertificateSubject);
                    }
                    else
                    {
                        //configure the client to use a generated STS token
                        StsTokenParameters stsParameters = new StsTokenParameters() { Xuid = userInfo.XUID, TitleId = NetworkToTitleID((ushort)SocialNetwork.Twitter), MachineId = ulong.Parse(deviceId) };
                        StsToken tokenGenerator = new StsToken(this.Environment.LiveConnectSettings.CertificateSubject);
                        string stsToken = tokenGenerator.GenerateConsoleToken(stsParameters);

                        authClient.ChannelFactory.Endpoint.Behaviors.RemoveAll<ClientCredentials>();                        
                        authClient.ChannelFactory.Endpoint.Behaviors.Add(new StsClientCredentials(stsToken));
                    }

                    result.Start();                    
                    TraceEx.TraceVerbose("Opening WCF channel to Live Connect Authentication Endpoint \"{0}\", at {1}...", authClient.Endpoint.Name, authClient.Endpoint.Address.Uri);
                    authClient.Open();
                    TraceEx.TraceVerbose("Calling SetAuthInfo with XUID={0}, GamerTag={1}, DeviceID={2}, Token={3}, Visibility={4}, Network=Twitter",
                                                userInfo.XUID,
                                                userInfo.GamerTag,
                                                deviceId,
                                                authInfo.Token,
                                                userInfo.Visibility);
                    authClient.SetAuthInfo((ushort)SocialNetwork.Twitter, userInfo.XUID, userInfo.GamerTag, deviceId, authInfo, true, userInfo.Visibility);

                    TraceEx.TraceVerbose("Calling GetAuthInfo with XUID={0}, DeviceID={1}, Network=Twitter", userInfo.XUID, deviceId);
                    SNAuthInfo actualAuthInfo = authClient.GetAuthInfo((ushort)SocialNetwork.Twitter, userInfo.XUID, deviceId);
                    if (authInfo.SNUserID != actualAuthInfo.SNUserID)
                        throw new ApplicationException(String.Format("SNAuthInfo returned from GetAuthInfo does not match the original value; expected SNUserID {0}, got {1}.", authInfo.SNUserID, actualAuthInfo.SNUserID));
                    if (authInfo.Token != actualAuthInfo.Token)
                        throw new ApplicationException(String.Format("SNAuthInfo returned from GetAuthInfo does not match the original value; expected Token {0}, got {1}.", authInfo.Token, actualAuthInfo.Token));

                    TraceEx.TraceVerbose("Calling RemoveAuthInfo with XUID={0}, DeviceID={1}, Network=Twitter", userInfo.XUID, deviceId);
                    authClient.RemoveAuthInfo((ushort)SocialNetwork.Twitter, userInfo.XUID, deviceId);
                }
                finally
                {
                    authClient.CloseConnection();
                }

                result.Passed = result.ReturnValue = true;
                Trace.TraceInformation("Successfully validated Live Connect Authentication service, using {0} authentication.", authText);
            }
            catch (Exception e)
            {
                result.Error = e;
                HandleError("Authentication service", useCertAuth, e);
            }
            finally
            {
                result.Stop();
                TraceEx.TraceStop("Finished LiveConnect Authentication tests, using {0} authentication.  Took {1}ms.", authText, result.Latency.TotalMilliseconds);                
            }

            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        [MonitoringTest(Name = "Authentication Service - Twitter App", Id = "3C8CCD53-0523-47EF-9D6C-B701ED336D79")]
        private Result<bool> TwitterAuthenticationTest()
        {
            Result<bool> result = new Result<bool>();
            TestInfo testInfo = GetTestInfo();

            try
            {
                TraceEx.TraceStart("Starting LiveConnect Twitter Authentication, using STS authentication.");
                StartTest(testInfo);
                IsValidEnvironment();   //make sure we're running against a valid environment

                LiveAuthenticationClient authClient = new LiveAuthenticationClient("LiveAuthenticationSts");

                try
                {
                    authClient.Endpoint.Address = new EndpointAddress(this.Environment.LiveConnectSettings.StsEndpoint.ToString());

                    SNUserInfo userInfo = new SNUserInfo();
                    userInfo.SNUserID = "VerifierTest-" + Utility.GenerateRandomString(10, BadSnuidChars);
                    userInfo.GamerTag = Utility.GenerateRandomString(10);
                    userInfo.XUID = 0;  //Twitter special case value; Lua can't easily deal w/ ulong...
                    userInfo.Visibility = Visibility.Everyone;

                    ulong stsXuid = Utility.GenerateRandomUInt64();
                    string stsMachineId = Utility.GenerateRandomUInt64().ToString();

                    SNAuthInfo authInfo = new SNAuthInfo();
                    authInfo.SNUserID = userInfo.SNUserID;
                    authInfo.Token = Utility.GenerateRandomString(150);

                    //configure the client to use a generated STS token
                    StsTokenParameters stsParameters = new StsTokenParameters() { Xuid = stsXuid, TitleId = NetworkToTitleID((ushort)SocialNetwork.Twitter), MachineId = ulong.Parse(stsMachineId) };
                    StsToken tokenGenerator = new StsToken(this.Environment.LiveConnectSettings.CertificateSubject);
                    string stsToken = tokenGenerator.GenerateConsoleToken(stsParameters);

                    authClient.ChannelFactory.Endpoint.Behaviors.RemoveAll<ClientCredentials>();                    
                    authClient.ChannelFactory.Endpoint.Behaviors.Add(new StsClientCredentials(stsToken));                    

                    result.Start();
                    TraceEx.TraceVerbose("Opening WCF channel to Live Connect Authentication Endpoint \"{0}\", at {1}...", authClient.Endpoint.Name, authClient.Endpoint.Address.Uri);
                    authClient.Open();
                    TraceEx.TraceVerbose("Calling SetAuthInfo with XUID={0}, GamerTag={1}, DeviceID=NULL, Token={2}, Visibility={3}, Network=Twitter",
                                                userInfo.XUID,
                                                userInfo.GamerTag,
                                                authInfo.Token,
                                                userInfo.Visibility);
                    authClient.SetAuthInfo((ushort)SocialNetwork.Twitter, userInfo.XUID, userInfo.GamerTag, null, authInfo, true, userInfo.Visibility);

                    TraceEx.TraceVerbose("Calling GetAuthInfo with XUID={0}, DeviceID={1}, Network=Twitter", userInfo.XUID, stsMachineId);
                    SNAuthInfo actualAuthInfo = authClient.GetAuthInfo((ushort)SocialNetwork.Twitter, userInfo.XUID, stsMachineId);
                    if (authInfo.SNUserID != actualAuthInfo.SNUserID)
                        throw new ApplicationException(String.Format("SNAuthInfo returned from GetAuthInfo does not match the original value; expected SNUserID {0}, got {1}.", authInfo.SNUserID, actualAuthInfo.SNUserID));
                    if (authInfo.Token != actualAuthInfo.Token)
                        throw new ApplicationException(String.Format("SNAuthInfo returned from GetAuthInfo does not match the original value; expected Token {0}, got {1}.", authInfo.Token, actualAuthInfo.Token));

                    TraceEx.TraceVerbose("Calling RemoveAuthInfo with XUID={0}, DeviceID={1}, Network=Twitter", userInfo.XUID, stsMachineId);
                    authClient.RemoveAuthInfo((ushort)SocialNetwork.Twitter, userInfo.XUID, stsMachineId);
                }
                finally
                {
                    authClient.CloseConnection();
                }

                result.Passed = result.ReturnValue = true;
                Trace.TraceInformation("Successfully validated LiveConnect Twitter Authentication, using STS authentication.");
            }
            catch (Exception e)
            {
                result.Error = e;
                HandleError("Authentication service", false, e);
            }
            finally
            {
                result.Stop();
                TraceEx.TraceStop("Finished LiveConnect Twitter Authentication tests, using STS authentication.  Took {0}ms.", result.Latency.TotalMilliseconds);
                EndTest(testInfo, result);
            }

            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        private void IsValidEnvironment()
        {
            if (this.Environment.Name.Equals("Production", StringComparison.InvariantCultureIgnoreCase) ||
                this.Environment.Name.Equals("Prod", StringComparison.InvariantCultureIgnoreCase) ||
                this.Environment.Name.Equals("INT2", StringComparison.InvariantCultureIgnoreCase))
                return;

            throw new ArgumentOutOfRangeException("Environment", this.Environment.Name, "The LiveConnect service is only available in INT2 and Production.");
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="networkId"></param>
        /// <returns></returns>
        private static uint NetworkToTitleID(ushort networkId)
        {
            if (networkId == 2)
                return 0x584807E1;  //Facebook title ID
            return 0xFFFE07D1;      //Xbox 360 dash (BDEs - like twitter, get this title ID)
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="e"></param>
        private static void HandleError(string serviceName, bool certAuth, Exception e)
        {
            string authMode = (certAuth) ? "client certificate" : "STS";
            string message;
            int eventId;

            if (e is FaultException<SecurityAccessDeniedException>)
            {
                FaultException<SecurityAccessDeniedException> fault = e as FaultException<SecurityAccessDeniedException>;
                message = String.Format("{0} (using {2} auth) returned SecurityAccessDeniedException; STS or cert auth failed; SOAP fault Detail: {1}", serviceName, fault.Detail.Message, authMode);
                eventId = 2000;
            }
            else if (e is FaultException<ArgumentException>)
            {
                FaultException<ArgumentException> fault = e as FaultException<ArgumentException>;
                message = String.Format("{0} (using {2} auth) returned ArgumentException; invalid parameter(s) sent; SOAP fault Detail: {1}", serviceName, fault.Detail.Message, authMode);
                eventId = 2001;
            }
            else if (e is FaultException<ArgumentOutOfRangeException>)
            {
                FaultException<ArgumentOutOfRangeException> fault = e as FaultException<ArgumentOutOfRangeException>;
                message = String.Format("{0} (using {2} auth) returned ArgumentOutOfRangeException; out-of-range parameter(s) sent; SOAP fault Detail: {1}", serviceName, fault.Detail.Message, authMode);
                eventId = 2002;
            }
            else if (e is FaultException<ArgumentNullException>)
            {
                FaultException<ArgumentNullException> fault = e as FaultException<ArgumentNullException>;
                message = String.Format("{0} (using {2} auth) returned ArgumentNullException; null parameter(s) sent; SOAP fault Detail: {1}", serviceName, fault.Detail.Message, authMode);
                eventId = 2003;
            }
            else if (e is FaultException)
            {
                FaultException fault = e as FaultException;
                message = String.Format("Bug! {0} (using {2} auth) returned an unknown FaultException! {0}. An unexpected, internal error occurred: {1}", serviceName, GetExceptionText(fault), authMode);
                eventId = 2004;
            }
            else if (e is MessageSecurityException)
            {
                MessageSecurityException fault = e as MessageSecurityException;
                message = String.Format("{0} (using {2} auth) returned MessageSecurityException; invalid STS token or client certificate; SOAP fault Detail: {1}", serviceName, GetExceptionText(fault), authMode);
                eventId = 2005;
            }
            else if (e is TimeoutException)
            {
                TimeoutException fault = e as TimeoutException;
                message = String.Format("Encountered a timeout when calling {0} (using {2} auth): {1}", serviceName, fault.Message, authMode);
                eventId = 3000;
            }
            else if (e is CommunicationException)
            {
                CommunicationException fault = e as CommunicationException;
                message = String.Format("Encountered a communication issue when calling {0} (using {2} auth): {1}", serviceName, GetExceptionText(fault), authMode);
                eventId = 4000;
            }
            else if (e is ApplicationException)
            {
                ApplicationException fault = e as ApplicationException;
                message = String.Format("Encountered a validation issue when calling {0} (using {2} auth); expected vs. actual data returned from the service did not match! {1}", serviceName, fault.Message, authMode);
                eventId = 5000;
            }
            else
            {
                message = String.Format("Unexpected exception occurred while calling {0} (using {2} auth)!\r\n\r\n{1}", serviceName, e.ToString(), authMode);
                eventId = 6000;
            }

            TraceEx.TraceError(eventId, message);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="e"></param>
        private static string GetExceptionText(Exception e)
        {
            if (e.InnerException != null)
                return e.InnerException.Message;
            return e.Message;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\AvatarServices\AvatarServicesMonitoringBlock.cs ===
﻿using System;
using System.Reflection;
using System.Configuration;
using System.Collections.Generic;
using System.Diagnostics;

using LiveNew.Test;

using LiveN.Test.Services;
using AsyncMultiplayer.NotificationService;

namespace LiveN.Test.Services
{
    public class AvatarServicesMonitoringBlock: MonitoringBlock
    {
        /// <summary>
        /// The Environment that your tests should run against
        /// </summary>
        private EnvironmentElement runEnvironment;

        private AvatarServicesUtil avatarServicesUtil = new AvatarServicesUtil();

        public AvatarServicesMonitoringBlock(string environmentName)
            : base(environmentName)
        {
            //TODO RobStartHere: FIX: Temp Hack in order to get the Gadget tool to work. As it uses different names then all other configuration files. Fix that tool
            switch(environmentName)
            {
                case "Dev":

                    environmentName = "le-xblob-test02";

                    Trace.WriteLine("****DEV Environment is set to Xblob; " + environmentName + "*****");

                    break;

                case "TEST":

                    environmentName = "TestNet";
                    break;

                case "CERT":

                    environmentName = "CertNet";
                    break;

                case "PART":

                    environmentName = "PartnerNet";
                    break;

                case "PROD":

                    environmentName = "Production";
                    break;
            }

            // Set the Selected Environment based off the Selected Base Environment
            runEnvironment = CurrentEnvironmentSettings.AllEnvironmentSettings.Environments[environmentName];
        }

        public override string Name
        {
            get { return "AvatarServices"; }
        }

        public override string FullName
        {
            get { return "AvatarServices"; }
        }

        public override int Priority
        {
            get
            {
                return 6;
            }
        }

        public override List<TestInfo> GetTestNames()
        {
            return GetMonitoringTests();
        }

        public override List<IResult> RunTests()
        {
            List<IResult> results = new List<IResult>();

            string userEmail = this.runEnvironment.UserSettings[0].UserEmail;
            string password = this.runEnvironment.UserSettings[0].Password;
            string gamerTag = this.runEnvironment.UserSettings[0].GamerTag;

            if (string.IsNullOrEmpty(gamerTag))
            {
                throw new Exception("'GamerTag' attribute must be set for the first user account within the App.config");
            }

            results.Add(ManifestWrite_Partner(runEnvironment, userEmail, password));

            results.Add(ManifestRead(runEnvironment, gamerTag));
            results.Add(ManifestRead_Origin(runEnvironment, gamerTag));
            results.Add(ManifestRead_Partner(runEnvironment, userEmail, password));

            results.Add(Closet_Partner(runEnvironment, userEmail, password));

            results.Add(GamerPic_Partner(runEnvironment, userEmail, password, gamerTag));

            results.Add(Blocklist_FilterTest(runEnvironment, userEmail, password, gamerTag));

            return results;
        }

        [MonitoringTest(Name = "ManifestRead (CDN)", Id = "B0680ABD-5A2C-4804-A1A4-E7635D7786C9")]
        private Result<bool> ManifestRead(EnvironmentElement runEnvironment, string gamerTag)
        {
            Result<bool> result = null;
            TestInfo testInfo = GetTestInfo();

            try
            {
                StartTest(testInfo);

                result = this.avatarServicesUtil.ManifestRead(runEnvironment, gamerTag);
            }
            finally
            {
                EndTest(testInfo, result);
            }

            return result;
        }

        [MonitoringTest(Name = "ManifestRead_Origin", Id = "B1680ABD-5A2C-4804-A1A4-E7635D7786C9")]
        private Result<bool> ManifestRead_Origin(EnvironmentElement runEnvironment, string gamerTag)
        {
            Result<bool> result = null;
            TestInfo testInfo = GetTestInfo();

            try
            {
                StartTest(testInfo);

                result = this.avatarServicesUtil.ManifestRead_Origin(runEnvironment, gamerTag);
            }
            finally
            {
                EndTest(testInfo, result);
            }

            return result;
        }

        [MonitoringTest(Name = "ManifestRead_Partner", Id = "B2680ABD-5A2C-4804-A1A4-E7635D7786C9")]
        private Result<bool> ManifestRead_Partner(EnvironmentElement runEnvironment, string userEmail, string password)
        {
            Result<bool> result = null;
            TestInfo testInfo = GetTestInfo();
            
            try
            {
                StartTest(testInfo);

                result = this.avatarServicesUtil.ManifestRead_Partner(runEnvironment, userEmail, password);
            }
            finally
            {
                EndTest(testInfo, result);
            }

            return result;
        }

        [MonitoringTest(Name = "ManifestWrite_Partner", Id = "B3680ABD-5A2C-4804-A1A4-E7635D7786C9")]
        private Result<bool> ManifestWrite_Partner(EnvironmentElement runEnvironment, string userEmail, string password)
        {
            Result<bool> result = null;
            TestInfo testInfo = GetTestInfo();

            try
            {
                StartTest(testInfo);

                result = this.avatarServicesUtil.ManifestWrite_Partner(runEnvironment, userEmail, password);
            }
            finally
            {
                EndTest(testInfo, result);
            }

            return result;
        }

        [MonitoringTest(Name = "Closet_Partner", Id = "B4680ABD-5A2C-4804-A1A4-E7635D7786C9")]
        private Result<bool> Closet_Partner(EnvironmentElement runEnvironment, string userEmail, string password)
        {
            Result<bool> result = null;
            TestInfo testInfo = GetTestInfo();

            try
            {
                StartTest(testInfo);

                result = this.avatarServicesUtil.Closet_Partner(runEnvironment, userEmail, password);
            }
            finally
            {
                EndTest(testInfo, result);
            }

            return result;
        }

        [MonitoringTest(Name = "Blocklist_FilterTest", Id = "B5680ABD-5A2C-4804-A1A4-E7635D7786C9")]
        private Result<bool> Blocklist_FilterTest(EnvironmentElement runEnvironment, string userEmail, string password, string gamerTag)
        {
            Result<bool> result = null;
            TestInfo testInfo = GetTestInfo();

            try
            {
                StartTest(testInfo);

                result = this.avatarServicesUtil.Blocklist_FilterTest(runEnvironment, userEmail, password, gamerTag);
            }
            finally
            {
                EndTest(testInfo, result);
            }

            return result;
        }

        [MonitoringTest(Name = "GamerPic_Partner(SSR)", Id = "B6680ABD-5A2C-4804-A1A4-E7635D7786C9")]
        private Result<bool> GamerPic_Partner(EnvironmentElement runEnvironment, string userEmail, string password, string gamerTag)
        {
            Result<bool> result = null;
            TestInfo testInfo = GetTestInfo();

            try
            {
                StartTest(testInfo);

                result = this.avatarServicesUtil.GamerPic_Partner(runEnvironment, userEmail, password, gamerTag);
            }
            finally
            {
                EndTest(testInfo, result);
            }

            return result;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\LiveConnect\WCF\StsTokenManager.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ServiceModel;
using System.ServiceModel.Description;
using System.IdentityModel;
using System.IdentityModel.Selectors;

namespace LiveN.Test.Services.LiveConnect
{
    /// <summary>
    /// 
    /// </summary>
    public class StsTokenManager : ClientCredentialsSecurityTokenManager
    {
        StsClientCredentials stsCreds;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="stsCreds"></param>
        public StsTokenManager(StsClientCredentials stsCreds): base(stsCreds)
        {
            this.stsCreds = stsCreds;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="tokenRequirement"></param>
        /// <returns></returns>
        public override SecurityTokenProvider CreateSecurityTokenProvider(SecurityTokenRequirement tokenRequirement)
        {
            return new StsTokenProvider(this.stsCreds.StsToken);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="tokenRequirement"></param>
        /// <param name="outOfBandTokenResolver"></param>
        /// <returns></returns>
        public override SecurityTokenAuthenticator CreateSecurityTokenAuthenticator(SecurityTokenRequirement tokenRequirement, out SecurityTokenResolver outOfBandTokenResolver)
        {
            return base.CreateSecurityTokenAuthenticator(tokenRequirement, out outOfBandTokenResolver);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="version"></param>
        /// <returns></returns>
        public override SecurityTokenSerializer CreateSecurityTokenSerializer(SecurityTokenVersion version)
        {
            //return new System.IdentityModel.Tokens.SamlSerializer();
            return base.CreateSecurityTokenSerializer(version);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\AvatarServices\AvatarServicesUtill.cs ===
﻿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using System.Net;
using System.Threading;

using LiveNew.Test;

using LiveN.Test.Common;
using LiveN.Test.Services.Multiplayer;
using AsyncMultiplayer.NotificationService;

namespace LiveN.Test.Services
{
    public class AvatarServicesUtil
    {
        /// <summary>
        /// Avatar wearing a ObiWanShirt which is blocked by default. But is nto blocked on XBox.com
        /// </summary>
        private const string Manifest_ObiWanShirt = "000000003F1000000000000000100000031A0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E00020000003360003C1C8F109A19CB2E00000800002EA0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002CE0003C1C8F109A19CB2E03F8000000000000000000000000000000000400002710003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFDE914DFF753E1FFF8A1A0EFF243F53FF753E1FFF000000FF753E1FFF7F3979FF7F39790000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E00001000000000000000000000000000000000004024F0003C1C8F109A19CB2E0000400000000000000000000000000000000001000910001C1C8F109A19CB2E0001000000000000000000000000000000000002000360001C1C8F109A19CB2E0002000000000000000000000000000000000004000F30001C1C8F109A19CB2E00040000000000000000000000000000000000008779DA2C1CB03604F4C4107E200080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000360001C1C8F109A19CB2E0002000000000000000000000000000000000001000910001C1C8F109A19CB2E0001000000000000000000000000000000000000800480001C1C8F109A19CB2E000080000FF94D614000000000000000000000004024F0003C1C8F109A19CB2E0000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";

        /// <summary>
        /// Manifest only containing stock assets
        /// </summary>
        private const string Manifest_Default = "000000003F1000000000000000100000031A0003C1C8F109A19CB2E000080000032B0003C1C8F109A19CB2E00020000003360003C1C8F109A19CB2E00000800002EA0003C1C8F109A19CB2E03F8000000000000000000000000000000000200002CE0003C1C8F109A19CB2E03F8000000000000000000000000000000000400002710003C1C8F109A19CB2E03F800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFDE914DFF753E1FFF8A1A0EFF243F53FF753E1FFF000000FF753E1FFF7F3979FF7F39790000000200000001C1C8F109A19CB2E0000200000000000000000000000000000000000100020003C1C8F109A19CB2E00001000000000000000000000000000000000004024F0003C1C8F109A19CB2E0000400000000000000000000000000000000000800520001C1C8F109A19CB2E0000800000000000000000000000000000000001000910001C1C8F109A19CB2E0001000000000000000000000000000000000002000360001C1C8F109A19CB2E0002000000000000000000000000000000000004000F30001C1C8F109A19CB2E000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000360001C1C8F109A19CB2E0002000000000000000000000000000000000001000910001C1C8F109A19CB2E0001000000000000000000000000000000000000800520001C1C8F109A19CB2E00008000000000000000000000000000000000004024F0003C1C8F109A19CB2E0000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";

        /// <summary>
        /// Title ID for XBox.com
        /// </summary>
        private const string Title_XBoxCom = "1297287585";

        /// <summary>
        /// Create an instance
        /// </summary>
        public AvatarServicesUtil()
        {
        }

        public Result<bool> ManifestRead(EnvironmentElement runEnvironment, string gamerTag)
        {
            Result<bool> result = new Result<bool>();

            try
            {
                TraceEx.TraceStart("ManifestRead:  -" + gamerTag);

                result.Start();

                ManifestReadClientResponse response;
                ManifestReadClientRequest ManifestReadClient = new ManifestReadClientRequest(runEnvironment.ManifestReadService.OriginalString);

                ManifestReadClient.QueryParameters.GamerTag.Value = gamerTag;

                response = ManifestReadClient.MakeARequest();

                if (response.StatusCode != HttpStatusCode.OK)
                {
                    string errMSG = "ManifestRead (CDN): Status code should have been 200 OK. But instead it returned: '" + response.StatusCode.ToString() + "'";

                    result.ReturnValue = result.Passed = false;
                    result.Error = new Exception(errMSG);

                    TraceEx.TraceError(errMSG);

                    return result;
                }

                if (!response.Body.Contains("<Manifest>"))
                {
                    string errMSG = "ManifestRead (CDN): Response body did not contain the users manifest element '<Manifest>'. Response: \r\n" + response.ToString() + " \r\nPOSSBALE REASON: Make sure the user has a manifest by calling the write manifest test case with the same creds.";

                    result.ReturnValue = result.Passed = false;
                    result.Error = new Exception(errMSG);

                    TraceEx.TraceError(errMSG);

                    return result;
                }

                result.ReturnValue = result.Passed = true;

                TraceEx.TraceVerbose("Successful");
            }
            catch (Exception e)
            {
                result.ReturnValue = result.Passed = false;
                result.Error = e;

                TraceEx.TraceError("Exception: \r\n" + e.ToString());
            }
            finally
            {
                result.Stop();
                TraceEx.TraceStop("Completed. Took {0}ms.", result.Latency.TotalMilliseconds);
            }

            return result;
        }

        public Result<bool> ManifestRead_Origin(EnvironmentElement runEnvironment, string gamerTag)
        {
            Result<bool> result = new Result<bool>();

            try
            {
                TraceEx.TraceStart("ManifestRead_Origin: -" + gamerTag);

                result.Start();

                ManifestReadOriginClientResponse response;
                ManifestReadOriginClientRequest ManifestReadClient = new ManifestReadOriginClientRequest(runEnvironment.ManifestReadOriginService.OriginalString);

                ManifestReadClient.QueryParameters.GamerTag.Value = gamerTag;

                response = ManifestReadClient.MakeARequest();

                if (response.StatusCode != HttpStatusCode.OK)
                {
                    string errMSG = "ManifestRead_Origin: Status code should have been 200 OK. But instead it returned: '" + response.StatusCode.ToString() + "'";

                    result.ReturnValue = result.Passed = false;
                    result.Error = new Exception(errMSG);

                    TraceEx.TraceError(errMSG);

                    return result;
                }

                if ((response.BodyWrapper.Manifests.Length != 1) ||
                    (response.BodyWrapper.Manifests[0].AvatarManifest.Manifest == null))
                {
                    string errMSG = "ManifestRead_Origin: Response body did not contain the users manifest element '<Manifest>'. Response which will contain the gamer tag: \r\n" + response.ToString() + " \r\nPOSSIBLE REASON: Make sure the passed in gamer tag is acually a real gamer tag. Look within the Closet_Partner results to see what the GamerTag really is. OR Make sure the user has a manifest by calling the write manifest test case with the same creds.";

                    result.ReturnValue = result.Passed = false;
                    result.Error = new Exception(errMSG);

                    TraceEx.TraceError(errMSG);

                    return result;
                }

                result.ReturnValue = result.Passed = true;

                TraceEx.TraceVerbose("Successful");
            }
            catch (Exception e)
            {
                result.ReturnValue = result.Passed = false;
                result.Error = e;

                TraceEx.TraceError("Exception: \r\n" + e.ToString());
            }
            finally
            {
                result.Stop();
                TraceEx.TraceStop("Completed. Took {0}ms.", result.Latency.TotalMilliseconds);
            }

            return result;
        }

        public Result<bool> ManifestRead_Partner(EnvironmentElement runEnvironment, string userEmail, string password)
        {
            Result<bool> result = new Result<bool>();

            try
            {
                TraceEx.TraceStart("ManifestRead_Partner: " + userEmail + " / " + password);

                result.Start();

                ManifestReadPartnerClientResponse response;
                ManifestReadPartnerClientRequest ManifestReadClient = new ManifestReadPartnerClientRequest(runEnvironment, userEmail, password);

                response = ManifestReadClient.MakeARequest();

                if (response.StatusCode != HttpStatusCode.OK)
                {
                    string errMSG = "ManifestRead_Partner: Status code should have been 200 OK. But instead it returned: '" + response.StatusCode.ToString() + "'";

                    result.ReturnValue = result.Passed = false;
                    result.Error = new Exception(errMSG);

                    TraceEx.TraceError(errMSG);

                    return result;
                }

                if (!response.Body.Contains("<Manifest>"))
                {
                    string errMSG = "ManifestRead_Partner: Response body did not contain the users manifest element '<Manifest>'. Response: \r\n" + response.ToString() + " \r\nPOSSBALE REASON: Make sure the user has a manifest by calling the write manifest test case with the same creds.";

                    result.ReturnValue = result.Passed = false;
                    result.Error = new Exception(errMSG); ;

                    TraceEx.TraceError(errMSG);

                    return result;
                }

                result.ReturnValue = result.Passed = true;

                TraceEx.TraceVerbose("Successful. Response: \r\n" + response.Body);
            }
            catch (Exception e)
            {
                result.ReturnValue = result.Passed = false;
                result.Error = e;

                TraceEx.TraceError("Exception: \r\n" + e.ToString());
            }
            finally
            {
                result.Stop();
                TraceEx.TraceStop("Completed. Took {0}ms.", result.Latency.TotalMilliseconds);
            }

            return result;
        }

        public Result<bool> ManifestWrite_Partner(EnvironmentElement runEnvironment, string userEmail, string password)
        {
            Result<bool> result = new Result<bool>();
           
            try
            {
                TraceEx.TraceStart("ManifestWrite_Partner: " + userEmail + " / " + password);

                result.Start();

                ManifestWritePartnerClientResponse response;
                ManifestWritePartnerClientRequest ManifestWriteClient = new ManifestWritePartnerClientRequest(runEnvironment, userEmail, password);

                ManifestWriteClient.ContentWrapper.Manifest = Manifest_Default;

                response = ManifestWriteClient.MakeARequest();

                if (response.StatusCode != HttpStatusCode.OK)
                {
                    string errMSG = "ManifestWrite_Partner: Status code should have been 200 OK. But instead it returned: '" + response.StatusCode.ToString() + "'";

                    result.ReturnValue = result.Passed = false;
                    result.Error = new Exception(errMSG);

                    TraceEx.TraceError(errMSG);

                    return result;
                }

                if (!response.Body.Contains("<SuccessCode>0</SuccessCode>"))
                {
                    string errMSG = "ManifestWrite_Partner: Response body did not contain '<SuccessCode>0</SuccessCode>'. Response: \r\n" + response.ToString();

                    result.ReturnValue = result.Passed = false;
                    result.Error = new Exception(errMSG);

                    TraceEx.TraceError(errMSG);

                    return result;
                }

                result.ReturnValue = result.Passed = true;

                TraceEx.TraceVerbose("Successful");
            }
            catch (Exception e)
            {
                result.ReturnValue = result.Passed = false;
                result.Error = e;

                TraceEx.TraceError("Exception: \r\n" + e.ToString());
            }
            finally
            {
                result.Stop();
                TraceEx.TraceStop("Completed. Took {0}ms.", result.Latency.TotalMilliseconds);
            }

            return result;
        }

        public Result<bool> Closet_Partner(EnvironmentElement runEnvironment, string userEmail, string password)
        {
            Result<bool> result = new Result<bool>();

            try
            {
                TraceEx.TraceStart("Closet_Partner: " + userEmail + " / " + password);

                result.Start();

                ClosetPartnerClientResponse response;
                ClosetPartnerClientRequest closetClient = new ClosetPartnerClientRequest(runEnvironment, userEmail, password);

                response = closetClient.MakeARequest();

                if (response.StatusCode != HttpStatusCode.OK)
                {
                    string errMSG = "Closet_Partner: Status code should have been 200 OK. But instead it returned: '" + response.StatusCode.ToString() + "' Response: \r\n" + response.ToString();

                    result.ReturnValue = result.Passed = false;
                    result.Error = new Exception(errMSG);

                    TraceEx.TraceError(errMSG);

                    return result;
                }

                if (!response.Body.StartsWith("<ClosetAssets"))
                {
                    string errMSG = "Closet_Partner: Response body did not start with '<ClosetAssets'. Response: \r\n" + response.ToString();

                    result.ReturnValue = result.Passed = false;
                    result.Error = new Exception(errMSG);

                    TraceEx.TraceError(errMSG);

                    return result;
                }

                result.ReturnValue = result.Passed = true;

                TraceEx.TraceVerbose("Successful");
            }
            catch (Exception e)
            {
                result.ReturnValue = result.Passed = false;
                result.Error = e;

                TraceEx.TraceError("Exception: \r\n" + e.ToString());
            }
            finally
            {
                result.Stop();
                TraceEx.TraceStop("Completed. Took {0}ms.", result.Latency.TotalMilliseconds);
            }

            return result;
        }

        /// <summary>
        /// Verifies that the blocklist filter is on and functioning correctly. 
        /// </summary>
        public Result<bool> Blocklist_FilterTest(EnvironmentElement runEnvironment, string userEmail, string password, string gamerTag)
        {
            Result<bool> result = new Result<bool>();
            ManifestReadOriginClientResponse readResponse;
            ManifestReadOriginClientRequest ManifestReadOriginClient;
                
            ManifestReadOriginClient = new ManifestReadOriginClientRequest(runEnvironment.ManifestReadOriginService.OriginalString);
            ManifestReadOriginClient.QueryParameters.GamerTag.Value = gamerTag;

            try
            {
                TraceEx.TraceStart("Blocklist_FilterTest: " + userEmail + " / " + password + " -" + gamerTag);

                result.Start();

                if (runEnvironment.Name != "Production")
                {
                    TraceEx.TraceVerbose("****This environment '" + runEnvironment.Name + "' does not have a user equiped with a blocklisted item. Blocklist is not being tested for this environment.****");

                    result.ReturnValue = result.Passed = true;
                    return result;
                }

                ManifestWritePartnerClientResponse response;
                ManifestWritePartnerClientRequest ManifestWriteClient = new ManifestWritePartnerClientRequest(runEnvironment, userEmail, password); 
                
                ManifestWriteClient.ContentWrapper.Manifest = Manifest_ObiWanShirt;

                response = ManifestWriteClient.MakeARequest();
                if (response.StatusCode != HttpStatusCode.OK)
                {
                    string errMSG = "Blocklist_FilterTest: ManifestWrite_Partner failed to write the manifest with a ObiWanShirt on the avatar. \r\nPOSSBALE REASON: The selected user does not have a ObiWanShirt within it closet.";

                    result.ReturnValue = result.Passed = false;
                    result.Error = new Exception(errMSG);

                    TraceEx.TraceError(errMSG);

                    return result;
                }

                // Making a request against the origin service with not title id. This this should result in the quickest response time as well as land this manifest within the block list
                readResponse = ManifestReadOriginClient.MakeARequest();
                if (!readResponse.BodyWrapper.Manifests[0].AvatarManifest.Filtered)
                {
                    string errMSG = "Blocklist_FilterTest: User's saved manifest should have the flag indicating it was filtered as it should now be wearing a ObiWanShirt on and being filtered against the global filtered list. \r\nResponse body:\r\n" + readResponse.Body;

                    result.ReturnValue = result.Passed = false;
                    result.Error = new Exception(errMSG);

                    TraceEx.TraceError(errMSG);

                    return result;
                }

                // Now make a request again using the title id where nothing gets filtered
                ManifestReadOriginClient.QueryParameters.TitleID.Value = Title_XBoxCom;

                readResponse = ManifestReadOriginClient.MakeARequest();
                if (readResponse.BodyWrapper.Manifests[0].AvatarManifest.Filtered)
                {
                    string errMSG = "Blocklist_FilterTest: User's saved manifest should have the flag indicating it was filtered as it has the ObiWanShirt on and going against the global filtered list. \r\nResponse body:\r\n" + readResponse.Body;

                    result.ReturnValue = result.Passed = false;
                    result.Error = new Exception(errMSG);

                    TraceEx.TraceError(errMSG);

                    return result;
                }

                result.ReturnValue = result.Passed = true;

                TraceEx.TraceVerbose("Successful");
            }
            catch (Exception e)
            {
                result.ReturnValue = result.Passed = false;
                result.Error = e;

                TraceEx.TraceError("Exception: \r\n" + e.ToString());
            }
            finally
            {
                result.Stop();
                TraceEx.TraceStop("Completed. Took {0}ms.", result.Latency.TotalMilliseconds);
            }

            return result;
        }

        /// <summary>
        /// Verifies that the GamerPic web serice is up and running as well as SSR updates the image 
        /// </summary>
        public Result<bool> GamerPic_Partner(EnvironmentElement runEnvironment, string userEmail, string password, string gamerTag)
        {
            HttpWebRequest req;
            DateTime lastModified;
            GamerPicClientPartnerResponse response;
            Result<bool> result = new Result<bool>();
            GamerPicClientPartnerRequest GamerPicClient = new GamerPicClientPartnerRequest(runEnvironment, userEmail, password);

            string avatarImageSmallUrl = runEnvironment.AvatarImage_GamerPicSmall.OriginalString.Replace("{gamertag}", gamerTag);

            try
            {
                TraceEx.TraceStart("GamerPic_Partner: " + userEmail + " / " + password + " -" + gamerTag);

                result.Start();

                if (runEnvironment.Name == "Dev")
                {
                    TraceEx.TraceVerbose("****This environment '" + runEnvironment.Name + "' does not expose a GamerPic image url. So GamerPic is not being tested for this environment.****");

                    result.ReturnValue = result.Passed = true;
                    return result;
                }

                req = (HttpWebRequest)WebRequest.Create(avatarImageSmallUrl);
                req.Headers.Add("Pragma", "no-cache");
                using (WebResponse resp = (WebResponse)req.GetResponse())
                {
                    lastModified = (((System.Net.HttpWebResponse)(resp)).LastModified);
                    TraceEx.TraceVerbose("Get current images LastModified date: " + lastModified.ToString() + " url: " + avatarImageSmallUrl);
                }

                response = GamerPicClient.MakeARequest();
                if (response.StatusCode != HttpStatusCode.OK)
                {
                    string errMSG = "GamerPic_Partner: Status code should have been 200 OK. But instead it returned: '" + response.StatusCode.ToString() + "' Response: \r\n" + response.ToString();

                    result.ReturnValue = result.Passed = false;
                    result.Error = new Exception(errMSG);

                    TraceEx.TraceError(errMSG);

                    return result;
                }

                if (response.BodyWrapper.SuccessCode != 0)
                {
                    string errMSG = "GamerPic_Partner: SuccessCode within the response's body was not set to 0. But instead it returned: '" + response.BodyWrapper.SuccessCode.ToString() + "' Response: \r\n" + response.ToString();

                    result.ReturnValue = result.Passed = false;
                    result.Error = new Exception(errMSG);

                    TraceEx.TraceError(errMSG);

                    return result;
                }

                int retry = 13;
                while (retry-- > 0)
                {
                    // Wait for the update
                    Thread.Sleep(5000);

                    try
                    {
                        req = (HttpWebRequest)WebRequest.Create(avatarImageSmallUrl);
                        req.Headers.Add("Pragma", "no-cache");
                        req.IfModifiedSince = lastModified;

                        //Only updated images proceed. All others will throw an exception and return a 304
                        using (WebResponse resp = (WebResponse)req.GetResponse())
                        {
                        }
                 
                        TraceEx.TraceVerbose("GamerPic has been updated.");

                        break;
                    }
                    catch (WebException webExc)
                    {
                        if (webExc.Status != WebExceptionStatus.ProtocolError)
                        {
                            result.ReturnValue = result.Passed = false;
                            result.Error = webExc;

                            TraceEx.TraceError("Unknown web exception: \r\n" + webExc.ToString());

                            return result;
                        }

                        TraceEx.TraceVerbose("Image has not been updated. Retry count down: " + retry.ToString());
                    }
                }

                if(retry <= 0)
                {
                    string errMSG = "GamerPic_Partner: GamerPic image '" + avatarImageSmallUrl + "' did not get updated within allotted time.";

                    result.ReturnValue = result.Passed = false;
                    result.Error = new Exception(errMSG);

                    TraceEx.TraceError(errMSG);

                    return result;
                }

                result.ReturnValue = result.Passed = true;

                TraceEx.TraceVerbose("Successful");
            }
            catch (Exception e)
            {
                result.ReturnValue = result.Passed = false;
                result.Error = e;

                TraceEx.TraceError("Exception: \r\n" + e.ToString());
            }
            finally
            {
                result.Stop();
                TraceEx.TraceStop("Completed. Took {0}ms.", result.Latency.TotalMilliseconds);
            }

            return result;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\LiveConnect\WCF\StsTokenProvider.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IdentityModel;
using System.IdentityModel.Selectors;
using System.IdentityModel.Tokens;
using System.Xml;

namespace LiveN.Test.Services.LiveConnect
{
    /// <summary>
    /// 
    /// </summary>
    public class StsTokenProvider: SecurityTokenProvider
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stsToken"></param>
        public StsTokenProvider(string stsToken)
        {
            this.StsToken = stsToken;
        }

        /// <summary>
        /// 
        /// </summary>
        public string StsToken
        {
            get;
            private set;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="timeout"></param>
        /// <returns></returns>
        protected override SecurityToken GetTokenCore(TimeSpan timeout)
        {
            XmlDocument samlXml = new XmlDocument();

            try
            {
                samlXml.LoadXml(this.StsToken);
            }
            catch (XmlException e)
            {
                throw new ApplicationException("the specified STS token is invalid Xml.", e);
            }
            
            SecurityToken securityToken = new GenericXmlSecurityToken(samlXml.DocumentElement, null, DateTime.MinValue, DateTime.MaxValue, null, null, null);
            return securityToken;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\LiveConnect\WCF\StsClientCredentials.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ServiceModel;
using System.ServiceModel.Description;
using System.IdentityModel.Selectors;

namespace LiveN.Test.Services.LiveConnect
{
    /// <summary>
    /// 
    /// </summary>
    public class StsClientCredentials: ClientCredentials
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stsToken"></param>
        public StsClientCredentials(string stsToken): base()
        {
            this.StsToken = stsToken;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="other"></param>
        protected StsClientCredentials(StsClientCredentials other)
            : base(other)
        {
            this.StsToken = other.StsToken;
        }

        /// <summary>
        /// 
        /// </summary>
        public string StsToken
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public override SecurityTokenManager CreateSecurityTokenManager()
        {
            return new StsTokenManager(this);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        protected override ClientCredentials CloneCore()
        {
            return new StsClientCredentials(this);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\LiveConnect\LiveConnectService.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4016
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace LiveConnectWeb
{
    using System.Runtime.Serialization;


    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "SNUserInfo", Namespace = "http://schemas.datacontract.org/2004/07/LiveConnectWeb")]
    public partial class SNUserInfo : object, System.Runtime.Serialization.IExtensibleDataObject
    {

        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;

        private string GamerTagField;

        private string SNUserIDField;

        private LiveConnectWeb.Visibility VisibilityField;

        private ulong XUIDField;

        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string GamerTag
        {
            get
            {
                return this.GamerTagField;
            }
            set
            {
                this.GamerTagField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string SNUserID
        {
            get
            {
                return this.SNUserIDField;
            }
            set
            {
                this.SNUserIDField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public LiveConnectWeb.Visibility Visibility
        {
            get
            {
                return this.VisibilityField;
            }
            set
            {
                this.VisibilityField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public ulong XUID
        {
            get
            {
                return this.XUIDField;
            }
            set
            {
                this.XUIDField = value;
            }
        }
    }

    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "Visibility", Namespace = "http://schemas.datacontract.org/2004/07/LiveConnectWeb")]
    public enum Visibility : int
    {

        [System.Runtime.Serialization.EnumMemberAttribute()]
        Me = 0,

        [System.Runtime.Serialization.EnumMemberAttribute()]
        Everyone = 1,
    }

    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "SNetworkInfo", Namespace = "http://schemas.datacontract.org/2004/07/LiveConnectWeb")]
    public partial class SNetworkInfo : object, System.Runtime.Serialization.IExtensibleDataObject
    {

        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;

        private string DescriptionField;

        private uint IdField;

        private string LogoField;

        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Description
        {
            get
            {
                return this.DescriptionField;
            }
            set
            {
                this.DescriptionField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public uint Id
        {
            get
            {
                return this.IdField;
            }
            set
            {
                this.IdField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Logo
        {
            get
            {
                return this.LogoField;
            }
            set
            {
                this.LogoField = value;
            }
        }
    }

    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name = "SNAuthInfo", Namespace = "http://schemas.datacontract.org/2004/07/LiveConnectWeb")]
    public partial class SNAuthInfo : object, System.Runtime.Serialization.IExtensibleDataObject
    {

        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;

        private string SNUserIDField;

        private string TokenField;

        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string SNUserID
        {
            get
            {
                return this.SNUserIDField;
            }
            set
            {
                this.SNUserIDField = value;
            }
        }

        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Token
        {
            get
            {
                return this.TokenField;
            }
            set
            {
                this.TokenField = value;
            }
        }
    }
}


[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
[System.ServiceModel.ServiceContractAttribute(Namespace = "http://liveconnect.xboxlive.com", ConfigurationName = "ILiveDirectory")]
public interface ILiveDirectory
{

    [System.ServiceModel.OperationContractAttribute(Action = "http://liveconnect.xboxlive.com/ILiveDirectory/SetSNUserInfo", ReplyAction = "http://liveconnect.xboxlive.com/ILiveDirectory/SetSNUserInfoResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/SetSNUserInfoArgumentExceptionFaul" +
        "t", Name = "ArgumentException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentNullException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/SetSNUserInfoArgumentNullException" +
        "Fault", Name = "ArgumentNullException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ServiceModel.Security.SecurityAccessDeniedException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/SetSNUserInfoSecurityAccessDeniedE" +
        "xceptionFault", Name = "SecurityAccessDeniedException", Namespace = "http://schemas.datacontract.org/2004/07/System.ServiceModel.Security")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentOutOfRangeException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/SetSNUserInfoArgumentOutOfRangeExc" +
        "eptionFault", Name = "ArgumentOutOfRangeException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    void SetSNUserInfo(ushort sNetworkId, LiveConnectWeb.SNUserInfo userInfo);

    [System.ServiceModel.OperationContractAttribute(Action = "http://liveconnect.xboxlive.com/ILiveDirectory/RemoveSNUserInfo", ReplyAction = "http://liveconnect.xboxlive.com/ILiveDirectory/RemoveSNUserInfoResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentOutOfRangeException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/RemoveSNUserInfoArgumentOutOfRange" +
        "ExceptionFault", Name = "ArgumentOutOfRangeException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/RemoveSNUserInfoArgumentExceptionF" +
        "ault", Name = "ArgumentException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ServiceModel.Security.SecurityAccessDeniedException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/RemoveSNUserInfoSecurityAccessDeni" +
        "edExceptionFault", Name = "SecurityAccessDeniedException", Namespace = "http://schemas.datacontract.org/2004/07/System.ServiceModel.Security")]
    void RemoveSNUserInfo(ushort sNetworkId, ulong XUID);

    [System.ServiceModel.OperationContractAttribute(Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfoByXUID", ReplyAction = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfoByXUIDResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfoByXUIDArgumentExcepti" +
        "onFault", Name = "ArgumentException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentOutOfRangeException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfoByXUIDArgumentOutOfRa" +
        "ngeExceptionFault", Name = "ArgumentOutOfRangeException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ServiceModel.Security.SecurityAccessDeniedException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfoByXUIDSecurityAccessD" +
        "eniedExceptionFault", Name = "SecurityAccessDeniedException", Namespace = "http://schemas.datacontract.org/2004/07/System.ServiceModel.Security")]
    LiveConnectWeb.SNUserInfo GetSNUserInfoByXUID(ushort sNetworkId, ulong XUID);

    [System.ServiceModel.OperationContractAttribute(Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfoBySNUId", ReplyAction = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfoBySNUIdResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfoBySNUIdArgumentExcept" +
        "ionFault", Name = "ArgumentException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentNullException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfoBySNUIdArgumentNullEx" +
        "ceptionFault", Name = "ArgumentNullException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ServiceModel.Security.SecurityAccessDeniedException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfoBySNUIdSecurityAccess" +
        "DeniedExceptionFault", Name = "SecurityAccessDeniedException", Namespace = "http://schemas.datacontract.org/2004/07/System.ServiceModel.Security")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentOutOfRangeException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfoBySNUIdArgumentOutOfR" +
        "angeExceptionFault", Name = "ArgumentOutOfRangeException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    LiveConnectWeb.SNUserInfo GetSNUserInfoBySNUId(ushort sNetworkId, string snUserId);

    [System.ServiceModel.OperationContractAttribute(Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfos", ReplyAction = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfosResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfosArgumentExceptionFau" +
        "lt", Name = "ArgumentException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentNullException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfosArgumentNullExceptio" +
        "nFault", Name = "ArgumentNullException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentOutOfRangeException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfosArgumentOutOfRangeEx" +
        "ceptionFault", Name = "ArgumentOutOfRangeException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ServiceModel.Security.SecurityAccessDeniedException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNUserInfosSecurityAccessDenied" +
        "ExceptionFault", Name = "SecurityAccessDeniedException", Namespace = "http://schemas.datacontract.org/2004/07/System.ServiceModel.Security")]
    LiveConnectWeb.SNUserInfo[] GetSNUserInfos(ushort sNetworkId, string[] sNUserIDs);

    [System.ServiceModel.OperationContractAttribute(Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNetworkInfo", ReplyAction = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNetworkInfoResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentOutOfRangeException), Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNetworkInfoArgumentOutOfRangeE" +
        "xceptionFault", Name = "ArgumentOutOfRangeException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    LiveConnectWeb.SNetworkInfo GetSNetworkInfo(ushort sNetworkId);

    [System.ServiceModel.OperationContractAttribute(Action = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNetworkInfos", ReplyAction = "http://liveconnect.xboxlive.com/ILiveDirectory/GetSNetworkInfosResponse")]
    LiveConnectWeb.SNetworkInfo[] GetSNetworkInfos();
}

[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public interface ILiveDirectoryChannel : ILiveDirectory, System.ServiceModel.IClientChannel
{
}

[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public partial class LiveDirectoryClient : System.ServiceModel.ClientBase<ILiveDirectory>, ILiveDirectory
{

    public LiveDirectoryClient()
    {
    }

    public LiveDirectoryClient(string endpointConfigurationName) :
        base(endpointConfigurationName)
    {
    }

    public LiveDirectoryClient(string endpointConfigurationName, string remoteAddress) :
        base(endpointConfigurationName, remoteAddress)
    {
    }

    public LiveDirectoryClient(string endpointConfigurationName, System.ServiceModel.EndpointAddress remoteAddress) :
        base(endpointConfigurationName, remoteAddress)
    {
    }

    public LiveDirectoryClient(System.ServiceModel.Channels.Binding binding, System.ServiceModel.EndpointAddress remoteAddress) :
        base(binding, remoteAddress)
    {
    }

    public void SetSNUserInfo(ushort sNetworkId, LiveConnectWeb.SNUserInfo userInfo)
    {
        base.Channel.SetSNUserInfo(sNetworkId, userInfo);
    }

    public void RemoveSNUserInfo(ushort sNetworkId, ulong XUID)
    {
        base.Channel.RemoveSNUserInfo(sNetworkId, XUID);
    }

    public LiveConnectWeb.SNUserInfo GetSNUserInfoByXUID(ushort sNetworkId, ulong XUID)
    {
        return base.Channel.GetSNUserInfoByXUID(sNetworkId, XUID);
    }

    public LiveConnectWeb.SNUserInfo GetSNUserInfoBySNUId(ushort sNetworkId, string snUserId)
    {
        return base.Channel.GetSNUserInfoBySNUId(sNetworkId, snUserId);
    }

    public LiveConnectWeb.SNUserInfo[] GetSNUserInfos(ushort sNetworkId, string[] sNUserIDs)
    {
        return base.Channel.GetSNUserInfos(sNetworkId, sNUserIDs);
    }

    public LiveConnectWeb.SNetworkInfo GetSNetworkInfo(ushort sNetworkId)
    {
        return base.Channel.GetSNetworkInfo(sNetworkId);
    }

    public LiveConnectWeb.SNetworkInfo[] GetSNetworkInfos()
    {
        return base.Channel.GetSNetworkInfos();
    }
}

[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
[System.ServiceModel.ServiceContractAttribute(Namespace = "http://liveconnect.xboxlive.com", ConfigurationName = "ILiveAuthentication")]
public interface ILiveAuthentication
{

    [System.ServiceModel.OperationContractAttribute(Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/SetAuthInfo", ReplyAction = "http://liveconnect.xboxlive.com/ILiveAuthentication/SetAuthInfoResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ServiceModel.Security.SecurityAccessDeniedException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/SetAuthInfoSecurityAccessDeni" +
        "edExceptionFault", Name = "SecurityAccessDeniedException", Namespace = "http://schemas.datacontract.org/2004/07/System.ServiceModel.Security")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/SetAuthInfoArgumentExceptionF" +
        "ault", Name = "ArgumentException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentOutOfRangeException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/SetAuthInfoArgumentOutOfRange" +
        "ExceptionFault", Name = "ArgumentOutOfRangeException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentNullException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/SetAuthInfoArgumentNullExcept" +
        "ionFault", Name = "ArgumentNullException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    void SetAuthInfo(ushort sNetworkId, ulong XUID, string gamerTag, string deviceId, LiveConnectWeb.SNAuthInfo userInfo, bool addToDirectory, LiveConnectWeb.Visibility visibility);

    [System.ServiceModel.OperationContractAttribute(Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/GetAuthInfo", ReplyAction = "http://liveconnect.xboxlive.com/ILiveAuthentication/GetAuthInfoResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ServiceModel.Security.SecurityAccessDeniedException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/GetAuthInfoSecurityAccessDeni" +
        "edExceptionFault", Name = "SecurityAccessDeniedException", Namespace = "http://schemas.datacontract.org/2004/07/System.ServiceModel.Security")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentNullException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/GetAuthInfoArgumentNullExcept" +
        "ionFault", Name = "ArgumentNullException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/GetAuthInfoArgumentExceptionF" +
        "ault", Name = "ArgumentException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentOutOfRangeException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/GetAuthInfoArgumentOutOfRange" +
        "ExceptionFault", Name = "ArgumentOutOfRangeException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    LiveConnectWeb.SNAuthInfo GetAuthInfo(ushort sNetworkId, ulong XUID, string deviceId);

    [System.ServiceModel.OperationContractAttribute(Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/RemoveAuthInfo", ReplyAction = "http://liveconnect.xboxlive.com/ILiveAuthentication/RemoveAuthInfoResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentNullException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/RemoveAuthInfoArgumentNullExc" +
        "eptionFault", Name = "ArgumentNullException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/RemoveAuthInfoArgumentExcepti" +
        "onFault", Name = "ArgumentException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ServiceModel.Security.SecurityAccessDeniedException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/RemoveAuthInfoSecurityAccessD" +
        "eniedExceptionFault", Name = "SecurityAccessDeniedException", Namespace = "http://schemas.datacontract.org/2004/07/System.ServiceModel.Security")]
    [System.ServiceModel.FaultContractAttribute(typeof(System.ArgumentOutOfRangeException), Action = "http://liveconnect.xboxlive.com/ILiveAuthentication/RemoveAuthInfoArgumentOutOfRa" +
        "ngeExceptionFault", Name = "ArgumentOutOfRangeException", Namespace = "http://schemas.datacontract.org/2004/07/System")]
    void RemoveAuthInfo(ushort sNetworkId, ulong XUID, string deviceId);
}

[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public interface ILiveAuthenticationChannel : ILiveAuthentication, System.ServiceModel.IClientChannel
{
}

[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public partial class LiveAuthenticationClient : System.ServiceModel.ClientBase<ILiveAuthentication>, ILiveAuthentication
{

    public LiveAuthenticationClient()
    {
    }

    public LiveAuthenticationClient(string endpointConfigurationName) :
        base(endpointConfigurationName)
    {
    }

    public LiveAuthenticationClient(string endpointConfigurationName, string remoteAddress) :
        base(endpointConfigurationName, remoteAddress)
    {
    }

    public LiveAuthenticationClient(string endpointConfigurationName, System.ServiceModel.EndpointAddress remoteAddress) :
        base(endpointConfigurationName, remoteAddress)
    {
    }

    public LiveAuthenticationClient(System.ServiceModel.Channels.Binding binding, System.ServiceModel.EndpointAddress remoteAddress) :
        base(binding, remoteAddress)
    {
    }

    public void SetAuthInfo(ushort sNetworkId, ulong XUID, string gamerTag, string deviceId, LiveConnectWeb.SNAuthInfo userInfo, bool addToDirectory, LiveConnectWeb.Visibility visibility)
    {
        base.Channel.SetAuthInfo(sNetworkId, XUID, gamerTag, deviceId, userInfo, addToDirectory, visibility);
    }

    public LiveConnectWeb.SNAuthInfo GetAuthInfo(ushort sNetworkId, ulong XUID, string deviceId)
    {
        return base.Channel.GetAuthInfo(sNetworkId, XUID, deviceId);
    }

    public void RemoveAuthInfo(ushort sNetworkId, ulong XUID, string deviceId)
    {
        base.Channel.RemoveAuthInfo(sNetworkId, XUID, deviceId);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\Multiplayer\GameSessionUtil.cs ===
﻿using System;
using System.Diagnostics;
using AsyncMultiplayer.SessionCommon;
using LiveN.Test.Common;

namespace LiveN.Test.Services.Multiplayer
{
    /// <summary>
    /// 
    /// </summary>
    public class GameSessionUtil: ServiceBaseUtil
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stsUrl"></param>
        /// <param name="clientCertSubject"></param>
        /// <param name="liveIdServiceTarget"></param>
        /// <param name="policy"></param>
        /// <param name="environment"></param>
        public GameSessionUtil(string gameSessionUrl, string stsUrl, string clientCertSubject, string liveIdServiceTarget, string policy, string environment, string titleId, string titleVersion, string platformType, string clientVersion, string audienceUri): base(stsUrl, clientCertSubject, liveIdServiceTarget, policy, environment, titleId, titleVersion, platformType, clientVersion)
        {
            this.GameSessionUrl = new Uri(gameSessionUrl);
            this.AudienceUri = audienceUri;
        }

        /// <summary>
        /// 
        /// </summary>
        public Uri GameSessionUrl
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="memberName"></param>
        /// <param name="password"></param>
        /// <returns></returns>
        public Result<SessionState> CreateGameSession(string memberName, string password)
        {
            Result<SessionState> result = new Result<SessionState>();

            try
            {
                TraceEx.TraceStart("Creating new game session for {0}...", memberName);
                string partnerToken = GetPartnerToken(memberName, password);
                SessionService sessionProxy = GetGameSessionProxy(this.GameSessionUrl.ToString(), partnerToken);
                CreationData creationData = new CreationData()
                {
                    DisplayName = String.Format("Multiplayer Ping Monitoring - {0}", DateTime.Now.ToString()),
                    GameID = uint.Parse(this.TitleId),
                    TotalSeatsAvailable = 2,
                    Variant = 0,
                    InactivityWarning = new InactivityWarningBehavior()
                    {
                        Action = InactivityWarningAction.None,
                        Interval = 1,
                        MaxNumberOfNudges = 5
                    },
                    SessionParameters = Utility.GenerateRandomBytes(1024)
                };

                result.Start();
                result.ReturnValue = sessionProxy.CreateSession(this.TitleId, creationData);
                result.Passed = true;
            }
            catch (Exception e)
            {
                result.Error = e;
                TraceError(ServiceError.CreateSession, e, "Error creating game session");
            }
            finally
            {
                result.Stop();
                TraceEx.TraceStop("Completed game session creation.  Took {0}ms.", result.Latency.TotalMilliseconds);
            }

            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="memberName"></param>
        /// <param name="password"></param>
        /// <param name="sessionId"></param>
        /// <param name="inviteEmailTo"></param>
        /// <returns></returns>
        public Result<SessionState> JoinSession(string memberName, string password, string sessionId)
        {
            Result<SessionState> result = new Result<SessionState>();

            try
            {
                TraceEx.TraceStart("{0} is attempting to join game session {1}...", memberName, sessionId);
                string partnerToken = GetPartnerToken(memberName, password);
                SessionService gameSessionProxy = GetGameSessionProxy(this.GameSessionUrl.ToString(), partnerToken);
                JoinData joinData = new JoinData()
                {
                    GameID = uint.Parse(this.TitleId),
                    SessionID = sessionId,
                    SeatIndex = 1,
                    SeatParameters = Utility.GenerateRandomBytes(100)
                };

                result.Start();
                result.ReturnValue = gameSessionProxy.JoinSession(sessionId, joinData);
                result.Passed = true;
                Trace.TraceInformation("Successfully joined game session {0}.", sessionId);
            }
            catch (Exception e)
            {
                result.Error = e;
                TraceError(ServiceError.JoinSession, e, "Error joining game session.");
            }
            finally
            {
                result.Stop();
                TraceEx.TraceStop("Completed joining game session.  Took {0}ms.", result.Latency.TotalMilliseconds);
            }

            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="memberName"></param>
        /// <param name="password"></param>
        /// <param name="sessionId"></param>
        /// <returns></returns>
        public Result<SessionState> ViewSession(string memberName, string password, string sessionId)
        {
            Result<SessionState> result = new Result<SessionState>();

            try
            {
                TraceEx.TraceStart("{0} is attempting to view game session state for {1}...", memberName, sessionId);
                string partnerToken = GetPartnerToken(memberName, password);
                SessionService gameSessionProxy = GetGameSessionProxy(this.GameSessionUrl.ToString(), partnerToken);

                result.Start();
                result.ReturnValue = gameSessionProxy.ViewSession(sessionId, this.TitleId);
                result.Passed = true;
                Trace.TraceInformation("Successfully viewed game session state for {0}.", sessionId);
            }
            catch (Exception e)
            {
                result.Error = e;
                TraceError(ServiceError.ViewSession, e, "Error viewing game session");
            }
            finally
            {
                result.Stop();
                TraceEx.TraceStop("Completed view session.  Took {0}ms.", result.Latency.TotalMilliseconds);
            }

            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="memberName"></param>
        /// <param name="password"></param>
        /// <returns></returns>
        public Result<SessionEntry[]> ViewSessionSummaries(string memberName, string password)
        {
            Result<SessionEntry[]> result = new Result<SessionEntry[]>();

            try
            {
                TraceEx.TraceStart("{0} is attempting to view game session summaries for title ID {1}...", memberName, this.TitleId);
                string partnerToken = GetPartnerToken(memberName, password);
                SessionService gameSessionProxy = GetGameSessionProxy(this.GameSessionUrl.ToString(), partnerToken);

                result.Start();
                result.ReturnValue = gameSessionProxy.ViewSessionSummaries(
                    this.TitleId,
                    "0",
                    String.Empty,
                    String.Empty,
                    "100",
                    ShowSessionType.All.ToString());
                result.Passed = true;
                Trace.TraceInformation("Successfully viewed game session summaries for title ID {0}.", this.TitleId);
            }
            catch (Exception e)
            {
                result.Error = e;
                TraceError(ServiceError.ViewSessionSummaries, e, "Error viewing game session summaries");
            }
            finally
            {
                result.Stop();
                TraceEx.TraceStop("Completed view session summaries.  Took {0}ms.", result.Latency.TotalMilliseconds);
            }

            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="session"></param>
        public static void TraceSession(SessionState session)
        {
            if (session == null)
                return;

            TraceEx.TraceVerbose(
                "Game Session State:\r\n\tDisplay Name:\t{0}\r\n\tCreation Time:\t{1}\r\n\tGame ID:\t{2}\r\n\tSession ID:\t{3}\r\n\tVariant:\t{4}\r\n\tSeats Available:\t{5}\r\n\tOwner Seat:\t{6}\r\n\tActive Seat:{7}\r\n\tIs Complete:\t{8}\r\n\tLast Modified:\t{9}\r\n",
                session.DisplayName,
                session.CreationTime,
                session.GameID,
                session.SessionID,
                session.Variant,
                session.SeatsAvailable,
                session.OwnerSeatIndex,
                session.State.ActiveSeatIndex,
                session.State.IsComplete,
                session.State.LastModified);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="partnerToken"></param>
        private static SessionService GetGameSessionProxy(string url, string partnerToken)
        {
            return GetGameSessionProxy(url, "en-US", ((int)Leet.Core.Platforms.PlatformType.Mobile).ToString(), partnerToken);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="locale"></param>
        /// <param name="platformType"></param>
        /// <param name="partnerToken"></param>
        /// <returns></returns>
        private static SessionService GetGameSessionProxy(string url, string locale, string platformType, string partnerToken)
        {
            SessionService sessionService = new SessionService(url);
            sessionService.Locale = locale;
            sessionService.PlatformType = platformType;
            sessionService.PartnerAuthorizationToken = partnerToken;
            return sessionService;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\Multiplayer\ServiceBaseUtil.cs ===
﻿using System;
using LiveN.Test.Common;
using LiveN.Test.Framework.Authorization;
using LiveN.Test.Common.Web;

namespace LiveN.Test.Services.Multiplayer
{
    /// <summary>
    /// 
    /// </summary>
    public class ServiceBaseUtil
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stsUrl"></param>
        /// <param name="clientCertSubject"></param>
        /// <param name="liveIdServiceTarget"></param>
        /// <param name="policy"></param>
        /// <param name="environment"></param>
        /// <param name="titleId"></param>
        /// <param name="titleVersion"></param>
        public ServiceBaseUtil(string stsUrl, string clientCertSubject, string liveIdServiceTarget, string policy, string environment, string titleId, string titleVersion)
            : this(stsUrl, clientCertSubject, liveIdServiceTarget, policy, environment, titleId, titleVersion, "15", "1", string.Empty)
        {
        }

        public ServiceBaseUtil(string stsUrl, string clientCertSubject, string liveIdServiceTarget, string policy, string environment, string titleId, string titleVersion, string platformType, string clientVersion)
            : this(stsUrl, clientCertSubject, liveIdServiceTarget, policy, environment, titleId, titleVersion, platformType, clientVersion, string.Empty)
        {
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="stsUrl"></param>
        /// <param name="clientCertSubject"></param>
        /// <param name="liveIdServiceTarget"></param>
        /// <param name="policy"></param>
        /// <param name="environment"></param>
        /// <param name="titleId"></param>
        /// <param name="titleVersion"></param>
        /// <param name="platformType"></param>
        /// <param name="clientVersion"></param>
        public ServiceBaseUtil(string stsUrl, string clientCertSubject, string liveIdServiceTarget, string policy, string environment, string titleId, string titleVersion, string platformType, string clientVersion, string audienceUri)
        {
            this.AuthorizationCache = new AuthorizationCache(stsUrl, clientCertSubject);

            this.LiveIdServiceTarget = liveIdServiceTarget;
            this.Policy = policy;
            this.Environment = environment;

            this.TitleId = titleId;
            this.TitleVersion = titleVersion;
            this.PlatformType = platformType;
            this.ClientVersion = clientVersion;
            this.AudienceUri = audienceUri;
        }

        /// <summary>
        /// 
        /// </summary>
        public AuthorizationCache AuthorizationCache
        {
            get;
            private set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string LiveIdServiceTarget
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string Policy
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string Environment
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string TitleId
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string TitleVersion
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string PlatformType
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string ClientVersion
        {
            get;
            set;
        }

        /// <summary>
        /// Note: only used by Game Session/State services (they require partner tokens)
        /// </summary>
        public string AudienceUri
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="serviceError"></param>
        /// <param name="e"></param>
        /// <param name="format"></param>
        /// <param name="args"></param>
        internal static void TraceError(ServiceError serviceError, Exception e, string format, params object[] args)
        {
            TraceError(serviceError, e, String.Format(format, args));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
        /// <param name="serviceError"></param>
        /// <param name="e"></param>
        public static void TraceError(ServiceError serviceError, Exception e, string message)
        {
            string errorTrace;
            if (e is RestException)
            {
                errorTrace = message + ":\r\n\r\n" + (e as RestException).Response.ToString();
            }
            else
            {
                errorTrace = message + "; " + e.Message + ":\r\n" + e.ToString();
            }

            TraceEx.TraceError((int)serviceError, errorTrace);
        }

        public static ServiceErrorMessage ParseServiceError(string responseXml)
        {
            return null;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="memberName"></param>
        /// <param name="password"></param>
        /// <returns></returns>
        internal string GetPartnerToken(string memberName, string password)
        {
            string userToken = AuthorizationCache.GetUserToken(
                                        memberName,
                                        password,
                                        this.LiveIdServiceTarget,
                                        this.Policy,
                                        this.Environment,
                                        this.PlatformType,
                                        this.TitleId,
                                        this.TitleVersion,
                                        this.ClientVersion);
            string partnerToken = AuthorizationCache.GetPartnerToken(
                                        userToken,
                                        this.TitleId,
                                        this.TitleVersion,
                                        this.AudienceUri);
            return partnerToken;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\Multiplayer\MultiplayerUtil.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;
using LiveN.Test.Common;
using LiveN.Test.Framework.Authorization;

namespace LiveN.Test.Services.Multiplayer
{
    /// <summary>
    /// Wrapper for all Multiplayer/Notifications service proxies.
    /// </summary>
    public class MultiplayerUtil
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="gameSessionUrl"></param>
        /// <param name="gameStateUrl"></param>
        /// <param name="notificationsUrl"></param>
        /// <param name="stsUrl"></param>
        /// <param name="clientCertSubject"></param>
        /// <param name="liveIdServiceTarget"></param>
        /// <param name="policy"></param>
        /// <param name="environment"></param>
        /// <param name="titleId"></param>
        /// <param name="titleVersion"></param>
        /// <param name="platformType"></param>
        /// <param name="clientVersion"></param>
        /// <param name="audienceUri"></param>
        public MultiplayerUtil(
            string gameSessionUrl,
            string gameStateUrl,
            string notificationsUrl,
            string stsUrl,
            string clientCertSubject,
            string liveIdServiceTarget,
            string policy,
            string environment,
            string titleId,
            string titleVersion,
            string platformType,
            string clientVersion,
            string audienceUri)
        {
            this.GameSessionUtil = new GameSessionUtil(gameSessionUrl, stsUrl, clientCertSubject, liveIdServiceTarget, policy, environment, titleId, titleVersion, platformType, clientVersion, audienceUri);
            this.GameSessionUtil.AudienceUri = audienceUri;

            this.GameStateUtil = new GameStateUtil(gameStateUrl, stsUrl, clientCertSubject, liveIdServiceTarget, policy, environment, titleId, titleVersion, platformType, clientVersion, audienceUri);
            this.GameStateUtil.AudienceUri = audienceUri;

            this.NotificationsUtil = new NotificationsUtil(notificationsUrl, stsUrl, clientCertSubject, liveIdServiceTarget, policy, environment, titleId, titleVersion, platformType, clientVersion);
        }

        /// <summary>
        /// 
        /// </summary>
        public GameSessionUtil GameSessionUtil
        {
            get;
            private set;
        }

        /// <summary>
        /// 
        /// </summary>
        public GameStateUtil GameStateUtil
        {
            get;
            private set;
        }

        /// <summary>
        /// 
        /// </summary>
        public NotificationsUtil NotificationsUtil
        {
            get;
            private set;
        }


        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public Result<bool> GetRpsTicket(string memberName, string password)
        {
            Result<bool> result = new Result<bool>();

            try
            {
                TraceEx.TraceStart("Starting IDCRL/Windows Live ID prereq check validation...");
                result.Start();
                string loginTicket = this.GameSessionUtil.AuthorizationCache.GetLoginTicket(
                    memberName,
                    password,
                    this.GameSessionUtil.LiveIdServiceTarget,
                    this.GameSessionUtil.Policy,
                    this.GameSessionUtil.Environment);
                result.ReturnValue = true;
                TraceEx.TraceVerbose("RPS ticket={0}", loginTicket);
                Trace.TraceInformation("Verified that {0} can login via IDCRL/Windows Live ID.", memberName);                
            }
            catch (Exception e)
            {
                ServiceBaseUtil.TraceError(ServiceError.PrereqIdcrl, e, "Unable to get RPS ticket for {0}.  Verify the username and password are correct", memberName);
            }
            finally
            {
                result.Stop();
                TraceEx.TraceStop("Completed IDCRL/Windows Live ID validation.  Took {0}ms.", result.Latency.TotalMilliseconds);
            }

            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public Result<bool> GetStsUserToken(string memberName, string password, string platformType, string titleId, string titleVersion, string clientVersion)
        {
            Result<bool> result = new Result<bool>();

            try
            {
                TraceEx.TraceStart("Starting STS User Token prereq check validation...");
                result.Start();
                string userToken = this.GameSessionUtil.AuthorizationCache.GetUserToken(
                                        memberName,
                                        password,
                                        this.GameSessionUtil.LiveIdServiceTarget,
                                        this.GameSessionUtil.Policy,
                                        this.GameSessionUtil.Environment,
                                        platformType,
                                        titleId,
                                        titleVersion,
                                        clientVersion);
                TraceEx.TraceVerbose("STS User Token={0}", userToken);

                //if this is a machine token, the user doesn't have an XBL account
                if (!Authorization.IsUserSecurityToken(userToken))
                {
                    TraceEx.TraceError((int)ServiceError.PrereqVerifyXblUser, "The platform STS service returned a Machine token for {0}; this user does not have an Xbox Live account.", memberName);
                    result.ReturnValue = false;
                }
                Trace.TraceInformation("Verified that {0} can obtain an STS user token.", memberName);
                result.ReturnValue = true;
            }
            catch (Exception e)
            {
                ServiceBaseUtil.TraceError(ServiceError.PrereqStsUserToken, e, "Unable to get an STS user token for {0}, with title ID {1} and title version {2}.", memberName, titleId, titleVersion);
            }
            finally
            {
                result.Stop();
                TraceEx.TraceStop("Completed STS user token validation.  Took {0}ms.", result.Latency.TotalMilliseconds);
            }

            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public Result<bool> GetStsPartnerToken(string memberName, string password, string platformType, string titleId, string titleVersion, string clientVersion, string audienceUri)
        {
            Result<bool> result = new Result<bool>();

            try
            {
                TraceEx.TraceStart("Starting STS Partner Token prereq check validation...");
                result.Start();
                string userToken = this.GameSessionUtil.AuthorizationCache.GetUserToken(
                                        memberName,
                                        password,
                                        this.GameSessionUtil.LiveIdServiceTarget,
                                        this.GameSessionUtil.Policy,
                                        this.GameSessionUtil.Environment,
                                        platformType,
                                        titleId,
                                        titleVersion,
                                        clientVersion);
                string partnerToken = this.GameSessionUtil.AuthorizationCache.GetPartnerToken(
                                        userToken,
                                        titleId,
                                        titleVersion,
                                        audienceUri);
                result.ReturnValue = true;
                TraceEx.TraceVerbose("STS Partner Token={0}", partnerToken);
                Trace.TraceInformation("Verified that {0} can obtain an STS partner token.", memberName);
            }
            catch (Exception e)
            {
                ServiceBaseUtil.TraceError(ServiceError.PrereqStsPartnerToken, e, "Unable to get an STS partner token for {0}, with title ID {1}, title version {2} and audience Uri {3}", memberName, this.GameSessionUtil.TitleId, this.GameSessionUtil.TitleVersion, this.GameSessionUtil.AudienceUri);
            }
            finally
            {
                result.Stop();
                TraceEx.TraceStop("Completed STS Partner Token validation.  Took {0}ms.", result.Latency.TotalMilliseconds);
            }

            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public Result<bool> VerifyTitle(string memberName, string password, string platformType, string titleId, string titleVersion, string clientVersion)
        {
            Result<bool> result = new Result<bool>();

            try
            {
                TraceEx.TraceStart("Starting Title ID/Version prereq check validation...");
                result.Start();
                string userToken = this.GameSessionUtil.AuthorizationCache.GetUserToken(
                                        memberName,
                                        password,
                                        this.GameSessionUtil.LiveIdServiceTarget,
                                        this.GameSessionUtil.Policy,
                                        this.GameSessionUtil.Environment,
                                        platformType,
                                        titleId,
                                        titleVersion,
                                        clientVersion);
                result.ReturnValue = result.Passed = true;
                Trace.TraceInformation("Verified that title ID {0} and title version {1}, for platform {2}, are valid.", titleId, titleVersion, platformType);
            }
            catch (Exception e)
            {
                result.Error = e;
                ServiceBaseUtil.TraceError(ServiceError.PrereqVerifyTitle, e, "Unable verify that title ID {0} and title version {1} are valid and available.  Verify this title has been propped in GMS and xLast", titleId, titleVersion);
            }
            finally
            {
                result.Stop();
                TraceEx.TraceStop("Completed Title ID/Version validation.  Took {0}ms", result.Latency.TotalMilliseconds);
            }

            return result;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\Multiplayer\MultiplayerMonitoringBlock.cs ===
﻿using System;
using System.Linq;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using System.Threading;
using AsyncMultiplayer.SessionCommon;
using AsyncMultiplayer.NotificationService;
using LiveN.Test.Common;
using LiveN.Test.Common.Web;
using LiveN.Test.Framework;

namespace LiveN.Test.Services.Multiplayer
{
    /// <summary>
    /// 
    /// </summary>
    public class MultiplayerMonitoringBlock: MonitoringBlock
    {
        private MultiplayerUtil multiplayerUtil;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="environment"></param>
        public MultiplayerMonitoringBlock(string environment): base(environment)
        {
            //NOTE: need to create an instance of MultiplayerUtil (or dervied class)
            //      to be able to use the static Auth cache
            this.multiplayerUtil = new MultiplayerUtil(
                this.Environment.GameSessionService.ToString(),
                this.Environment.GameStateService.ToString(),
                this.Environment.NotificationsService.ToString(),
                this.Environment.StsSettings.StsUrl,
                this.Environment.StsSettings.ClientCertSubject,
                this.Environment.WindowsLiveIDSettings.LiveIdServiceTarget,
                this.Environment.WindowsLiveIDSettings.Policy,
                this.Environment.WindowsLiveIDSettings.Environment,
                this.Environment.StsSettings.TitleId,
                this.Environment.StsSettings.TitleVersion,
                this.Environment.StsSettings.PlatformType,
                this.Environment.StsSettings.ClientVersion,
                this.Environment.StsSettings.AudienceUri_MultiPlayer);
        }

        /// <summary>
        /// 
        /// </summary>
        public override string Name
        {
            get { return "Multiplayer"; }
        }

        /// <summary>
        /// 
        /// </summary>
        public override string FullName
        {
            get { return "Multiplayer (Game Session/State + Notifications)"; }
        }

        /// <summary>
        /// 
        /// </summary>
        public override int Priority
        {
            get
            {
                return 6;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public override List<TestInfo> GetTestNames()
        {
            return GetMonitoringTests();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public override List<IResult> RunTests()
        {
            List<IResult> results = new List<IResult>();
            List<IResult> getNotificationsResults = new List<IResult>();
            XboxLiveAccount player1, player2;

            //make sure we have a multiplayer title available.  If not, we're done...
            results.Add(VerifyMultiplayerTitle(
                this.Environment.UserSettings[0].Membername,
                this.Environment.UserSettings[0].Password));
            if (!results[0].Passed) 
                return results;

            //player 1 creates the game session
            Result<SessionState> createResult = CreateSessionWithRetry(out player1);
            results.Add(createResult);
            if (!createResult.Passed)
                return results;
                                             
            string sessionId = createResult.ReturnValue.SessionID;

            Result<bool> result = SendInviteWithRetry(player1, sessionId, out player2);
            results.Add(result);
            if (!result.Passed)
                return results;

            //validate invite notification for player2
            result = VerifyNotification(player2, sessionId, Notification.NotificationType.Invitation);
            getNotificationsResults.Add(result);

            //player 2 joins the session
            Result<SessionState> joinResult = JoinSession(player2.MemberName, player2.Password, sessionId);
            results.Add(joinResult);
            if (!joinResult.Passed)
                return results;

            //player 1 makes the first move
            byte[] gameData = Utility.GenerateRandomBytes(1024);
            result = PutGameState(player1.MemberName, player1.Password, sessionId, gameData, 1);
            results.Add(result);
            if (!result.Passed)
                return results;

            //validate your turn notification for player2
            result = VerifyNotification(player2, sessionId, Notification.NotificationType.YourTurn);
            getNotificationsResults.Add(result);

            //player 2 reads the board
            Result<FullGameState> gameState = GetGameState(player2.MemberName, player2.Password, sessionId);
            results.Add(gameState);

            result = PostGameEnd(player2.MemberName, player2.Password, sessionId, 1, 0);
            results.Add(result);

            //validate you win/lose notifications for both players
            result = VerifyNotification(player1, sessionId, Notification.NotificationType.YouLose);
            getNotificationsResults.Add(result);
            result = VerifyNotification(player2, sessionId, Notification.NotificationType.YouWin);
            getNotificationsResults.Add(result);
            
            Result<SessionState> viewSession = ViewSession(player1.MemberName, player1.Password, sessionId);
            results.Add(viewSession);

            Result<SessionEntry[]> viewSessionSummaries = ViewSessionSummaries(player2.MemberName, player2.Password);
            results.Add(viewSession);

            //process an aggregate result for GetNotifications
            results.Add(GetNotifications(getNotificationsResults));

            return results;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        [MonitoringTest(Name = "Verify Multiplayer Title", Id = "93C7366E-3BD2-4DC6-9F1A-11D711BA9865")]
        private Result<bool> VerifyMultiplayerTitle(string username, string password)
        {
            Result<bool> result = new Result<bool>();
            TestInfo testInfo = GetTestInfo();
            
            try
            {
                StartTest(testInfo);
                result = this.multiplayerUtil.VerifyTitle(
                        username,
                        password,
                        this.Environment.StsSettings.PlatformType,
                        this.Environment.StsSettings.TitleId,
                        this.Environment.StsSettings.TitleVersion,
                        this.Environment.StsSettings.ClientVersion);
            }
            finally
            {
                EndTest(testInfo, result);
            }

            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="username"></param>
        /// <param name="password"></param>
        /// <returns></returns>
        [MonitoringTest(Name = "CreateSession", Id = "3152962C-3A4A-4A8F-BE39-058C534822EC")]
        private Result<SessionState> CreateSession(string username, string password)
        {
            Result<SessionState> result = new Result<SessionState>();
            TestInfo testInfo = GetTestInfo();

            try
            {
                StartTest(testInfo);
                result = this.multiplayerUtil.GameSessionUtil.CreateGameSession(
                        username,
                        password);
                GameSessionUtil.TraceSession(result.ReturnValue);
            }
            finally
            {
                EndTest(testInfo, result);
            }

            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="player1"></param>
        /// <returns></returns>
        private Result<SessionState> CreateSessionWithRetry(out XboxLiveAccount player1)
        {
            int randomUserIndex = Utility.GlobalRandom.Next(this.Environment.UserSettings.Count);
            int startIndex = randomUserIndex;
            Result<SessionState> createResult;

            do
            {
                player1 = new XboxLiveAccount() { MemberName = this.Environment.UserSettings[randomUserIndex].Membername, Password = this.Environment.UserSettings[randomUserIndex].Password };
                createResult = CreateSession(player1.MemberName, player1.Password);

                randomUserIndex++;
                if (randomUserIndex >= this.Environment.UserSettings.Count)
                    randomUserIndex = 0;

                if (randomUserIndex == startIndex)
                {
                    //we went all the way around, and no dice; time to bail
                    Trace.TraceError("No more users are available; all pre-existing users have reached the maximum number of game sessions!");
                    break;
                }

                if(CheckForSessionsQuota(createResult))
                    Trace.TraceWarning("{0} has too many game sessions; attempting to call CreateSession with {1}...", player1.MemberName, this.Environment.UserSettings[randomUserIndex].Membername);
            }
            while (CheckForSessionsQuota(createResult));

            return createResult;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="username"></param>
        /// <param name="password"></param>
        /// <param name="sessionId"></param>
        /// <returns></returns>
        [MonitoringTest(Name = "JoinSession", Id = "C81E9898-9271-4637-98E7-F42312E6D9D7")]
        private Result<SessionState> JoinSession(string username, string password, string sessionId)
        {
            Result<SessionState> result = new Result<SessionState>();
            TestInfo testInfo = GetTestInfo();

            try
            {
                StartTest(testInfo);
                result = this.multiplayerUtil.GameSessionUtil.JoinSession(
                        username,
                        password,
                        sessionId);
                GameSessionUtil.TraceSession(result.ReturnValue);
            }
            finally
            {
                EndTest(testInfo, result);
            }

            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="username"></param>
        /// <param name="password"></param>
        /// <param name="sessionId"></param>
        /// <returns></returns>
        [MonitoringTest(Name = "ViewSession", Id = "{5EB7F6E1-1432-462B-AB3A-36E209BA49AB}")]
        private Result<SessionState> ViewSession(string username, string password, string sessionId)
        {
            Result<SessionState> result = new Result<SessionState>();
            TestInfo testInfo = GetTestInfo();

            try
            {
                StartTest(testInfo);
                result = this.multiplayerUtil.GameSessionUtil.ViewSession(
                        username,
                        password,
                        sessionId);
                GameSessionUtil.TraceSession(result.ReturnValue);
            }
            finally
            {
                EndTest(testInfo, result);
            }

            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="username"></param>
        /// <param name="password"></param>
        /// <returns></returns>
        [MonitoringTest(Name = "ViewSessionSummaries", Id = "B25BFA10-3C3D-4582-915E-B969EB528AF1")]
        private Result<SessionEntry[]> ViewSessionSummaries(string username, string password)
        {
            Result<SessionEntry[]> result = new Result<SessionEntry[]>();
            TestInfo testInfo = GetTestInfo();

            try
            {
                StartTest(testInfo);
                result = this.multiplayerUtil.GameSessionUtil.ViewSessionSummaries(
                        username,
                        password);
                //TODO: trace session count and name/id
            }
            finally
            {
                EndTest(testInfo, result);
            }

            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="username"></param>
        /// <param name="password"></param>
        /// <param name="sessionId"></param>
        /// <param name="gameData"></param>
        /// <param name="activeSeat"></param>
        /// <returns></returns>
        [MonitoringTest(Name = "PutGameState", Id = "A61DCA8A-CFB9-437C-8828-6CA8F103B92F")]
        private Result<bool> PutGameState(string username, string password, string sessionId, byte[] gameData, int activeSeat)
        {
            Result<bool> result = new Result<bool>();
            TestInfo testInfo = GetTestInfo();

            try
            {
                StartTest(testInfo);
                result = this.multiplayerUtil.GameStateUtil.PutGameState(
                        username,
                        password,
                        gameData,
                        activeSeat,
                        sessionId
                        );
            }
            finally
            {
                EndTest(testInfo, result);
            }

            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="username"></param>
        /// <param name="password"></param>
        /// <param name="sessionId"></param>
        /// <returns></returns>
        [MonitoringTest(Name = "GetGameState", Id = "C464F303-861D-4399-940F-B2BA530BCA7B")]
        private Result<FullGameState> GetGameState(string username, string password, string sessionId)
        {
            Result<FullGameState> result = new Result<FullGameState>();
            TestInfo testInfo = GetTestInfo();

            try
            {
                StartTest(testInfo);
                result = this.multiplayerUtil.GameStateUtil.GetGameState(
                        username,
                        password,
                        sessionId
                        );
            }
            finally
            {
                EndTest(testInfo, result);
            }

            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="username"></param>
        /// <param name="password"></param>
        /// <param name="sessionId"></param>
        /// <param name="winningSeat"></param>
        /// <param name="losingSeat"></param>
        /// <returns></returns>
        [MonitoringTest(Name = "PostGameEnd", Id = "17278B63-D1E6-4757-8A35-DEADF3719481")]
        private Result<bool> PostGameEnd(string username, string password, string sessionId, int winningSeat, int losingSeat)
        {
            Result<bool> result = new Result<bool>();
            TestInfo testInfo = GetTestInfo();

            try
            {
                StartTest(testInfo);
                result = this.multiplayerUtil.GameStateUtil.PostGameEnd(
                        username,
                        password,
                        sessionId,
                        winningSeat,
                        losingSeat
                        );
            }
            finally
            {
                EndTest(testInfo, result);
            }

            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="username"></param>
        /// <param name="password"></param>
        /// <param name="sessionId"></param>
        /// <param name="emailAddresses"></param>
        /// <returns></returns>
        [MonitoringTest(Name = "SendInvite", Id = "A5D47DC5-9E7D-4496-8003-A330648F2473")]
        private Result<bool> SendInvite(string username, string password, string sessionId, string emailAddresses)
        {
            Result<bool> result = new Result<bool>();
            TestInfo testInfo = GetTestInfo();

            try
            {
                StartTest(testInfo);
                result = this.multiplayerUtil.NotificationsUtil.SendInvite(
                        username,
                        password,
                        sessionId,
                        emailAddresses);
            }
            finally
            {
                EndTest(testInfo, result);
            }

            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="getNotificationResults"></param>
        [MonitoringTest(Name = "GetNotifications", Id = "539F696D-D4CC-4AFB-8AB9-BB09EBD86452")]
        private Result<bool> GetNotifications(List<IResult> getNotificationResults)
        {
            Result<bool> result = new Result<bool>();
            TestInfo testInfo = GetTestInfo();

            try
            {
                StartTest(testInfo);                
                result.ReturnValue = result.Passed = getNotificationResults.All<IResult>(r => r.Passed);
                result.Latency = TimeSpan.FromMilliseconds(getNotificationResults.Sum<IResult>(r => r.Latency.TotalMilliseconds));

                if (!result.Passed)
                {
                    StringBuilder errors = new StringBuilder();
                    for (int i = 0; i < getNotificationResults.Count; i++)
                    {
                        if(!getNotificationResults[i].Passed && getNotificationResults[i].Error != null)
                            errors.Append(getNotificationResults[i].Error.Message + "\r\n");
                    }

                    result.Error = new ApplicationException(errors.ToString());
                }
            }
            finally
            {
                EndTest(testInfo, result);
            }

            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="account"></param>
        /// <param name="sessionId"></param>
        /// <param name="type"></param>
        /// <returns></returns>
        private Result<bool> VerifyNotification(XboxLiveAccount account, string sessionId, Notification.NotificationType type)
        {
            Result<bool> result = new Result<bool>() { Passed = false };
            DateTime start = DateTime.Now;
            int count = 0;

            do
            {
                count++;
                Result<List<Notification>> notificationsResult = this.multiplayerUtil.NotificationsUtil.GetNotifications(account.MemberName, account.Password);
                result.Latency = DateTime.Now.Subtract(start);

                if (!notificationsResult.Passed)
                {
                    result.Error = notificationsResult.Error;
                    continue;
                }
                
                IEnumerable<Notification> notifications = notificationsResult.ReturnValue.Where<Notification>(n => n.SessionId == sessionId && n.Type == type);
                int notificationCount = notifications.Count<Notification>();
                if (notificationCount == 1)
                {
                    Trace.TraceInformation("Successfully found '{0}' notification for {1}, after {2}ms", type, account.MemberName, result.Latency.TotalMilliseconds);
                    result.Passed = true;
                    return result;
                }
                else if (notificationCount > 1) //this would be a bug...
                {
                    Trace.TraceError("Found multiple '{0}' notification for {1}, after {2}ms", type, account.MemberName, result.Latency.TotalMilliseconds);
                    result.Passed = false;
                    return result;
                }

                Thread.Sleep(1000); //throttle for a sec
            }
            while (DateTime.Now.Subtract(start).TotalSeconds < 60);

            string error = String.Format("Unable to verify that a '{0}' notification, for session ID {1}, was delivered for {2}, after calling GetNotifications {3} times (60s).", type, sessionId, account.MemberName, count);
            Trace.TraceError(error);
            result.Error = new ApplicationException(error);
            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="player1"></param>
        /// <param name="sessionId"></param>
        /// <param name="player2"></param>
        /// <returns></returns>
        private Result<bool> SendInviteWithRetry(XboxLiveAccount player1, string sessionId, out XboxLiveAccount player2)
        {
            int randomUserIndex;
            Result<bool> result;

            //select another, random user to invite to the game session
            do
            {
                randomUserIndex = Utility.GlobalRandom.Next(this.Environment.UserSettings.Count); 
                player2 = new XboxLiveAccount() { MemberName = this.Environment.UserSettings[randomUserIndex].Membername, Password = this.Environment.UserSettings[randomUserIndex].Password };                
            }
            while (player1.Equals(player2));    //make sure a user isn't sending an invite to themselves...

            string senderMemberName = player1.MemberName;
            string senderPassword = player1.Password;
            int startIndex = randomUserIndex;

            // user can actually create a game session and not be able to send game invites due to our invite cap.
            // However, our system also allows users who have NOT created the game session to send games invites for it.  

            //TL;DR: if the game session creator can't send an invite, find another, random user who can

            do
            {                
                result = SendInvite(senderMemberName, senderPassword, sessionId, player2.MemberName);
                if (CheckForInviteQuota(result))
                {
                    randomUserIndex++;
                    if (randomUserIndex >= this.Environment.UserSettings.Count)
                        randomUserIndex = 0;

                    if (randomUserIndex == startIndex)
                    {
                        //we went all the way around, and no dice; time to bail
                        Trace.TraceError("No more users are available; all pre-existing users have reached the maximum number of game invitations, per hour!");
                        break;
                    }

                    Trace.TraceWarning("{0} has sent too many game invitations, per hour.  Attempting to call SendInvite with {1}...", senderMemberName, this.Environment.UserSettings[randomUserIndex].Membername); 
                    senderMemberName = this.Environment.UserSettings[randomUserIndex].Membername;
                    senderPassword = this.Environment.UserSettings[randomUserIndex].Password;
                }                                  
            }
            while (CheckForInviteQuota(result));

            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="result"></param>
        /// <returns></returns>
        private static bool CheckForSessionsQuota(IResult result)
        {
            if (result.Error != null && result.Error is RestException)
            {
                RestException re = result.Error as RestException;
                ServiceErrorMessage error = new ServiceErrorMessage(re.Response.Body);
                if (error.ErrorCode.Equals(((uint)SessionServiceError.TooManySessionsCreatedByTheUser).ToString(), StringComparison.InvariantCultureIgnoreCase))
                    return true;
            }

            return false;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="result"></param>
        /// <returns></returns>
        private static bool CheckForInviteQuota(IResult result)
        {
            if (result.Error != null && result.Error is RestException)
            {
                RestException re = result.Error as RestException;
                ServiceErrorMessage error = new ServiceErrorMessage(re.Response.Body);
                if (error.ErrorCode.Equals(((uint)NotificationServiceErrors.InviteQuotaExceeded).ToString(), StringComparison.InvariantCultureIgnoreCase))
                    return true;
            }

            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\Multiplayer\ServiceError.cs ===
﻿using System;

namespace LiveN.Test.Services.Multiplayer
{
    /// <summary>
    /// 
    /// </summary>
    public enum ServiceError : int
    {
        InvalidArgument = 1000,
        InvalidEnvironment,
        PrereqClientCertificate,
        PrereqIdcrl,
        PrereqVerifyXblUser,
        PrereqStsUserToken,
        PrereqStsPartnerToken,
        PrereqVerifyTitle,
        PrereqChecks,
        CreateSession,
        SendInvite,
        JoinSession,
        PutGameState,
        GetGameState,
        PostGameEnd,
        ViewSession,
        ViewSessionSummaries,
        GetNotifications,
        GetSpotlight,
        ValidationError,
        GetUserTokenXml,
        GetPartnerTokenXml,
        Unknown,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\Multiplayer\GameStateUtil.cs ===
﻿using System;
using System.Collections.Generic;
using System.Diagnostics;
using AsyncMultiplayer.SessionCommon;
using Gds.Contracts;
using LiveN.Test.Common;

namespace LiveN.Test.Services.Multiplayer
{
    /// <summary>
    /// 
    /// </summary>
    public class GameStateUtil: ServiceBaseUtil
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stsUrl"></param>
        /// <param name="clientCertSubject"></param>
        /// <param name="liveIdServiceTarget"></param>
        /// <param name="policy"></param>
        /// <param name="environment"></param>
        public GameStateUtil(string gameStateUrl, string stsUrl, string clientCertSubject, string liveIdServiceTarget, string policy, string environment, string titleId, string titleVersion, string platformType, string clientVersion, string audienceUri): base(stsUrl, clientCertSubject, liveIdServiceTarget, policy, environment, titleId, titleVersion, platformType, clientVersion)
        {
            this.GameSessionUrl = new Uri(gameStateUrl);
            this.AudienceUri = audienceUri;
        }

        /// <summary>
        /// 
        /// </summary>
        public Uri GameSessionUrl
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="memberName"></param>
        /// <param name="password"></param>
        /// <param name="sessionId"></param>
        /// <param name="inviteEmailTo"></param>
        /// <returns></returns>
        public Result<FullGameState> GetGameState(string memberName, string password, string sessionId)
        {
            Result<FullGameState> result = new Result<FullGameState>();

            try
            {
                TraceEx.TraceStart("{0} is attempting to get game state for session {1}...", memberName, sessionId);
                string partnerToken = GetPartnerToken(memberName, password);
                StateService gameStateProxy = GetGameStateProxy(this.GameSessionUrl.ToString(), partnerToken);
                result.Start();
                result.ReturnValue = gameStateProxy.GetGameState(sessionId, this.TitleId);
                result.Passed = true;
                Trace.TraceInformation("Successfully retrieved game state.");
            }
            catch (Exception e)
            {
                result.Error = e;
                TraceError(ServiceError.GetGameState, e, "Error retrieving game state");
            }
            finally
            {
                result.Stop();
                TraceEx.TraceStop("Completed get game state.  Took {0}ms.", result.Latency.TotalMilliseconds);
            }

            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="memberName"></param>
        /// <param name="password"></param>
        /// <param name="gameState"></param>
        /// <param name="activeSeat"></param>
        /// <param name="sessionId"></param>
        /// <returns></returns>
        public Result<bool> PutGameState(string memberName, string password, byte[] gameState, int activeSeat, string sessionId)
        {
            Result<bool> result = new Result<bool>();

            try
            {
                TraceEx.TraceStart("{0} is attempting to put game state for session {1}...", memberName, sessionId);
                string partnerToken = GetPartnerToken(memberName, password);
                StateService gameStateProxy = GetGameStateProxy(this.GameSessionUrl.ToString(), partnerToken);
                ModifiableGameState updatedGameState = new ModifiableGameState()
                {
                    ActiveSeatIndex = activeSeat,
                    GameData = gameState
                };

                result.Start();
                gameStateProxy.PutGameState(sessionId, this.TitleId, updatedGameState);
                result.ReturnValue = result.Passed = true;
                Trace.TraceInformation("Successfully put game state.");
            }
            catch (Exception e)
            {
                result.Error = e;
                TraceError(ServiceError.PutGameState, e, "Error putting game state");
            }
            finally
            {
                result.Stop();
                TraceEx.TraceStop("Completed put game state.  Took {0}ms.", result.Latency.TotalMilliseconds);
            }

            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="memberName"></param>
        /// <param name="password"></param>
        /// <param name="gameState"></param>
        /// <param name="activeSeat"></param>
        /// <param name="sessionId"></param>
        /// <returns></returns>
        public Result<bool> PostGameEnd(string memberName, string password, string sessionId, int winningSeat, int losingSeat)
        {
            Result<bool> result = new Result<bool>();

            try
            {
                TraceEx.TraceStart("{0} is attempting to post game end for session {1}...", memberName, sessionId);
                string partnerToken = GetPartnerToken(memberName, password);
                StateService gameStateProxy = GetGameStateProxy(this.GameSessionUrl.ToString(), partnerToken);
                GameResults results = CreateGameResults(this.TitleId, winningSeat, losingSeat);

                result.Start();
                gameStateProxy.PostGameEnd(sessionId, this.TitleId, results);
                result.ReturnValue = result.Passed = true;
                Trace.TraceInformation("Successfully posted game end.");
            }
            catch (Exception e)
            {
                result.Error = e;
                TraceError(ServiceError.PostGameEnd, e, "Error posting game end");
            }
            finally
            {
                result.Stop();
                TraceEx.TraceStop("Completed post game end.  Took {0}ms.", result.Latency.TotalMilliseconds);
            }

            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="partnerToken"></param>
        /// <returns></returns>
        private static StateService GetGameStateProxy(string url, string partnerToken)
        {
            return GetGameStateProxy(url, "en-US", ((int)Leet.Core.Platforms.PlatformType.Mobile).ToString(), partnerToken);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="locale"></param>
        /// <param name="platformType"></param>
        /// <param name="partnerToken"></param>
        /// <returns></returns>
        private static StateService GetGameStateProxy(string url, string locale, string platformType, string partnerToken)
        {
            StateService stateService = new StateService(url);
            stateService.Locale = locale;
            stateService.PlatformType = platformType;
            stateService.PartnerAuthorizationToken = partnerToken;
            return stateService;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="titleId"></param>
        /// <param name="winningSeat"></param>
        /// <param name="losingSeat"></param>
        /// <returns></returns>
        private static GameResults CreateGameResults(string titleId, int winningSeat, int losingSeat)
        {
            GameResults results = new GameResults();
            results.Results = new Dictionary<int, Gds.Contracts.GameResult>();
            results.WinningSeatIndexes = new int[] { winningSeat };
            results.LosingSeatIndexes = new int[] { losingSeat };

            results.Results.Add(0, new GameResult()
            {
                GameId = uint.Parse(titleId),
                GameResultId = Guid.NewGuid(),
                Outcome = (winningSeat == 0) ? GameResultOutcome.Win.ToString() : GameResultOutcome.Loss.ToString(),
                Score = null,
                Time = null,
                TimeStamp = DateTime.UtcNow,
                Variant = 0
            });

            results.Results.Add(1, new GameResult()
            {
                GameId = uint.Parse(titleId),
                GameResultId = Guid.NewGuid(),
                Outcome = (winningSeat == 1) ? GameResultOutcome.Win.ToString() : GameResultOutcome.Loss.ToString(),
                Score = null,
                Time = null,
                TimeStamp = DateTime.UtcNow,
                Variant = 0
            });

            return results;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\Multiplayer\NotificationsService.cs ===
﻿using System;
using System.Collections.Generic;
using System.Security.Cryptography.X509Certificates;
using AsyncMultiplayer.NotificationService;
using LiveN.Test.Common.Web;
using LiveN.Test.Framework.Web;

namespace LiveN.Test.Services.Multiplayer
{
    /// <summary>
    /// 
    /// </summary>
    public enum NotificationServiceErrors: uint
    {
        InviteQuotaExceeded = 2148015942,
    }

    /// <summary>
    /// 
    /// </summary>
    public class NotificationsService : XboxWcfService
    {
        public const string GetNotificationsUrlFormat = "/game/{gameId}";
        public const string DeleteNotificationsBySessionUrlFormat = "/deletesession/?game={gameIdString}&session={sessionId}";
        public const string DeleteNotificationsUrlFormat = "/delete/?notification={notificationId}";
        public const string SpotlightUrlFormat = "/Spotlight/?carrier={carrierString}";
        public const string UpdateNotificationUrlFormat = "/update/?notification={notificationId}&status={status}";

        /// <summary>
        /// 
        /// </summary>
        /// <param name="baseUri"></param>
        public NotificationsService(string baseUri): base(baseUri)
        {

        }

        /// <summary>
        /// 
        /// </summary>
        public string EtagInResponse
        {
            get;
            private set;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="locale"></param>
        /// <param name="eTag"></param>
        /// <param name="platformType"></param>
        /// <param name="xuid"></param>
        /// <returns></returns>
        //public new Dictionary<string, string> GetHttpHeaders(string eTag)
        //{
        //    Dictionary<string, string> httpHeaders = base.GetHttpHeaders();
        //    if (eTag != null)
        //        httpHeaders.Add("If-None-Match", eTag);
        //    return httpHeaders;
        //}

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public List<Notification> GetNotifications()
        {
            return GetNotifications(null, null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="gameId"></param>
        /// <param name="sessionId"></param>
        /// <returns></returns>
        public List<Notification> GetNotifications(string gameId, string sessionId)
        {
            return GetNotifications(gameId, sessionId, 0, null, 100, null, false, null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="gameId"></param>
        /// <param name="sessionId"></param>
        /// <param name="category"></param>
        /// <param name="lastId"></param>
        /// <param name="count"></param>
        /// <param name="typeString"></param>
        /// <param name="userVisibleOnly"></param>
        /// <param name="cert"></param>
        /// <returns></returns>
        public List<Notification> GetNotifications(
            string gameId,
            string sessionId,
            int category,
            string lastId,
            int count,
            string typeString,
            bool userVisibleOnly,
            X509Certificate2 cert)
        {
            return GetNotifications(GetHttpHeaders(),
                gameId,
                sessionId,
                category,
                lastId,
                count,
                typeString,
                userVisibleOnly,
                cert);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="httpHeaders"></param>
        /// <param name="gameId"></param>
        /// <param name="sessionId"></param>
        /// <param name="category"></param>
        /// <param name="lastId"></param>
        /// <param name="count"></param>
        /// <param name="typeString"></param>
        /// <param name="userVisibleOnly"></param>
        /// <param name="cert"></param>
        /// <returns></returns>
        public List<Notification> GetNotifications(
            Dictionary<string, string> httpHeaders,
            string gameId,
            string sessionId,
            int category,
            string lastId,
            int count,
            string typeString,
            bool userVisibleOnly,
            X509Certificate2 cert)
        {
            string url = String.Format("{0}/?game={1}&session={2}&category={3}&last={4}&count={5}&type={6}&userVisibleOnly={7}",
                this.BaseUri,
                gameId,
                sessionId,
                category,
                lastId,
                count,
                typeString,
                userVisibleOnly);

            RestResponse response = Get(url, httpHeaders, cert);
            if (response.Headers.ContainsKey("ETag"))
            {
                this.EtagInResponse = response.Headers["ETag"];
            }
            else
                this.EtagInResponse = null;

            if (!response.Succeeded)
            {
                throw new RestException(response);
            }
            return DeserializeObject<NotificationList>(response.Body);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="httpHeaders"></param>
        /// <param name="notificationId"></param>
        /// <param name="status"></param>
        /// <param name="cert"></param>
        public void UpdateNotification(
            Dictionary<string, string> httpHeaders,
            string notificationId,
            string status,
            X509Certificate2 cert)
        {
            string uri = String.Format("{0}update/?notification={1}&status={2}",
                this.BaseUri,
                notificationId,
                status);

            RestResponse rr = Put(uri, httpHeaders, null, cert);

            if (!rr.Succeeded)
            {
                throw new RestException(rr);
            }
        }

        public void DeleteNotificationQuery(
            Dictionary<string, string> customHeaders,
            string notificationId,
            X509Certificate2 cert)
        {
            string uri = String.Format("{0}delete/?notification={1}",
                this.BaseUri,
                notificationId);

            RestResponse rr = Delete(uri, customHeaders, cert);
            if (!rr.Succeeded)
            {
                throw new RestException(rr);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="customHeaders"></param>
        /// <param name="gameIdString"></param>
        /// <param name="sessionId"></param>
        /// <param name="cert"></param>
        public void DeleteNotificationBySession(
            Dictionary<string, string> customHeaders,
            string gameIdString,
            string sessionId,
            X509Certificate2 cert)
        {

            string uri = String.Format("{0}deletesession/?game={1}&session={2}",
                this.BaseUri,
                gameIdString,
                sessionId);

            RestResponse rr = Delete(uri, customHeaders, cert);
            if (!rr.Succeeded)
            {
                throw new RestException(rr);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="request"></param>
        public void SendInvite(InviteRequest request)
        {
            SendInvite(request, null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="request"></param>
        /// <param name="cert"></param>
        public void SendInvite(InviteRequest request, X509Certificate2 cert)
        {
            SendInvite(GetHttpHeaders(), request, cert);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="customHeaders"></param>
        /// <param name="request"></param>
        /// <param name="cert"></param>
        public void SendInvite(
            Dictionary<string, string> customHeaders,
            InviteRequest request,
            X509Certificate2 cert)
        {
            string uri = String.Format("{0}/invite/", this.BaseUri);
            RestResponse rr = Post(uri, customHeaders, SerializeObject(request), cert);

            if (!rr.Succeeded)
            {
                throw new RestException(rr);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public List<Spotlight> GetSpotlight()
        {
            return GetSpotlight(null);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="carrierString"></param>
        /// <returns></returns>
        public List<Spotlight> GetSpotlight(string carrierString)
        {
            return GetSpotlight(GetHttpHeaders(), carrierString);
        }

        /// <summary>
        ///  
        /// </summary>
        /// <param name="customHeaders"></param>
        /// <param name="carrierString"></param>
        /// <returns></returns>
        public List<Spotlight> GetSpotlight(
            Dictionary<string, string> customHeaders,
            string carrierString)
        {
            string uri = String.Format("{0}/Spotlight/", this.BaseUri);

            if (carrierString != null)
            {
                uri += String.Format("?carrier={0}/", carrierString);
            }

            RestResponse rr = Get(uri, customHeaders);

            if (rr.Headers.ContainsKey("ETag"))
            {
                // If you query for Spotlight with an unsupported language+locale combination you don't get an ETag back
                this.EtagInResponse = rr.Headers["ETag"];
            }
            else
            {
                this.EtagInResponse = null;
            }

            if (!rr.Succeeded)
            {
                throw new RestException(rr);
            }

            if (string.IsNullOrEmpty(rr.Body))
            {
                return null;
            }
            else
                return new List<Spotlight>(DeserializeObject<Spotlight[]>(rr.Body));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\Multiplayer\NotificationsUtil.cs ===
﻿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using AsyncMultiplayer.NotificationService;
using LiveN.Test.Common;
using LiveN.Test.Services;

namespace LiveN.Test.Services.Multiplayer
{
    /// <summary>
    /// 
    /// </summary>
    public class NotificationsUtil: ServiceBaseUtil
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stsUrl"></param>
        /// <param name="clientCertSubject"></param>
        /// <param name="liveIdServiceTarget"></param>
        /// <param name="policy"></param>
        /// <param name="environment"></param>
        public NotificationsUtil(string notificationsUrl, string stsUrl, string clientCertSubject, string liveIdServiceTarget, string policy, string environment, string titleId, string titleVersion, string platformType, string clientVersion): base(stsUrl, clientCertSubject, liveIdServiceTarget, policy, environment, titleId, titleVersion, platformType, clientVersion)
        {
            this.NotificationsUrl = new Uri(notificationsUrl);
        }

        /// <summary>
        /// 
        /// </summary>
        public Uri NotificationsUrl
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="memberName"></param>
        /// <param name="password"></param>
        /// <param name="sessionId"></param>
        /// <param name="inviteEmailTo"></param>
        /// <returns></returns>
        public Result<bool> SendInvite(string memberName, string password, string sessionId, string inviteEmailTo)
        {
            Result<bool> result = new Result<bool>();
            
            try
            {
                TraceEx.TraceStart("Sending game invite(s) from {0} to {1}...", memberName, inviteEmailTo);
                string userToken = AuthorizationCache.GetUserToken(
                                                            memberName,
                                                            password,
                                                            this.LiveIdServiceTarget,
                                                            this.Policy,
                                                            this.Environment,
                                                            this.PlatformType,
                                                            this.TitleId,
                                                            this.TitleVersion,
                                                            this.ClientVersion);
                NotificationsService notificationsProxy = GetNotificationsProxy(this.NotificationsUrl.ToString(), userToken);
                InviteRequest invite = new InviteRequest()
                {
                    GameId = uint.Parse(this.TitleId),
                    Recipients = inviteEmailTo,
                    SessionId = sessionId
                };

                result.Start();
                notificationsProxy.SendInvite(invite);
                result.ReturnValue = result.Passed = true;
                Trace.TraceInformation("Successfully sent game invite to {0}.", inviteEmailTo);
            }
            catch (Exception e)
            {
                result.Error = e;
                TraceError(ServiceError.SendInvite, e, "Error sending game invite");
            }
            finally
            {
                result.Stop();
                TraceEx.TraceStop("Completed sending of game invite(s).  Took {0}ms.", result.Latency.TotalMilliseconds);
            }

            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="memberName"></param>
        /// <param name="password"></param>
        /// <returns></returns>
        public Result<List<Notification>> GetNotifications(string memberName, string password)
        {
            Result<List<Notification>> result = new Result<List<Notification>>();
            
            try
            {
                TraceEx.TraceStart("Attempting to get notifications for {0}...", memberName);                
                string userToken = AuthorizationCache.GetUserToken(
                                                            memberName,
                                                            password,
                                                            this.LiveIdServiceTarget,
                                                            this.Policy,
                                                            this.Environment,
                                                            this.PlatformType,
                                                            this.TitleId,
                                                            this.TitleVersion,
                                                            this.ClientVersion);
                NotificationsService notificationsProxy = GetNotificationsProxy(this.NotificationsUrl.ToString(), userToken);
                result.Start();
                result.ReturnValue = notificationsProxy.GetNotifications();
                result.Passed = true;

                StringBuilder trace = new StringBuilder(String.Format("Current Notifications for {0}:\r\n\t", memberName));
                for (int i = 0; i < result.ReturnValue.Count; i++)
                {
                    trace.AppendFormat(
                        "Type:\t{0} ({1})\r\n\tFrom:\t{2}\r\n\tStatus:\t\t{3}\r\n\tGame ID:\t{4} ({5})\r\n\tSession ID:\t{6}\r\n\tUrl:\t{7}\r\n\tSent:\t\t{8}\r\n\tDelivered:\t{9}\r\n\r\n\t",
                        result.ReturnValue[i].Type,
                        result.ReturnValue[i].TypeDisplayName,
                        result.ReturnValue[i].From,
                        result.ReturnValue[i].Status,
                        result.ReturnValue[i].GameId,
                        result.ReturnValue[i].GameDisplayName,
                        result.ReturnValue[i].SessionId,
                        result.ReturnValue[i].Url,
                        result.ReturnValue[i].SentTime,
                        result.ReturnValue[i].DeliveredTime);
                }

                TraceEx.TraceVerbose(trace.ToString());
                Trace.TraceInformation("Successfully got notifications for {0}.", memberName);
            }
            catch (Exception e)
            {
                result.Error = e;
                TraceError(ServiceError.GetNotifications, e, "Error getting notifications");
            }
            finally
            {
                result.Stop();
                TraceEx.TraceStop("Completed getting notifications.  Took {0}ms.", result.Latency.TotalMilliseconds);
            }

            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="memberName"></param>
        /// <param name="password"></param>
        /// <returns></returns>
        public Result<List<Spotlight>> GetSpotlight(string memberName, string password)
        {
            Result<List<Spotlight>> result = new Result<List<Spotlight>>();
            
            try
            {
                TraceEx.TraceStart("Attempting to get spotlight...");
                string userToken = AuthorizationCache.GetUserToken(
                                                            memberName,
                                                            password,
                                                            this.LiveIdServiceTarget,
                                                            this.Policy,
                                                            this.Environment,
                                                            this.PlatformType,
                                                            this.TitleId,
                                                            this.TitleVersion,
                                                            this.ClientVersion);
                NotificationsService notificationsProxy = GetNotificationsProxy(this.NotificationsUrl.ToString(), userToken);
                result.Start();
                result.ReturnValue = notificationsProxy.GetSpotlight();
                result.Passed = true;

                StringBuilder trace = new StringBuilder("Current SpotLight Entries:\r\n\t");
                for (int i = 0; i < result.ReturnValue.Count; i++)
                {
                    trace.AppendFormat(
                           "Title:\t\t{0}\r\n\tSubtitle:\t{1}\r\n\tGame ID:\t{2}\r\n\tUrl:\t\t{3}\r\n\r\n\t",
                           result.ReturnValue[i].Title,
                           result.ReturnValue[i].Subtitle,
                           result.ReturnValue[i].GameId,
                           result.ReturnValue[i].Url);
                }

                TraceEx.TraceVerbose(trace.ToString());
                Trace.TraceInformation("Successfully got spotlight.");
            }
            catch (Exception e)
            {
                TraceError(ServiceError.GetSpotlight, e, "Error getting spotlight entries");
            }
            finally
            {
                result.Stop();
                TraceEx.TraceStop("Completed get spotlight.  Took {0}ms.", result.Latency.TotalMilliseconds);
            }

            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="userToken"></param>
        /// <returns></returns>
        private static NotificationsService GetNotificationsProxy(string url, string userToken)
        {
            return GetNotificationsProxy(url, "en-US", ((int)Leet.Core.Platforms.PlatformType.Mobile).ToString(), userToken);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="locale"></param>
        /// <param name="platformType"></param>
        /// <param name="partnerToken"></param>
        /// <returns></returns>
        private static NotificationsService GetNotificationsProxy(string url, string locale, string platformType, string partnerToken)
        {
            NotificationsService notificationsService = new NotificationsService(url);
            notificationsService.Locale = locale;
            notificationsService.PlatformType = platformType;
            notificationsService.UserAuthorizationToken = partnerToken;
            return notificationsService;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\Multiplayer\SpotlightMonitoringBlock.cs ===
﻿using System;
using System.Collections.Generic;
using AsyncMultiplayer.NotificationService;

namespace LiveN.Test.Services.Multiplayer
{
    /// <summary>
    /// 
    /// </summary>
    public class SpotlightMonitoringBlock: MonitoringBlock
    {
        private NotificationsUtil notificationUtil;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="environment"></param>
        public SpotlightMonitoringBlock(string environment)
            : base(environment)
        {
            //NOTE: need to create an instance of NotificationsUtil (or dervied class)
            //      to be able to use the static Auth cache
            this.notificationUtil = new NotificationsUtil(               
                this.Environment.NotificationsService.ToString(),
                this.Environment.StsSettings.StsUrl,
                this.Environment.StsSettings.ClientCertSubject,
                this.Environment.WindowsLiveIDSettings.LiveIdServiceTarget,
                this.Environment.WindowsLiveIDSettings.Policy,
                this.Environment.WindowsLiveIDSettings.Environment,
                this.Environment.StsSettings.TitleId,
                this.Environment.StsSettings.TitleVersion,
                this.Environment.StsSettings.PlatformType,
                this.Environment.StsSettings.ClientVersion);
        }

        /// <summary>
        /// 
        /// </summary>
        public override string Name
        {
            get { return "Spotlight"; }
        }

        /// <summary>
        /// 
        /// </summary>
        public override string FullName
        {
            get { return "Spotlight"; }
        }

        /// <summary>
        /// 
        /// </summary>
        public override int Priority
        {
            get
            {
                return 5;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public override List<TestInfo> GetTestNames()
        {
            return GetMonitoringTests();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public override List<IResult> RunTests()
        {
            List<IResult> results = new List<IResult>();

            string player1 = this.Environment.UserSettings[0].Membername;
            string player1Password = this.Environment.UserSettings[0].Password;

            results.Add(GetSpotlight(player1, player1Password));
            return results;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="username"></param>
        /// <param name="password"></param>
        /// <param name="sessionId"></param>
        /// <param name="emailAddresses"></param>
        /// <returns></returns>
        [MonitoringTest(Name = "GetSpotlight", Id = "B8680ABD-5A2C-4804-A1A4-E7635D7786C2")]
        private Result<List<Spotlight>> GetSpotlight(string username, string password)
        {
            Result<List<Spotlight>> result = new Result<List<Spotlight>>();
            TestInfo testInfo = GetTestInfo();

            try
            {
                StartTest(testInfo);
                result = this.notificationUtil.GetSpotlight(
                        username,
                        password);
            }
            finally
            {
                EndTest(testInfo, result);
            }

            return result;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\Multiplayer\SessionService.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using AsyncMultiplayer.SessionCommon;
using LiveN.Test.Common.Web;
using LiveN.Test.Framework.Web;

namespace LiveN.Test.Services.Multiplayer
{
    /// <summary>
    /// 
    /// </summary>
    public enum SessionServiceError: uint
    {
        TooManySessionsCreatedByTheUser = 2148082595,
    }

    /// <summary>
    /// 
    /// </summary>
    public class SessionService : XboxWcfService
    {
        public const string CreateSessionUrlFormat = "/game/{gameId}";
        public const string JoinSessionUrlFormat = "/session/{sessionId}";

        /// <summary>
        /// 
        /// </summary>
        /// <param name="baseUri"></param>
        public SessionService(string baseUri): base(baseUri)
        {
            
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="gameId"></param>
        /// <returns></returns>
        public string FormatCreateSessionUrl(string gameId)
        {
            return this.BaseUri + CreateSessionUrlFormat.Replace("{gameId}", gameId);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="sessionId"></param>
        /// <returns></returns>
        public string FormatJoinSessionUrl(string sessionId)
        {
            return this.BaseUri + JoinSessionUrlFormat.Replace("{sessionId}", sessionId);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="creationData"></param>
        /// <returns></returns>
        public SessionState CreateSession(CreationData creationData)
        {
            return CreateSession(GetHttpHeaders(), creationData.GameID.ToString(), creationData);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="httpHeaders"></param>
        /// <param name="creationData"></param>
        public SessionState CreateSession(Dictionary<string, string> httpHeaders, CreationData creationData)
        {
            return CreateSession(httpHeaders, creationData.GameID.ToString(), creationData);
        }


        /// <summary>
        /// 
        /// </summary>
        /// <param name="gameId"></param>
        /// <param name="creationData"></param>
        public SessionState CreateSession(string gameId, CreationData creationData)
        {
            return CreateSession(GetHttpHeaders(), gameId, creationData);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="httpHeaders"></param>
        /// <param name="gameId"></param>
        /// <param name="creationData"></param>
        public SessionState CreateSession(Dictionary<string, string> httpHeaders, string gameId, CreationData creationData)
        {
            string url = FormatCreateSessionUrl(gameId);

            RestResponse response = Post(url, httpHeaders, SerializeObject(creationData));
            HandleResponse(response);

            return DeserializeObject<SessionState>(response.Body);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="sessionId"></param>
        /// <param name="joinData"></param>
        /// <returns></returns>
        public SessionState JoinSession(string sessionId, JoinData joinData)
        {
            return JoinSession(GetHttpHeaders(), sessionId, joinData);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="httpHeaders"></param>
        /// <param name="sessionId"></param>
        /// <param name="joinData"></param>
        public SessionState JoinSession(Dictionary<string, string> httpHeaders, string sessionId, JoinData joinData)
        {
            string url = FormatJoinSessionUrl(sessionId);

            RestResponse response = Post(url, httpHeaders, SerializeObject(joinData));
            HandleResponse(response);

            return DeserializeObject<SessionState>(response.Body);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="sessionId"></param>
        /// <param name="gameId"></param>
        public void RejectInvitation(string sessionId, string gameId)
        {
            RejectInvitation(GetHttpHeaders(), sessionId, gameId);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="sessionId"></param>
        /// <param name="gameId"></param>
        public void RejectInvitation(Dictionary<string, string> httpHeaders, string sessionId, string gameId)
        {
            string url = String.Format("{0}/invite/{1}/{2}", this.BaseUri, sessionId, gameId);

            RestResponse response = Delete(url, httpHeaders);
            HandleResponse(response);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="sessionId"></param>
        /// <param name="gameId"></param>
        public void LeaveSession(string sessionId, string gameId)
        {
            LeaveSession(GetHttpHeaders(), sessionId, gameId);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="sessionId"></param>
        /// <param name="gameId"></param>
        public void LeaveSession(Dictionary<string, string> httpHeaders, string sessionId, string gameId)
        {
            string url = String.Format("{0}/session/{1}/{2}", this.BaseUri, sessionId, gameId);

            RestResponse response = Delete(url, httpHeaders);
            HandleResponse(response);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="sessionId"></param>
        /// <param name="gameId"></param>
        /// <param name="modData"></param>
        public void ModifySession(string sessionId, string gameId, ModificationData modData)
        {
            ModifySession(GetHttpHeaders(), sessionId, gameId, modData);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="httpHeaders"></param>
        /// <param name="sessionId"></param>
        /// <param name="gameId"></param>
        /// <param name="modData"></param>
        public void ModifySession(Dictionary<string, string> httpHeaders, string sessionId, string gameId, ModificationData modData)
        {
            string url = String.Format("{0}/session/{1}/{2}", this.BaseUri, sessionId, gameId);

            RestResponse response = Put(url, httpHeaders, SerializeObject(modData));
            HandleResponse(response);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="sessionId"></param>
        /// <param name="gameId"></param>
        /// <returns></returns>
        public SessionState ViewSession(string sessionId, string gameId)
        {
            return ViewSession(GetHttpHeaders(), sessionId, gameId);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="httpHeaders"></param>
        /// <param name="sessionId"></param>
        /// <param name="gameId"></param>
        /// <returns></returns>
        public SessionState ViewSession(Dictionary<string, string> httpHeaders, string sessionId, string gameId)
        {
            string url = String.Format("{0}/session/{1}/{2}", this.BaseUri, sessionId, gameId);

            RestResponse response = Get(url, httpHeaders);
            HandleResponse(response);

            return DeserializeObject<SessionState>(response.Body);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="gameId"></param>
        /// <param name="firstSession"></param>
        /// <param name="max"></param>
        /// <param name="sessionType"></param>
        /// <returns></returns>
        public SessionEntry[] ViewSessionSummaries(string gameId, string variant, string lastSessionID, string lastGameID, string maxSessions, string showSessionType)
        {
            return ViewSessionSummaries(GetHttpHeaders(), gameId, variant, lastSessionID, lastGameID, maxSessions, showSessionType);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="gameId"></param>
        /// <param name="firstSession"></param>
        /// <param name="max"></param>
        /// <param name="sessionType"></param>
        /// <returns></returns>
        public SessionEntry[] ViewSessionSummaries(string gameId, string variant, string lastSessionID, string lastGameID, int maxSessions, ShowSessionType showSessionType)
        {
            return ViewSessionSummaries(GetHttpHeaders(), gameId, variant, lastSessionID, lastGameID, maxSessions, showSessionType);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="httpHeaders"></param>
        /// <param name="gameId"></param>
        /// <param name="firstSession"></param>
        /// <param name="max"></param>
        /// <param name="sessionType"></param>
        /// <returns></returns>
        public SessionEntry[] ViewSessionSummaries(Dictionary<string, string> httpHeaders, string gameId, string variant, string lastSessionID, string lastGameID, int maxSessions, ShowSessionType showSessionType)
        {
            return ViewSessionSummaries(httpHeaders, gameId, variant, lastSessionID, lastGameID, maxSessions.ToString(), showSessionType.ToString());
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="httpHeaders"></param>
        /// <param name="gameId"></param>
        /// <param name="firstSession"></param>
        /// <param name="max"></param>
        /// <param name="sessionType"></param>
        /// <returns></returns>
        public SessionEntry[] ViewSessionSummaries(Dictionary<string, string> httpHeaders, string gameId, string variant, string lastSessionID, string lastGameID, string maxSessions, string showSessionType)
        {
            StringBuilder url = new StringBuilder(String.Format("{0}/game?", this.BaseUri));
            Dictionary<string, string> queryStringParams = new Dictionary<string, string>();

            if (gameId != null)
                queryStringParams.Add("game", gameId);
            if (variant != null)
                queryStringParams.Add("variant", variant);
            if (lastSessionID != null)
                queryStringParams.Add("lastSession", lastSessionID);
            if (lastGameID != null)
                queryStringParams.Add("lastGame", lastGameID);
            if (maxSessions != null)
                queryStringParams.Add("max", maxSessions);
            if (showSessionType != null)
                queryStringParams.Add("showSessionType", showSessionType);

            foreach (string key in queryStringParams.Keys)
            {
                url.AppendFormat("{0}={1}&", key, queryStringParams[key]);
            }

            url.Length -= 1;    //strip off the last & (or ?)

            RestResponse response = Get(url.ToString(), httpHeaders);
            HandleResponse(response);

            return DeserializeObject<SessionEntry[]>(response.Body);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\Rewards\LeaderboardMonitoringBlock.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using LiveN.Test.Services.Rewards;
using Rewards.Contracts;
using LiveN.Test.Common;

namespace LiveN.Test.Services.Multiplayer
{
    /// <summary>
    /// 
    /// </summary>
    public class LeaderboardMonitoringBlock : MonitoringBlock
    {
        private UDSUtil udsUtil = null;
        private RewardsUtil rewardsUtil = null;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="environment"></param>
        public LeaderboardMonitoringBlock(string environment)
            : base(environment)
        {
            udsUtil = new UDSUtil(
                      this.Environment.UDSProfileService.ToString(),
                      this.Environment.UDSGameDataService.ToString(),
                      this.Environment.StsSettings.StsUrl,
                      this.Environment.StsSettings.ClientCertSubject,
                      this.Environment.WindowsLiveIDSettings.LiveIdServiceTarget,
                      this.Environment.WindowsLiveIDSettings.Policy,
                      this.Environment.WindowsLiveIDSettings.Environment,
                      this.Environment.StsSettings.TitleId3,
                      this.Environment.StsSettings.TitleVersion3,
                      this.Environment.StsSettings.PlatformType,
                      this.Environment.StsSettings.ClientVersion);

            rewardsUtil = new RewardsUtil(
                   this.Environment.RewardsService.ToString(),
                   this.Environment.StsSettings.StsUrl,
                   this.Environment.StsSettings.ClientCertSubject,
                   this.Environment.WindowsLiveIDSettings.LiveIdServiceTarget,
                   this.Environment.WindowsLiveIDSettings.Policy,
                   this.Environment.WindowsLiveIDSettings.Environment,
                   this.Environment.StsSettings.TitleId3,
                   this.Environment.StsSettings.TitleVersion3,
                   this.Environment.StsSettings.PlatformType,
                   this.Environment.StsSettings.ClientVersion);          
            
        }

        
        /// <summary>
        /// 
        /// </summary>
        public override string Name
        {
            get { return "Leaderboard"; }
        }

        /// <summary>
        /// 
        /// </summary>
        public override string FullName
        {
            get { return "Leaderboard"; }
        }

        /// <summary>
        /// 
        /// </summary>
        public override int Priority
        {
            get
            {
                return 4;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public override List<TestInfo> GetTestNames()
        {
            return GetMonitoringTests();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public override List<IResult> RunTests()
        {
            List<IResult> results = new List<IResult>();

            string player1 = this.Environment.UserSettings[0].Membername;
            string player1Password = this.Environment.UserSettings[0].Password;
            string player1Gamertag = this.Environment.UserSettings[0].GamerTag;

            

            int initialGamesPlayed = 0;
            // Setting this so that it does not match the initialGamesPlayed; otherwise it would be possible to run this test and nothing happen and it would pass.
            int finalGamesPlayed = int.MaxValue;
            int increment = 1;

            results.Add(PostGameResult(player1, player1Password));
            if (results[0].Passed == false) { return results; }

            Result<LeaderboardResult> leaderboardResult1 = GetLeaderboard(player1, player1Password);
            if (leaderboardResult1.Passed == false) { return results; }
            try
            {
                foreach (LeaderboardItem item in leaderboardResult1.ReturnValue.Leaderboard)
                {
                    if (item.User.GamerTag.ToLower() == player1Gamertag.ToLower())
                    {
                        initialGamesPlayed = int.Parse(FindLeaderboardEntry(item, "GamesPlayed"));
                        break;
                    }
                }
            }
            catch (Exception)
            {
                Result<bool> gameCheck = new Result<bool>();
                gameCheck.Passed = false;
                gameCheck.Error = new Exception("GamesPlayed stat was not returned.");
                results.Add(gameCheck);
                return results;
            }
            results.Add(leaderboardResult1);
            results.Add(VerifyInitialGamesPlayedCount(initialGamesPlayed));

            results.Add(PostGameResult(player1, player1Password));
            if (results[3].Passed == false) { return results; }

            Result<LeaderboardResult> leaderboardResult2 = GetLeaderboard(player1, player1Password);

            foreach (LeaderboardItem item in leaderboardResult2.ReturnValue.Leaderboard) 
            {
                if (item.User.GamerTag.ToLower() == player1Gamertag.ToLower())
                {
                    finalGamesPlayed = int.Parse(FindLeaderboardEntry(item, "GamesPlayed"));
                    break;
                }
            }

                        
            results.Add(leaderboardResult2);
            results.Add(VerifyFinalGamesPlayedCount((initialGamesPlayed + increment), finalGamesPlayed));

            return results;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="username"></param>
        /// <param name="password"></param>
        /// <returns></returns>
        [MonitoringTest(Name = "PostGameResult", Id = "B86AAABD-5A2C-4804-A1A4-E7635D7786C2")]
        private Result<bool> PostGameResult(string username, string password)
        {
            Result<bool> result = new Result<bool>();
            TestInfo testInfo = GetTestInfo();

            try
            {
                StartTest(testInfo);

                GameResult gameRes = CreateGameResult(Convert.ToUInt32(this.Environment.StsSettings.TitleId3),
                                                     Guid.NewGuid(),
                                                     DateTime.Now,
                                                     0,
                                                     0,
                                                     "Win",
                                                     "blob",
                                                     0);

                result = rewardsUtil.RewardsServiceUtil.PostGameResult(username, password, gameRes);

                System.Threading.Thread.Sleep(1500);


            }
            finally
            {
                EndTest(testInfo, result);
            }

            return result;
        }

        [MonitoringTest(Name = "GetLeaderboard", Id = "C86AAABD-5A2C-4804-A1A4-E7635D7786C2")]
        private Result<LeaderboardResult> GetLeaderboard(string username, string password)
        {
            Result<LeaderboardResult> result = new Result<LeaderboardResult>();
            TestInfo testInfo = GetTestInfo();

            try
            {
                StartTest(testInfo);

                result = udsUtil.GameDataUtil.GetLeaderboard(username, password, this.Environment.StsSettings.TitleId3, "0", "BestScore", "Lifetime", "50", "1", "2");

            }
            finally
            {
                EndTest(testInfo, result);
            }

            return result;
        }

        [MonitoringTest(Name = "VerifyInitialGamesPlayedCount", Id = "C86AAABD-5A2C-4804-A1A4-E7635D7786A2")]
        private Result<bool> VerifyInitialGamesPlayedCount(int count)
        {
            Result<bool> result = new Result<bool>();
            TestInfo testInfo = GetTestInfo();

            try
            {
                StartTest(testInfo);

                TraceEx.TraceVerbose("Verifying games played count > 0: Count = {0}.", count);

                if (count > 0)
                {
                    result.Passed = true;
                    result.ReturnValue = true;
                }
                else
                {
                    result.Passed = false;
                    result.ReturnValue = false;
                    result.Error = new Exception("Games played was not updated. Verify RulesService and RewardsTargetQueue are up");
                }

            }
            finally
            {
                EndTest(testInfo, result);
            }

            return result;
        }

        [MonitoringTest(Name = "VerifyFinalGamesPlayedCount", Id = "C86ADFABD-5A2C-4804-A1A4-E7635D7786A2")]
        private Result<bool> VerifyFinalGamesPlayedCount(int expectedCount, int actualCount)
        {
            Result<bool> result = new Result<bool>();
            TestInfo testInfo = GetTestInfo();

            try
            {
                StartTest(testInfo);
                TraceEx.TraceVerbose(string.Format("Verifying games played count in LeaderboardResult: Expected = {0}, Actual = {1}", expectedCount, actualCount));

                if (expectedCount >= actualCount)
                {
                    result.Passed = true;
                    result.ReturnValue = true;
                }
                else
                {
                    result.Passed = false;
                    result.ReturnValue = false;
                    result.Error = new Exception("Games played was not updated. Verify RulesService and RewardsTargetQueue are up"); 
                }

            }
            finally
            {
                EndTest(testInfo, result);
            }

            return result;
        }

        private GameResult CreateGameResult(uint gameId, Guid gameResultId, DateTime timeStamp, long score, long time, string outcome, string blob, uint variant)
        {
            GameResult gameResult = new GameResult();
            gameResult.GameId = gameId;
            gameResult.GameResultId = gameResultId;
            gameResult.TimeStamp = timeStamp;
            gameResult.Score = score;
            gameResult.Time = time;
            gameResult.Outcome = outcome;
            gameResult.Blob = Encoding.UTF8.GetBytes(blob);
            gameResult.Variant = variant;

            return gameResult;
        }

        private string FindLeaderboardEntry(LeaderboardItem item, string statEntry)
        {
            string result = (from i in item.Statistics
                             where i.Name.ToLower() == statEntry.ToLower()
                             select i.Value).First();
            return result;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\Rewards\RewardsMonitoringBlock.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using LiveN.Test.Services.Rewards;
using Rewards.Contracts;
using LiveN.Test.Common;

namespace LiveN.Test.Services.Multiplayer
{
    /// <summary>
    /// 
    /// </summary>
    public class RewardsMonitoringBlock : MonitoringBlock
    {
        private UDSUtil udsUtil = null;
        private RewardsUtil rewardsUtil = null;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="environment"></param>
        public RewardsMonitoringBlock(string environment)
            : base(environment)
        {
            udsUtil = new UDSUtil(
                      this.Environment.UDSProfileService.ToString(),
                      this.Environment.UDSGameDataService.ToString(),
                      this.Environment.StsSettings.StsUrl,
                      this.Environment.StsSettings.ClientCertSubject,
                      this.Environment.WindowsLiveIDSettings.LiveIdServiceTarget,
                      this.Environment.WindowsLiveIDSettings.Policy,
                      this.Environment.WindowsLiveIDSettings.Environment,
                      this.Environment.StsSettings.TitleId3,
                      this.Environment.StsSettings.TitleVersion3,
                      this.Environment.StsSettings.PlatformType,
                      this.Environment.StsSettings.ClientVersion);

            rewardsUtil = new RewardsUtil(
                   this.Environment.RewardsService.ToString(),
                   this.Environment.StsSettings.StsUrl,
                   this.Environment.StsSettings.ClientCertSubject,
                   this.Environment.WindowsLiveIDSettings.LiveIdServiceTarget,
                   this.Environment.WindowsLiveIDSettings.Policy,
                   this.Environment.WindowsLiveIDSettings.Environment,
                   this.Environment.StsSettings.TitleId3,
                   this.Environment.StsSettings.TitleVersion3,
                   this.Environment.StsSettings.PlatformType,
                   this.Environment.StsSettings.ClientVersion);
        }

        /// <summary>
        /// 
        /// </summary>
        public override string Name
        {
            get { return "Rewards"; }
        }

        /// <summary>
        /// 
        /// </summary>
        public override string FullName
        {
            get { return "Rewards"; }
        }

        /// <summary>
        /// 
        /// </summary>
        public override int Priority
        {
            get
            {
                return 3;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public override List<TestInfo> GetTestNames()
        {
            return GetMonitoringTests();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public override List<IResult> RunTests()
        {
            List<IResult> results = new List<IResult>();

            string player1 = this.Environment.UserSettings[0].Membername;
            string player1Password = this.Environment.UserSettings[0].Password;

            //GrantAchievements
            results.Add(GrantAchievements(player1, player1Password));
            if (results[0].Passed == false) { return results; }

            return results;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="username"></param>
        /// <param name="password"></param>
        /// <returns></returns>
        [MonitoringTest(Name = "GrantAchievements", Id = "B86AB4BD-5A2C-4804-A1A4-E7635D7786C2")]
        private Result<bool> GrantAchievements(string username, string password)
        {
            Result<bool> result = new Result<bool>();
            TestInfo testInfo = GetTestInfo();

            try
            {
                StartTest(testInfo);

                Result<AchievementsResult> achievements = udsUtil.GameDataUtil.GetAchievements(username, password, this.Environment.StsSettings.TitleId3);

                AchievementEarned grantMe = CreateAchievement(achievements.ReturnValue.Achievements[0].Key, DateTime.Now, true);

                GrantAchievements grantAchievements = new GrantAchievements();
                grantAchievements.GameId = Convert.ToUInt32(this.Environment.StsSettings.TitleId3);
                grantAchievements.AppId = "c203973c-fd2b-4b8c-b785-5e38b3e35dec"; //Flowerz App ID
                grantAchievements.Achievements = new List<AchievementEarned>();

                grantAchievements.Achievements.Add(grantMe);

                result = rewardsUtil.RewardsServiceUtil.GrantAchievements(username, password, grantAchievements);

            }
            finally
            {
                EndTest(testInfo, result);
            }

            return result;
        }

        private GameResult CreateGameResult(uint gameId, Guid gameResultId, DateTime timeStamp, long score, long time, string outcome, string blob, uint variant)
        {
            GameResult gameResult = new GameResult();
            gameResult.GameId = gameId;
            gameResult.GameResultId = gameResultId;
            gameResult.TimeStamp = timeStamp;
            gameResult.Score = score;
            gameResult.Time = time;
            gameResult.Outcome = outcome;
            gameResult.Blob = Encoding.UTF8.GetBytes(blob);
            gameResult.Variant = variant;

            return gameResult;
        }

        /// <summary>
        /// Create an achievement to be added to an achievement list.
        /// </summary>
        /// <param name="key">achievement ID</param>
        /// <param name="earnedDateTime">DateTime the achievement was earned</param>
        /// <param name="earnedOnline">True if the player was online when the achievement was earned, false otherwise</param>
        /// <returns></returns>
        public AchievementEarned CreateAchievement(string key, DateTime earnedDateTime, bool earnedOnline)
        {
            AchievementEarned achievementEarned = new AchievementEarned();
            achievementEarned.Key = key;
            achievementEarned.EarnedDateTime = earnedDateTime;
            achievementEarned.EarnedOnline = earnedOnline;
            return achievementEarned;
        }

        private string FindLeaderboardEntry(LeaderboardItem item, string statEntry)
        {
            string result = (from i in item.Statistics
                             where i.Name.ToLower() == statEntry.ToLower()
                             select i.Value).First();
            return result;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\Rewards\RewardsServiceService.cs ===
﻿using System;
using System.Collections.Generic;
using LiveN.Test.Common.Web;
using LiveN.Test.Framework.Web;
using Rewards.Contracts;

namespace LiveN.Test.Services.Rewards
{
    /// <summary>
    /// 
    /// </summary>
    public class RewardsServiceService : XboxWcfService
    {
        // RewardsService path and queries
        public const string PostGameResult_RelativePathAndQuery = "/GameResult?format=xml";
        public const string GrantAchievements_RelativePathAndQuery = "/GrantAchievements?format=xml";

        /// <summary>
        /// 
        /// </summary>
        /// <param name="baseUri"></param>
        public RewardsServiceService(string baseUri)
            : base(baseUri)
        {

        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="sectionFlags"></param>
        /// <param name="friendsSectionFlags"></param>
        /// <param name="gamertag"></param>
        /// <returns></returns>
        public bool PostGameResult(
            GameResult gameResult)
        {
            string url = this.BaseUri + PostGameResult_RelativePathAndQuery;

            RestResponse response = Post(url, GetHttpHeaders(), SerializeObject(gameResult));

            if (!response.Succeeded)
            {
                throw new RestException(response);
            }
            return true;
        }

        public bool GrantAchievements(
            GrantAchievements grantAchievements)
        {
            string url = this.BaseUri + GrantAchievements_RelativePathAndQuery;

            RestResponse response = Post(url, GetHttpHeaders(), SerializeObject(grantAchievements));

            if (!response.Succeeded)
            {
                throw new RestException(response);
            }
            return true;
        }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\Multiplayer\StateService.cs ===
﻿using System.Collections.Generic;
using AsyncMultiplayer.SessionCommon;
using LiveN.Test.Common.Web;
using LiveN.Test.Framework.Web;

namespace LiveN.Test.Services.Multiplayer
{
    /// <summary>
    /// 
    /// </summary>
    public class StateService : XboxWcfService
    {
        public const string GetGameStateUrlFormat = "/GameState/{sessionId}/{gameId}";
        public const string PutGameStateUrlFormat = "/GameState/{sessionId}/{gameId}";
        public const string PostGameEndUrlFormat = "/GameState/{sessionId}/{gameId}";
        public const string PostGameActionUrlFormat = "/GameAction/{sessionId}/{gameId}";

        /// <summary>
        /// 
        /// </summary>
        /// <param name="baseUri"></param>
        public StateService(string baseUri): base(baseUri)
        {
            
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="url"></param>
        /// <param name="sessionId"></param>
        /// <param name="gameId"></param>
        /// <returns></returns>
        public string FormatGameStateUrl(string url, string sessionId, string gameId)
        {
            return this.BaseUri + url.Replace("{sessionId}", sessionId).Replace("{gameId}", gameId);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="sessionId"></param>
        /// <param name="gameId"></param>
        /// <returns></returns>
        public FullGameState GetGameState(string sessionId, string gameId)
        {
            return GetGameState(GetHttpHeaders(), sessionId, gameId);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="httpHeaders"></param>
        /// <param name="sessionId"></param>
        /// <param name="gameId"></param>
        /// <returns></returns>
        public FullGameState GetGameState(Dictionary<string, string> httpHeaders, string sessionId, string gameId)
        {
            string url = FormatGameStateUrl(GetGameStateUrlFormat, sessionId, gameId);
            
            RestResponse response = Get(url, httpHeaders);
            HandleResponse(response);
            
            return DeserializeObject<FullGameState>(response.Body);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="sessionId"></param>
        /// <param name="gameId"></param>
        /// <param name="gameStateData"></param>
        public void PutGameState(string sessionId, string gameId, ModifiableGameState gameStateData)
        {
            PutGameState(GetHttpHeaders(), sessionId, gameId, gameStateData);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="httpHeaders"></param>
        /// <param name="sessionId"></param>
        /// <param name="gameId"></param>
        /// <param name="gameStateData"></param>
        public void PutGameState(Dictionary<string, string> httpHeaders, string sessionId, string gameId, ModifiableGameState gameStateData)
        {
            string url = FormatGameStateUrl(PutGameStateUrlFormat, sessionId, gameId);

            RestResponse response = Put(url, httpHeaders, SerializeObject(gameStateData));
            HandleResponse(response);            
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="sessionId"></param>
        /// <param name="gameId"></param>
        /// <param name="results"></param>
        public void PostGameEnd(string sessionId, string gameId, GameResults results)
        {
            PostGameEnd(GetHttpHeaders(), sessionId, gameId, results);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="httpHeaders"></param>
        /// <param name="sessionId"></param>
        /// <param name="gameId"></param>
        /// <param name="results"></param>
        public void PostGameEnd(Dictionary<string, string> httpHeaders, string sessionId, string gameId, GameResults results)
        {
            string url = FormatGameStateUrl(PostGameEndUrlFormat, sessionId, gameId);

            RestResponse response = Post(url, httpHeaders, SerializeObject(results));
            HandleResponse(response);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="sessionId"></param>
        /// <param name="gameId"></param>
        /// <param name="gameAction"></param>
        public void PostGameAction(string sessionId, string gameId, GameAction gameAction)
        {
            PostGameAction(GetHttpHeaders(), sessionId, gameId, gameAction);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="httpHeaders"></param>
        /// <param name="sessionId"></param>
        /// <param name="gameId"></param>
        /// <param name="gameAction"></param>
        public void PostGameAction(Dictionary<string, string> httpHeaders, string sessionId, string gameId, GameAction gameAction)
        {
            string url = FormatGameStateUrl(PostGameActionUrlFormat, sessionId, gameId);

            RestResponse response = Post(url, httpHeaders, SerializeObject(gameAction));
            HandleResponse(response);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\Rewards\RewardsServiceUtil.cs ===
﻿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using LiveN.Test.Common;
using LiveN.Test.Framework.Authorization;
using LiveN.Test.Services.Multiplayer;
using Rewards.Contracts;
using LiveN.Test.Services;

namespace LiveN.Test.Services.Rewards
{
    /// <summary>
    /// 
    /// </summary>
    public class RewardsServiceUtil: ServiceBaseUtil
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="profileUrl"></param>
        /// <param name="stsUrl"></param>
        /// <param name="clientCertSubject"></param>
        /// <param name="liveIdServiceTarget"></param>
        /// <param name="policy"></param>
        /// <param name="environment"></param>
        /// <param name="titleId"></param>
        /// <param name="titleVersion"></param>
        /// <param name="platformType"></param>
        /// <param name="clientVersion"></param>
        public RewardsServiceUtil(string rewardsUrl, string stsUrl, string clientCertSubject, string liveIdServiceTarget, string policy, string environment, string titleId, string titleVersion, string platformType, string clientVersion)
            : base(stsUrl, clientCertSubject, liveIdServiceTarget, policy, environment, titleId, titleVersion, platformType, clientVersion)
        {
            this.AuthorizationCache = new AuthorizationCache(
                stsUrl,
                clientCertSubject);

            this.RewardsUrl = new Uri(rewardsUrl);
        }

        /// <summary>
        /// 
        /// </summary>
        public Uri RewardsUrl
        {
            get;
            set;
        }

        public new AuthorizationCache AuthorizationCache
        {
            get;
            private set;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="memberName"></param>
        /// <param name="password"></param>
        /// <param name="gameResult"></param>
        /// <returns></returns>
        public Result<bool> PostGameResult(string memberName, string password, GameResult gameResult)
        {
            Result<bool> result = new Result<bool>();
            result.ReturnValue = false;
            result.Passed = false;
            
            try
            {
                TraceEx.TraceStart("Posting game result of user with WLID {0}...", memberName );

                string userToken = GetUserToken(memberName, password);
                RewardsServiceService rewardsProxy = GetRewardsProxy(this.RewardsUrl.ToString(), userToken);

                result.Start();
                rewardsProxy.PostGameResult(gameResult);
                result.ReturnValue = true;
                result.Passed = true;
                Trace.TraceInformation("Successfully posted game result for user with WLID {0}...", memberName );
            }
            catch (Exception e)
            {
                result.Error= e;
                TraceError(ServiceError.Unknown, e, "Error posting game result");
            }
            finally
            {
                result.Stop();
                TraceEx.TraceStop("Completed posting game result.  Took {0}ms.", result.Latency.TotalMilliseconds);
            }

            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="memberName"></param>
        /// <param name="password"></param>
        /// <param name="grantAchievements"></param>
        /// <returns></returns>
        public Result<bool> GrantAchievements(string memberName, string password, GrantAchievements grantAchievements)
        {
            Result<bool> result = new Result<bool>();
            result.ReturnValue = false;

            try
            {
                TraceEx.TraceStart("Granting achievements for user with WLID {0}...", memberName);

                string userToken = GetUserToken(memberName, password);
                RewardsServiceService rewardsProxy = GetRewardsProxy(this.RewardsUrl.ToString(), userToken);

                result.Start();
                result.ReturnValue = rewardsProxy.GrantAchievements(grantAchievements);
                result.Passed = true;
                Trace.TraceInformation("Successfully granted achievements for user with WLID {0}...", memberName);
            }
            catch (Exception e)
            {
                result.Error= e;
                TraceError(ServiceError.Unknown, e, "Error granting achievements");
            }
            finally
            {
                result.Stop();
                TraceEx.TraceStop("Completed granting achievements.  Took {0}ms.", result.Latency.TotalMilliseconds);
            }

            return result;
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="userToken"></param>
        /// <returns></returns>
        private static RewardsServiceService GetRewardsProxy(string url, string userToken)
        {
            return GetRewardsProxy(url, "en-US", ((int)Leet.Core.Platforms.PlatformType.Mobile).ToString(), userToken);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="locale"></param>
        /// <param name="platformType"></param>
        /// <param name="partnerToken"></param>
        /// <returns></returns>
        private static RewardsServiceService GetRewardsProxy(string url, string locale, string platformType, string userToken)
        {
            RewardsServiceService rewardsService = new RewardsServiceService(url);
            rewardsService.Locale = locale;
            rewardsService.PlatformType = platformType;
            rewardsService.UserAuthorizationToken = userToken;
            return rewardsService;
        }

        private string GetUserToken(string memberName, string password)
        {
            string userToken = AuthorizationCache.GetUserToken(memberName,
                                                                password,
                                                                this.LiveIdServiceTarget,
                                                                this.Policy,
                                                                this.Environment,
                                                                this.PlatformType,
                                                                this.TitleId,
                                                                this.TitleVersion,
                                                                this.ClientVersion);
            return userToken;
        }

        private new string GetPartnerToken(string memberName, string password)
        {
            string userToken = AuthorizationCache.GetUserToken( memberName,
                                                                password,
                                                                this.LiveIdServiceTarget,
                                                                this.Policy,
                                                                this.Environment,
                                                                this.PlatformType,
                                                                this.TitleId,
                                                                this.TitleVersion,
                                                                this.ClientVersion);

            string partnerToken = AuthorizationCache.GetPartnerToken(userToken,
                                                                     this.TitleId,
                                                                     this.TitleVersion,
                                                                     this.AudienceUri);

            return partnerToken;
        
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\UDS\UDSMonitoringBlock.cs ===
﻿using System;
using System.Collections.Generic;
using LiveN.Test.Services.Rewards;
using LiveN.Test.Framework.Configuration;
using Rewards.Contracts;

namespace LiveN.Test.Services.Multiplayer
{
    /// <summary>
    /// 
    /// </summary>
    public class UDSMonitoringBlock : MonitoringBlock
    {
        //private EnvironmentElement envConfig = null;
        private UDSUtil udsUtil;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="environment"></param>
        public UDSMonitoringBlock(string environment)
            : base(environment)
        {
            //envConfig = Config.EnvironmentSettings.Environments[environment];
            udsUtil = new UDSUtil(this.Environment.UDSProfileService.ToString(),
                                this.Environment.UDSGameDataService.ToString(),
                                this.Environment.StsSettings.StsUrl,
                                this.Environment.StsSettings.ClientCertSubject,
                                this.Environment.WindowsLiveIDSettings.LiveIdServiceTarget,
                                this.Environment.WindowsLiveIDSettings.Policy,
                                this.Environment.WindowsLiveIDSettings.Environment,
                                this.Environment.StsSettings.TitleId3,
                                this.Environment.StsSettings.TitleVersion3,
                                this.Environment.StsSettings.PlatformType,
                                this.Environment.StsSettings.ClientVersion);

        }

        /// <summary>
        /// 
        /// </summary>
        public override string Name
        {
            get { return "UDS"; }
        }

        /// <summary>
        /// 
        /// </summary>
        public override string FullName
        {
            get { return "UDS"; }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public override List<TestInfo> GetTestNames()
        {
            return GetMonitoringTests();
        }

        /// <summary>
        /// 
        /// </summary>
        public override int Priority
        {
            get
            {
                return 1;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public override List<IResult> RunTests()
        {
            List<IResult> results = new List<IResult>();

            string player1 = this.Environment.UserSettings[0].Membername;
            string player1Password = this.Environment.UserSettings[0].Password;

            //GetProfile
            results.Add(GetProfile(player1, player1Password));
            if (results[0].Passed == false) { return results; }

            //GetAchievements
            results.Add(GetAchievements(player1, player1Password));
            if (results[1].Passed == false) { return results; }

            return results;
        }

        [MonitoringTest(Name = "GetProfile", Id = "B8684ABD-5A2C-4804-A1A4-F8635D7786C2")]
        private Result<Profile> GetProfile(string username, string password)
        {
            Result<Profile> result = new Result<Profile>();
            TestInfo testInfo = GetTestInfo();

            try
            {
                StartTest(testInfo);
                result = this.udsUtil.ProfileUtil.GetProfile(
                        username,
                        password,
                        "1",
                        "");
            }
            finally
            {
                EndTest(testInfo, result);
            }

            return result;
        }

        [MonitoringTest(Name = "GetAchievements", Id = "A5684ABD-5A2C-4804-A1A4-E7635DFEA6C2")]
        private Result<AchievementsResult> GetAchievements(string username, string password)
        {
            Result<AchievementsResult> result = new Result<AchievementsResult>();
            TestInfo testInfo = GetTestInfo();

            try
            {
                StartTest(testInfo);
                result = this.udsUtil.GameDataUtil.GetAchievements(
                        username,
                        password,
                        this.Environment.StsSettings.TitleId3);
            }
            finally
            {
                EndTest(testInfo, result);
            }

            return result;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\UDS\UDSProfileService.cs ===
﻿using System;
using System.Collections.Generic;
using LiveN.Test.Common.Web;
using LiveN.Test.Framework.Web;
using Rewards.Contracts;

namespace LiveN.Test.Services.Rewards
{
    /// <summary>
    /// 
    /// </summary>
    public class UDSProfileService : XboxWcfService
    {
        // ProfileService path and queries
        public const string GetProfile_RelativePathAndQuery = "/profile?format=xml&sectionflags={sectionflags}&gamertag={gamertag}";

        /// <summary>
        /// 
        /// </summary>
        /// <param name="baseUri"></param>
        public UDSProfileService(string baseUri)
            : base(baseUri)
        {

        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="sectionFlags"></param>
        /// <param name="friendsSectionFlags"></param>
        /// <param name="gamertag"></param>
        /// <returns></returns>
        public Profile GetProfile(
            string sectionFlags,
            string gamertag)
        {
            string url = this.BaseUri + GetProfile_RelativePathAndQuery;
            url = url.Replace("{sectionflags}", sectionFlags);
            url = url.Replace("{gamertag}", gamertag);

            RestResponse response = Get(url, GetHttpHeaders());

            if (!response.Succeeded)
            {
                throw new RestException(response);
            }
            return DeserializeObject<Profile>(response.Body);
        }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\UDS\UDSProfileUtil.cs ===
﻿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using LiveN.Test.Common;
using LiveN.Test.Framework.Authorization;
using LiveN.Test.Services.Multiplayer;
using Rewards.Contracts;
using LiveN.Test.Services;

namespace LiveN.Test.Services.Rewards
{
    /// <summary>
    /// 
    /// </summary>
    public class UDSProfileUtil: ServiceBaseUtil
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="profileUrl"></param>
        /// <param name="stsUrl"></param>
        /// <param name="clientCertSubject"></param>
        /// <param name="liveIdServiceTarget"></param>
        /// <param name="policy"></param>
        /// <param name="environment"></param>
        /// <param name="titleId"></param>
        /// <param name="titleVersion"></param>
        /// <param name="platformType"></param>
        /// <param name="clientVersion"></param>
        public UDSProfileUtil(string profileUrl, string stsUrl, string clientCertSubject, string liveIdServiceTarget, string policy, string environment, string titleId, string titleVersion, string platformType, string clientVersion)
            : base(stsUrl, clientCertSubject, liveIdServiceTarget, policy, environment, titleId, titleVersion, platformType, clientVersion)
        {
            this.AuthorizationCache = new AuthorizationCache(
                stsUrl,
                clientCertSubject);

            this.ProfileUrl = new Uri(profileUrl);
        }

        /// <summary>
        /// 
        /// </summary>
        public Uri ProfileUrl
        {
            get;
            set;
        }

        public new AuthorizationCache AuthorizationCache
        {
            get;
            private set;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="memberName"></param>
        /// <param name="password"></param>
        /// <param name="sectionFlags"></param>
        /// <param name="gamertag"></param>
        /// <returns></returns>
        public Result<Profile> GetProfile(string memberName, string password, string sectionFlags, string gamertag)
        {
            Result<Profile> result = new Result<Profile>();
            
            try
            {
                TraceEx.TraceStart("Getting Profile of user with WLID {0}...", memberName );

                string userToken = GetUserToken(memberName, password);
                UDSProfileService profileProxy = GetProfileProxy(this.ProfileUrl.ToString(), userToken);

                result.Start();
                result.ReturnValue = profileProxy.GetProfile(sectionFlags, gamertag);
                result.Passed = true;
                Trace.TraceInformation("Successfully got profile for user with WLID {0}...", memberName );
            }
            catch (Exception e)
            {
                result.Error= e;
                TraceError(ServiceError.Unknown, e, "Error getting profile");
            }
            finally
            {
                result.Stop();
                TraceEx.TraceStop("Completed getting profile.  Took {0}ms.", result.Latency.TotalMilliseconds);
            }

            return result;
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="userToken"></param>
        /// <returns></returns>
        private static UDSProfileService GetProfileProxy(string url, string userToken)
        {
            return GetProfileProxy(url, "en-US", ((int)Leet.Core.Platforms.PlatformType.Mobile).ToString(), userToken);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="locale"></param>
        /// <param name="platformType"></param>
        /// <param name="partnerToken"></param>
        /// <returns></returns>
        private static UDSProfileService GetProfileProxy(string url, string locale, string platformType, string userToken)
        {
            UDSProfileService profileService = new UDSProfileService(url);
            profileService.Locale = locale;
            profileService.PlatformType = platformType;
            profileService.UserAuthorizationToken = userToken;
            return profileService;
        }

        private string GetUserToken(string memberName, string password)
        {
            string userToken = AuthorizationCache.GetUserToken(memberName,
                                                                password,
                                                                this.LiveIdServiceTarget,
                                                                this.Policy,
                                                                this.Environment,
                                                                this.PlatformType,
                                                                this.TitleId,
                                                                this.TitleVersion,
                                                                this.ClientVersion);
            return userToken;
        }

        private new string GetPartnerToken(string memberName, string password)
        {
            string userToken = AuthorizationCache.GetUserToken( memberName,
                                                                password,
                                                                this.LiveIdServiceTarget,
                                                                this.Policy,
                                                                this.Environment,
                                                                this.PlatformType,
                                                                this.TitleId,
                                                                this.TitleVersion,
                                                                this.ClientVersion);

            string partnerToken = AuthorizationCache.GetPartnerToken(userToken,
                                                                     this.TitleId,
                                                                     this.TitleVersion,
                                                                     this.AudienceUri);

            return partnerToken;
        
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\Rewards\RewardsUtil.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;
using LiveN.Test.Common;
using LiveN.Test.Framework.Authorization;
using LiveN.Test.Services.Multiplayer;
using LiveN.Test.Services;

namespace LiveN.Test.Services.Rewards
{
    /// <summary>
    /// Wrapper for all Rewards service proxies.
    /// </summary>
    public class RewardsUtil
    {
        public RewardsUtil(
            string rewardsUrl,
            string stsUrl,
            string clientCertSubject,
            string liveIdServiceTarget,
            string policy,
            string environment,
            string titleId,
            string titleVersion,
            string platformType,
            string clientVersion)
        {
            this.RewardsServiceUtil = new RewardsServiceUtil(rewardsUrl, stsUrl, clientCertSubject, liveIdServiceTarget, policy, environment, titleId, titleVersion, platformType, clientVersion);

            AuthorizationCache = new AuthorizationCache(
                stsUrl,
                clientCertSubject);
        }

        /// <summary>
        /// 
        /// </summary>
        public RewardsServiceUtil RewardsServiceUtil
        {
            get;
            private set;
        }

        public AuthorizationCache AuthorizationCache
        {
            get;
            private set;
        }


        ///// <summary>
        ///// 
        ///// </summary>
        ///// <returns></returns>
        //public Result<bool> GetRpsTicket(string memberName, string password)
        //{
        //    Result<bool> result = new Result<bool>();

        //    try
        //    {
        //        TraceEx.TraceStart("Starting IDCRL/Windows Live ID prereq check validation...");
        //        result.Start();
        //        string loginTicket = this.AuthorizationCache.GetLoginTicket(memberName, password);
        //        result.ReturnValue = true;
        //        TraceEx.TraceVerbose("RPS ticket={0}", loginTicket);
        //        Trace.TraceInformation("Verified that {0} can login via IDCRL/Windows Live ID.", memberName);                
        //    }
        //    catch (Exception e)
        //    {
        //        ServiceBaseUtil.TraceError(ServiceError.PrereqIdcrl, e, "Unable to get RPS ticket for {0}.  Verify the username and password are correct", memberName);
        //    }
        //    finally
        //    {
        //        result.Stop();
        //        TraceEx.TraceStop("Completed IDCRL/Windows Live ID validation.  Took {0}ms.", result.Latency.TotalMilliseconds);
        //    }

        //    return result;
        //}

        ///// <summary>
        ///// 
        ///// </summary>
        ///// <returns></returns>
        //public Result<bool> GetStsUserToken(string memberName, string password, string platformType, string titleId, string titleVersion, string clientVersion)
        //{
        //    Result<bool> result = new Result<bool>();

        //    try
        //    {
        //        TraceEx.TraceStart("Starting STS User Token prereq check validation...");
        //        result.Start();
        //        string userToken = this.AuthorizationCache.GetUserToken(
        //                                memberName,
        //                                password,
        //                                platformType,
        //                                titleId,
        //                                titleVersion,
        //                                clientVersion);
        //        TraceEx.TraceVerbose("STS User Token={0}", userToken);

        //        //if this is a machine token, the user doesn't have an XBL account
        //        if (!Authorization.IsUserSecurityToken(userToken))
        //        {
        //            TraceEx.TraceError((int)ServiceError.PrereqVerifyXblUser, "The platform STS service returned a Machine token for {0}; this user does not have an Xbox Live account.", memberName);
        //            result.ReturnValue = false;
        //        }
        //        Trace.TraceInformation("Verified that {0} can obtain an STS user token.", memberName);
        //        result.ReturnValue = true;
        //    }
        //    catch (Exception e)
        //    {
        //        ServiceBaseUtil.TraceError(ServiceError.PrereqStsUserToken, e, "Unable to get an STS user token for {0}, with title ID {1} and title version {2}.", memberName, titleId, titleVersion);
        //    }
        //    finally
        //    {
        //        result.Stop();
        //        TraceEx.TraceStop("Completed STS user token validation.  Took {0}ms.", result.Latency.TotalMilliseconds);
        //    }

        //    return result;
        //}

        ///// <summary>
        ///// 
        ///// </summary>
        ///// <returns></returns>
        //public Result<bool> GetStsPartnerToken(string memberName, string password, string platformType, string titleId, string titleVersion, string clientVersion, string audienceUri)
        //{
        //    Result<bool> result = new Result<bool>();

        //    try
        //    {
        //        TraceEx.TraceStart("Starting STS Partner Token prereq check validation...");
        //        result.Start();
        //        string userToken = this.AuthorizationCache.GetUserToken(
        //                                memberName,
        //                                password,
        //                                platformType,
        //                                titleId,
        //                                titleVersion,
        //                                clientVersion);
        //        string partnerToken = this.AuthorizationCache.GetPartnerToken(
        //                                userToken,
        //                                titleId,
        //                                titleVersion,
        //                                audienceUri);
        //        result.ReturnValue = true;
        //        TraceEx.TraceVerbose("STS Partner Token={0}", partnerToken);
        //        Trace.TraceInformation("Verified that {0} can obtain an STS partner token.", memberName);
        //    }
        //    catch (Exception e)
        //    {
        //        ServiceBaseUtil.TraceError(ServiceError.PrereqStsPartnerToken, e, "Unable to get an STS partner token for {0}, with title ID {1}, title version {2} and audience Uri {3}", memberName, this.RewardsServiceUtil.TitleId, this.RewardsServiceUtil.TitleVersion, this.RewardsServiceUtil.AudienceUri);
        //    }
        //    finally
        //    {
        //        result.Stop();
        //        TraceEx.TraceStop("Completed STS Partner Token validation.  Took {0}ms.", result.Latency.TotalMilliseconds);
        //    }

        //    return result;
        //}

        ///// <summary>
        ///// 
        ///// </summary>
        ///// <returns></returns>
        //public Result<bool> VerifyTitle(string memberName, string password, string platformType, string titleId, string titleVersion, string clientVersion)
        //{
        //    Result<bool> result = new Result<bool>();

        //    try
        //    {
        //        TraceEx.TraceStart("Starting Title ID/Version prereq check validation...");
        //        result.Start();
        //        string userToken = this.AuthorizationCache.GetUserToken(
        //                                memberName,
        //                                password,
        //                                platformType,
        //                                titleId,
        //                                titleVersion,
        //                                clientVersion);
        //        result.ReturnValue = true;
        //        Trace.TraceInformation("Verified that title ID {0} and title version {1}, for platform {2}, are valid.", titleId, titleVersion, platformType);
        //    }
        //    catch (Exception e)
        //    {
        //        ServiceBaseUtil.TraceError(ServiceError.PrereqVerifyTitle, e, "Unable verify that title ID {0} and title version {1} are valid and available.  Verify this title has been propped in GMS and xLast", titleId, titleVersion);
        //    }
        //    finally
        //    {
        //        result.Stop();
        //        TraceEx.TraceStop("Completed Title ID/Version validation.  Took {0}ms", result.Latency.TotalMilliseconds);
        //    }

        //    return result;
        //}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\UDS\UDSUtil.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;
using LiveN.Test.Common;
using LiveN.Test.Framework.Authorization;
using LiveN.Test.Services.Multiplayer;
using LiveN.Test.Services;

namespace LiveN.Test.Services.Rewards
{
    /// <summary>
    /// Wrapper for all UDS service proxies.
    /// </summary>
    public class UDSUtil
    {
        public UDSUtil(
            string profileUrl,
            string gameDataUrl,
            string stsUrl,
            string clientCertSubject,
            string liveIdServiceTarget,
            string policy,
            string environment,
            string titleId,
            string titleVersion,
            string platformType,
            string clientVersion)
        {

            this.ProfileUtil = new UDSProfileUtil(profileUrl, stsUrl, clientCertSubject, liveIdServiceTarget, policy, environment, titleId, titleVersion, platformType, clientVersion);

            this.GameDataUtil = new UDSGameDataUtil(gameDataUrl, stsUrl, clientCertSubject, liveIdServiceTarget, policy, environment, titleId, titleVersion, platformType, clientVersion);

            AuthorizationCache = new AuthorizationCache(
                stsUrl,
                clientCertSubject);
        }

        /// <summary>
        /// 
        /// </summary>
        public UDSProfileUtil ProfileUtil
        {
            get;
            private set;
        }

        /// <summary>
        /// 
        /// </summary>
        public UDSGameDataUtil GameDataUtil
        {
            get;
            private set;
        }

        public AuthorizationCache AuthorizationCache
        {
            get;
            private set;
        }


        ///// <summary>
        ///// 
        ///// </summary>
        ///// <returns></returns>
        //public Result<bool> GetRpsTicket(string memberName, string password)
        //{
        //    Result<bool> result = new Result<bool>();

        //    try
        //    {
        //        TraceEx.TraceStart("Starting IDCRL/Windows Live ID prereq check validation...");
        //        result.Start();
        //        string loginTicket = this.AuthorizationCache.GetLoginTicket(memberName, password, this.liveIdTarget, this.liveIdPolicy, this.liveIdEnvironment);
        //        result.ReturnValue = true;
        //        TraceEx.TraceVerbose("RPS ticket={0}", loginTicket);
        //        Trace.TraceInformation("Verified that {0} can login via IDCRL/Windows Live ID.", memberName);                
        //    }
        //    catch (Exception e)
        //    {
        //        ServiceBaseUtil.TraceError(ServiceError.PrereqIdcrl, e, "Unable to get RPS ticket for {0}.  Verify the username and password are correct", memberName);
        //    }
        //    finally
        //    {
        //        result.Stop();
        //        TraceEx.TraceStop("Completed IDCRL/Windows Live ID validation.  Took {0}ms.", result.Latency.TotalMilliseconds);
        //    }

        //    return result;
        //}

        ///// <summary>
        ///// 
        ///// </summary>
        ///// <returns></returns>
        //public Result<bool> GetStsUserToken(string memberName, string password, string platformType, string titleId, string titleVersion, string clientVersion)
        //{
        //    Result<bool> result = new Result<bool>();

        //    try
        //    {
        //        TraceEx.TraceStart("Starting STS User Token prereq check validation...");
        //        result.Start();
        //        string userToken = this.AuthorizationCache.GetUserToken(
        //                                memberName,
        //                                password,
                                        

        //                                platformType,
        //                                titleId,
        //                                titleVersion,
        //                                clientVersion);
        //        TraceEx.TraceVerbose("STS User Token={0}", userToken);

        //        //if this is a machine token, the user doesn't have an XBL account
        //        if (!Authorization.IsUserSecurityToken(userToken))
        //        {
        //            TraceEx.TraceError((int)ServiceError.PrereqVerifyXblUser, "The platform STS service returned a Machine token for {0}; this user does not have an Xbox Live account.", memberName);
        //            result.ReturnValue = false;
        //        }
        //        Trace.TraceInformation("Verified that {0} can obtain an STS user token.", memberName);
        //        result.ReturnValue = true;
        //    }
        //    catch (Exception e)
        //    {
        //        ServiceBaseUtil.TraceError(ServiceError.PrereqStsUserToken, e, "Unable to get an STS user token for {0}, with title ID {1} and title version {2}.", memberName, titleId, titleVersion);
        //    }
        //    finally
        //    {
        //        result.Stop();
        //        TraceEx.TraceStop("Completed STS user token validation.  Took {0}ms.", result.Latency.TotalMilliseconds);
        //    }

        //    return result;
        //}

        ///// <summary>
        ///// 
        ///// </summary>
        ///// <returns></returns>
        //public Result<bool> GetStsPartnerToken(string memberName, string password, string platformType, string titleId, string titleVersion, string clientVersion, string audienceUri)
        //{
        //    Result<bool> result = new Result<bool>();

        //    try
        //    {
        //        TraceEx.TraceStart("Starting STS Partner Token prereq check validation...");
        //        result.Start();
        //        string userToken = this.AuthorizationCache.GetUserToken(
        //                                memberName,
        //                                password,
        //                                platformType,
        //                                titleId,
        //                                titleVersion,
        //                                clientVersion);
        //        string partnerToken = this.AuthorizationCache.GetPartnerToken(
        //                                userToken,
        //                                titleId,
        //                                titleVersion,
        //                                audienceUri);
        //        result.ReturnValue = true;
        //        TraceEx.TraceVerbose("STS Partner Token={0}", partnerToken);
        //        Trace.TraceInformation("Verified that {0} can obtain an STS partner token.", memberName);
        //    }
        //    catch (Exception e)
        //    {
        //        ServiceBaseUtil.TraceError(ServiceError.PrereqStsPartnerToken, e, "Unable to get an STS partner token for {0}, with title ID {1}, title version {2} and audience Uri {3}", memberName, this.ProfileUtil.TitleId, this.ProfileUtil.TitleVersion, this.ProfileUtil.AudienceUri);
        //    }
        //    finally
        //    {
        //        result.Stop();
        //        TraceEx.TraceStop("Completed STS Partner Token validation.  Took {0}ms.", result.Latency.TotalMilliseconds);
        //    }

        //    return result;
        //}

        ///// <summary>
        ///// 
        ///// </summary>
        ///// <returns></returns>
        //public Result<bool> VerifyTitle(string memberName, string password, string platformType, string titleId, string titleVersion, string clientVersion)
        //{
        //    Result<bool> result = new Result<bool>();

        //    try
        //    {
        //        TraceEx.TraceStart("Starting Title ID/Version prereq check validation...");
        //        result.Start();
        //        string userToken = this.AuthorizationCache.GetUserToken(
        //                                memberName,
        //                                password,
        //                                platformType,
        //                                titleId,
        //                                titleVersion,
        //                                clientVersion);
        //        result.ReturnValue = true;
        //        Trace.TraceInformation("Verified that title ID {0} and title version {1}, for platform {2}, are valid.", titleId, titleVersion, platformType);
        //    }
        //    catch (Exception e)
        //    {
        //        ServiceBaseUtil.TraceError(ServiceError.PrereqVerifyTitle, e, "Unable verify that title ID {0} and title version {1} are valid and available.  Verify this title has been propped in GMS and xLast", titleId, titleVersion);
        //    }
        //    finally
        //    {
        //        result.Stop();
        //        TraceEx.TraceStop("Completed Title ID/Version validation.  Took {0}ms", result.Latency.TotalMilliseconds);
        //    }

        //    return result;
        //}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\UDS\UDSGameDataUtil.cs ===
﻿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using LiveN.Test.Common;
using LiveN.Test.Framework.Authorization;
using LiveN.Test.Services.Multiplayer;
using Rewards.Contracts;
using LiveN.Test.Services;

namespace LiveN.Test.Services.Rewards
{
    /// <summary>
    /// 
    /// </summary>
    public class UDSGameDataUtil: ServiceBaseUtil
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="profileUrl"></param>
        /// <param name="stsUrl"></param>
        /// <param name="clientCertSubject"></param>
        /// <param name="liveIdServiceTarget"></param>
        /// <param name="policy"></param>
        /// <param name="environment"></param>
        /// <param name="titleId"></param>
        /// <param name="titleVersion"></param>
        /// <param name="platformType"></param>
        /// <param name="clientVersion"></param>
        public UDSGameDataUtil(string gameDataUrl, string stsUrl, string clientCertSubject, string liveIdServiceTarget, string policy, string environment, string titleId, string titleVersion, string platformType, string clientVersion)
            : base(stsUrl, clientCertSubject, liveIdServiceTarget, policy, environment, titleId, titleVersion, platformType, clientVersion)
        {
            this.AuthorizationCache = new AuthorizationCache(
                stsUrl,
                clientCertSubject);

            this.GameDataUrl = new Uri(gameDataUrl);
        }

        /// <summary>
        /// 
        /// </summary>
        public Uri GameDataUrl
        {
            get;
            set;
        }

        public new AuthorizationCache AuthorizationCache
        {
            get;
            private set;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="memberName"></param>
        /// <param name="password"></param>
        /// <param name="gameId"></param>
        /// <param name="variant"></param>
        /// <param name="property"></param>
        /// <param name="datagroup"></param>
        /// <param name="numRows"></param>
        /// <param name="rankStart"></param>
        /// <param name="socialGraph"></param>
        /// <returns></returns>
        public Result<LeaderboardResult> GetLeaderboard(
            string memberName, 
            string password, 
            string gameId, 
            string variant, 
            string property,
            string datagroup,
            string numRows,
            string rankStart,
            string socialGraph)
        {
            Result<LeaderboardResult> result = new Result<LeaderboardResult>();
            result.Passed = false;

            try
            {
                TraceEx.TraceStart("Getting Leaderboard of user with WLID {0}...", memberName);

                string userToken = GetUserToken(memberName, password);
                UDSGameDataService gameDataProxy = GetGameDataProxy(this.GameDataUrl.ToString(), userToken);

                result.Start();
                result.ReturnValue = gameDataProxy.GetLeaderboard(gameId, variant, property, datagroup, numRows, rankStart, socialGraph);
                result.Passed = true;
                Trace.TraceInformation("Successfully got leaderboard for user with WLID {0}...", memberName);
            }
            catch (Exception e)
            {
                result.Error= e;
                TraceError(ServiceError.Unknown, e, "Error getting leaderboard");
            }
            finally
            {
                result.Stop();
                TraceEx.TraceStop("Completed getting leaderboard.  Took {0}ms.", result.Latency.TotalMilliseconds);
            }

            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="memberName"></param>
        /// <param name="password"></param>
        /// <param name="gameId"></param>
        /// <returns></returns>
        public Result<AchievementsResult> GetAchievements(string memberName, string password, string gameId)
        {
            Result<AchievementsResult> result = new Result<AchievementsResult>();

            try
            {
                TraceEx.TraceStart("Getting Achievements of user with WLID {0}...", memberName);

                string userToken = GetUserToken(memberName, password);
                UDSGameDataService gameDataProxy = GetGameDataProxy(this.GameDataUrl.ToString(), userToken);

                result.Start();
                result.ReturnValue = gameDataProxy.GetAchievements(gameId);
                result.Passed = true;
                Trace.TraceInformation("Successfully got achievements for user with WLID {0}...", memberName);
            }
            catch (Exception e)
            {
                result.Error= e;
                TraceError(ServiceError.Unknown, e, "Error getting achievements");
            }
            finally
            {
                result.Stop();
                TraceEx.TraceStop("Completed getting achievements.  Took {0}ms.", result.Latency.TotalMilliseconds);
            }

            return result;
        }

        public Result<bool> GetDataBlob(string memberName, string password, string dataBlobId)
        {
            Result<bool> result = new Result<bool>();
            result.ReturnValue = false;

            try
            {
                TraceEx.TraceStart("Getting Datablob of user with WLID {0}...", memberName);

                string userToken = GetUserToken(memberName, password);
                UDSGameDataService gameDataProxy = GetGameDataProxy(this.GameDataUrl.ToString(), userToken);

                result.Start();
                gameDataProxy.GetDatablob(dataBlobId);
                result.ReturnValue = true;
                Trace.TraceInformation("Successfully got Datablob for user with WLID {0}...", memberName);
            }
            catch (Exception e)
            {
                result.Error= e;
                TraceError(ServiceError.Unknown, e, "Error getting Datablob");
            }
            finally
            {
                result.Stop();
                TraceEx.TraceStop("Completed getting Datablob.  Took {0}ms.", result.Latency.TotalMilliseconds);
            }

            return result;
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="userToken"></param>
        /// <returns></returns>
        private static UDSGameDataService GetGameDataProxy(string url, string userToken)
        {
            return GetGameDataProxy(url, "en-US", ((int)Leet.Core.Platforms.PlatformType.Mobile).ToString(), userToken);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="locale"></param>
        /// <param name="platformType"></param>
        /// <param name="partnerToken"></param>
        /// <returns></returns>
        private static UDSGameDataService GetGameDataProxy(string url, string locale, string platformType, string userToken)
        {
            UDSGameDataService gameDataService = new UDSGameDataService(url);
            gameDataService.Locale = locale;
            gameDataService.PlatformType = platformType;
            gameDataService.UserAuthorizationToken = userToken;
            return gameDataService;
        }

        private string GetUserToken(string memberName, string password)
        {
            string userToken = AuthorizationCache.GetUserToken(memberName,
                                                                password,
                                                                this.LiveIdServiceTarget,
                                                                this.Policy,
                                                                this.Environment,
                                                                this.PlatformType,
                                                                this.TitleId,
                                                                this.TitleVersion,
                                                                this.ClientVersion);
            return userToken;
        }

        private new string GetPartnerToken(string memberName, string password)
        {
            string userToken = AuthorizationCache.GetUserToken( memberName,
                                                                password,
                                                                this.LiveIdServiceTarget,
                                                                this.Policy,
                                                                this.Environment,
                                                                this.PlatformType,
                                                                this.TitleId,
                                                                this.TitleVersion,
                                                                this.ClientVersion);

            string partnerToken = AuthorizationCache.GetPartnerToken(userToken,
                                                                     this.TitleId,
                                                                     this.TitleVersion,
                                                                     this.AudienceUri);

            return partnerToken;
        
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\UDS\UDSGameDataService.cs ===
﻿using System;
using System.Collections.Generic;
using LiveN.Test.Common.Web;
using LiveN.Test.Framework.Web;
using Rewards.Contracts;

namespace LiveN.Test.Services.Rewards
{
    /// <summary>
    /// 
    /// </summary>
    public class UDSGameDataService : XboxWcfService
    {
        // GameDataService path and queries
        //public const string GrantAchievements_RelativePathAndQuery = "/GrantAchievements?format=xml";
        public const string GetLeaderBoard_RelativePathAndQuery = "/leaderboard?format=xml&gameId={gameId}&variant={variant}&property={property}&datagroup={datagroup}&numRows={numRows}&rankStart={rankStart}&socialGraph={socialGraph}";
        public const string GetAchievements_RelativePathAndQuery = "/achievements?format=xml&gameId={gameId}";
        public const string GetDataBlob_RelativePathAndQuery = "/Datablob?format=xml&datablobId={DataBlobId}";


        /// <summary>
        /// 
        /// </summary>
        /// <param name="baseUri"></param>
        public UDSGameDataService(string baseUri)
            : base(baseUri)
        {

        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="sectionFlags"></param>
        /// <param name="friendsSectionFlags"></param>
        /// <param name="gamertag"></param>
        /// <returns></returns>
        public LeaderboardResult GetLeaderboard(
            string gameId,
            string variant,
            string property, 
            string datagroup, 
            string numRows,
            string rankStart,
            string socialGraph)
        {
            string url = this.BaseUri + GetLeaderBoard_RelativePathAndQuery;
            url = url.Replace("{gameId}", gameId);
            url = url.Replace("{variant}", variant);
            url = url.Replace("{property}", property);
            url = url.Replace("{datagroup}", datagroup);
            url = url.Replace("{numRows}", numRows);
            url = url.Replace("{rankStart}", rankStart);
            url = url.Replace("{socialGraph}", socialGraph);

            RestResponse response = Get(url, GetHttpHeaders());

            if (!response.Succeeded)
            {
                throw new RestException(response);
            }
            return DeserializeObject<LeaderboardResult>(response.Body);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="gameId"></param>
        /// <returns></returns>
        public AchievementsResult GetAchievements(
           string gameId)
        {
            string url = this.BaseUri + GetAchievements_RelativePathAndQuery;
            url = url.Replace("{gameId}", gameId);

            RestResponse response = Get(url, GetHttpHeaders());

            if (!response.Succeeded)
            {
                throw new RestException(response);
            }
            return DeserializeObject<AchievementsResult>(response.Body);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="dataBlobId"></param>
        /// <returns></returns>
        public DatablobResult GetDatablob(
           string dataBlobId)
        {
            string url = this.BaseUri + GetDataBlob_RelativePathAndQuery;
            url = url.Replace("{DataBlobId}", dataBlobId);

            RestResponse response = Get(url, GetHttpHeaders());

            if (!response.Succeeded)
            {
                throw new RestException(response);
            }
            return DeserializeObject<DatablobResult>(response.Body);
        }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\UDSPartner\UDSPartnerFriendUtil.cs ===
﻿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using LiveN.Test.Common;
using LiveN.Test.Framework.Authorization;
using LiveN.Test.Services.Multiplayer;
using Rewards.Contracts;
using LiveN.Test.Services;

namespace LiveN.Test.Services.Rewards
{
    /// <summary>
    /// 
    /// </summary>
    public class UDSPartnerFriendUtil : ServiceBaseUtil
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="profileUrl"></param>
        /// <param name="stsUrl"></param>
        /// <param name="clientCertSubject"></param>
        /// <param name="liveIdServiceTarget"></param>
        /// <param name="policy"></param>
        /// <param name="environment"></param>
        /// <param name="titleId"></param>
        /// <param name="titleVersion"></param>
        /// <param name="platformType"></param>
        /// <param name="clientVersion"></param>
        public UDSPartnerFriendUtil(string friendUrl, string stsUrl, string clientCertSubject, string liveIdServiceTarget, string policy, string environment, string titleId, string titleVersion, string platformType, string clientVersion)
            : base(stsUrl, clientCertSubject, liveIdServiceTarget, policy, environment, titleId, titleVersion, platformType, clientVersion)
        {
            this.AuthorizationCache = new AuthorizationCache(
                stsUrl,
                clientCertSubject);

            this.FriendUrl = new Uri(friendUrl);
        }

        /// <summary>
        /// 
        /// </summary>
        public Uri FriendUrl
        {
            get;
            set;
        }

        public new AuthorizationCache AuthorizationCache
        {
            get;
            private set;
        }

        public Result<bool> AddFriend(string memberName, string password, string gamertag)
        {
            Result<bool> result = new Result<bool>();

            try
            {
                TraceEx.TraceStart("Sending friend request from user with WLID {0}...", memberName);

                string partnerToken = GetPartnerToken(memberName, password);
                UDSPartnerFriendService friendProxy = GetFriendProxy(this.FriendUrl.ToString(), partnerToken);

                result.Start();
                result.ReturnValue = friendProxy.AddFriend(gamertag);
                result.Passed = true;
                Trace.TraceInformation("Successfully sent friend request from user with WLID {0}...", memberName);
            }
            catch (Exception e)
            {
                result.Error = e;
                TraceError(ServiceError.Unknown, e, "Error sending friend request");
            }
            finally
            {
                result.Stop();
                TraceEx.TraceStop("Completed sending friend request.  Took {0}ms.", result.Latency.TotalMilliseconds);
            }

            return result;
        }


        public Result<bool> AcceptFriendRequest(string memberName, string password, string gamertag)
        {
            throw new NotImplementedException();
        }

        public Result<bool> RejectFriendRequest(string memberName, string password, string gamertag)
        {
            throw new NotImplementedException();
        }

        public Result<bool> DeleteFriend(string memberName, string password, string gamertag)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="userToken"></param>
        /// <returns></returns>
        private static UDSPartnerFriendService GetFriendProxy(string url, string partnerToken)
        {
            return GetFriendProxy(url, "en-US", ((int)Leet.Core.Platforms.PlatformType.Mobile).ToString(), partnerToken);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="locale"></param>
        /// <param name="platformType"></param>
        /// <param name="partnerToken"></param>
        /// <returns></returns>
        private static UDSPartnerFriendService GetFriendProxy(string url, string locale, string platformType, string partnerToken)
        {
            UDSPartnerFriendService friendService = new UDSPartnerFriendService(url);
            friendService.Locale = locale;
            friendService.PlatformType = platformType;
            friendService.PartnerAuthorizationToken = partnerToken;
            return friendService;
        }

        private new string GetPartnerToken(string memberName, string password)
        {
            string userToken = AuthorizationCache.GetUserToken(memberName,
                                                                password,
                                                                this.LiveIdServiceTarget,
                                                                this.Policy,
                                                                this.Environment,
                                                                this.PlatformType,
                                                                this.TitleId,
                                                                this.TitleVersion,
                                                                this.ClientVersion);

            string partnerToken = AuthorizationCache.GetPartnerToken(userToken,
                                                                     this.TitleId,
                                                                     this.TitleVersion,
                                                                     this.AudienceUri);

            return partnerToken;

        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\UDSPartner\UDSPartnerMessageService.cs ===
﻿using System;
using System.Collections.Generic;
using LiveN.Test.Common.Web;
using LiveN.Test.Framework.Web;
using Rewards.Contracts;

namespace LiveN.Test.Services.Rewards
{
    /// <summary>
    /// 
    /// </summary>
    public class UDSPartnerMessageService : XboxWcfService
    {
        // MessagePartnerService path and queries
        public const string GetMessageSummaries_RelativePathAndQuery = "/summarylist?hashCode={hashCode}";
        public const string GetMessageDetails_RelativePathAndQuery = "/messagedetails?messageId={messageId}";
        public const string SendMessages_RelativePathAndQuery = "/send";
        public const string DeleteMessage_RelativePathAndQuery = "/delete?messageId={messageId}";
        public const string DeleteMessageAndBlockGamertag_RelativePathAndQuery = "/block?messageId={messageId}";

        /// <summary>
        /// 
        /// </summary>
        /// <param name="baseUri"></param>
        public UDSPartnerMessageService(string baseUri)
            : base(baseUri)
        {

        }

        public MessageSummariesResponse GetMessageSummaries(string hashCode)
        {
            string url = this.BaseUri + GetMessageSummaries_RelativePathAndQuery;
            url = url.Replace("{hashcode}", hashCode);

            RestResponse response = Get(url, GetHttpHeaders());

            if (!response.Succeeded)
            {
                throw new RestException(response);
            }
            return DeserializeObject<MessageSummariesResponse>(response.Body);
        }

        public MessageDetails GetMessageDetails(string messageId)
        {
            string url = this.BaseUri + GetMessageDetails_RelativePathAndQuery;
            url = url.Replace("{messageId}", messageId);

            RestResponse response = Get(url, GetHttpHeaders());

            if (!response.Succeeded)
            {
                throw new RestException(response);
            }
            return DeserializeObject<MessageDetails>(response.Body);
        }

        public bool SendMessage(SendMessageRequest sendMessageRequest)
        {
            string url = this.BaseUri + SendMessages_RelativePathAndQuery;

            string body = SerializeObject(sendMessageRequest);

            RestResponse response = Post(url, GetHttpHeaders(), body);

            if (!response.Succeeded)
            {
                throw new RestException(response);
            }
            return true;
        }

        public bool DeleteMessage(string messageId)
        {
            string url = this.BaseUri + DeleteMessage_RelativePathAndQuery;
            url = url.Replace("{messageId}", messageId);

            RestResponse response = Delete(url, GetHttpHeaders());

            if (!response.Succeeded)
            {
                throw new RestException(response);
            }
            return true;
        }

        public bool DeleteMessageAndBlockGamertag(string messageId)
        {
            string url = this.BaseUri + DeleteMessageAndBlockGamertag_RelativePathAndQuery;
            url = url.Replace("{messageId}", messageId);

            RestResponse response = Delete(url, GetHttpHeaders());

            if (!response.Succeeded)
            {
                throw new RestException(response);
            }
            return true;
        }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\UDSPartner\UDSPartnerPresenceService.cs ===
﻿using System;
using System.Collections.Generic;
using LiveN.Test.Common.Web;
using LiveN.Test.Framework.Web;
using Rewards.Contracts;

namespace LiveN.Test.Services.Rewards
{
    /// <summary>
    /// 
    /// </summary>
    public class UDSPartnerPresenceService : XboxWcfService
    {
        // PresencePartnerService path and queries
        public const string PostPresence_RelativePathAndQuery = "/update";

        /// <summary>
        /// 
        /// </summary>
        /// <param name="baseUri"></param>
        public UDSPartnerPresenceService(string baseUri)
            : base(baseUri)
        {

        }

        public bool PostPresence()
        {
            string url = this.BaseUri + PostPresence_RelativePathAndQuery;

            RestResponse response = Post(url, GetHttpHeaders(), null);

            if (!response.Succeeded)
            {
                throw new RestException(response);
            }
            return true;
        }

   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\UDSPartner\UDSPartnerFriendService.cs ===
﻿using System;
using System.Collections.Generic;
using LiveN.Test.Common.Web;
using LiveN.Test.Framework.Web;
using Rewards.Contracts;

namespace LiveN.Test.Services.Rewards
{
    /// <summary>
    /// 
    /// </summary>
    public class UDSPartnerFriendService : XboxWcfService
    {
        // FriendPartnerService path and queries
        public const string AddFriend_RelativePathAndQuery = "/add?gamertag={gamertag}";
        public const string AcceptFriend_RelativePathAndQuery = "/accept?gamertag={gamertag}";
        public const string RejectFriend_RelativePathAndQuery = "/reject?gamertag={gamertag}";
        public const string DeleteFriend_RelativePathAndQuery = "/gamertag={gamertag}";

        /// <summary>
        /// 
        /// </summary>
        /// <param name="baseUri"></param>
        public UDSPartnerFriendService(string baseUri)
            : base(baseUri)
        {

        }

        public bool AddFriend(string gamertag)
        {
            string url = this.BaseUri + AddFriend_RelativePathAndQuery;
            url = url.Replace("{gamertag}", gamertag);

            RestResponse response = Post(url, GetHttpHeaders(), null);

            if (!response.Succeeded)
            {
                throw new RestException(response);
            }
            return true;
        }

   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\UDSPartner\UDSPartnerGameDataService.cs ===
﻿using System;
using System.Collections.Generic;
using LiveN.Test.Common.Web;
using LiveN.Test.Framework.Web;
using Rewards.Contracts;

namespace LiveN.Test.Services.Rewards
{
    /// <summary>
    /// 
    /// </summary>
    public class UDSPartnerGameDataService : XboxWcfService
    {
        // GameDataPartnerService path and queries
        public const string GetGames_RelativePathAndQuery = "/games?gamertags={gamertags}&pageStart={pageStart}&pageCount={pageCount}";
        public const string GetAchievementsPartner_RelativePathAndQuery = "/achievements?gameId={gameId}&gamertags={gamertags}";

        /// <summary>
        /// 
        /// </summary>
        /// <param name="baseUri"></param>
        public UDSPartnerGameDataService(string baseUri)
            : base(baseUri)
        {

        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="gameid"></param>
        /// <param name="gamertags"></param>
        /// <returns></returns>
        public Games GetGames(
            string gamertags,
            string pageStart,
            string pageCount)
        {
            string url = this.BaseUri + GetGames_RelativePathAndQuery;
            url = url.Replace("{gamertags}", gamertags);
            url = url.Replace("{pageStart}", pageStart);
            url = url.Replace("{pageCount}", pageCount);

            RestResponse response = Get(url, GetHttpHeaders());

            if (!response.Succeeded)
            {
                throw new RestException(response);
            }
            return DeserializeObject<Games>(response.Body);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="sectionFlags"></param>
        /// <param name="friendsSectionFlags"></param>
        /// <param name="gamertag"></param>
        /// <returns></returns>
        public Achievements GetAchievements(
            string gameId,
            string gamertags)
        {
            string url = this.BaseUri + GetAchievementsPartner_RelativePathAndQuery;
            url = url.Replace("{gameId}", gameId);
            url = url.Replace("{gamertags}", gamertags);

            RestResponse response = Get(url, GetHttpHeaders());

            if (!response.Succeeded)
            {
                throw new RestException(response);
            }
            return DeserializeObject<Achievements>(response.Body);
        }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\UDSPartner\UDSPartnerMessageUtil.cs ===
﻿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using LiveN.Test.Common;
using LiveN.Test.Framework.Authorization;
using LiveN.Test.Services.Multiplayer;
using Rewards.Contracts;
using LiveN.Test.Services;

namespace LiveN.Test.Services.Rewards
{
    /// <summary>
    /// 
    /// </summary>
    public class UDSPartnerMessageUtil : ServiceBaseUtil
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="profileUrl"></param>
        /// <param name="stsUrl"></param>
        /// <param name="clientCertSubject"></param>
        /// <param name="liveIdServiceTarget"></param>
        /// <param name="policy"></param>
        /// <param name="environment"></param>
        /// <param name="titleId"></param>
        /// <param name="titleVersion"></param>
        /// <param name="platformType"></param>
        /// <param name="clientVersion"></param>
        public UDSPartnerMessageUtil(string messageUrl, string stsUrl, string clientCertSubject, string liveIdServiceTarget, string policy, string environment, string titleId, string titleVersion, string platformType, string clientVersion)
            : base(stsUrl, clientCertSubject, liveIdServiceTarget, policy, environment, titleId, titleVersion, platformType, clientVersion)
        {
            this.AuthorizationCache = new AuthorizationCache(
                stsUrl,
                clientCertSubject);

            this.MessageUrl = new Uri(messageUrl);
        }

        /// <summary>
        /// 
        /// </summary>
        public Uri MessageUrl
        {
            get;
            set;
        }

        public new AuthorizationCache AuthorizationCache
        {
            get;
            private set;
        }

        public Result<MessageSummariesResponse> GetMessageSummaries(string memberName, string password, string hashCode)
        {
            Result<MessageSummariesResponse> result = new Result<MessageSummariesResponse>();

            try
            {
                TraceEx.TraceStart("Getting message summaries of user with WLID {0}...", memberName);

                string partnerToken = GetPartnerToken(memberName, password);
                UDSPartnerMessageService messageProxy = GetMessageProxy(this.MessageUrl.ToString(), partnerToken);

                result.Start();
                result.ReturnValue = messageProxy.GetMessageSummaries(hashCode);
                result.Passed = true;
                Trace.TraceInformation("Successfully got message summaries for user with WLID {0}...", memberName);
            }
            catch (Exception e)
            {
                result.Error= e;
                TraceError(ServiceError.Unknown, e, "Error getting message summaries");
            }
            finally
            {
                result.Stop();
                TraceEx.TraceStop("Completed getting message summaries.  Took {0}ms.", result.Latency.TotalMilliseconds);
            }

            return result;
        }

        public Result<MessageDetails> GetMessageDetails(string memberName, string password, string messageId)
        {
            Result<MessageDetails> result = new Result<MessageDetails>();

            try
            {
                TraceEx.TraceStart("Getting message details of user with WLID {0}...", memberName);

                string partnerToken = GetPartnerToken(memberName, password);
                UDSPartnerMessageService messageProxy = GetMessageProxy(this.MessageUrl.ToString(), partnerToken);

                result.Start();
                result.ReturnValue = messageProxy.GetMessageDetails(messageId);
                result.Passed = true;
                Trace.TraceInformation("Successfully got message details for user with WLID {0}...", memberName);
            }
            catch (Exception e)
            {
                result.Error= e;
                TraceError(ServiceError.Unknown, e, "Error getting message details");
            }
            finally
            {
                result.Stop();
                TraceEx.TraceStop("Completed getting message details.  Took {0}ms.", result.Latency.TotalMilliseconds);
            }

            return result;
        }

        public Result<bool> SendMessage(string memberName, string password, SendMessageRequest sendMessage)
        {
            throw new NotImplementedException();
        }

        public Result<bool> DeleteMessage(string memberName, string password, string messageId)
        {
            throw new NotImplementedException();
        }

        public Result<bool> DeleteMessageAndBlockGamertag(string memberName, string password, string messageId)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="userToken"></param>
        /// <returns></returns>
        private static UDSPartnerMessageService GetMessageProxy(string url, string partnerToken)
        {
            return GetMessageProxy(url, "en-US", ((int)Leet.Core.Platforms.PlatformType.Mobile).ToString(), partnerToken);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="locale"></param>
        /// <param name="platformType"></param>
        /// <param name="partnerToken"></param>
        /// <returns></returns>
        private static UDSPartnerMessageService GetMessageProxy(string url, string locale, string platformType, string partnerToken)
        {
            UDSPartnerMessageService messageService = new UDSPartnerMessageService(url);
            messageService.Locale = locale;
            messageService.PlatformType = platformType;
            messageService.PartnerAuthorizationToken = partnerToken;
            return messageService;
        }

        private new string GetPartnerToken(string memberName, string password)
        {
            string userToken = AuthorizationCache.GetUserToken(memberName,
                                                                password,
                                                                this.LiveIdServiceTarget,
                                                                this.Policy,
                                                                this.Environment,
                                                                this.PlatformType,
                                                                this.TitleId,
                                                                this.TitleVersion,
                                                                this.ClientVersion);

            string partnerToken = AuthorizationCache.GetPartnerToken(userToken,
                                                                     this.TitleId,
                                                                     this.TitleVersion,
                                                                     this.AudienceUri);

            return partnerToken;

        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\UDSPartner\UDSPartnerMonitoringBlock.cs ===
﻿using System;
using System.Collections.Generic;
using LiveN.Test.Services.Rewards;
using LiveN.Test.Framework.Configuration;
using Rewards.Contracts;

namespace LiveN.Test.Services.Multiplayer
{
    /// <summary>
    /// 
    /// </summary>
    public class UDSPartnerMonitoringBlock : MonitoringBlock
    {
        //private EnvironmentElement envConfig = null;
        private UDSPartnerUtil udsPartnerUtil;
        private string theEnv;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="environment"></param>
        public UDSPartnerMonitoringBlock(string environment)
            : base(environment)
        {
            //envConfig = Config.EnvironmentSettings.Environments[environment];
            udsPartnerUtil = new UDSPartnerUtil(
                    this.Environment.UDSPartnerProfileService.ToString(),
                    this.Environment.UDSPartnerGameDataService.ToString(),
                    this.Environment.UDSPartnerMessageService.ToString(),
                    this.Environment.UDSPartnerFriendService.ToString(),
                    this.Environment.UDSPartnerPresenceService.ToString(),
                    this.Environment.StsSettings.StsUrl,
                    this.Environment.StsSettings.ClientCertSubject,
                    this.Environment.WindowsLiveIDSettings.LiveIdServiceTarget,
                    this.Environment.WindowsLiveIDSettings.Policy,
                    this.Environment.WindowsLiveIDSettings.Environment,
                    this.Environment.StsSettings.TitleId2,
                    this.Environment.StsSettings.TitleVersion2,
                    this.Environment.StsSettings.PlatformType,
                    this.Environment.StsSettings.ClientVersion,
                    this.Environment.StsSettings.AudienceUri_UserData);

            theEnv = environment;
        }

        /// <summary>
        /// 
        /// </summary>
        public override string Name
        {
            get { return "UDS Partner"; }
        }

        /// <summary>
        /// 
        /// </summary>
        public override string FullName
        {
            get { return "UDS Partner"; }
        }

        /// <summary>
        /// 
        /// </summary>
        public override int Priority
        {
            get
            {
                return 2;
            }
        }


        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public override List<TestInfo> GetTestNames()
        {
            return GetMonitoringTests();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public override List<IResult> RunTests()
        {
            List<IResult> results = new List<IResult>();

            string player1 = this.Environment.UserSettings[0].Membername;
            string player1Password = this.Environment.UserSettings[0].Password;

            //GetProfile
            results.Add(GetProfile(player1, player1Password));
            //if (results[0].Passed == false) { return results; }

            //GetProfileUserToken
            results.Add(GetProfileUserToken(player1, player1Password));
            //if (results[1].Passed == false) { return results; }

            //GetGames
            results.Add(GetGames(player1, player1Password));
            //if (results[2].Passed == false) { return results; }

            //GetMessageSumamries
            results.Add(GetMessageSummaries(player1, player1Password));
            //if (results[3].Passed == false) { return results; }

            //AddFriend
            results.Add(AddFriend(player1, player1Password));
            //if (results[4].Passed == false) { return results; }

            //PostPresence
            results.Add(PostPresence(player1, player1Password));
            //if (results[5].Passed == false) { return results; }

            return results;
        }

        [MonitoringTest(Name = "GetProfile", Id = "B8684ABD-5A2C-4804-A1A4-E7635D7786C2")]
        private Result<ProfileEx> GetProfile(string username, string password)
        {
            Result<ProfileEx> result = new Result<ProfileEx>();
            TestInfo testInfo = GetTestInfo();

            try
            {
                StartTest(testInfo);
                result = this.udsPartnerUtil.ProfileUtil.GetProfile(
                        username,
                        password,
                        "1",
                        "1",
                        "");
            }
            finally
            {
                EndTest(testInfo, result);
            }

            return result;
        }

        [MonitoringTest(Name = "GetProfileUserToken", Id = "B8684ABD-5A2C-4AAA-A1A4-E7635D7786C2")]
        private Result<ProfileEx> GetProfileUserToken(string username, string password)
        {
            Result<ProfileEx> result = new Result<ProfileEx>();
            TestInfo testInfo = GetTestInfo();

            try
            {
                StartTest(testInfo);
                result = this.udsPartnerUtil.ProfileUtil.GetProfileUserToken(
                        username,
                        password,
                        "1",
                        "1",
                        "");
            }
            finally
            {
                EndTest(testInfo, result);
            }

            return result;
        }

        [MonitoringTest(Name = "GetGames", Id = "A5684ABD-5A2C-4804-A1A4-E7635D7786C2")]
        private Result<Games> GetGames(string username, string password)
        {
            Result<Games> result = new Result<Games>();
            TestInfo testInfo = GetTestInfo();

            try
            {
                StartTest(testInfo);
                result = this.udsPartnerUtil.GameDataUtil.GetGames(
                        username,
                        password,
                        "rewardshead",
                        "0",
                        "50");
            }
            finally
            {
                EndTest(testInfo, result);
            }

            return result;
        }

        [MonitoringTest(Name = "GetMessageSummaries", Id = "A5684123-5A2C-4804-A1A4-E7635D7786C2")]
        private Result<MessageSummariesResponse> GetMessageSummaries(string username, string password)
        {
            Result<MessageSummariesResponse> result = new Result<MessageSummariesResponse>();
            TestInfo testInfo = GetTestInfo();

            try
            {
                StartTest(testInfo);
                result = this.udsPartnerUtil.MessageUtil.GetMessageSummaries(
                        username,
                        password,
                        "hashcode");
            }
            finally
            {
                EndTest(testInfo, result);
            }

            return result;
        }

        [MonitoringTest(Name = "AddFriend", Id = "A568BCD23-5A2C-4804-A1A4-E7635D7786C2")]
        private Result<bool> AddFriend(string username, string password)
        {
            Result<bool> result = new Result<bool>();
            TestInfo testInfo = GetTestInfo();

            try
            {
                string gamertag = "rewardshead";

                if (theEnv.ToLower().StartsWith("cert"))
                {
                    gamertag = "MP Cert Test";
                }

                StartTest(testInfo);
                result = this.udsPartnerUtil.FriendUtil.AddFriend(
                        username,
                        password,
                        gamertag);
            }
            finally
            {
                EndTest(testInfo, result);
            }

            return result;
        }

        [MonitoringTest(Name = "PostPresence", Id = "A5684123-533C-4804-A1A4-E7635D7786C2")]
        private Result<bool> PostPresence(string username, string password)
        {
            Result<bool> result = new Result<bool>();
            TestInfo testInfo = GetTestInfo();

            try
            {
                StartTest(testInfo);
                result = this.udsPartnerUtil.PresenceUtil.PostPresence(username, password);
            }
            finally
            {
                EndTest(testInfo, result);
            }

            return result;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\UDSPartner\UDSPartnerGameDataUtil.cs ===
﻿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using LiveN.Test.Common;
using LiveN.Test.Framework.Authorization;
using LiveN.Test.Services.Multiplayer;
using Rewards.Contracts;
using LiveN.Test.Services;

namespace LiveN.Test.Services.Rewards
{
    /// <summary>
    /// 
    /// </summary>
    public class UDSPartnerGameDataUtil: ServiceBaseUtil
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="profileUrl"></param>
        /// <param name="stsUrl"></param>
        /// <param name="clientCertSubject"></param>
        /// <param name="liveIdServiceTarget"></param>
        /// <param name="policy"></param>
        /// <param name="environment"></param>
        /// <param name="titleId"></param>
        /// <param name="titleVersion"></param>
        /// <param name="platformType"></param>
        /// <param name="clientVersion"></param>
        public UDSPartnerGameDataUtil(string gameDataUrl, string stsUrl, string clientCertSubject, string liveIdServiceTarget, string policy, string environment, string titleId, string titleVersion, string platformType, string clientVersion)
            : base(stsUrl, clientCertSubject, liveIdServiceTarget, policy, environment, titleId, titleVersion, platformType, clientVersion)
        {
            this.AuthorizationCache = new AuthorizationCache(
                stsUrl,
                clientCertSubject);

            this.GameDataUrl = new Uri(gameDataUrl);
        }

        /// <summary>
        /// 
        /// </summary>
        public Uri GameDataUrl
        {
            get;
            set;
        }

        public new AuthorizationCache AuthorizationCache
        {
            get;
            private set;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="memberName"></param>
        /// <param name="password"></param>
        /// <param name="gameId"></param>
        /// <param name="gamertags"></param>
        /// <returns></returns>
        public Result<Games> GetGames(string memberName, string password, string gamertags, string pageStart, string pageCount)
        {
            Result<Games> result = new Result<Games>();

            try
            {
                TraceEx.TraceStart("Getting Games of user with WLID {0}...", memberName);

                string partnerToken = GetPartnerToken(memberName, password);
                UDSPartnerGameDataService gameDataProxy = GetGameDataProxy(this.GameDataUrl.ToString(), partnerToken);

                result.Start();
                result.ReturnValue = gameDataProxy.GetGames(gamertags, pageStart, pageCount);
                result.Passed = true;
                Trace.TraceInformation("Successfully got games for user with WLID {0}...", memberName);
            }
            catch (Exception e)
            {
                result.Error= e;
                TraceError(ServiceError.Unknown, e, "Error getting games");
            }
            finally
            {
                result.Stop();
                TraceEx.TraceStop("Completed getting games.  Took {0}ms.", result.Latency.TotalMilliseconds);
            }

            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="memberName"></param>
        /// <param name="password"></param>
        /// <param name="gamertags"></param>
        /// <param name="pageStart"></param>
        /// <param name="pageCount"></param>
        /// <returns></returns>
        public Result<bool> GetAchievements(string memberName, string password, string gameId, string gamertags)
        {
            Result<bool> result = new Result<bool>();
            result.ReturnValue = false;

            try
            {
                TraceEx.TraceStart("Getting Achievements of user with WLID {0}...", memberName);

                string partnerToken = GetPartnerToken(memberName, password);
                UDSPartnerGameDataService gameDataProxy = GetGameDataProxy(this.GameDataUrl.ToString(), partnerToken);

                result.Start();
                gameDataProxy.GetAchievements(gameId, gamertags);
                result.ReturnValue = true;
                Trace.TraceInformation("Successfully got achievements for user with WLID {0}...", memberName);
            }
            catch (Exception e)
            {
                result.Error= e;
                TraceError(ServiceError.Unknown, e, "Error getting achievements");
            }
            finally
            {
                result.Stop();
                TraceEx.TraceStop("Completed getting achievements.  Took {0}ms.", result.Latency.TotalMilliseconds);
            }

            return result;
        }

        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="userToken"></param>
        /// <returns></returns>
        private static UDSPartnerGameDataService GetGameDataProxy(string url, string partnerToken)
        {
            return GetGameDataProxy(url, "en-US", ((int)Leet.Core.Platforms.PlatformType.Mobile).ToString(), partnerToken);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="locale"></param>
        /// <param name="platformType"></param>
        /// <param name="partnerToken"></param>
        /// <returns></returns>
        private static UDSPartnerGameDataService GetGameDataProxy(string url, string locale, string platformType, string partnerToken)
        {
            UDSPartnerGameDataService gameDataService = new UDSPartnerGameDataService(url);
            gameDataService.Locale = locale;
            gameDataService.PlatformType = platformType;
            gameDataService.PartnerAuthorizationToken = partnerToken;
            return gameDataService;
        }

        private new string GetPartnerToken(string memberName, string password)
        {
            string userToken = AuthorizationCache.GetUserToken( memberName,
                                                                password,
                                                                this.LiveIdServiceTarget,
                                                                this.Policy,
                                                                this.Environment,
                                                                this.PlatformType,
                                                                this.TitleId,
                                                                this.TitleVersion,
                                                                this.ClientVersion);

            string partnerToken = AuthorizationCache.GetPartnerToken(userToken,
                                                                     this.TitleId,
                                                                     this.TitleVersion,
                                                                     this.AudienceUri);

            return partnerToken;
        
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\UDSPartner\UDSPartnerPresenceUtil.cs ===
﻿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using LiveN.Test.Common;
using LiveN.Test.Framework.Authorization;
using LiveN.Test.Services.Multiplayer;
using Rewards.Contracts;
using LiveN.Test.Services;

namespace LiveN.Test.Services.Rewards
{
    /// <summary>
    /// 
    /// </summary>
    public class UDSPartnerPresenceUtil : ServiceBaseUtil
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="profileUrl"></param>
        /// <param name="stsUrl"></param>
        /// <param name="clientCertSubject"></param>
        /// <param name="liveIdServiceTarget"></param>
        /// <param name="policy"></param>
        /// <param name="environment"></param>
        /// <param name="titleId"></param>
        /// <param name="titleVersion"></param>
        /// <param name="platformType"></param>
        /// <param name="clientVersion"></param>
        public UDSPartnerPresenceUtil(string presenceUrl, string stsUrl, string clientCertSubject, string liveIdServiceTarget, string policy, string environment, string titleId, string titleVersion, string platformType, string clientVersion)
            : base(stsUrl, clientCertSubject, liveIdServiceTarget, policy, environment, titleId, titleVersion, platformType, clientVersion)
        {
            this.AuthorizationCache = new AuthorizationCache(
                stsUrl,
                clientCertSubject);

            this.PresenceUrl = new Uri(presenceUrl);
        }

        /// <summary>
        /// 
        /// </summary>
        public Uri PresenceUrl
        {
            get;
            set;
        }

        public new AuthorizationCache AuthorizationCache
        {
            get;
            private set;
        }

        public Result<bool> PostPresence(string memberName, string password)
        {
            Result<bool> result = new Result<bool>();

            try
            {
                TraceEx.TraceStart("Updating Presence of user with WLID {0}...", memberName);

                string partnerToken = GetPartnerToken(memberName, password);
                UDSPartnerPresenceService presenceProxy = GetPresenceProxy(this.PresenceUrl.ToString(), partnerToken);

                result.Start();
                result.ReturnValue = presenceProxy.PostPresence();
                result.Passed = true;
                Trace.TraceInformation("Successfully updated presence for user with WLID {0}...", memberName);
            }
            catch (Exception e)
            {
                result.Error = e;
                TraceError(ServiceError.Unknown, e, "Error updating presence");
            }
            finally
            {
                result.Stop();
                TraceEx.TraceStop("Completed updating presence.  Took {0}ms.", result.Latency.TotalMilliseconds);
            }

            return result;
        }


        /// <summary>
        /// 
        /// </summary>
        /// <param name="userToken"></param>
        /// <returns></returns>
        private static UDSPartnerPresenceService GetPresenceProxy(string url, string partnerToken)
        {
            return GetPresenceProxy(url, "en-US", ((int)Leet.Core.Platforms.PlatformType.Mobile).ToString(), partnerToken);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="locale"></param>
        /// <param name="platformType"></param>
        /// <param name="partnerToken"></param>
        /// <returns></returns>
        private static UDSPartnerPresenceService GetPresenceProxy(string url, string locale, string platformType, string partnerToken)
        {
            UDSPartnerPresenceService presenceService = new UDSPartnerPresenceService(url);
            presenceService.Locale = locale;
            presenceService.PlatformType = platformType;
            presenceService.PartnerAuthorizationToken = partnerToken;
            return presenceService;
        }

        private new string GetPartnerToken(string memberName, string password)
        {
            string userToken = AuthorizationCache.GetUserToken(memberName,
                                                                password,
                                                                this.LiveIdServiceTarget,
                                                                this.Policy,
                                                                this.Environment,
                                                                this.PlatformType,
                                                                this.TitleId,
                                                                this.TitleVersion,
                                                                this.ClientVersion);

            string partnerToken = AuthorizationCache.GetPartnerToken(userToken,
                                                                     this.TitleId,
                                                                     this.TitleVersion,
                                                                     this.AudienceUri);

            return partnerToken;

        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\UDSPartner\UDSPartnerUtil.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;
using LiveN.Test.Common;
using LiveN.Test.Framework.Authorization;
using LiveN.Test.Services.Multiplayer;
using LiveN.Test.Services;

namespace LiveN.Test.Services.Rewards
{
    /// <summary>
    /// Wrapper for all UDS Partner service proxies.
    /// </summary>
    public class UDSPartnerUtil
    {
        
        public UDSPartnerUtil(
            string profileUrl,
            string gameDataUrl,
            string messageUrl,
            string friendUrl,
            string presenceUrl,
            string stsUrl,
            string clientCertSubject,
            string liveIdServiceTarget,
            string policy,
            string environment,
            string titleId,
            string titleVersion,
            string platformType,
            string clientVersion,
            string audienceUri)
        {
            this.ProfileUtil = new UDSPartnerProfileUtil(profileUrl, stsUrl, clientCertSubject, liveIdServiceTarget, policy, environment, titleId, titleVersion, platformType, clientVersion);
            this.ProfileUtil.AudienceUri = audienceUri;

            this.GameDataUtil = new UDSPartnerGameDataUtil(gameDataUrl, stsUrl, clientCertSubject, liveIdServiceTarget, policy, environment, titleId, titleVersion, platformType, clientVersion);
            this.GameDataUtil.AudienceUri = audienceUri;

            this.MessageUtil = new UDSPartnerMessageUtil(messageUrl, stsUrl, clientCertSubject, liveIdServiceTarget, policy, environment, titleId, titleVersion, platformType, clientVersion);
            this.MessageUtil.AudienceUri = audienceUri;

            this.FriendUtil = new UDSPartnerFriendUtil(friendUrl, stsUrl, clientCertSubject, liveIdServiceTarget, policy, environment, titleId, titleVersion, platformType, clientVersion);
            this.FriendUtil.AudienceUri = audienceUri;

            this.PresenceUtil = new UDSPartnerPresenceUtil(presenceUrl, stsUrl, clientCertSubject, liveIdServiceTarget, policy, environment, titleId, titleVersion, platformType, clientVersion);
            this.PresenceUtil.AudienceUri = audienceUri;

            AuthorizationCache = new AuthorizationCache(
                stsUrl,
                clientCertSubject);
        }

        /// <summary>
        /// 
        /// </summary>
        public UDSPartnerProfileUtil ProfileUtil
        {
            get;
            private set;
        }

        /// <summary>
        /// 
        /// </summary>
        public UDSPartnerGameDataUtil GameDataUtil
        {
            get;
            private set;
        }

        /// <summary>
        /// 
        /// </summary>
        public UDSPartnerMessageUtil MessageUtil
        {
            get;
            private set;
        }

        /// <summary>
        /// 
        /// </summary>
        public UDSPartnerFriendUtil FriendUtil
        {
            get;
            private set;
        }

        /// <summary>
        /// 
        /// </summary>
        public UDSPartnerPresenceUtil PresenceUtil
        {
            get;
            private set;
        }

        public AuthorizationCache AuthorizationCache
        {
            get;
            private set;
        }


        ///// <summary>
        ///// 
        ///// </summary>
        ///// <returns></returns>
        //public Result<bool> GetRpsTicket(string memberName, string password)
        //{
        //    Result<bool> result = new Result<bool>();

        //    try
        //    {
        //        TraceEx.TraceStart("Starting IDCRL/Windows Live ID prereq check validation...");
        //        result.Start();
        //        string loginTicket = this.AuthorizationCache.GetLoginTicket(memberName, password, this.liveIdTarget, this.liveIdPolicy, this.liveIdEnvironment);
        //        result.ReturnValue = true;
        //        TraceEx.TraceVerbose("RPS ticket={0}", loginTicket);
        //        Trace.TraceInformation("Verified that {0} can login via IDCRL/Windows Live ID.", memberName);                
        //    }
        //    catch (Exception e)
        //    {
        //        ServiceBaseUtil.TraceError(ServiceError.PrereqIdcrl, e, "Unable to get RPS ticket for {0}.  Verify the username and password are correct", memberName);
        //    }
        //    finally
        //    {
        //        result.Stop();
        //        TraceEx.TraceStop("Completed IDCRL/Windows Live ID validation.  Took {0}ms.", result.Latency.TotalMilliseconds);
        //    }

        //    return result;
        //}

        ///// <summary>
        ///// 
        ///// </summary>
        ///// <returns></returns>
        //public Result<bool> GetStsUserToken(string memberName, string password, string platformType, string titleId, string titleVersion, string clientVersion)
        //{
        //    Result<bool> result = new Result<bool>();

        //    try
        //    {
        //        TraceEx.TraceStart("Starting STS User Token prereq check validation...");
        //        result.Start();
        //        string userToken = this.AuthorizationCache.GetUserToken(
        //                                memberName,
        //                                password,
        //                                platformType,
        //                                titleId,
        //                                titleVersion,
        //                                clientVersion);
        //        TraceEx.TraceVerbose("STS User Token={0}", userToken);

        //        //if this is a machine token, the user doesn't have an XBL account
        //        if (!Authorization.IsUserSecurityToken(userToken))
        //        {
        //            TraceEx.TraceError((int)ServiceError.PrereqVerifyXblUser, "The platform STS service returned a Machine token for {0}; this user does not have an Xbox Live account.", memberName);
        //            result.ReturnValue = false;
        //        }
        //        Trace.TraceInformation("Verified that {0} can obtain an STS user token.", memberName);
        //        result.ReturnValue = true;
        //    }
        //    catch (Exception e)
        //    {
        //        ServiceBaseUtil.TraceError(ServiceError.PrereqStsUserToken, e, "Unable to get an STS user token for {0}, with title ID {1} and title version {2}.", memberName, titleId, titleVersion);
        //    }
        //    finally
        //    {
        //        result.Stop();
        //        TraceEx.TraceStop("Completed STS user token validation.  Took {0}ms.", result.Latency.TotalMilliseconds);
        //    }

        //    return result;
        //}

        ///// <summary>
        ///// 
        ///// </summary>
        ///// <returns></returns>
        //public Result<bool> GetStsPartnerToken(string memberName, string password, string platformType, string titleId, string titleVersion, string clientVersion, string audienceUri)
        //{
        //    Result<bool> result = new Result<bool>();

        //    try
        //    {
        //        TraceEx.TraceStart("Starting STS Partner Token prereq check validation...");
        //        result.Start();
        //        string userToken = this.AuthorizationCache.GetUserToken(
        //                                memberName,
        //                                password,
        //                                platformType,
        //                                titleId,
        //                                titleVersion,
        //                                clientVersion);
        //        string partnerToken = this.AuthorizationCache.GetPartnerToken(
        //                                userToken,
        //                                titleId,
        //                                titleVersion,
        //                                audienceUri);
        //        result.ReturnValue = true;
        //        TraceEx.TraceVerbose("STS Partner Token={0}", partnerToken);
        //        Trace.TraceInformation("Verified that {0} can obtain an STS partner token.", memberName);
        //    }
        //    catch (Exception e)
        //    {
        //        ServiceBaseUtil.TraceError(ServiceError.PrereqStsPartnerToken, e, "Unable to get an STS partner token for {0}, with title ID {1}, title version {2} and audience Uri {3}", memberName, this.ProfileUtil.TitleId, this.ProfileUtil.TitleVersion, this.ProfileUtil.AudienceUri);
        //    }
        //    finally
        //    {
        //        result.Stop();
        //        TraceEx.TraceStop("Completed STS Partner Token validation.  Took {0}ms.", result.Latency.TotalMilliseconds);
        //    }

        //    return result;
        //}

        ///// <summary>
        ///// 
        ///// </summary>
        ///// <returns></returns>
        //public Result<bool> VerifyTitle(string memberName, string password, string platformType, string titleId, string titleVersion, string clientVersion)
        //{
        //    Result<bool> result = new Result<bool>();

        //    try
        //    {
        //        TraceEx.TraceStart("Starting Title ID/Version prereq check validation...");
        //        result.Start();
        //        string userToken = this.AuthorizationCache.GetUserToken(
        //                                memberName,
        //                                password,
        //                                platformType,
        //                                titleId,
        //                                titleVersion,
        //                                clientVersion);
        //        result.ReturnValue = true;
        //        Trace.TraceInformation("Verified that title ID {0} and title version {1}, for platform {2}, are valid.", titleId, titleVersion, platformType);
        //    }
        //    catch (Exception e)
        //    {
        //        ServiceBaseUtil.TraceError(ServiceError.PrereqVerifyTitle, e, "Unable verify that title ID {0} and title version {1} are valid and available.  Verify this title has been propped in GMS and xLast", titleId, titleVersion);
        //    }
        //    finally
        //    {
        //        result.Stop();
        //        TraceEx.TraceStop("Completed Title ID/Version validation.  Took {0}ms", result.Latency.TotalMilliseconds);
        //    }

        //    return result;
        //}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\WebSTS\WebStsMonitoringBlock.cs ===
﻿using System;
using System.Linq;
using System.Collections.Generic;
using LiveN.Test.Framework.Configuration;

namespace LiveN.Test.Services.WebSTS
{
    /// <summary>
    /// 
    /// </summary>
    public class WebStsMonitoringBlock: MonitoringBlock
    {
        private WebStsUtil webStsUtil;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="environment"></param>
        public WebStsMonitoringBlock(string environment)
            : base(environment)
        {
            this.webStsUtil = new WebStsUtil(this.Environment.StsSettings.WebStsUrl, this.Environment.StsSettings.WebStsLiveIdUrl);
        }

        /// <summary>
        /// 
        /// </summary>
        public override string Name
        {
            get { return "WebSTS"; }
        }

        /// <summary>
        /// 
        /// </summary>
        public override string FullName
        {
            get { return "WebSTS"; }
        }

        /// <summary>
        /// 
        /// </summary>
        public override int Priority
        {
            get
            {
                return 8;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public override List<TestInfo> GetTestNames()
        {
            return GetMonitoringTests();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public override List<IResult> RunTests()
        {
            List<IResult> results = new List<IResult>();

            string player1 = this.Environment.UserSettings[0].Membername;
            string player1Password = this.Environment.UserSettings[0].Password;
            TitleElement title = this.Environment.Titles.OfType<TitleElement>().First<TitleElement>(t => t.ConsoleType == LiveN.Test.ConsoleType.WebGames);

            results.Add(GetUserToken(player1, player1Password, title.Id, title.Version));
            results.Add(GetPartnerToken(player1, player1Password, title.Id, title.Version, this.Environment.StsSettings.AudienceUri_MultiPlayer));
            return results;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="username"></param>
        /// <param name="password"></param>
        /// <param name="titleId"></param>
        /// <param name="titleVersion"></param>
        /// <returns></returns>
        [MonitoringTest(Name = "GetUserTokenXml", Id = "A42BD413-5300-4373-887F-511389F271B9")]
        private Result<string> GetUserToken(string username, string password, string titleId, string titleVersion)
        {
            Result<string> result = new Result<string>();
            TestInfo testInfo = GetTestInfo();

            try
            {
                StartTest(testInfo);
                result = this.webStsUtil.GetUserToken(
                        username,
                        password,
                        titleId,
                        titleVersion);
            }
            finally
            {
                EndTest(testInfo, result);
            }

            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="username"></param>
        /// <param name="password"></param>
        /// <param name="titleId"></param>
        /// <param name="titleVersion"></param>
        /// <param name="audienceUri"></param>
        /// <returns></returns>
        [MonitoringTest(Name = "GetPartnerTokenXml", Id = "E6666AE0-4415-40EE-9259-DF50878F933D")]
        private Result<string> GetPartnerToken(string username, string password, string titleId, string titleVersion, string audienceUri)
        {
            Result<string> result = new Result<string>();
            TestInfo testInfo = GetTestInfo();

            try
            {
                StartTest(testInfo);
                result = this.webStsUtil.GetPartnerToken(
                        username,
                        password,
                        titleId,
                        titleVersion,
                        audienceUri);
            }
            finally
            {
                EndTest(testInfo, result);
            }

            return result;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\WebSTS\WebStsUtil.cs ===
﻿using System;
using System.Diagnostics;
using LiveN.Test.Common;
using LiveN.Test.Framework;
using LiveN.Test.Services.Multiplayer;
using LiveN.Test.Framework.Authorization;

namespace LiveN.Test.Services.WebSTS
{
    public class WebStsUtil
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="webStsUrl"></param>
        /// <param name="webStsLiveIdUrl"></param>
        public WebStsUtil(string webStsUrl, string webStsLiveIdUrl)
        {
            this.WebStsUrl = webStsUrl;
            this.WebStsLiveIdUrl = webStsLiveIdUrl;
        }

        /// <summary>
        /// 
        /// </summary>
        public string WebStsUrl
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string WebStsLiveIdUrl
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="memberName"></param>
        /// <param name="password"></param>
        /// <returns></returns>
        public Result<string> GetUserToken(string memberName, string password, string titleId, string titleVersion)
        {
            Result<string> result = new Result<string>();

            try
            {
                WebStsService webSts = new WebStsService(this.WebStsUrl);
                string rpsCookie = GetRpsAuthCookie(memberName, password);

                TraceEx.TraceStart("Attempting to call GetUserTokenXml for {0} / {1}...", memberName, password); 
                result.Start();
                SecurityTokensResponse str = webSts.GetUserTokenXml(rpsCookie, titleId, titleVersion);
                if (String.IsNullOrEmpty(str.UserToken))
                    throw new ApplicationException(String.Format("No user token was returned for {0} / {1}, with title ID {2} and title version {3}", memberName, password, titleId, titleVersion));

                Trace.TraceInformation("Successfully got a user token for {0}, with title ID {1} and title version {2}", memberName, titleId, titleVersion);
                TraceEx.TraceVerbose("Partner Token:\r\n\r\n{0}", str.UserToken);
                result.Passed = true;
                result.ReturnValue = str.UserToken;
            }
            catch (Exception e)
            {
                ServiceBaseUtil.TraceError(ServiceError.GetUserTokenXml, e, "Error getting user token for {0} / {1}, with title ID {2} and title version {3}.", memberName, password, titleId, titleVersion);
                result.Error = e;
            }
            finally
            {
                result.Stop();
                TraceEx.TraceStop("Completed; GetUserTokenXml took {0}ms", result.Latency.TotalMilliseconds);
            }

            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="memberName"></param>
        /// <param name="password"></param>
        /// <param name="titleId"></param>
        /// <param name="titleVersion"></param>
        /// <param name="audienceUri"></param>
        /// <returns></returns>
        public Result<string> GetPartnerToken(string memberName, string password, string titleId, string titleVersion, string audienceUri)
        {
            Result<string> result = new Result<string>();

            try
            {
                WebStsService webSts = new WebStsService(this.WebStsUrl);
                string rpsCookie = GetRpsAuthCookie(memberName, password);

                TraceEx.TraceStart("Attempting to call GetPartnerTokenXml for {0} / {1}...", memberName, password);
                result.Start();
                SecurityTokensResponse str = webSts.GetPartnerTokenXml(rpsCookie, titleId, titleVersion, audienceUri);
                if (String.IsNullOrEmpty(str.PartnerToken))
                    throw new ApplicationException(String.Format("No partner token was returned for {0} / {1}, with title ID {2}, title version {3} and audience uri '{4}'", memberName, password, titleId, titleVersion, audienceUri));

                Trace.TraceInformation("Successfully got a partner token for {0}, with title ID {1}, title version {2} and audience uri '{3}'", memberName, titleId, titleVersion, audienceUri);
                TraceEx.TraceVerbose("Partner Token:\r\n\r\n{0}", str.PartnerToken);
                result.Passed = true;
                result.ReturnValue = str.PartnerToken;
            }
            catch (Exception e)
            {
                ServiceBaseUtil.TraceError(ServiceError.GetPartnerTokenXml, e, "Error getting partner token for {0} / {1}, with title ID {2}, title version {3} and audience uri '{4}'", memberName, password, titleId, titleVersion, audienceUri);
                result.Error = e;
            }
            finally
            {
                result.Stop();
                TraceEx.TraceStop("Completed; GetPartnerTokenXml took {0}ms", result.Latency.TotalMilliseconds);
            }

            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="memberName"></param>
        /// <param name="password"></param>
        /// <returns></returns>
        private string GetRpsAuthCookie(string memberName, string password)
        {
            string key = this.WebStsUrl.ToLower() + this.WebStsLiveIdUrl.ToLower() + memberName.ToLower();
            string rpsCookie = AuthorizationCache.AuthCache.Get(key) as String;

            if (rpsCookie == null)
            {
                rpsCookie = LiveID.GetRpsAuthCookie(this.WebStsLiveIdUrl, memberName, password);
                AuthorizationCache.AddToCache(key, rpsCookie, TimeSpan.FromHours(4));   //MBI == 8 hours, so 4 to be safe
            }

            return rpsCookie;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\WebSTS\WebStsService.cs ===
﻿using System;
using System.Collections.Generic;
using LiveN.Test.Common.Web;
using LiveN.Test.Framework;

namespace LiveN.Test.Services.WebSTS
{
    /// <summary>
    /// 
    /// </summary>
    public class WebStsService: RestRequest
    {
        public const string GetUserTokensUrlFormat = "/usertoken?gameId={gameId}&gameVersion={gameVersion}";
        public const string GetPartnerTokensUrlFormat = "/partnertoken?gameId={gameId}&gameVersion={gameVersion}&audienceUri={audienceUri}";
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="baseUri"></param>
        public WebStsService(string baseUri)
        {
            this.BaseUri = baseUri;
        }

        /// <summary>
        /// 
        /// </summary>
        public string BaseUri
        {
            get;
            set;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="rpsCookie"></param>
        /// <param name="gameId"></param>
        /// <param name="gameVersion"></param>
        /// <returns></returns>
        public SecurityTokensResponse GetUserTokenXml(string rpsCookie, string gameId, string gameVersion)
        {
            Dictionary<string, string> httpHeaders = new Dictionary<string, string>();
            httpHeaders.Add("Cookie", String.Format("{0}={1}", LiveID.RpsSecAuthCookieName, rpsCookie));

            return GetUserTokenXml(httpHeaders, gameId, gameVersion);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="httpHeaders"></param>
        /// <param name="gameId"></param>
        /// <param name="gameVersion"></param>
        /// <returns></returns>
        public SecurityTokensResponse GetUserTokenXml(Dictionary<string, string> httpHeaders, string gameId, string gameVersion)
        {
            string url = this.BaseUri + GetUserTokensUrlFormat.Replace("{gameId}", gameId).Replace("{gameVersion}", gameVersion);
            RestResponse response = Get(url, httpHeaders);
            SecurityTokensResponse tokens = new SecurityTokensResponse(response.Body);
            return tokens;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="rpsCookie"></param>
        /// <param name="gameId"></param>
        /// <param name="gameVersion"></param>
        /// <param name="audienceUri"></param>
        /// <returns></returns>
        public SecurityTokensResponse GetPartnerTokenXml(string rpsCookie, string gameId, string gameVersion, string audienceUri)
        {
            Dictionary<string, string> httpHeaders = new Dictionary<string, string>();
            httpHeaders.Add("Cookie", String.Format("{0}={1}", LiveID.RpsSecAuthCookieName, rpsCookie));

            return GetPartnerTokenXml(httpHeaders, gameId, gameVersion, audienceUri);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="httpHeaders"></param>
        /// <param name="gameId"></param>
        /// <param name="gameVersion"></param>
        /// <param name="audienceUri"></param>
        /// <returns></returns>
        public SecurityTokensResponse GetPartnerTokenXml(Dictionary<string, string> httpHeaders, string gameId, string gameVersion, string audienceUri)
        {
            string url = this.BaseUri + GetPartnerTokensUrlFormat.Replace("{gameId}", gameId).Replace("{gameVersion}", gameVersion).Replace("{audienceUri}", audienceUri);
            RestResponse response = Get(url, httpHeaders);
            SecurityTokensResponse tokens = new SecurityTokensResponse(response.Body);
            return tokens;
        }  
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\UDSPartner\UDSPartnerProfileUtil.cs ===
﻿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using LiveN.Test.Common;
using LiveN.Test.Framework.Authorization;
using LiveN.Test.Services.Multiplayer;
using Rewards.Contracts;
using LiveN.Test.Services;

namespace LiveN.Test.Services.Rewards
{
    /// <summary>
    /// 
    /// </summary>
    public class UDSPartnerProfileUtil: ServiceBaseUtil
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="profileUrl"></param>
        /// <param name="stsUrl"></param>
        /// <param name="clientCertSubject"></param>
        /// <param name="liveIdServiceTarget"></param>
        /// <param name="policy"></param>
        /// <param name="environment"></param>
        /// <param name="titleId"></param>
        /// <param name="titleVersion"></param>
        /// <param name="platformType"></param>
        /// <param name="clientVersion"></param>
        public UDSPartnerProfileUtil(string profileUrl, string stsUrl, string clientCertSubject, string liveIdServiceTarget, string policy, string environment, string titleId, string titleVersion, string platformType, string clientVersion)
            : base(stsUrl, clientCertSubject, liveIdServiceTarget, policy, environment, titleId, titleVersion, platformType, clientVersion)
        {
            this.AuthorizationCache = new AuthorizationCache(
                stsUrl,
                clientCertSubject);

            this.ProfileUrl = new Uri(profileUrl);
        }

        /// <summary>
        /// 
        /// </summary>
        public Uri ProfileUrl
        {
            get;
            set;
        }

        public new AuthorizationCache AuthorizationCache
        {
            get;
            private set;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="memberName"></param>
        /// <param name="password"></param>
        /// <param name="sessionId"></param>
        /// <param name="inviteEmailTo"></param>
        /// <returns></returns>
        public Result<ProfileEx> GetProfile(string memberName, string password, string sectionFlags, string friendsSectionFlags, string gamertag)
        {
            Result<ProfileEx> result = new Result<ProfileEx>();
            
            try
            {
                TraceEx.TraceStart("Getting Profile of user with WLID {0}...", memberName );

                string partnerToken = GetPartnerToken(memberName, password);
                UDSPartnerProfileService profileProxy = GetProfileProxy(this.ProfileUrl.ToString(), partnerToken, null);

                result.Start();
                result.ReturnValue = profileProxy.GetProfile(sectionFlags, friendsSectionFlags, gamertag);
                result.Passed = true;
                Trace.TraceInformation("Successfully got profile for user with WLID {0}...", memberName );
            }
            catch (Exception e)
            {
                result.Error= e;
                TraceError(ServiceError.Unknown, e, "Error getting profile");
            }
            finally
            {
                result.Stop();
                TraceEx.TraceStop("Completed getting profile.  Took {0}ms.", result.Latency.TotalMilliseconds);
            }

            return result;
        }

        public Result<ProfileEx> GetProfileUserToken(string memberName, string password, string sectionFlags, string friendsSectionFlags, string gamertag)
        {
            Result<ProfileEx> result = new Result<ProfileEx>();

            try
            {
                TraceEx.TraceStart("Getting Profile [USER TOKEN] of user with WLID {0}...", memberName);

                string userToken = GetUserToken(memberName, password);
                UDSPartnerProfileService profileProxy = GetProfileProxy(this.ProfileUrl.ToString(), null, userToken);

                result.Start();
                result.ReturnValue = profileProxy.GetProfile(sectionFlags, friendsSectionFlags, gamertag);
                result.Passed = true;
                Trace.TraceInformation("Successfully got profile [USER TOKEN] for user with WLID {0}...", memberName);
            }
            catch (Exception e)
            {
                result.Error = e;
                TraceError(ServiceError.Unknown, e, "Error getting profile [USER TOKEN]");
            }
            finally
            {
                result.Stop();
                TraceEx.TraceStop("Completed getting profile [USER TOKEN].  Took {0}ms.", result.Latency.TotalMilliseconds);
            }

            return result;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="memberName"></param>
        /// <param name="password"></param>
        /// <param name="profile"></param>
        /// <param name="sectionFlags"></param>
        /// <param name="friendsSectionFlags"></param>
        /// <param name="gamertag"></param>
        /// <returns></returns>
        public Result<bool> PostProfile(string memberName, string password, ProfileEx profile, string sectionFlags, string friendsSectionFlags, string gamertag)
        {
            Result<bool> result = new Result<bool>();

            try
            {
                TraceEx.TraceStart("Updating Profile of user with WLID {0}...", memberName);

                string partnerToken = GetPartnerToken(memberName, password);
                UDSPartnerProfileService profileProxy = GetProfileProxy(this.ProfileUrl.ToString(), partnerToken, null);

                result.Start();
                profileProxy.PostProfile(profile, sectionFlags, friendsSectionFlags, gamertag);
                result.ReturnValue = true;
                Trace.TraceInformation("Successfully updated profile for user with WLID {0}...\n{1}", memberName);
            }
            catch (Exception e)
            {
                result.Error= e;
                TraceError(ServiceError.SendInvite, e, "Error getting profile");
            }
            finally
            {
                result.Stop();
                TraceEx.TraceStop("Completed updating profile.  Took {0}ms.", result.Latency.TotalMilliseconds);
            }

            return result;
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="userToken"></param>
        /// <returns></returns>
        private static UDSPartnerProfileService GetProfileProxy(string url, string partnerToken, string userToken)
        {
            return GetProfileProxy(url, "en-US", ((int)Leet.Core.Platforms.PlatformType.Mobile).ToString(), partnerToken, userToken);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="locale"></param>
        /// <param name="platformType"></param>
        /// <param name="partnerToken"></param>
        /// <returns></returns>
        private static UDSPartnerProfileService GetProfileProxy(string url, string locale, string platformType, string partnerToken, string userToken)
        {
            UDSPartnerProfileService profileService = new UDSPartnerProfileService(url);
            profileService.Locale = locale;
            profileService.PlatformType = platformType;
            if (partnerToken != null)
            {
                profileService.PartnerAuthorizationToken = partnerToken;
            }
            if (userToken != null)
            {
                profileService.UserAuthorizationToken = userToken;
            }
            return profileService;
        }

        private new string GetUserToken(string memberName, string password)
        {
            string userToken = AuthorizationCache.GetUserToken(memberName,
                                                                password,
                                                                this.LiveIdServiceTarget,
                                                                this.Policy,
                                                                this.Environment,
                                                                this.PlatformType,
                                                                this.TitleId,
                                                                this.TitleVersion,
                                                                this.ClientVersion);

            return userToken;
        }

        private new string GetPartnerToken(string memberName, string password)
        {
            string userToken = AuthorizationCache.GetUserToken( memberName,
                                                                password,
                                                                this.LiveIdServiceTarget,
                                                                this.Policy,
                                                                this.Environment,
                                                                this.PlatformType,
                                                                this.TitleId,
                                                                this.TitleVersion,
                                                                this.ClientVersion);

            string partnerToken = AuthorizationCache.GetPartnerToken(userToken,
                                                                     this.TitleId,
                                                                     this.TitleVersion,
                                                                     this.AudienceUri);

            return partnerToken;
        
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\TestCommonCode\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\UDSPartner\UDSPartnerProfileService.cs ===
﻿using System;
using System.Collections.Generic;
using LiveN.Test.Common.Web;
using LiveN.Test.Framework.Web;
using Rewards.Contracts;

namespace LiveN.Test.Services.Rewards
{
    /// <summary>
    /// 
    /// </summary>
    public class UDSPartnerProfileService : XboxWcfService
    {
        public const string PostProfile_RelativePathAndQuery = "/";
        public const string GetProfilePartner_RelativePathAndQuery = "/profile?sectionFlags={sectionFlags}&friendsSectionFlags={friendsSectionFlags}&gamertag={gamertag}";
        public const string FreeGamertagChange_RelativePathAndQuery = "/gamertag/change?gamertag={gamertag}";

        /// <summary>
        /// 
        /// </summary>
        /// <param name="baseUri"></param>
        public UDSPartnerProfileService(string baseUri)
            : base(baseUri)
        {

        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="sectionFlags"></param>
        /// <param name="friendsSectionFlags"></param>
        /// <param name="gamertag"></param>
        /// <returns></returns>
        public ProfileEx GetProfile(
            string sectionFlags,
            string friendsSectionFlags,
            string gamertag)
        {
            string url = this.BaseUri + GetProfilePartner_RelativePathAndQuery;
            url = url.Replace("{sectionFlags}", sectionFlags);
            url = url.Replace("{friendsSectionFlags}", friendsSectionFlags);
            url = url.Replace("{gamertag}", gamertag);

            RestResponse response = Get(url, GetHttpHeaders());

            if (!response.Succeeded)
            {
                throw new RestException(response);
            }
            return DeserializeObject<ProfileEx>(response.Body);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="sectionFlags"></param>
        /// <param name="friendsSectionFlags"></param>
        /// <param name="gamertag"></param>
        /// <returns></returns>
        public bool PostProfile(
            ProfileEx profile,
            string sectionFlags,
            string friendsSectionFlags,
            string gamertag)
        {
            string url = this.BaseUri + PostProfile_RelativePathAndQuery;

            string body = SerializeObject(profile);

            RestResponse response = Post(url, GetHttpHeaders(), body);

            if (!response.Succeeded)
            {
                throw new RestException(response);
            }
            return true;
        }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\ServicesCommon\WebSTS\SecurityTokensResponse.cs ===
﻿using System;
using System.Xml;
using LiveN.Test.Common;

namespace LiveN.Test.Services.WebSTS
{
    /// <summary>
    /// 
    /// </summary>
    public class SecurityTokensResponse
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="response"></param>
        /// <param name="tokenType"></param>
        public SecurityTokensResponse(string response)
        {
            ParseTokens(response);
        }

        /// <summary>
        /// 
        /// </summary>
        public string UserToken
        {
            get;
            private set;
        }

        /// <summary>
        /// 
        /// </summary>
        public string PartnerToken
        {
            get;
            private set;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="response"></param>
        /// <param name="tokenType"></param>
        protected void ParseTokens(string response)
        {
            try
            {
                XmlDocumentEx xmlResponse = new XmlDocumentEx(response, true);

                XmlNode temp = xmlResponse.SelectSingleNode("dfltns:Tokens/dfltns:User", xmlResponse.NamespaceManager);
                if (temp != null)
                {
                    this.UserToken = temp.InnerText;
                }

                temp = xmlResponse.SelectSingleNode("dfltns:Tokens/dfltns:Partner", xmlResponse.NamespaceManager);
                if (temp != null)
                {
                    this.PartnerToken = temp.InnerText;
                }
            }
            catch (XmlException)
            {
                throw new ApplicationException(String.Format("Invalid Xml returned by WebSTS service:\r\n\r\n{0}", response));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Templates\LoadTestSample\LoadTestSample\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("LoadTestSample")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("LoadTestSample")]
[assembly: AssemblyCopyright("Copyright © Microsoft 2010")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM componenets.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("5e30b014-dfbc-4dd7-bd31-1c39b92cbc6e")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\TestCommonCode\DataDrivenTest\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("DataDrivenTest")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("86e7aa77-3af2-4205-87e9-2e08d6b3040c")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Templates\LoadTestSample\LoadTestSample\WebTests\WebHomePageTests.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.VisualStudio.TestTools.WebTesting;

namespace LoadTestSample.WebTests
{
    public class VerifyHomePage : WebTest
    {
        public VerifyHomePage()
        {
            this.PreAuthenticate = true;
        }

        public override IEnumerator<WebTestRequest> GetRequestEnumerator()
        {
            WebTestRequest webRequest = new WebTestRequest("http://www.xbox.com");
            webRequest.ParseDependentRequests = false;

            yield return webRequest;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\TestCommonCode\DataDrivenTest\SerializableCollection.cs ===
﻿using System;
using System.Collections.Generic;
using System.Xml.Serialization;
using System.Runtime.Serialization;

namespace DataDrivenTest
{
    /// <summary>
    /// Xml serializable dictionary object.
    /// </summary>
    /// <typeparam name="TKey">Key type</typeparam>
    /// <typeparam name="TValue">Object type</typeparam>
    [SerializableAttribute]
    public class XmlSerializableDictionary<TKey, TValue> : Dictionary<TKey, TValue>, IXmlSerializable
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="XmlSerializableDictionary&lt;TKey, TValue&gt;"/> class.
        /// </summary>
        public XmlSerializableDictionary()
            : base() { }

        /// <summary>
        /// Initializes a new instance of the <see cref="XmlSerializableDictionary&lt;TKey, TValue&gt;"/> class.
        /// </summary>
        /// <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo"></see> object containing the   
        /// information required to serialize the <see cref="T:System.Collections.Generic.Dictionary`2"></see>.</param>
        /// <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext"></see> structure 
        /// containing the source and destination of the serialized stream associated with the 
        /// <see  cref="T:System.Collections.Generic.Dictionary`2"></see>.</param>

        protected XmlSerializableDictionary(SerializationInfo info, StreamingContext context)
            : base(info, context) { }
        #endregion

        #region Constants
        private const string ITEM = "item";
        private const string KEY = "key";
        private const string VALUE = "value";
        #endregion

        #region IXmlSerializable Members
        /// <summary>
        /// This property is reserved, apply the <see cref="T:System.Xml.Serialization.XmlSchemaProviderAttribute"></see> to 
        /// the class instead.
        /// </summary>
        /// <returns>An <see cref="T:System.Xml.Schema.XmlSchema"></see> that describes the XML representation of the object that is 
        /// produced by the <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)"></see> method 
        /// and consumed by the <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)"></see> 
        /// method.
        /// </returns>
        public System.Xml.Schema.XmlSchema GetSchema()
        {
            return null;
        }

        /// <summary>
        /// Generates an object from its XML representation.
        /// </summary>
        /// <param name="reader">The <see cref="T:System.Xml.XmlReader"></see> stream from which the object is deserialized.</param>
        public void ReadXml(System.Xml.XmlReader reader)
        {
            XmlSerializer keySerializer = new XmlSerializer(typeof(TKey));
            XmlSerializer valueSerializer = new XmlSerializer(typeof(TValue));

            bool wasEmpty = reader.IsEmptyElement;
            reader.Read();

            if (wasEmpty)
                return;

            while (reader.NodeType != System.Xml.XmlNodeType.EndElement)
            {
                reader.ReadStartElement(ITEM);
                reader.ReadStartElement(KEY);
                TKey key = (TKey)keySerializer.Deserialize(reader);
                reader.ReadEndElement();
                reader.ReadStartElement(VALUE);
                TValue value = (TValue)valueSerializer.Deserialize(reader);
                reader.ReadEndElement();
                this.Add(key, value);
                reader.ReadEndElement();
                reader.MoveToContent();
            }
            reader.ReadEndElement();
        }

        /// <summary>
        /// Converts an object into its XML representation.
        /// </summary>
        /// <param name="writer">The <see cref="T:System.Xml.XmlWriter"></see> stream to which the object is serialized.</param>
        public void WriteXml(System.Xml.XmlWriter writer)
        {
            XmlSerializer keySerializer = new XmlSerializer(typeof(TKey));
            XmlSerializer valueSerializer = new XmlSerializer(typeof(TValue));

            foreach (TKey key in this.Keys)
            {
                writer.WriteStartElement(ITEM);
                writer.WriteStartElement(KEY);
                keySerializer.Serialize(writer, key);
                writer.WriteEndElement();
                writer.WriteStartElement(VALUE);
                TValue value = this[key];
                valueSerializer.Serialize(writer, value);
                writer.WriteEndElement();
                writer.WriteEndElement();
            }
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Templates\LoadTestSample\LoadTestSample\UnitTests\UnitHomePageTests.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace LoadTestSample.UnitTests
{
    [TestClass()]
    public class UnitHomePageTests
    {
        #region Define the Test Context parameters
        private TestContext _testContextInstance;
        public TestContext TestContext
        {
            get
            {
                return _testContextInstance;
            }
            set
            {
                _testContextInstance = value;
            }
        }
        #endregion

        #region Initialize Class Items
        //Use ClassInitialize to run code before running the first test in the class
        //[ClassInitialize()]
        //public static void MyClassInitialize(TestContext testContext) { }

        //Use ClassCleanup to run code after all tests in a class have run
        //[ClassCleanup()]
        //public static void MyClassCleanup() { }

        ////Use TestInitialize to run code before running each test
        //[TestInitialize()]
        //public void MyTestInitialize() { }

        ////Use TestCleanup to run code after each test has run
        //[TestCleanup()]
        //public void MyTestCleanup() { }
        #endregion

        [TestMethod()]
        public void LoadHomePage()
        {
            Uri expected = new Uri("http://www.xbox.com");
            Uri actual = new Uri("http://www.xbox.com");

            Assert.AreEqual(expected, actual);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\UserLib\AccountDataParser.cs ===
﻿using System;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Xml;
using System.Xml.Linq;
using live.common;

namespace Xboxcom.Test.Library
{
    /// <summary>
    /// This class is necessary for holding the important data types we want out of the XML file
    /// We can use this class and whatever data it has initialized to modify existing account data
    /// </summary>
    public class AccountData
    {
        //PRIVATE PROPERTIES
        private XblUserTier tier = XblUserTier.NewUser;
        private PassportType passportType = PassportType.Real;
        private XblUserSettings settings = new XblUserSettings(XblUserTier.NewUser, PassportType.Real);
        private AddressInfo addressInfo = new AddressInfo();

        #region PUBLIC PROPERTIES
        public XblUserSettings Settings
        {
            get
            {
                return settings;
            }
            set
            {
                settings = value;
            }
        }
        public AddressInfo AddressInfo
        {
            get
            {
                return addressInfo;
            }
            set
            {
                addressInfo = value;
            }
        }
        public XblUserTier Tier
        {
            get
            {
                return tier;
            }
            set
            {
                tier = value;
            }
        }
        public PassportType PassportType
        {
            get
            {
                return passportType;
            }
            set
            {
                passportType = value;
            }
        }
        //Gets/Sets that affect more than one object in the XblUserSettings
        public string Email
        {
            get
            {
                return settings.PersonalInfo.Email;
            }

            set
            {
                settings.OwnerPassportInfo.MemberName = value;
                settings.UserPassportInfo.MemberName = value;
                settings.PersonalInfo.Email = value;
            }
        }

        public string Password
        {
            get
            {
                return settings.UserPassportInfo.Password;
            }
            set
            {
                settings.OwnerPassportInfo.Password = value;
                settings.UserPassportInfo.Password = value;
            }
        }

        public string SecretAnswer
        {
            get
            {
                return settings.UserPassportInfo.SecretAnswer;
            }
            set
            {
                settings.OwnerPassportInfo.SecretAnswer = value;
                settings.UserPassportInfo.SecretAnswer = value;
            }
        }

        public string SecretQuestion
        {
            get
            {
                return settings.UserPassportInfo.SecretQuestion;
            }
            set
            {
                settings.OwnerPassportInfo.SecretQuestion = value;
                settings.UserPassportInfo.SecretQuestion = value;
            }
        }

        public CountryId CountryId
        {
            get
            {
                return settings.UserPassportInfo.CountryId;
            }
            set
            {
                settings.OwnerPassportInfo.CountryId = value;
                settings.UserPassportInfo.CountryId = value;
                settings.PersonalInfo.CountryId = value;
            }
        }

        public LanguageId LanguageId
        {
            get
            {
                return (LanguageId)settings.PersonalInfo.LanguageId;
            }
            set
            {
                settings.PersonalInfo.LanguageId = Convert.ToUInt16(value);
            }
        }
        //Gets/Sets that only affect XblUserSettings.PersonalInfo
        public string GamerTag
        {
            get
            {
                return settings.PersonalInfo.Gamertag;
            }
            set
            {
                settings.PersonalInfo.Gamertag = value;
            }
        }

        public string FirstName
        {
            get
            {
                return settings.PersonalInfo.FirstName;
            }
            set
            {
                settings.PersonalInfo.FirstName = value;
            }
        }

        public string LastName
        {
            get
            {
                return settings.PersonalInfo.LastName;
            }
            set
            {
                settings.PersonalInfo.LastName = value;
            }
        }
        //Gets/Sets that only affect XblUserSettings.PersonalInfo.AddressInfo
        public string Street1
        {
            get
            {
                return settings.PersonalInfo.AddressInfo.Street1;
            }
            set
            {
                settings.PersonalInfo.AddressInfo.Street1 = value;
            }
        }

        public string Street2
        {
            get
            {
                return settings.PersonalInfo.AddressInfo.Street2;
            }
            set
            {
                settings.PersonalInfo.AddressInfo.Street2 = value;
            }
        }

        public string City
        {
            get
            {
                return settings.PersonalInfo.AddressInfo.City;
            }
            set
            {
                settings.PersonalInfo.AddressInfo.City = value;
            }
        }

        public string State
        {
            get
            {
                return settings.PersonalInfo.AddressInfo.State;
            }
            set
            {
                settings.PersonalInfo.AddressInfo.State = value;
            }
        }

        public string PostalCode
        {
            get
            {
                return settings.PersonalInfo.AddressInfo.PostalCode;
            }
            set
            {
                settings.PersonalInfo.AddressInfo.PostalCode = value;
            }
        }

        public string District
        {
            get
            {
                return settings.PersonalInfo.AddressInfo.District;
            }
            set
            {
                settings.PersonalInfo.AddressInfo.District = value;
            }
        }
        #endregion

        public AccountData() { }

        /// <summary>
        /// A method that calculates the default languageid for a countryid a user specifies
        /// </summary>
        /// <param name="countryId">The countryid enum</param>
        /// <returns></returns>
        public LanguageId GetDefaultLanguageForCountry(CountryId countryId)
        {
            LanguageId languageId = LanguageId.en;
            byte[] languages = Countries.CountryInfo(countryId).LiveLanguages;

            if (languages != null && languages.Length > 0)
            {
                languageId = (LanguageId)languages[0];
            }

            return languageId;
        }
    }

    public class AccountDataParser
    {
        public AccountData aData = new AccountData();

        public XmlReader reader;
        public XmlWriter writer;
        public XElement root;

        //Initializes the aData object with data from the embedded XML
        public AccountDataParser(string environment, string userName)
        {
            GetUserData(environment, userName);
        }

        /// <summary>
        /// Fills the AccountXMLData class with all pertinent data from the Accounts.xml file
        /// </summary>
        /// <param name="environment">The environment you want to get the user from (found in Accounts.xml)</param>
        /// <param name="userName">The user you want to get data for (found in Accounts.xml)</param>
        /// <returns>An AccountXMLData class object initialized from the Accounts.xml</returns>
        private AccountData GetUserData(string environment, string userName)
        {
            reader = XmlReader.Create(GetEmbeddedXML(null));
            root = XElement.Load(reader);

            //Ensure that the Linq can find the environment and name by forcing them to lowercase
            environment = environment.ToLower();
            userName = userName.ToLower();

            /* LOCALE (CountryID and LanguageID)
             * 
             * Here we set the string from the attribute first then we create a .NET container for the culture and
             * region. We use these containers to find the proper values from the exsting enums of CountryId
             * and LanguageId. This prevents us from having to modify the data furter down in the code
             * 
             */
            string locale = root.Elements("Environment")
                .Where(e => e.Attribute("name").Value == environment)
                .Elements("User").Single(u => u.Attribute("name").Value == userName).Attribute("locale").Value;

            CultureInfo culture = new CultureInfo(locale, false);
            RegionInfo region = new RegionInfo(culture.Name);

            aData.CountryId = (CountryId)Enum.Parse(typeof(CountryId), region.TwoLetterISORegionName);
            aData.LanguageId = (LanguageId)Enum.Parse(typeof(LanguageId), culture.Parent.ToString().ToLower());
            //TIER (Gold, Silver, etc...)
            aData.Tier = (XblUserTier)Enum.Parse(typeof(XblUserTier), 
                root.Elements("Environment")
                .Where(e => e.Attribute("name").Value == environment)
                .Elements("User").Single(u => u.Attribute("name").Value == userName).Attribute("tier").Value);
            //PASSPORT TYPE (Fake, Real, Existing)
            aData.PassportType = (PassportType)Enum.Parse(typeof(PassportType), 
                root.Elements("Environment")
                .Where(e => e.Attribute("name").Value == environment)
                .Elements("User").Single(u => u.Attribute("name").Value == userName).Attribute("passporttype").Value);
            //CHILD ACCOUNT FLAG
            bool isChild = Convert.ToBoolean(root.Elements("Environment")
                .Where(e => e.Attribute("name").Value == environment)
                .Elements("User").Single(u => u.Attribute("name").Value == userName).Attribute("isChild").Value);
            //EMAIL
            aData.Email = root.Elements("Environment")
                .Where(e => e.Attribute("name").Value == environment)
                .Elements("User").Single(u => u.Attribute("name").Value == userName).Element("Email").Value;
            //PASSWORD
            aData.Password = root.Elements("Environment")
                .Where(e => e.Attribute("name").Value == environment)
                .Elements("User").Single(u => u.Attribute("name").Value == userName).Element("Password").Value;
            //GAMER TAG
            aData.GamerTag = root.Elements("Environment")
                .Where(e => e.Attribute("name").Value == environment)
                .Elements("User").Single(u => u.Attribute("name").Value == userName).Element("Gamertag").Value;
            //SECRET ANSWER
            aData.SecretAnswer = root.Elements("Environment")
                .Where(e => e.Attribute("name").Value == environment)
                .Elements("User").Single(u => u.Attribute("name").Value == userName).Element("SecretAnswer").Value;
            //SECRET QUESTION
            aData.SecretQuestion = root.Elements("Environment")
                .Where(e => e.Attribute("name").Value == environment)
                .Elements("User").Single(u => u.Attribute("name").Value == userName).Element("SecretQuestion").Value;
            //FIRST NAME
            aData.FirstName = root.Elements("Environment")
                .Where(e => e.Attribute("name").Value == environment)
                .Elements("User").Single(u => u.Attribute("name").Value == userName)
                .Elements("ContactInformation").Single().Element("FirstName").Value;
            //LAST NAME
            aData.LastName = root.Elements("Environment")
                .Where(e => e.Attribute("name").Value == environment)
                .Elements("User").Single(u => u.Attribute("name").Value == userName)
                .Elements("ContactInformation").Single().Element("LastName").Value;
            //ADDRESS INFORMATION
            aData.AddressInfo.Street1 = aData.LastName = root.Elements("Environment")
                .Where(e => e.Attribute("name").Value == environment)
                .Elements("User").Single(u => u.Attribute("name").Value == userName)
                .Elements("ContactInformation").Single().Element("Address1").Value;
            aData.AddressInfo.Street2 = aData.LastName = root.Elements("Environment")
                .Where(e => e.Attribute("name").Value == environment)
                .Elements("User").Single(u => u.Attribute("name").Value == userName)
                .Elements("ContactInformation").Single().Element("Address2").Value;
            aData.AddressInfo.City = aData.LastName = root.Elements("Environment")
                .Where(e => e.Attribute("name").Value == environment)
                .Elements("User").Single(u => u.Attribute("name").Value == userName)
                .Elements("ContactInformation").Single().Element("City").Value;
            aData.AddressInfo.State = aData.LastName = root.Elements("Environment")
                .Where(e => e.Attribute("name").Value == environment)
                .Elements("User").Single(u => u.Attribute("name").Value == userName)
                .Elements("ContactInformation").Single().Element("State").Value;
            aData.AddressInfo.PostalCode = aData.LastName = root.Elements("Environment")
                .Where(e => e.Attribute("name").Value == environment)
                .Elements("User").Single(u => u.Attribute("name").Value == userName)
                .Elements("ContactInformation").Single().Element("PostalCode").Value;

            return aData;
        }

        /// <summary>
        /// Gets a stream of the Accounts.xml data that is embedded in PlatformLib
        /// </summary>
        /// <param name="resourceName">The name of the embedded resource file</param>
        /// <returns>A stream with data from the file specified within the embedded resources</returns>
        private Stream GetEmbeddedXML(string resourceName)
        {
            //Initialize a null stream and the current assembly
            Stream stream = null;
            Assembly a = GetType().Assembly;

            //If the user doesn't feed a filename and path in then we use the embedded resource
            if (resourceName == null)
                resourceName = @"Accounts.xml";

            //Find the resource entered and place it in our stream
            string[] names = a.GetManifestResourceNames();
            foreach (string name in names)
            {
                if (name.Contains(resourceName))
                {
                    stream = a.GetManifestResourceStream(name);
                }
            }

            if (stream == null)
                throw new Exception("Embedded resource could not be found '" + resourceName);
            return stream;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\UserLib\Account.cs ===
﻿using System;
using System.Collections.ObjectModel;
using System.Text;
using System.Diagnostics;

using live.client;
using live.common;
using live.lfm;
using live.protocol;
using live.server;

namespace LiveN.Test.Users
{
    public enum AccountTier
    {
        Gold,
        Silver
    }

    public class Account
    {
        private XblUser _user;
        private Profile _gamerProfile;
        private Feedback _feedback;
        private Avatar _avatar;

        #region PROPERTY ACCESSORS
        //Returns the private instance of the XblUser class
        public XblUser XblUser
        {
            get { return _user; }
        }
        //Returns the private instance of the GamerProfile class
        public Profile GamerProfile
        {
            get
            {
                if (_gamerProfile == null)
                {
                    _gamerProfile = new Profile(_user);
                }
                return _gamerProfile;
            }
        }
        //Returns the private instance of the Feedback class
        public Feedback Feedback
        {
            get
            {
                if (_feedback == null)
                {
                    _feedback = new Feedback(_user);
                }
                return _feedback;
            }
        }
        // Returns the private instance of the Avatar class
        public Avatar Avatar
        {
            get
            {
                if (_avatar == null)
                {
                    _avatar = new Avatar(_user);
                }
                return _avatar;
            }
        }
        //Returns the current Gamertag of the XblUser
        public string Gamertag
        {
            get
            {
                return XblUser.Gamertag;
            }
        }

        /// <summary>
        /// Gets the Xbox LIVE puid of the XblUser
        /// </summary>
        public ulong Xuid
        {
            get
            {
                return XblUser.Puid;
            }
        }

        /// <summary>
        /// Gets the email address of the XblUser
        /// </summary>
        public string Email
        {
            get
            {
                if (XblUser.Settings.UserPassportInfo != null)
                {
                    return XblUser.Settings.UserPassportInfo.MemberName;
                }
                else
                {
                    return null;
                }
            }
        }

        /// <summary>
        /// Gets the password of the XblUser
        /// </summary>
        public string Password
        {
            get
            {
                if (XblUser.Settings.UserPassportInfo != null)
                {
                    return XblUser.Settings.UserPassportInfo.Password;
                }
                else
                {
                    return null;
                }
            }
        }

        #endregion

        #region Account Creation Functions (Ctors)

        /// <summary>
        /// Account() creates an adult, US, Gold account with random passport and membername.
        /// </summary>
        /// <remarks>
        /// Default constructor.
        /// </remarks>
        public Account()
        {
            try
            {
                _user = Util.Accounts.CreateLiveAccount(XblUserTier.Gold, PassportType.Real, false);

                Trace.WriteLine("Created new user account: " + this.Email + " / " + this.Password + " - " + this.Gamertag);
            }
            catch (XErrFailedException ex)
            {
                if (ex.HResult == 0x8015D001) // XONLINE_E_PASSPORT_NAME_ALREADY_TAKEN
                {
                    //TODO: If this happens again; The base should not be trying to create a user that already exists. Should just retry. Add this logic.
                }

                throw ex;
            }
        }

        /// <summary>
        /// Creates child, foreign, and silver accounts
        /// </summary>
        /// <param name="tier">Silver or Gold</param>
        /// <param name="country">Billing region for the account</param>
        /// <param name="control">none = adult, strict = child, partial = teen</param>
        public Account(XblUserTier tier, CountryId country, ParentalControl control)
        {
            AccountSettings account = new AccountSettings(tier, PassportType.Real, null, null, null, country, control);
            
            _user = Util.Accounts.CreateLiveAccount(account.Settings);

            Trace.WriteLine("Created new user account: " + this.Email + " / " + this.Password + " - " + this.Gamertag);
        }

        /// <summary>
        /// Creates an account with the same settings specified in the AccountSettings parameter
        /// </summary>
        /// <param name="settings">Used to specify tier, parental control, nationality, gamertag, passport info, etc.</param>
        /// <remarks>
        /// If the specified passport membername and password are already taken, the function will attempt to recover the original account.
        /// </remarks>
        public Account(AccountSettings account)
        {
            int retry = 3;

            while (true)
            {
                try
                {
                    _user = Util.Accounts.CreateLiveAccount(account.Settings);

                    Trace.WriteLine("Created new user account: " + this.Email + " / " + this.Password + " - " + this.Gamertag);

                    break;
                }
                catch (XErrFailedException ex)
                {
                    if (retry-- > 0)
                    {
                        // Account creation failed. Still within retry count. So try again
                        continue;
                    }

                    // Account creation failed to many times. Allow the exception to be trapped.

                    if (ex.HResult == 0x8015D001) // XONLINE_E_PASSPORT_NAME_ALREADY_TAKEN
                    {
                        account.Settings.UserPassportInfo.PassportType = PassportType.Existing;
                        account.Settings.OwnerPassportInfo.PassportType = PassportType.Existing;
                        new Account(account);
                    }
                    else if (ex.HResult == 0x80154013) //XONLINE_E_ACCOUNTS_PASSPORT_ALREADY_LINKED
                    {
                        //Attempt to load the existing account
                        new Account(account.Settings.UserPassportInfo.MemberName, account.Settings.UserPassportInfo.Password);
                    }
                    else if (ex.HResult == 0x80154000) //XONLINE_E_ACCOUNTS_NAME_TAKEN
                    {
                        //Attempt to load the existing account
                        new Account(account.Settings.UserPassportInfo.MemberName, account.Settings.UserPassportInfo.Password);
                    }
                    else
                    {
                        throw new Exception("The Account::Account(AccountData) method "
                            + "threw the following unhandled exception from Util.Accounts.CreateLiveAccount: "
                            + "(HResult: " + ex.HResult + ") - "
                            + "\r\nPOSSABLE ISSUE: Seen issues with laptops where rebooting fixed the issue. OR if the test's are being executed over a RAS connection, this will not work."
                            + "\r\nException:\r\n" + ex.Message);
                    }
                }
                catch(Exception exc)
                {
                    if (retry-- > 0)
                    {
                        // Account creation failed. Still within retry count. So try again
                        continue;
                    }

                    throw exc;
                }
            }
        }

        /// <summary>
        /// Recovers an account.
        /// </summary>
        /// <param name="membername">Passport Live ID</param>
        /// <param name="password">Passport password</param>
        /// <remarks>
        /// If a user cannot be recovered, it will attempt to create an adult, Gold account with the specified membername and password.
        /// </remarks>
        public Account(string memberName, string password)
        {
            try
            {
                _user = Account.LoadExistingAccount(memberName, password)._user;

                _gamerProfile = new Profile(_user);
                _feedback = new Feedback(_user);
            }
            catch (XErrFailedException ex)
            {
                if (ex.HResult == 0x8015D002) // XONLINE_E_PASSPORT_WRONG_NAME_OR_PASSWORD
                {
                    XblUserSettings settings = new XblUserSettings(XblUserTier.Gold, PassportType.Real);
                    settings.UserPassportInfo.MemberName = memberName;
                    settings.UserPassportInfo.Password = password;
                    _user = Util.Accounts.CreateLiveAccount(settings);
                }
                else
                {
                    throw new Exception("The Account::Account().LoadExistingAccount() method "
                        + "threw the following unhandled exception from Util.Accounts.CreateLiveAccount: "
                        + "(HResult: " + ex.HResult + ") - "
                        + ex.Message);
                }
            }
        }

        /// <summary>
        /// Changes an XblUser into an Account object.
        /// </summary>
        /// <param name="XblUser">LiveLib XblUser object</param>
        /// <remarks>
        /// Use this if you already have an XblUser but you want to access Account functions with the user.
        /// </remarks>
        public Account(XblUser user)
        {
            _user = user;
            _gamerProfile = new Profile(_user);
            _feedback = new Feedback(_user);
        }
        #endregion

        #region Account Management Functions
        /// <summary>
        /// Loads an account that was previously created on the backend.
        /// Note: This gets around some issues with LiveLib which failed to load all settings for
        /// existing accounts and used default values instead.
        /// </summary>
        /// <param name="memberName">Passport membername for the existing account</param>
        /// <param name="password">Passport password for the existing account</param>
        /// <returns>An XblUser that represents the pre-existing account</returns>
        public static Account LoadExistingAccount(string memberName, string password)
        {
            METHOD.ENTER();
            PassportInfo ppi = new PassportInfo();
            ppi.MemberName = memberName;
            ppi.Password = password;
            ppi.PassportType = PassportType.Existing;
            Xbox360Client client = new Xbox360Client();

            //load existing passport account
            PassportUtils.LoadExistingPassportAccount(client, ppi);

            //create a new XblUser and copy the original user's settings from the backend
            ulong xuid;
            string gamertag = UACS.XeGetLinkedGamertag(client, ppi, out xuid);
            XblUser user = new XblUser(xuid, gamertag);
            XblUserSettings settings = new XblUserSettings(XblUserTier.Silver, PassportType.Existing);
            user.Settings = settings;
            client.UserLoggingOn(user);
            XeGetAccountInfoRequest req = new XeGetAccountInfoRequest();
            XeGetAccountInfoResponse resp = new XeGetAccountInfoResponse();
            req.machinePuid = client.MachinePuid;
            req.userPuid = user.Puid;
            uint hr = UACS.SendRequest(client, null, req, resp);
            Throw.IfXErrFailed(hr);
            PersonalInfo pi = new PersonalInfo(resp);
            pi.Gamertag = user.Gamertag;
            user.Settings.PersonalInfo = pi;
            user.Settings.PersonalInfo.LanguageId = resp.languageId;
            user.Settings.UserPassportInfo = ppi;

            //get actual User Tier and Parental Control
            uint xboxtitle = client.TitleId;
            client.TitleId = XOn.WEB_TITLE_ID;
            UserWebInfo uwi = UACS.XeGetUserWebInfo(client, user);
            client.TitleId = xboxtitle;
            user.Settings.UserType = uwi.Tier;
            user.Settings.PersonalInfo.ParentalControlGroupId = uwi.ParentalControlGroupId;
            if (uwi.ParentalControlGroupId == 0) //adult, so owner and user info are identical
            {
                user.Settings.OwnerPassportInfo = ppi.DeepClone();
            }
            else //child, get owner passport info for original adult account
            {
                PassportInfo ownerPpi = new PassportInfo();
                XePassportGetMemberNameRequest ppreq = new XePassportGetMemberNameRequest();
                XePassportGetMemberNameResponse ppresp = new XePassportGetMemberNameResponse();
                ppreq.userPuid = xuid;
                hr = UACS.SendRequest(client, null, ppreq, ppresp);
                Throw.IfXErrFailed(hr);
                ownerPpi.MemberName = ppresp.parentPmn;
                ownerPpi.PassportType = PassportType.Existing;
                try
                {
                    //assume parent's password is the default 'supersecret'
                    PassportUtils.LoadExistingPassportAccount(client, ownerPpi);
                }
                catch (XErrFailedException ex)
                {
                    if (ex.HResult == 0x8015D002 && !ownerPpi.Password.Equals(user.Settings.UserPassportInfo.Password)) // XONLINE_E_PASSPORT_WRONG_NAME_OR_PASSWORD
                    {
                        //try using child's password instead of the default one
                        ownerPpi.Password = password;
                        PassportUtils.LoadExistingPassportAccount(client, ownerPpi);
                    }
                    else
                    {
                        Throw.IfXErrFailed(hr);
                    }
                }
                user.Settings.OwnerPassportInfo = ownerPpi;
            }

            //set created on info
            ClientSettings clientSettings = new ClientSettings();
            clientSettings.Key = client.Key;
            clientSettings.MachinePuid = client.MachinePuid;
            clientSettings.OfflineXuid = client.OfflineXuid;
            clientSettings.Principal = client.Principal;
            clientSettings.TitleId = client.TitleId;
            user.Settings.CreatedOn = clientSettings;

            //get billing info
            UACS.XeGetPaymentInstruments(client, user, 50);

            client.UserLoggingOff(user);

            METHOD.EXIT();

            return new Account(user);
        }

        /// <summary>
        /// Sets default gamerpic, region and zone for newly created accounts
        /// Initializes the GamerProfile and Feedback classes
        /// Grants parental consent to passport child accounts
        /// </summary>
        public void InitializeAccount()
        {
            _feedback = new Feedback(_user);
            _gamerProfile = new Profile(_user);
            GamerZone zone = GamerZone.Pro;
            CountryId region = _user.Settings.PersonalInfo.CountryId;
            string gamerPic = _gamerProfile.SelectRandomPicture();

            _gamerProfile.WriteProfileSettings(null, null, null, null, gamerPic, gamerPic, null, zone, region);

            //Is this a child account? If so, we may need to grant parental consent via WLID so the account can sign into the LCW
            if (!_user.Settings.UserPassportInfo.MemberName.Equals(_user.Settings.OwnerPassportInfo.MemberName))
            {
                int age = DateTime.Now.Year - _user.Settings.PersonalInfo.BirthDate.Year;
                if (age <= 13 && (_user.Settings.PersonalInfo.CountryId == CountryId.US || _user.Settings.PersonalInfo.CountryId == CountryId.KR))
                {
                    WLID.SetParentalConsent(_user, true);
                }
            }
        }
        #endregion

        #region Friends Functions
        /// <summary>
        /// Creates community-specific items (messages, friends, and recent players)
        /// </summary>
        /// <param name="numMessages">Number of messages user should have in their message list</param>
        /// <param name="numFriends">Number of friends user should have in their friend list</param>
        /// <param name="numPlayers">Number of players user should have in their recent player list</param>
        /// <remarks>
        /// All friends and players created by this method have 'fake' passport information and therefore, cannot be recovered.
        /// </remarks>
        public void CreateFriends(int numberMessages, int numberFriends, int numberPlayers)
        {
            Friends.CreateFriends(_user, numberMessages, numberFriends, numberPlayers, null, null);
        }

        /// <summary>
        /// Creates community-specific items (messages, friends, and recent players)
        /// </summary>
        /// <param name="numMessages">Number of messages user should have in their message list</param>
        /// <param name="numFriends">Number of friends user should have in their friend list</param>
        /// <param name="numPlayers">Number of players user should have in their recent player list</param>
        /// <param name="friendPassports">Passport information for 'real' friend accounts</param>
        /// <param name="playerPassports">Passport information for 'real' player accounts</param>
        /// <remarks>
        /// Use this to link real friend and player accounts to the Account object.
        /// If numFriends > number fo friends in friendPassports, additional 'fake' friends will be created.
        /// If numPlayers > number of players in playerPassports, additional 'fake' players will be created.
        /// If a friend or player account cannot be recoverd becuase the passport info given does not exist
        /// on the backend, then a gold account will be created with the specified passport information.
        /// </remarks>
        public void CreateFriends(int numberMessages, int numberFriends, int numberPlayers, Collection<PassportInfo> friendPassports, Collection<PassportInfo> playerPassports)
        {
            Friends.CreateFriends(_user, numberMessages, numberFriends, numberPlayers, friendPassports, playerPassports);
        }
        #endregion

        #region Gaming Functions
        /// <summary>
        /// Creates a list of games and awards achievements to the calling Account object.
        /// </summary>
        /// <param name="numGames">Number of games that should be added to the 'All Games' list</param>
        /// <param name="skill">Player skill, determines max amount of achievements awarded per game</param>
        /// <remarks>
        /// If numGames is more than the amount of max games (Games.MAX_GAMES), then only the max will be created.
        /// </remarks>
        public void CreateGameHistory(int numberGames, PlayerSkill skill)
        {
            Products.CreateGameHistory(_user, numberGames, skill);
        }

        /// <summary>
        /// Awards achievements to the calling Account object.
        /// </summary>
        /// <param name="title">Title information, including the title Id and an array of achievements to award</param>
        /// <remarks>
        /// Use this for finer control over which achievements are awarded to the user for a specific title.
        /// </remarks>
        public void AwardAchievements(Title title)
        {
            Products.AwardAchievements(_user, title);
        }

        /// <summary>
        /// Adds the array of title IDs to the user's account
        /// </summary>
        /// <param name="titleIDs">Title IDs to sync</param>
        public void AddTitles(uint[] titleIds)
        {
            Products.SyncTitles(_user, titleIds);
        }
        #endregion

        #region Banning Functions
        /// <summary>
        /// Bans the account.
        /// </summary>
        /// <param name="bans">Set specific bans (such as voice bans and gamertag bans) to true if you want to inflict them on the user</param>
        /// <remarks>
        /// Use this fucntion to apply or remove bans on the calling Account object.
        /// </remarks>
        public void BanAccount(BanSettings bans)
        {
            Banning.ApplyNewBans(bans, _user);
        }
        #endregion

        #region Privacy Functions
        /// <summary>
        /// Changes the privacy settings for the calling adult Account object.
        /// </summary>
        /// <param name="privSettings">New privacy settings for the account</param>
        /// <remarks>
        /// Resets all privacy settings normally available to users via the xbox dashboard or on xbox.com.
        /// For use with adult accounts only, user ResetFamilySettings() for child accounts.
        /// </remarks>
        public void ResetPrivacySettings(PrivacySettings newSettings)
        {
            if (!_user.Settings.UserPassportInfo.MemberName.Equals(_user.Settings.OwnerPassportInfo.MemberName))
            {
                throw new ArgumentException("Privacy Settings are for adult accounts only. Use ResetFamilySettings() instead.");
            }
            Privacy.ResetPrivacySettings(_user, newSettings);
        }

        /// <summary>
        /// Changes the family settings for the calling child Account object.
        /// </summary>
        /// <param name="privSettings">New family settings for the account</param>
        /// <remarks>
        /// Resets all family settings normally available to users via the xbox dashboard or on xbox.com.
        /// For use with child accounts, use ResetPrivacySettings() for adult accounts.
        /// </remarks>
        public void ResetFamilySettings(FamilySettings newSettings)
        {
            if (_user.Settings.UserPassportInfo.MemberName.Equals(_user.Settings.OwnerPassportInfo.MemberName))
            {
                throw new ArgumentException("Family Settings are for dependent accounts only. Use ResetPrivacySettings() instead.");
            }
            Privacy.ResetFamilySettings(_user, newSettings);
        }
        #endregion

        #region Billing functions
        /// <summary>
        /// Adds a credit card to the user account
        /// </summary>
        /// <param name="creditType">Type of credit card to add</param>
        /// <param name="defaultPayment">If true, sets credit card to be the default payment type for the user</param>
        public void AddCreditCard(CreditCardType creditType, bool defaultPayment)
        {
            METHOD.ENTER();
            using (Xbox360 xbox = new Xbox360())
            {
                xbox.Live.Logon(_user);
                CreditCardInfo cc = Randomizer.CreditCards.CardInfoForPerson(creditType, _user.Settings.PersonalInfo);
                live.server.UACS.XeAddPaymentInstrument(xbox.Client, _user, cc);
                if (defaultPayment)
                {
                    _user.Settings.BillingInfo.SetActivePaymentInstrument(cc);
                }
                xbox.Live.Logout(_user);
                xbox.ShutdownConsole();
            }
            METHOD.EXIT();
        }

        /// <summary>
        /// Adds a direct debit card to the user account, the account must be from Germany
        /// </summary>
        /// <param name="defaultPayment">If true, sets direct debit to be the default payment type for the user</param>
        public void AddDirectDebit(bool defaultPayment)
        {
            METHOD.ENTER();
            if (_user.Settings.PersonalInfo.CountryId != CountryId.DE)
            {
                throw new InvalidOperationException("Direct Debit is only supported for German accounts.");
            }
            using (Xbox360 xbox = new Xbox360())
            {
                xbox.Live.Logon(_user);
                DirectDebitRandomizer ddRand = new DirectDebitRandomizer();
                DirectDebitInfo dd = new DirectDebitInfo();
                dd.AccountNumber = ddRand.AccountNumber;
                dd.BankCode = ddRand.BankCode;
                dd.BranchCode = ddRand.BranchCode;
                dd.CheckDigits = ddRand.CheckDigits;
                StringBuilder holderName = new StringBuilder(_user.Settings.PersonalInfo.FirstName + " " + _user.Settings.PersonalInfo.LastName);
                dd.AccountHolderName = holderName.ToString();
                dd.PhoneInfo = _user.Settings.PersonalInfo.PhoneInfo;
                live.server.UACS.XeAddPaymentInstrument(xbox.Client, _user, dd);
                if (defaultPayment)
                {
                    _user.Settings.BillingInfo.SetActivePaymentInstrument(dd);
                }
                xbox.Live.Logout(_user);
                xbox.ShutdownConsole();
            }
            METHOD.EXIT();
        }

        /// <summary>
        /// Purchases Microsoft Points (the offers must be propped to the targeted backend)
        /// </summary>
        /// <param name="offer">The points offer to purchase</param>
        /// <return>Total number of Microsoft Points that the account has</return>
        public uint PurchasePointsWithCreditCard(Offers.PointsOffers offer)
        {
            METHOD.ENTER();
            uint totalPoints = 0;
            
            if (_user.Settings.BillingInfo.GetActivePaymentInstrument() == null)
            {
                System.Collections.Generic.List<CreditCardInfo> creditCards = _user.Settings.BillingInfo.CreditCards;
                if (creditCards.Count == 0)
                {
                    // Add credit card
                    AddCreditCard(CreditCardType.Visa, true);
                }

                _user.Settings.BillingInfo.SetActivePaymentInstrument((PaymentInstrumentBase)creditCards[0]);
            }

            using (Xbox360 xbox = new Xbox360())
            {
                xbox.Live.Logon(_user);

                Billing.XeOfferPurchase(xbox.Client, _user, Offers.GetOfferId(offer));
                totalPoints = UACS.XeGetPointsBalance(xbox.Client, _user);

                xbox.Live.Logout(_user);

                xbox.ShutdownConsole();
            }

            METHOD.EXIT();

            return totalPoints;
        }

        /// <summary>
        /// Purchases Family Gold Subscription
        /// </summary>
        public void PurchaseFamilyGoldSubscriptionWithCreditCard()
        {
            
            METHOD.ENTER();
            live.protocol.next.OfferProductInfo info = new live.protocol.next.OfferProductInfo();
            info.offerId = Subscriptions.FamilySubOfferId;
            info.productTypeId = 51;

            live.protocol.next.PreviewSubscriptionProductInfo subInfo = PreviewProductPurchase(new live.protocol.next.OfferProductInfo[] { info });

            uint wholePrice = (uint)subInfo.netPrice;
            uint fracPrice = (uint)(subInfo.netPrice * 100) - wholePrice * 100;
            uint hresult;
            using (Xbox360 xbox = new Xbox360())
            {
                xbox.Client.SchemaVersion = WireData.MakeSchemaVersion(6, 4);
                hresult = live.server.Billing.PurchaseMediaOffers(xbox.Client, _user, Subscriptions.FamilySubOfferId, wholePrice, fracPrice, (int)51, PaymentTypeEnum.CreditCard, "", _user.Settings.BillingInfo.ActivePaymentInstrumentId, 1, (uint)subInfo.timeExtendedinMonths);
            }

            if (hresult != 0)
            {
                throw new XErrFailedException(hresult, "Purchasing family gold subscription failed.");
            }

            METHOD.EXIT();
        }

        /// <summary>
        /// Purchase Microsoft Points with token (the token and offer must be propped to the backend)
        /// </summary>
        /// <param name="offer">The points offer to purchase</param>
        /// <param name="prepaidCode">The token to redeem for points</param>
        /// <returns>Total number of Microsoft Points that the account has</returns>
        public uint PurchasePointsWithPrepaidCode(Offers.PointsOffers offer, string prepaidCode)
        {
            METHOD.ENTER();
            uint totalPoints = 0;
            using (Xbox360 xbox = new Xbox360())
            {
                xbox.Live.Logon(_user);
                live.lfm.xbox360Internal.HUD.RedeemCodeScene scene = xbox.Marketplace.RedeemMSPointsCode(offer, prepaidCode);
                scene.RedeemNow();
                totalPoints = UACS.XeGetPointsBalance(xbox.Client, _user);
                xbox.Live.Logout(_user);
                xbox.ShutdownConsole();
            }
            METHOD.EXIT();
            return totalPoints;
        }
        #endregion

        #region Purchase Marketplace Offers
        public void PurchaseMarketplaceOffers(OfferMediaTypeExpectedPrice[] offerList)
        {
            using (Xbox360 xbox = new Xbox360())
            {
                xbox.Live.Logon(_user);
                uint totalPoints = UACS.XeGetPointsBalance(xbox.Client, _user);
                xbox.Live.Logout(_user);

                uint totalCost = 0;
                foreach (OfferMediaTypeExpectedPrice offer in offerList)
                {
                    totalCost += offer.expectedPriceWhole;
                    if (offer.expectedPriceFractional > 0)
                    {
                        totalCost++;
                    }
                }

                if (totalPoints < totalCost)
                {
                    if (_user.Settings.BillingInfo.CreditCards.Count <= 0)
                    {
                        AddCreditCard(CreditCardType.Visa, true);
                    }

                    PurchasePointsWithCreditCard(Offers.PointsOffers.CC5000US);
                }

                try
                {
                    Billing.XePurchaseMediaOffers(xbox.Client, _user, offerList, (int)PaymentTypeEnum.Points,
                        _user.Settings.BillingInfo.ActivePaymentInstrumentId, "", 1);
                }
                catch (XErrFailedException ex)
                {
                    if (ex.HResult != 0x8015300C) //8015300C: XOFF_E_ALREADY_OWN_MAX.
                    {
                        throw;
                    }
                }
                xbox.Live.Logout(_user);
                xbox.ShutdownConsole();
            }
        }

        public live.protocol.next.PreviewSubscriptionProductInfo PreviewProductPurchase(live.protocol.next.OfferProductInfo[] offers)
        {
            if (_user.Settings.BillingInfo.GetActivePaymentInstrument() == null)
                this.AddCreditCard(CreditCardType.Visa, true);

            live.protocol.next.XePreviewProductPurchaseRequest request = new live.protocol.next.XePreviewProductPurchaseRequest();
            request.offers = offers;
            request.offersLength = (uint)offers.Length;
            request.paymentInstrumentID = _user.Settings.BillingInfo.ActivePaymentInstrumentId;
            request.paymentInstrumentIDLength = (ushort)_user.Settings.BillingInfo.ActivePaymentInstrumentId.Length;
            request.paymentType = (uint)PaymentTypeEnum.CreditCard;
            request.storeId = 1;
            request.userPuid = _user.Puid;

            live.protocol.next.XePreviewProductPurchaseResponse response = new live.protocol.next.XePreviewProductPurchaseResponse();
            uint hresult;
            using (Xbox360 xbox = new Xbox360())
            {
                xbox.Live.Logon(_user);
                hresult = Billing.SendRequest(xbox.Client, _user, XOService.Billing_Offering, request, response);
                xbox.Live.Logout(_user);
            }
            if (hresult != 0)
            {
                throw new XErrFailedException(hresult, "Previewing product purchase failed.");
            }

            return response.previewSubscriptionInfo;
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\TestCommonCode\DataDrivenTest\TestData.cs ===
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Xml.Serialization;

namespace DataDrivenTest
{
    /// <summary>
    /// Generic collection for containing a dictionary of the test data
    /// </summary>
    /// <typeparam name="TKey">Data type for the dictionary's key</typeparam>
    /// <typeparam name="TValue">Data type for the dictionary's value, must be derived from the TestData class</typeparam>
    [XmlRoot("TestDataList")]
    public class TestDataList<TKey, TValue> : XmlSerializableDictionary<TKey, TValue> where TValue : TestData
    {
        #region Properties
        /// <summary>
        /// High-level results of all of the tests encapsulated in the list.  Must execute ReportResults prior to this property being set
        /// </summary>
        public TestResult MasterResult { get; private set; }
        #endregion

        #region Methods
        /// <summary>
        /// Compiles and writes out the individual results to the Console, also sets the MasterResult property
        /// </summary>
        public void ReportResults()
        {
            // Format of [  Result   TestName  TestDescription    ResultMessage]
            const string ReportTemplate = "\t{0}\t{1}\t{2}\t{3}";

            List<string> passList = new List<string>();
            List<string> failList = new List<string>();

            string message = String.Empty;

            // Iterate thru the list and compile the results
            foreach (TKey key in this.Keys)
            {
                TValue test = this[key];

                message = String.Format(ReportTemplate,
                                        test.Result.ToString(),
                                        key.ToString(),
                                        test.TestDescription,
                                        test.ResultMessage);

                if (test.Result == TestResult.Failed)
                {
                    failList.Add(message);
                }
                else
                {
                    passList.Add(message);
                }
            }

            // Determine our master result value
            this.MasterResult = (failList.Count > 0 ? TestResult.Failed : TestResult.Passed);

            // Output the results to the Console
            // Display a summary and then list out the failures followed by the succeeds
            Console.WriteLine("RESULTS: {0} PASSED | {1} FAILED", passList.Count.ToString(), failList.Count.ToString());

            foreach (string entry in failList)
                Console.WriteLine(entry);

            foreach (string entry in passList)
                Console.WriteLine(entry);
        }
        #endregion

        #region Serialization/Deserialization
        /// <summary>
        /// Serializes the data to a file
        /// </summary>
        /// <param name="fileName"></param>
        public void Serialize(string fileName)
        {
            using (TextWriter writer = new StreamWriter(fileName))
            {
                XmlSerializer serializer = new XmlSerializer(typeof(TestDataList<TKey, TValue>));
                serializer.Serialize(writer, this);
            }
        }

        /// <summary>
        /// Deserializes the data from the specified file
        /// </summary>
        /// <param name="fileName">Path and name of the file to deserialize from</param>
        /// <returns>A TestDataList object</returns>
        public static TestDataList<TKey, TValue> DeserializeFromFile(string fileName)
        {
            using (TextReader reader = new StreamReader(fileName))
            {
                XmlSerializer serializer = new XmlSerializer(typeof(TestDataList<TKey, TValue>));
                return (TestDataList<TKey, TValue>)serializer.Deserialize(reader);
            }
        }

        /// <summary>
        /// Deserializes the data from the specified resource
        /// </summary>
        /// <param name="resourceName">Name of the embedded resource</param>
        /// <returns>A TestDataList object</returns>
        public static TestDataList<TKey, TValue> DeserializeFromResource(string resourceName)
        {
            Assembly myAssembly = Assembly.GetCallingAssembly();
            Stream xmlData = myAssembly.GetManifestResourceStream(resourceName);
            XmlSerializer serializer = new XmlSerializer(typeof(TestDataList<TKey, TValue>));

            return (TestDataList<TKey, TValue>)serializer.Deserialize(xmlData);
        }
        #endregion
    }

    /// <summary>
    /// Public class to inherit off of which encapsulates the data which will be used for the test
    /// </summary>
    [XmlRoot("TestData")]
    public class TestData
    {
        #region Properties
        [XmlIgnore()]
        public TestResult Result { get; set; }
        [XmlIgnore()]
        public string ResultMessage { get; set; }

        public string TestDescription { get; set; }
        public string ExpectedExceptionTypeName { get; set; }

        [XmlIgnore()]
        public Type ExpectedExceptionType
        {
            get
            {
                if (!String.IsNullOrEmpty(this.ExpectedExceptionTypeName))
                    return Type.GetType(this.ExpectedExceptionTypeName, true, true);
                else
                    return null;
            }
        }
        #endregion

        #region Constructor
        public TestData()
        {
            this.Result = TestResult.Failed;
            this.ResultMessage = String.Empty;
            this.TestDescription = String.Empty;
        }
        #endregion
    }

    /// <summary>
    /// Public enum for the pass/fail result
    /// </summary>
    public enum TestResult
    {
        Failed,
        Passed
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\UserLib\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\UserLib\Community.cs ===
﻿using System;
using System.Globalization;
using System.Collections.ObjectModel;

using live.common;
using live.lfm;
using live.protocol.Presence;

namespace PlatformLib
{
    public sealed class Community
    {
        // max values
        public static readonly int MaxFriends = 1000;
        public static readonly int MaxPlayers = 50;
        public static readonly int MaxMessages = 100;

        private Community() { }

        internal static void CreateCommunity(XblUser user, int numberMessages, int numberFriends, int numberPlayers, Collection<PassportInfo> friendPIs, Collection<PassportInfo> playerPIs)
        {
            METHOD.ENTER();
            int numberRealFriends = (friendPIs != null) ? friendPIs.Count : 0;
            int numberRealPlayers = (playerPIs != null) ? playerPIs.Count : 0;

            // create friends
            if (friendPIs != null)
            {
                AddRealFriends(user, friendPIs);
                numberFriends = numberFriends - numberRealFriends;
            }
            AddFakeFriends(user, numberFriends);

            // add recent players
            if (playerPIs != null)
            {
                AddRealPlayers(user, playerPIs);
                numberPlayers = numberPlayers - numberRealPlayers;
            }
            AddFakePlayers(user, numberPlayers);

            // send messages
            SendMessages(user, numberMessages);
            METHOD.EXIT();
        }

        private static void AddFakePlayers(XblUser user, int numberPlayers)
        {
            METHOD.ENTER();
            if (numberPlayers > MaxPlayers)
            {
                throw new ArgumentOutOfRangeException(String.Format(CultureInfo.CurrentCulture, "Cannot have > {0} players", MaxPlayers.ToString(CultureInfo.CurrentCulture)));
            }
            for (int i = 0; i < numberPlayers; i++)
            {
                XblUser player = Util.Accounts.CreateLiveAccount(XblUserTier.Gold, PassportType.Fake, false);
                Util.Presence.AddRecentPlayer(user, player);
            }
            METHOD.EXIT();
        }

        private static void AddRealPlayers(XblUser user, Collection<PassportInfo> playerPIs)
        {
            METHOD.ENTER();
            if (playerPIs.Count > MaxPlayers)
            {
                throw new ArgumentOutOfRangeException(String.Format(CultureInfo.CurrentCulture, "Cannot have > {0} players", MaxPlayers.ToString(CultureInfo.CurrentCulture)));
            }
            using (Xbox360 playerXbox360 = new Xbox360(), userXbox360 = new Xbox360())
            {
                foreach (PassportInfo ppi in playerPIs)
                {
                    // retrieve the player account
                    Account playerAcct = new Account(ppi.MemberName, ppi.Password);
                    XblUser player = playerAcct.XblUser;

                    // The Util.Presence.AddRecentPlayer() function does not work with previously existing accounts
                    // so we need to add players the hard way...                    
                    // sign the user and player into LIVE on their own consoles
                    playerXbox360.Live.Logon(player);
                    userXbox360.Live.Logon(user);

                    // add player and user to each other's recent players list
                    live.server.Presence.AddAffiliate(userXbox360.Client, user, player,
                        live.protocol.Presence.AffiliateFlags.CompletedGame);
                    live.server.Presence.AddAffiliate(playerXbox360.Client, player, user,
                        live.protocol.Presence.AffiliateFlags.CompletedGame);

                    // log both accounts out
                    playerXbox360.Live.Logout(player);
                    userXbox360.Live.Logout(user);
                }
                playerXbox360.ShutdownConsole();
                userXbox360.ShutdownConsole();
            }
            METHOD.EXIT();
        }

        private static void AddFakeFriends(XblUser user, int numberFriends)
        {
            METHOD.ENTER();
            if (numberFriends > MaxFriends)
            {
                throw new ArgumentOutOfRangeException(String.Format(CultureInfo.CurrentCulture, "Cannot have > {0} friends", MaxFriends.ToString(CultureInfo.CurrentCulture)));
            }
            for (int i = 0; i < numberFriends; i++)
            {
                XblUser friend = Util.Accounts.CreateLiveAccount(XblUserTier.Gold, PassportType.Fake, false);
                Util.Presence.MakeFriends(user, friend);
            }
            METHOD.EXIT();
        }

        private static void AddRealFriends(XblUser user, Collection<PassportInfo> friendPIs)
        {
            METHOD.ENTER();
            if (friendPIs.Count > MaxFriends)
            {
                throw new ArgumentOutOfRangeException(String.Format(CultureInfo.CurrentCulture, "Cannot have > {0} friends", MaxFriends.ToString(CultureInfo.CurrentCulture)));
            }
            using (Xbox360 friendXbox360 = new Xbox360(), userXbox360 = new Xbox360())
            {
                foreach (PassportInfo ppi in friendPIs)
                {
                    // retrieve the friend account
                    Account friendAcct = new Account(ppi.MemberName, ppi.Password);
                    XblUser friend = friendAcct.XblUser;

                    // The Util.Presence.MakeFriends() function does not work with previously existing accounts
                    // so we need to make friends the hard way...
                    // sign the user and friend into LIVE on their own consoles
                    friendXbox360.Live.Logon(friend);
                    userXbox360.Live.Logon(user);

                    // send the invite
                    userXbox360.Live.Friends.AddFriend(user, friend);

                    // wait for invite and accept it
                    friendXbox360.Live.Friends.WaitForFriendStatusRequested(friend, user);
                    friendXbox360.Live.Friends.AcceptFriendRequest(friend, user);

                    // log out both accounts
                    friendXbox360.Live.Logout(friend);
                    userXbox360.Live.Logout(user);
                }
                friendXbox360.ShutdownConsole();
                userXbox360.ShutdownConsole();
            }
            METHOD.EXIT();
        }

        private static void SendMessages(XblUser user, int numberMessages)
        {
            METHOD.ENTER();
            if (numberMessages > MaxMessages)
            {
                throw new ArgumentOutOfRangeException(String.Format(CultureInfo.CurrentCulture, "Cannot have > {0} messages", MaxMessages.ToString(CultureInfo.CurrentCulture)));
            }

            if (numberMessages > 0)
            {
                XblUser sender = null;
                if (!user.Settings.UserPassportInfo.MemberName.Equals(user.Settings.OwnerPassportInfo.MemberName))
                {
                    // children can only recieve messages from friends, so create a temporary friend
                    sender = Util.Accounts.CreateLiveAccount(XblUserTier.Gold, PassportType.Fake, false);
                    Util.Presence.MakeFriends(user, sender);
                    for (int i = 1; i <= numberMessages; i++)
                    {
                        String message = String.Format(CultureInfo.CurrentCulture, "Message{0}", i);
                        Util.Presence.SendMessage(sender, user, message);
                    }
                    DeleteFriend(user, sender);
                }
                else
                {
                    // create a fake user to send messages with
                    sender = Util.Accounts.CreateLiveAccount(XblUserTier.Gold, PassportType.Fake, false);
                    for (int i = 1; i <= numberMessages; i++)
                    {
                        String message = String.Format(CultureInfo.CurrentCulture, "Message{0}", i);
                        Util.Presence.SendMessage(sender, user, message);
                    }
                }
            }
            METHOD.EXIT();
        }

        private static void DeleteFriend(XblUser user, XblUser friend)
        {
            METHOD.ENTER();
            using (Xbox360 userXbox = new Xbox360(), friendXbox = new Xbox360())
            {
                userXbox.Live.Logon(user);
                friendXbox.Live.Logon(friend);
                PNState state = PNState.FindOrCreate(userXbox.Client, user, null);
                PNState buddyState = PNState.FindOrCreate(friendXbox.Client, friend, null);
                state.DeleteBuddy(buddyState);
                userXbox.Live.Logout(user);
                friendXbox.Live.Logout(friend);
                userXbox.ShutdownConsole();
                friendXbox.ShutdownConsole();
            }
            METHOD.EXIT();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\UserLib\Banning.cs ===
﻿using live.common;
using live.lfm;

namespace LiveN.Test.Users
{
    public struct BanSettings
    {
        private bool isGamertagBanned, isVoiceBanned, isLockedOut, isGeofenceExempt, isNicknameBanned;

        public BanSettings(bool isGamertagBanned, bool isVoiceBanned, bool isLockedOut, bool isGeofenceExempt, bool isNicknameBanned)
        {
            this.isGamertagBanned = isGamertagBanned;
            this.isVoiceBanned = isVoiceBanned;
            this.isLockedOut = isLockedOut;
            this.isGeofenceExempt = isGeofenceExempt;
            this.isNicknameBanned = isNicknameBanned;
        }

        #region Property Accessors
        public bool GamertagBanned
        {
            get
            {
                return this.isGamertagBanned;
            }
            set
            {
                this.isGamertagBanned = value;
            }
        }

        public bool VoiceBanned
        {
            get
            {
                return this.isVoiceBanned;
            }
            set
            {
                this.isVoiceBanned = value;
            }
        }

        public bool LockedOut
        {
            get
            {
                return this.isLockedOut;
            }
            set
            {
                this.isLockedOut = value;
            }
        }

        public bool GeofenceExempt
        {
            get
            {
                return this.isGeofenceExempt;
            }
            set
            {
                this.isGeofenceExempt = value;
            }
        }

        public bool NicknameBanned
        {
            get
            {
                return this.isNicknameBanned;
            }
            set
            {
                this.isNicknameBanned = value;
            }
        }
        #endregion
    }

    public sealed class Banning
    {
        private Banning() { }

        internal static void ApplyNewBans(BanSettings bans, XblUser user)
        {
            METHOD.ENTER();
            AccountInfo acctInfo = new AccountInfo();
            acctInfo.MustChangeXName = bans.GamertagBanned;
            acctInfo.IsVoiceBanned = bans.VoiceBanned;
            acctInfo.IsLockedOut = bans.LockedOut;
            acctInfo.IsGeofenceExempt = bans.GeofenceExempt;
            acctInfo.IsNicknameBanned = bans.NicknameBanned;

            using (Xbox360 xbox = new Xbox360())
            {
                xbox.Live.Logon(user);
                live.server.Cust.ModifyAccount(xbox.Client, user.Puid, acctInfo);
                xbox.Live.Logout(user);
                xbox.ShutdownConsole();
            }
            METHOD.EXIT();
        }

        internal static BanSettings GetCurrentBans(XblUser user)
        {
            METHOD.ENTER();
            AccountInfo acctInfo = new AccountInfo();
            using (Xbox360 xbox = new Xbox360())
            {
                xbox.Live.Logon(user);
                acctInfo = live.server.Cust.GetAccount(xbox.Client, user.Puid);
                xbox.Live.Logout(user);
                xbox.ShutdownConsole();
            }
            BanSettings currBans = new BanSettings(acctInfo.MustChangeXName, acctInfo.IsVoiceBanned, acctInfo.IsLockedOut, acctInfo.IsGeofenceExempt, acctInfo.IsNicknameBanned);
            METHOD.EXIT();
            return currBans;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\UserLib\AccountSetting.cs ===
﻿using System;
using System.Globalization;
using System.Linq;
using System.Xml;
using System.Xml.Linq;
using live.common;

namespace LiveN.Test.Users
{
    public enum ParentalControl
    {
        None,
        Partial,
        Strict
    }

    public class AccountSettings
    {
        private XblUserSettings settings;
        public XblUserSettings Settings
        {
            get
            {
                //If the settings weren't initialized we'll just assume a gold user and real passport type
                if (settings != null)
                    return settings;
                else
                    return new XblUserSettings(XblUserTier.Gold, PassportType.Real);
            }
            set
            {
                settings = value;
            }
        }

        public AccountSettings(XblUserTier tier, PassportType passportType)
        {
            SetAccountSettings(tier, passportType, null, null, null, CountryId.US, LanguageId.en, ParentalControl.None, true);
        }

        public AccountSettings(XblUserTier tier, PassportType passportType, string memberName, string password, string gamertag)
        {
            SetAccountSettings(tier, passportType, memberName, password, gamertag, CountryId.US, LanguageId.en, ParentalControl.None, true);
        }

        public AccountSettings(XblUserTier tier, PassportType passportType, string memberName, string password, string gamertag, CountryId countryId)
        {
            SetAccountSettings(tier, passportType, memberName, password, gamertag, countryId, this.GetDefaultLanguageForCountry(countryId), ParentalControl.None, true);
        }

        public AccountSettings(XblUserTier tier, PassportType passportType, ParentalControl parentalControl)
        {
            SetAccountSettings(tier, passportType, null, null, null, CountryId.US, LanguageId.en, parentalControl, true);
        }

        public AccountSettings(XblUserTier tier, PassportType passportType, string memberName, string password, string gamertag, CountryId countryId, ParentalControl parentalControl)
        {
            SetAccountSettings(tier, passportType, memberName, password, gamertag, countryId, this.GetDefaultLanguageForCountry(countryId), parentalControl, true);
        }

        public AccountSettings(XblUserTier tier, PassportType passportType, string memberName, string password, string gamertag, CountryId countryId, LanguageId languageId, ParentalControl parentalControl)
        {
            SetAccountSettings(tier, passportType, memberName, password, gamertag, countryId, languageId, parentalControl, true);
        }

        public AccountSettings(XblUserTier tier, PassportType passportType, string memberName, string password, string gamertag, CountryId countryId, LanguageId languageId, ParentalControl parentalControl, bool contactInformation)
        {
            SetAccountSettings(tier, passportType, memberName, password, gamertag, countryId, languageId, parentalControl, contactInformation);
        }

        /// <summary>
        /// Calls account settings and gets the settings data from the Accounts.xml based on the user input
        /// </summary>
        /// <param name="environment">The environment attribute from the Accounts.xml</param>
        /// <param name="userName">The username attribute from the Accounts.xml</param>
        public AccountSettings(string environment, string userName)
        {
            SetAccountSettings(environment, userName, null);
        }

        public AccountSettings(string environment, string userName, string xmlPath)
        {
            SetAccountSettings(environment, userName, xmlPath);
        }

        public AccountSettings(AccountSettings source)
        {
            settings = source.Settings;
        }

        /// <summary>
        /// Sets the private XblUserSettings class with data the user inputs
        /// </summary>
        /// <param name="tier">The account level of the user (Gold, Silver, etc...)</param>
        /// <param name="passportType">The type of passport account to create (Fake, Real, NewUser)</param>
        /// <param name="memberName">The username of the user (bradtotallyrules@xbltest.com)</param>
        /// <param name="password">The password for the account</param>
        /// <param name="gamertag">The gamertag for the account</param>
        /// <param name="countryId">The country for the account (has to be an Xbox supported country)</param>
        /// <param name="languageID">The language for the account</param>
        /// <param name="parentalControl">The level of parental control (Strict, None, etc...)</param>
        /// <param name="contactInformation">A true/false value for adding contact information to the personal info of the account</param>
        private void SetAccountSettings(XblUserTier tier, PassportType passportType, string memberName, string password, string gamertag, CountryId countryId, LanguageId languageID, ParentalControl parentalControl, bool contactInformation)
        {
            METHOD.ENTER();
            settings = new XblUserSettings(tier, passportType);

            //If we're not defaulting to the US we need to find the country and language ids
            if (countryId != CountryId.US)
            {
                AddressInfo[] countryAddress = Countries.CountryInfo(countryId).Addresses;
                if (countryAddress == null || countryAddress.Length == 0)
                {
                    throw new InvalidOperationException("No addresses are defined for country id " + countryId.ToString());
                }

                settings.PersonalInfo.AddressInfo = countryAddress[0];
                if (!new System.Collections.Generic.List<byte>(Countries.CountryInfo(countryId).LiveLanguages).Contains((byte)languageID))
                {
                    throw new ArgumentException(String.Format("Language id {0} is not supported for country id {1}", (uint)languageID, (uint)countryId));
                }

                /*
                 * Sets all CountryId elements in the XblUserSettings object to the countryId fed in.
                 * Sets all LanguageId elements in the XblUserSettings object to the languageId fed in.
                 */
                settings.PersonalInfo.CountryId = countryId;
                settings.OwnerPassportInfo.CountryId = countryId;
                settings.UserPassportInfo.CountryId = countryId;
                settings.PersonalInfo.LanguageId = (ushort)languageID;
            }

            // If empty, LiveLib will generate a random Windows Live Id
            if (!String.IsNullOrEmpty(memberName))
            {
                settings.UserPassportInfo.MemberName = memberName;
            }
            // If empty, LiveLib will assign a default password of 'supersecret'
            if (!String.IsNullOrEmpty(password)) 
            {
                settings.UserPassportInfo.Password = password;
            }
            // If empty, LiveLib will generate a random gamertag
            if (!String.IsNullOrEmpty(gamertag)) 
            {
                settings.PersonalInfo.Gamertag = gamertag;
            }
            // If the parental control is set to something besides none 
            if (parentalControl != ParentalControl.None)
            {
                DateTime birthday;
                if (parentalControl == ParentalControl.Strict)
                {
                    // set age to 10
                    birthday = new DateTime(
                        (DateTime.Today.Year) - 10, 
                        DateTime.Today.Month, 
                        DateTime.Today.Day, 0, 0, 0, 0, 
                        CultureInfo.CurrentCulture.Calendar, 
                        DateTimeKind.Local);
                }
                else
                {
                    // set age to 15
                    birthday = new DateTime(
                        (DateTime.Today.Year - 15), 
                        DateTime.Today.Month, 
                        DateTime.Today.Day, 0, 0, 0, 0, 
                        CultureInfo.CurrentCulture.Calendar, 
                        DateTimeKind.Local);
                }
                settings.PersonalInfo.BirthDate = birthday;
            }
            // LiveLib will set contact information by default, but accounts created on xbox.com have no contact information
            if (contactInformation == false) 
            {
                settings.PersonalInfo.AddressInfo.City = "";
                settings.PersonalInfo.AddressInfo.PostalCode = "";
                settings.PersonalInfo.AddressInfo.State = "";
                settings.PersonalInfo.AddressInfo.Street1 = "";
                settings.PersonalInfo.FirstName = "";
                settings.PersonalInfo.LastName = "";
                settings.PersonalInfo.PhoneInfo.PhoneExtension = "";
                settings.PersonalInfo.PhoneInfo.PhoneNumber = "";
                settings.PersonalInfo.PhoneInfo.PhonePrefix = "";
            }
            METHOD.EXIT();
        }

        /// <summary>
        /// Fills the AccountXMLData class with all pertinent data from the Accounts.xml file
        /// </summary>
        /// <param name="environment">The environment you want to get the user from (found in Accounts.xml)</param>
        /// <param name="userName">The user you want to get data for (found in Accounts.xml)</param>
        /// <returns>An AccountXMLData class object initialized from the Accounts.xml</returns>
        private void SetAccountSettings(string environment, string userName, string xmlPath)
        {
            METHOD.ENTER();
            XmlReader reader;
            XElement root;

            reader = GetXmlFile(xmlPath);
            root = XElement.Load(reader);

            //Ensure that the Linq can find the environment and name by forcing them to lowercase
            environment = environment.ToLower();
            userName = userName.ToLower();

            /*
             * Create a var to hold all the elements under the node with the fed in username
             *      If this element is null then we want to throw an error.
            */
            XElement userElement = root.Elements("Environment")
                .Where(e => e.Attribute("name").Value == environment)
                .Elements("User").Single(u => u.Attribute("name").Value == userName);

            if (userElement == null)
            {
                throw new Exception(
                    String.Format("No nodes could be found in Account.xml for environment {0} and user {1}", 
                    environment, 
                    userName)
                    );
            }
            else
            {
                /*
                 * CHILD ACCOUNT FLAG (Defaults to false if the attribute doesn't exist)
                 * TODO: Put handling code that will trigger child account creation using
                 *      information from the Account.xml file
                 */
                bool isChild = (bool?)userElement.Attribute("isChild") ?? false;

                #region Initialize the XblUserSettings that are required
                //XBLUSER SETTING (We get the default created by LiveLib then replace it with data from the xml)
                settings = new XblUserSettings(
                    (XblUserTier)Enum.Parse(typeof(XblUserTier), userElement.Attribute("tier").Value),
                    (PassportType)Enum.Parse(typeof(PassportType), userElement.Attribute("passporttype").Value)
                    );
                //EMAIL
                settings.OwnerPassportInfo.MemberName = 
                    settings.UserPassportInfo.MemberName = 
                    settings.PersonalInfo.Email =
                    GetElement("Email", environment, userName, userElement);
                //PASSWORD
                settings.OwnerPassportInfo.Password = 
                    settings.UserPassportInfo.Password =
                    GetElement("Password", environment, userName, userElement);
                //SECRET ANSWER
                settings.OwnerPassportInfo.SecretAnswer =
                    settings.UserPassportInfo.SecretAnswer =
                    GetElement("SecretAnswer", environment, userName, userElement);
                //SECRET QUESTION
                settings.OwnerPassportInfo.SecretQuestion =
                    settings.UserPassportInfo.SecretQuestion = 
                    GetElement("SecretQuestion", environment, userName, userElement);
                //GAMER TAG
                settings.PersonalInfo.Gamertag = GetElement("Gamertag", environment, userName, userElement);
                /* LOCALE (CountryID and LanguageID)
                  * 
                  * Here we set the string from the attribute first then we create a .NET container for the culture and
                  * region. We use these containers to find the proper values from the exsting enums of CountryId
                  * and LanguageId. This prevents us from having to modify the data furter down in the code
                  * 
                  */
                string locale = (string)userElement.Attribute("locale");
                CultureInfo culture = new CultureInfo(locale, false);
                CountryId countryId = (CountryId)Enum.Parse(typeof(CountryId),
                    new RegionInfo(culture.Name).TwoLetterISORegionName);

                settings.OwnerPassportInfo.CountryId = countryId;
                settings.UserPassportInfo.CountryId = countryId;
                settings.PersonalInfo.CountryId = countryId;

                settings.PersonalInfo.LanguageId = Convert.ToUInt16(
                    (LanguageId)Enum.Parse(typeof(LanguageId),
                    culture.Parent.ToString().ToLower()));
                #endregion

                #region Initialize XblUserSettings that can be null
                settings.PersonalInfo.FirstName = (string)userElement.Elements("ContactInformation").Single().Element("FirstName");
                settings.PersonalInfo.LastName = (string)userElement.Elements("ContactInformation").Single().Element("LastName");
                settings.PersonalInfo.AddressInfo.Street1 = (string)userElement.Elements("ContactInformation").Single().Element("Address1");
                settings.PersonalInfo.AddressInfo.Street2 = (string)userElement.Elements("ContactInformation").Single().Element("Address2");
                settings.PersonalInfo.AddressInfo.City = (string)userElement.Elements("ContactInformation").Single().Element("City");
                settings.PersonalInfo.AddressInfo.State = (string)userElement.Elements("ContactInformation").Single().Element("State");
                settings.PersonalInfo.AddressInfo.PostalCode = (string)userElement.Elements("ContactInformation").Single().Element("PostalCode");
                #endregion
            }
            METHOD.EXIT();
        }

        private static string GetElement(string nodeName, string environment, string userName, XElement userElement)
        {
            string element = (string)userElement.Element(nodeName);

            if (element == null)
            {
                throw new Exception(
                    String.Format("The {0} node could not be found in Account.xml for environment {1} and user {2}",
                    nodeName,
                    environment,
                    userName)
                    );
            }

            return element;
        }

        /// <summary>
        /// A method that calculates the default languageid for a countryid a user specifies
        /// </summary>
        /// <param name="countryId">The countryid enum</param>
        /// <returns></returns>
        public LanguageId GetDefaultLanguageForCountry(CountryId countryId)
        {
            LanguageId languageId = LanguageId.en;
            byte[] languages = Countries.CountryInfo(countryId).LiveLanguages;

            if (languages != null && languages.Length > 0)
            {
                languageId = (LanguageId)languages[0];
            }

            return languageId;
        }

        private static XmlReader GetXmlFile(string filePath)
        {
            XmlReader reader = null;
            
            //If the path is null we default to the XML we expect is with the project
            if (filePath == null)
                filePath = "Accounts.xml";

            //Verify that the filePath specified actually exists
            if (System.IO.File.Exists(filePath))
            {
                reader = XmlReader.Create(filePath);
            }
            else
            {
                throw new Exception(String.Format("The XML file you specified ({0}) could not be found.", filePath), 
                    new Exception("AccountSetting::GetXmlFile"));
            }
            
            return reader;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\UserLib\Avatar.cs ===
﻿using System;
using live.common;
using live.lfm;
using live.protocol;
using live.server;
using LiveN.Test.Users.Stf;
using ServerTestFramework.LiveService.AvatarAsset;

namespace LiveN.Test.Users
{
    public class Avatar
    {
        #region Privates
        internal Avatar(XblUser xblUser)
        {
            this.user = xblUser;
        }

        private XblUser user;
        private byte[] manifestData;

        private const uint AWARD_TITLE_ID = 0xFFFFBAAA;
        private static char[] manifestBuffer = new char[2000];
        private static char[] hexCharacterMap = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
        #endregion

        #region Public Properties
        public byte[] ManifestData
        {
            get { return manifestData; }
        }

        #endregion
        
        #region Read Manifests
        /// <summary>
        /// Reads the current accounts manifest.
        /// If the account has a manifest, it sets the manifest in memory. Otherwise, nothing happens.
        /// </summary>
        public void ReadManifest()
        {
            ReadSettingsResponse resp;
            using (Xbox360 xbox = new Xbox360())
            {
                xbox.Live.Logon(user);
                uint[] settings = new uint[1];
                settings[0] = ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_1;

                resp = UserSettings.ReadSettings(xbox.Client, user, xbox.Client.TitleId, new ulong[] { user.Puid }, settings);
                xbox.Live.Logout(user);
                xbox.ShutdownConsole();
            }


            if (resp.Settings[0] != null)
            {
                SetManifest(resp.Settings[0].Value);
            }
        }
        #endregion

        #region Set Manifest
        /// <summary>
        /// Sets the current account's manifest in memory. The change is not commited until WriteManifest is called.
        /// </summary>
        /// <param name="manifest">Manifest data in bytes</param>
        public void SetManifest(byte[] manifest)
        {
            this.manifestData = manifest;
        }
        #endregion

        #region Write Manifests
        /// <summary>
        /// Writes the current account's manifest to Live Service.
        /// Once the manifest is written, ManifestRead is called to validate the change.
        /// </summary>
        /// <returns>Manifest returned from the service.</returns>
        public byte[] WriteManifest()
        {
            UserSetting[] userSettings = new UserSetting[1];
            userSettings[0] = (new UserSetting(user.Puid, XOn.XSOURCE_DEFAULT, ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_1, manifestData));

            // Set manifest
            using (Xbox360 xbox = new Xbox360())
            {
                xbox.Live.Logon(user);
                UserSettings.SyncSettings(xbox.Client, user, xbox.Client.TitleId, userSettings, DateTime.UtcNow);
                xbox.Live.Logout(user);
                xbox.ShutdownConsole();
            }

            // Read manifest
            byte[] updatedManifestData;
            using (Xbox360 xbox = new Xbox360())
            {
                xbox.Live.Logon(user);
                uint[] settings = new uint[1];
                settings[0] = ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_1;

                ReadSettingsResponse resp = UserSettings.ReadSettings(xbox.Client, user, xbox.Client.TitleId, new ulong[] { user.Puid }, settings);
                updatedManifestData = resp.Settings[0].Value;
                xbox.Live.Logout(user);
                xbox.ShutdownConsole();
            }

            return updatedManifestData;
        }
        #endregion

        #region Assets        
        /// <summary>
        /// Enumerates the avatar assets that the current user has or has not achieved using LiveLib.
        /// NOTE: The returned list contains all assets, and the user must iterate through the list to find the achieved awards.
        /// BUSTED: This method, as it stands, does not work. It could be outdated LiveLib or incorrect schema version or invalid request. Use at your own risk.
        /// </summary>
        /// <returns>List of all awardable assets.</returns>
        public AvatarAsset[] EnumAvatarAsset_LL()
        {
            live.protocol.AvatarAssetEnumResponse resp;
            using (Xbox360 xbox = new Xbox360())
            {
                xbox.Live.Logon(user);
                AvatarAssetEnumRequest req = new AvatarAssetEnumRequest();
                req.ForPuid = user.Puid;
                req.LocaleId = 103;
                req.MaxAssets = 10;
                req.Puid = user.Puid;
                req.StartingIndex = 0;
                req.TitleId = AWARD_TITLE_ID;
                resp = new live.protocol.AvatarAssetEnumResponse();
                Throw.IfXErrFailed(xbox.Client.SendRequest(user, XOService.Stats, req.Xrl, "POST", null, req, resp));
                xbox.Live.Logout(user);
                xbox.ShutdownConsole();
            }
            return resp.AvatarAssets;
        }

        /// <summary>
        /// Enumerates the avatar assets that the current user has or has not achieved using Stf.
        /// NOTE: The returned list contains all assets, and the user must iterate through the list to find the achieved awards.
        /// </summary>
        /// <returns>List of all awardable assets.</returns>
        public AvatarAssetWD[] EnumAvatarAsset_Stf()
        {
            AvatarAssetWD[] responseAssets = StfProxy.EnumAvatarAssets(AWARD_TITLE_ID, user.Puid);

            return responseAssets;
        }

        /// <summary>
        /// Awards the given list of avatar assets to the current user using LiveLib.
        /// BUSTED: This method, as it stands, does not work. It could be outdated LiveLib or incorrect schema version or invalid request. Use at your own risk.
        /// </summary>
        /// <param name="awardableAssetList">List of assets to award.</param>
        public void AwardAvatarAsset_LL(AvatarAsset[] awardableAssetList)
        {            
            using (Xbox360 xbox = new Xbox360())
            {
                xbox.Live.Logon(user);
                SyncAvatarAssetRequest req = new SyncAvatarAssetRequest();
                req.AvatarAssets = awardableAssetList;
                // todo: add description, etc
                req.AvatarAssetCount = (ushort)awardableAssetList.Length;
                req.LocaleId = 103;
                req.StartingIndex = 0;
                req.TitleId = AWARD_TITLE_ID;
                req.UserId = user.Puid;
                req.Version = DateTime.Now;

                SyncAvatarAssetResponse resp = new SyncAvatarAssetResponse();
                Throw.IfXErrFailed(xbox.Client.SendRequest(user, XOService.Stats, req.Xrl, "POST", null, req, resp));
                xbox.Live.Logout(user);
                xbox.ShutdownConsole();
            }
        }

        /// <summary>
        /// Awards the given avatar asset to the current user using Stf.
        /// </summary>
        /// <param name="awardableAsset">Avatar asset to award.</param>
        public void AwardAvatarAsset_Stf(AvatarAssetWD awardableAsset)
        {
            AwardAvatarAsset_Stf(new AvatarAssetWD[] { awardableAsset });
        }

        /// <summary>
        /// Awards the given list of avatar assets to the current user using Stf.
        /// </summary>
        /// <param name="awardableAssetList">List of assets to award.</param>
        public void AwardAvatarAsset_Stf(AvatarAssetWD[] awardableAssetList)
        {
            StfProxy.AwardAvatarAssets(AWARD_TITLE_ID, user.Puid, awardableAssetList);
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\UserLib\Feedback.cs ===
﻿using System;
using live.common;
using live.lfm;
using live.protocol;

namespace LiveN.Test.Users
{
    public class Feedback
    {
        private XblUser _user;

        /// <summary>
        /// Constructor for the Feedback class
        /// </summary>
        /// <param name="user">The underlying XblUser whose repuation settings are going to be changed/retrieved</param>
        public Feedback(XblUser user)
        {
            _user = user;
        }

        public void AlterReputation(double starValue)
        {
            METHOD.ENTER();
            CheckStarValue(starValue);
            using (Xbox360 xbox = new Xbox360())
            {
                xbox.Live.Logon(_user);
                double currentRep = GetCurrentRepValue(xbox);
                double lastRep = currentRep;
                double currentStars = Profile.ConvertRepToStars(currentRep);
                while (currentStars != starValue)
                {
                    if (currentStars < starValue)
                    {
                        IncreaseStars();
                    }
                    else
                    {
                        DecreaseStars();
                    }
                    //it takes a bit of time before rep updates on the backend, so keep querying until it changes
                    while (lastRep == currentRep)
                    {
                        System.Threading.Thread.Sleep(500); //give the CPU and the backend a rest before querying
                        currentRep = GetCurrentRepValue(xbox);
                    }
                    currentStars = Profile.ConvertRepToStars(currentRep);
                    lastRep = currentRep;
                }
                xbox.Live.Logout(_user);
                xbox.ShutdownConsole();
            }
            METHOD.EXIT();
        }

        /// <summary>
        /// Increases a users reputation by having another player play with the user and submit a positive review
        /// </summary>
        private void IncreaseStars()
        {
            METHOD.ENTER();
            using (Xbox360 playerXbox = new Xbox360())
            {
                //reputation is increased when the user's player list grows, so add more players
                XblUser player = Util.Accounts.CreateLiveAccount(XblUserTier.Gold, PassportType.Fake, false);
                playerXbox.Live.Logon(player);

                live.server.Presence.AddAffiliate(playerXbox.Client, player, _user,
                    live.protocol.Presence.AffiliateFlags.CompletedGame);
                playerXbox.Live.Feedback.SubmitPlayerReview(_user.Puid, FeedbackDefs.PlayerReview.Prefer);

                // log the player account out
                playerXbox.Live.Logout(player);
                playerXbox.ShutdownConsole();
            }
            METHOD.EXIT();
        }

        /// <summary>
        /// Decreases a user's reputation by having another player play a game with the user and submit a negative review
        /// </summary>
        private void DecreaseStars()
        {
            METHOD.ENTER();
            using (Xbox360 playerXbox = new Xbox360())
            {
                //reputation is decreased when user recieves negative reviews from other players
                XblUser player = Util.Accounts.CreateLiveAccount(XblUserTier.Gold, PassportType.Fake, false);
                playerXbox.Live.Logon(player);

                live.server.Presence.AddAffiliate(playerXbox.Client, player, _user,
                    live.protocol.Presence.AffiliateFlags.CompletedGame);
                playerXbox.Live.Feedback.SubmitPlayerReview(_user.Puid, FeedbackDefs.PlayerReview.AvoidTrashTalk);

                // log the player account out
                playerXbox.Live.Logout(player);
                playerXbox.ShutdownConsole();
            }
            METHOD.EXIT();
        }

        /// <summary>
        /// Retrieves the raw reputation score from the LIVE backend
        /// </summary>
        /// <param name="xbox"></param>
        /// <returns></returns>
        private double GetCurrentRepValue(Xbox360 xbox)
        {
            METHOD.ENTER();
            uint[] settings = new uint[1];
            settings[0] = ProfileDefs.XPROFILE_GAMERCARD_REP;
            ReadSettingsResponse resp = live.server.UserSettings.ReadSettings(xbox.Client, _user, xbox.Client.TitleId, new ulong[] { _user.Puid }, settings);
            float fRaw = BitConverter.ToSingle(resp.Settings[0].Value, 0);
            METHOD.EXIT();
            return (double)fRaw;
        }

        /// <summary>
        /// Verifies that the star value passed into AlterReputation() is valid
        /// </summary>
        /// <param name="starValue"></param>
        private static void CheckStarValue(double starValue)
        {
            METHOD.ENTER();
            if ((starValue > 5) || (starValue < 0))
            {
                throw new ArgumentOutOfRangeException("starValue", "must be between 0 and 5");
            }
            double decimalValue = starValue - Math.Floor(starValue);
            if (decimalValue != 0.0)
            {
                if (decimalValue != 0.25)
                {
                    if (decimalValue != 0.5)
                    {
                        if (decimalValue != 0.75)
                        {
                            throw new ArgumentOutOfRangeException("starValue", "must have a decimal value of .0, .25, .5, or .75");
                        }
                    }
                }
            }
            METHOD.EXIT();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\UserLib\Friends.cs ===
﻿using System;
using System.Collections.ObjectModel;
using System.Globalization;
using live.common;
using live.lfm;
using live.protocol.Presence;

namespace LiveN.Test.Users
{
    public sealed class Friends
    {
        // max values
        public static readonly int MaxFriends = 1000;
        public static readonly int MaxPlayers = 50;
        public static readonly int MaxMessages = 100;

        private Friends() { }

        internal static void CreateFriends(XblUser user, int numberMessages, int numberFriends, int numberPlayers, Collection<PassportInfo> friendPIs, Collection<PassportInfo> playerPIs)
        {
            METHOD.ENTER();
            int numberRealFriends = (friendPIs != null) ? friendPIs.Count : 0;
            int numberRealPlayers = (playerPIs != null) ? playerPIs.Count : 0;

            // create friends
            if (friendPIs != null)
            {
                AddRealFriends(user, friendPIs);
                numberFriends = numberFriends - numberRealFriends;
            }
            AddFakeFriends(user, numberFriends);

            // add recent players
            if (playerPIs != null)
            {
                AddRealPlayers(user, playerPIs);
                numberPlayers = numberPlayers - numberRealPlayers;
            }
            AddFakePlayers(user, numberPlayers);

            // send messages
            SendMessages(user, numberMessages);
            METHOD.EXIT();
        }

        private static void AddFakePlayers(XblUser user, int numberPlayers)
        {
            METHOD.ENTER();
            if (numberPlayers > MaxPlayers)
            {
                throw new ArgumentOutOfRangeException(String.Format(CultureInfo.CurrentCulture, "Cannot have > {0} players", MaxPlayers.ToString(CultureInfo.CurrentCulture)));
            }
            for (int i = 0; i < numberPlayers; i++)
            {
                XblUser player = Util.Accounts.CreateLiveAccount(XblUserTier.Gold, PassportType.Fake, false);
                Util.Presence.AddRecentPlayer(user, player);
            }
            METHOD.EXIT();
        }

        private static void AddRealPlayers(XblUser user, Collection<PassportInfo> playerPIs)
        {
            METHOD.ENTER();
            if (playerPIs.Count > MaxPlayers)
            {
                throw new ArgumentOutOfRangeException(String.Format(CultureInfo.CurrentCulture, "Cannot have > {0} players", MaxPlayers.ToString(CultureInfo.CurrentCulture)));
            }
            using (Xbox360 playerXbox360 = new Xbox360(), userXbox360 = new Xbox360())
            {
                foreach (PassportInfo ppi in playerPIs)
                {
                    // retrieve the player account
                    Account playerAcct = new Account(ppi.MemberName, ppi.Password);
                    XblUser player = playerAcct.XblUser;

                    // The Util.Presence.AddRecentPlayer() function does not work with previously existing accounts
                    // so we need to add players the hard way...                    
                    // sign the user and player into LIVE on their own consoles
                    playerXbox360.Live.Logon(player);
                    userXbox360.Live.Logon(user);

                    // add player and user to each other's recent players list
                    live.server.Presence.AddAffiliate(userXbox360.Client, user, player,
                        live.protocol.Presence.AffiliateFlags.CompletedGame);
                    live.server.Presence.AddAffiliate(playerXbox360.Client, player, user,
                        live.protocol.Presence.AffiliateFlags.CompletedGame);

                    // log both accounts out
                    playerXbox360.Live.Logout(player);
                    userXbox360.Live.Logout(user);
                }
                playerXbox360.ShutdownConsole();
                userXbox360.ShutdownConsole();
            }
            METHOD.EXIT();
        }

        private static void AddFakeFriends(XblUser user, int numberFriends)
        {
            METHOD.ENTER();
            if (numberFriends > MaxFriends)
            {
                throw new ArgumentOutOfRangeException(String.Format(CultureInfo.CurrentCulture, "Cannot have > {0} friends", MaxFriends.ToString(CultureInfo.CurrentCulture)));
            }
            for (int i = 0; i < numberFriends; i++)
            {
                XblUser friend = Util.Accounts.CreateLiveAccount(XblUserTier.Gold, PassportType.Fake, false);
                Util.Presence.MakeFriends(user, friend);
            }
            METHOD.EXIT();
        }

        private static void AddRealFriends(XblUser user, Collection<PassportInfo> friendPIs)
        {
            METHOD.ENTER();
            if (friendPIs.Count > MaxFriends)
            {
                throw new ArgumentOutOfRangeException(String.Format(CultureInfo.CurrentCulture, "Cannot have > {0} friends", MaxFriends.ToString(CultureInfo.CurrentCulture)));
            }
            using (Xbox360 friendXbox360 = new Xbox360(), userXbox360 = new Xbox360())
            {
                foreach (PassportInfo ppi in friendPIs)
                {
                    // retrieve the friend account
                    Account friendAcct = new Account(ppi.MemberName, ppi.Password);
                    XblUser friend = friendAcct.XblUser;

                    // The Util.Presence.MakeFriends() function does not work with previously existing accounts
                    // so we need to make friends the hard way...
                    // sign the user and friend into LIVE on their own consoles
                    friendXbox360.Live.Logon(friend);
                    userXbox360.Live.Logon(user);

                    // send the invite
                    userXbox360.Live.Friends.AddFriend(user, friend);

                    // wait for invite and accept it
                    friendXbox360.Live.Friends.WaitForFriendStatusRequested(friend, user);
                    friendXbox360.Live.Friends.AcceptFriendRequest(friend, user);

                    // log out both accounts
                    friendXbox360.Live.Logout(friend);
                    userXbox360.Live.Logout(user);
                }
                friendXbox360.ShutdownConsole();
                userXbox360.ShutdownConsole();
            }
            METHOD.EXIT();
        }

        private static void SendMessages(XblUser user, int numberMessages)
        {
            METHOD.ENTER();
            if (numberMessages > MaxMessages)
            {
                throw new ArgumentOutOfRangeException(String.Format(CultureInfo.CurrentCulture, "Cannot have > {0} messages", MaxMessages.ToString(CultureInfo.CurrentCulture)));
            }

            if (numberMessages > 0)
            {
                XblUser sender = null;
                if (!user.Settings.UserPassportInfo.MemberName.Equals(user.Settings.OwnerPassportInfo.MemberName))
                {
                    // children can only recieve messages from friends, so create a temporary friend
                    sender = Util.Accounts.CreateLiveAccount(XblUserTier.Gold, PassportType.Fake, false);
                    Util.Presence.MakeFriends(user, sender);
                    for (int i = 1; i <= numberMessages; i++)
                    {
                        String message = String.Format(CultureInfo.CurrentCulture, "Message{0}", i);
                        Util.Presence.SendMessage(sender, user, message);
                    }
                    DeleteFriend(user, sender);
                }
                else
                {
                    // create a fake user to send messages with
                    sender = Util.Accounts.CreateLiveAccount(XblUserTier.Gold, PassportType.Fake, false);
                    for (int i = 1; i <= numberMessages; i++)
                    {
                        String message = String.Format(CultureInfo.CurrentCulture, "Message{0}", i);
                        Util.Presence.SendMessage(sender, user, message);
                    }
                }
            }
            METHOD.EXIT();
        }

        private static void DeleteFriend(XblUser user, XblUser friend)
        {
            METHOD.ENTER();
            using (Xbox360 userXbox = new Xbox360(), friendXbox = new Xbox360())
            {
                userXbox.Live.Logon(user);
                friendXbox.Live.Logon(friend);
                PNState state = PNState.FindOrCreate(userXbox.Client, user, null);
                PNState buddyState = PNState.FindOrCreate(friendXbox.Client, friend, null);
                state.DeleteBuddy(buddyState);
                userXbox.Live.Logout(user);
                friendXbox.Live.Logout(friend);
                userXbox.ShutdownConsole();
                friendXbox.ShutdownConsole();
            }
            METHOD.EXIT();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\UserLib\Offers.cs ===
﻿using System;
using live.protocol;

namespace LiveN.Test.Users
{
    public class MarketplaceOffer
    {
        public OfferMediaTypeExpectedPrice offerInfo;

        #region Constructors
        /// <summary>
        /// Default Constructor
        /// </summary>
        public MarketplaceOffer()
        {
            offerInfo = new OfferMediaTypeExpectedPrice();
        }

        /// <summary>
        /// Constructor using a 16 char hex offerId
        /// </summary>
        /// <param name="offerId">16 hex character offerId</param>
        /// <param name="mediaType">MediaTypeEnum value for offer type</param>
        /// <param name="expectedPrice">Expected price of the offer</param>
        public MarketplaceOffer(string offerId, int mediaType, uint expectedPrice)
            : this(OfferIdToGuid(offerId), mediaType, expectedPrice)
        {
        }

        /// <summary>
        /// Constructor using a Guid object
        /// </summary>
        /// <param name="offerGuid">Guid object representing the offer's Id</param>
        /// <param name="mediaType">MediaTypeEnum value for offer type</param>
        /// <param name="expectedPrice">Expected price of the offer</param>
        public MarketplaceOffer(Guid offerGuid, int mediaType, uint expectedPrice)
        {
            offerInfo = new OfferMediaTypeExpectedPrice();
            offerInfo.mediaTypeId = mediaType;
            offerInfo.expectedPriceWhole = expectedPrice;
            offerInfo.offerId = offerGuid;
        }
        #endregion

        #region OfferId and Guid Conversion Functions
        /// <summary>
        /// Converts a 16 hex character offerId to a Guid object
        /// </summary>
        /// <param name="offerId">16 hex character offerId string</param>
        /// <returns>Guid object representing the offer's Id</returns>
        public static Guid OfferIdToGuid(string offerId)
        {
            if (offerId.Length != 16)
            {
                throw new ArgumentException("OfferID must be 16 hex characters long; OfferId passed in: " + offerId);
            }

            String TitleId = offerId.Substring(0, 8);
            String Offer = offerId.Substring(8, 8);

            return new Guid(Offer + "-0000-4000-8000-0000" + TitleId);

        }

        /// <summary>
        /// Converts a Guid object to a 16 hex character offerId string
        /// </summary>
        /// <param name="guid">Guid object representing the offer's Id</param>
        /// <returns>16 hex character offerId string</returns>
        public static string GuidToOfferId(Guid guid)
        {
            String GuidString = guid.ToString();

            String TitleId = GuidString.Substring(28, 8);
            String OfferId = GuidString.Substring(0, 8);

            return TitleId + OfferId;
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\UserLib\Profile.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using live.common;
using live.lfm;
using live.protocol;
using live.server;

namespace LiveN.Test.Users
{
    //gamer zone values
    public enum GamerZone
    {
        None = 0,
        Recreation = 1,
        Pro,
        Family,
        Underground
    }

    public class Profile
    {
        #region Properties
        private UserSetting[] userSettings = new UserSetting[NumSettings];
        private XblUser _user;

        //max values
        public const int MaxMotto = 21;
        public const int MaxName = 129;
        public const int MaxLocation = 40;
        public const int MaxBio = 499;

        //Important! The value of NumSettings should match the number of settings in the Settings enumerator,
        //else you will get 'Index out of range' when calling ReadUserSettings()
        private const int NumSettings = 13;

        /// <summary>
        /// Private enumerator for tracking the position of each item in the userSettings array
        /// Used in all 'Get' methods and in the ReadUserSettings() function
        /// </summary>
        private enum Settings
        {
            score = 0,
            motto,
            personalPic,
            gamerPic,
            region,
            rep,
            bio,
            location,
            name,
            zone,
            achievementsEarned,
            titlesPlayed,
            avatar
        }
        #endregion

        /// <summary>
        /// Constructor for the GamerProfile class
        /// </summary>
        /// <param name="user">The underlying XblUser whose gamer profile settings are going to be changed/retrieved</param>
        public Profile(XblUser user)
        {
            _user = user;
        }

        #region GamerPic array
        /// <summary>
        /// Reference array for storing gamerpic keys
        /// </summary>
        private string[] _gamerPictures = {                    
                    // Gamerpics unique to GFWL
                    "585207d10002000100010001\0", //bubbles
                    "585207d10002000200010002\0", //dragon
                    "585207d10002000300010003\0", //blue guy1
                    "585207d10002000400010004\0", //gorrilla
                    "585207d10002000500010005\0", //fish
                    "585207d10002000600010006\0", //kitty
                    "585207d10002000700010007\0", //blue guy2
                    "585207d10002000800010008\0", //chess
                    "585207d10002000900010009\0", //purple chatter
                    "585207d10002000a0001000a\0", //elf lady
                    "585207d10002000b0001000b\0", //horse
                    "585207d10002000c0001000c\0", //red-haired alien
                    "585207d10002000d0001000d\0", //green monster1
                     // Gamerpics on GFWL and Xbox
                    "fffe07d10002000100010001\0", //xbox rings
                    "fffe07d10002000200010002\0", //boy
                    "fffe07d10002000300010003\0", //chimp
                    "fffe07d10002000400010004\0", //smiley
                    "fffe07d10002000500010005\0", //pirate
                    "fffe07d10002000600010006\0", //panda
                    "fffe07d10002000700010007\0", //pink-haired girl
                    "fffe07d10002000800010008\0", //drogon sillouette
                    "fffe07d10002000900010009\0", //dog
                    "fffe07d10002000a0001000a\0", //blue guy3
                    "fffe07d10002000b0001000b\0", //soccer ball
                    "fffe07d10002000c0001000c\0"}; //skull

        /// <summary>
        /// Selects a random picture key that can be used when setting the gamer or personal picture
        /// </summary>
        /// <returns>A string which represents a valid picture on LIVE</returns>
        public string SelectRandomPicture()
        {
            Random rand = new Random();
            int randomPic = rand.Next(_gamerPictures.Length);
            return _gamerPictures[randomPic];
        }
        #endregion

        #region Avatar arrays
        // Male Avatar metadata.
        public byte[] MaleAvatar = { 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xBF, 0x80, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x03, 0x1A, 0x00, 0x03, 
            0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0, 0x00, 0x08, 0x00, 0x00, 0x03, 0x2E, 0x00, 0x03, 0xC1, 0xC8, 0xF1, 0x09, 
            0xA1, 0x9C, 0xB2, 0xE0, 0x00, 0x20, 0x00, 0x00, 0x03, 0x36, 0x00, 0x03, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0, 
            0x00, 0x00, 0x80, 0x00, 0x02, 0xEB, 0x00, 0x03, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0, 0x3F, 0x80, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x02, 0xA6, 0x00, 0x03, 
            0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0, 0x3F, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x02, 0x71, 0x00, 0x03, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0, 
            0x3F, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xD7, 0xB9, 0x71, 0xFF, 0x52, 0x34, 0x36, 
            0xFF, 0x83, 0x46, 0x3F, 0xFF, 0x63, 0x81, 0xA7, 0xFF, 0x52, 0x34, 0x36, 0xFF, 0x90, 0x4F, 0x33, 0xFF, 0x52, 0x34, 0x36, 
            0xFF, 0x5F, 0x42, 0x94, 0xFF, 0x5F, 0x42, 0x94, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0xC1, 0xC8, 0xF1, 0x09, 
            0xA1, 0x9C, 0xB2, 0xE0, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0, 0x00, 0x01, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x02, 0x1F, 0x00, 0x03, 
            0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x61, 0x00, 0x01, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0, 
            0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 
            0x00, 0x99, 0x00, 0x01, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x35, 0x00, 0x01, 0xC1, 0xC8, 0xF1, 0x09, 
            0xA1, 0x9C, 0xB2, 0xE0, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x35, 0x00, 0x01, 0xC1, 0xC8, 0xF1, 0x09, 
            0xA1, 0x9C, 0xB2, 0xE0, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x10, 0x00, 0x99, 0x00, 0x01, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0, 0x00, 0x10, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x61, 0x00, 0x01, 
            0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x02, 0x1F, 0x00, 0x03, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0, 
            0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x15, 0xB9, 
            0xD8, 0x5C, 0x4C, 0x90, 0x06, 0x35, 0xC4, 0xC9, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                            };

        public byte[] FemaleAvatarMetadata = { 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x03, 0x1F, 0x00, 0x03, 
            0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0, 0x00, 0x08, 0x00, 0x00, 0x03, 0x2F, 0x00, 0x03, 0xC1, 0xC8, 0xF1, 0x09, 
            0xA1, 0x9C, 0xB2, 0xE0, 0x00, 0x20, 0x00, 0x00, 0x03, 0x3C, 0x00, 0x03, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0, 
            0x00, 0x00, 0x80, 0x00, 0x02, 0xEC, 0x00, 0x03, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0, 0x3F, 0x80, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x02, 0x92, 0x00, 0x03, 
            0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0, 0x3F, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x02, 0x61, 0x00, 0x03, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0, 
            0x3F, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xA8, 0x7D, 0x3F, 0xFF, 0x52, 0x34, 0x36, 
            0xFF, 0x87, 0x57, 0x41, 0xFF, 0x21, 0x21, 0x21, 0xFF, 0x52, 0x34, 0x36, 0xFF, 0xA2, 0xA8, 0x9B, 0xFF, 0x52, 0x34, 0x36, 
            0xFF, 0x8A, 0xBF, 0x55, 0xFF, 0x8A, 0xBF, 0x55, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0x00, 0x02, 0xC1, 0xC8, 0xF1, 0x09, 
            0xA1, 0x9C, 0xB2, 0xE0, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0, 0x00, 0x01, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x02, 0x33, 0x00, 0x03, 
            0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x13, 0x00, 0x02, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0, 
            0x00, 0x08, 0x00, 0x00, 0xFF, 0x61, 0xE7, 0x67, 0xFF, 0x61, 0xE7, 0x67, 0xFF, 0x61, 0xE7, 0x67, 0x00, 0x00, 0x00, 0x10, 
            0x01, 0x67, 0x00, 0x02, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x01, 0x0B, 0x00, 0x02, 0xC1, 0xC8, 0xF1, 0x09, 
            0xA1, 0x9C, 0xB2, 0xE0, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x01, 0x0B, 0x00, 0x02, 0xC1, 0xC8, 0xF1, 0x09, 
            0xA1, 0x9C, 0xB2, 0xE0, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x10, 0x01, 0x67, 0x00, 0x02, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0, 0x00, 0x10, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x13, 0x00, 0x02, 
            0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0, 0x00, 0x08, 0x00, 0x00, 0xFF, 0x61, 0xE7, 0x67, 0xFF, 0x61, 0xE7, 0x67, 
            0xFF, 0x61, 0xE7, 0x67, 0x00, 0x00, 0x00, 0x04, 0x02, 0x33, 0x00, 0x03, 0xC1, 0xC8, 0xF1, 0x09, 0xA1, 0x9C, 0xB2, 0xE0, 
            0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xED, 0x24, 0x26, 0x91, 
            0x84, 0x35, 0x28, 0xCE, 0x06, 0x35, 0xC4, 0xC9, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                              };
        #endregion

        #region Get methods for read-only settings
        /// <summary>
        /// Get accessor for AcheivementsEarned profile setting
        /// AchievementsEarned cannot be set directly
        /// Have the user play games to see this value change (call CreateGameHistory())
        /// </summary>
        public uint AchievementsEarned
        {
            get
            {
                userSettings = ReadUserSettings();
                if (userSettings[(int)Settings.achievementsEarned].Source == 1)
                {
                    return BitConverter.ToUInt32(userSettings[(int)Settings.achievementsEarned].Value, 0);
                }
                else
                {
                    return 0; //the user has not played any games
                }
            }
        }

        /// <summary>
        /// Returns the raw reputation value, which is the value on the backend before it has been converted to stars
        /// </summary>
        public double RawRep
        {
            get
            {
                userSettings = ReadUserSettings();
                if (userSettings[(int)Settings.rep].Source == 1)
                {
                    float fRaw = BitConverter.ToSingle(userSettings[(int)Settings.rep].Value, 0);
                    return (double)fRaw;
                }
                else
                {
                    //rep should always be available, throw an exception if it is not
                    throw new InvalidOperationException("Failed to retrieve the raw rep value from LIVE");
                }
            }
        }

        /// <summary>
        /// Returns the full gamer pic value (gamerpic and personal pic combined)
        /// </summary>
        public string RawGamerPicture
        {
            get
            {
                userSettings = ReadUserSettings();
                if (userSettings[(int)Settings.gamerPic].Source == 1)
                {
                    string gamerpic = UnicodeEncoding.Unicode.GetString(userSettings[(int)Settings.gamerPic].Value);
                    return gamerpic;
                }
                else
                {
                    return String.Empty;
                }
            }
        }

        /// <summary>
        /// Get accessor for the Rep (stars) on the user's gamercard
        /// Rep cannot be set directly, call Feedback.AlterReputation() instead.
        /// Rep can be increased by playing with other players
        /// Rep can be decreased when other players submit negative reviews
        /// </summary>
        public double Rep
        {
            get
            {
                userSettings = ReadUserSettings();
                if (userSettings[(int)Settings.rep].Source == 1)
                {
                    float fRaw = BitConverter.ToSingle(userSettings[(int)Settings.rep].Value, 0);
                    return ConvertRepToStars((double)fRaw);
                }
                else
                {
                    //rep should always be available, throw an exception if it is not
                    throw new InvalidOperationException("Failed to retrieve rep");
                }
            }
        }

        /// <summary>
        /// Get accessor for Score item on the user's gamercard
        /// </summary>
        public uint Score
        {
            get
            {
                userSettings = ReadUserSettings();
                if (userSettings[(int)Settings.score].Source == 1)
                {
                    return BitConverter.ToUInt32(userSettings[(int)Settings.score].Value, 0);
                }
                else
                {
                    return 0; //the user has not played any games
                }
            }
        }

        /// <summary>
        /// Get accessor for the TitlesPlayed profile setting
        /// TitlesPlayed cannot be set directly
        /// Have the user play games to see this value change (call CreateGameHistory())
        /// </summary>
        public uint TitlesPlayed
        {
            get
            {
                userSettings = ReadUserSettings();
                if (userSettings[(int)Settings.titlesPlayed].Source == 1)
                {
                    return BitConverter.ToUInt32(userSettings[(int)Settings.titlesPlayed].Value, 0);
                }
                else
                {
                    return 0; //the user has not played any games
                }
            }
        }
        #endregion

        #region Get and Set methods for read/write profile settings
        /// <summary>
        /// Get and Set accessors for the users Avatar data
        /// </summary>
        public byte[] Avatar
        {
            get
            {
                userSettings = ReadUserSettings();
                return userSettings[(int)Settings.avatar].Value;
            }
            set
            {
                WriteProfileSettings(null, null, null, null, null, null, value, null, null);
            }
        }

        /// <summary>
        /// Get and Set accessors for GamerPic item on the user's gamercard
        /// </summary>
        public string GamerPicture
        {
            get
            {
                userSettings = ReadUserSettings();
                if (userSettings[(int)Settings.gamerPic].Source == 1)
                {
                    string gamerpic = UnicodeEncoding.Unicode.GetString(userSettings[(int)Settings.gamerPic].Value);
                    if (!String.IsNullOrEmpty(gamerpic) && gamerpic.Length > 24)
                    {
                        //if the gamerpic and personal pic are different, the picture key will contain both strings, 
                        //only return the gamer pic (first 24 characters)
                        return UnicodeEncoding.Unicode.GetString(userSettings[(int)Settings.gamerPic].Value).Substring(0, 24);
                    }
                    else
                    {
                        return gamerpic;
                    }
                }
                else
                {
                    return String.Empty;
                }
            }
            set
            {
                WriteProfileSettings(null, null, null, null, value, null, null, null, null);
            }
        }

        /// <summary>
        /// Get and Set accessors for the PersonalPic item on the user's gamercard
        /// </summary>
        public string PersonalPicture
        {
            get
            {
                userSettings = ReadUserSettings();
                if (userSettings[(int)Settings.personalPic].Source == 1)
                {
                    return UnicodeEncoding.Unicode.GetString(userSettings[(int)Settings.personalPic].Value);
                }
                else
                {
                    return String.Empty;
                }
            }
            set
            {
                WriteProfileSettings(null, null, null, null, null, value, null, null, null);
            }
        }

        /// <summary>
        /// Get and Set accessors for Bio field on the user's extended gamercard
        /// </summary>
        public string Bio
        {
            get
            {
                userSettings = ReadUserSettings();
                if (userSettings[(int)Settings.bio].Source == 1)
                {
                    return UnicodeEncoding.Unicode.GetString(userSettings[(int)Settings.bio].Value);
                }
                else
                {
                    return String.Empty;
                }
            }
            set
            {
                WriteProfileSettings(null, null, null, value, null, null, null, null, null);
            }
        }

        /// <summary>
        /// Get and Set accessors for Location field on the user's extended gamercard
        /// </summary>
        public string Location
        {
            get
            {
                userSettings = ReadUserSettings();
                if (userSettings[(int)Settings.location].Source == 1)
                {
                    return UnicodeEncoding.Unicode.GetString(userSettings[(int)Settings.location].Value);
                }
                else
                {
                    return String.Empty;
                }
            }
            set
            {
                WriteProfileSettings(null, null, value, null, null, null, null, null, null);
            }
        }

        /// <summary>
        /// Get and Set accessors for Name field on the user's extended gamercard
        /// </summary>
        public string Name
        {
            get
            {
                userSettings = ReadUserSettings();
                if (userSettings[(int)Settings.name].Source == 1)
                {
                    return UnicodeEncoding.Unicode.GetString(userSettings[(int)Settings.name].Value);
                }
                else
                {
                    return String.Empty;
                }
            }
            set
            {
                WriteProfileSettings(null, value, null, null, null, null, null, null, null);
            }
        }

        /// <summary>
        /// Get and Set accessors for Motto field on the user's extended gamercard
        /// </summary>
        public string Motto
        {
            get
            {
                userSettings = ReadUserSettings();
                if (userSettings[(int)Settings.motto].Source == 1)
                {
                    return UnicodeEncoding.Unicode.GetString(userSettings[(int)Settings.motto].Value);
                }
                else
                {
                    return String.Empty;
                }
            }
            set
            {
                WriteProfileSettings(value, null, null, null, null, null, null, null, null);
            }
        }

        /// <summary>
        /// Get and Set accessors for the Region item on the user's extended gamercard
        /// Region is determined by the user's physical location, so anything that you set it to here
        /// will be overwritten if the user account is signed into Games for Windows - LIVE.
        /// </summary>
        public CountryId Region
        {
            get
            {
                userSettings = ReadUserSettings();
                if (userSettings[(int)Settings.region].Source == 1)
                {
                    UInt32 region = BitConverter.ToUInt32(userSettings[(int)Settings.region].Value, 0);
                    return (CountryId)Convert.ToByte(region);
                }
                else
                {
                    throw new InvalidOperationException("Region has not been set for this account");
                }
            }
            set
            {
                WriteProfileSettings(null, null, null, null, null, null, null, null, value);
            }
        }

        /// <summary>
        /// Get and Set accessors for the Zone item on the user's gamercard
        /// </summary>
        public GamerZone Zone
        {
            get
            {
                userSettings = ReadUserSettings();
                if (userSettings[(int)Settings.zone].Source == 1)
                {
                    return (GamerZone)BitConverter.ToUInt32(userSettings[(int)Settings.zone].Value, 0);
                }
                else
                {
                    return GamerZone.None; //typical for xbox1 accounts
                }
            }
            set
            {
                WriteProfileSettings(null, null, null, null, null, null, null, value, null);
            }
        }
        #endregion

        #region WriteProfileSettings()
        /// <summary>
        /// Syncs all writable profile settings to the server
        /// </summary>
        /// <param name="motto">new motto string, or null if don't want to change it</param>
        /// <param name="name">new name string, or null if don't want to change it</param>
        /// <param name="location">new location string, or null if don't want to change it</param>
        /// <param name="bio">new bio string, or null if don't want to change it</param>
        /// <param name="gamerpic">new gamerpic string (use the gamerpic array), or null</param>
        /// <param name="personalpic">new personal pic string (use the gamerpic array), or null</param>
        /// <param name="avatar">new avatar type (select from MaleAvatar or FemaleAvatar)</param>
        /// <param name="zone">new zone, or null if don't want to change it</param>
        /// <param name="region">new region, or null if don't want to change it</param>
        public void WriteProfileSettings(string motto, string name, string location, string bio, string gamerPicture, string personalPicture, byte[] avatar, GamerZone? zone, CountryId? region)
        {
            METHOD.ENTER();
            List<UserSetting> settings = new List<UserSetting>();

            //determine which settings we need to send up to the server
            if (avatar != null)
            {
                settings.Add(new UserSetting(_user.Puid, XOn.XSOURCE_DEFAULT, ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_1, avatar));
            }
            if (motto != null)
            {
                if (motto.Length > MaxMotto)
                {
                    throw new ArgumentOutOfRangeException("Motto is too long, max characters allowed = " + MaxMotto);
                }
                byte[] mottoValue = System.Text.UnicodeEncoding.Unicode.GetBytes(motto + "\0");
                settings.Add(new UserSetting(_user.Puid, XOn.XSOURCE_DEFAULT, ProfileDefs.XPROFILE_GAMERCARD_MOTTO, mottoValue));
            }
            if (name != null)
            {
                if (name.Length > MaxName)
                {
                    throw new ArgumentOutOfRangeException("Name is too long, max characters allowed = " + MaxName);
                }
                byte[] nameValue = System.Text.UnicodeEncoding.Unicode.GetBytes(name + "\0");
                settings.Add(new UserSetting(_user.Puid, XOn.XSOURCE_DEFAULT, ProfileDefs.XPROFILE_GAMERCARD_USER_NAME, nameValue));
            }
            if (location != null)
            {
                if (location.Length > MaxLocation)
                {
                    throw new ArgumentOutOfRangeException("Location is too long, max characters allowed = " + MaxLocation);
                }
                byte[] locValue = System.Text.UnicodeEncoding.Unicode.GetBytes(location + "\0");
                settings.Add(new UserSetting(_user.Puid, XOn.XSOURCE_DEFAULT, ProfileDefs.XPROFILE_GAMERCARD_USER_LOCATION, locValue));
            }
            if (bio != null)
            {
                if (bio.Length > MaxBio)
                {
                    throw new ArgumentOutOfRangeException("Bio is too long, max characters allowed = " + MaxBio);
                }
                byte[] bioValue = System.Text.UnicodeEncoding.Unicode.GetBytes(bio + "\0");
                settings.Add(new UserSetting(_user.Puid, XOn.XSOURCE_DEFAULT, ProfileDefs.XPROFILE_GAMERCARD_USER_BIO, bioValue));
            }
            if (gamerPicture != null)
            {
                byte[] gamerpicValue = System.Text.UnicodeEncoding.Unicode.GetBytes(gamerPicture);
                settings.Add(new UserSetting(_user.Puid, XOn.XSOURCE_DEFAULT, ProfileDefs.XPROFILE_GAMERCARD_PICTURE_KEY, gamerpicValue));
            }
            if (personalPicture != null)
            {
                byte[] personalpicValue = System.Text.UnicodeEncoding.Unicode.GetBytes(personalPicture);
                settings.Add(new UserSetting(_user.Puid, XOn.XSOURCE_DEFAULT, ProfileDefs.XPROFILE_GAMERCARD_PERSONAL_PICTURE, personalpicValue));
            }
            if (zone.HasValue)
            {
                byte[] zoneValue = BitConverter.GetBytes((uint)zone.Value);
                settings.Add(new UserSetting(_user.Puid, XOn.XSOURCE_DEFAULT, ProfileDefs.XPROFILE_GAMERCARD_ZONE, zoneValue));
            }
            if (region.HasValue)
            {
                uint dwRegion = Convert.ToUInt32(region.Value); //xlive expects this value to be a DWORD, so convert to equivalent unsigned int32 first
                byte[] regionValue = BitConverter.GetBytes(dwRegion);
                settings.Add(new UserSetting(_user.Puid, XOn.XSOURCE_DEFAULT, ProfileDefs.XPROFILE_GAMERCARD_REGION, regionValue));
            }

            //sync all valid settings
            if (settings.Count > 0)
            {
                UserSetting[] profileSettings = new live.protocol.UserSetting[settings.Count];
                settings.CopyTo(profileSettings);
                using (Xbox360 xbox = new Xbox360())
                {
                    xbox.Live.Logon(_user);
                    UserSettings.SyncSettings(xbox.Client, _user, xbox.Client.TitleId, profileSettings, DateTime.UtcNow);
                    xbox.Live.Logout(_user);
                    xbox.ShutdownConsole();
                }
            }
            METHOD.EXIT();
        }
        #endregion

        #region Private Helper Functions
        /// <summary>
        /// Retrieves the user's gamer profile settings from the backend, all values are in bytes
        /// </summary>
        /// <returns>An array of user settings that are supported by Games for Windows - LIVE</returns>
        private UserSetting[] ReadUserSettings()
        {
            METHOD.ENTER();
            UserSetting[] gamercardData;
            using (Xbox360 xbox = new Xbox360())
            {
                xbox.Live.Logon(_user);
                uint[] settings = new uint[NumSettings];
                settings[(int)Settings.score] = ProfileDefs.XPROFILE_GAMERCARD_CRED;
                settings[(int)Settings.motto] = ProfileDefs.XPROFILE_GAMERCARD_MOTTO;
                settings[(int)Settings.personalPic] = ProfileDefs.XPROFILE_GAMERCARD_PERSONAL_PICTURE;
                settings[(int)Settings.gamerPic] = ProfileDefs.XPROFILE_GAMERCARD_PICTURE_KEY;
                settings[(int)Settings.region] = ProfileDefs.XPROFILE_GAMERCARD_REGION;
                settings[(int)Settings.rep] = ProfileDefs.XPROFILE_GAMERCARD_REP;
                settings[(int)Settings.bio] = ProfileDefs.XPROFILE_GAMERCARD_USER_BIO;
                settings[(int)Settings.location] = ProfileDefs.XPROFILE_GAMERCARD_USER_LOCATION;
                settings[(int)Settings.name] = ProfileDefs.XPROFILE_GAMERCARD_USER_NAME;
                settings[(int)Settings.zone] = ProfileDefs.XPROFILE_GAMERCARD_ZONE;
                settings[(int)Settings.achievementsEarned] = ProfileDefs.XPROFILE_GAMERCARD_ACHIEVEMENTS_EARNED;
                settings[(int)Settings.titlesPlayed] = ProfileDefs.XPROFILE_GAMERCARD_TITLES_PLAYED;
                settings[(int)Settings.avatar] = ProfileDefs.XPROFILE_GAMERCARD_AVATAR_INFO_1;

                ReadSettingsResponse resp = live.server.UserSettings.ReadSettings(xbox.Client, _user, xbox.Client.TitleId, new ulong[] { _user.Puid }, settings);
                gamercardData = resp.Settings;

                xbox.Live.Logout(_user);
                xbox.ShutdownConsole();
            }
            METHOD.EXIT();
            return gamercardData;
        }

        /// <summary>
        /// Converts a raw reputation value to the equivalent number of stars
        /// </summary>
        /// <param name="rep">Raw reputation value from backend</param>
        /// <returns>Number of stars needed to represent the player's rep</returns>
        internal static double ConvertRepToStars(double rep)
        {
            double starValue;
            // the following values came from a table in xlive\ui\friends\playerscene.cpp
            if (rep >= 96) { starValue = 5; }
            else if (rep >= 91) { starValue = 4.75; }
            else if (rep >= 86) { starValue = 4.5; }
            else if (rep >= 81) { starValue = 4.25; }
            else if (rep >= 76) { starValue = 4; }
            else if (rep >= 71) { starValue = 3.75; }
            else if (rep >= 66) { starValue = 3.5; }
            else if (rep >= 61) { starValue = 3.25; }
            else if (rep >= 56) { starValue = 3; }
            else if (rep >= 51) { starValue = 2.75; }
            else if (rep >= 46) { starValue = 2.5; }
            else if (rep >= 41) { starValue = 2.25; }
            else if (rep >= 36) { starValue = 2; }
            else if (rep >= 31) { starValue = 1.75; }
            else if (rep >= 26) { starValue = 1.5; }
            else if (rep >= 21) { starValue = 1.25; }
            else if (rep >= 16) { starValue = 1; }
            else if (rep >= 11) { starValue = 0.75; }
            else if (rep >= 6) { starValue = 0.5; }
            else if (rep >= 1) { starValue = 0.25; }
            else { starValue = 0; }

            return starValue;
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\UserLib\WLID.cs ===
﻿using System;
using live.common;
using Microsoft.WindowsLive.Test.WinLiveUser;
using Microsoft.WindowsLive.Test.WinLiveUser.WinLiveId;
using Microsoft.WindowsLive.Test.WinLiveUser.WinLiveIdInterface;

namespace LiveN.Test.Users
{
    /// <summary>
    /// This class should contain functions for manipulating a user's WLID properties (via the WinLiveIdInterface)
    /// </summary>
    public class WLID
    {
        /// <summary>
        /// Link two XblUser accounts
        /// </summary>
        /// <param name="user1">The Xbluser you want to link to</param>
        /// <param name="user2">The Xbluser you want to be linked to the first user fed in</param>
        public static void LinkAccounts(XblUser user1, XblUser user2)
        {
            METHOD.ENTER();
            WinLiveIdInterface wi = new WinLiveIdInterface(Clusters.INT);

            //Get the user account
            WinLiveUser wlidUser1 = wi.GetExistingUserByMemberName(user1.Settings.UserPassportInfo.MemberName);
            wlidUser1.Password = user1.Settings.UserPassportInfo.Password;
            wlidUser1.UserName = user1.Settings.UserPassportInfo.MemberName;
            wi.UpdateUser(wlidUser1);

            WinLiveUser wlidUser2 = wi.GetExistingUserByMemberName(user2.Settings.UserPassportInfo.MemberName);
            wlidUser2.Password = user2.Settings.UserPassportInfo.Password;
            wlidUser2.UserName = user2.Settings.UserPassportInfo.MemberName;
            wi.UpdateUser(wlidUser2);

            wi.LinkUsers(wlidUser1, wlidUser2);
            METHOD.EXIT();
        }

        /// <summary>
        /// Set whether or not a child account subject to COPPA (in the US or Korea and less than 13 years of age) is allowed to access internet sources.
        /// Note: If the child is not granted access, their account will not be able to sign into the LCW.
        /// </summary>
        /// <param name="childAccount">The account to grant or deny access to.</param>
        /// <param name="grantConsent">Set to true if the child can access the internet source, false otherwise</param>
        public static void SetParentalConsent(XblUser childAccount, bool grantConsent)
        {
            METHOD.ENTER();
            int age = DateTime.Now.Year - childAccount.Settings.PersonalInfo.BirthDate.Year;
            if (age > 13 && !(childAccount.Settings.PersonalInfo.CountryId == CountryId.US || childAccount.Settings.PersonalInfo.CountryId == CountryId.KR))
            {
                throw new InvalidOperationException("Only US and Korean accounts <=13 years of age require parental consent");
            }

            WinLiveIdInterface wi = new WinLiveIdInterface(Clusters.INT);

            // retrieve the WLID child account
            WinLiveUser child = wi.GetExistingUserByMemberName(childAccount.Settings.UserPassportInfo.MemberName);
            child.Password = childAccount.Settings.UserPassportInfo.Password;
            child.UserName = childAccount.Settings.UserPassportInfo.MemberName;
            wi.UpdateUser(child);

            //retrieve the WLID parent account
            WinLiveUser parent = wi.GetExistingUserByMemberName(childAccount.Settings.OwnerPassportInfo.MemberName);
            parent.Password = childAccount.Settings.OwnerPassportInfo.Password;
            parent.UserName = childAccount.Settings.OwnerPassportInfo.MemberName;
            wi.UpdateUser(parent);

            //update parental consent on WLID for the child account
            if (childAccount.Settings.PersonalInfo.CountryId == CountryId.KR)
            {
                wi.CreateConsentRelationship(parent, child, ConsentStatus.Korean, grantConsent);
            }
            else if (childAccount.Settings.PersonalInfo.CountryId == CountryId.US)
            {
                wi.CreateConsentRelationship(parent, child, ConsentStatus.COPPA, grantConsent);
            }
            METHOD.EXIT();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\UserLib\EnvironmentSetting.cs ===
﻿using System;
using System.IO;
using System.Linq;
using System.Xml;
using System.Xml.Linq;
using live.common;
using LiveN.Test.Users.Stf;

namespace LiveN.Test.Users
{
    public sealed class Environments
    {
        private Environments() { }

        /// <summary>
        /// Gets the current LiveLib and Xonline environment values and returns them as a string
        /// Sets the current LiveLib environment
        /// </summary>
        public static string CurrentEnvironment
        {
            get
            {
                return GetEnvironment("LiveLib.xml");
            }
            set
            {
                //This only sets the LiveLib environment, use "xonline" if you want to match environments
                SetEnvironment(value);
            }
        }

        /// <summary>
        /// Gets the current environment node from the LiveLib.xml file
        /// </summary>
        /// <param name="livelibPath">The path to LiveLib.xml (normally set to just LiveLib.xml)</param>
        /// <returns>A string containing the current environment variable from LiveLib.xml</returns>
        private static string GetEnvironment(string livelibPath)
        {
            METHOD.ENTER();

            XmlTextReader reader = new XmlTextReader(livelibPath);
            XElement root = XElement.Load(reader);

            string envName = root.Element("config").Element("currentEnvironment").Attribute("name").Value;

            METHOD.EXIT();
            return envName;
        }

        #region ****** SetEnvironment() *******************************************
        /// <summary>
        /// Sets the backend environment by altering LiveLib.xml
        /// </summary>
        /// <param name="newEnv">The environment to target ('test' for TestNet, 'stress' for StressNet)</param>
        public static void SetEnvironment(string environmentName)
        {
            if (String.IsNullOrEmpty(environmentName))
            {
                throw new ArgumentNullException("environmentName");
            }

            METHOD.ENTER();

            // Set LiveLib environment
            String targetEnv = environmentName.ToLower();

            if (targetEnv.Equals("xonline"))
            {
                MatchXOnlineEnvironment();
            }
            else if (targetEnv.Equals("test") || targetEnv.Equals("stress") || targetEnv.Equals("stress2"))
            {
                SetCommonTestEnvironment(targetEnv);
            }
            else
            {
                if (FindEnvironmentNode(targetEnv))
                {
                    AlterCurrentEnvironmentNode(targetEnv, "kdc.test.xboxlive.com");
                }
                else
                {
                    throw new InvalidOperationException("Environment not supported or information is missing from LiveLib.xml");
                }
            }

            METHOD.EXIT();
        }

        public static void SetStfEnvironment(string environmentName)
        {
            if (!string.IsNullOrEmpty(environmentName))
            {
                StfProxy.Initialize(environmentName);
            }
            else
            {
                throw new ArgumentNullException(environmentName);
            }

        }
        #endregion

        #region ****** SetCommonTestEnvironment() ****************************************
        /// <summary>
        /// Changes the environment to one of the common test backends
        /// </summary>
        /// <param name="environmentName">common test environment</param>
        private static void SetCommonTestEnvironment(string environmentName)
        {
            METHOD.ENTER();
            String targetEnv = String.Empty;
            String targetSite = String.Empty;
            switch (environmentName)
            {
                case ("test"):
                    targetEnv = "testnetrr-tg2";
                    targetSite = "kdc.test.xboxlive.com";
                    break;
                case ("stress"):
                    targetEnv = "stressnet1rr-int";
                    targetSite = "kdc.test.xboxlive.com";
                    break;
                case ("stress2"):
                    targetEnv = "stressnet2rr-int";
                    targetSite = "kdc.test.xboxlive.com";
                    break;
            }
            AlterCurrentEnvironmentNode(targetEnv, targetSite);
            METHOD.EXIT();
        }
        #endregion

        #region ****** AlterCurrentEnvironmentNode() ***************************************
        /// <summary>
        /// Changes the 'currentEnvironment' node in LiveLib.xml to target the new backend
        /// </summary>
        /// <param name="newEnvironment">Backend to target</param>
        /// <param name="newSite">Passport site associated with new backend</param>
        private static void AlterCurrentEnvironmentNode(string newEnvironment, string newSite)
        {
            METHOD.ENTER();
            string filename = "LiveLib.xml";
            XmlDocument doc = new XmlDocument();
            doc.Load(filename);

            // get the <currentEnvironment> node and 'name' attribute
            XmlNodeList envNodes = doc.GetElementsByTagName("currentEnvironment");
            XmlAttributeCollection envAtt = envNodes[0].Attributes;
            XmlAttribute envName = envAtt[0]; // 'name' is the first attribute in the 'currentEnvironment' node
            string currEnv = envName.InnerText;

            // get the <passport> node and 'site' attribute
            XmlNodeList ppNodes = doc.GetElementsByTagName("passport");
            XmlAttributeCollection ppAtt = ppNodes[0].Attributes; // there are 3 attributes under passport
            XmlAttribute site = ppAtt[0];// 'site' is the first attribute in the 'passport' node

            if (!currEnv.Equals(newEnvironment))
            {
                envName.InnerText = newEnvironment; // set value for 'name' attribute
                site.InnerText = newSite; // set value for 'site' attribute
                doc.Save(filename);
            }
            METHOD.ENTER();
        }
        #endregion

        #region ****** FindEnvironmentNode()****************************************************
        /// <summary>
        /// Locates the information node in LiveLib.xml that corresponds to the target environment
        /// </summary>
        /// <param name="targetEnvironment">The target environment to locate</param>
        /// <returns>True if the node was found, false otherwise</returns>
        private static bool FindEnvironmentNode(string targetEnvironment)
        {
            METHOD.ENTER();
            string liveLibEnvironment;
            bool isTargetPresent = false;

            XDocument xmlDoc = XDocument.Load("LiveLib.xml");

            var environmentElements = xmlDoc.Root.Elements("environments").Elements("environment");
            try
            {
                liveLibEnvironment = (string)environmentElements
                    .Where(u => u.Attribute("name").Value.Contains(targetEnvironment))
                    .Single().Attribute("name");
            }
            catch (Exception exc)
            {
                throw new Exception("Could not find Environment Name '" + targetEnvironment + "' within LiveLib.xml. Make sure this environment has been added. \r\nException:\r\n" + exc.ToString());
            }

            isTargetPresent = String.Equals(liveLibEnvironment, targetEnvironment);

            METHOD.EXIT();
            return isTargetPresent;
        }
        #endregion

        #region ****** MatchXOnlineEnvironment() ****************************************
        /// <summary>
        /// Reads the xonline.ini file to determine what backend to target and then adjusts LiveLib.xml accordingly
        /// </summary>
        private static void MatchXOnlineEnvironment()
        {
            METHOD.ENTER();
            StreamReader sr = new StreamReader(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + "\\Microsoft\\XLive\\xonline.ini");
            String networkId = String.Empty;
            String ipAddress = String.Empty;
            String cluster = String.Empty;
            String xppTarget = String.Empty;

            while (!sr.EndOfStream)
            {
                String currentString = sr.ReadLine();
                if (currentString.ToUpper().Contains("NETWORKID"))
                {
                    networkId = currentString.Remove(0, 10);
                }
                else if (currentString.ToUpper().Contains("MKDC"))
                {
                    ipAddress = currentString.Remove(0, 5);
                }
                else if (currentString.ToUpper().Contains("CLUSTER"))
                {
                    cluster = currentString.Remove(0, 8);
                }
                else if (currentString.ToUpper().Contains("XPPTARGET"))
                {
                    xppTarget = currentString.Remove(0, 10);
                }
            }
            sr.Close();
            if (String.IsNullOrEmpty(cluster)) // cluster isn't available in all xonline files
            {
                cluster = networkId;
            }
            // this could be a common test environment
            if (String.IsNullOrEmpty(ipAddress))
            {
                if (networkId.ToLower().Contains("test") || cluster.ToLower().Contains("test"))
                {
                    SetCommonTestEnvironment("test");
                }
                else if (networkId.ToLower().Contains("str") || cluster.ToLower().Contains("stress"))
                {
                    if (networkId.ToLower().Contains("strt") || cluster.ToLower().Contains("stresstwo"))
                    {
                        SetCommonTestEnvironment("stress2");
                    }
                    else
                    {
                        SetCommonTestEnvironment("stress");
                    }
                }
            }
            // or it might be an xblob
            else if (networkId.ToLower().Contains("blob") || cluster.ToLower().Contains("blob"))
            {
                String newEnvironment = String.Empty;
                String newSite = String.Empty;

                if (!networkId.ToLower().Equals("blob"))
                {
                    newEnvironment = networkId;
                }
                else
                {
                    newEnvironment = cluster;
                }

                if (!String.IsNullOrEmpty(xppTarget))
                {
                    newSite = xppTarget;
                }
                else
                {
                    newSite = "kdc.test.xboxlive.com";
                }

                if (FindEnvironmentNode(newEnvironment))
                {
                    AlterCurrentEnvironmentNode(newEnvironment, newSite);
                }
                else
                {
                    throw new InvalidOperationException("An environment entry for this backend does not exist in LiveLib.xml, add the entry and try again");
                }
            }
            else
            {
                if (cluster.ToLower().Equals("xetestnet") || networkId.ToLower().Equals("test"))
                {
                    SetCommonTestEnvironment("test");
                }
                else if (cluster.ToLower().Equals("stressnet") || networkId.ToLower().Contains("str"))
                {
                    if (cluster.ToLower().Equals("stresstwo") || networkId.ToLower().Contains("strt"))
                    {
                        SetCommonTestEnvironment("stress2");
                    }
                    else
                    {
                        SetCommonTestEnvironment("stress");
                    }
                }
                // if it wasn't one of the common guys, see if it's already in LiveLib.xml 
                else if (FindEnvironmentNode(networkId))
                {
                    AlterCurrentEnvironmentNode(networkId, xppTarget);
                }
                else if (FindEnvironmentNode(cluster))
                {
                    AlterCurrentEnvironmentNode(networkId, xppTarget);
                }
                else
                {
                    throw new InvalidOperationException("Environment specified by xonline.ini is not supported or the information is missing from LiveLib.xml");
                }
            }
            METHOD.EXIT();
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\UserLib\Products.cs ===
﻿using System;
using System.Globalization;
using live.common;
using live.lfm;
using live.protocol;

namespace LiveN.Test.Users
{
    public struct Title
    {
        private uint titleId;
        private uint[] achievementIds;
        bool pcTitle;

        public Title(uint titleId, uint[] achievementIds, bool pcTitle)
        {
            this.titleId = titleId;
            this.achievementIds = achievementIds;
            this.pcTitle = pcTitle;
        }

        #region Property Accessors
        public uint TitleId
        {
            get
            {
                return this.titleId;
            }
        }

        public uint[] AchievementIds()
        {
            return this.achievementIds;
        }

        public bool PCTitle()
        {
            return this.pcTitle;
        }
        #endregion
    }

    public enum PlayerSkill
    {
        None, // no achievements awarded
        Novice, // up to 2 achievements earned per game
        Casual, // up to 5 achievements earned per game
        Hardcore // all achievements earned per game
    }

    public sealed class Products
    {
        #region Create titles known to exist from deployments
        public static readonly int MaxGames = 14; // titles that are regularly propped to TestNet
        private const int MaxSync = 30; // maximum number of achievements that can be synced to the server at one time

        private static readonly Title panShellApp = new Title((uint)0x585207D3, new uint[] { 1, 2, 3, 4, 5, 6, 7 }, true);
        private static readonly Title horseRancher = new Title((uint)0x585207EF, new uint[] { 1, 2, 3, 4, 5 }, true);
        private static readonly Title hexic = new Title((uint)0x584107D1, new uint[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 }, false);
        private static readonly Title geoWars = new Title((uint)0x584107ed, new uint[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 }, false);
        private static readonly Title uno = new Title((uint)0x584107F3, new uint[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 }, false);
        private static readonly Title achievements = new Title((uint)0xFFFF0079, new uint[] { 100, 101, 102, 200, 201, 202 }, false);
        private static readonly Title achievementFVT2 = new Title((uint)0xFFFF0086, new uint[] { 1, 2, 3, 4, 6, 7, 8, 9 }, false);
        private static readonly Title profileFVT = new Title((uint)0xFFFF0087, new uint[] { 1, 2, 3, 4, 5 }, false);
        private static readonly Title xe1 = new Title((uint)0xFFFFAB34, new uint[] { 7, 8, 9, 10, 11 }, false);
        private static readonly Title xeu1 = new Title((uint)0xFFFFAB33, new uint[] { 6, 7, 8, 9, 10 }, false);
        private static readonly Title xe50 = new Title((uint)0xFFFFAB30, new uint[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50 }, false);
        private static readonly Title www = new Title((uint)0xFFFFAB99, new uint[] { 1, 2, 3, 4, 5 }, false);
        private static readonly Title liveBVT = new Title((uint)0xFFFF0072, new uint[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17 }, false);
        private static readonly Title xeu1Loc = new Title((uint)0xFFFFAB97, new uint[] { 1, 2, 3, 4, 5 }, false);

        private static readonly Title[] titles = new Title[] {panShellApp, horseRancher, hexic, geoWars, uno, achievements, achievementFVT2,
        profileFVT, xe1, xe50, xeu1, xeu1Loc, www, liveBVT };
        #endregion

        private Products() { }

        internal static void CreateGameHistory(XblUser user, int numGames, PlayerSkill skill)
        {
            METHOD.ENTER();
            if (numGames > titles.Length)
            {
                throw new ArgumentOutOfRangeException(String.Format(CultureInfo.CurrentCulture, "numGames is too large, only {0} titles are available. Use MaxGames to get the limit.", MaxGames.ToString(CultureInfo.CurrentCulture)));
            }
            using (Xbox360 xbox = new Xbox360())
            {
                xbox.Live.Logon(user);
                SyncTitles(user, xbox, numGames);
                if (skill != PlayerSkill.None)
                {
                    for (int i = 0; i < numGames; i++)
                    {
                        int numAchievements = titles[i].AchievementIds().Length;
                        switch (skill)
                        {
                            case PlayerSkill.Novice:
                                numAchievements = 2;
                                break;
                            case PlayerSkill.Casual:
                                numAchievements = 5;
                                break;
                        }
                        if (titles[i].PCTitle() == false)
                        {
                            xbox.Live.Play(titles[i].TitleId);
                            AwardAchievements(user, xbox.Client, titles[i].AchievementIds(), numAchievements);
                        }
                    }
                }
                xbox.Live.Logout(user);
                xbox.ShutdownConsole();
            }

            METHOD.EXIT();
        }

        private static void SyncTitles(XblUser user, Xbox360 xbox, int numGames)
        {
            METHOD.ENTER();
            UserTitle[] userTitles = new UserTitle[numGames];
            for (int i = 0; i < numGames; i++)
            {
                UserTitle title = new UserTitle(titles[i].TitleId, DateTime.UtcNow, 0, 0, 0);
                userTitles[i] = title;
            }
            SyncTitlesResponse resp = live.server.UserSettings.SyncTitles(xbox.Client, user, DateTime.UtcNow, userTitles);
            METHOD.EXIT();
        }

        internal static void SyncTitles(XblUser user, uint[] titleIDs)
        {
            METHOD.ENTER();
            using (Xbox360 xbox = new Xbox360())
            {
                xbox.Live.Logon(user);
                int numGames = titleIDs.Length;
                UserTitle[] userTitles = new UserTitle[numGames];
                for (int i = 0; i < numGames; i++)
                {
                    UserTitle title = new UserTitle(titleIDs[i], DateTime.UtcNow, 0, 0, 0);
                    userTitles[i] = title;
                }
                SyncTitlesResponse resp = live.server.UserSettings.SyncTitles(xbox.Client, user, DateTime.UtcNow, userTitles);
                xbox.Live.Logout(user);
                xbox.ShutdownConsole();
            }
            METHOD.EXIT();
        }

        private static void AwardAchievements(XblUser user, IClient client, uint[] achievementIds, int numAchievements)
        {
            METHOD.ENTER();
            int maxAchievements = achievementIds.Length;
            if (numAchievements > maxAchievements)
            {
                throw new ArgumentOutOfRangeException(String.Format(CultureInfo.CurrentCulture, "Can only award {0} achievements unless more Ids are provided", maxAchievements.ToString(CultureInfo.CurrentCulture)));
            }
            if (numAchievements < MaxSync) // can only sync 30 achievements at a time
            {
                live.protocol.Achievement[] achievements = new live.protocol.Achievement[numAchievements];
                for (int i = 0; i < numAchievements; i++)
                {
                    achievements[i] = new live.protocol.Achievement(achievementIds[i], DateTime.UtcNow, (int)XOn.XACHIEVEMENT_DETAILS_ACHIEVED);
                }

                live.protocol.SyncAchievementsResponse response = live.server.Achievements.SyncAchievements(client, user, client.TitleId, achievements);
            }
            else if (numAchievements > MaxSync)
            {
                int remaining = numAchievements - MaxSync;
                live.protocol.Achievement[] achievements1 = new live.protocol.Achievement[MaxSync];
                live.protocol.Achievement[] achievements2 = new live.protocol.Achievement[remaining];
                for (int i = 0; i < MaxSync; i++) // sync first 30 achievements
                {
                    achievements1[i] = new live.protocol.Achievement(achievementIds[i], DateTime.UtcNow, (int)XOn.XACHIEVEMENT_DETAILS_ACHIEVED);
                }
                for (int i = 0; i < remaining; i++) // sync up to 30 more achievements (games shouldn't have more than 50)
                {
                    achievements2[i] = new live.protocol.Achievement(achievementIds[MaxSync + i], DateTime.UtcNow, (int)XOn.XACHIEVEMENT_DETAILS_ACHIEVED);
                }

                live.protocol.SyncAchievementsResponse response = live.server.Achievements.SyncAchievements(client, user, client.TitleId, achievements1);
                response = live.server.Achievements.SyncAchievements(client, user, client.TitleId, achievements2);
            }
            METHOD.EXIT();
        }

        internal static void AwardAchievements(XblUser user, Title title)
        {
            METHOD.ENTER();
            using (Xbox360 xbox = new Xbox360())
            {
                xbox.Live.Logon(user, title.TitleId);
                int numAchievements = title.AchievementIds().Length;
                if (numAchievements == 0)
                {
                    throw new ArgumentException("There are no achievements for the title. Only call this function when you have achievements to earn.");
                }
                AwardAchievements(user, xbox.Client, title.AchievementIds(), numAchievements);
                xbox.Live.Logout(user);
                xbox.ShutdownConsole();
            }
            METHOD.EXIT();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\UserLib\Privacy.cs ===
﻿using System;
using live.common;
using live.lfm;
using live.protocol;

namespace LiveN.Test.Users
{
    public enum PrivacyOption
    {
        Everyone,
        FriendsOnly,
        Blocked
    }

    public enum FamilyOption
    {
        Allow,
        Restrict
    }

    public struct PrivacySettings
    {
        private PrivacyOption voiceAndText, gamerProfile, playedGames, memberContent, friendsList, video, onlineStatus;

        public PrivacySettings(PrivacyOption voiceAndText, PrivacyOption gamerProfile, PrivacyOption playedGames,
            PrivacyOption memberContent, PrivacyOption friendsList, PrivacyOption video, PrivacyOption onlineStatus)
        {
            this.voiceAndText = voiceAndText;
            this.gamerProfile = gamerProfile; // other players can view motto, bio, personal pic, locale
            this.playedGames = playedGames; // other players can view game and achievement history
            this.memberContent = memberContent;
            this.friendsList = friendsList;
            this.video = video;
            this.onlineStatus = onlineStatus;
        }

        #region Property Accessors
        public PrivacyOption VoiceAndText
        {
            get
            {
                return this.voiceAndText;
            }
        }

        public PrivacyOption GamerProfile
        {
            get
            {
                return this.gamerProfile;
            }
        }

        public PrivacyOption PlayedGames
        {
            get
            {
                return this.playedGames;
            }
        }

        public PrivacyOption MemberContent
        {
            get
            {
                return this.memberContent;
            }
        }

        public PrivacyOption FriendsList
        {
            get
            {
                return this.friendsList;
            }
        }

        public PrivacyOption Video
        {
            get
            {
                return this.video;
            }
        }

        public PrivacyOption OnlineStatus
        {
            get
            {
                return this.onlineStatus;
            }
        }
        #endregion
    }

    public struct FamilySettings
    {
        private PrivacyOption voiceAndText, profileViewing, profileSharing, memberContent, friendsList, video, onlineStatus;
        private FamilyOption onlineGamePlay, xbox1Games, onlineFriends, downloadContent;

        public FamilySettings(PrivacyOption voiceAndText, PrivacyOption profileViewing, PrivacyOption profileSharing,
            PrivacyOption memberContent, PrivacyOption friendsList, PrivacyOption video, PrivacyOption onlineStatus,
            FamilyOption onlineGamePlay, FamilyOption xbox1Games, FamilyOption onlineFriends, FamilyOption downloadContent)
        {
            this.voiceAndText = voiceAndText;
            this.profileViewing = profileViewing; // child can view other profiles
            this.profileSharing = profileSharing; // other people can view child's profile (motto, bio, game history)
            this.memberContent = memberContent;
            this.friendsList = friendsList;
            this.video = video;
            this.onlineStatus = onlineStatus;
            this.onlineGamePlay = onlineGamePlay;
            this.xbox1Games = xbox1Games;
            this.onlineFriends = onlineFriends;
            this.downloadContent = downloadContent;
        }

        #region Property Accessors
        public PrivacyOption VoiceAndText
        {
            get
            {
                return this.voiceAndText;
            }
        }

        public PrivacyOption ProfileViewing
        {
            get
            {
                return this.profileViewing;
            }
        }

        public PrivacyOption ProfileSharing
        {
            get
            {
                return this.profileSharing;
            }
        }

        public PrivacyOption MemberContent
        {
            get
            {
                return this.memberContent;
            }
        }

        public PrivacyOption FriendsList
        {
            get
            {
                return this.friendsList;
            }
        }

        public PrivacyOption Video
        {
            get
            {
                return this.video;
            }
        }

        public PrivacyOption OnlineStatus
        {
            get
            {
                return this.onlineStatus;
            }
        }

        public FamilyOption OnlineGamePlay
        {
            get
            {
                return this.onlineGamePlay;
            }
        }

        public FamilyOption Xbox1Games
        {
            get
            {
                return this.xbox1Games;
            }
        }

        public FamilyOption OnlineFriends
        {
            get
            {
                return this.onlineFriends;
            }
        }

        public FamilyOption DownloadContent
        {
            get
            {
                return this.downloadContent;
            }
        }
        #endregion
    }

    public sealed class Privacy
    {
        private Privacy() { }
        
        private static void SetPrivacyPrivilege(ref Privileges grantPrivileges, ref Privileges restrictPrivileges, Privilege everyonePrivilege, Privilege friendPrivilege, PrivacyOption privSetting)
        {
            METHOD.ENTER();
            if (privSetting == PrivacyOption.Everyone)
            {
                grantPrivileges.Set(everyonePrivilege, true);
                grantPrivileges.Set(friendPrivilege, false);

                restrictPrivileges.Set(everyonePrivilege, false);
                restrictPrivileges.Set(friendPrivilege, true);
            }
            else if (privSetting == PrivacyOption.FriendsOnly)
            {
                grantPrivileges.Set(everyonePrivilege, false);
                grantPrivileges.Set(friendPrivilege, true);

                restrictPrivileges.Set(everyonePrivilege, true);
                restrictPrivileges.Set(friendPrivilege, false);
            }
            else
            {
                grantPrivileges.Set(everyonePrivilege, false);
                grantPrivileges.Set(friendPrivilege, false);

                restrictPrivileges.Set(everyonePrivilege, true);
                restrictPrivileges.Set(friendPrivilege, true);
            }
            METHOD.EXIT();
        }

        private static void PrepareNewPrivacyPrivileges(ref Privileges grantPrivileges, ref Privileges restrictPrivileges, PrivacySettings newSettings)
        {
            METHOD.ENTER();
            SetPrivacyPrivilege(ref grantPrivileges, ref restrictPrivileges, Privilege.Communications, Privilege.CommunicationsFriendsOnly, newSettings.VoiceAndText);
            SetPrivacyPrivilege(ref grantPrivileges, ref restrictPrivileges, Privilege.UserCreatedContent, Privilege.UserCreatedContentFriendsOnly, newSettings.MemberContent);
            SetPrivacyPrivilege(ref grantPrivileges, ref restrictPrivileges, Privilege.ShareFriendsList, Privilege.ShareFriendsListFriendsOnly, newSettings.FriendsList);
            SetPrivacyPrivilege(ref grantPrivileges, ref restrictPrivileges, Privilege.VideoCommunications, Privilege.VideoCommunicationsFriendsOnly, newSettings.Video);
            SetPrivacyPrivilege(ref grantPrivileges, ref restrictPrivileges, Privilege.Presence, Privilege.PresenceFriendsOnly, newSettings.OnlineStatus);
            METHOD.EXIT();
        }

        private static void SetFamilyPrivilege(ref Privileges grantPrivileges, ref Privileges restrictPrivileges, Privilege privilege, FamilyOption famSetting)
        {
            METHOD.ENTER();
            if (famSetting == FamilyOption.Allow)
            {
                grantPrivileges.Set(privilege, true);
                restrictPrivileges.Set(privilege, false);
            }
            else
            {
                grantPrivileges.Set(privilege, false);
                restrictPrivileges.Set(privilege, true);
            }
            METHOD.EXIT();
        }

        private static void PrepareNewFamilyPrivileges(ref Privileges grantPrivileges, ref Privileges restrictPrivileges, FamilySettings famSettings)
        {
            METHOD.ENTER();
            SetPrivacyPrivilege(ref grantPrivileges, ref restrictPrivileges, Privilege.Communications, Privilege.CommunicationsFriendsOnly, famSettings.VoiceAndText);
            SetPrivacyPrivilege(ref grantPrivileges, ref restrictPrivileges, Privilege.UserCreatedContent, Privilege.UserCreatedContentFriendsOnly, famSettings.MemberContent);
            SetPrivacyPrivilege(ref grantPrivileges, ref restrictPrivileges, Privilege.ShareFriendsList, Privilege.ShareFriendsListFriendsOnly, famSettings.FriendsList);
            SetPrivacyPrivilege(ref grantPrivileges, ref restrictPrivileges, Privilege.VideoCommunications, Privilege.VideoCommunicationsFriendsOnly, famSettings.Video);
            SetPrivacyPrivilege(ref grantPrivileges, ref restrictPrivileges, Privilege.Presence, Privilege.PresenceFriendsOnly, famSettings.OnlineStatus);
            SetPrivacyPrivilege(ref grantPrivileges, ref restrictPrivileges, Privilege.ProfileViewing, Privilege.ProfileViewingFriendsOnly, famSettings.ProfileViewing);
            SetFamilyPrivilege(ref grantPrivileges, ref restrictPrivileges, Privilege.MultiplayerDedicatedServer, famSettings.OnlineGamePlay);
            SetFamilyPrivilege(ref grantPrivileges, ref restrictPrivileges, Privilege.MultiplayerSessions, famSettings.OnlineGamePlay);
            SetFamilyPrivilege(ref grantPrivileges, ref restrictPrivileges, Privilege.Xbox1LiveAccess, famSettings.Xbox1Games);
            SetFamilyPrivilege(ref grantPrivileges, ref restrictPrivileges, Privilege.AddFriend, famSettings.OnlineFriends);
            SetFamilyPrivilege(ref grantPrivileges, ref restrictPrivileges, Privilege.PurchaseContent, famSettings.DownloadContent);
            METHOD.EXIT();
        }

        internal static void ResetPrivacySettings(XblUser user, PrivacySettings newPrivacySettings)
        {
            METHOD.ENTER();
            if (!user.Settings.UserPassportInfo.MemberName.Equals(user.Settings.OwnerPassportInfo.MemberName))
            {
                throw new ArgumentException("Personal Settings are for adult accounts only. Use Family Settings instead.");
            }
            using (Xbox360 xbox = new Xbox360())
            {
                xbox.Live.Logon(user, XOn.WEB_TITLE_ID);
                UserWebInfo uwi = live.server.UACS.XeGetUserWebInfo(xbox.Client, user);
                Privileges grantPrivileges = new Privileges(uwi.Privileges);
                Privileges restrictPrivileges = new Privileges(uwi.Privileges);
                PrepareNewPrivacyPrivileges(ref grantPrivileges, ref restrictPrivileges, newPrivacySettings);
                live.server.UACS.XeUpdateParentalControls(xbox.Client, user, grantPrivileges, restrictPrivileges, null);
                SetGamerProfileSettings(user, xbox, newPrivacySettings.PlayedGames, newPrivacySettings.GamerProfile);
                xbox.Live.Logout(user);
                xbox.ShutdownConsole();
            }
            METHOD.EXIT();
        }

        internal static void ResetFamilySettings(XblUser user, FamilySettings newFamilySettings)
        {
            METHOD.ENTER();
            if (user.Settings.UserPassportInfo.MemberName.Equals(user.Settings.OwnerPassportInfo.MemberName))
            {
                throw new ArgumentException("Family Settings are for child accounts only. Use Privacy Settings instead.");
            }
            using (Xbox360 xbox = new Xbox360())
            {
                xbox.Live.Logon(user, XOn.WEB_TITLE_ID);
                UserWebInfo uwi = live.server.UACS.XeGetUserWebInfo(xbox.Client, user);
                Privileges grantPrivileges = new Privileges(uwi.Privileges);
                Privileges restrictPrivileges = new Privileges(uwi.Privileges);
                PrepareNewFamilyPrivileges(ref grantPrivileges, ref restrictPrivileges, newFamilySettings);
                live.server.UACS.XeUpdateParentalControls(xbox.Client, user, grantPrivileges, restrictPrivileges, null);
                SetGamerProfileSettings(user, xbox, newFamilySettings.ProfileSharing, newFamilySettings.ProfileSharing);
                xbox.Live.Logout(user);
                xbox.ShutdownConsole();
            }
            METHOD.EXIT();
        }

        private static void SetGamerProfileSettings(XblUser user, Xbox360 xbox, PrivacyOption playedGames, PrivacyOption gamerProfile)
        {
            METHOD.ENTER();
            byte newSettings = 0;
            switch (playedGames)
            {
                case PrivacyOption.FriendsOnly:
                    newSettings |= XOn.XPROFILE_PERMISSION_SHARE_ACTIVITY_FRIENDS;
                    break;
                case PrivacyOption.Blocked:
                    newSettings |= XOn.XPROFILE_PERMISSION_SHARE_ACTIVITY_NOONE;
                    break;
            }
            switch (gamerProfile)
            {
                case PrivacyOption.FriendsOnly:
                    newSettings |= XOn.XPROFILE_PERMISSION_SHARE_UCC_FRIENDS;
                    break;
                case PrivacyOption.Blocked:
                    newSettings |= XOn.XPROFILE_PERMISSION_SHARE_UCC_NOONE;
                    break;
            }
            live.protocol.UserSetting[] userSettings = new UserSetting[1];
            byte[] profileSettings = new byte[] { newSettings };
            userSettings[0] = new live.protocol.UserSetting(user.Puid, XOn.XSOURCE_DEFAULT, XOn.XPROFILE_PERMISSIONS, profileSettings);
            live.server.UserSettings.SyncSettings(xbox.Client, user, xbox.Client.TitleId, userSettings, DateTime.UtcNow);
            METHOD.EXIT();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\UserLib\UserAccount.cs ===
﻿using System;
using System.Net;
using System.Collections.ObjectModel;
using System.Diagnostics;

using live.common;

using LiveNew.Test;

using LiveN.Test.Avatar;
using LiveN.Test.Users;

namespace LiveN.Test
{
    /// <summary>
    /// Generic user Account class
    /// </summary>
    public class UserAccount
    {
        /// <summary>
        /// Token that can be used to purchase 4000 points
        /// </summary>
        public const string Prepaid4000TokenString = "RPQQJ-KWXGM-JV8KV-Q8RVX-VQCD3";

        /// <summary>
        /// Base Account. Building on top of this in a generic way.
        /// </summary>
        private readonly Account userAccount;

        /// <summary>
        /// User Purchased History
        /// </summary>
        public Collection<PurchasedItemStruct> Purchases = new Collection<PurchasedItemStruct>();

        /// <summary>
        /// Sets up all the default configuration required to communicate with the back end systems
        /// </summary>
        static UserAccount()
        {
            // Take the current settings from the current global settings
            Environments.SetEnvironment(CurrentEnvironmentSettings.SelectedEnvironment.LiveLibSettings.LiveLibEnvironment);

            if (CurrentEnvironmentSettings.SelectedEnvironment.LiveLibSettings.UseStf)
            {
                Environments.SetStfEnvironment(CurrentEnvironmentSettings.SelectedEnvironment.LiveLibSettings.LiveLibEnvironment);
            }
        }

        /// <summary>
        /// Create a User with the designated account setting
        /// </summary>
        /// <param name="userTier">XBox Live Tier level</param>
        public UserAccount(XblLiveUserTier userTier)
        {
            AccountUserSettings userSettings = new AccountUserSettings();

            // Set the user's xbob live tier level
            switch (userTier)
            {
                case XblLiveUserTier.Silver:

                    userSettings.tier = XblUserTier.Silver;

                    break;

                case XblLiveUserTier.Gold:

                    userSettings.tier = XblUserTier.Gold;

                    break;

                case XblLiveUserTier.GoldLight:

                    userSettings.tier = XblUserTier.Gold;
                    userSettings.LightAccount = true;

                    break;

                case XblLiveUserTier.GoldChild:

                    userSettings.tier = XblUserTier.Gold;
                    userSettings.parentalControl = ParentalControl.Strict;

                    break;
            }

            this.userAccount = CreateUser(userSettings);
        }

        /// <summary>
        /// Create a User with the designated account setting and add points
        /// </summary>
        /// <param name="userTier">XBox Live Tier level</param>
        /// <param name="withPoints">Add points to this account</param>
        public UserAccount(XblLiveUserTier userTier, bool withPoints)
            : this(userTier)
        {
            if (withPoints)
            {
                if (userTier == XblLiveUserTier.GoldChild)
                {
                    // Child user that needs points also need to be able to purchase PDLC
                    this.SetCanPuchasePDLC(true);
                }

                this.AddPoints();
            }
        }

        /// <summary>
        /// [Extreme Customisation ONLY]Create an account with custom settings
        /// </summary>
        /// <param name="userSettings">Custom User settings</param>
        /// <remarks>If this is being called consistently with the same type of user creation, then the creation should be wrapped and expose generically</remarks>
        public UserAccount(AccountUserSettings userSettings)
        {
            this.userAccount = CreateUser(userSettings);
        }

        /// <summary>
        /// Email address used for this user
        /// </summary>
        public string Email
        {
            get
            {
                return this.userAccount.Email;
            }
        }

        /// <summary>
        /// Password used for this user
        /// </summary>
        public string Password
        {
            get
            {
                return this.userAccount.Password;
            }
        }

        /// <summary>
        /// Gamer tag used for this user
        /// </summary>
        public string GamerTag
        {
            get
            {
                return this.userAccount.Gamertag;
            }
        }

        /// <summary>
        /// Xuid to identify this within our system
        /// </summary>
        public ulong Xuid
        {
            get
            {
                return this.userAccount.Xuid;
            }
        }

        /// <summary>
        /// Added 4000 points to this user's account
        /// </summary>
        public uint AddPoints()
        {
            uint usersPointsBalance;

            // Purchase using a token so just in case this use is a Light User (No Credit Card on file), they will still be able to purchase
            usersPointsBalance = this.userAccount.PurchasePointsWithPrepaidCode(Offers.PointsOffers.PP4000, Prepaid4000TokenString);

            return usersPointsBalance;
        }

        /// <summary>
        /// Purchase the passed in offer for this user
        /// </summary>
        /// <param name="offer">Offer to be purchased</param>
        public PurchaseClientResponse PurchaseOffer(OfferContext offer)
        {
            return PurchaseOffer(offer, PurchasePaymentType.Points);
        }

        /// <summary>
        /// Purchase the passed in offer for this user
        /// </summary>
        /// <param name="offer">Offer to be purchased</param>
        /// <param name="paymentType">Payment Type to be used to purchase the offer</param>
        public PurchaseClientResponse PurchaseOffer(OfferContext offer, PurchasePaymentType paymentType)
        {
            PurchaseClientRequest request;
            PurchaseClientResponse response;

            request = new PurchaseClientRequest(this.userAccount.Email, this.userAccount.Password);

            request.RequestContent.CreatePurchaseRequest(offer, paymentType);

            response = request.MakeARequest();
            if(response.StatusCode != HttpStatusCode.OK)
            {
                throw new Exception("Could not purchase OfferId: '" + offer.OfferId.ToString() + "' \r\nResponse:\r\n" + response.ToString());
            }

            // Add this purchase to the purchase history for this user
            Purchases.Add(new PurchasedItemStruct(offer, request, response));

            return response;
        }

        /// <summary>
        /// Set the user's ability to purchase PDLC or not
        /// </summary>
        /// <param name="canPurchase">Allow the user to purchase PDLC</param>
        public void SetCanPuchasePDLC(bool canPurchase)
        {
            FamilyOption familyoption;
            FamilySettings familySettings;

            if (canPurchase)
            {
                familyoption = FamilyOption.Allow;
            }
            else
            {
                familyoption = FamilyOption.Restrict;
            }

            familySettings = new FamilySettings(    PrivacyOption.Blocked,
                                                    PrivacyOption.Blocked,
                                                    PrivacyOption.Blocked,
                                                    PrivacyOption.Blocked,
                                                    PrivacyOption.Blocked,
                                                    PrivacyOption.Blocked,
                                                    PrivacyOption.Blocked,
                                                    FamilyOption.Restrict,
                                                    FamilyOption.Restrict,
                                                    FamilyOption.Restrict,
                                                    familyoption
                                                );

            this.userAccount.ResetFamilySettings(familySettings);
        }

        /// <summary>
        /// Gets this users Avatar body type
        /// </summary>
        /// <param name="avatarBodyType">Desired body type</param>
        public void SetAvatarBodyType(AvatarBodyType avatarBodyType)
        {
            byte[] manifestData = ManifestHelper.CreateRandomManifest((uint)avatarBodyType);

            this.userAccount.Avatar.SetManifest(manifestData);

            if (!ManifestHelper.ManifestsAreEqual(manifestData, this.userAccount.Avatar.WriteManifest()))
            {
                throw new Exception("Manifest written to the service does not match the manifest read from the service.");
            }
        }

        /// <summary>
        /// Creates a new Xbox Live user account based on the given parameters.
        /// </summary>
        /// <param name="userSettings">Settings used to create the user</param>
        /// <returns>Created user account</returns>
        public static Account CreateUser(AccountUserSettings userSettings)
        {
            Account account;
            AccountSettings accountSettings;

            accountSettings = new AccountSettings(  userSettings.tier, 
                                                    live.common.PassportType.Real,
                                                    string.Empty, 
                                                    string.Empty, 
                                                    string.Empty, 
                                                    userSettings.countryId, 
                                                    userSettings.languageId, 
                                                    userSettings.parentalControl, 
                                                    !userSettings.LightAccount
                                                 );

            account = new Account(accountSettings);

            return account;
        }
    }

    /// <summary>
    /// XBox live tier levels
    /// </summary>
    public enum XblLiveUserTier
    {
        Gold,
        Silver,
                
        /// <summary>
        /// Gold account that has not set up an account yet
        /// </summary>
        GoldLight,

        /// <summary>
        /// Strict restrictions but allowed to purchase DLC
        /// </summary>
        GoldChild
    }

    /// <summary>
    /// Defines all the excepted Avatar Body types
    /// </summary>
    public enum AvatarBodyType : uint
    {
        Male = 1, 
        Female = 2, 

        /// <summary>
        /// Either Male or Female
        /// </summary>
        Random = 3
    }

    /// <summary>
    /// Strucuture used to store all the different user settings
    /// </summary>
    public class AccountUserSettings
    {
        /// <summary>
        /// Country id of the user (i.e. US = 103)
        /// </summary>
        public CountryId countryId;

        /// <summary>
        /// Language id of the user (i.e. EN = 1)
        /// </summary>
        public LanguageId languageId;

        /// <summary>
        /// Level of parental control on the user (None = adult, Partial = adolescent, Strict = child)
        /// </summary>
        public ParentalControl parentalControl;

        /// <summary>
        /// Xbox subscription level (Xbox1 = -1, NewUser = 0, Silver = 3, Gold = 6, FamilyGold = 9)
        /// </summary>
        public XblUserTier tier;

        /// <summary>
        /// True if the user is missing billing information. False otherwise.
        /// </summary>
        public bool LightAccount;

        /// <summary>
        /// Create the default User Settings
        /// </summary>
        public AccountUserSettings()
        {
            this.countryId = CountryId.US;
            this.languageId = LanguageId.en;
            this.parentalControl = ParentalControl.None;
            this.LightAccount = false;
        }
    }

    /// <summary>
    /// Structure used to store a purchase
    /// </summary>
    public struct PurchasedItemStruct
    {
        public OfferContext Offer;
        public PurchaseClientRequest Request;
        public PurchaseClientResponse Response;

        /// <summary>
        /// Create a new Purchase Item
        /// </summary>
        public PurchasedItemStruct(OfferContext offer, PurchaseClientRequest request, PurchaseClientResponse response)
        {
            this.Offer = offer;
            this.Request = request;
            this.Response = response;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\UserLib\LiveLibExtensions\AvatarAsset.cs ===
﻿using System;
using live.common;

namespace live.protocol
{
    public class AvatarAsset : WireData
    {
        // Fields
        [WireInfo(ArraySize = 0x10)]
        public byte[] AvatarAssetId;
        public uint AvatarAssetOrdinal;
        public DateTime Awarded;
        public uint BodyComponent;
        public byte BodyTypeMask;
        public string Description;
        public byte DescriptionLen;
        public int Flags;
        public string HowTo;
        public byte HowToLen;
        public uint ImageId;
        public uint Sequence;
        public uint SubCategory;
        public string Title;
        public byte TitleLen;
        public const int XAVATAR_DETAILS_PLATFORM_MASK = 0x700000;
        public const int XAVATAR_DETAILS_PLATFORM_SHIFT = 20;

        // Methods
        public AvatarAsset()
        {
            this.AvatarAssetOrdinal = 0;
            this.Awarded = XOn.MinDateTime;
            this.Sequence = 0;
            this.Flags = 0;
            this.ImageId = 0;
            this.TitleLen = 0;
            this.Title = "";
            this.DescriptionLen = 0;
            this.Description = "";
            this.HowToLen = 0;
            this.HowTo = "";
            this.BodyTypeMask = 0;
            this.BodyComponent = 0;
            this.SubCategory = 0;
        }

        public AvatarAsset(uint avatarAssetOrdinal, byte avatarAssetBodyTypeMask, DateTime awarded, int flags)
        {
            this.AvatarAssetOrdinal = 0;
            this.Awarded = XOn.MinDateTime;
            this.Sequence = 0;
            this.Flags = 0;
            this.ImageId = 0;
            this.TitleLen = 0;
            this.Title = "";
            this.DescriptionLen = 0;
            this.Description = "";
            this.HowToLen = 0;
            this.HowTo = "";
            this.BodyTypeMask = 0;
            this.BodyComponent = 0;
            this.SubCategory = 0;
            this.AvatarAssetOrdinal = avatarAssetOrdinal;
            this.BodyTypeMask = avatarAssetBodyTypeMask;
            this.Awarded = awarded;
            this.Flags = flags;
        }

        public static int SetPlatformTypeInFlags(int existingFlags, int platformType)
        {
            int newFlags = existingFlags & -7340033;
            return (newFlags | ((platformType << 20) & 0x700000));
        }
    }

 

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\AccessibilityAutomation\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\UserLib\LiveLibExtensions\EnumAvatarAssetRequest.cs ===
﻿
namespace live.protocol
{
    public class AvatarAssetEnumRequest : XRLObject2
    {
        // Fields
        public ulong ForPuid = 0L;
        public ushort LocaleId = 0;
        public ushort MaxAssets = 0x20;
        public ulong Puid = 0L;
        public ushort StartingIndex = 0;
        public uint TitleId = 0;

        // Properties
        public string Xrl
        {
            get
            {
                return "/xstats/xavatarassetenum.ashx";
            }
        }
    }

    public class AvatarAssetEnumResponse : XRLObject2
    {
        // Fields
        [WireInfo(SizeParam = "AvatarAssetsCount")]
        public AvatarAsset[] AvatarAssets = null;
        public ushort AvatarAssetsCount = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\AccessibilityWebSite\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\UserLib\LiveLibExtensions\SyncAvatarAwardRequest.cs ===
﻿using System;
using live.common;

namespace live.protocol
{
    public class SyncAvatarAssetRequest : XRLObject2
    {
        // Fields
        [WireInfo(Max = 0x20L)]
        public ushort AvatarAssetCount = 0;
        [WireInfo(SizeParam = "AvatarAssetCount")]
        public AvatarAsset[] AvatarAssets = null;
        public ushort LocaleId = 0;
        public ushort StartingIndex = 0;
        public uint TitleId = 0;
        public ulong UserId = 0L;
        public DateTime Version = XOn.MinDateTime;

        // Properties
        public string Xrl
        {
            get
            {
                return "/xstats/syncavatarassets.ashx";
            }
        }
    }

    public class SyncAvatarAssetResponse : XRLObject2
    {
        // Fields
        [WireInfo(Max = 0x20L)]
        public ushort AvatarAssetCount = 0;
        [WireInfo(SizeParam = "AvatarAssetCount")]
        public AvatarAsset[] AvatarAssets = null;
        public uint MoreAvatarAssetPending = 0;
        public DateTime Version = XOn.MinDateTime;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\UserLib\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("LiveN.Test.Users")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("10846e99-32a5-45ea-815d-3b3018b6bc48")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\UserLib\StfProxy\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("LiveN.Test.Users.Stf")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("Microsoft")]
//[assembly: AssemblyProduct("StfProxy")]
//[assembly: AssemblyCopyright("Copyright © Microsoft 2010")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("d014b65b-f5a7-4d2f-892d-ee8fbf1d0694")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
//[assembly: AssemblyVersion("1.0.0.0")]
//[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\UserLib\StfProxy\StfProxy.cs ===
﻿using System;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.AvatarAsset;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.Utilities;

namespace LiveN.Test.Users.Stf
{
    public static class StfProxy
    {
        public static void Initialize(string environmentName)
        {
            Global.Initialize("stf.xml");

            try
            {
                Global.CurrentEnvironment = Global.EnvironmentList.Find(env => env.Environment.Equals(environmentName, StringComparison.OrdinalIgnoreCase));
            }
            catch(Exception exc)
            {
                throw new Exception("Could not find Environment Name '" + environmentName + "' within stf.xml. Make sure this environment has been added. \r\nException:\r\n" + exc.ToString());
            }
        }

        public static void AwardAvatarAssets(uint titleId, ulong xuid, AvatarAssetWD[] assets)
        {
            XRLSyncAvatarAssets req = new XRLSyncAvatarAssets(titleId, xuid, assets);
            SyncAvatarAssetsResponse resp = req.Execute();
            if (resp.xResult != HResult.S_OK)
            {
                throw new Exception("Unexpected XError returned by server " + resp.xResult);
            }
        }

        public static AvatarAssetWD[] EnumAvatarAssets(uint titleId, ulong xuid)
        {
            XRLEnumAvatarAsset req = new XRLEnumAvatarAsset(titleId, xuid, xuid, 103, 0, 100);
            ServerTestFramework.LiveService.AvatarAsset.AvatarAssetEnumResponse resp = req.Execute();
            if (resp.xResult != HResult.S_OK)
            {
                throw new Exception("Unexpected XError returned by server " + resp.xResult);
            }

            return resp.AvatarAssets;
        }

        public static void AddFamilyMember(ulong primaryPuid, ulong dependentPuid, ulong dependentOwnerPassportPuid)
        {
            XRLXeAddDependentRequest request = new XRLXeAddDependentRequest();
            request.userPuid = dependentPuid;
            byte[] sessionToken = PassportUtilities.GenerateSessionToken(dependentOwnerPassportPuid, request.Slot.Key);
            request.signedOldOwnerPassportPuid = sessionToken;
            request.ownerPuid = primaryPuid;

            if (!request.Execute())
            {
                throw new UnexpectedTestResultException(string.Format("AddDependent failed: {0}", request.GetDumpString()));
            }
            if (request.XErr != 0)
            {
                throw new UnexpectedTestResultException(string.Format("AddDependent didnot return S_OK: {0}", request.GetDumpString()));
            }
        }

        public static void AssignGold(ulong primaryPuid, ulong dependentPuid)
        {
            XRLXeFamilySubscriptionAssignGoldUser request = new XRLXeFamilySubscriptionAssignGoldUser();
            request.ownerPuid = primaryPuid;
            request.userPuid = dependentPuid;

            if (!request.Execute())
            {
                throw new UnexpectedTestResultException("XRLXeFamilySubscriptionAssignGoldUserRequest failed: " + request.GetDumpString());
            }
            if (request.XErr != 0)
            {
                throw new UnexpectedTestResultException(string.Format("XRLXeFamilySubscriptionAssignGoldUserRequest returned XErr=0x{0:x}", request.XErr));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\AccessibilityAutomation\AccessibilityAutomation\Program.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Collections;
using System.Xml;
using System.Configuration;

namespace Test.Common.Utilities.AccessibilityAutomation
{
    /// <summary>
    /// This class starts the program to search for accessibility errors
    /// </summary>
    class Program
    {
        static string errorsXmlFile; // xml file that stores errors
        static string rootErrorNode; // root file of errorsXmlFile
        static string path; // path to errorsXmlFile
        static ArrayList urlsFromArguments; // urls passed in as arguments
        static string commandLineErrorsFile; // Policy errors that occur for urls passed in as command lines
        
        static void Main(string[] args)
        {
            if (args.Length > 0)
            {
                urlsFromArguments = new ArrayList();
                foreach (string arg in args)
                {
                    urlsFromArguments.Add(arg);
                }
            }
            Start();
        }

        /// <summary>
        /// Creates an instance of the ParseHtml class and searches for 
        /// accessibility errors for each url.
        /// </summary>
        static void Start()
        {
            string url = string.Empty;
            string group = string.Empty;
            errorsXmlFile = ConfigurationManager.AppSettings["errorsXml"].ToString();
            rootErrorNode = ConfigurationManager.AppSettings["rootErrorNode"].ToString();
            path = ConfigurationManager.AppSettings["path"].ToString();
            commandLineErrorsFile = ConfigurationManager.AppSettings["commandLineErrorsFile"].ToString();
            
            AccessXMLUrlsDocument accessXMLUrlsDocument = new AccessXMLUrlsDocument();
            XmlNodeList urls = accessXMLUrlsDocument.GetAccessibilityUrls();
            AccessXMLNodesDocument accessXMLNodesDocument = new AccessXMLNodesDocument();
            XmlNodeList nodes = accessXMLNodesDocument.GetAccessibilityNodes(); //nodes that we don't need to check for missing id
            ParseHtml parser = new ParseHtml();
            ArrayList nodesThatDoNotNeedID = new ArrayList();
            foreach (XmlNode node in nodes)
            {
                nodesThatDoNotNeedID.Add(node.InnerText.ToLower());
            }

            if (urlsFromArguments == null || urlsFromArguments.Count == 0)
            {
                foreach (XmlNode urlNode in urls)
                {
                    url = urlNode.InnerText;
                    group = urlNode.ParentNode.Attributes["group"].Value;
                    parser.Start(url, group, nodesThatDoNotNeedID);
                }
            }
            else
            {
                foreach (string urlArg in urlsFromArguments)
                {
                    parser.Start(urlArg, "", nodesThatDoNotNeedID);
                }
            }
            ArrayList alGetAccessibilityErrors = parser.GetAccessibilityErrors();
            GetGeneralWarnings(alGetAccessibilityErrors);
            UpdateErrorXmlFile(alGetAccessibilityErrors);
        }
        /// <summary>
        /// Adds in general warnings
        /// </summary>
        /// <param name="alGetAccessibilityErrors"></param>
        static void GetGeneralWarnings(ArrayList alGetAccessibilityErrors)
        {    
            string guideline = string.Empty;
            string description = string.Empty;
            int priority = 0;
            int level = 2;
            string[] Warnings = ConfigurationManager.AppSettings["warnings"].ToString().Split(',');
            AccessXMLErrorsDocument accessXMLErrorsDocument = new AccessXMLErrorsDocument();
            foreach (string warning in Warnings)
            {
                accessXMLErrorsDocument.GetAccessibilityError(warning, ref guideline, ref description, ref priority, ref level);
                alGetAccessibilityErrors.Add(new AccessibilityError("Any Web Page", "", "", "", warning, guideline, description, priority, level, ""));
            }
        
        }
        /// <summary>
        /// Updates xml file of current accessibility errors
        /// </summary>
        /// <param name="alGetAccessibilityErrors"></param>
        static void UpdateErrorXmlFile(ArrayList alGetAccessibilityErrors)
        {
            try
            {
                XmlDocument xmlErrorsDoc = new XmlDocument();
                string thePath = path + errorsXmlFile;
                bool bUsingCommandLine = false;
                
                if (urlsFromArguments != null && urlsFromArguments.Count > 0)
                {
                    bUsingCommandLine = true;
                    thePath = commandLineErrorsFile;
                    // insert root node
                    XmlElement xmlelem = xmlErrorsDoc.CreateElement("", "errorNodes", "");
                    xmlErrorsDoc.AppendChild(xmlelem);
                    xmlErrorsDoc.Save(thePath);
                }
                xmlErrorsDoc.Load(thePath);
                XmlNode errorNodes = xmlErrorsDoc.SelectSingleNode(rootErrorNode);
                errorNodes.RemoveAll();

                foreach (AccessibilityError errorObject in alGetAccessibilityErrors)
                {
                    XmlElement newErrorNode = xmlErrorsDoc.CreateElement("error");
                    newErrorNode.SetAttribute("Url", errorObject.Url);
                    newErrorNode.SetAttribute("Node", errorObject.Node);
                    newErrorNode.SetAttribute("LineNumber", errorObject.LineNumber.ToString());
                    newErrorNode.SetAttribute("Column", errorObject.Column.ToString());
                    newErrorNode.SetAttribute("Error", errorObject.Error.ToString());
                    newErrorNode.SetAttribute("Guideline", errorObject.Guidelines);
                    newErrorNode.SetAttribute("Description", errorObject.Description.Replace("<", "&lt;").Replace(">", "&gt;"));
                    newErrorNode.SetAttribute("Priority", errorObject.Priority.ToString());
                    newErrorNode.SetAttribute("Level", errorObject.Level.ToString());
                    if(!bUsingCommandLine)
                        newErrorNode.SetAttribute("Group", errorObject.Group.ToString());
                    errorNodes.AppendChild(newErrorNode);
                }

                xmlErrorsDoc.Save(thePath);
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
            }

        }
            
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\AccessibilityWebSite\AccessibilityWebSite\Default.aspx.cs ===
﻿using System;
using System.Collections.Generic;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Configuration;
using System.Collections;
using System.Xml;
using System.IO;
using System.Collections.Specialized;

namespace Test.Common.Utilities.AccessibilityWebSite
{
    public partial class _Default : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {
            if (!IsPostBack)
            {
                ddlGroups.SelectedIndex = 0;
                InsertGroups();
                InsertUrls();
                SetDate();
            }
            if (Request.QueryString.Count > 0)
            {
                try
                {
                    int index = 0;
                    foreach (string key in Request.QueryString)
                    {
                        if (key == "pri")
                        {
                            index = Convert.ToInt32(Request.QueryString[key]);
                            if (index > 0 && index < 6)
                            {
                                cblWCAG.Items[index-1].Selected = true;
                                cblWCAG.Visible = true;
                                rblGuideline.SelectedIndex = 0;
                                cblMicrosoft.Visible = false;
                            }
                        }
                        if (key == "level")
                        {
                            index = Convert.ToInt32(Request.QueryString[key]);
                            if (index >= 0 && index < 4)
                            {
                                cblMicrosoft.Items[index].Selected = true;
                                cblWCAG.Visible = false;
                                rblGuideline.SelectedIndex = 1;
                                cblMicrosoft.Visible = true;
                            }
                        }
                        else if (key == "url")
                        {
                            tbUrlContains.Text = Request.QueryString[key];
                        }
                    }
                    ShowDataGrid();
                }
                catch (Exception ex)
                {
                    Response.Write(ex.Message);
                }
            }
            MaintainScrollPositionOnPostBack = true;
        }

        void SetDate()
        {
            string path = Paths.GetFullPath() + Paths.GetErrorsFile();
            if (File.Exists(path))
            {
                label_LastWrite.Text = "Last Run: " + File.GetLastWriteTime(path).ToString();
            }
        }

        /// <summary>
        /// Gets all the errors from the xml file
        /// </summary>
        /// <returns>An arraylist of errors</returns>
        ArrayList GetErrorObjects()
        {
            string filter = string.Empty;
            if (cblWCAG.Visible)
            {
                foreach (ListItem item in cblWCAG.Items)
                {
                    if (item.Selected)
                    {
                        if (filter != "")
                            filter += " or ";
                        filter += "@Priority='" + item.Value + "'";
                    }
                }
            }
            else if (cblMicrosoft.Visible)
            {
                foreach (ListItem item in cblMicrosoft.Items)
                {
                    if (item.Selected)
                    {
                        if (filter != "")
                            filter += " or ";
                        filter += "@Level='" + item.Value + "'";
                    }
                }
            }
            ArrayList errorObjects = new ArrayList();
            if (filter == "")
                return errorObjects;
            string urlContains = tbUrlContains.Text;
            if (urlContains != "" || ddlUrls.SelectedIndex > 0 || ddlGroupEquals.SelectedIndex > 0)
                filter = "(" + filter + ")";
            if (urlContains != "" && tbUrlContains.Visible)
            {  
                filter += " and contains(@Url,'" + urlContains + "')";
            }
            if (ddlUrls.SelectedIndex > 0 && ddlUrls.Visible)
            {
                filter += " and @Url = '" + ddlUrls.SelectedValue + "'";
            }
            if (ddlGroupEquals.SelectedIndex > 0 && ddlGroupEquals.Visible)
            {
                filter += " and @Group = '" + ddlGroupEquals.SelectedValue + "'";
            }
            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(Paths.GetFullPath() + Paths.GetErrorsFile());
            XmlNodeList Errors = xDoc.SelectNodes(Paths.GetRootErrorNodes() + "[" + filter + "]");
            
            foreach (XmlNode errorNode in Errors)
            {
                errorObjects.Add(new AccessibilityError(errorNode.Attributes["Url"].Value, errorNode.Attributes["Node"].Value, errorNode.Attributes["LineNumber"].Value, errorNode.Attributes["Column"].Value, errorNode.Attributes["Error"].Value, errorNode.Attributes["Guideline"].Value, errorNode.Attributes["Description"].Value, Convert.ToInt32(errorNode.Attributes["Priority"].Value), Convert.ToInt32(errorNode.Attributes["Level"].Value)));
            }
            return errorObjects;
        }
        /// <summary>
        /// Binds the data to the datagrid
        /// </summary>
        void MyDataBind(bool resetPageIndex)
        {          
            ArrayList alErrorObjects = GetErrorObjects();
            dgErrors.DataSource = alErrorObjects;
            if (resetPageIndex)
                dgErrors.CurrentPageIndex = 0;
            dgErrors.DataBind();
        }

        /// <summary>
        /// This method is used to page through the datagrid
        /// </summary>
        /// <param name="source"></param>
        /// <param name="e"></param>
        protected void Paging_DataGrid(object source, System.Web.UI.WebControls.DataGridPageChangedEventArgs e)
        {
            dgErrors.CurrentPageIndex = e.NewPageIndex;

            MyDataBind(false);
        }

        protected void btnDisplay_Click(object sender, EventArgs e)
        {
            ShowDataGrid();
        }
        /// <summary>
        /// Displays data grid of policy errors
        /// </summary>
        void ShowDataGrid()
        {
            btnViewAll.Visible = true;
            SetDate();
            MyDataBind(true);
        }
        /// <summary>
        /// This method gets all the groups from the xml file
        /// and adds them to a drop down list
        /// </summary>
        void InsertGroups()
        {
            string group = string.Empty;
            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(Paths.GetFullPath() + Paths.GetUrlsFile());

            XmlNodeList nodes = xDoc.SelectNodes(Paths.GetUrlGroupNodes());
            ddlGroups.Items.Add("Show All");
            ddlGroupEquals.Items.Add("");
            foreach (XmlNode node in nodes)
            {
                group = node.Attributes["group"].Value;
                ddlGroups.Items.Add(group);
                ddlGroupEquals.Items.Add(group);
            }
        }
        /// <summary>
        /// This method gets all the urls from the xml file
        /// and adds them to a drop down list
        /// </summary>
        void InsertUrls()
        {
            string group = ddlGroups.SelectedValue;
            ArrayList urls = GetUrlObjects(group);
            ddlUrls.Items.Clear();
            ddlUrls.Items.Add("");
            foreach (string url in urls)
                ddlUrls.Items.Add(url);
        }
        /// <summary>
        /// Gets all the urls from the xml file
        /// </summary>
        /// <returns></returns>
        ArrayList GetUrlObjects()
        {
            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(Paths.GetFullPath() + Paths.GetUrlsFile());
            XmlNodeList Urls = xDoc.SelectNodes(Paths.GetUrlNodes());
            ArrayList urlObjects = new ArrayList();
            foreach (XmlNode urlNode in Urls)
            {
                urlObjects.Add(urlNode.InnerText);
            }
            return urlObjects;
        }
        /// <summary>
        /// Gets all the urls from the xml file, filtered by group
        /// </summary>
        /// <param name="Group">The group to filter by</param>
        /// <returns></returns>
        ArrayList GetUrlObjects(string Group)
        {
            if (Group == "Show All")
            {
                return GetUrlObjects();
            }

            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(Paths.GetFullPath() + Paths.GetUrlsFile());
            XmlNodeList Urls = xDoc.SelectNodes("//urls/urlGroup[@group='" + Group + "']/url");
            ArrayList urlObjects = new ArrayList();
            foreach (XmlNode urlNode in Urls)
            {
                urlObjects.Add(urlNode.InnerText);
            }

            return urlObjects;
        }
        protected void btnExport_Click(object sender, EventArgs e)
        {
            exportToExcel("Downloads/", "test" + System.Guid.NewGuid().ToString() + ".csv");
            
        }
        public void exportToExcel(string path, string fileName)
        {
            string filepath = Paths.GetFullPath() + fileName;

            ArrayList alErrorObjects = GetErrorObjects();
            string[] name = { "Url", "Node", "LineNumber", "Column", "Error", "Guideline", "Description", "Priority", "Level" };

            System.IO.StreamWriter excelDoc;

            excelDoc = new System.IO.StreamWriter(filepath);

            for (int x = 0; x < name.Length; x++)
            {
                excelDoc.Write(name[x] + ",");
            }
            foreach (AccessibilityError error in alErrorObjects)
            {
                excelDoc.Write(excelDoc.NewLine);
                excelDoc.Write(error.Url + "," + error.Node + "," + error.LineNumber + "," + error.Column + "," + "\"" + error.Error + "\"" + "," + "\"" + error.Guideline + "\"" + "," + "\"" + error.Description + "\"" + "," + error.Priority + "," + error.Level);
            }

            excelDoc.Close();
            FileInfo file = new FileInfo(filepath);

            if (file.Exists)
            {
                Response.ClearContent();
                Response.AddHeader("Content-Disposition", "attachment; filename=" + "data.csv");
                Response.AddHeader("Content-Length", file.Length.ToString());
                Response.ContentType = "application/vnd.ms-excel";
                Response.WriteFile(file.FullName);
                Response.Flush();
                file.Delete();
                Response.End();
            }
        }

        protected void btnViewAll_Click(object sender, EventArgs e)
        {
            if (Session["ViewAll"] == null)
            {
                Session["ViewAll"] = "true";
            }
            if (Session["ViewAll"].ToString() == "true")
            {
                Session["ViewAll"] = "false";
                dgErrors.AllowPaging = false;
                btnViewAll.Text = "Allow Paging";
            }
            else
            {
                Session["ViewAll"] = "true";
                dgErrors.AllowPaging = true;
                btnViewAll.Text = "View All";
            }

            MyDataBind(false);
        }

        protected void btnUrls_Click(object sender, EventArgs e)
        {
            Response.Redirect("Urls.aspx");
        }

        protected void rblGuideline_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (rblGuideline.SelectedValue.Equals("WCAG"))
            {
                cblMicrosoft.Visible = false;
                cblWCAG.Visible = true;
            }
            else
            {
                cblMicrosoft.Visible = true;
                cblWCAG.Visible = false;
            }
        }

        protected void ddlGroups_SelectedIndexChanged(object sender, EventArgs e)
        {
            InsertUrls();
        }

        protected void rblFilter_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (rblFilter.Items[0].Selected)
            {
                tbUrlContains.Visible = true;
                ddlUrls.Visible = false;
                lblGroup.Visible = false;
                ddlGroups.Visible = false;
                ddlGroupEquals.Visible = false;
            }
            else if (rblFilter.Items[1].Selected)
            {
                tbUrlContains.Visible = false;
                ddlUrls.Visible = true;
                lblGroup.Visible = true;
                ddlGroups.Visible = true;
                ddlGroupEquals.Visible = false;
            }
            else if (rblFilter.Items[2].Selected)
            {
                tbUrlContains.Visible = false;
                ddlUrls.Visible = false;
                lblGroup.Visible = false;
                ddlGroups.Visible = false;
                ddlGroupEquals.Visible = true;
            }
        }
    }

    class Paths
    {
        public static string GetFullSharedPath()
        {
            return ConfigurationManager.AppSettings["FullSharedPath"];
        }
        public static string GetFullPath()
        {
            return ConfigurationManager.AppSettings["FullPath"];
        }
        public static string GetErrorsFile()
        {
            return ConfigurationManager.AppSettings["ErrorsFile"];
        }
        public static string GetRootErrorNodes()
        {
            return ConfigurationManager.AppSettings["rootErrorNode"];
        }
        public static string GetDocumentation()
        {
            return ConfigurationManager.AppSettings["documentation"];
        }
        public static string GetUrlsFile()
        {
            return ConfigurationManager.AppSettings["accessibilityUrlsFile"];
        }
        public static string GetUrlNodes()
        {
            return ConfigurationManager.AppSettings["accessibilityUrlsNodes"];
        }
        public static string GetUrlRootNode()
        {
            return ConfigurationManager.AppSettings["accessibilityUrlRootNode"];
        }
        public static string GetUrlGroupNodes()
        {
            return ConfigurationManager.AppSettings["accessibilityUrlGroupNodes"];
        }

    }
    /// <summary>
    /// Stores accessibility errors
    /// </summary>
    class AccessibilityError
    {
        string url;
        string node;
        string error;
        string guideline;
        string description;
        string lineNumber;
        string column;
        int priority;
        int level;

        public AccessibilityError(string url, string node, string lineNumber, string column, string error, string guideline, string description, int priority, int level)
        {
            this.url = url;
            this.lineNumber = lineNumber;
            this.column = column;
            this.node = node;
            this.error = error;
            this.guideline = guideline;
            this.description = description;
            this.priority = priority;
            this.level = level;
        }
        public string Url
        {
            get { return url; }
        }
        public string Node
        {
            get { return node; }
        }
        public string LineNumber
        {
            get { return lineNumber; }
        }
        public string Column
        {
            get { return column; }
        }
        public string Error
        {
            get { return error; }
        }
        public string Guideline
        {
            get { return guideline; }
        }
        public string Description
        {
            get { return description; }
        }
        public int Priority
        {
            get { return priority; }
        }
        public int Level
        {
            get { return level; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\AccessibilityAutomation\AccessibilityAutomation\ParseHtml.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml;
using System.Collections;
using System.Configuration;
using Test.Common.Library.HtmlAgilityPack;
using System.IO;

namespace Test.Common.Utilities.AccessibilityAutomation
{
    /// <summary>
    /// This class parses the html of a particular url and searches for accessibility errors.
    /// </summary>
    class ParseHtml
    {
        bool bCheckForID; // flag to check for id with each element for improving test automation. This isn't really an accessibility issue.
        string elementHasNoID; // error: element is missing id
        ArrayList nodesThatDoNotNeedID; //nodes that we don't need to check for missing id
        
        AccessXMLErrorsDocument accessXMLErrorsDocument; // object to store accessiblity errors for this url
        ArrayList alAccessibilityErrors; //Arraylist of accessibility errors found for this url
        string currentUrl; // the url currently being examined
        string currentGroup; // the group that this url belongs to
        string languageError; // accessibility error when document language not identified
        string onclickError;//accessibility error when OnClick event missing onkeypress event
        string ondblclickError; //accessibility error  OnDblClick event missing keyboard shortcut
        string onmousedownError; //accessibility error onmousedown event missing onkeydown event
        string onmouseupError; //accessibility error onmouseup event handler missing onfocus event handler
        string onmouseoverError; //accessibility error onmouseover event handler missing onfocus event handler
        string onmouseoutError; //accessibility error onmouseout event handler missing onfocus event handler
        string imgElementMissingAltError; //accessibility error img element missing alt attribute
        string imgElementAltSameAsSrc; //accessibility error img element alt attribute same as src attribute
        string imgElementAltAttributeTooLong; //accessibility error img element alt attribute too long
        string imgElementContainedInATagHasAltAttributeEmpty; //accessibility error img element contained in <a> has alt attribute empty
        string largeImgElementHasAltAttributeEmpty; //accessibility error large img element has alt attribute empty
        int largeAltTextLength; //accessibility error Maximum alt text length before error is issued
        string imgWithLongdescHasNoDLink; //accessibility error All img elements that have a longdesc attribute also have an associated d-link.
        int largeImgSize; //accessibility error Maximum image size before error is issued
        string imgUsedAsBulletHasAltAttributeEmpty; //accessibility error Images used as bullets missing alternative text
        string areaElementMissingAltError; //accessibility error area element missing alt attribute
        string serverSideImageMapMissingClientsideImageMap; //accessibility error Server-side image map used without client-side image map
        string anchorContainsNoText; //accessibility error Anchor contains no text
        string noTabOrder; //accessibility error Object has no tab order
        string missingTitleAttribute; //accessibility error Object missing title attribute
        string documentMissingTitleElement; //accessibility error Document missing title element
        string inputElementMissingAssociatedLabel; //accessibility error input element missing an associated label
        string textareaElementMissingAssociatedLabel; //accessibility error textarea element missing an associated label
        string selectElementMissingAssociatedLabel; //accessibility error select element missing an associated label
        string frameMissingTitleAttribute; //accessibility error frame missing title attribute
        string framesetMissingNoframesSection; //accessibility error frameset missing noframes section
        bool hasHeadingTag; //set to false until an h1 tag is found on the page
        int numH1Tags; // number of h1 tags on the page
        bool hasDoctypeDeclaration; //set to false until it finds the document declaration
        string noHeadingTags; //Policy error when no h1 tag found
        string pElementMayBeMisused; //Policy error: p element may be misused (could be a header)
        string fontUsed;// Policy error when relying on a specific font
        string textColorNotSet; //Policy error when using a specific color
        string marqueeElementUsed; //Policy error when marquee used
        string noScriptSection; //Policy error when script section is not followed by a noscript section
        string anchorOpensNewWindow; // Policy error when a new window opens without warning
        string blinkElementUsed; // Policy error: Do not create applications that are likely to cause seizures due to UI that flashes at a rate greater than 3 times per second.
        string frameMissingSrc; // Policy error: Content developers must provide text equivalents of frames
        string usingMetaToRefreshAPage; // Policy error: Do not create periodically auto-refreshing pages.
        string autoRedirectUsed; // Policy error: Do not use markup to redirect pages automatically.
        string imageMissingAltText; // Policy error: input element with type of image must have an alt attribute.
        string objectMissingTextEquivalent; //Policy error: When using OBJECT, specify a text equivalent in the body of the OBJECT element.
        string linkToMultimediaMissingTextAlternative; //Policy error: This error will be generated for each a (anchor) element that contains an href attribute value ending with (case insensitive): .wmv, .mpg, .mov, .ram, .aif and is missing alternative text.
        string usingFrameWithTarget_blank; //Policy error: Content developers should avoid specifying a new window as the target of a frame with target="_blank"
        string doctypeDeclarationMissing; //Policy error: Each document must contain a valid doctype declaration.
        string linkUsesJavascript; //Policy error: Avoid creating links that use "javascript" as the URI. If a user is not using scripts, then they won't be able to link since the browser can't create the link content.
        string doNotUseDeprecatedElements; //Policy error: Avoid deprecated elements so that your Web page is compliant with current browser technology
        string doNotUseDeprecatedAttributes; //Policy error: Avoid deprecated elements so that your Web page is compliant with current browser technology
        string missingFieldsetAndLegendToGroupMultipleRadioButtons; //Policy error: form element content must contain both fieldset and legend elements if there are related radio buttons
        string optgroupMayBeRequiredForLargeNumberOptions; //Policy error: select element content that contains 4 or more option elements must contain at least 2 optgroup elements.
        string usingBorIelements; //Policy error: The B and I elements should not be used
        string longTableHeaderLabelMissingTerseSubstitute; //Policy error: Long table header label missing terse substitute.
        bool scriptFound; // Checking that scripts have a corresponding noscript
        bool noscriptFound; // Checking that scripts have a corresponding noscript
        string embedUsedWithoutNoembed; //Policy error: embed used without noembed
        bool embedFound; // Checking that embed have a corresponding noembed
        bool noembedFound; // Checking that embed have a corresponding embed
        string noKeyboardAccessToObjectOrLink; //Policy error: All Anchor, AREA, BUTTON, INPUT, LABEL, LEGEND, and TEXTAREA elements are required to use the 'accesskey' attribute.
        string imgElementHasAltAttributeEmpty; //Possible policy error: img element contains the alt attribute with an empty value. Please verify that this image is only used for spacing or design and has no meaning.
        string warningShouldThisBeALayoutTable; //Possible policy error: Using a layout table when stylesheets should be used instead, or using a data table without TH elements
        string warningLayoutTableShouldNotContainSummary; //Possible policy error: Layout table should not contain a summary
        string warningProvideSummariesForDataTables; //Possible policy error: Add a summary attribute describing the contents of the table. This is read aloud before the table contents, allowing non-sighted users to decide whether to skip the table.
        string warningProvideMarkupForDataTables; //Possible policy error: For complex tables, i.e. where tables have structural divisions beyond those implicit in the rows and columns, use appropriate markup to identify those divisions.
        string warningProvideAbbreviationsForHeaderLabels; //Possible policy error: If you don't use the abbr attribute, the entire header will be spoken for its associated data values by the screen reader. 
        string warningLayoutTableContainsACaption; //Possible policy error: Layout table contains a caption
        string warningDataTableShouldContainsACaption; //Possible policy error: Data table should contain a caption
        string dataTableShouldContainsIdAndHeadersAttributes; //Possible policy error: Data table should contain id and header attributes
        string linkElementMissingRelAndHrefAttributes; //Possible error: Link element missing rel and href attributes
        string selectElementsCausesAnExtremeChangeInContext; //Possible error: All select elements should not cause an extreme change in context. Examine the onchange handler for any action that will cause the page to reload or cause an extreme change of context. Actions that will cause the page to reload or cause an extreme change of context may be variations of one of the following JavaScript statements: form.submit(), window.location.href = uri, elementElsewhereOnThePage.focus()
        string useHrefInsteadOfSpanOnclick; //Policy Error: Use anchor href, not span onclick=navigate()
        string useParagraphsInsteadOfBreaks; // MATS policy error: Use <p> not <div> or <br><br>
        string moreThan1H1Tag; // Microsoft recommendation" Description="Microsoft recommends that there should be only one H1 on every page, and it should match the page title.

        // The following array lists are used for checking if id attribute in input element matches the for attribute value of a label elsewhere
        ArrayList alForAttributesInLabel;
        ArrayList alNodeInputElement;
        ArrayList alIdAttributeInputElement;
        
        public ParseHtml()
        {
            alAccessibilityErrors = new ArrayList();
            SetConfigValues();       
        }
        /// <summary>
        /// Get values from the app.config file
        /// </summary>
        void SetConfigValues()
        {
            bCheckForID = true;

            languageError = ConfigurationManager.AppSettings["languageError"].ToString();
            onclickError = ConfigurationManager.AppSettings["onclickError"].ToString();
            ondblclickError = ConfigurationManager.AppSettings["ondblclickError"].ToString();
            onmousedownError = ConfigurationManager.AppSettings["onmousedownError"].ToString();
            onmouseupError = ConfigurationManager.AppSettings["onmouseupError"].ToString();
            onmouseoverError = ConfigurationManager.AppSettings["onmouseoverError"].ToString();
            onmouseoutError = ConfigurationManager.AppSettings["onmouseoutError"].ToString();
            imgElementMissingAltError = ConfigurationManager.AppSettings["imgElementMissingAltError"].ToString();
            imgElementAltSameAsSrc = ConfigurationManager.AppSettings["imgElementAltSameAsSrc"].ToString();
            imgElementAltAttributeTooLong = ConfigurationManager.AppSettings["imgElementAltAttributeTooLong"].ToString();
            imgElementContainedInATagHasAltAttributeEmpty = ConfigurationManager.AppSettings["imgElementContainedInATagHasAltAttributeEmpty"].ToString();
            largeImgElementHasAltAttributeEmpty = ConfigurationManager.AppSettings["largeImgElementHasAltAttributeEmpty"].ToString();
            largeAltTextLength = Convert.ToInt32(ConfigurationManager.AppSettings["largeAltTextLength"].ToString());
            imgWithLongdescHasNoDLink = ConfigurationManager.AppSettings["imgWithLongdescHasNoDLink"].ToString();
            largeImgSize = Convert.ToInt32(ConfigurationManager.AppSettings["largeImgSize"].ToString());
            imgUsedAsBulletHasAltAttributeEmpty = ConfigurationManager.AppSettings["imgUsedAsBulletHasAltAttributeEmpty"].ToString();
            areaElementMissingAltError = ConfigurationManager.AppSettings["areaElementMissingAltError"].ToString();
            serverSideImageMapMissingClientsideImageMap = ConfigurationManager.AppSettings["serverSideImageMapMissingClientsideImageMap"].ToString();
            anchorContainsNoText = ConfigurationManager.AppSettings["anchorContainsNoText"].ToString();
            noTabOrder = ConfigurationManager.AppSettings["noTabOrder"].ToString();
            missingTitleAttribute = ConfigurationManager.AppSettings["missingTitleAttribute"].ToString();
            documentMissingTitleElement = ConfigurationManager.AppSettings["documentMissingTitleElement"].ToString();
            inputElementMissingAssociatedLabel = ConfigurationManager.AppSettings["inputElementMissingAssociatedLabel"].ToString();
            textareaElementMissingAssociatedLabel = ConfigurationManager.AppSettings["textareaElementMissingAssociatedLabel"].ToString();
            selectElementMissingAssociatedLabel = ConfigurationManager.AppSettings["selectElementMissingAssociatedLabel"].ToString();
            frameMissingTitleAttribute = ConfigurationManager.AppSettings["frameMissingTitleAttribute"].ToString();
            framesetMissingNoframesSection = ConfigurationManager.AppSettings["framesetMissingNoframesSection"].ToString();
            hasHeadingTag = false;
            numH1Tags = 0;
            hasDoctypeDeclaration = false;
            noHeadingTags = ConfigurationManager.AppSettings["noHeadingTags"].ToString();
            fontUsed = ConfigurationManager.AppSettings["fontUsed"].ToString();
            textColorNotSet = ConfigurationManager.AppSettings["textColorNotSet"].ToString();
            marqueeElementUsed = ConfigurationManager.AppSettings["marqueeElementUsed"].ToString();
            noScriptSection = ConfigurationManager.AppSettings["noScriptSection"].ToString();
            anchorOpensNewWindow = ConfigurationManager.AppSettings["anchorOpensNewWindow"].ToString();
            blinkElementUsed = ConfigurationManager.AppSettings["blinkElementUsed"].ToString();
            frameMissingSrc = ConfigurationManager.AppSettings["frameMissingSrc"].ToString();
            usingMetaToRefreshAPage = ConfigurationManager.AppSettings["usingMetaToRefreshAPage"].ToString();
            autoRedirectUsed = ConfigurationManager.AppSettings["autoRedirectUsed"].ToString();
            imageMissingAltText = ConfigurationManager.AppSettings["imageMissingAltText"].ToString();
            objectMissingTextEquivalent = ConfigurationManager.AppSettings["objectMissingTextEquivalent"].ToString();
            linkToMultimediaMissingTextAlternative = ConfigurationManager.AppSettings["linkToMultimediaMissingTextAlternative"].ToString();
            usingFrameWithTarget_blank = ConfigurationManager.AppSettings["usingFrameWithTarget_blank"].ToString();
            doctypeDeclarationMissing = ConfigurationManager.AppSettings["doctypeDeclarationMissing"].ToString();
            linkUsesJavascript = ConfigurationManager.AppSettings["linkUsesJavascript"].ToString();
            doNotUseDeprecatedElements = ConfigurationManager.AppSettings["doNotUseDeprecatedElements"].ToString();
            missingFieldsetAndLegendToGroupMultipleRadioButtons = ConfigurationManager.AppSettings["missingFieldsetAndLegendToGroupMultipleRadioButtons"].ToString();
            optgroupMayBeRequiredForLargeNumberOptions = ConfigurationManager.AppSettings["optgroupMayBeRequiredForLargeNumberOptions"].ToString();
            usingBorIelements = ConfigurationManager.AppSettings["usingBorIelements"].ToString();
            longTableHeaderLabelMissingTerseSubstitute = ConfigurationManager.AppSettings["longTableHeaderLabelMissingTerseSubstitute"].ToString();
            doNotUseDeprecatedAttributes = ConfigurationManager.AppSettings["doNotUseDeprecatedAttributes"].ToString();
            pElementMayBeMisused = ConfigurationManager.AppSettings["pElementMayBeMisused"].ToString();
            scriptFound = false;
            noscriptFound = false;
            embedUsedWithoutNoembed = ConfigurationManager.AppSettings["embedUsedWithoutNoembed"].ToString();
            embedFound = false;
            noembedFound = false;
            noKeyboardAccessToObjectOrLink = ConfigurationManager.AppSettings["noKeyboardAccessToObjectOrLink"].ToString();
            imgElementHasAltAttributeEmpty = ConfigurationManager.AppSettings["imgElementHasAltAttributeEmpty"].ToString();
            elementHasNoID = ConfigurationManager.AppSettings["elementHasNoID"].ToString();
            warningShouldThisBeALayoutTable = ConfigurationManager.AppSettings["warningShouldThisBeALayoutTable"].ToString();
            warningLayoutTableShouldNotContainSummary = ConfigurationManager.AppSettings["warningLayoutTableShouldNotContainSummary"].ToString();
            warningProvideSummariesForDataTables = ConfigurationManager.AppSettings["warningProvideSummariesForDataTables"].ToString();
            warningProvideMarkupForDataTables = ConfigurationManager.AppSettings["warningProvideMarkupForDataTables"].ToString();
            warningProvideAbbreviationsForHeaderLabels = ConfigurationManager.AppSettings["warningProvideAbbreviationsForHeaderLabels"].ToString();
            warningLayoutTableContainsACaption = ConfigurationManager.AppSettings["warningLayoutTableContainsACaption"].ToString();
            warningDataTableShouldContainsACaption = ConfigurationManager.AppSettings["warningDataTableShouldContainsACaption"].ToString();
            dataTableShouldContainsIdAndHeadersAttributes = ConfigurationManager.AppSettings["dataTableShouldContainsIdAndHeadersAttributes"].ToString();
            linkElementMissingRelAndHrefAttributes = ConfigurationManager.AppSettings["linkElementMissingRelAndHrefAttributes"].ToString();
            selectElementsCausesAnExtremeChangeInContext = ConfigurationManager.AppSettings["selectElementsCausesAnExtremeChangeInContext"].ToString();
            useHrefInsteadOfSpanOnclick = ConfigurationManager.AppSettings["useHrefInsteadOfSpanOnclick"].ToString();
            useParagraphsInsteadOfBreaks = ConfigurationManager.AppSettings["useParagraphsInsteadOfBreaks"].ToString();
            moreThan1H1Tag = ConfigurationManager.AppSettings["moreThan1H1Tag"].ToString();

            alForAttributesInLabel = new ArrayList();
            alIdAttributeInputElement = new ArrayList();
            alNodeInputElement = new ArrayList();
        }
        /// <summary>
        /// Checks accessibility policies for a single url
        /// </summary>
        /// <param name="url"></param>
        public void Start(string url, string group, ArrayList theNodesThatDoNotNeedID)
        {
            nodesThatDoNotNeedID = theNodesThatDoNotNeedID;
            accessXMLErrorsDocument = new AccessXMLErrorsDocument();  
            currentUrl = url;
            currentGroup = group;
            HtmlWeb htmlWeb = new HtmlWeb();
            HtmlDocument doc = htmlWeb.Load(url);
            
            ConvertTo(doc.DocumentNode);

            if (!hasHeadingTag)
            {
                AddAccessibilityError(noHeadingTags, "", -1, -1);
            }
            if (numH1Tags > 1)
            {
                AddAccessibilityError(moreThan1H1Tag, "", -1, -1);
            }
            if (!hasDoctypeDeclaration)
            {
                AddAccessibilityError(doctypeDeclarationMissing, "", -1, -1);
            }
            if(scriptFound && !noscriptFound)
                AddAccessibilityError(noScriptSection, "script", -1, -1);

            if(embedFound && !noembedFound)
                AddAccessibilityError(embedUsedWithoutNoembed, "embed", -1, -1);

            //check if id of input element matches the for attribute value of a label
            bool inputWithoutLabelError = true;
            foreach (string id in alIdAttributeInputElement)
            {
                inputWithoutLabelError = true;
                foreach (string forAttribute in alForAttributesInLabel)
                {
                    if(String.Compare(id.ToLower(), forAttribute.ToLower()) == 0)
                        inputWithoutLabelError = false;
                }
                if (inputWithoutLabelError)
                {
                    int index = alIdAttributeInputElement.IndexOf(id);
                    if (index >= 0 && index < alNodeInputElement.Count)
                    {
                        HtmlNode node = alNodeInputElement[index] as HtmlNode;
                        switch (node.Name.ToLower())
                        {
                            case "input":
                                AddAccessibilityError(inputElementMissingAssociatedLabel, node.Name, node.Line, node.LinePosition);
                                break;
                            case "textarea":
                                AddAccessibilityError(textareaElementMissingAssociatedLabel, node.Name, node.Line, node.LinePosition);
                                break;
                            case "select":
                                AddAccessibilityError(selectElementMissingAssociatedLabel, node.Name, node.Line, node.LinePosition);
                                break;
                            default:
                                AddAccessibilityError(inputElementMissingAssociatedLabel, node.Name, node.Line, node.LinePosition);
                                break;
                        }
                        
                    }
                }
            }
        }

        //public void ConvertHtml(string html)
        //{
        //    HtmlDocument doc = new HtmlDocument();
        //    doc.LoadHtml(html);

        //    ConvertTo(doc.DocumentNode);
        //}

        /// <summary>
        /// Searches through the child nodes of the node passed in
        /// </summary>
        /// <param name="node"></param>
        private void ConvertContentTo(HtmlNode node)
        {
            foreach (HtmlNode subnode in node.ChildNodes)
            {
                ConvertTo(subnode);
            }
        }

        /// <summary>
        /// Examines the node passed in.
        /// </summary>
        /// <param name="node"></param>
        public void ConvertTo(HtmlNode node)
        {
            //string html;
            switch (node.NodeType)
            {
                case HtmlNodeType.Comment:
                    break;

                case HtmlNodeType.Document:
                    if(node.InnerText.ToUpper().Contains("!DOCTYPE"))
                        hasDoctypeDeclaration = true;
                    ConvertContentTo(node);
                    break;

                case HtmlNodeType.Text:
                   
                    //// get text
                    //html = ((HtmlTextNode)node).Text;

                    //// is it in fact a special closing node output as text?
                    //if (HtmlNode.IsOverlappedClosingElement(html))
                    //    break;

                    break;

                case HtmlNodeType.Element:
                    if (bCheckForID && !nodesThatDoNotNeedID.Contains(node.Name.ToLower()))
                        CheckForNonEmptyAttribute(node, "id", elementHasNoID);

                    CheckForKeyBoardHandler(node);
                    SearchForDeprecatedAttributes(node);
                    switch (node.Name.ToLower())
                    {
                        case "img":
                            CheckImageForAltAttribute(node);
                            CheckImgHasValidUsemapAttribute(node);
                            CheckForDeprecatedAttributes(node, "hspace", "vspace", "border");
                            CheckForDLinkIfLongdesc(node);
                            break;
                        case "html":
                            CheckLanguageAttribute(node);
                            break;
                        case "script":
                            if (node.ParentNode.Name.ToLower() == "body")
                                scriptFound = true;
                            break;
                        case "noscript":
                            noscriptFound = true;
                            break;
                        case "area":
                            CheckForNonEmptyAttribute(node, "alt", areaElementMissingAltError);
                            CheckForTabIndex(node);
                            CheckForNonEmptyAttribute(node, "accesskey", noKeyboardAccessToObjectOrLink);
                            CheckIfAnchorHasJavascriptHrefAttribute(node);
                            break;
                        case "a":
                            CheckThatAnchorContainsText(node);
                            CheckIfAnchorOpensNewWindow(node);
                            CheckIfAnchorHasMultimediaHrefAttribute(node);
                            CheckIfAnchorHasJavascriptHrefAttribute(node);
                            CheckForTabIndex(node);
                            CheckForNonEmptyAttribute(node, "accesskey", noKeyboardAccessToObjectOrLink);
                            break;
                        case "input":
                            CheckThatInputContainsLabel(node);
                            CheckForTabIndex(node);
                            CheckForNonEmptyAttribute(node, "accesskey", noKeyboardAccessToObjectOrLink);
                            string type = GetValueOfAttribute(node, "type");
                            if (type == "image")
                                CheckForNonEmptyAttribute(node, "alt", imageMissingAltText); //could also have title attribute?
                            if (type == "radio")
                                CheckForFieldsetParent(node);
                            break;
                        case "object":
                            CheckForNonEmptyAttribute(node, "title", missingTitleAttribute);
                            CheckThatObjectHasTextEquivalent(node);
                            CheckForTabIndex(node);
                            CheckForNonEmptyAttribute(node, "accesskey", noKeyboardAccessToObjectOrLink);
                            CheckForDeprecatedAttributes(node, "hspace", "vspace", "border");
                            break;
                        case "head":
                            CheckHeadNodeForTitleChild(node);
                            break;
                        case "textarea":
                            CheckThatTextareaContainsLabel(node);
                            CheckForTabIndex(node);
                            CheckForNonEmptyAttribute(node, "accesskey", noKeyboardAccessToObjectOrLink);
                            break;
                        case "frame":
                            CheckForNonEmptyAttribute(node, "title", frameMissingTitleAttribute);
                            CheckFrameForNoframesSection(node); // perhaps it doesn't have to have both a noframe and src
                            CheckFrameForSourceAttribute(node);
                            CheckFrameForTargetAttributeBlank(node);
                            break;
                        case "iframe":
                            CheckForNonEmptyAttribute(node, "title", frameMissingTitleAttribute);
                            break;
                        case "h1":
                            hasHeadingTag = true;
                            numH1Tags++;
                            break;
                        case "font":
                        case "basefont":
                            AddAccessibilityError(fontUsed, node.Name, node.Line, node.LinePosition);
                            break;
                        case "marquee":
                            AddAccessibilityError(marqueeElementUsed, node.Name, node.Line, node.LinePosition);
                            break;
                        case "body":
                            CheckIfRelyingOnASpecificColor(node);
                            CheckForDeprecatedAttributes(node, "bgcolor", "text", "link", "alink", "vlink"); 
                            break;
                        case "blink":
                            AddAccessibilityError(blinkElementUsed, node.Name, node.Line, node.LinePosition);
                            break;
                        case "meta":
                            CheckIfMetaAutoRefreshingPage(node);
                            CheckIfMetaRedirectingPage(node);
                            break;
                        case "dir":
                        case "applet":
                        case "isindex":
                        case "center":
                        case "strike":
                        case "s":
                        case "u":
                            AddAccessibilityError(doNotUseDeprecatedElements, node.Name, node.Line, node.LinePosition, "The document contains the deprecated element: " + node.Name);
                            break;
                        case "select":
                            CheckForRequiredOptGroup(node);
                            CheckForTabIndex(node);
                            CheckThatSelectContainsLabel(node);
                            CheckThatSelectCausesAnExtremeChangeInContext(node);
                            break;
                        //case "option":
                        //    break;
                        case "b":
                        case "i":
                            AddAccessibilityError(usingBorIelements, node.Name, node.Line, node.LinePosition);
                            break;
                        case "th":
                            CheckForTableHeaderAbbreviation(node);
                            CheckForDeprecatedAttributes(node, "nowrap", "width");
                            break;
                        case "button":
                            CheckForTabIndex(node);
                            CheckForNonEmptyAttribute(node, "accesskey", noKeyboardAccessToObjectOrLink);
                            break;
                        case "td":
                            CheckForDeprecatedAttributes(node, "nowrap", "bgcolor", "width");
                            break;
                        case "tr":
                            CheckForDeprecatedAttributes(node, "bgcolor");
                            break;
                        case "table":
                            CheckForDeprecatedAttributes(node, "bgcolor");
                            ShowTableWarnings(node);
                            break;
                        case "hr":
                            CheckForDeprecatedAttributes(node, "size", "noshade", "width");
                            break;
                        case "ul":
                            CheckForDeprecatedAttributes(node, "compact", "type");
                            break;
                        case "ol":
                            CheckForDeprecatedAttributes(node, "compact", "type", "start");
                            break;
                        case "li":
                            CheckForDeprecatedAttributes(node, "type", "value");
                            break;
                        case "br":
                            CheckForDeprecatedAttributes(node, "clear");
                            if (node.NextSibling != null && node.NextSibling.Name.ToLower() == "br")
                                AddAccessibilityError(useParagraphsInsteadOfBreaks, node.Name, node.Line, node.LinePosition);
                            break;
                        case "dl":
                        case "menu":
                            CheckForDeprecatedAttributes(node, "compact");
                            break;
                        case "p":
                            CheckIfpElementMisused(node);
                            break;
                        case "embed":
                            embedFound = true;
                            break;
                        case "noembed":
                            noembedFound = true;
                            break;
                        case "label":
                            CheckForNonEmptyAttribute(node, "accesskey", noKeyboardAccessToObjectOrLink);
                            string forAttribute = GetValueOfAttribute(node, "for");
                            if (forAttribute != null)
                                alForAttributesInLabel.Add(forAttribute);
                            break;
                        case "legend":
                            CheckForNonEmptyAttribute(node, "accesskey", noKeyboardAccessToObjectOrLink);
                            break;
                        case "link":
                            CheckForNonEmptyAttribute(node, "rel", linkElementMissingRelAndHrefAttributes);
                            CheckForNonEmptyAttribute(node, "href", linkElementMissingRelAndHrefAttributes);
                            break;
                        case "span":
                            string onclickAttribute = GetValueOfAttribute(node, "onclick");
                            if (onclickAttribute != null && onclickAttribute.ToLower() == "navigate()")
                                AddAccessibilityError(useHrefInsteadOfSpanOnclick, node.Name, node.Line, node.LinePosition);
                            break;
                    }

                    if (node.HasChildNodes)
                    {
                        ConvertContentTo(node);
                    }
                    break;
            }
        }

        /// <summary>
        /// Checks if meta is being used to refresh a page
        /// </summary>
        /// <param name="node"></param>
        void CheckIfMetaAutoRefreshingPage(HtmlNode node)
        {
            string attributeValue = GetValueOfAttribute(node, "http-equiv");
            string contentValue = GetValueOfAttribute(node, "content");
            int num;
            if (attributeValue != null && attributeValue.ToLower() == "refresh" && contentValue != null && int.TryParse(contentValue, out num) && num > 0)
                AddAccessibilityError(usingMetaToRefreshAPage, node.Name, node.Line, node.LinePosition);
        }
        /// <summary>
        /// Checks if meta if redirects a page
        /// </summary>
        /// <param name="node"></param>
        void CheckIfMetaRedirectingPage(HtmlNode node)
        {
            string attributeValue = GetValueOfAttribute(node, "http-equiv");
            string contentValue = GetValueOfAttribute(node, "content");
            if (attributeValue != null && attributeValue.ToLower() == "refresh" && contentValue != null && contentValue.ToLower().StartsWith("http://"))
                AddAccessibilityError(autoRedirectUsed, node.Name, node.Line, node.LinePosition);
        }
        /// <summary>
        /// Checking if node has a particular attribute value and it's non-empty
        /// </summary>
        /// <param name="node"></param>
        /// <param name="attribute"></param>
        /// <param name="error"></param>
        void CheckForNonEmptyAttribute(HtmlNode node, string attribute, string error)
        {
            bool thisAttributeIsNonempty = false;
            string attributeValue = GetValueOfAttribute(node, attribute);
            if (attributeValue != null)
            {
                if (attributeValue.Length > 0)
                    thisAttributeIsNonempty = true;
            }
            if (!thisAttributeIsNonempty)
                AddAccessibilityError(error, node.Name, node.Line, node.LinePosition);
        }
        /// <summary>
        /// Check if node contains deprecated attributes
        /// </summary>
        /// <param name="node"></param>
        void CheckForDeprecatedAttributes(HtmlNode node, params string [] attributes)
        {
            foreach (string attribute in attributes)
            {

                string attributeValue = GetValueOfAttribute(node, attribute);
                if (attributeValue != null)
                {
                    string moreDescription = "The document contains the element: " + node.Name + " with the deprecated attribute: " + attribute;
                    AddAccessibilityError(doNotUseDeprecatedAttributes, node.Name, node.Line, node.LinePosition, moreDescription);
                }
            }
        }
        /// <summary>
        /// Check if all the text contained by the p element is marked with presentational elements. 
        /// Presentational elements include the elements b, i, u, strong, span, font, and em.
        /// </summary>
        /// <param name="node"></param>
        void CheckIfpElementMisused(HtmlNode node)
        {
            foreach(HtmlNode childNode in node.ChildNodes)
            {
                string childName = childNode.Name.ToLower();
                if (childName == "b" || childName == "i" || childName == "u" || childName == "strong" || childName == "span" || childName == "font" || childName == "em")
                {
                    AddAccessibilityError(pElementMayBeMisused, node.Name, node.Line, node.LinePosition);
                    return;
                }
            }
        }
        /// <summary>
        /// Check that frame has a source attribute and value is an html file
        /// </summary>
        /// <param name="node"></param>
        void CheckFrameForSourceAttribute(HtmlNode node)
        {
            bool nodeHasSourceAttribute = false;
            string sourceAttribute = GetValueOfAttribute(node, "source");
            if (sourceAttribute != null)
            {
                if (sourceAttribute.Length > 0)
                {
                    // check that extension is html
                    int index = sourceAttribute.IndexOf('.');
                    if (index > 0)
                    {
                        string extension = sourceAttribute.Substring(index + 1);
                        if(extension.ToLower().StartsWith("htm"))
                            nodeHasSourceAttribute = true;
                    }
                }
            }
            if (!nodeHasSourceAttribute)
                AddAccessibilityError(frameMissingSrc, node.Name, node.Line, node.LinePosition);
        }
        /// <summary>
        /// Content developers should avoid specifying a new window as the target of a frame with target=_blank
        /// </summary>
        /// <param name="node"></param>
        void CheckFrameForTargetAttributeBlank(HtmlNode node)
        {
            string targetAttribute = GetValueOfAttribute(node, "target");
            if(targetAttribute == "_blank")
                AddAccessibilityError(usingFrameWithTarget_blank, node.Name, node.Line, node.LinePosition);
        }
        /// <summary>
        /// th element content must be less than 20 characters (English) 
        /// if th element does not contain abbr attribute. 
        /// </summary>
        /// <param name="node"></param>
        void CheckForTableHeaderAbbreviation(HtmlNode node)
        {
            if (node.InnerText.Length >= 20)
            {
                string abbrAttribute = GetValueOfAttribute(node, "abbr");
                if(abbrAttribute == null)
                    AddAccessibilityError(longTableHeaderLabelMissingTerseSubstitute, node.Name, node.Line, node.LinePosition);
            }
        }
        /// <summary>
        /// form element content must contain both fieldset and legend elements if there are related radio buttons. 
        /// </summary>
        /// <param name="node"></param>
        void CheckForFieldsetParent(HtmlNode node)
        {
            bool radioButtonContainedInFieldSet = false;
            HtmlNode parentNode = node.ParentNode;
            while (parentNode != null)
            {
                if (parentNode.Name.ToLower() == "fieldset")
                {
                    radioButtonContainedInFieldSet = true;
                    bool hasLegendNode = false;
                    foreach (HtmlNode siblingNode in parentNode.ChildNodes)
                    {
                        if (siblingNode.Name.ToLower() == "legend")
                            hasLegendNode = true;
                    }
                    if (!hasLegendNode)
                        AddAccessibilityError(missingFieldsetAndLegendToGroupMultipleRadioButtons, node.Name, node.Line, node.LinePosition);
                    break;
                }
                parentNode = parentNode.ParentNode;
            }
            if(!radioButtonContainedInFieldSet)
                AddAccessibilityError(missingFieldsetAndLegendToGroupMultipleRadioButtons, node.Name, node.Line, node.LinePosition);
        }
        /// <summary>
        /// select element content that contains 4 or more option elements must contain at least 2 optgroup elements. 
        /// </summary>
        /// <param name="node"></param>
        void CheckForRequiredOptGroup(HtmlNode node)
        {
            int numOptionElements = 0;
            foreach (HtmlNode childNode in node.ChildNodes)
            {
                if (childNode.Name.ToLower() == "option")
                    numOptionElements++;
            }
            if(numOptionElements > 3)
                AddAccessibilityError(optgroupMayBeRequiredForLargeNumberOptions, node.Name, node.Line, node.LinePosition);
        }
        /// Displaying new windows without warning is very confusing to non-sighted users because some screen readers do not give any 
        /// indication when new windows appear. If you cannot avoid displaying a new window, insert a warning like the following: "This link will open in a new window".
        /// </summary>
        /// <param name="node"></param>
        void CheckIfAnchorOpensNewWindow(HtmlNode node)
        {
            string hrefAttValue = GetValueOfAttribute(node, "href");
            if (hrefAttValue != null)
            {
                if(hrefAttValue != "_self" && hrefAttValue != "_top" && hrefAttValue != "_parent")
                    AddAccessibilityError(anchorOpensNewWindow, node.Name, node.Line, node.LinePosition);
            }
        }
        /// <summary>
        /// This error will be generated for each a (anchor) element that contains an 
        /// href attribute value ending with (case insensitive): .wmv, .mpg, .mov, .ram, .aif and is missing alternative text.
        /// </summary>
        /// <param name="node"></param>
        void CheckIfAnchorHasMultimediaHrefAttribute(HtmlNode node)
        {
            string hrefAttValue = GetValueOfAttribute(node, "href");
            if (hrefAttValue != null)
            {
                if (hrefAttValue.ToLower().EndsWith("wmv") || hrefAttValue.ToLower().EndsWith("mpg") || hrefAttValue.ToLower().EndsWith("mov") || hrefAttValue.ToLower().EndsWith("ram") || hrefAttValue.ToLower().EndsWith("aif"))
                {
                    // The link to the text alternative must be immediately before or immediately after the link to the multimedia file.
                    if ((node.PreviousSibling != null && node.PreviousSibling.Name != "a") && (node.NextSibling != null && node.NextSibling.Name != "a"))
                        AddAccessibilityError(linkToMultimediaMissingTextAlternative, node.Name, node.Line, node.LinePosition);
                }
            }
        }
        void SearchForDeprecatedAttributes(HtmlNode node)
        {
            string alignAttValue = GetValueOfAttribute(node, "align");
            if (alignAttValue != null && node.Name != "COL" && node.Name != "COLGROUP" && node.Name != "TBODY" && node.Name != "TD" && node.Name != "TFOOT" && node.Name != "TH" && node.Name != "THEAD" && node.Name != "TR")
            {
                string moreDescription = "The document contains the element: " + node.Name + " with the deprecated attribute: align";
                AddAccessibilityError(doNotUseDeprecatedElements, node.Name, node.Line, node.LinePosition, moreDescription);
            }
        }
        /// <summary>
        /// Check if anchor has javascript href attribute
        /// </summary>
        /// <param name="node"></param>
        void CheckIfAnchorHasJavascriptHrefAttribute(HtmlNode node)
        {
            string hrefAttValue = GetValueOfAttribute(node, "href");
            if (hrefAttValue.ToLower().StartsWith("javascript"))
            {
                AddAccessibilityError(linkUsesJavascript, node.Name, node.Line, node.LinePosition);
            }
        }
        void CheckIfRelyingOnASpecificColor(HtmlNode node)
        {
            if (GetValueOfAttribute(node, "bgcolor") != null)
                AddAccessibilityError(textColorNotSet, node.Name, node.Line, node.LinePosition);

        }
        /// <summary>
        /// Check Frame For Noframes Section
        /// </summary>
        /// <param name="node"></param>
        void CheckFrameForNoframesSection(HtmlNode node)
        {
            bool noframeFound = false;
            HtmlNode parentNode = node.ParentNode;
            // is frame always a child of frameset?
            if (parentNode.Name.ToLower() == "frameset")
            {
                foreach (HtmlNode childNode in parentNode.ChildNodes)
                {
                    if (childNode.Name.ToLower() == "noframes")
                    {
                        noframeFound = true;
                        break;
                    }
                }
            }
            if (!noframeFound)
                AddAccessibilityError(framesetMissingNoframesSection, node.Name, node.Line, node.LinePosition);
        }
        /// <summary>
        /// Check head node for title tag among its children
        /// </summary>
        /// <param name="node"></param>
        void CheckHeadNodeForTitleChild(HtmlNode node)
        {
            bool nodeHasTitleChild = false;
            foreach (HtmlNode childNode in node.ChildNodes)
            {
                if (childNode.Name.ToLower() == "title")
                {
                    if (childNode.InnerText.Length > 0)
                        nodeHasTitleChild = true;
                    break;
                }
            }
            if (!nodeHasTitleChild)
                AddAccessibilityError(documentMissingTitleElement, node.Name, node.Line, node.LinePosition);
        }
        void CheckThatObjectHasTextEquivalent(HtmlNode node)
        {
            bool noTextEquivalent = true;
            for (int i = 0; i < node.ChildNodes.Count; i++)
            {
                if (node.ChildNodes[i].Name.ToLower() == "href")
                    noTextEquivalent = false;
                else if (node.ChildNodes[i].Name.ToLower() == "img")
                    noTextEquivalent = false;
            }
            if (node.InnerText.Length > 0)
            {
                string newString = node.InnerText.Replace("\n", "").Replace("\r", "").Replace("\t", "");
                if(newString.Length > 0)
                    noTextEquivalent = false;
            }

            if(noTextEquivalent)
                AddAccessibilityError(objectMissingTextEquivalent, node.Name, node.Line, node.LinePosition);
        }
        /// <summary>
        /// a logical tab order through links, form controls, and objects. 
        /// </summary>
        /// <param name="node"></param>
        void CheckForTabIndex(HtmlNode node)
        {
            string tabIndex = GetValueOfAttribute(node, "tabindex");
            if(tabIndex == null || tabIndex.Length == 0)
                AddAccessibilityError(noTabOrder, node.Name, node.Line, node.LinePosition);
        }
        /// <summary>
        /// Check that input tag contains an associated label
        /// The input element must have an explicitly associated label using one or more of the following methods.
        /// A.The input element has an id attribute value that matches the for attribute value of a label element.
        /// B.The input element has a title attribute.
        /// C.The input element is contained by a label element.
        /// </summary>
        /// <param name="node"></param>
        void CheckThatInputContainsLabel(HtmlNode node)
        {
            bool noMissingLabelError = true;
            string type = GetValueOfAttribute(node, "type");
            if (type != null)
            {  
                if (type == "text" || type == "radio" || type == "password" || type == "checkbox" || type == "file")
                {
                    noMissingLabelError = false;
                    string id = GetValueOfAttribute(node, "id");
                    string title = GetValueOfAttribute(node, "title");
                    string parent = node.ParentNode.Name;
                    if (title != null)
                    {
                        if (title.Length > 0)
                            noMissingLabelError = true;
                    }
                    if (parent.ToLower() == "label")
                        noMissingLabelError = true;
                    if (noMissingLabelError)
                    {
                        if (id != null)
                        {
                            if (id.Length > 0)
                            {
                                //check if this matches the for attribute value of a label
                                alIdAttributeInputElement.Add(id);
                                alNodeInputElement.Add(node);
                            }
                        }
                    }
                }
            }
            if (!noMissingLabelError)
                AddAccessibilityError(inputElementMissingAssociatedLabel, node.Name, node.Line, node.LinePosition);
        }

        /// <summary>
        /// Check that textarea tag contains an associated label
        /// </summary>
        /// <param name="node"></param>
        void CheckThatTextareaContainsLabel(HtmlNode node)
        {
            bool noMissingLabelError = false;

            string id = GetValueOfAttribute(node, "id");
            string title = GetValueOfAttribute(node, "title");
            string parent = node.ParentNode.Name;
            if (title != null)
            {
                if (title.Length > 0)
                    noMissingLabelError = true;
            }
            if (parent.ToLower() == "label")
                noMissingLabelError = true;

            if (!noMissingLabelError)
                AddAccessibilityError(textareaElementMissingAssociatedLabel, node.Name, node.Line, node.LinePosition);
            else
            {
                if (id != null)
                {
                    if (id.Length > 0)
                    {
                        //check if this matches the for attribute value of a label
                        alIdAttributeInputElement.Add(id);
                        alNodeInputElement.Add(node);
                    }
                }
            }
        }
        /// <summary>
        /// Check that select tag contains an associated label
        /// </summary>
        /// <param name="node"></param>
        void CheckThatSelectContainsLabel(HtmlNode node)
        {
            bool noMissingLabelError = false;

            string id = GetValueOfAttribute(node, "id");
            string title = GetValueOfAttribute(node, "title");
            string parent = node.ParentNode.Name;
            if (title != null)
            {
                if (title.Length > 0)
                    noMissingLabelError = true;
            }
            if (parent.ToLower() == "label")
                noMissingLabelError = true;

            if (!noMissingLabelError)
                AddAccessibilityError(selectElementMissingAssociatedLabel, node.Name, node.Line, node.LinePosition);
            else
            {
                if (id != null)
                {
                    if (id.Length > 0)
                    {
                        //check if this matches the for attribute value of a label
                        alIdAttributeInputElement.Add(id);
                        alNodeInputElement.Add(node);
                    }
                }
            }
        }
        /// <summary>
        /// All select elements should not cause an extreme change in context. 
        /// Examine the onchange handler for any action that will cause the page 
        /// to reload or cause an extreme change of context. Actions that will 
        /// cause the page to reload or cause an extreme change of context may 
        /// be variations of one of the following JavaScript statements: 
        /// form.submit(), window.location.href = uri, elementElsewhereOnThePage.focus()
        /// </summary>
        /// <param name="node"></param>
        void CheckThatSelectCausesAnExtremeChangeInContext(HtmlNode node)
        {
            string onChangeAttribute = GetValueOfAttribute(node, "onchange");
            if (onChangeAttribute != null && (onChangeAttribute.ToLower().Contains("form.submit") || onChangeAttribute.ToLower().Contains("window.location.href") || onChangeAttribute.ToLower().Contains("elementelsewhereonthepage.focus")))
                AddAccessibilityError(selectElementsCausesAnExtremeChangeInContext, node.Name, node.Line, node.LinePosition);
        }
        /// <summary>
        /// a (anchor) element must contain text. The text may occur in the anchor text 
        /// or in the title attribute of the anchor or in the Alt text of an image used within the anchor.
        /// </summary>
        /// <param name="node"></param>
        void CheckThatAnchorContainsText(HtmlNode node)
        {
            bool anchorContainsText = false;
            if (node.InnerText.Length == 0)
            {
                string aTitleAttribute = GetValueOfAttribute(node, "title");
                if (aTitleAttribute != null)
                {
                    if(aTitleAttribute.Length > 0)
                        anchorContainsText = true;
                }
                foreach (HtmlNode childNode in node.ChildNodes)
                {
                    string imgAltAttribute = GetValueOfAttribute(childNode, "alt");
                    if (childNode.Name == "img" && imgAltAttribute != null)
                    { 
                        if(imgAltAttribute.Length > 0)
                            anchorContainsText = true;
                        break;
                    }
                }
            }
            else
                anchorContainsText = true;

            if(!anchorContainsText)
                AddAccessibilityError(anchorContainsNoText, node.Name, node.Line, node.LinePosition);
        }

        /// <summary>
        /// Checks the alt attribute of an img node
        /// </summary>
        /// <param name="node"></param>
        void CheckImageForAltAttribute(HtmlNode node)
        {
            int lineNumber = node.Line;
            int linePosition = node.LinePosition;
            string currentNode = node.Name;
            string altAttributeValue = GetValueOfAttribute(node, "alt");
            if (altAttributeValue != null)
            {
                string srcAttributeValue = GetValueOfAttribute(node, "src");
                // Check each img element and compare its alt attribute value to its src attribute value. They should not be the same.
                if (altAttributeValue == srcAttributeValue)
                {
                    AddAccessibilityError(imgElementAltSameAsSrc, currentNode, lineNumber, linePosition);
                }
                // If the Alt text is greater than 100 characters (English) then it must be shortened or the user must confirm that it is the shortest Alt text possible.
                else if (altAttributeValue.Length > largeAltTextLength)
                {
                    AddAccessibilityError(imgElementAltAttributeTooLong, currentNode, lineNumber, linePosition);
                }
                //img element cannot have alt attribute value of null or whitespace if the img element is contained by an A element and there is no other link text. 
                else if ((altAttributeValue == "" || altAttributeValue == "&nbsp;" || altAttributeValue == " ") && node.ParentNode.Name.ToLower() == "a")
                {
                    AddAccessibilityError(imgElementContainedInATagHasAltAttributeEmpty, currentNode, lineNumber, linePosition);
                }
                // img element cannot have alt attribute value of null ("") if WIDTH and HEIGHT attribute values are both greater than 25. 
                else if ((altAttributeValue == "" || altAttributeValue == "&nbsp;" || altAttributeValue == " ") && GetValueOfAttribute(node, "width") != null && GetValueOfAttribute(node, "height") != null)
                {
                    int width = Convert.ToInt32(GetValueOfAttribute(node, "width"));
                    int height = Convert.ToInt32(GetValueOfAttribute(node, "height"));
                    if (height >= largeImgSize && width >= largeImgSize)
                        AddAccessibilityError(largeImgElementHasAltAttributeEmpty, currentNode, lineNumber, linePosition);
                    // Otherwise warn if the alt attribute value is empty
                    else
                        AddAccessibilityError(imgElementHasAltAttributeEmpty, currentNode, lineNumber, linePosition);
                }
                // Images used as bullets missing alternative text
                else if (altAttributeValue == "" && node.ParentNode.Name.ToLower() == "dd")
                {
                    AddAccessibilityError(imgUsedAsBulletHasAltAttributeEmpty, currentNode, lineNumber, linePosition);
                }
                // Otherwise warn if the alt attribute value is empty
                else if (altAttributeValue == "")
                {
                    AddAccessibilityError(imgElementHasAltAttributeEmpty, currentNode, lineNumber, linePosition);
                }
            }
            else
            {
                AddAccessibilityError(imgElementMissingAltError, currentNode, lineNumber, linePosition);
            }
        }

        /// <summary>
        /// All img elements with an ismap attribute should have a valid usemap attribute.
        /// </summary>
        /// <param name="node"></param>
        void CheckImgHasValidUsemapAttribute(HtmlNode node)
        {
            if (GetValueOfAttribute(node, "ismap") != null && GetValueOfAttribute(node, "usemap") == null)
                AddAccessibilityError(serverSideImageMapMissingClientsideImageMap, node.Name, node.Line, node.LinePosition);
        }
        /// <summary>
        /// All img elements that have a longdesc attribute also have an associated d-link.
        /// </summary>
        /// <param name="node"></param>
        void CheckForDLinkIfLongdesc(HtmlNode node)
        {
            if (GetValueOfAttribute(node, "longdesc") != null)
            {
                HtmlNode nextNode = node.NextSibling;
                if(nextNode.Name.ToLower() != "a" || !nextNode.InnerText.Contains("[d]"))
                    AddAccessibilityError(imgWithLongdescHasNoDLink, node.Name, node.Line, node.LinePosition);
            }
        }
        /// <summary>
        /// Adds an accessibility error to the array list
        /// </summary>
        /// <param name="error"></param>
        /// <param name="lineNumber"></param>
        void AddAccessibilityError(string error, string currentNode, int lineNumber, int column)
        {
            string guideline = string.Empty;
            string description = string.Empty;
            int priority = 0;
            int level = 2;
            string sLineNumber = lineNumber == -1 ? "" : lineNumber.ToString();
            string sColumn = column == -1 ? "" : column.ToString();
            currentNode = currentNode.Length > 0 ? "&lt;" + currentNode + "&gt;" : currentNode;
            accessXMLErrorsDocument.GetAccessibilityError(error, ref guideline, ref description, ref priority, ref level);
            alAccessibilityErrors.Add(new AccessibilityError(currentUrl, currentNode, sLineNumber, sColumn, error, guideline, description, priority, level, currentGroup));
        }

        /// <summary>
        /// Adds an accessibility error to the array list
        /// </summary>
        /// <param name="error"></param>
        /// <param name="lineNumber"></param>
        void AddAccessibilityError(string error, string currentNode, int lineNumber, int column, string moreDescription)
        {
            string guideline = string.Empty;
            string description = string.Empty;
            int priority = 0;
            int level = 2;
            string sLineNumber = lineNumber == -1 ? "" : lineNumber.ToString();
            string sColumn = column == -1 ? "" : column.ToString();
            currentNode = currentNode.Length > 0 ? "&lt;" + currentNode + "&gt;" : currentNode;
            accessXMLErrorsDocument.GetAccessibilityError(error, ref guideline, ref description, ref priority, ref level);
            alAccessibilityErrors.Add(new AccessibilityError(currentUrl, currentNode, sLineNumber, sColumn, error, guideline, description + " " + moreDescription, priority, level, currentGroup));
        }

        /// <summary>
        /// Checks that mouse events have corresponding keyboard handlers.
        /// </summary>
        /// <param name="node"></param>
        void CheckForKeyBoardHandler(HtmlNode node)
        {
            int lineNumber = node.Line;
            int linePosition = node.LinePosition;
            string currentNode = node.Name;

            if (GetValueOfAttribute(node, "ONCLICK") != null)
            {
                if (GetValueOfAttribute(node, "onkeypress") == null)
                    AddAccessibilityError(onclickError, currentNode, lineNumber, linePosition);
            }
            if (GetValueOfAttribute(node, "ondblclick") != null)
            {
                AddAccessibilityError(ondblclickError, currentNode, lineNumber, linePosition);
            }
            if (GetValueOfAttribute(node, "onmousedown") != null)
            {
                if(GetValueOfAttribute(node, "onkeydown") == null)
                    AddAccessibilityError(onmousedownError, currentNode, lineNumber, linePosition);
            }
            if (GetValueOfAttribute(node, "onmouseup") != null)
            {
                if (GetValueOfAttribute(node, "onkeyup") == null)
                    AddAccessibilityError(onmouseupError, currentNode, lineNumber, linePosition);
            }
            if (GetValueOfAttribute(node, "onmouseover") != null)
            {
                if (GetValueOfAttribute(node, "onfocus") == null)
                    AddAccessibilityError(onmouseoverError, currentNode, lineNumber, linePosition);
            }
            if (GetValueOfAttribute(node, "onmouseout") != null)
            {
                if (GetValueOfAttribute(node, "onblur") == null)
                    AddAccessibilityError(onmouseoutError, currentNode, lineNumber, linePosition);
            }
        }
        
        /// <summary>
        /// Find any possible policy warnings for a table
        /// </summary>
        /// <param name="node"></param>
        void ShowTableWarnings(HtmlNode node)
        {
            bool bDataTable = false;
            bool hasCaption = false;
            bool hasSummaryAttribute = false;

            int lineNumber = node.Line;
            int linePosition = node.LinePosition;
            string currentNode = node.Name;
            GetTableInformation(node, ref bDataTable, ref hasCaption, ref hasSummaryAttribute);
            if(!bDataTable)
            {
                AddAccessibilityError(warningShouldThisBeALayoutTable, currentNode, lineNumber, linePosition);
                if(hasSummaryAttribute)
                    AddAccessibilityError(warningLayoutTableShouldNotContainSummary, currentNode, lineNumber, linePosition);
                if(hasCaption)
                    AddAccessibilityError(warningLayoutTableContainsACaption, currentNode, lineNumber, linePosition);
                
            }
            if (bDataTable)
            {
                AddAccessibilityError(warningProvideMarkupForDataTables, currentNode, lineNumber, linePosition);
                AddAccessibilityError(warningProvideAbbreviationsForHeaderLabels, currentNode, lineNumber, linePosition);
                AddAccessibilityError(dataTableShouldContainsIdAndHeadersAttributes, currentNode, lineNumber, linePosition);
                if (!hasSummaryAttribute)
                    AddAccessibilityError(warningProvideSummariesForDataTables, currentNode, lineNumber, linePosition);
                if(!hasCaption)
                    AddAccessibilityError(warningDataTableShouldContainsACaption, currentNode, lineNumber, linePosition);
            }
        }
        /// <summary>
        /// Determines if this is a data table by finding a th element
        /// Also determines if this table has a caption and/or summary
        /// </summary>
        /// <param name="node"></param>
        /// <returns></returns>
        void GetTableInformation(HtmlNode node, ref bool bDataTable, ref bool hasCaption, ref bool hasSummaryAttribute)
        {
            bDataTable = false;
            hasCaption = false;
            hasSummaryAttribute = false;
            string summaryAttribute = GetValueOfAttribute(node, "summary");
            if (summaryAttribute != null && summaryAttribute != "")
                hasSummaryAttribute = true;
            foreach (HtmlNode childNode in node.ChildNodes)
            {
                HtmlNode firstChildNodeOfChildNode = childNode.FirstChild;
                if (childNode.Name.ToLower() == "tr")
                {
                    foreach (HtmlNode cellNode in childNode.ChildNodes)
                    {
                        if (cellNode.Name.ToLower() == "th")
                        {
                            bDataTable = true;
                            break;
                        }
                    }
                }
                else if (childNode.Name.ToLower() == "thead")
                {
                    if (firstChildNodeOfChildNode != null && firstChildNodeOfChildNode.Name.ToLower() == "tr")
                    {
                        foreach (HtmlNode cellNode in firstChildNodeOfChildNode.ChildNodes)
                        {
                            if (cellNode.Name.ToLower() == "th")
                            {
                                bDataTable = true;
                                break;
                            }
                        }
                    }
                }
                else if (childNode.Name.ToLower() == "caption")
                    hasCaption = true;
            }
        }
        /// <summary>
        /// Checks that an html node has a lang attribute
        /// </summary>
        /// <param name="node"></param>
        void CheckLanguageAttribute(HtmlNode node)
        {
            string attributeValue = GetValueOfAttribute(node, "lang");
            if (attributeValue == null) // note: I'm not checking if it's an actual language code, eg, "en"
            {
                AddAccessibilityError(languageError, node.Name, node.Line, node.LinePosition);
            }
        }
        /// <summary>
        /// Gets the value of the attribute
        /// </summary>
        /// <param name="node"></param>
        /// <param name="attributeName"></param>
        /// <returns></returns>
        string GetValueOfAttribute(HtmlNode node, string attributeName)
        {
            if (node.Attributes[attributeName] != null)
                return node.Attributes[attributeName].Value;
            else
                return null;
        }
        /// <summary>
        /// ArrayList of all accessibility errors found
        /// </summary>
        /// <returns></returns>
        public ArrayList GetAccessibilityErrors()
        {
            return alAccessibilityErrors;
        }
    }
    /// <summary>
    /// Class for xml file that stores accessibility errors.
    /// </summary>
    class AccessXMLErrorsDocument
    {
        XmlDocument xDoc;
        string accessibilityErrorsNode;
        public AccessXMLErrorsDocument()
        {
            try
            {
                xDoc = new XmlDocument();
                string accessibilityErrorsFile = ConfigurationManager.AppSettings["accessibilityErrorsFile"].ToString();
                string path = ConfigurationManager.AppSettings["path"].ToString();
                xDoc.Load(path + accessibilityErrorsFile);
                accessibilityErrorsNode = ConfigurationManager.AppSettings["accessibilityErrorsNode"].ToString();
            }
            catch (Exception ex)
            {
                Logging.WriteToLog(ex.Message + "\r\n" + ex.StackTrace, "Log.txt");
            }
        }

        public void GetAccessibilityError(string error, ref string guideline, ref string description, ref int priority, ref int level)
        {
            XmlNodeList accessibilityErrors = xDoc.SelectNodes(accessibilityErrorsNode);

            foreach (XmlNode errorNode in accessibilityErrors)
            {
                if (error == errorNode.Attributes["Error"].Value)
                {
                    description = errorNode.Attributes["Description"].Value;
                    guideline = errorNode.Attributes["Guideline"].Value;
                    priority = Convert.ToInt32(errorNode.Attributes["Priority"].Value);
                    level = Convert.ToInt32(errorNode.Attributes["Level"].Value);
                    break;
                }
            }
        }
    }

    /// <summary>
    /// Class for xml file that stores urls
    /// </summary>
    class AccessXMLUrlsDocument
    {
        XmlDocument xDoc;
        string accessibilityUrlsNode;
        public AccessXMLUrlsDocument()
        {
            try
            {
                xDoc = new XmlDocument();
                string accessibilityUrlsFile = ConfigurationManager.AppSettings["accessibilityUrlsFile"].ToString();
                string path = ConfigurationManager.AppSettings["path"].ToString();
                xDoc.Load(path + accessibilityUrlsFile);
                accessibilityUrlsNode = ConfigurationManager.AppSettings["accessibilityUrlsNode"].ToString();
            }
            catch (Exception ex)
            {
                Logging.WriteToLog(ex.Message + "\r\n" + ex.StackTrace, "Log.txt");
            }
        }

        /// <summary>
        /// Gets all the urls to be tested from xml file
        /// </summary>
        /// <returns></returns>
        public XmlNodeList GetAccessibilityUrls()
        {
            XmlNodeList Urls = xDoc.SelectNodes(accessibilityUrlsNode);
            return Urls;
        }
    }
    /// <summary>
    /// Class for xml file that stores nodes that don't need id
    /// </summary>
    class AccessXMLNodesDocument
    {
        XmlDocument xDoc;
        string nodesWithNoIdsNodes; //root node of NodesWithNoIds xml file
        public AccessXMLNodesDocument()
        {
            try
            {
                string nodesWithNoIdsFile; // xml file that contains the nodes that we won't check for missing id       
                nodesWithNoIdsFile = ConfigurationManager.AppSettings["nodesWithNoIdsFile"].ToString();
                nodesWithNoIdsNodes = ConfigurationManager.AppSettings["nodesWithNoIdsNodes"].ToString();
                xDoc = new XmlDocument();
                string path = ConfigurationManager.AppSettings["path"].ToString();
                xDoc.Load(path + nodesWithNoIdsFile);
            }
            catch (Exception ex)
            {
                Logging.WriteToLog(ex.Message + "\r\n" + ex.StackTrace, "Log.txt");
            }
        }

        /// <summary>
        /// Gets all the urls to be tested from xml file
        /// </summary>
        /// <returns></returns>
        public XmlNodeList GetAccessibilityNodes()
        {
            XmlNodeList nodes = xDoc.SelectNodes(nodesWithNoIdsNodes);
            return nodes;
        }
    }
    /// <summary>
    /// Stores accessibility errors
    /// </summary>
    class AccessibilityError
    {
        string url;
        string node;
        string error;
        string guidelines;
        string description;
        string lineNumber;
        string column;
        int priority;
        int level;
        string group;

        public AccessibilityError(string url, string node, string lineNumber, string column, string error, string guidelines, string description, int priority, int level, string group)
        {
            this.url = url;
            this.lineNumber = lineNumber;
            this.column = column;
            this.node = node;
            this.error = error;
            this.guidelines = guidelines;
            this.description = description;
            this.priority = priority;
            this.level = level;
            this.group = group;
        }
        public string Url
        {
            get { return url; }
        }
        public string Node
        {
            get { return node; }
        }
        public string LineNumber
        {
            get { return lineNumber; }
        }
        public string Column
        {
            get { return column; }
        }
        public string Error
        {
            get { return error; }
        }
        public string Guidelines
        {
            get { return guidelines; }
        }
        public string Description
        {
            get { return description; }
        }
        public int Priority
        {
            get { return priority; }
        }
        public int Level
        {
            get { return level; }
        }
        public string Group
        {
            get { return group; }
        }
    }

    class Logging
    {
        /// <summary>
        /// Writes out exceptions to the log file
        /// </summary>
        /// <param name="logMessage">Message including date</param>
        /// <param name="logFile">Path of the log file</param>
        public static void WriteToLog(String logMessage, string logFile)
        {
            try
            {
                using (StreamWriter stWriter = File.AppendText(logFile))
                {
                    stWriter.Write("\r\nLog Entry : ");
                    stWriter.WriteLine("Date: {0} {1}", DateTime.Now.ToLongTimeString(),
                        DateTime.Now.ToLongDateString());
                    stWriter.WriteLine(logMessage);
                    stWriter.WriteLine("-------------------------------");
                    // Update the underlying file.
                    stWriter.Flush();
                    stWriter.Close();
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine(ex.Message);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\AccessibilityWebSite\AccessibilityWebSite\Default.aspx.designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Test.Common.Utilities.AccessibilityWebSite {
    
    
    public partial class _Default {
        
        /// <summary>
        /// lblTitle control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblTitle;
        
        /// <summary>
        /// lblGuideline control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblGuideline;
        
        /// <summary>
        /// rblGuideline control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.RadioButtonList rblGuideline;
        
        /// <summary>
        /// cblWCAG control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.CheckBoxList cblWCAG;
        
        /// <summary>
        /// cblMicrosoft control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.CheckBoxList cblMicrosoft;
        
        /// <summary>
        /// lblTasks control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblTasks;
        
        /// <summary>
        /// rblFilter control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.RadioButtonList rblFilter;
        
        /// <summary>
        /// tbUrlContains control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox tbUrlContains;
        
        /// <summary>
        /// ddlUrls control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DropDownList ddlUrls;
        
        /// <summary>
        /// lblGroup control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblGroup;
        
        /// <summary>
        /// ddlGroups control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DropDownList ddlGroups;
        
        /// <summary>
        /// ddlGroupEquals control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DropDownList ddlGroupEquals;
        
        /// <summary>
        /// btnDisplay control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnDisplay;
        
        /// <summary>
        /// label_LastWrite control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label label_LastWrite;
        
        /// <summary>
        /// dgErrors control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DataGrid dgErrors;
        
        /// <summary>
        /// btnViewAll control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnViewAll;
        
        /// <summary>
        /// btnExport control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnExport;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\AccessibilityAutomation\AccessibilityAutomation\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("AccessibilityAutomation")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("MSIT")]
//[assembly: AssemblyProduct("AccessibilityAutomation")]
//[assembly: AssemblyCopyright("Copyright © MSIT 2009")]
//[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("c8f49e04-2cbd-4205-9302-366b830f8246")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
//[assembly: AssemblyVersion("1.0.0.0")]
//[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\AccessibilityWebSite\AccessibilityWebSite\Site1.Master.cs ===
﻿using System;
using System.Collections.Generic;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.IO;

namespace Test.Common.Utilities.AccessibilityWebSite
{
    public partial class Site1 : System.Web.UI.MasterPage
    {
        protected void Page_Load(object sender, EventArgs e)
        {

        }
        protected void btnDocumentation_Click(object sender, EventArgs e)
        {
            DownloadFile();
        }
        void DownloadFile()
        {
            string filepath = Paths.GetFullSharedPath() + Paths.GetDocumentation();
            FileInfo file = new FileInfo(filepath);

            if (file.Exists)
            {
                // Clear the content of the response
                Response.ClearContent();

                // Add the file name and attachment, which will force the open/cancel/save dialog to show, to the header
                Response.AddHeader("Content-Disposition", "attachment; filename=" + file.Name);

                // Add the file size into the response header
                Response.AddHeader("Content-Length", file.Length.ToString());

                // Set the ContentType
                Response.ContentType = "application/ms-word";

                // Write the file into the response
                Response.WriteFile(file.FullName);

                // Flush the response
                Response.Flush();

                // End the response
                Response.End();
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\AccessibilityWebSite\AccessibilityWebSite\Urls.aspx.cs ===
﻿using System;
using System.Collections.Generic;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Xml;
using System.Collections;
using System.Data;
using System.IO;
using System.Configuration;

namespace Test.Common.Utilities.AccessibilityWebSite
{
    public partial class Urls : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {
            if (!IsPostBack)
            {
                Session["group"] = null;
                MyDataBind(false);
                InsertGroups();
            }
               
            MaintainScrollPositionOnPostBack = true;
        }
        /// <summary>
        /// Binds the data to the datagrid
        /// </summary>
        void MyDataBind(bool resetPageIndex)
        {
            ArrayList urlObjects = GetUrlObjects();
            dgUrls.DataSource = urlObjects;
            if (resetPageIndex)
                dgUrls.CurrentPageIndex = 0;
            dgUrls.DataBind();
        }
        /// <summary>
        /// Gets all the urls from the xml file
        /// </summary>
        /// <returns></returns>
        ArrayList GetUrlObjects()
        {
            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(Paths.GetFullPath() + Paths.GetUrlsFile());
            XmlNodeList Urls = xDoc.SelectNodes(Paths.GetUrlNodes());
            ArrayList urlObjects = new ArrayList();
            if (Session["group"] != null)
            {
                string groupValue = Session["group"].ToString();
                if (groupValue != GetShowAllGroupsPhrase())
                    Urls = xDoc.SelectNodes("//urls/urlGroup[@group='" + groupValue + "']/url");
            }
            foreach (XmlNode urlNode in Urls)
            {
                urlObjects.Add(new UrlObject(urlNode.InnerText, urlNode.ParentNode.Attributes["group"].Value));
            }
            return urlObjects;
        }
        string GetShowAllGroupsPhrase()
        {
            return ConfigurationManager.AppSettings["ShowAllGroupsPhrase"];
        }
        /// <summary>
        /// Gets all the urls from the xml file, filtered by group
        /// </summary>
        /// <param name="Group">The group to filter by</param>
        /// <returns></returns>
        //ArrayList GetUrlObjects(string Group)
        //{
        //    if (Group == "Show All")
        //    {
        //        return GetUrlObjects();
        //    }

        //    XmlDocument xDoc = new XmlDocument();
        //    xDoc.Load(Paths.GetFullPath() + Paths.GetUrlsFile());
        //    XmlNodeList Urls = xDoc.SelectNodes("//urls/urlGroup[@group='" + Group + "']/url");
        //    ArrayList urlObjects = new ArrayList();
        //    foreach (XmlNode urlNode in Urls)
        //    {
        //        urlObjects.Add(new UrlObject(urlNode.InnerText, Group));
        //    }

        //    return urlObjects;
        //}
        /// <summary>
        /// This method is used to change page viewing to view all, or visa versa.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void btnViewAll_Click(object sender, EventArgs e)
        {
            if (Session["ViewAllPassed"] == null)
            {
                Session["ViewAllPassed"] = "true";
            }
            if (Session["ViewAllPassed"].ToString() == "true")
            {
                Session["ViewAllPassed"] = "false";
                dgUrls.AllowPaging = false;
                btnViewAll.Text = "Allow Paging";
            }
            else
            {
                Session["ViewAllPassed"] = "true";
                dgUrls.AllowPaging = true;
                btnViewAll.Text = "View All";
            }
            MyDataBind(false);
        }
        /// <summary>
        /// This method is used to page through the datagrid
        /// </summary>
        /// <param name="source"></param>
        /// <param name="e"></param>
        protected void Paging_DataGrid(object source, System.Web.UI.WebControls.DataGridPageChangedEventArgs e)
        {
            dgUrls.CurrentPageIndex = e.NewPageIndex;
            MyDataBind(false);
        }
        /// <summary>
        /// Adds multiple urls to the datagrid
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void btnAddMultipleUrls_Click(object sender, EventArgs e)
        {
            string[] urls = tbNewUrls.Text.ToString().Split("\n".ToCharArray());
            string group = tbGroup.Text;
            foreach (string url in urls)
            {
                string newUrl = url.Replace("\r", "");
                InsertUrl(newUrl, group);
            }
        }
        /// <summary>
        /// Adds a new url to the xml file
        /// </summary>
        /// <param name="url"></param>
        /// <param name="group"></param>
        void InsertUrl(string url, string group)
        {
            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(Paths.GetFullPath() + Paths.GetUrlsFile());
            XmlNodeList nodes = xDoc.SelectNodes(Paths.GetUrlGroupNodes());
            if (group == "")
                group = "none";
            bool groupExists = false;
            foreach (XmlNode xNode in nodes)
            {
                if (xNode.Attributes["group"].Value == group)
                    groupExists = true;
            }
            if (!groupExists)
            {
                XmlNode urlNode = xDoc.SelectSingleNode("//urls");
                XmlElement newGroupNode = xDoc.CreateElement("urlGroup");
                newGroupNode.SetAttribute("group", group);
                urlNode.AppendChild(newGroupNode);
            }
            XmlNode node = xDoc.SelectSingleNode("//urls/urlGroup[@group='" + group + "']");
            XmlElement newNode = xDoc.CreateElement("url");
            newNode.InnerText = url;
            node.AppendChild(newNode);
            xDoc.Save(Paths.GetFullPath() + Paths.GetUrlsFile());
            MyDataBind(false);
        }
        /// <summary>
        /// Deletes a url from the xml file
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void btnDeleteUrl_Click(object sender, EventArgs e)
        {
            string url = tbDeleteUrl.Text;
            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(Paths.GetFullPath() + Paths.GetUrlsFile());
            XmlNodeList nodes = xDoc.SelectNodes(Paths.GetUrlGroupNodes());
            foreach (XmlNode node in nodes)
            {
                foreach (XmlNode urlNode in node.ChildNodes)
                {
                    if (url == urlNode.InnerText.ToString())
                        node.RemoveChild(urlNode);
                }
            }
            xDoc.Save(Paths.GetFullPath() + Paths.GetUrlsFile());
            MyDataBind(false);
        }
        
        protected void btnErrors_Click(object sender, EventArgs e)
        {
            Response.Redirect("Default.aspx");
        }

        /// <summary>
        /// Shows urls in the datagrid based on what group is slected in the dropdown list
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void ddlGroups_SelectedIndexChanged(object sender, EventArgs e)
        {
            Session["group"] = ddlGroups.SelectedValue;
            MyDataBind(true);
        }
        /// <summary>
        /// This method gets all the groups from the xml file
        /// and adds them to a drop down list
        /// </summary>
        void InsertGroups()
        {
            string group = string.Empty;
            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(Paths.GetFullPath() + Paths.GetUrlsFile());

            XmlNodeList nodes = xDoc.SelectNodes(Paths.GetUrlGroupNodes());
            ddlGroups.Items.Add("Show All");
            foreach (XmlNode node in nodes)
            {
                group = node.Attributes["group"].Value;
                ddlGroups.Items.Add(group);
            }
        }
    }
    /// <summary>
    /// This class is used for storing information about urls used in url based testing
    /// It is used when the data is bound to the datagrid.
    /// </summary>
    class UrlObject
    {
        string url;
        string group;

        public UrlObject(string Url, string Group)
        {
            this.url = Url;
            this.group = Group;
        }
        public string Url
        {
            get { return url; }
        }
        public string Group
        {
            get { return group; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\AppeventParser\AppEventParser.cs ===
using System;
using System.Xml;
using System.Collections;
using System.Diagnostics;
using System.Configuration;
using System.IO;

namespace AppEventParser
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	class MainConsole
	{
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main(string[] args)
		{
			
			//System.Environment.CommandLine
			FileParser FP = new FileParser();
           

			// First We need a folder to copy the Applogs over to
			string TempFolder = ConfigurationSettings.AppSettings["TempFolder"];
			if (!Directory.Exists(TempFolder))
                Directory.CreateDirectory(TempFolder);

			XmlDocument XMLDoc = new XmlDocument();
			try
			{
				XMLDoc.Load(ConfigurationSettings.AppSettings["AppConfigFile"]);
				
			}
			catch (Exception e)
			{
				Debug.WriteLine("Error Loading XML File: " +e.Message);
				Console.WriteLine("Error Loading XML File: " +e.Message);
			}

			XmlNode xn = XMLDoc.DocumentElement;
			XmlNodeList ServicesList = xn.SelectNodes("/ZoneServices/ServiceSet/Service");

			for (int i=0; i<ServicesList.Count;i++)
			{
				Console.WriteLine(ServicesList.Item(i).SelectSingleNode("Name").InnerXml);
				string FromDirectory = ServicesList.Item(i).SelectSingleNode("BackUpLocation").InnerXml;
				XmlNodeList FileTypeList = ServicesList.Item(i).SelectNodes("FileSet");

				foreach (XmlNode FileType in FileTypeList)
				{
                    try
                    {
                        string[] FileList = Directory.GetFiles(FromDirectory, FileType.InnerText);
                   
					
					foreach (string FileName in FileList)
					{
						string NewTempFile = TempFolder +"\\" +  Path.GetFileName(FileName);
						File.Copy(FileName, NewTempFile, true);
						Console.WriteLine(FileName);
						FP.ReadFile(NewTempFile);
					}
                         }
                   
                    catch (Exception ex)
                    {
                        Console.WriteLine(ex.Message);
                        //return;
                    }
				}
			}

			// now add the static data to the SQL table
			Console.WriteLine("Process yesterdays static grouping");
			FP.SQLI.GroupEventData(DateTime.Now.AddDays(-1), DateTime.Now.AddDays(-1));

			Console.WriteLine("Process todays static grouping");
			FP.SQLI.GroupEventData(DateTime.Now, DateTime.Now);

			if (Debugger.IsAttached)
			{
				Console.WriteLine("hit enter to continue");
				Console.ReadLine();
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\AccessibilityWebSite\AccessibilityWebSite\Site1.Master.designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Test.Common.Utilities.AccessibilityWebSite {
    
    
    public partial class Site1 {
        
        /// <summary>
        /// head control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.ContentPlaceHolder head;
        
        /// <summary>
        /// form1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.HtmlControls.HtmlForm form1;
        
        /// <summary>
        /// Menu1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Menu Menu1;
        
        /// <summary>
        /// ContentPlaceHolder1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.ContentPlaceHolder ContentPlaceHolder1;
        
        /// <summary>
        /// btnDocumentation control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnDocumentation;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\ActiveAuthHeaderWebSite\ActiveAuth.aspx.cs ===
﻿using System;
using System.Configuration;
using System.IO;
using System.Net;
using System.Reflection;
using System.Web;
using System.Web.UI;
using Microsoft.Passport.RPS;

public partial class _Default : Page
{
    public string Token
    {
        get { return ViewState["Token"].ToString(); }
        set { ViewState.Add("Token", value); }
    }

    protected void Page_Load(object sender, EventArgs e)
    {
        if (!IsPostBack)
        {
            //Ensure page is not cached which can result in incorrect auth state being displayed
            Response.Cache.SetCacheability(HttpCacheability.NoCache);
            showDateTime.Text = DateTime.Now.ToString();

            try
            {
                //Get the RPS object pre-initialized in the Global.asax
                RPS myRps = (RPS)Application["globalRPS"];
                string siteName = ConfigurationSettings.AppSettings["Site"];

                //Create other base RPS objects
                RPSHttpAuth httpAuth = new RPSHttpAuth(myRps);
                RPSPropBag authPropBag = new RPSPropBag(myRps);
                RPSDomainMap domainMap = new RPSDomainMap(myRps);


                RPSServerConfig mainConfig = new RPSServerConfig(myRps);
                RPSPropBag siteConfig = (RPSPropBag)mainConfig["Sites"];

                RPSPropBag mySiteConfig = (RPSPropBag)siteConfig[siteName];

                int siteID = Convert.ToInt32(mySiteConfig["SiteID"]);

                //Set returnUrl and siteID in authPropBag
                //Use SSL and remove query string parameters from returnUrl
                string returnUrl = "http://" + Request.ServerVariables["SERVER_NAME"] + Request.Path;

                authPropBag["ReturnURL"] = returnUrl;
                authPropBag["SiteID"] = siteID;
                authPropBag["TicketType"] = 2; // compact ticket type

                //Create ticket object and populate the authPropBag with values from the Request object
                RPSTicket ticket = httpAuth.Authenticate(siteName, Request, authPropBag);

                //Obtain the users 'authState' to determine if they are currently signed in
                uint authState = (uint)authPropBag["RPSAuthState"];

                if (ticket == null)
                {
                    //No RPSTicket found.  Check for AuthState=2 (Maybe) state.
                    if (authState == 2)
                    {
                        //RPS Maybe state detected.  Indicates a ticket is present, but cannot be read.
                        //Redirect to SilentAuth URL to obtain a fresh RPS Ticket.
                        //Write RPS response headers to write the Maybe state cookie to prevent looping.
                        string rpsHeaders = (string)authPropBag["RPSRespHeaders"];
                        if (rpsHeaders != "")
                        {
                            httpAuth.WriteHeaders(Response, rpsHeaders);
                        }

                        string SilentAuthUrl = domainMap.ConstructURL("SilentAuth", siteName, null, authPropBag);
                        Response.Redirect(SilentAuthUrl);
                    }
                    else
                    {
                        //User is not signed in.  Show page with Sign in option

                        Message.Text = "A ticket was not detected.  Click the sign in button below to sign in.";
                        ShowTicketProperties.Text = "";
                        bool showSignIn = true;
                        bool isSecure = Request.IsSecureConnection;

                        LogoButton.Text = httpAuth.LogoTag(showSignIn, isSecure, null, null, siteName, authPropBag);
                    }
                }
                else
                {
                    //RPS ticket found. Ensure ticket is valid (signature is valid and policy criteria such as time window and use of SSL is met

                    bool isValid = ticket.Validate(authPropBag);

                    if (!isValid)
                    {
                        //RPS ticket exists, but is not valid. Refresh ticket by redirecting user to Auth URL
                        //If appropriate login server cookies exist, ticket refresh will be a transparent to the user
                        Response.Redirect(domainMap.ConstructURL("Auth", siteName, null, authPropBag));
                    }
                    else
                    {
                        //RPS ticket exists and is valid. Show page with Sign out button and user's NetID
                        bool showSignIn = false;
                        bool isSecure = Request.IsSecureConnection;
                        LogoButton.Text = httpAuth.LogoTag(showSignIn, isSecure, null, null, siteName, authPropBag);

                        this.Token = ticket.Token;

                        Message.Text = "You have a current ticket.  You are signed in.";

                        ShowTicketProperties.Text += "<table width=90%>";
                        ShowTicketProperties.Text += "<tr><td>Your NetID (PUID)</td><td>" + (string)ticket.Property["HexPUID"] + "</td></tr>";
                        ShowTicketProperties.Text += "<tr><td>TicketType</td><td>" + ticket.TicketType + "&nbsp;&nbsp;<i>[1=WebSSO, 2=Compact, 3=AuthCookie, 4=SecAuthCookie]</i>" + "</td></tr>";
                        ShowTicketProperties.Text += "<tr><td>Ticket IssueInstant</td><td>" + ticket.Property["IssueInstant"] + "&nbsp;&nbsp;<i>[IssueInstant = seconds since 1970</i>" + "</td></tr>";
                        ShowTicketProperties.Text += "<tr><td>Auth Header:</td><td>Authorization:WLID1.0 t=" + ticket.Token + "</td></tr>";
                        ShowTicketProperties.Text += "</table>";


                        //Get RPS response headers from authPropBag and write to response stream
                        string rpsHeaders = (string)authPropBag["RPSRespHeaders"];
                        if (rpsHeaders != "")
                        {
                            httpAuth.WriteHeaders(Response, rpsHeaders);
                        }

                        this.SetRequestVisible(true);
                    }
                }
            }
            catch (Exception ex)
            {
                displayExceptionInfo.Text = "<div>Exception Handler:<br>Exception.TargetSite: " + ex.TargetSite + "<br>Exception.Message: " + ex.Message + "</div>";
            }
        }
    }

    private void SetRequestVisible(bool isVisible)
    {
        Message2.Visible = isVisible;
        UrlTextBox.Visible = isVisible;
        GoButton.Visible = isVisible;
        DropDownList1.Visible = isVisible;
        RequestBodyTextBox.Visible = isVisible;
        RequestBodyLiteral.Visible = isVisible;
        MethodLiteral.Visible = isVisible;
    }

    private void DisplayError(Exception exception)
    {
        OutputLiteral.Text = exception.Message + "<p>" + exception.StackTrace + "<p>" + exception.InnerException;
    }

    protected void GoButton_Click(object sender, EventArgs e)
    {
        if (string.IsNullOrEmpty(UrlTextBox.Text) || !UrlTextBox.Text.StartsWith("http") )
        {
            OutputLiteral.Text = "Please specify a valid URL starting with \"http://\"";
            return;
        }

        // Create a request
        HttpWebRequest request = (HttpWebRequest)WebRequest.Create(UrlTextBox.Text);
        request.Method = DropDownList1.Text;

        // Add an Authorization header
        WebHeaderCollection collection = new WebHeaderCollection();
        collection.Add("Authorization", "WLID1.0 t=" + this.Token);
        request.Headers = collection;

        // read the response
        try
        {
            using (HttpWebResponse response = (HttpWebResponse)request.GetResponse())
            {
                using (StreamReader reader = new StreamReader(response.GetResponseStream()))
                {
                    OutputLiteral.Text = reader.ReadToEnd();
                }
            }
        }
        catch (WebException ex)
        {
            this.DisplayError(ex);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\AccessibilityWebSite\AccessibilityWebSite\Urls.aspx.designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Test.Common.Utilities.AccessibilityWebSite {
    
    
    public partial class Urls {
        
        /// <summary>
        /// lblTitle control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblTitle;
        
        /// <summary>
        /// dgUrls control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DataGrid dgUrls;
        
        /// <summary>
        /// btnViewAll control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnViewAll;
        
        /// <summary>
        /// lblGroups control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblGroups;
        
        /// <summary>
        /// ddlGroups control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DropDownList ddlGroups;
        
        /// <summary>
        /// lblAddMultipleUrls control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblAddMultipleUrls;
        
        /// <summary>
        /// tbNewUrls control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox tbNewUrls;
        
        /// <summary>
        /// lblGroup control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblGroup;
        
        /// <summary>
        /// tbGroup control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox tbGroup;
        
        /// <summary>
        /// btnAddMultipleUrls control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnAddMultipleUrls;
        
        /// <summary>
        /// lblDeleteUrlTitle control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblDeleteUrlTitle;
        
        /// <summary>
        /// lblDeleteUrl control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblDeleteUrl;
        
        /// <summary>
        /// tbDeleteUrl control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox tbDeleteUrl;
        
        /// <summary>
        /// btnDeleteUrl control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnDeleteUrl;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\AccessibilityWebSite\AccessibilityWebSite\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("AccessibilityWebSite")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("MSIT")]
//[assembly: AssemblyProduct("AccessibilityWebSite")]
//[assembly: AssemblyCopyright("Copyright © MSIT 2009")]
//[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("3d5900ae-111a-45be-96b3-d9e4606ca793")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
//[assembly: AssemblyVersion("1.0.0.0")]
//[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\AppeventParser\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\AppeventParser\FileParser.cs ===
using System;
using System.Diagnostics;
using System.IO;
using System.Text;

namespace AppEventParser
{
	/// <summary>
	/// Summary description for FileParser.
	/// </summary>
	public class FileParser
	{
	
		public enum ColumnNames {DT, Computer, LogType, Type, Source, ID, User, EventDetails};
		public SQLInterface SQLI;
		DateTime LastEntryDate=DateTime.Parse("01/01/1900 00:00:00");
		protected string CurrentComputer=string.Empty;
		
		public FileParser()
		{
			SQLI = new SQLInterface();
		}

		public void ReadFile(string FileName)
		{
			Console.WriteLine("Loading File: "+FileName);

			// reset the start time 
			LastEntryDate=DateTime.Parse("01/01/1900 00:00:00");
			CurrentComputer = string.Empty;

			FileStream Stream  = new FileStream(FileName, FileMode.Open);
			StreamReader Reader = new StreamReader(Stream);
			
			String StringLine = String.Empty;
			int i = 0;
            while ((StringLine = Reader.ReadLine()) != null) 
            {
                //Console.WriteLine(StringLine);
				if (StringLine.IndexOf("OnePoint Operations") != -1)
					continue;
				ParseLine(StringLine);
				i++;
            }

		}
		protected void ParseLine(string Line)
		{
			if (Line == String.Empty)
				return;

			DateTime EventDate;
			
			string delimStr = ",";
			char [] delimiter = delimStr.ToCharArray();

			string [] LineSplit = Line.Split(delimiter, 8);

			if (LineSplit.Length < 7)
				return;

			string EvtComputer = LineSplit[(int)ColumnNames.Computer].Trim();
			string EvtType = MakeFirstUpper(LineSplit[(int)ColumnNames.Type].Trim());
			string EvtSource = LineSplit[(int)ColumnNames.Source].Trim();
			int ID=Convert.ToInt32(CleanUpID(LineSplit[(int)ColumnNames.ID].Trim()));
			string EvtUser = LineSplit[(int)ColumnNames.User].Trim();

			// did you know events can come from another computer?
			if (CurrentComputer != EvtComputer)
			{
				LastEntryDate = SQLI.GetLastDate(EvtComputer);
				CurrentComputer = EvtComputer;
			}

			// we only want events that have a computer name.
			if (CurrentComputer==string.Empty || CurrentComputer == "")
				return;

			EventDate = DateTime.Parse(LineSplit[(int)ColumnNames.DT]);

			if (EventDate <= LastEntryDate)
			{
				return;
			}
			Console.WriteLine("DateTime: " + EventDate.ToString("G"));

			Console.WriteLine("Type: "+ EvtType);
			//Console.WriteLine("ID: "+ ID.ToString());
			//Console.WriteLine("Source: "+ EvtSource);
			//Console.WriteLine("User: "+ EvtUser);
			//Console.WriteLine("Computer: "+ EvtComputer);

			String EventDet=String.Empty;
			try
			{
				if (LineSplit[(int)ColumnNames.EventDetails] != null)
					EventDet = CleanUpAppDetails(LineSplit[(int)ColumnNames.EventDetails].Trim());
				//Console.WriteLine("Details: "+ EventDet);
			}
			catch
			{
				Debug.WriteLine("Can not parse event: \n"+ Line);
				Console.WriteLine("Can not parse event: \n"+ Line);
				return;
			}

			SQLI.AddEventDetailsToSQL(EventDate,
										EvtType,
										0, 
										ID, 
										EvtSource, 
										EvtUser, 
										EvtComputer, 
										EventDet);


			//Console.WriteLine("Computer: "+ LineSplit[(int)ColumnNames.Computer]);
			Console.WriteLine("=====================");
		}

		private string MakeFirstUpper(string input) 
		{ 
			StringBuilder sb = new StringBuilder(input, input.Length); 
			sb[0] = Char.ToUpper(sb[0]); 
			return sb.ToString(); 
		}
		// the ID comes back with 'ID(#)' we need to remove the ()
		private string CleanUpID(string input)
		{
			return input.Substring(0,input.IndexOf("("));
		}
		// the details also include event Data=, but sometimes it's empty, so I strip it.
		private string CleanUpAppDetails(string input)
		{
			string LookFor = " , Data =";
			if (input.IndexOf(LookFor)==input.Length - LookFor.Length)
				return input.Substring(0,input.Length - LookFor.Length);
			else if (input.IndexOf(" , ") == (input.Length-3))
				return input.Substring(0,input.Length-3);
			else
				return input;
			

		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\AppeventParser\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("")]
//[assembly: AssemblyProduct("")]
//[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

//[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\AppeventParser\AppEventWeb\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("")]
//[assembly: AssemblyProduct("")]
//[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

//[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//        When specifying the KeyFile, the location of the KeyFile should be
//        relative to the "project output directory". The location of the project output
//        directory is dependent on whether you are working with a local or web project.
//        For local projects, the project output directory is defined as
//       <Project Directory>\obj\<Configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//        For web projects, the project output directory is defined as
//       %HOMEPATH%\VSWebCache\<Machine Name>\<Project Directory>\obj\<Configuration>.
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\AppeventParser\AppEventWeb\EventGraph.aspx.cs ===
using System;
using System.Collections;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Drawing.Drawing2D;
using Microsoft.McsMx.Web.Chart;
using System.Diagnostics;
using System.Data.SqlClient;

namespace AppEventWeb
{
	/// <summary>
	/// Summary description for WebForm1.
	/// </summary>
	public partial class EventGraph : BasePage
	{

		protected System.Web.UI.WebControls.Table EventCheckBoxes;
		protected string EventSourceList = String.Empty;
		protected Hashtable ColorHash;
		protected DateTime HowFarBack;
		protected bool IsHourly=false;
		protected string Service=string.Empty;
		protected string Source=string.Empty;
		protected string Computer=string.Empty;
		protected string Type=string.Empty;
		protected string EventID=string.Empty;
		protected bool IncludeSystemEvents=false;
		protected bool IncludeInfo=false;
		protected bool IncludeWarning=false;
		protected bool IncludeError=false;
		protected string SQLQuery=string.Empty;

		protected System.Drawing.Color[] ColorList = {Color.Red, Color.Blue, Color.Gold, Color.Green, Color.Violet, Color.DarkGray ,Color.MediumVioletRed, Color.Gray, Color.LightCoral, Color.Maroon, Color.Olive, Color.Tomato, Color.DimGray, Color.SaddleBrown, Color.GreenYellow, Color.Gainsboro, Color.Turquoise, Color.MidnightBlue, Color.Plum, Color.BlueViolet};
	
       
		protected void Page_Load(object sender, System.EventArgs e)
		{
			base.BlastWaitGraphics();
        
			InitSQL();

			if (Page.Request.QueryString["HowFarBack"] == null)
				HowFarBack = DateTime.Now.AddDays(-14);
			else
				HowFarBack = Convert.ToDateTime(Page.Request.QueryString["HowFarBack"]);
			Service = Page.Request.QueryString["Service"];
			Source = Page.Request.QueryString["Source"];
			Computer = Page.Request.QueryString["Computer"];
			Type = Page.Request.QueryString["Type"];
			EventID = Page.Request.QueryString["ID"];
			IncludeSystemEvents = Convert.ToBoolean(Page.Request.QueryString["IncludeSystemEvents"]);
			IncludeInfo = Convert.ToBoolean(Page.Request.QueryString["IncludeInfo"]);
			IncludeWarning = Convert.ToBoolean(Page.Request.QueryString["IncludeWarning"]);
			IncludeError = Convert.ToBoolean(Page.Request.QueryString["IncludeError"]);
			IsHourly = Convert.ToBoolean(Page.Request.QueryString["IsHourly"]);

			EventDetailsLink.NavigateUrl="./ViewEventDetails.aspx?"+Page.Request.QueryString;
           

			GraphTitle.Text =  Page.Request.QueryString["Service"];
			if (Source!=null)
				GraphTitle.Text += "."+Source;
			if( Computer!=null)
				GraphTitle.Text += "."+Computer;
			if( Type!=null)
				GraphTitle.Text += "."+Type;
			if( EventID!=null)
				GraphTitle.Text += "."+EventID;

			if (IsHourly)
				BuildHourlyEventGraph();
			else
				BuildDailyEventGraph();
		}

		protected void BuildHourlyEventGraph()
		{
			int Quanity = 0;

			string MaxEventCount="";
			LineChart  EventLineChart;

			ChartPointCollection DatePoints=null;
			
			// what is the date range?
			//TimeSpan DayDiff = new TimeSpan();
			TimeSpan TotalTime = new TimeSpan();
			DateTime MaxDate = GetMaxEventDate(Service, HowFarBack.ToString("G"), IncludeSystemEvents);
			MaxDate=MaxDate.AddSeconds(60-MaxDate.Second);
			MaxDate=MaxDate.AddMinutes((15+(MaxDate.Minute/15)*15)-MaxDate.Minute);
			TotalTime = MaxDate-HowFarBack;

			string ChildNode=string.Empty;
			int i=0;
			int TimeIncreament=0;

			SqlDataReader SqlDR = GetHourlyGraphData(HowFarBack, Service, Source, Computer, Type, EventID, IncludeSystemEvents, IncludeInfo, IncludeWarning, IncludeError);
			if (!SqlDR.HasRows || SqlDR==null)
			{
				EventChart.ToolTip= "No data selected";
				EventChart.RedrawChart();
				return;
			}
			
			while (SqlDR.Read())
			{
				if (ChildNode!= SqlDR.GetValue(0).ToString())
				{
					if (ChildNode!=string.Empty)
					{
						EventLineChart = new LineChart(DatePoints, GetColor(ChildNode, EventChart.Charts.Count));

						EventLineChart.Legend = ChildNode;
						EventLineChart.Fill.Color =  GetColor(ChildNode, EventChart.Charts.Count);

						EventChart.Charts.Add(EventLineChart);
					}
					ChildNode=SqlDR.GetValue(0).ToString();

					DatePoints = new ChartPointCollection();
				
					int Mins = Convert.ToInt32(TotalTime.TotalMinutes/15);
					for (int j=0;j<=Mins;j++)
					{
						DatePoints.Add(new ChartPoint(HowFarBack.AddMinutes(j*15).ToString("t"),(float)0));
					}
				}

				Quanity = SqlDR.GetSqlInt32(2).Value;

				TimeIncreament = SqlDR.GetSqlInt32(1).Value;

				DatePoints[TimeIncreament].YValue = Quanity;

			}
			SqlDR.Close();

			// get the last one added
			EventLineChart = new LineChart(DatePoints, GetColor(ChildNode, EventChart.Charts.Count));

			EventLineChart.Legend = ChildNode;
			EventLineChart.Fill.Color =   GetColor(ChildNode, EventChart.Charts.Count);

			EventChart.Charts.Add(EventLineChart);
			
			if(EventChart.Charts.Count <= 3)
			{
				EventChart.Legend.Width = 28;
			}
			else
			{
				EventChart.Legend.Width=Convert.ToInt16(33*(EventChart.Charts.Count/3));
				if (EventChart.Charts.Count%3 ==0)
					EventChart.Legend.Width-=30;
			}

			EventChart.Height = Unit.Pixel(Convert.ToInt32(EventChart.Height.Value+EventChart.Legend.Width)) ;
			int Max=0;
			for (i=0;i<EventChart.Charts.Count;i++)
			{	
				float min, max, mean;
				EventChart.Charts[i].GetMinMaxMeanValue(out min, out max, out mean);
				if (Convert.ToInt32(max) > Max)
					Max=Convert.ToInt32(max);

				if (EventChart.Charts[0].Data.Count <=50 && EventChart.Charts.Count<4)
				{
					EventChart.Charts[i].DataLabels.ShowValue=true;
					EventChart.Charts[i].DataLabels.Visible=true;
				}
			}
			
			if (Max <=12)
			{
				EventChart.YCustomEnd = Max;
				EventChart.YValuesInterval = 1;
			}
			else 
			{
				EventChart.YValuesInterval =(Max-(Max%12))/12;
				if (Max%EventChart.YValuesInterval==0)
					EventChart.YCustomEnd =(float)(EventChart.YValuesInterval+Max);
				else
					EventChart.YCustomEnd =(float)(EventChart.YValuesInterval*Math.Ceiling(Max/EventChart.YValuesInterval));
			}

			EventChart.ToolTip= "Max ("+Max+") on "+MaxEventCount;
			EventChart.XTitle.Text="Date";
			EventChart.YTitle.Text="Total Events";

			if (EventChart.Charts[0].Data.Count <= 48)
			{
				EventChart.XValuesInterval =2;
			}
			else
			{
				EventChart.XValuesInterval =8;
			}

			EventChart.XTitle.Text="Time";

			EventChart.RedrawChart();

		}


		protected void BuildDailyEventGraph()
		{
			int Quanity = 0;

			string MaxEventCount="";
			LineChart  EventLineChart;

			ChartPointCollection DatePoints=null;
			
			// what is the date range?
			TimeSpan DayDiff = new TimeSpan();
			TimeSpan TotalDays = new TimeSpan();
			DateTime DateCheck =  Convert.ToDateTime(DateTime.Now.ToString("d"));
			TotalDays = DateCheck- HowFarBack;
			string ChildNode=string.Empty;
			int i=0;

			SqlDataReader SqlDR = GetDailyGraphData(HowFarBack, Service, Source, Computer, Type, EventID, IncludeSystemEvents, IncludeInfo, IncludeWarning, IncludeError);
			if (!SqlDR.HasRows || SqlDR==null)
			{
				EventChart.ToolTip= "No data selected";
				EventChart.RedrawChart();
				return;
			}
			while (SqlDR.Read())
			{
				if (ChildNode!= SqlDR.GetValue(0).ToString())
				{
					if (ChildNode!=string.Empty)
					{
						EventLineChart = new LineChart(DatePoints, GetColor(ChildNode, EventChart.Charts.Count));

						EventLineChart.Legend = ChildNode;
						EventLineChart.Fill.Color =  GetColor(ChildNode, EventChart.Charts.Count);

						EventChart.Charts.Add(EventLineChart);
					}
					ChildNode=SqlDR.GetValue(0).ToString();

					DatePoints = new ChartPointCollection();
				
					for (int j=0;j<=TotalDays.Days;j++)
					{
						DatePoints.Add(new ChartPoint(HowFarBack.AddDays(j).ToString("d"),(float)0));
					}
				}

				Quanity = SqlDR.GetSqlInt32(1).Value;

				//EventDate = SqlDR.GetSqlDateTime(2).ToString("");.ToString().Substring(0,dr["EntryDate"].ToString().IndexOf(" "));
				DayDiff = SqlDR.GetSqlDateTime(2).Value-HowFarBack;

				DatePoints[DayDiff.Days].YValue = Quanity;
			}
			SqlDR.Close();

			// get the last one added
			EventLineChart = new LineChart(DatePoints, GetColor(ChildNode, EventChart.Charts.Count));

			EventLineChart.Legend = ChildNode;
			EventLineChart.Fill.Color =   GetColor(ChildNode, EventChart.Charts.Count);

			EventChart.Charts.Add(EventLineChart);
			
			if(EventChart.Charts.Count <= 3)
			{
				EventChart.Legend.Width = 28;
			}
			else
			{
				EventChart.Legend.Width=Convert.ToInt16(33*(EventChart.Charts.Count/3));
				if (EventChart.Charts.Count%3 ==0)
					EventChart.Legend.Width-=30;
			}

			EventChart.Height = Unit.Pixel(Convert.ToInt32(EventChart.Height.Value+EventChart.Legend.Width)) ;
			int Max=0;
			for (i=0;i<EventChart.Charts.Count;i++)
			{	
				float min, max, mean;
				EventChart.Charts[i].GetMinMaxMeanValue(out min, out max, out mean);
				if (Convert.ToInt32(max) > Max)
                    Max=Convert.ToInt32(max);

				if (TotalDays.Days<=14 && EventChart.Charts.Count<4)
				{
					EventChart.Charts[i].DataLabels.ShowValue=true;
					EventChart.Charts[i].DataLabels.Visible=true;
				}
			}
			
			if (Max <=12)
			{
				EventChart.YCustomEnd = Max;
				EventChart.YValuesInterval = 1;
			}
			else 
			{
				EventChart.YValuesInterval =(Max-(Max%12))/12;
				if (Max%EventChart.YValuesInterval==0)
					EventChart.YCustomEnd =(float)(EventChart.YValuesInterval+Max);
				else
					EventChart.YCustomEnd =(float)(EventChart.YValuesInterval*Math.Ceiling(Max/EventChart.YValuesInterval));
			}

			EventChart.ToolTip= "Max ("+Max+") on "+MaxEventCount;
			EventChart.XTitle.Text="Date";
			EventChart.YTitle.Text="Total Events";

			if (EventChart.Charts[0].Data.Count <= 31)
			{
				EventChart.XValuesInterval =1;
			}
			else
			{
				EventChart.XValuesInterval =14;
			}

			EventChart.RedrawChart();
		}

		protected Color GetColor(string NodeName, int CurrentChart)
		{
			Color UseColor=Color.Pink;
			if (NodeName == "Error")
				UseColor = Color.Red;
			else if (NodeName=="Warning")
				UseColor = Color.Goldenrod;
			else if (NodeName=="Information")
				UseColor = Color.Blue;
			else
			{
				UseColor = ColorList[(CurrentChart%ColorList.Length)];
			}
			return UseColor;
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    

		}
		#endregion


	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\AppeventParser\SQLInterface.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Configuration;

namespace AppEventParser
{
	/// <summary>
	/// Summary description for SQLInterface.
	/// </summary>
	public class SQLInterface
	{
		public static  string		ConnectionString	= "";
		public SqlDataAdapter		sqlDA				= null;

		public SQLInterface()
		{
			ConnectionString = ConfigurationSettings.AppSettings["SQL_ConnectionString"];
		}

		private static void OpenConnection( ref SqlConnection SQLCon)
		{
	
			if (SQLCon != null)
			{
				Debug.WriteLine("Connection must be NULL");
				return;
			}

			SQLCon = new SqlConnection(ConnectionString);

			try
			{
				// Open the SQL connection.
				SQLCon.Open();
			}
			catch(Exception e)
			{
				Console.WriteLine(e.ToString());
			}

		}
		public void GroupEventData(DateTime StartDate, DateTime EndDate)
		{
			SqlConnection SQLCon = null;

			try
			{
				OpenConnection(ref SQLCon);

				SqlCommand sqlCmd = new SqlCommand("AddApplicationGrouping", SQLCon );
				sqlCmd.CommandTimeout=60*30;
				sqlCmd.CommandType=CommandType.StoredProcedure;

				sqlCmd.Parameters.Add(new SqlParameter("@StartDate",SqlDbType.DateTime));
				sqlCmd.Parameters.Add(new SqlParameter("@EndDate",SqlDbType.DateTime));

				sqlCmd.Parameters["@StartDate"].Value = StartDate;
				sqlCmd.Parameters["@EndDate"].Value = EndDate;
				
				//Do the SQL command
				sqlCmd.ExecuteNonQuery();
			}
			catch (Exception e)
			{				
				Debug.WriteLine(e.ToString());
				Console.WriteLine(e.ToString());
			}
			SQLCon.Close();
			SQLCon.Dispose();
		}

		public void AddEventDetailsToSQL(DateTime EntryDate, String Type, int Category, int ID, String Source, String User, String Computer, String EventDetails)
		{
		
			SqlConnection SQLCon = null;
			OpenConnection(ref SQLCon);
			
			SqlCommand sqlCmd = new SqlCommand("AddApplicationEvent", SQLCon );
			sqlCmd.CommandType=CommandType.StoredProcedure;
			try
			{
				//todo: make a central params list?
				sqlCmd.Parameters.Add(new SqlParameter("@EntryDate",SqlDbType.DateTime));
				sqlCmd.Parameters.Add(new SqlParameter("@Type", SqlDbType.VarChar, 16));
				sqlCmd.Parameters.Add(new SqlParameter("@Category",SqlDbType.Int ));
				sqlCmd.Parameters.Add(new SqlParameter("@ID",SqlDbType.Int));
				sqlCmd.Parameters.Add(new SqlParameter("@Source",SqlDbType.VarChar,64));
				sqlCmd.Parameters.Add(new SqlParameter("@User",SqlDbType.VarChar,64));
				sqlCmd.Parameters.Add(new SqlParameter("@Computer",SqlDbType.VarChar, 16));
				sqlCmd.Parameters.Add(new SqlParameter("@EventDetails",SqlDbType.VarChar,8000));

				sqlCmd.Parameters["@EntryDate"].Value = EntryDate;
				sqlCmd.Parameters["@Type"].Value = Type;
				sqlCmd.Parameters["@Category"].Value = Category;
				sqlCmd.Parameters["@ID"].Value = ID;
				sqlCmd.Parameters["@Source"].Value = Source;
				sqlCmd.Parameters["@User"].Value = User;
				sqlCmd.Parameters["@Computer"].Value = Computer;
				sqlCmd.Parameters["@EventDetails"].Value = EventDetails;

				//Do the SQL command
				sqlCmd.ExecuteNonQuery();
				
                
			}
			catch (Exception e)
			{				
				Debug.WriteLine(e.ToString());
				Console.WriteLine(e.ToString());

			}
			SQLCon.Close();
			SQLCon.Dispose();
		}
		public DateTime GetLastDate(String ComputerName)
		{
			DateTime Temp = DateTime.Parse("01/01/1901 00:00:00");
			SqlConnection SQLCon = null;
			OpenConnection(ref SQLCon);
			SqlCommand DataCommand = new SqlCommand("Select MAX(EntryDate) as MaxDate from ApplicationEvents where Computer='"+ComputerName+"'", SQLCon);
            DataCommand.CommandTimeout = 60 * 5;           
            //SqlDataReader DataReader = DataCommand.ExecuteReader();
            SqlDataReader DataReader = DataCommand.ExecuteReader(CommandBehavior.CloseConnection);
			if(DataReader.Read())
			{
				try
				{Temp = DataReader.GetDateTime(0);}
				catch
				{}
			}

			DataReader.Close();

			SQLCon.Close();
			SQLCon.Dispose();
			return Temp;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\AppeventParser\AppEventWeb\EventTreeView.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Data.SqlClient;

namespace AppEventWeb
{
	/// <summary>
	/// Summary description for FastTreeViewDemo.
	/// </summary>
	public partial class EventTreeView : BasePage
	{
		protected FastTreeView myFastTreeView;

		const string kNodeImage = "images/directory.GIF";
		public static string kPlusImage = "images/plus.gif";
		public static string kMinusImage = "images/minus.gif";
		public DateTime HowFarBack;
		const int kImageSize = 16;
		const int kIndentAmount = 8;
		protected bool IsHourly=false;

		protected void Page_Load(object sender, System.EventArgs e)
		{
			
			BlastWaitGraphics();
						
			DateTime HowLong = DateTime.Now;
			//set node properties
			myFastTreeView.PlusImage = kPlusImage;
			myFastTreeView.MinusImage = kMinusImage;

			//clear all nodes
			myFastTreeView.Nodes.Clear();

			InitSQL();

			int Duration = Convert.ToInt32(DateRange.SelectedItem.Value.Substring(0,DateRange.SelectedItem.Value.Length-1));

			if (DateRange.SelectedItem.Value.IndexOf("h")!=-1)
			{
				IsHourly=true;
				HowFarBack = DateTime.Now.AddHours(-Duration);
			}
			else
			{
				HowFarBack = DateTime.Now.AddDays(-Duration);
			}

			// what is the filter
			SqlDataAdapter sqlDA = new SqlDataAdapter("Select Source from SystemEventFilters where FilterOut=1 order by Source", SQLConnection);
			DataTable dt=null;
			DataSet sqlDS = new DataSet();

			sqlDA.Fill(sqlDS);
			dt=sqlDS.Tables[0];
			IncludeSystemEvents.ToolTip="Excluding these events:\n";
			foreach (DataRow DRow in dt.Rows)
			{
					IncludeSystemEvents.ToolTip+=DRow["Source"].ToString()+"\n";
			}
			
			FastTreeNode TopNode = CreateLinkNode("Zone Services","images/Home.ico", BuildLink(-1,null));
			
			TopNode.Expanded=true;
			myFastTreeView.Nodes.Add(TopNode);
			int TopRootCount = 0;	

			sqlDA.SelectCommand.CommandText="SELECT Service from ZoneServices order by Service";
			sqlDS = new DataSet();
			sqlDA.Fill(sqlDS);
			dt=sqlDS.Tables[0];

			foreach (DataRow DRow in dt.Rows)
			{	
				DateTime MaxDate;

				if (IsHourly)
				{
					MaxDate = GetMaxEventDate(DRow["Service"].ToString(), DateTime.Now.AddHours(-(Duration+1)).ToString("G"), IncludeSystemEvents.Checked);
					MaxDate=MaxDate.AddSeconds(60-MaxDate.Second);
					MaxDate=MaxDate.AddMinutes((15+(MaxDate.Minute/15)*15)-MaxDate.Minute);
					HowFarBack = MaxDate.AddHours(-Duration);
					dt = GetHourlyTreeData(HowFarBack, DRow["Service"].ToString(), IncludeSystemEvents.Checked, IncludeInfo.Checked, IncludeWarning.Checked, IncludeError.Checked);
				}
				else
				{
					// first round down to midnight.
					HowFarBack = Convert.ToDateTime(DateTime.Now.ToString("d"));

					HowFarBack = Convert.ToDateTime(HowFarBack.AddDays(-(Duration-1)).ToString("d"));
					dt = GetDailyTreeData(HowFarBack, DRow["Service"].ToString(), IncludeSystemEvents.Checked, IncludeInfo.Checked, IncludeWarning.Checked, IncludeError.Checked);
				}
				
				string[] CurrentColumn = new string[Enum.GetNames(typeof(EventTypes)).Length];
				CurrentColumn.Initialize();

				FastTreeNode[] CurrentRoot =new FastTreeNode[Enum.GetNames(typeof(EventTypes)).Length];
				CurrentRoot.Initialize();

				int[] CurrentCount = new int[Enum.GetNames(typeof(EventTypes)).Length];
				CurrentCount.Initialize();

				foreach (DataRow Row in dt.Rows)
				{
					foreach(string Column in Enum.GetNames(typeof(EventTypes)))
					{
						int index = (int)Enum.Parse(typeof(EventTypes),Column);

						if (CurrentColumn[index] == null || (CurrentColumn[index].ToLower() != Row[Column].ToString().ToLower()))
						{
							CurrentColumn[index] = Row[Column].ToString();
							// ico name is different when we are on Type
							string IcoName=Column;
							if (Column == EventTypes.Type.ToString())
								IcoName=CurrentColumn[index];

							// add the new node
							CurrentRoot[index]= CreateLinkNode(CurrentColumn[index],"images/"+IcoName+".ico", BuildLink(index, Row));	
							CurrentRoot[index].Name=Row[Column].ToString();

							if (index==0)
							{
								CurrentRoot[index].Title=GetServiceFilter(DRow["Service"].ToString());
								TopNode.Nodes.Add(CurrentRoot[index]);
							}
							else
							{
								CurrentRoot[index-1].Nodes.Add(CurrentRoot[index]);
							}

							// zero out the children
							for(int j=index+1;j<CurrentColumn.Length;j++)
							{
								CurrentColumn[j]=string.Empty;
							}
							CurrentCount[index]=0;
						}
						CurrentCount[index] += Convert.ToInt32(Row["Total"]);	
						CurrentRoot[index].Name = Row[Column].ToString() +" ("+CurrentCount[index]+")";
				
					}

					TopRootCount+=Convert.ToInt32(Row["Total"]);
				}
			}
			TopNode.Name = "Zone Services"+ " ("+TopRootCount+")";
			TimeSpan TS = DateTime.Now-HowLong;
			ExecutionTime.Text= TS.Minutes+":"+TS.Seconds+" (mm:ss)";
		}

		protected string BuildLink(int CurrentIndex, DataRow LinkData)
		{
			string LinkBuilt = "./EventGraph.aspx?IsHourly="+IsHourly.ToString()+"&HowFarBack="+HowFarBack.ToString("G")+"&IncludeSystemEvents="+IncludeSystemEvents.Checked+"&IncludeInfo="+IncludeInfo.Checked+"&IncludeWarning="+IncludeWarning.Checked+"&IncludeError="+IncludeError.Checked;

			for (int i=0; i<= CurrentIndex; i++)
			{
				LinkBuilt+="&"+Enum.GetName(typeof(EventTypes), i)+"="+LinkData[Enum.GetName(typeof(EventTypes), i)];
			}

			return LinkBuilt;
		}

		FastTreeNode CreateNode(string name, string image)
		{
			FastTreeNode node = new FastTreeNode(kPlusImage, kMinusImage, kImageSize, kIndentAmount);
			node.Image = image;
			node.Name = name;
			node.Expanded = false;
			node.OnRightClick = "alert('you right clicked " + name + "');return false";

			return node;
		}

		FastTreeNode CreateLinkNode(string name,  string image, string link)
		{
			FastTreeNode node = new FastTreeNode(kPlusImage, kMinusImage, kImageSize, kIndentAmount);
			node.Image = image;
			node.Name = name;
			node.Expanded = false;
			node.OnClick = "parent.frames[1].location.href='"+link+"';";

			return node;
		}

		public string GetServiceFilter(string Service)
		{
			// what is the filter
			string ToolTip="Excluding Service Events:\n";
			SqlDataAdapter sqlDA = new SqlDataAdapter("Select Source from ServiceEventFilters where FilterOut=1 and ZoneServiceID=(Select ID from ZoneServices where Service='"+Service+"') order by Source", SQLConnection);
			DataTable dt=null;
			DataSet sqlDS = new DataSet();

			sqlDA.Fill(sqlDS);
			dt=sqlDS.Tables[0];
			if (dt.Rows.Count==0)
			{
				return "No Service Level Filter";
			}
			foreach (DataRow DRow in dt.Rows)
			{
				ToolTip+=DRow["Source"].ToString()+"\n";
			}
			
			return ToolTip.Trim();
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    

		}
		#endregion

        protected void DateRange_SelectedIndexChanged(object sender, EventArgs e)
        {

        }


	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\AppeventParser\AppEventWeb\EventGraph.aspx.designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.1434
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace AppEventWeb {
    
    
    public partial class EventGraph {
        
        /// <summary>
        /// Form1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.HtmlControls.HtmlForm Form1;
        
        /// <summary>
        /// GraphTitle control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label GraphTitle;
        
        /// <summary>
        /// EventChart control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::Microsoft.McsMx.Web.Chart.Chart EventChart;
        
        /// <summary>
        /// EventDetailsLink control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.HyperLink EventDetailsLink;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\AppeventParser\AppEventWeb\MainContent.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace AppEventWeb
{
	/// <summary>
	/// Summary description for MainContent.
	/// </summary>
	public partial class MainContent : System.Web.UI.Page
	{
		protected void Page_Load(object sender, System.EventArgs e)
		{
			// Put user code to initialize the page here
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\AppeventParser\AppEventWeb\FastTreeView.ascx.designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.1434
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace AppEventWeb {
    
    
    public partial class FastTreeView {
        
        /// <summary>
        /// Tree control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Literal Tree;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\AppeventParser\AppEventWeb\MainContent.aspx.designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.1434
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace AppEventWeb {
    
    
    public partial class MainContent {
        
        /// <summary>
        /// Form1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.HtmlControls.HtmlForm Form1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\AppeventParser\AppEventWeb\EventTreeView.aspx.designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3053
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace AppEventWeb {
    
    
    public partial class EventTreeView {
        
        /// <summary>
        /// Form1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.HtmlControls.HtmlForm Form1;
        
        /// <summary>
        /// DateRange control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DropDownList DateRange;
        
        /// <summary>
        /// IncludeSystemEvents control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.CheckBox IncludeSystemEvents;
        
        /// <summary>
        /// IncludeInfo control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.CheckBox IncludeInfo;
        
        /// <summary>
        /// IncludeWarning control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.CheckBox IncludeWarning;
        
        /// <summary>
        /// IncludeError control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.CheckBox IncludeError;
        
        /// <summary>
        /// ExecutionTime control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label ExecutionTime;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\AppeventParser\AppEventWeb\TopBanner.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace AppEventWeb
{
	/// <summary>
	/// Summary description for TopBanner.
	/// </summary>
	public partial class TopBanner : System.Web.UI.Page
	{
		protected void Page_Load(object sender, System.EventArgs e)
		{
			// Put user code to initialize the page here
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\AppeventParser\AppEventWeb\Global.asax.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Web;
using System.Web.SessionState;

namespace AppEventWeb 
{
	/// <summary>
	/// Summary description for Global.
	/// </summary>
	public class Global : System.Web.HttpApplication
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		public Global()
		{
			InitializeComponent();
		}	
		
		protected void Application_Start(Object sender, EventArgs e)
		{

		}
 
		protected void Session_Start(Object sender, EventArgs e)
		{
            // Code that runs when a new session is started

            //Ensure SessionID in order to prevent the folloing exception
            //when the Application Pool Recycles
            //[HttpException]: Session state has created a session id, but cannot 
            //				   save it because the response was already flushed by 
            string sessionId = Session.SessionID;

		}

		protected void Application_BeginRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_EndRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_AuthenticateRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_Error(Object sender, EventArgs e)
		{

		}

		protected void Session_End(Object sender, EventArgs e)
		{

		}

		protected void Application_End(Object sender, EventArgs e)
		{

		}
			
		#region Web Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.components = new System.ComponentModel.Container();
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\AppeventParser\AppEventWeb\FastTreeView.ascx.cs ===
namespace AppEventWeb
{
	using System;
	using System.Data;
	using System.Drawing;
	using System.Web;
	using System.Web.UI.WebControls;
	using System.Web.UI.HtmlControls;
	using System.Collections;
	using System.Text;

	public partial class FastTreeView : System.Web.UI.UserControl
	{
		protected ArrayList nodes = new ArrayList();
		protected string plusImage;
		public string PlusImage {set { plusImage = value; }}
		protected string minusImage;
		public string MinusImage {set { minusImage = value; }}
		public ArrayList Nodes {get{ return nodes; }}

		protected void Page_Load(object sender, System.EventArgs e)
		{
			//add locations of plus/minus images to client script
			Tree.Text = "<script>\nvar kPlusImage = '" + plusImage + "';\nvar kMinusImage = '" + minusImage + "';\n</script>";
            
			//render nodes
			int id = 0;
			foreach(FastTreeNode node in nodes)
				Tree.Text += node.RenderNode("", 0, ref id);
           

		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		///		Required method for Designer support - do not modify
		///		the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{

		}
		#endregion
	}

	public class FastTreeNode
	{
		protected int imageSize;
		protected int indentAmount;
		protected string plusImage;
		protected string minusImage;

		public FastTreeNode(string plusImage, string minusImage, int imageSize, int indentAmount)
		{
			this.plusImage = plusImage;
			this.minusImage = minusImage;
			this.imageSize = imageSize;
			this.indentAmount = indentAmount;
		}

		//Expanded property
		protected bool expanded = true;
		public bool Expanded {get{ return expanded; }
							set{ expanded = value; }}

		//Image property
		protected string image = "";
		public string Image {get{ return image; }
			set{ image = value; }
		}

		//Name property
		protected string name = "";
		public string Name {get{ return name; }
			set{ name = value;}
		}

		//OnClick property
		protected string onClick = "";
		public string OnClick {get{ return onClick; }
			set{ onClick = value.Replace("\"", "'"); }
		}

		//OnRightClick property
		protected string onRightClick = "";
		public string OnRightClick {get{ return onRightClick; }
			set{ onRightClick = value.Replace("\"", "'"); }
		}

		//OnMouseOver property
		protected string onMouseOver = "";
		public string OnMouseOver {get{ return onMouseOver; }
			set{ onMouseOver = value.Replace("\"", "'"); }
		}

		//OnMouseOut property
		protected string onMouseOut = "";
		public string OnMouseOut {get{ return onMouseOut; }
			set{ onMouseOut = value.Replace("\"", "'"); }
		}

		//OnMouseOut property
		protected string NodeTitle = "";
		public string Title {get{ return NodeTitle; }
			set{ NodeTitle = value.Replace("\"", "'"); }
		}

		//Nodes property
		protected ArrayList nodes = new ArrayList();
		public ArrayList Nodes {get{ return nodes; }}

		/// <summary>
		/// Renders the node and all its children.
		/// </summary>
		/// <param name="indentation">Specifies indent level.</param>
		/// <param name="currentID">Reference to an int specifying the current node ID.</param>
		/// <returns>String of HTML.</returns>
		public string RenderNode(string strParentID, int indentation, ref int currentID)
		{
			//render node
			StringBuilder strHTML = new StringBuilder();
			string expandID = "";
			string divstyle = "";
			int indentPlus = indentation*indentAmount;
			int indentImage = indentation*indentAmount+imageSize;
			int indent;
			if(nodes.Count > 0)
				indent = indentPlus;
			else
				indent = indentImage;
			strHTML.Append("<table cellpadding=0 cellspacing=0 style='left: " + indent.ToString() + "px'><tr>");

			//Add expand image
			expandID = "n" + currentID;
			if(nodes.Count > 0)
			{
				string expandImage;
				if(expanded)
				{
					expandImage = minusImage;
					divstyle = "display:inline";
				}
				else
				{
					expandImage = plusImage;
					divstyle = "display:none";	
				}
				strHTML.Append("<td><img id='" + expandID + "i' ");
				strHTML.Append("onclick=\"T('" + expandID + "')\" src='" + expandImage + "' /></td>");
				currentID++;
			}
			strHTML.Append("<td name='" + name + "." + strParentID + "' ");
			if(onRightClick.Length > 0)
				strHTML.Append("oncontextmenu=\"" + onRightClick + "\" ");
			if(onClick.Length > 0)
				strHTML.Append("onclick=\"" + onClick + "\" ");
			if(NodeTitle!="")
				strHTML.Append("title=\""+NodeTitle+"\"");
			strHTML.Append("onmouseover=\"M(this);" + onMouseOver + "\" onmouseout=\"O(this);" + onMouseOut + "\">");
			strHTML.Append("<img src='" + image + "' />&nbsp" + name + "</td></tr></table>");
			currentID++;

			//add div to hide children
			if(nodes.Count > 0)
				strHTML.Append("<div name='" + name + "." + strParentID + "' style='" + divstyle + "' id='" + expandID + "'>");

			//render children
			strHTML.Append(RenderChildNodes(expandID, nodes, indentation+1, ref currentID));

			//terminate div that hides children
			if(nodes.Count > 0)
				strHTML.Append("</div>");

			return strHTML.ToString();
		}

		/// <summary>
		/// Recursively renders children of a node.
		/// </summary>
		/// <param name="nodes">Node children.</param>
		/// <param name="indentation">Int specifying indent level.</param>
		/// <param name="currentID">Reference to an int specifying the current node ID.</param>
		/// <returns>String of HTML.</returns>
		protected string RenderChildNodes(string strParentID, ArrayList nodes, int indentation, ref int currentID)
		{
			if(nodes == null)
				return "";
			string html = "";
			foreach(FastTreeNode node in nodes)
			{
				html += node.RenderNode(strParentID, indentation, ref currentID);
			}
			return html;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\BrowserShots\BrowserShots\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\AppeventParser\AppEventWeb\ViewEventDetails.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Data.SqlClient;

namespace AppEventWeb
{
	/// <summary>
	/// Summary description for ViewEventDetails.
	/// </summary>
	public partial class ViewEventDetails : BasePage
	{
		protected DateTime HowFarBack;
		protected string Service=string.Empty;
		protected string Source=string.Empty;
		protected string Computer=string.Empty;
		protected string Type=string.Empty;
		protected string EventID=string.Empty;
		protected string SQLQuery=string.Empty;
		protected bool IncludeSystemEvents=false;
		protected bool IncludeInfo=false;
		protected bool IncludeWarning=false;
		protected bool IncludeError=false;
	
		protected void Page_Load(object sender, System.EventArgs e)
		{

			base.BlastWaitGraphics();

			HowFarBack = Convert.ToDateTime(Page.Request.QueryString["HowFarBack"]);
            //HowFarBack = DateTime.Now.AddDays(-1);
           // HowFarBack = DateTime.Now.AddYears(-100);
			Service = Page.Request.QueryString["Service"];
			Source = Page.Request.QueryString["Source"];
			Computer = Page.Request.QueryString["Computer"];
			Type = Page.Request.QueryString["Type"];
			EventID = Page.Request.QueryString["ID"];

			IncludeSystemEvents = Convert.ToBoolean(Page.Request.QueryString["IncludeSystemEvents"]);
			IncludeInfo = Convert.ToBoolean(Page.Request.QueryString["IncludeInfo"]);
			IncludeWarning = Convert.ToBoolean(Page.Request.QueryString["IncludeWarning"]);
			IncludeError = Convert.ToBoolean(Page.Request.QueryString["IncludeError"]);

			TableTitle.Text =  Page.Request.QueryString["Service"];

            //modifing the HowFarBack varialbe based on the Service type.
            
            if (Service == "Messenger" || Service == "Stadium")
            {
                HowFarBack = DateTime.Now.AddHours(-6);
 
            }
            if (Service == "Population")
            {
                HowFarBack = DateTime.Now.AddDays(-1);
 
            }
            if (Service == "Zoneweb" || Service == null)
            {
                int minutesNow = DateTime.Now.Minute;
                if (minutesNow < 10)
                {
                    HowFarBack = DateTime.Now.AddMinutes(-80);
                }
                else
                {
                    HowFarBack = DateTime.Now.AddMinutes(-minutesNow - 10);
                }
            }

			if (Page.IsPostBack==true)
				return;

			base.InitSQL();
			BuildSQLString();
			BuildTable();
			

		}
		protected void BuildSQLString()
		{
			string EventTypeInclude = string.Empty;

			if(!IncludeInfo)
				EventTypeInclude += "and Type!='Information' ";

			if(!IncludeWarning)
				EventTypeInclude += "and Type!='Warning' ";

			if(!IncludeError)
				EventTypeInclude += "and Type!='Error' ";
			
			if (EventTypeInclude == string.Empty)
				EventTypeInclude = "and Type!='NoEventSelected' ";
// We have modified the query to just return the TOP 10000 event details and display them as many times the show event detail will fial 
            //to load Lakhs of event details. As initial 10000 event details are sufficient to perform the initial level of analysis.
            // Also it will reduce the load time drastically.
			if (Service==null)
			{
				SQLQuery = "select top 10000 Type, ApplicationEvents.ID, EntryDate, Source, Computer, EventDetails  from ApplicationEvents "+
					"inner join Servers on ApplicationEvents.Computer=Servers.ServerName "+
					"inner join ZoneServices on ZoneServices.ID=Servers.ZoneServiceID "+
					"where EntryDate > '"+HowFarBack.ToString("G")+"' "+
					"and Source not in (Select Source from ServiceEventFilters where ZoneServiceID=ZoneServices.ID) ";
				if(!IncludeSystemEvents)
						SQLQuery+="and Source not in (Select Source from SystemEventFilters where FilterOut=1) ";
				SQLQuery+=EventTypeInclude +
					"order by EntryDate desc ";
			}
			else if (Source==null)
			{
                SQLQuery = "select top 10000 Type, ApplicationEvents.ID, EntryDate, Source, Computer, EventDetails  from ApplicationEvents " +
					"inner join Servers on ApplicationEvents.Computer=Servers.ServerName "+
					"inner join ZoneServices on ZoneServices.ID=Servers.ZoneServiceID "+
					"where Service='"+Service+"' "+
					"and EntryDate > '"+HowFarBack.ToString("G")+"' "+
					"and Source not in (Select Source from ServiceEventFilters where ZoneServiceID=ZoneServices.ID) ";
				if(!IncludeSystemEvents)
					SQLQuery+="and Source not in (Select Source from SystemEventFilters where FilterOut=1) ";
				SQLQuery+=EventTypeInclude +
				"order by EntryDate desc ";
			}
			else if (Computer==null)
			{
                SQLQuery = "select top 10000 Type, ApplicationEvents.ID, EntryDate, Source, Computer, substring(EventDetails, 0, 120) + '...' as ShortDetails , EventDetails  from ApplicationEvents " +
					"inner join Servers on ApplicationEvents.Computer=Servers.ServerName "+
					"inner join ZoneServices on ZoneServices.ID=Servers.ZoneServiceID "+
					"where Service='"+Service+"' "+
					"and Source = '"+Source+"' "+
					"and EntryDate > '"+HowFarBack.ToString("G")+"' "+
					"and Source not in (Select Source from ServiceEventFilters where ZoneServiceID=ZoneServices.ID) ";
				if(!IncludeSystemEvents)
					SQLQuery+="and Source not in (Select Source from SystemEventFilters where FilterOut=1) ";
				SQLQuery+=EventTypeInclude +
					"order by EntryDate desc ";

				TableTitle.Text+="."+Page.Request.QueryString["Source"];
			}
			else if (Type==null)
			{
                SQLQuery = "select top 10000 Type, ApplicationEvents.ID, EntryDate, Source, Computer, EventDetails  from ApplicationEvents " +
					"inner join Servers on ApplicationEvents.Computer=Servers.ServerName "+
					"inner join ZoneServices on ZoneServices.ID=Servers.ZoneServiceID "+
					"where Service='"+Service+"' "+
					"and Source = '"+Source+"' "+
					"and Computer = '"+Computer+"' "+
					"and EntryDate > '"+HowFarBack.ToString("G")+"' "+
					"and Source not in (Select Source from ServiceEventFilters where ZoneServiceID=ZoneServices.ID) ";
				if(!IncludeSystemEvents)
					SQLQuery+="and Source not in (Select Source from SystemEventFilters where FilterOut=1) ";
				SQLQuery+=EventTypeInclude +
					"order by EntryDate desc ";

				TableTitle.Text+="."+Page.Request.QueryString["Source"]+"."+Page.Request.QueryString["Computer"];
			}
			else if (EventID==null)
			{
                SQLQuery = "select top 10000 Type, ApplicationEvents.ID, EntryDate, Source, Computer, EventDetails  from ApplicationEvents " +
					"inner join Servers on ApplicationEvents.Computer=Servers.ServerName "+
					"inner join ZoneServices on ZoneServices.ID=Servers.ZoneServiceID "+
					"where Service='"+Service+"' "+
					"and Source = '"+Source+"' "+
					"and Computer = '"+Computer+"' "+
					"and Type = '"+Type+"' "+
					"and EntryDate > '"+HowFarBack.ToString("G")+"' "+
					"and Source not in (Select Source from ServiceEventFilters where ZoneServiceID=ZoneServices.ID) ";
				if(!IncludeSystemEvents)
					SQLQuery+="and Source not in (Select Source from SystemEventFilters where FilterOut=1) ";
				SQLQuery+=EventTypeInclude +
					"order by EntryDate desc ";

				TableTitle.Text+="."+Page.Request.QueryString["Source"]+"."+Page.Request.QueryString["Computer"]+"."+Page.Request.QueryString["Type"];
			}
			else
			{
                SQLQuery = "select top 10000 Type, ApplicationEvents.ID, EntryDate, Source, Computer, EventDetails  from ApplicationEvents " +
					"inner join Servers on ApplicationEvents.Computer=Servers.ServerName "+
					"inner join ZoneServices on ZoneServices.ID=Servers.ZoneServiceID "+
					"where Service='"+Service+"' "+
					"and Source = '"+Source+"' "+
					"and Computer = '"+Computer+"' "+
					"and Type = '"+Type+"' "+
					"and ApplicationEvents.ID = '"+EventID+"' "+
					"and EntryDate > '"+HowFarBack.ToString("G")+"' "+
					"and Source not in (Select Source from ServiceEventFilters where ZoneServiceID=ZoneServices.ID) ";
				if(!IncludeSystemEvents)
					SQLQuery+="and Source not in (Select Source from SystemEventFilters where FilterOut=1) ";
				SQLQuery+=EventTypeInclude +
					"order by EntryDate desc ";


				TableTitle.Text+="."+Page.Request.QueryString["Source"]+"."+Page.Request.QueryString["Computer"]+"."+Page.Request.QueryString["Type"]+"."+Page.Request.QueryString["ID"];
			}
		}

		protected void BuildTable()
		{

			SqlDataAdapter sqlDA = new SqlDataAdapter(SQLQuery, SQLConnection);
			sqlDA.SelectCommand.CommandTimeout = 60*3;
			DataSet sqlDS = new DataSet();
			sqlDA.Fill(sqlDS);

			//DataTable dt=sqlDS.Tables[0];

			EventDetails.DataSource=sqlDS;
			EventDetails.DataBind();
			SQLConnection.Close();

		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.EventDetails.PageIndexChanged += new System.Web.UI.WebControls.DataGridPageChangedEventHandler(this.ChangePage);

		}
		#endregion

		private void ChangePage(object source, System.Web.UI.WebControls.DataGridPageChangedEventArgs e)
		{
			EventDetails.CurrentPageIndex = e.NewPageIndex;
            base.InitSQL();
            BuildSQLString();
            BuildTable();
            
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\AppeventParser\AppEventWeb\TopBanner.aspx.designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.1434
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace AppEventWeb {
    
    
    public partial class TopBanner {
        
        /// <summary>
        /// Form1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.HtmlControls.HtmlForm Form1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\BrowserShots\BrowserShotsService\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\AppeventParser\AppEventWeb\ViewEventDetails.aspx.designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3053
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace AppEventWeb {
    
    
    public partial class ViewEventDetails {
        
        /// <summary>
        /// Form1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.HtmlControls.HtmlForm Form1;
        
        /// <summary>
        /// TableTitle control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label TableTitle;
        
        /// <summary>
        /// EventDetails control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DataGrid EventDetails;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\BrowserShots\BrowserShotsWebsite\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\BrowserShots\BrowserShots\BrowserShots\BrowserShot.cs ===
﻿using System;
using System.Runtime.InteropServices;
using System.Diagnostics;
using Microsoft.Win32;
using System.Xml;
using System.IO;
using Microsoft.WLX.CXP.WebPageGrabber;
using System.Collections;
using System.Threading;
using System.Configuration;
using System.Drawing;
using System.Drawing.Imaging;

namespace Test.Common.Utilities.BrowserShots
{
    // This class will set the properties and then take screenshots for the urls
    internal class BrowserShot
    {
        int newActiveScriptSetting;
        int newActiveXSetting;
        string disableScriptDebugging; // both ie and other
        string errorDlgDisplayedOnEveryError;
        int warnOnZoneCrossing;
        int zoom;
        int textSize;
        bool limitedUserPrivileges;
        int newXResolution;
        int newYResolution;
        int colorDepth;
        string newFlashVersion;
        int webPageGrabberDelay;
        string MachineName;
        string operatingSystem;
        string browserVersion;
        string path;
        int rank;
        int totalMachines;
        string screenShotPath;
        string currentUrl;
        ArrayList urlWithDelay;

        public BrowserShot(int webPageGrabberDelay, string MachineName, string operatingSystem, string browser, string path, int rank, int totalMachines, string screenShotPath)
        {
            this.webPageGrabberDelay = webPageGrabberDelay;
            this.MachineName = MachineName;
            this.operatingSystem = operatingSystem;
            this.browserVersion = browser;
            this.path = path;
            this.rank = rank;
            this.totalMachines = totalMachines;
            this.screenShotPath = screenShotPath;
        }

        /// <summary>
        /// This method starts the browser shots
        /// </summary>
        public void Start()
        {
            ArrayList urls = GetUrls();
            ArrayList myUrls = GetMyUrls(urls, rank, totalMachines);

            if (browserVersion.ToUpper().StartsWith("I"))
                StartIExplorer(myUrls);
            else if (browserVersion.StartsWith("Firefox"))
                StartFirefox(myUrls);
        }

        /// <summary>
        /// Gets all the urls that this machine will run.
        /// If more than one machine is running with the 
        /// same OS and Browser, then ranked so that the URLs 
        /// are divided up between them.
        /// </summary>
        /// <param name="urls"></param>
        /// <param name="rank"></param>
        /// <param name="totalMachines"></param>
        /// <returns></returns>
        ArrayList GetMyUrls(ArrayList urls, int rank, int totalMachines)
        {
            ArrayList myUrls = new ArrayList();
            int length = urls.Count;
            int segment = length / totalMachines;
            int remainder = length % totalMachines;
            int start = segment * (rank - 1);
            for (int i = start; i < start + segment; i++)
                myUrls.Add(urls[i]);
            if (rank == totalMachines)
            {
                for (int i = length - remainder; i < length; i++)
                    myUrls.Add(urls[i]);
            }

            return myUrls;
        }

        /// <summary>
        /// Sets the properties under which browser shots will be taken for the urls
        /// </summary>
        /// <param name="newActiveScriptSetting"></param>
        /// <param name="newActiveXSetting"></param>
        /// <param name="disableScriptDebugging"></param>
        /// <param name="errorDlgDisplayedOnEveryError"></param>
        /// <param name="warnOnZoneCrossing"></param>
        /// <param name="zoom"></param>
        /// <param name="textSize"></param>
        /// <param name="limitedUserPrivileges"></param>
        /// <param name="newXResolution"></param>
        /// <param name="newYResolution"></param>
        /// <param name="colorDepth"></param>
        /// <param name="newFlashVersion"></param>
        public void SetValues(int newActiveScriptSetting, int newActiveXSetting, string disableScriptDebugging, string errorDlgDisplayedOnEveryError, int warnOnZoneCrossing, int zoom, int textSize, bool limitedUserPrivileges, int newXResolution, int newYResolution, int colorDepth, string newFlashVersion)
        {
            this.newActiveScriptSetting = newActiveScriptSetting;
            this.newActiveXSetting = newActiveXSetting;
            this.disableScriptDebugging = disableScriptDebugging;
            this.errorDlgDisplayedOnEveryError = errorDlgDisplayedOnEveryError;
            this.warnOnZoneCrossing = warnOnZoneCrossing;
            this.zoom = zoom;
            this.textSize = textSize;
            this.limitedUserPrivileges = limitedUserPrivileges;
            this.newXResolution = newXResolution;
            this.newYResolution = newYResolution;
            this.colorDepth = colorDepth;
            this.newFlashVersion = newFlashVersion;
        }

        /// <summary>
        /// This is for firefox as browser settings aren't changed
        /// </summary>
        /// <param name="newXResolution"></param>
        /// <param name="newYResolution"></param>
        /// <param name="colorDepth"></param>
        /// <param name="newFlashVersion"></param>
        public void SetValues(int newXResolution, int newYResolution, int colorDepth, string newFlashVersion)
        {
            this.newXResolution = newXResolution;
            this.newYResolution = newYResolution;
            this.colorDepth = colorDepth;
            this.newFlashVersion = newFlashVersion;
        }

        /// <summary>
        /// This method is called when browser shots will be taken for IE
        /// </summary>
        /// <param name="urls"></param>
        public void StartIExplorer(ArrayList urls)
        {
            string newFlashVersion = GetFlashVersion();
            ArrayList arrayListActiveScriptSetting = new ArrayList();
            ArrayList arrayListActiveXSetting = new ArrayList();
            ArrayList arrayListDisableScriptDebugging = new ArrayList();
            ArrayList arrayListErrorDlgDisplayedOnEveryError = new ArrayList();
            ArrayList arrayListZoom = new ArrayList();
            ArrayList arrayListTextSize = new ArrayList();
            ArrayList arrayListWarnOnZoneCrossing = new ArrayList();
            ArrayList arrayListLimitedUserPrivileges = new ArrayList();
            ArrayList arrayListNewXResolution = new ArrayList();
            ArrayList arrayListNewYResolution = new ArrayList();
            ArrayList arrayListColorDepths = new ArrayList();

            SetRegistryValues(arrayListActiveScriptSetting, arrayListActiveXSetting, arrayListDisableScriptDebugging, arrayListErrorDlgDisplayedOnEveryError, arrayListWarnOnZoneCrossing, arrayListZoom, arrayListTextSize, arrayListLimitedUserPrivileges, arrayListNewXResolution, arrayListNewYResolution, arrayListColorDepths);
            // Save the current values
            int ie_zone = 3; // internet zone
            RegistryKey keyCurrentUserRemote = RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive.CurrentUser, MachineName);
            RegistryKey keyActiveScript = keyCurrentUserRemote.OpenSubKey(@"Software\Microsoft\Windows\CurrentVersion\Internet Settings\Zones\" + ie_zone.ToString(), true);
            int oldActiveScriptSetting = (int)keyActiveScript.GetValue("1400");
            int oldActiveXSetting = (int)keyActiveScript.GetValue("1200");
            RegistryKey browserSecurityKey = keyCurrentUserRemote.OpenSubKey(@"Software\Microsoft\Internet Explorer\Main", true);
            string oldDisableScriptDebuggingOther = (string)browserSecurityKey.GetValue("Disable Script Debugger");
            string oldDisableScriptDebuggingIE = (string)browserSecurityKey.GetValue("DisableScriptDebuggerIE");
            string oldErrorDlgDisplayedOnEveryError = (string)browserSecurityKey.GetValue("Error Dlg Displayed On Every Error");

            RegistryKey browserSecurityKey1 = keyCurrentUserRemote.OpenSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Internet Settings", true);
            int oldWarnOnZoneCrossing = 0;
            int oldZoom = 100000;
            int oldTextSize = 2;

            // Flash Version
            RegistryKey keyLocalMachineRemote = RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive.LocalMachine, MachineName);
            RegistryKey keyFlashVersion = keyLocalMachineRemote.OpenSubKey(@"Software\Macromedia\FlashPlayer\");
            // RegistryKey keyFlashVersion1 = Registry.LocalMachine.OpenSubKey(@"Software\Macromedia\FlashPlayer\", true);
            string oldFlashVersion = string.Empty;
            if (keyFlashVersion != null)
                oldFlashVersion = (string)keyFlashVersion.GetValue("CurrentVersion");
            for (int i = 0; i < arrayListNewXResolution.Count; i++)
            {
                foreach (string colorDepth in arrayListColorDepths)
                {
                    RunModifyScreenSizeProcess(" /W:" + Convert.ToInt32(arrayListNewXResolution[i]) + " /H:" + Convert.ToInt32(arrayListNewYResolution[i]) + " /C:" + colorDepth);
                    Thread.Sleep(5000);
                    foreach (string newActiveScriptSetting in arrayListActiveScriptSetting)
                    {
                        foreach (string newActiveXSetting in arrayListActiveXSetting)
                        {
                            foreach (string disableScriptDebugging in arrayListDisableScriptDebugging)
                            {
                                foreach (string errorDlgDisplayedOnEveryError in arrayListErrorDlgDisplayedOnEveryError)
                                {
                                    foreach (string warnOnZoneCrossing in arrayListWarnOnZoneCrossing)
                                    {
                                        foreach (string zoom in arrayListZoom)
                                        {
                                            foreach (int textSize in arrayListTextSize)
                                            {
                                                foreach (string limitedUserPrivileges in arrayListLimitedUserPrivileges)
                                                {
                                                    SetValues(Convert.ToInt32(newActiveScriptSetting), Convert.ToInt32(newActiveXSetting), disableScriptDebugging, errorDlgDisplayedOnEveryError, Convert.ToInt32(warnOnZoneCrossing), Convert.ToInt32(zoom), textSize, Convert.ToBoolean(limitedUserPrivileges), Convert.ToInt32(arrayListNewXResolution[i]), Convert.ToInt32(arrayListNewYResolution[i]), Convert.ToInt32(colorDepth), newFlashVersion);
                                                    SetWindowsRegistryInformationAndTakeScreenShot(urls);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // Reset Values
            keyActiveScript.SetValue("1400", oldActiveScriptSetting);
            keyActiveScript.SetValue("1200", oldActiveXSetting);
            RegistryKey keyScaling = keyCurrentUserRemote.OpenSubKey(@"Software\Microsoft\Internet Explorer\Zoom", true);
            if (keyScaling != null)
                keyScaling.SetValue("ZoomFactor", oldZoom);

            RegistryKey fontSize = keyCurrentUserRemote.OpenSubKey(@"Software\Microsoft\Internet Explorer\International\Scripts\3", true);
            fontSize.SetValue("IEFontSize", oldTextSize);
            fontSize.SetValue("IEFontSizePrivate", oldTextSize);
            browserSecurityKey.SetValue("Disable Script Debugger", oldDisableScriptDebuggingOther);
            browserSecurityKey.SetValue("DisableScriptDebuggerIE", oldDisableScriptDebuggingIE);
            browserSecurityKey.SetValue("Error Dlg Displayed On Every Error", oldErrorDlgDisplayedOnEveryError);
            browserSecurityKey1.SetValue("WarnOnZoneCrossing", oldWarnOnZoneCrossing);
        }

        /// <summary>
        /// This method is called when browser shots will be taken for Firefox
        /// </summary>
        /// <param name="urls"></param>
        public void StartFirefox(ArrayList urls)
        {
            string MachineName = System.Environment.MachineName;

            ArrayList arrayListNewXResolution = new ArrayList();
            ArrayList arrayListNewYResolution = new ArrayList();
            ArrayList arrayListColorDepths = new ArrayList();

            SetRegistryValuesFirefox(arrayListNewXResolution, arrayListNewYResolution, arrayListColorDepths);

            for (int i = 0; i < arrayListNewXResolution.Count; i++)
            {
                foreach (string colorDepth in arrayListColorDepths)
                {
                    RunModifyScreenSizeProcess(" /W:" + Convert.ToInt32(arrayListNewXResolution[i]) + " /H:" + Convert.ToInt32(arrayListNewYResolution[i]) + " /C:" + colorDepth);
                    Thread.Sleep(5000);
                    SetValues(Convert.ToInt32(arrayListNewXResolution[i]), Convert.ToInt32(arrayListNewYResolution[i]), Convert.ToInt32(colorDepth), newFlashVersion);
                    SetWindowsRegistryInformationAndTakeScreenShotFirefox(urls);
                }
            }
            //RunDeleteBrowsersProcess("Firefox");
        }

        /// <summary>
        /// Sets the registry values before browser shots are taken for IE
        /// </summary>
        /// <param name="arrayListActiveScriptSetting"></param>
        /// <param name="arrayListActiveXSetting"></param>
        /// <param name="arrayListDisableScriptDebugging"></param>
        /// <param name="arrayListErrorDlgDisplayedOnEveryError"></param>
        /// <param name="arrayListWarnOnZoneCrossing"></param>
        /// <param name="arrayListZoom"></param>
        /// <param name="arrayListTextSize"></param>
        /// <param name="arrayListLimitedUserPrivileges"></param>
        /// <param name="arrayListNewXResolution"></param>
        /// <param name="arrayListNewYResolution"></param>
        /// <param name="arrayListColorDepths"></param>
        void SetRegistryValues(ArrayList arrayListActiveScriptSetting, ArrayList arrayListActiveXSetting, ArrayList arrayListDisableScriptDebugging, ArrayList arrayListErrorDlgDisplayedOnEveryError, ArrayList arrayListWarnOnZoneCrossing, ArrayList arrayListZoom, ArrayList arrayListTextSize, ArrayList arrayListLimitedUserPrivileges, ArrayList arrayListNewXResolution, ArrayList arrayListNewYResolution, ArrayList arrayListColorDepths)
        {
            string RegistryScreenSizeXNodes = string.Empty;
            string RegistryScreenSizeYNodes = string.Empty;
            string RegistryColorDepthNodes = string.Empty;
            string RegistryJavaScriptNodes = string.Empty;
            string RegistryActiveXNodes = string.Empty;
            string RegistryDisableScriptDebuggingNodes = string.Empty;
            string RegistryDisplayErrorDialogNodes = string.Empty;
            string RegistryWarnOnZoneCrossingNodes = string.Empty;
            string RegistryZoomNodes = string.Empty;
            string RegistryTextSizeNodes = string.Empty;
            string RegistryLimitedUserPrivilegesNodes = string.Empty;
            string folder = string.Empty;
            XmlDocument xDoc;
            XmlNode parentNode;
            string[] ScreenSizeX;
            string[] colorDepths;
            try
            {
                RegistryScreenSizeXNodes = GetRegistryScreenSizeXNodes();
                RegistryScreenSizeYNodes = GetRegistryScreenSizeYNodes();
                RegistryColorDepthNodes = GetRegistryColorDepthNodes();
                RegistryJavaScriptNodes = GetRegistryJavaScriptNodes();
                RegistryActiveXNodes = GetRegistryActiveXNodes();
                RegistryDisableScriptDebuggingNodes = GetRegistryDisableScriptDebuggingNodes();
                RegistryDisplayErrorDialogNodes = GetRegistryDisplayErrorDialogNode();
                RegistryWarnOnZoneCrossingNodes = GetRegistryWarnOnZoneCrossingNodes();
                RegistryZoomNodes = GetRegistryZoomNodes();
                RegistryTextSizeNodes = GetRegistryTextSizeNodes();
                RegistryLimitedUserPrivilegesNodes = GetRegistryLimitedUserPrivilegesNodes();
                folder = path;
                xDoc = new XmlDocument();
                xDoc.Load(folder + GetRegistryFile());
                parentNode = xDoc.SelectSingleNode(RegistryScreenSizeXNodes);
                foreach (XmlNode node in parentNode.ChildNodes)
                {
                    if (node.Attributes["active"].Value == "true")
                    {
                        ScreenSizeX = node.InnerText.Split(' ');
                        arrayListNewXResolution.Add(ScreenSizeX[0]);
                    }
                }
                parentNode = xDoc.SelectSingleNode(RegistryScreenSizeYNodes);
                foreach (XmlNode node in parentNode.ChildNodes)
                {
                    if (node.Attributes["active"].Value == "true")
                        arrayListNewYResolution.Add(node.InnerText);
                }
                parentNode = xDoc.SelectSingleNode(RegistryColorDepthNodes);
                foreach (XmlNode node in parentNode.ChildNodes)
                {
                    if (node.Attributes["active"].Value == "true")
                    {
                        colorDepths = node.InnerText.Split(' ');
                        arrayListColorDepths.Add(colorDepths[0]);
                    }
                }
                parentNode = xDoc.SelectSingleNode(RegistryJavaScriptNodes);
                foreach (XmlNode node in parentNode.ChildNodes)
                {
                    if (node.Attributes["active"].Value == "true")
                        arrayListActiveScriptSetting.Add(node.InnerText.ToLower() == "enabled" ? "0" : "3");
                }
                parentNode = xDoc.SelectSingleNode(RegistryActiveXNodes);
                foreach (XmlNode node in parentNode.ChildNodes)
                {
                    if (node.Attributes["active"].Value == "true")
                        arrayListActiveXSetting.Add(node.InnerText.ToLower() == "enabled" ? "0" : "3");
                }
                parentNode = xDoc.SelectSingleNode(RegistryDisableScriptDebuggingNodes);
                foreach (XmlNode node in parentNode.ChildNodes)
                {
                    if (node.Attributes["active"].Value == "true")
                        arrayListDisableScriptDebugging.Add(node.InnerText.ToLower());
                }
                parentNode = xDoc.SelectSingleNode(RegistryDisplayErrorDialogNodes);
                foreach (XmlNode node in parentNode.ChildNodes)
                {
                    if (node.Attributes["active"].Value == "true")
                        arrayListErrorDlgDisplayedOnEveryError.Add(node.InnerText.ToLower());
                }
                parentNode = xDoc.SelectSingleNode(RegistryWarnOnZoneCrossingNodes);
                foreach (XmlNode node in parentNode.ChildNodes)
                {
                    if (node.Attributes["active"].Value == "true")
                        arrayListWarnOnZoneCrossing.Add(node.InnerText.ToLower() == "no" ? "0" : "1");
                }
                parentNode = xDoc.SelectSingleNode(RegistryZoomNodes);
                foreach (XmlNode node in parentNode.ChildNodes)
                {
                    if (node.Attributes["active"].Value == "true")
                    {
                        string zoom = node.InnerText;
                        int index = zoom.IndexOf('%');
                        if (index >= 1)
                            zoom = zoom.Substring(0, index);
                        zoom = zoom + "000";
                        arrayListZoom.Add(zoom);
                    }
                }
                parentNode = xDoc.SelectSingleNode(RegistryTextSizeNodes);
                foreach (XmlNode node in parentNode.ChildNodes)
                {
                    if (node.Attributes["active"].Value == "true")
                    {
                        string textSize = node.InnerText.ToLower();
                        int iTextSize = 0;
                        switch (textSize)
                        {
                            case "largest":
                                iTextSize = 4;
                                break;
                            case "large":
                                iTextSize = 3;
                                break;
                            case "medium":
                                iTextSize = 2;
                                break;
                            case "smaller":
                                iTextSize = 1;
                                break;
                            case "smallest":
                                iTextSize = 0;
                                break;
                        }
                        arrayListTextSize.Add(iTextSize);
                    }
                }
                parentNode = xDoc.SelectSingleNode(RegistryLimitedUserPrivilegesNodes);
                foreach (XmlNode node in parentNode.ChildNodes)
                {
                    if (node.Attributes["active"].Value == "true")
                        arrayListLimitedUserPrivileges.Add(node.InnerText.ToLower() == "no" ? "false" : "true");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
                Console.WriteLine(ex.StackTrace);
            }
        }

        /// <summary>
        /// Sets the registry values before browser shots are taken for
        /// </summary>
        /// <param name="arrayListNewXResolution"></param>
        /// <param name="arrayListNewYResolution"></param>
        /// <param name="arrayListColorDepths"></param>
        void SetRegistryValuesFirefox(ArrayList arrayListNewXResolution, ArrayList arrayListNewYResolution, ArrayList arrayListColorDepths)
        {
            string RegistryScreenSizeXNodes = string.Empty;
            string RegistryScreenSizeYNodes = string.Empty;
            string RegistryColorDepthNodes = string.Empty;
            string folder = string.Empty;
            XmlDocument xDoc;
            XmlNode parentNode;
            string[] ScreenSizeX;
            string[] colorDepths;
            try
            {
                RegistryScreenSizeXNodes = GetRegistryScreenSizeXNodes();
                RegistryScreenSizeYNodes = GetRegistryScreenSizeYNodes();
                RegistryColorDepthNodes = GetRegistryColorDepthNodes();
                folder = path;
                xDoc = new XmlDocument();
                xDoc.Load(folder + GetRegistryFile());
                parentNode = xDoc.SelectSingleNode(RegistryScreenSizeXNodes);
                foreach (XmlNode node in parentNode.ChildNodes)
                {
                    if (node.Attributes["active"].Value == "true")
                    {
                        ScreenSizeX = node.InnerText.Split(' ');
                        arrayListNewXResolution.Add(ScreenSizeX[0]);
                    }
                }
                parentNode = xDoc.SelectSingleNode(RegistryScreenSizeYNodes);
                foreach (XmlNode node in parentNode.ChildNodes)
                {
                    if (node.Attributes["active"].Value == "true")
                        arrayListNewYResolution.Add(node.InnerText);
                }
                parentNode = xDoc.SelectSingleNode(RegistryColorDepthNodes);
                foreach (XmlNode node in parentNode.ChildNodes)
                {
                    if (node.Attributes["active"].Value == "true")
                    {
                        colorDepths = node.InnerText.Split(' ');
                        arrayListColorDepths.Add(colorDepths[0]);
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
                Console.WriteLine(ex.StackTrace);
            }
        }

        /// <summary>
        /// Gets all the urls from the xml file that will have browser shots taken
        /// </summary>
        /// <returns></returns>
        ArrayList GetUrls()
        {
            ArrayList urls = new ArrayList();
            urlWithDelay = new ArrayList();
            string folder = path;
            string url = string.Empty;
            XmlDocument xDoc = new XmlDocument();
            XmlNodeList groupNodes;
            try
            {
                xDoc.Load(folder + GetmUrlFile());
                groupNodes = xDoc.SelectNodes(GetUrlGroupNodes());
                foreach (XmlNode groupNode in groupNodes)
                {
                    if (groupNode.Attributes["active"].Value == "true")
                    {
                        foreach (XmlNode node in groupNode.ChildNodes)
                        {
                            url = node.InnerText.ToString();
                            urls.Add(url);
                            if (node.Attributes != null && node.Attributes.Count > 0)
                            {
                                urlWithDelay.Add(new UrlDelay(url, node.Attributes["delay"].Value));
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Console.WriteLine(e.Message);
            }
            return urls;
        }

        /// <summary>
        /// A backup screenshot is taken if a full screen shot fails.
        /// This happens for example if there is an error dialog on top of the web page
        /// </summary>
        /// <param name="commandArguments"></param>
        public void TakeScreenShotBackup(string commandArguments)
        {
            Thread.Sleep(4000);
            RunTakeScreenShotProcess(commandArguments);
            Console.WriteLine(browserVersion);
            if (browserVersion.StartsWith("IExplore"))
            {
                Thread.Sleep(10000);
                RunDeleteBrowsersProcess("iexplore");
                Thread.Sleep(10000);
            }
        }

        /// <summary>
        /// Sets windows registry and takes the screen shot for all the urls passed in for IE
        /// </summary>
        /// <param name="urls"></param>
        public void SetWindowsRegistryInformationAndTakeScreenShot(ArrayList urls)
        {
            //Set Active Script and ActiveX
            int ie_zone = 3; // internet zone
            RegistryKey keyCurrentUserRemote = RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive.CurrentUser, MachineName);
            RegistryKey keyActiveScript = keyCurrentUserRemote.OpenSubKey(@"Software\Microsoft\Windows\CurrentVersion\Internet Settings\Zones\" + ie_zone.ToString(), true);
            if (newActiveScriptSetting == 0 || newActiveScriptSetting == 1 || newActiveScriptSetting == 3)
            {
                keyActiveScript.SetValue("1400", newActiveScriptSetting); //set active scripting
            }
            if (newActiveXSetting == 0 || newActiveXSetting == 1 || newActiveXSetting == 3)
            {
                keyActiveScript.SetValue("1200", newActiveXSetting); //set activeX

            }

            // Set these values
            // 1) Zoom
            // 2) TextSize
            RegistryKey keyScaling = keyCurrentUserRemote.OpenSubKey(@"Software\Microsoft\Internet Explorer\Zoom", true);
            if (keyScaling != null)
                keyScaling.SetValue("ZoomFactor", zoom);

            RegistryKey fontSize = keyCurrentUserRemote.OpenSubKey(@"Software\Microsoft\Internet Explorer\International\Scripts\3", true);
            fontSize.SetValue("IEFontSize", textSize);
            fontSize.SetValue("IEFontSizePrivate", textSize);

            // Set these values:
            // 1) Disable script debugging (both ie and other)
            // 2) Display a notification about every script error
            // 3) Warn if changing between secure and not secure mode

            RegistryKey browserSecurityKey = keyCurrentUserRemote.OpenSubKey(@"Software\Microsoft\Internet Explorer\Main", true);
            browserSecurityKey.SetValue("Disable Script Debugger", disableScriptDebugging);
            browserSecurityKey.SetValue("DisableScriptDebuggerIE", disableScriptDebugging);
            browserSecurityKey.SetValue("Error Dlg Displayed On Every Error", errorDlgDisplayedOnEveryError);

            RegistryKey browserSecurityKey1 = keyCurrentUserRemote.OpenSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Internet Settings", true);
            browserSecurityKey1.SetValue("WarnOnZoneCrossing", warnOnZoneCrossing);

            // Flash Version
            RegistryKey keyLocalMachineRemote = RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive.LocalMachine, MachineName);
            RegistryKey keyFlashVersion = keyLocalMachineRemote.OpenSubKey(@"Software\Macromedia\FlashPlayer\");

            foreach (string url in urls)
            {
                TakeScreenshot(url);
            }
        }

        /// <summary>
        /// This will start taking the screenshot for this url
        /// Taking the screenshot will be in a thread
        /// If the thread is alive too long, it will abort
        /// so the program won't be stalled
        /// </summary>
        /// <param name="url"></param>
        void TakeScreenshot(string url)
        {
            currentUrl = url;
            Thread t = new Thread(TakeScreenshot);
            t.Start();
            int i = 0;
            while (i < 20)
            {
                if (t.IsAlive)
                    Thread.Sleep(5000);
                else
                    break;
                i++;
            }
            if (t.IsAlive)
            {
                t.Abort();
                RunDeleteBrowsersProcess("iexplore");
                using (Bitmap b1 = new Bitmap(GetErrorBitmap()))
                {
                    try
                    {
                        string browser1 = browserVersion.Replace("IExplore", "IE");
                        string ActiveScriptSetting = newActiveScriptSetting == 0 ? "Enabled" : "Disabled";
                        string ActiveXSetting = newActiveXSetting == 0 ? "Enabled" : "Disabled";
                        string WarnOnZoneCrossing = warnOnZoneCrossing == 1 ? "Yes" : "No";
                        string LimitedUserPrivileges = limitedUserPrivileges ? "Yes" : "No";
                        string newUrl = url.Replace(":", "").Replace("/", "").Replace("?", "").Replace("%", "");
                        string sTextSize = textSize > 2 ? "L" : (textSize == 2 ? "M" : "S");

                        string name = "OS;" + operatingSystem + ";BR;" + browser1 + ";SS;" + newXResolution + ";CD;" + colorDepth + ";JV;" + ActiveScriptSetting[0] + ";AX;" + ActiveXSetting[0] + ";DSC;" + disableScriptDebugging[0] + ";DED;" + errorDlgDisplayedOnEveryError[0] + ";WZC;" + WarnOnZoneCrossing[0] + ";Z;" + zoom.ToString().Substring(0, 1) + ";TS;" + sTextSize + ";LUP;" + LimitedUserPrivileges[0] + ";URL;" + newUrl + ";";
                        b1.Save(screenShotPath + name + ".png", ImageFormat.Png);
                        Console.WriteLine("Copying error bitmap");
                    }
                    catch (Exception exc)
                    {
                        Console.WriteLine(exc.Message);
                    }
                }
            }
        }

        /// <summary>
        /// This will start taking the screenshot for this url
        /// Taking the screenshot will be in a thread
        /// If the thread is alive too long, it will abort
        /// so the program won't be stalled
        /// </summary>
        void TakeScreenshot()
        {
            string commandArguments = GetCommandArgumentsForTakeScreenShot(currentUrl);
            bool success;

            success = OpenBrowserAndTakeFullScreenShot(currentUrl, commandArguments);
            if (!success)
                TakeScreenShotBackup(commandArguments);
        }

        /// <summary>
        /// Sets windows registry and takes the screen shot for all the urls passed in for Firefox
        /// </summary>
        /// <param name="urls"></param>
        public void SetWindowsRegistryInformationAndTakeScreenShotFirefox(ArrayList urls)
        {
            foreach (string url in urls)
            {
                TakeScreenshotFirefox(url);
            }
        }

        /// <summary>
        /// This will start taking the screenshot for this url
        /// Taking the screenshot will be in a thread
        /// If the thread is alive too long, it will abort
        /// so the program won't be stalled
        /// </summary>
        /// <param name="url"></param>
        void TakeScreenshotFirefox(string url)
        {
            currentUrl = url;
            Thread t = new Thread(TakeScreenshotFirefox);
            t.Start();
            int i = 0;
            while (i < 40)
            {
                if (t.IsAlive)
                    Thread.Sleep(5000);
                else
                    break;
                i++;
            }
            if (t.IsAlive)
            {
                t.Abort();
                using (Bitmap b1 = new Bitmap(GetErrorBitmap()))
                {
                    try
                    {
                        string newUrl = url.Replace(":", "").Replace("/", "").Replace("?", "").Replace("%", "");

                        string name = "OS;" + operatingSystem + ";BR;" + browserVersion + ";SS;" + newXResolution + ";CD;" + colorDepth + ";URL;" + newUrl + ";";
                        string folder = screenShotPath;
                        if (name.Length + folder.Length >= GetMaxFolderNameSize() + 1)
                            name = name.Substring(0, GetMaxFolderNameSize() - folder.Length);
                        b1.Save(screenShotPath + name + ".png", ImageFormat.Png);
                        Console.WriteLine("Copying error bitmap");
                    }
                    catch (Exception exc)
                    {
                        Console.WriteLine(exc.Message);
                    }
                }
            }
        }

        /// <summary>
        /// This will start taking the screenshot for this url
        /// Taking the screenshot will be in a thread
        /// If the thread is alive too long, it will abort
        /// so the program won't be stalled
        /// </summary>
        void TakeScreenshotFirefox()
        {
            string newUrl = currentUrl.Replace(":", "").Replace("/", "").Replace("?", "").Replace("%", "");

            string name = "OS;" + operatingSystem + ";BR;" + browserVersion + ";SS;" + newXResolution + ";CD;" + colorDepth + ";URL;" + newUrl + ";";
            string folder = screenShotPath;
            if (name.Length + folder.Length >= GetMaxFolderNameSize() + 1)
                name = name.Substring(0, GetMaxFolderNameSize() - folder.Length);
            name += ".png";
            string commandArguments = operatingSystem + " " + browserVersion + " " + newXResolution + " " + colorDepth + " " + newUrl; ;

            bool success = TakeFullScreenShot(currentUrl, name);
            if (!success)
                TakeScreenShotBackup(commandArguments);
        }


        /// <summary>
        ///  When a backup screenshot needs to be taken, this method gets
        ///  the command line arguments for that exe
        /// </summary>
        /// <param name="url"></param>
        /// <returns></returns>
        string GetCommandArgumentsForTakeScreenShot(string url)
        {
            string commandArguments = string.Empty;

            string browser = browserVersion.Replace("IExplore", "IE");

            string ActiveScriptSetting = newActiveScriptSetting == 0 ? "Enabled" : "Disabled";
            string ActiveXSetting = newActiveXSetting == 0 ? "Enabled" : "Disabled";
            string WarnOnZoneCrossing = warnOnZoneCrossing == 1 ? "Yes" : "No";
            string LimitedUserPrivileges = limitedUserPrivileges ? "Yes" : "No";
            string sTextSize = textSize > 2 ? "L" : (textSize == 2 ? "M" : "S");

            commandArguments = operatingSystem + " " + browser + " " + newXResolution + " " + colorDepth + " " + ActiveScriptSetting + " " + ActiveXSetting + " " + disableScriptDebugging + " " + errorDlgDisplayedOnEveryError + " " + WarnOnZoneCrossing + " " + zoom.ToString().Substring(0, 1) + " " + sTextSize + " " + LimitedUserPrivileges + " " + url;

            return commandArguments;
        }

        /// <summary>
        /// Calls the BackupScreenShot process
        /// </summary>
        /// <param name="arguments"></param>
        void RunTakeScreenShotProcess(string arguments)
        {
            Process p = new Process();
            p.StartInfo.FileName = GetScreenShotBackupPath();
            p.StartInfo.CreateNoWindow = true;
            p.StartInfo.Arguments = arguments;
            p.Start();
        }

        /// <summary>
        /// Calls the Chres process to modify the screen size
        /// </summary>
        /// <param name="arguments"></param>
        void RunModifyScreenSizeProcess(string arguments)
        {
            string ScreenResolution = GetChresPath();
            Process p = new Process();
            p.StartInfo.FileName = ScreenResolution;
            p.StartInfo.Arguments = arguments;
            p.StartInfo.CreateNoWindow = true;
            p.Start();
        }

        /// <summary>
        /// Opens the browser and takes a full page screen shot
        /// </summary>
        /// <param name="url"></param>
        /// <param name="commandArguments"></param>
        /// <returns></returns>
        public bool OpenBrowserAndTakeFullScreenShot(string url, string commandArguments)
        {
            string browser1 = browserVersion.Replace("IExplore", "IE");
            string ActiveScriptSetting = newActiveScriptSetting == 0 ? "Enabled" : "Disabled";
            string ActiveXSetting = newActiveXSetting == 0 ? "Enabled" : "Disabled";
            string WarnOnZoneCrossing = warnOnZoneCrossing == 1 ? "Yes" : "No";
            string LimitedUserPrivileges = limitedUserPrivileges ? "Yes" : "No";
            string sTextSize = textSize > 2 ? "L" : (textSize == 2 ? "M" : "S");

            string newUrl = url.Replace(":", "").Replace("/", "").Replace("?", "").Replace("%", "");

            string name = "OS;" + operatingSystem + ";BR;" + browser1 + ";SS;" + newXResolution + ";CD;" + colorDepth + ";JV;" + ActiveScriptSetting[0] + ";AX;" + ActiveXSetting[0] + ";DSC;" + disableScriptDebugging[0] + ";DED;" + errorDlgDisplayedOnEveryError[0] + ";WZC;" + WarnOnZoneCrossing[0] + ";Z;" + zoom.ToString().Substring(0, 1) + ";TS;" + sTextSize + ";LUP;" + LimitedUserPrivileges[0] + ";URL;" + newUrl + ";";
            string folder = screenShotPath;
            if (name.Length + folder.Length >= GetMaxFolderNameSize() + 1)
                name = name.Substring(0, GetMaxFolderNameSize() - folder.Length);
            name += ".png";

            if (limitedUserPrivileges)
            {
                if (browserVersion.StartsWith("IExplore"))
                {
                    Process.Start("psexec", "-l " + GetIExplorePath() + " " + url);
                    Thread.Sleep(webPageGrabberDelay * 1000);
                    TakeScreenShotBackup(commandArguments);
                }
                else if (browserVersion.StartsWith("Firefox"))
                {
                    Process.Start("psexec", "-l " + GetFirefoxPath() + " " + url);
                    Thread.Sleep(webPageGrabberDelay * 1000);
                    TakeScreenShotBackup(commandArguments);
                }
                return true;
            }

            bool success = TakeFullScreenShot(url, name);

            if (success)
            {
                RunDeleteBrowsersProcess("iexplore");
                Thread.Sleep(10000);
            }

            return success;

        }

        /// <summary>
        /// Take a full page screen shot for this url
        /// </summary>
        /// <param name="url">url of the screenshot to be taking</param>
        /// <param name="name">name that will be given to the image</param>
        /// <returns></returns>
        public bool TakeFullScreenShot(string url, string name)
        {
            bool success = true;

            GrabberOptions opts = GrabberOptions.Default;
            string folder = screenShotPath;
            opts.Outputfile = folder + name;
            opts.Delay = webPageGrabberDelay;
            opts.ShowTitle = false;
            int urlDelay = GetUrlDelay(url);
            if (urlDelay != -1)
                opts.Delay = urlDelay;

            try
            {
                if (browserVersion.StartsWith("IExplore"))
                {
                    if (!browserVersion.Contains("7"))
                        opts.ShowTitle = false;
                    Console.WriteLine("Starting full page screen shot");
                    BrowserControlDriver.Ie7Driver.FullPageScreenShot(url, opts);
                    Console.WriteLine("Finishing full page screen shot");
                }
                else if (browserVersion.StartsWith("Firefox"))
                    BrowserControlDriver.Firefox3Driver.FullPageScreenShot(url, opts);
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
                Console.WriteLine(ex.StackTrace);
                Console.WriteLine(DateTime.Now);
                success = false;
            }

            return success;
        }

        /// <summary>
        /// Close the browsers after the screenshots have been taken
        /// </summary>
        /// <param name="processName"></param>
        void RunDeleteBrowsersProcess(string processName)
        {
            Process[] processes = Process.GetProcessesByName(processName);
            foreach (Process p in processes)
            {
                try
                {
                    p.Kill();
                }
                catch (Exception Ex)
                {
                    Console.WriteLine(Ex.Message);
                }
            }
        }

        /// <summary>
        /// Gets the delay that the browser will have time to open
        /// </summary>
        /// <param name="url"></param>
        /// <returns></returns>
        int GetUrlDelay(string url)
        {
            foreach (UrlDelay ud in urlWithDelay)
            {
                if (ud.Url == url)
                {
                    uint Num;
                    bool isNum = uint.TryParse(ud.Delay, out Num);
                    if (!isNum)
                        return -1;
                    return Convert.ToInt32(ud.Delay);
                }
            }
            return -1;
        }
        /// <summary>
        /// Get values from App.config
        /// </summary>
        /// <returns></returns>
        string GetRegistryScreenSizeXNodes()
        {
            return ConfigurationSettings.AppSettings["RegistryScreenSizeXNodes"];
        }
        string GetRegistryScreenSizeYNodes()
        {
            return ConfigurationSettings.AppSettings["RegistryScreenSizeYNodes"];
        }
        string GetRegistryColorDepthNodes()
        {
            return ConfigurationSettings.AppSettings["RegistryColorDepthNodes"];
        }
        string GetRegistryJavaScriptNodes()
        {
            return ConfigurationSettings.AppSettings["RegistryJavaScriptNodes"];
        }
        string GetRegistryActiveXNodes()
        {
            return ConfigurationSettings.AppSettings["RegistryActiveXNodes"];
        }
        string GetRegistryDisableScriptDebuggingNodes()
        {
            return ConfigurationSettings.AppSettings["RegistryDisableScriptDebuggingNodes"];
        }
        string GetRegistryDisplayErrorDialogNode()
        {
            return ConfigurationSettings.AppSettings["RegistryDisplayErrorDialogNodes"];
        }
        string GetRegistryWarnOnZoneCrossingNodes()
        {
            return ConfigurationSettings.AppSettings["RegistryWarnOnZoneCrossingNodes"];
        }
        string GetRegistryZoomNodes()
        {
            return ConfigurationSettings.AppSettings["RegistryZoomNodes"];
        }
        string GetRegistryTextSizeNodes()
        {
            return ConfigurationSettings.AppSettings["RegistryTextSizeNodes"];
        }
        string GetRegistryLimitedUserPrivilegesNodes()
        {
            return ConfigurationSettings.AppSettings["RegistryLimitedUserPrivilegesNodes"];
        }
        string GetRegistryFile()
        {
            return ConfigurationSettings.AppSettings["RegistryFile"];
        }
        string GetFlashVersion()
        {
            return ConfigurationSettings.AppSettings["FlashVersion"];
        }
        string GetmUrlFile()
        {
            return ConfigurationSettings.AppSettings["UrlFile"];
        }
        string GetChresPath()
        {
            return ConfigurationSettings.AppSettings["ChresPath"];
        }
        string GetIExplorePath()
        {
            return ConfigurationSettings.AppSettings["IExplorePath"];
        }
        string GetFirefoxPath()
        {
            return ConfigurationSettings.AppSettings["FirefoxPath"];
        }
        string GetScreenShotBackupPath()
        {
            return ConfigurationSettings.AppSettings["ScreenShotBackupPath"];
        }
        string GetUrlGroupNodes()
        {
            return ConfigurationSettings.AppSettings["UrlGroupNodes"];
        }
        int GetMaxFolderNameSize()
        {
            return Convert.ToInt32(ConfigurationSettings.AppSettings["MaxFolderNameSize"]);
        }
        static string GetErrorBitmap()
        {
            return ConfigurationSettings.AppSettings["mErrorBitmap"];
        }
    }

    /// <summary>
    /// This class is store the delay for each url
    /// </summary>
    internal class UrlDelay
    {
        string url;
        string delay;

        public UrlDelay(string url, string delay)
        {
            this.url = url;
            this.delay = delay;
        }
        public string Url
        {
            get { return url; }
        }
        public string Delay
        {
            get { return delay; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\BrowserShots\BrowserShots\BrowserShots\Program.cs ===
﻿using System;
using System.Xml;
using System.IO;
using System.Configuration;

// path to IE and Firefox may vary from computer to computer.
// Use MSI to install

namespace Test.Common.Utilities.BrowserShots.BrowserShots
{
    // This program takes full page screen shots of urls that are stored in an xml file
    internal class Program
    {
        static int Main(string[] args)
        {
            int returnValue = 0;
            // return -1 if failure, else 0
            string machineName = string.Empty; //name of the host computer that will take the browser shots
            string operatingSystem = string.Empty; // operating system on that computer
            string browser = string.Empty; // browser to be used when taking screen shots
            int webPageGrabberDelay = 0; // time browser will have to open before screen shot is taken
            int rank = 0; // rank for this computer. Used if there are 2 computers with the same os and browser, so they can divide up the screen shots.
            int totalMachines = 0; // total number of machines with this os and browser
            string path = string.Empty; // path where the xml files are stored
            string screenShotPath = string.Empty; // path where the screenshots will be stored.
            bool success; // exit if this machine isn't stored in the machine.xml file at the path above
            XmlDocument xDoc;
            BrowserShot browserShot; //Instance of the browser shot class.
            try
            {
                machineName = System.Environment.MachineName;
                path = GetPath();
                screenShotPath = GetScreenShotPath();
                xDoc = GetXmlDoc(path);
                success = GetMachineValues(xDoc, machineName, ref operatingSystem, ref browser, ref webPageGrabberDelay);
                if (!success)
                {
                    Logging.WriteToLog("This machine is not listed at the website", "Log.txt");
                    return -1;
                }
                GetMachineRank(xDoc, machineName, operatingSystem, browser, ref rank, ref totalMachines);
                browserShot = new BrowserShot(webPageGrabberDelay, machineName, operatingSystem, browser, path, rank, totalMachines, screenShotPath);
                browserShot.Start();
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
                Console.WriteLine(ex.StackTrace);
                returnValue = -1;
                Logging.WriteToLog(ex.Message + "\r\n" + ex.StackTrace, "Log.txt");
            }
            finally
            {
                try
                {
                    XmlDocument xQueueDoc = new XmlDocument();
                    xQueueDoc.Load(GetPath() + GetQueueFile());
                    XmlNode currentNode = xQueueDoc.SelectSingleNode(@"//current");
                    foreach (XmlNode node in currentNode.ChildNodes)
                    {
                        if (node.Attributes["OS"].Value == operatingSystem && node.Attributes["Browser"].Value == browser)
                        {
                            currentNode.RemoveChild(node);
                            break;
                        }
                    }
                    xQueueDoc.Save(GetPath() + GetQueueFile());
                }
                catch (Exception ex)
                {
                    Console.WriteLine(ex.Message);
                    Console.WriteLine(ex.StackTrace);
                    Logging.WriteToLog(ex.Message + "\r\n" + ex.StackTrace, "Log.txt");
                }
            }
            return returnValue;
        }

        /// <summary>
        /// Gets the XML document with the properties for the computer where this program is running
        /// </summary>
        /// <param name="path"></param>
        /// <returns></returns>
        static XmlDocument GetXmlDoc(string path)
        {
            string folder = path;
            XmlDocument xDoc = new XmlDocument();
            try
            {
                xDoc.Load(folder + GetMachineNameFile());
            }
            catch (Exception e)
            {
                Logging.WriteToLog(e.Message, "Log.txt");
            }
            return xDoc;
        }

        /// <summary>
        /// Gets the values for this machine from xml file, such as which browser to use
        /// </summary>
        /// <param name="xDoc"></param>
        /// <param name="machineName"></param>
        /// <param name="operatingSystem"></param>
        /// <param name="browser"></param>
        /// <param name="webPageGrabberDelay"></param>
        /// <returns></returns>
        static bool GetMachineValues(XmlDocument xDoc, string machineName, ref string operatingSystem, ref string browser, ref int webPageGrabberDelay)
        {
            string browserCurrent = string.Empty;
            try
            {
                XmlDocument xQueueDoc = new XmlDocument();
                xQueueDoc.Load(GetPath() + GetQueueFile());
                XmlNode currentNode = xQueueDoc.SelectSingleNode(@"//current");
                foreach (XmlNode node in currentNode.ChildNodes)
                {
                    if (node.Attributes["MachineName"].Value.ToLower() == machineName.ToLower())
                    {
                        browserCurrent = node.Attributes["Browser"].Value;
                        break;
                    }
                }

            }
            catch (Exception ex)
            {
                Logging.WriteToLog(ex.Message, "Log.txt");
            }
            bool foundABrowser = false;

            XmlNodeList nodes = xDoc.SelectNodes(GetMachineNodes());
            XmlNode parentNode = xDoc.SelectSingleNode(GetRemoteClientNode());
            foreach (XmlNode node in nodes)
            {
                if (node.Attributes["Name"].Value.ToUpper() == machineName.ToUpper())
                {
                    operatingSystem = node.Attributes["OperatingSystem"].Value;
                    browser = node.Attributes["Browser"].Value;
                    webPageGrabberDelay = Convert.ToInt32(node.Attributes["Delay"].Value);
                    foundABrowser = true;
                    if (browser.ToLower() == browserCurrent.ToLower())
                        return true;
                }
            }
            return foundABrowser;
        }
        /// <summary>
        /// If more than one machine is running with the same OS and Browser, then ranked so that the URLs are divided up between them.
        /// </summary>
        /// <param name="xDoc"></param>
        /// <param name="machineName"></param>
        /// <param name="operatingSystem"></param>
        /// <param name="browser"></param>
        /// <param name="rank"></param>
        /// <param name="totalMachines"></param>
        static void GetMachineRank(XmlDocument xDoc, string machineName, string operatingSystem, string browser, ref int rank, ref int totalMachines)
        {
            totalMachines = 0;
            XmlNodeList nodes = xDoc.SelectNodes(GetMachineNodes());
            foreach (XmlNode node in nodes)
            {
                if (node.Attributes["OperatingSystem"].Value.ToUpper() == operatingSystem.ToUpper() && node.Attributes["Browser"].Value.ToUpper() == browser.ToUpper())
                {
                    totalMachines++;
                    if (node.Attributes["Name"].Value.ToUpper() == machineName.ToUpper())
                    {
                        rank = totalMachines;
                    }
                }
            }
        }

        /// <summary>
        /// Get values from App.config
        /// </summary>
        /// <returns></returns>
        static string GetPath()
        {
            return ConfigurationSettings.AppSettings["Path"];
        }
        static string GetQueueFile()
        {
            return ConfigurationSettings.AppSettings["BrowserShotsQueueFile"];
        }
        static string GetScreenShotPath()
        {
            return ConfigurationSettings.AppSettings["ScreenShotPath"];
        }
        static string GetMachineNameFile()
        {
            return ConfigurationSettings.AppSettings["MachineNameFile"];
        }
        static string GetMachineNodes()
        {
            return ConfigurationSettings.AppSettings["MachineNodes"];
        }
        static string GetRemoteClientNode()
        {
            return ConfigurationSettings.AppSettings["RemoteClientNode"];
        }
    }

    class Logging
    {
        /// <summary>
        /// Writes out exceptions to the log file
        /// </summary>
        /// <param name="logMessage">Message including date</param>
        /// <param name="logFile">Path of the log file</param>
        public static void WriteToLog(String logMessage, string logFile)
        {
            try
            {
                using (StreamWriter stWriter = File.AppendText(logFile))
                {
                    stWriter.Write("\r\nLog Entry : ");
                    stWriter.WriteLine("Date: {0} {1}", DateTime.Now.ToLongTimeString(),
                        DateTime.Now.ToLongDateString());
                    stWriter.WriteLine(logMessage);
                    stWriter.WriteLine("-------------------------------");
                    // Update the underlying file.
                    stWriter.Flush();
                    stWriter.Close();
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine(ex.Message);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\BrowserShots\BrowserShotsService\BrowserShotsService\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("BrowserShotsService")]
[assembly: AssemblyDescription("")]
//[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("MSIT")]
//[assembly: AssemblyProduct("BrowserShots")]
//[assembly: AssemblyCopyright("Copyright © MSIT 2008")]
//[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("570c6970-30cc-4e2a-b44b-9a5a100da26e")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
//[assembly: AssemblyVersion("1.0.0.0")]
//[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\BrowserShots\BrowserShots\BrowserShots\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("BrowserShots")]
[assembly: AssemblyDescription("")]
//[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("MSIT")]
//[assembly: AssemblyProduct("BrowserShots")]
//[assembly: AssemblyCopyright("Copyright © MSIT 2008")]
//[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("7bba4dd6-f6f5-49ed-bca6-cca3ef14ac07")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
//[assembly: AssemblyVersion("1.0.0.0")]
//[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\BrowserShots\BrowserShotsService\BrowserShotsService\Program.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Xml;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Configuration;
using System.IO;

namespace Test.Common.Utilities.BrowserShotsService
{
    class Program
    {
        #region Console Window property stuff
        [DllImport("kernel32.dll", ExactSpelling = true)]
        private static extern IntPtr GetConsoleWindow();

        private static IntPtr ThisConsole = GetConsoleWindow();

        [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        private static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);
        private const int HIDE = 0;

        #endregion
        static void Main(string[] args)
        {
            int sleepAfterProcessStarts = GetSleepAfterProcessStarts();
            int sleepIfProcessRunning = GetSleepIfProcessRunning();
            ShowWindow(ThisConsole, HIDE); //Hides Console Window
            while (true)
            {
                if (!IsProcessOpen("browsershots"))
                {
                    GetFirstInQueue();
                    System.Threading.Thread.Sleep(sleepAfterProcessStarts);
                }
                else
                {
                    System.Threading.Thread.Sleep(sleepIfProcessRunning);
                }
            }
        }

        static void GetFirstInQueue()
        {
            try
            {
                string machineName = System.Environment.MachineName;
                string urlGroups = string.Empty;
                string os = string.Empty;
                string browser = string.Empty;
                XmlDocument xDoc = new XmlDocument();
                xDoc.Load(GetPath() + GetFile());
                XmlNodeList nodes = xDoc.SelectNodes(GetQueueNodes());
                DateTime oldestDate = DateTime.Now.AddDays(1);
                DateTime currentDate = DateTime.Now.AddDays(1);
                foreach (XmlNode node in nodes)
                {
                    if (machineName.ToLower() == node.Attributes["MachineName"].Value.ToLower())
                    {
                        currentDate = Convert.ToDateTime(node.Attributes["Date"].Value);
                        if (currentDate < oldestDate)
                            oldestDate = currentDate;
                    }
                }
                // If a node exists, copy over the registry values to Registry.xml and
                // then delete that node before starting the process.
                XmlNode nodeToBeDeleted = null;
                foreach (XmlNode node in nodes)
                {
                    if (machineName.ToLower() == node.Attributes["MachineName"].Value.ToLower() && oldestDate == Convert.ToDateTime(node.Attributes["Date"].Value))
                    {
                        XmlDocument xDocReg = new XmlDocument();
                        xDocReg.Load(GetPath() + GetRegistryFile());
                        XmlNode regNode = xDocReg.SelectSingleNode(@"//Registry");
                        regNode.RemoveAll();
                        foreach (XmlNode childNode in node.ChildNodes)
                        {
                            if (childNode.Name == "Registry")
                            {
                                foreach (XmlNode grandChildNode in childNode)
                                {
                                    XmlNode tempNode = grandChildNode;
                                    XmlNode nodeDest = xDocReg.ImportNode(tempNode, true);
                                    regNode.AppendChild(nodeDest);
                                }
                            }
                            else if (childNode.Name == "UrlGroups")
                            {
                                XmlDocument xUrlDoc = new XmlDocument();
                                xUrlDoc.Load(GetPath() + GetUrlFile());
                                XmlNodeList groupNodes = xUrlDoc.SelectNodes(GetUrlGroupNodes());
                                foreach (XmlNode groupNode in groupNodes)
                                {
                                    groupNode.Attributes["active"].Value = "false";
                                    foreach (XmlNode grandchildNode in childNode)
                                    {
                                        if (grandchildNode.InnerText == groupNode.Attributes["group"].Value)
                                        {
                                            urlGroups += grandchildNode.InnerText + ",";
                                            groupNode.Attributes["active"].Value = "true";
                                        }
                                    }
                                }
                                urlGroups = urlGroups.Substring(0, urlGroups.Length - 1);
                                xUrlDoc.Save(GetPath() + GetUrlFile());
                            }
                        }
                        xDocReg.Save(GetPath() + GetRegistryFile());
                        nodeToBeDeleted = node;
                        break;
                    }
                }
                if (nodeToBeDeleted != null)
                {
                    // first add it to the currently running requests
                    //XmlNode currentNode = xDoc.SelectSingleNode(GetCurrentRequestsNode());
                    XmlNode currentNode = xDoc.SelectSingleNode(@"//current");
                    XmlElement itemNode = xDoc.CreateElement("item");
                    for (int i = 0; i < nodeToBeDeleted.Attributes.Count; i++)
                    {
                        itemNode.SetAttribute(nodeToBeDeleted.Attributes[i].Name, nodeToBeDeleted.Attributes[i].Value);
                        if (nodeToBeDeleted.Attributes[i].Name == "OS")
                            os = nodeToBeDeleted.Attributes[i].Value;
                        if (nodeToBeDeleted.Attributes[i].Name == "Browser")
                            browser = nodeToBeDeleted.Attributes[i].Value;
                    }
                    itemNode.SetAttribute("StartTime", DateTime.Now.ToString());
                    itemNode.SetAttribute("UrlGroups", urlGroups);
                    foreach (XmlNode node in currentNode.ChildNodes)
                    {
                        if (node.Attributes["OS"].Value == os && node.Attributes["Browser"].Value == browser)
                        {
                            currentNode.RemoveChild(node);
                            break;
                        }
                    }
                    currentNode.AppendChild(itemNode);
                    // delete it from the queue
                    XmlNode parentNode = nodeToBeDeleted.ParentNode;
                    parentNode.RemoveChild(nodeToBeDeleted);
                    xDoc.Save(GetPath() + GetFile());
                    string exePath = GetExePath();
                    Process.Start(exePath);
                }
            }
            catch (Exception ex)
            {
                using (StreamWriter w = File.AppendText(GetLogFile()))
                {
                    Log(ex.Message + "\r\n" + ex.StackTrace, w);
                    w.Close();
                }
            }
        }

        public static bool IsProcessOpen(string name)
        {
            foreach (Process clsProcess in Process.GetProcesses())
            {
                if (clsProcess.ProcessName.ToLower().Contains(name.ToLower()) && !clsProcess.ProcessName.ToLower().Contains("browsershotsservice"))
                {
                    return true;
                }
            }
            return false;
        }
        static string GetFile()
        {
            return ConfigurationSettings.AppSettings["mBrowserShotsQueue"].ToString();
        }
        static string GetPath()
        {
            return ConfigurationSettings.AppSettings["mPath"].ToString();
        }
        static string GetRegistryFile()
        {
            return ConfigurationSettings.AppSettings["mRegistryFile"].ToString();
        }
        static string GetMachineNameFile()
        {
            return ConfigurationSettings.AppSettings["mMachineNameFile"].ToString();
        }
        static string GetMachineNodes()
        {
            return ConfigurationSettings.AppSettings["mMachineNodes"].ToString();
        }
        static string GetQueueNodes()
        {
            return ConfigurationSettings.AppSettings["mQueueNodes"].ToString();
        }
        public static string GetCurrentRequestsNode()
        {
            return ConfigurationSettings.AppSettings["mCurrentRequestsNode"].ToString();
        }
        static string GetUrlFile()
        {
            return ConfigurationSettings.AppSettings["UrlFile"].ToString();
        }
        static string GetUrlGroupNodes()
        {
            return ConfigurationSettings.AppSettings["UrlGroupNodes"].ToString();
        }
        static string GetExePath()
        {
            return ConfigurationSettings.AppSettings["mExePath"].ToString();
        }
        static string GetLogFile()
        {
            return ConfigurationSettings.AppSettings["LogFile"].ToString();
        }
        static int GetMaxFileSize()
        {
            return Convert.ToInt32(ConfigurationSettings.AppSettings["LogFileMaxSize"].ToString());
        }
        static int GetSleepAfterProcessStarts()
        {
            return Convert.ToInt32(ConfigurationSettings.AppSettings["SleepAfterProcessStarts"].ToString());
        }
        static int GetSleepIfProcessRunning()
        {
            return Convert.ToInt32(ConfigurationSettings.AppSettings["SleepIfProcessRunning"].ToString());
        }
        public static void Log(String logMessage, TextWriter w)
        {
            try
            {
                FileStream fs = new FileStream(GetLogFile(), FileMode.Open);
                long length = fs.Length;
                fs.Close();

                if (length > GetMaxFileSize())
                {
                    File.Delete(GetLogFile());
                    fs = File.Create(GetLogFile());
                    fs.Close();
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message + "\r\n" + ex.StackTrace);
            }
            w.Write("\r\nLog Entry : ");
            w.WriteLine("Date: {0} {1}", DateTime.Now.ToLongTimeString(),
                DateTime.Now.ToLongDateString());
            w.WriteLine(logMessage);
            w.WriteLine("-------------------------------");
            // Update the underlying file.
            w.Flush();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\BrowserShots\BrowserShotsWebsite\BrowserShotsWebsite\Default.aspx.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Collections;
using System.IO;
using System.Xml;

namespace Test.Common.Utilities.BrowserShotsWebsite
{
    // This class is used for viewing the browser shots
    public partial class Default : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {
            if (!IsPostBack)
            {
                InsertUrls();
                InsertGroups();
                InsertRegistryValues();
            }
            ShowMachinesAndBrowsers();
            MaintainScrollPositionOnPostBack = true;
        }

        /// <summary>
        /// Submit button to display image of selected url
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void btnSubmit_Click(object sender, EventArgs e)
        {
            string selectedUrl = ddlURL.SelectedValue;
            DisplayImageOfTheSelectedUrl(selectedUrl);
        }

        /// <summary>
        /// Gets all the registry values from the xml file
        /// </summary>
        void InsertRegistryValues()
        {
            string folder = Paths.GetFilesPath();
            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(folder + Paths.GetRegistryFile());

            XmlNode screenSizeXNode = xDoc.SelectSingleNode(Paths.GetRegistryScreenSizeXNodes());
            ddlScreenSize.Items.Clear();
            foreach (XmlNode node in screenSizeXNode.ChildNodes)
            {
                ddlScreenSize.Items.Add(node.InnerText);
            }
            ddlScreenSize.Items.Add("All");
            XmlNode colorDepthNode = xDoc.SelectSingleNode(Paths.GetRegistryColorDepthNodes());
            ddlColorDepth.Items.Clear();
            foreach (XmlNode node in colorDepthNode.ChildNodes)
            {
                ddlColorDepth.Items.Add(node.InnerText);
            }
            ddlColorDepth.Items.Add("Both");
            XmlNode javaScriptNode = xDoc.SelectSingleNode(Paths.GetRegistryJavaScriptNodes());
            ddlJavascript.Items.Clear();
            foreach (XmlNode node in javaScriptNode.ChildNodes)
            {
                ddlJavascript.Items.Add(node.InnerText);
            }
            ddlJavascript.Items.Add("Both");
            XmlNode activeXNode = xDoc.SelectSingleNode(Paths.GetRegistryActiveXNodes());
            ddlActiveX.Items.Clear();
            foreach (XmlNode node in activeXNode.ChildNodes)
            {
                ddlActiveX.Items.Add(node.InnerText);
            }
            ddlActiveX.Items.Add("Both");
            XmlNode disableScriptDebuggingNode = xDoc.SelectSingleNode(Paths.GetRegistryDisableScriptDebuggingNodes());
            ddlDisableScriptDebugging.Items.Clear();
            foreach (XmlNode node in disableScriptDebuggingNode.ChildNodes)
            {
                ddlDisableScriptDebugging.Items.Add(node.InnerText);
            }
            ddlDisableScriptDebugging.Items.Add("Both");
            XmlNode displayErrorDialogNode = xDoc.SelectSingleNode(Paths.GetRegistryDisplayErrorDialogNodes());
            ddlDisplayErrorDialog.Items.Clear();
            foreach (XmlNode node in displayErrorDialogNode.ChildNodes)
            {
                ddlDisplayErrorDialog.Items.Add(node.InnerText);
            }
            ddlDisplayErrorDialog.Items.Add("Both");
            XmlNode warnOnZoneCrossingNode = xDoc.SelectSingleNode(Paths.GetRegistryWarnOnZoneCrossingNodes());
            ddlWarnOnZoneCrossing.Items.Clear();
            foreach (XmlNode node in warnOnZoneCrossingNode.ChildNodes)
            {
                ddlWarnOnZoneCrossing.Items.Add(node.InnerText);
            }
            ddlWarnOnZoneCrossing.Items.Add("Both");
            XmlNode limitedUserPrivilegesNode = xDoc.SelectSingleNode(Paths.GetRegistryLimitedUserPrivilegesNodes());
            ddlLimitedUserPrivileges.Items.Clear();
            foreach (XmlNode node in limitedUserPrivilegesNode.ChildNodes)
            {
                ddlLimitedUserPrivileges.Items.Add(node.InnerText);
            }
        }
        /// <summary>
        /// This method will display the image of the selected url
        /// </summary>
        /// <param name="selectedUrl"></param>
        /// <returns>Number of items displayed</returns>
        int DisplayImageOfTheSelectedUrl(string selectedUrl)
        {
            ArrayList fileNames = new ArrayList();
            string operatingSystem = string.Empty;
            string browser = string.Empty;
            ArrayList alOperatingSystem = new ArrayList();
            string sOperatingSystem;

            foreach (Control control in phMachines.Controls)
            {
                Console.WriteLine(control.ID);
                if (control.ID != null && control.ID.StartsWith("cbl") && control is CheckBoxList)
                {
                    CheckBoxList cbl = (CheckBoxList)control;
                    for (int j = 0; j < cbl.Items.Count; j++)
                    {
                        if (cbl.Items[j].Selected)
                        {
                            sOperatingSystem = cbl.ID.Substring(3) + " " + cbl.Items[j].Text;
                            alOperatingSystem.Add(sOperatingSystem);
                        }
                    }
                }
            }

            string newActiveScriptSetting = ddlJavascript.SelectedValue;
            string newActiveXSetting = ddlActiveX.SelectedValue;
            string disableScriptDebugging = ddlDisableScriptDebugging.SelectedValue;
            string errorDlgDisplayedOnEveryError = ddlDisplayErrorDialog.SelectedValue;
            string warnOnZoneCrossing = ddlWarnOnZoneCrossing.SelectedValue;
            string limitedUserPrivileges = ddlLimitedUserPrivileges.SelectedValue;
            string newXResolution = ddlScreenSize.SelectedValue;
            string colorDepth = ddlColorDepth.SelectedValue;
            string url = selectedUrl.Replace(":", "").Replace("/", "").Replace("?", "").Replace("%", "");

            Label lbUrl = new Label();
            lbUrl.ID = "lbUrl";
            lbUrl.Text = "URL: " + selectedUrl;

            phImages.Controls.Add(new LiteralControl("<br/><br/>"));
            phImages.Controls.Add(lbUrl);
            phImages.Controls.Add(new LiteralControl("<br/>"));

            string[] xRes = newXResolution.Split(' ');
            string[] color = colorDepth.Split(' ');
            ArrayList arrayListxRes = new ArrayList();
            if (xRes[0] == "All")
            {
                foreach (ListItem item in ddlScreenSize.Items)
                {
                    if (item.Text != "All")
                    {
                        string[] aXRes = item.Text.Split(' ');
                        arrayListxRes.Add(aXRes[0]);

                    }
                }
            }
            else
            {
                arrayListxRes.Add(xRes[0]);
            }

            ArrayList arrayListColor = new ArrayList();
            if (color[0] == "Both")
            {
                foreach (ListItem item in ddlColorDepth.Items)
                {
                    if (item.Text != "Both")
                    {
                        string[] aColorDepth = item.Text.Split(' ');
                        arrayListColor.Add(aColorDepth[0]);

                    }
                }
            }
            else
            {
                arrayListColor.Add(color[0]);
            }

            ArrayList arrayListActiveScriptSetting = new ArrayList();
            if (newActiveScriptSetting == "Both")
            {
                foreach (ListItem item in ddlJavascript.Items)
                {
                    if (item.Text != "Both")
                    {
                        string[] aActiveScriptSetting = item.Text.Split(' ');
                        arrayListActiveScriptSetting.Add(aActiveScriptSetting[0]);

                    }
                }
            }
            else
            {
                arrayListActiveScriptSetting.Add(newActiveScriptSetting);
            }

            ArrayList arrayListActiveXSetting = new ArrayList();
            if (newActiveXSetting == "Both")
            {
                foreach (ListItem item in ddlActiveX.Items)
                {
                    if (item.Text != "Both")
                    {
                        string[] aActiveX = item.Text.Split(' ');
                        arrayListActiveXSetting.Add(aActiveX[0]);

                    }
                }
            }
            else
            {
                arrayListActiveXSetting.Add(newActiveXSetting);
            }

            ArrayList arrayListDisableScriptDebugging = new ArrayList();
            if (disableScriptDebugging == "Both")
            {
                foreach (ListItem item in ddlDisableScriptDebugging.Items)
                {
                    if (item.Text != "Both")
                    {
                        string[] aDisableScriptDebugging = item.Text.Split(' ');
                        arrayListDisableScriptDebugging.Add(aDisableScriptDebugging[0]);
                    }
                }
            }
            else
            {
                arrayListDisableScriptDebugging.Add(disableScriptDebugging);
            }

            ArrayList arrayListErrorDlgDisplayedOnEveryError = new ArrayList();
            if (errorDlgDisplayedOnEveryError == "Both")
            {
                foreach (ListItem item in ddlDisplayErrorDialog.Items)
                {
                    if (item.Text != "Both")
                    {
                        string[] aErrorDlgDisplayedOnEveryError = item.Text.Split(' ');
                        arrayListErrorDlgDisplayedOnEveryError.Add(aErrorDlgDisplayedOnEveryError[0]);
                    }
                }
            }
            else
            {
                arrayListErrorDlgDisplayedOnEveryError.Add(errorDlgDisplayedOnEveryError);
            }

            ArrayList arrayListWarnOnZoneCrossing = new ArrayList();
            if (warnOnZoneCrossing == "Both")
            {
                foreach (ListItem item in ddlWarnOnZoneCrossing.Items)
                {
                    if (item.Text != "Both")
                    {
                        string[] aWarnOnZoneCrossing = item.Text.Split(' ');
                        arrayListWarnOnZoneCrossing.Add(aWarnOnZoneCrossing[0]);
                    }
                }
            }
            else
            {
                arrayListWarnOnZoneCrossing.Add(warnOnZoneCrossing);
            }

            ArrayList arrayListLimitedUserPrivileges = new ArrayList();
            if (limitedUserPrivileges == "Both")
            {
                foreach (ListItem item in ddlLimitedUserPrivileges.Items)
                {
                    if (item.Text != "Both")
                    {
                        string[] aLimitedUserPrivileges = item.Text.Split(' ');
                        arrayListLimitedUserPrivileges.Add(aLimitedUserPrivileges[0]);
                    }
                }
            }
            else
            {
                arrayListLimitedUserPrivileges.Add(limitedUserPrivileges);
            }

            string name = string.Empty;
            string longName = string.Empty;
            string folder = Paths.GetScreenShotPath();

            foreach (string os in alOperatingSystem)
            {
                foreach (string sXRes in arrayListxRes)
                {
                    foreach (string sColor in arrayListColor)
                    {
                        if (os.Contains("Firefox"))
                        {
                            string[] sOS = os.Split(' ');
                            operatingSystem = sOS[0];
                            browser = sOS[1];
                            name = "OS;" + operatingSystem + ";BR;" + browser + ";SS;" + sXRes + ";CD;" + sColor + ";URL;" + url + ";";
                            longName = "OS: " + operatingSystem + " BR: " + browser + " SS: " + sXRes + " CD: " + sColor;

                            if (name.Length + folder.Length > Convert.ToInt32(Paths.GetMaxLengthFolderName()))
                                name = name.Substring(0, Convert.ToInt32(Paths.GetMaxLengthFolderName()) - folder.Length);

                            fileNames.Add(new names(name, longName));
                            continue;
                        }
                        foreach (string sNewActiveScriptSetting in arrayListActiveScriptSetting)
                        {
                            foreach (string sNewActiveXSetting in arrayListActiveXSetting)
                            {
                                foreach (string sDisableScriptDebugging in arrayListDisableScriptDebugging)
                                {
                                    foreach (string sErrorDlgDisplayedOnEveryError in arrayListErrorDlgDisplayedOnEveryError)
                                    {
                                        foreach (string sWarnOnZoneCrossing in arrayListWarnOnZoneCrossing)
                                        {
                                            foreach (string sLimitedUserPrivileges in arrayListLimitedUserPrivileges)
                                            {
                                                string[] sOS = os.Split(' ');
                                                operatingSystem = sOS[0];
                                                browser = sOS[1];
                                                name = "OS;" + operatingSystem + ";BR;" + browser + ";SS;" + sXRes + ";CD;" + sColor + ";JV;" + sNewActiveScriptSetting[0] + ";AX;" + sNewActiveXSetting[0] + ";DSC;" + sDisableScriptDebugging[0] + ";DED;" + sErrorDlgDisplayedOnEveryError[0] + ";WZC;" + sWarnOnZoneCrossing[0] + ";LUP;" + sLimitedUserPrivileges[0] + ";URL;" + url + ";";
                                                longName = "OS: " + operatingSystem + " BR: " + browser + " SS: " + sXRes + " CD: " + sColor + " JS: " + sNewActiveScriptSetting + " AX: " + sNewActiveXSetting + " DSD: " + sDisableScriptDebugging + " DED: " + sErrorDlgDisplayedOnEveryError + " WZC: " + sWarnOnZoneCrossing + " LUP: " + sLimitedUserPrivileges;

                                                if (name.Length + folder.Length > Convert.ToInt32(Paths.GetMaxLengthFolderName()))
                                                    name = name.Substring(0, Convert.ToInt32(Paths.GetMaxLengthFolderName()) - folder.Length);

                                                fileNames.Add(new names(name, longName));
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            int i = 0;
            string date = string.Empty;
            phImages.Controls.Add(new LiteralControl("<table>"));
            int fileNum = 0, picsPerRow = 1, currentPic = 0;
            if (cbThumbnails.Checked)
                picsPerRow = Convert.ToInt32(ddlPerRow.SelectedValue);
            string resize = ddlThumbnailsResize.SelectedValue;
            int iResize = Convert.ToInt32(resize.Substring(0, resize.Length - 1));
            foreach (names fileName in fileNames)
            {
                date = GetDateOfFile(fileName.Name);
                if (date == null)
                {
                    Label lblNameNotFound = new Label();
                    lblNameNotFound.ID = "lbDate" + i;
                    lblNameNotFound.Text = fileName.LongName + " NOT FOUND";

                    phImages.Controls.Add(new LiteralControl("<br/>"));
                    phImages.Controls.Add(lblNameNotFound);

                    continue;
                }

                Label lbDate = new Label();
                lbDate.ID = "lbDate" + i;
                lbDate.Text = "Date: " + date;

                Label lbName = new Label();
                lbName.ID = "lbDate" + i;
                lbName.Text = fileName.LongName;

                if (cbThumbnails.Checked)
                {
                    System.Drawing.Image FullsizeImage = System.Drawing.Image.FromFile(Paths.GetScreenShotPath() + fileName.Name + ".png");
                    int width = FullsizeImage.Width * iResize / 100;
                    int height = FullsizeImage.Height * iResize / 100;
                    System.Drawing.Image ThumbnailImage = FullsizeImage.GetThumbnailImage(width, height, null, IntPtr.Zero);
                    FullsizeImage.Dispose();
                    System.IO.FileStream fs = System.IO.File.Open(Paths.GetThumbnailPath() + fileName.Name + ".png", FileMode.OpenOrCreate);
                    ThumbnailImage.Save(fs, System.Drawing.Imaging.ImageFormat.Png);
                    fs.Close();
                    ThumbnailImage.Dispose();
                }
                Image im = new Image();
                im.ID = "im" + i;

                im.ImageUrl = Paths.GetImageUrl() + fileName.Name + ".png";
                if (cbThumbnails.Checked)
                {
                    im.ImageUrl = Paths.GetImageUrlThumbnails() + fileName.Name + ".png";
                }

                HyperLink hLink = new HyperLink();
                hLink.ID = "hl" + i;
                hLink.Text = "Show";
                string windowName = "subwindow" + i;
                hLink.NavigateUrl = "javascript:window.open('ShowImage.aspx?FileName=" + fileName.Name + "','" + windowName + "', 'menubar=1,resizable=1, scrollbars=1, width=500,height=500'); void('');";

                if (fileNum % picsPerRow == 0)
                {
                    phImages.Controls.Add(new LiteralControl("<tr>"));
                }
                currentPic++;
                phImages.Controls.Add(new LiteralControl("<td>"));
                phImages.Controls.Add(new LiteralControl("<br/>"));
                phImages.Controls.Add(lbDate);
                phImages.Controls.Add(new LiteralControl("<br/>"));
                phImages.Controls.Add(lbName);
                phImages.Controls.Add(new LiteralControl("<br/>"));
                if (cbThumbnails.Checked)
                {
                    phImages.Controls.Add(hLink);
                    phImages.Controls.Add(new LiteralControl("<br/>"));
                }
                phImages.Controls.Add(im);
                phImages.Controls.Add(new LiteralControl("<br/>"));
                phImages.Controls.Add(new LiteralControl("</td>"));
                if (currentPic == picsPerRow || fileNum + 1 == fileNames.Count)
                {
                    phImages.Controls.Add(new LiteralControl("</tr>"));
                    currentPic = 0;
                }
                i++;
                fileNum++;
            }
            phImages.Controls.Add(new LiteralControl("</table>"));


            return fileNames.Count;
        }


        int DisplayImagesOfAllUrls(int maxNumImages)
        {
            ArrayList fileNames = new ArrayList();
            string operatingSystem = string.Empty;
            string browser = string.Empty;
            ArrayList alOperatingSystem = new ArrayList();
            string sOperatingSystem;

            foreach (Control control in phMachines.Controls)
            {
                Console.WriteLine(control.ID);
                if (control.ID != null && control.ID.StartsWith("cbl") && control is CheckBoxList)
                {
                    CheckBoxList cbl = (CheckBoxList)control;
                    for (int j = 0; j < cbl.Items.Count; j++)
                    {
                        if (cbl.Items[j].Selected)
                        {
                            sOperatingSystem = cbl.ID.Substring(3) + " " + cbl.Items[j].Text;
                            alOperatingSystem.Add(sOperatingSystem);
                        }
                    }
                }
            }

            string newActiveScriptSetting = ddlJavascript.SelectedValue;
            string newActiveXSetting = ddlActiveX.SelectedValue;
            string disableScriptDebugging = ddlDisableScriptDebugging.SelectedValue;
            string errorDlgDisplayedOnEveryError = ddlDisplayErrorDialog.SelectedValue;
            string warnOnZoneCrossing = ddlWarnOnZoneCrossing.SelectedValue;
            string limitedUserPrivileges = ddlLimitedUserPrivileges.SelectedValue;
            string newXResolution = ddlScreenSize.SelectedValue;
            string colorDepth = ddlColorDepth.SelectedValue;

            string[] xRes = newXResolution.Split(' ');
            string[] color = colorDepth.Split(' ');
            ArrayList arrayListxRes = new ArrayList();
            if (xRes[0] == "All")
            {
                foreach (ListItem item in ddlScreenSize.Items)
                {
                    if (item.Text != "All")
                    {
                        string[] aXRes = item.Text.Split(' ');
                        arrayListxRes.Add(aXRes[0]);
                    }
                }
            }
            else
            {
                arrayListxRes.Add(xRes[0]);
            }

            ArrayList arrayListColor = new ArrayList();
            if (color[0] == "Both")
            {
                foreach (ListItem item in ddlColorDepth.Items)
                {
                    if (item.Text != "Both")
                    {
                        string[] aColorDepth = item.Text.Split(' ');
                        arrayListColor.Add(aColorDepth[0]);

                    }
                }
            }
            else
            {
                arrayListColor.Add(color[0]);
            }

            ArrayList arrayListActiveScriptSetting = new ArrayList();
            if (newActiveScriptSetting == "Both")
            {
                foreach (ListItem item in ddlJavascript.Items)
                {
                    if (item.Text != "Both")
                    {
                        string[] aActiveScriptSetting = item.Text.Split(' ');
                        arrayListActiveScriptSetting.Add(aActiveScriptSetting[0]);

                    }
                }
            }
            else
            {
                arrayListActiveScriptSetting.Add(newActiveScriptSetting);
            }

            ArrayList arrayListActiveXSetting = new ArrayList();
            if (newActiveXSetting == "Both")
            {
                foreach (ListItem item in ddlActiveX.Items)
                {
                    if (item.Text != "Both")
                    {
                        string[] aActiveX = item.Text.Split(' ');
                        arrayListActiveXSetting.Add(aActiveX[0]);

                    }
                }
            }
            else
            {
                arrayListActiveXSetting.Add(newActiveXSetting);
            }

            ArrayList arrayListDisableScriptDebugging = new ArrayList();
            if (disableScriptDebugging == "Both")
            {
                foreach (ListItem item in ddlDisableScriptDebugging.Items)
                {
                    if (item.Text != "Both")
                    {
                        string[] aDisableScriptDebugging = item.Text.Split(' ');
                        arrayListDisableScriptDebugging.Add(aDisableScriptDebugging[0]);
                    }
                }
            }
            else
            {
                arrayListDisableScriptDebugging.Add(disableScriptDebugging);
            }

            ArrayList arrayListErrorDlgDisplayedOnEveryError = new ArrayList();
            if (errorDlgDisplayedOnEveryError == "Both")
            {
                foreach (ListItem item in ddlDisplayErrorDialog.Items)
                {
                    if (item.Text != "Both")
                    {
                        string[] aErrorDlgDisplayedOnEveryError = item.Text.Split(' ');
                        arrayListErrorDlgDisplayedOnEveryError.Add(aErrorDlgDisplayedOnEveryError[0]);
                    }
                }
            }
            else
            {
                arrayListErrorDlgDisplayedOnEveryError.Add(errorDlgDisplayedOnEveryError);
            }

            ArrayList arrayListWarnOnZoneCrossing = new ArrayList();
            if (warnOnZoneCrossing == "Both")
            {
                foreach (ListItem item in ddlWarnOnZoneCrossing.Items)
                {
                    if (item.Text != "Both")
                    {
                        string[] aWarnOnZoneCrossing = item.Text.Split(' ');
                        arrayListWarnOnZoneCrossing.Add(aWarnOnZoneCrossing[0]);
                    }
                }
            }
            else
            {
                arrayListWarnOnZoneCrossing.Add(warnOnZoneCrossing);
            }

            ArrayList arrayListLimitedUserPrivileges = new ArrayList();
            if (limitedUserPrivileges == "Both")
            {
                foreach (ListItem item in ddlLimitedUserPrivileges.Items)
                {
                    if (item.Text != "Both")
                    {
                        string[] aLimitedUserPrivileges = item.Text.Split(' ');
                        arrayListLimitedUserPrivileges.Add(aLimitedUserPrivileges[0]);
                    }
                }
            }
            else
            {
                arrayListLimitedUserPrivileges.Add(limitedUserPrivileges);
            }

            string name = string.Empty;
            string longName = string.Empty;
            string folder = Paths.GetScreenShotPath();

            foreach (ListItem item in ddlURL.Items)
            {
                if (fileNames.Count > maxNumImages)
                    break;
                string selectedUrl = item.Text.ToString();
                string url = selectedUrl.Replace(":", "").Replace("/", "").Replace("?", "").Replace("%", "");
                foreach (string os in alOperatingSystem)
                {
                    foreach (string sXRes in arrayListxRes)
                    {
                        foreach (string sColor in arrayListColor)
                        {
                            if (os.Contains("Firefox"))
                            {
                                string[] sOS = os.Split(' ');
                                operatingSystem = sOS[0];
                                browser = sOS[1];
                                name = "OS;" + operatingSystem + ";BR;" + browser + ";SS;" + sXRes + ";CD;" + sColor + ";URL;" + url + ";";
                                longName = "OS: " + operatingSystem + " BR: " + browser + " SS: " + sXRes + " CD: " + sColor;

                                if (name.Length + folder.Length > Convert.ToInt32(Paths.GetMaxLengthFolderName()))
                                    name = name.Substring(0, Convert.ToInt32(Paths.GetMaxLengthFolderName()) - folder.Length);

                                fileNames.Add(new names(name, longName));
                                continue;
                            }
                            foreach (string sNewActiveScriptSetting in arrayListActiveScriptSetting)
                            {
                                foreach (string sNewActiveXSetting in arrayListActiveXSetting)
                                {
                                    foreach (string sDisableScriptDebugging in arrayListDisableScriptDebugging)
                                    {
                                        foreach (string sErrorDlgDisplayedOnEveryError in arrayListErrorDlgDisplayedOnEveryError)
                                        {
                                            foreach (string sWarnOnZoneCrossing in arrayListWarnOnZoneCrossing)
                                            {
                                                foreach (string sLimitedUserPrivileges in arrayListLimitedUserPrivileges)
                                                {
                                                    string[] sOS = os.Split(' ');
                                                    operatingSystem = sOS[0];
                                                    browser = sOS[1];
                                                    name = "OS;" + operatingSystem + ";BR;" + browser + ";SS;" + sXRes + ";CD;" + sColor + ";JV;" + sNewActiveScriptSetting[0] + ";AX;" + sNewActiveXSetting[0] + ";DSC;" + sDisableScriptDebugging[0] + ";DED;" + sErrorDlgDisplayedOnEveryError[0] + ";WZC;" + sWarnOnZoneCrossing[0] + ";LUP;" + sLimitedUserPrivileges[0] + ";URL;" + url + ";";
                                                    longName = "OS: " + operatingSystem + " BR: " + browser + " SS: " + sXRes + " CD: " + sColor + " JS: " + sNewActiveScriptSetting + " AX: " + sNewActiveXSetting + " DSD: " + sDisableScriptDebugging + " DED: " + sErrorDlgDisplayedOnEveryError + " WZC: " + sWarnOnZoneCrossing + " LUP: " + sLimitedUserPrivileges;

                                                    if (name.Length + folder.Length > Convert.ToInt32(Paths.GetMaxLengthFolderName()))
                                                        name = name.Substring(0, Convert.ToInt32(Paths.GetMaxLengthFolderName()) - folder.Length);

                                                    fileNames.Add(new names(name, longName));
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            int i = 0;
            string date = string.Empty;
            phImages.Controls.Add(new LiteralControl("<table>"));
            int fileNum = 0, picsPerRow = 1, currentPic = 0;
            if (cbThumbnails.Checked)
                picsPerRow = Convert.ToInt32(ddlPerRow.SelectedValue);
            string resize = ddlThumbnailsResize.SelectedValue;
            int iResize = Convert.ToInt32(resize.Substring(0, resize.Length - 1));
            foreach (names fileName in fileNames)
            {
                date = GetDateOfFile(fileName.Name);
                if (date == null)
                {
                    Label lblNameNotFound = new Label();
                    lblNameNotFound.ID = "lbDate" + i;
                    lblNameNotFound.Text = fileName.LongName + " NOT FOUND";

                    phImages.Controls.Add(new LiteralControl("<br/>"));
                    phImages.Controls.Add(lblNameNotFound);

                    continue;
                }

                Label lbDate = new Label();
                lbDate.ID = "lbDate" + i;
                lbDate.Font.Size = 10;
                lbDate.Text = "Date: " + date;

                string selectedUrl = fileName.Name.Substring(fileName.Name.IndexOf("URL;") + 4).Replace(";", "");
                selectedUrl = selectedUrl.Substring(selectedUrl.IndexOf("com") + 3);
                Label lbUrl = new Label();
                lbUrl.ID = "lbUrl" + i;
                lbUrl.Font.Size = 10;
                lbUrl.Text = "URL: " + selectedUrl;

                Label lbName = new Label();
                lbName.ID = "lbDate" + i;
                lbName.Font.Size = 10;
                lbName.Text = fileName.LongName;

                if (cbThumbnails.Checked)
                {
                    System.Drawing.Image FullsizeImage = System.Drawing.Image.FromFile(Paths.GetScreenShotPath() + fileName.Name + ".png");
                    int width = FullsizeImage.Width * iResize / 100;
                    int height = FullsizeImage.Height * iResize / 100;
                    System.Drawing.Image ThumbnailImage = FullsizeImage.GetThumbnailImage(width, height, null, IntPtr.Zero);
                    FullsizeImage.Dispose();
                    System.IO.FileStream fs = System.IO.File.Open(Paths.GetThumbnailPath() + fileName.Name + ".png", FileMode.OpenOrCreate);
                    ThumbnailImage.Save(fs, System.Drawing.Imaging.ImageFormat.Png);
                    fs.Close();
                    ThumbnailImage.Dispose();
                }
                Image im = new Image();
                im.ID = "im" + i;

                im.ImageUrl = Paths.GetImageUrl() + fileName.Name + ".png";
                if (cbThumbnails.Checked)
                {
                    im.ImageUrl = Paths.GetImageUrlThumbnails() + fileName.Name + ".png";
                }

                HyperLink hLink = new HyperLink();
                hLink.ID = "hl" + i;
                hLink.Text = "Show";
                string windowName = "subwindow" + i;
                hLink.NavigateUrl = "javascript:window.open('ShowImage.aspx?FileName=" + fileName.Name + "','" + windowName + "', 'menubar=1,resizable=1, scrollbars=1, width=500,height=500'); void('');";

                if (fileNum % picsPerRow == 0)
                {
                    phImages.Controls.Add(new LiteralControl("<tr>"));
                }
                currentPic++;
                phImages.Controls.Add(new LiteralControl("<td>"));
                phImages.Controls.Add(new LiteralControl("<br/>"));
                phImages.Controls.Add(lbDate);
                phImages.Controls.Add(new LiteralControl("<br/>"));
                phImages.Controls.Add(lbUrl);
                phImages.Controls.Add(new LiteralControl("<br/>"));
                phImages.Controls.Add(lbName);
                phImages.Controls.Add(new LiteralControl("<br/>"));
                if (cbThumbnails.Checked)
                {
                    phImages.Controls.Add(hLink);
                    phImages.Controls.Add(new LiteralControl("<br/>"));
                }
                phImages.Controls.Add(im);
                phImages.Controls.Add(new LiteralControl("<br/>"));
                phImages.Controls.Add(new LiteralControl("</td>"));
                if (currentPic == picsPerRow || fileNum + 1 == fileNames.Count)
                {
                    phImages.Controls.Add(new LiteralControl("</tr>"));
                    currentPic = 0;
                }
                i++;
                fileNum++;
            }
            phImages.Controls.Add(new LiteralControl("</table>"));

            return fileNames.Count;
        }

        /// <summary>
        /// Gets date of the image file to be displayed on the webpage
        /// </summary>
        /// <param name="fileName"></param>
        /// <returns></returns>
        string GetDateOfFile(string fileName)
        {
            string date = string.Empty;
            DirectoryInfo di = new DirectoryInfo(Paths.GetDirectoryInfoPath());
            FileInfo[] fileInfo = di.GetFiles();
            foreach (FileInfo file in fileInfo)
            {
                if (file.Name.ToUpper() == (fileName + ".png").ToUpper())
                {
                    date = file.LastWriteTime.ToString();
                    return date;
                }
            }

            return null;
        }

        /// <summary>
        /// Gets all the urls from the xml file and inserts them in the dropdown list
        /// </summary>
        void InsertUrls()
        {
            string folder = Paths.GetFilesPath();
            string url = string.Empty;
            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(folder + Paths.GetUrlFile());

            XmlNodeList nodes = xDoc.SelectNodes(Paths.GetUrlNodes());
            foreach (XmlNode node in nodes)
            {
                url = node.InnerText.ToString();
                ddlURL.Items.Add(url);
            }
        }

        /// <summary>
        /// Gets all the urls from the xml file, filtered by group, and inserts them in the dropdown list
        /// </summary>
        /// <param name="groupValue"></param>
        void InsertUrls(string groupValue)
        {
            ddlURL.Items.Clear();
            if (groupValue == Paths.GetShowAllGroupsPhrase())
            {
                btnShowAllUrls.Visible = false;
                rblNumImages.Visible = false;
                lblNumImages.Visible = false;
                InsertUrls();
                return;
            }
            btnShowAllUrls.Visible = true;
            rblNumImages.Visible = true;
            lblNumImages.Visible = true;
            string folder = Paths.GetFilesPath();
            string url = string.Empty;
            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(folder + Paths.GetUrlFile());

            XmlNodeList nodes = xDoc.SelectNodes("//Urls/urlGroup[@group='" + groupValue + "']/url");
            foreach (XmlNode node in nodes)
            {
                url = node.InnerText.ToString();
                ddlURL.Items.Add(url);
            }
        }

        /// <summary>
        /// Gets all the groups from the xml file and inserts them in the dropdown list
        /// </summary>
        void InsertGroups()
        {
            string folder = Paths.GetFilesPath();
            string group = string.Empty;
            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(folder + Paths.GetUrlFile());

            XmlNodeList nodes = xDoc.SelectNodes(Paths.GetUrlGroupNodes());
            ddlGroups.Items.Add(Paths.GetShowAllGroupsPhrase());
            foreach (XmlNode node in nodes)
            {
                group = node.Attributes["group"].Value;
                ddlGroups.Items.Add(group);
            }
        }

        /// <summary>
        /// Shows all the machines with their browsers from the xml file
        /// </summary>
        void ShowMachinesAndBrowsers()
        {
            string folder = Paths.GetFilesPath();
            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(folder + Paths.GetMachinesFile());

            XmlNodeList nodes = xDoc.SelectNodes(Paths.GetMachineNodes());
            ArrayList configs = new ArrayList();
            ArrayList OpSystems = new ArrayList();
            foreach (XmlNode xNode in nodes)
            {
                string os = xNode.Attributes["OperatingSystem"].Value;
                if (!OpSystems.Contains(os))
                    OpSystems.Add(os);
                string browser = xNode.Attributes["Browser"].Value.Replace("IExplore", "IE");
                string config = os + " " + browser;
                if (!configs.Contains(config))
                    configs.Add(config);
            }
            phMachines.Controls.Add(new LiteralControl("<table><tr>"));
            foreach (string os in OpSystems)
            {
                Label lb = new Label();
                lb.ID = "lbl" + os;
                lb.Text = os;
                lb.Style.Add("font-size", "x-large");
                phMachines.Controls.Add(new LiteralControl("<td valign=\"top\">"));
                phMachines.Controls.Add(lb);
                CheckBoxList cbl = new CheckBoxList();
                cbl.ID = "cbl" + os;
                cbl.Style.Add("font-size", "larger");
                foreach (string sOperatingSystem in configs)
                {
                    if (sOperatingSystem.StartsWith(os))
                    {
                        cbl.Items.Add(new ListItem(sOperatingSystem.Substring(sOperatingSystem.IndexOf(" ") + 1)));
                    }
                }
                phMachines.Controls.Add(cbl);
                phMachines.Controls.Add(new LiteralControl("</td>"));
            }
            phMachines.Controls.Add(new LiteralControl("</tr></table>"));
        }

        /// <summary>
        /// Shows the next url image
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void btnNextUrl_Click(object sender, EventArgs e)
        {
            int count = ddlURL.Items.Count;
            if (ddlURL.SelectedIndex < 0)
                ddlURL.SelectedIndex = 0;
            else
            {
                ddlURL.SelectedIndex = (ddlURL.SelectedIndex + 1) % count;
            }
            string selectedUrl = ddlURL.SelectedValue;
            DisplayImageOfTheSelectedUrl(selectedUrl);
        }

        /// <summary>
        /// Shows the previous url image
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void btnPreviousUrl_Click(object sender, EventArgs e)
        {
            int count = ddlURL.Items.Count;
            int selectedIndex = ddlURL.SelectedIndex - 1;

            if (selectedIndex < 0)
                selectedIndex = count - 1;

            ddlURL.SelectedIndex = selectedIndex;
            string selectedUrl = ddlURL.SelectedValue;
            DisplayImageOfTheSelectedUrl(selectedUrl);
        }

        /// <summary>
        /// Updates the urls based on the group selected
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void ddlGroups_SelectedIndexChanged(object sender, EventArgs e)
        {
            string groupValue = ddlGroups.SelectedValue;
            InsertUrls(groupValue);
        }

        /// <summary>
        /// Shows the images of all urls in the group selected
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void btnShowAllUrls_Click(object sender, EventArgs e)
        {
            int count = 0;
            string maximum = rblNumImages.SelectedValue;
            int maxNumImages = 0;
            if (maximum == "No Limit")
                maxNumImages = 10000;
            else
                maxNumImages = Convert.ToInt32(maximum);
            if (!cbThumbnails.Checked || cbGroupByUrl.Checked)
            {
                foreach (ListItem item in ddlURL.Items)
                {
                    string url = item.Text.ToString();
                    count += DisplayImageOfTheSelectedUrl(url);
                    if (count > maxNumImages)
                        break;
                }
            }
            else
            {
                DisplayImagesOfAllUrls(maxNumImages);
            }
        }

        /// <summary> 
        /// To show controls associated with thumbnails.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        public void ThumbnailsCheck_Clicked(Object sender, EventArgs e)
        {
            if (cbThumbnails.Checked)
            {
                ddlThumbnailsResize.Visible = true;
                cbGroupByUrl.Visible = true;
                lblPerRow.Visible = true;
                ddlPerRow.Visible = true;
            }
            else
            {
                ddlThumbnailsResize.Visible = false;
                cbGroupByUrl.Visible = false;
                lblPerRow.Visible = false;
                ddlPerRow.Visible = false;
            }
        }
    }

    /// <summary>
    /// This class is used for storing images.
    /// Longname is how the url image is stored on the server
    /// Name is how it's displayed on the webpage
    /// </summary>
    class names
    {
        string name;
        string longName;

        public names(string name, string longName)
        {
            this.name = name;
            this.longName = longName;
        }
        public string Name
        {
            get { return name; }
        }
        public string LongName
        {
            get { return longName; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\BrowserShots\BrowserShotsWebsite\BrowserShotsWebsite\Default.aspx.designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Test.Common.Utilities.BrowserShotsWebsite
{
    
    
    public partial class Default {
        
        /// <summary>
        /// lblTitle control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblTitle;
        
        /// <summary>
        /// phMachines control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.PlaceHolder phMachines;
        
        /// <summary>
        /// lblScreenSize control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblScreenSize;
        
        /// <summary>
        /// ddlScreenSize control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DropDownList ddlScreenSize;
        
        /// <summary>
        /// lblColorDepth control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblColorDepth;
        
        /// <summary>
        /// ddlColorDepth control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DropDownList ddlColorDepth;
        
        /// <summary>
        /// lblJavascript control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblJavascript;
        
        /// <summary>
        /// ddlJavascript control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DropDownList ddlJavascript;
        
        /// <summary>
        /// lblActiveX control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblActiveX;
        
        /// <summary>
        /// ddlActiveX control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DropDownList ddlActiveX;
        
        /// <summary>
        /// lblDisableScriptDebugging control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblDisableScriptDebugging;
        
        /// <summary>
        /// ddlDisableScriptDebugging control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DropDownList ddlDisableScriptDebugging;
        
        /// <summary>
        /// lblDisplayErrorDialog control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblDisplayErrorDialog;
        
        /// <summary>
        /// ddlDisplayErrorDialog control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DropDownList ddlDisplayErrorDialog;
        
        /// <summary>
        /// lblWarnOnZoneCrossing control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblWarnOnZoneCrossing;
        
        /// <summary>
        /// ddlWarnOnZoneCrossing control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DropDownList ddlWarnOnZoneCrossing;
        
        /// <summary>
        /// lblLimitedUserPrivileges control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblLimitedUserPrivileges;
        
        /// <summary>
        /// ddlLimitedUserPrivileges control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DropDownList ddlLimitedUserPrivileges;
        
        /// <summary>
        /// lblURL control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblURL;
        
        /// <summary>
        /// ddlURL control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DropDownList ddlURL;
        
        /// <summary>
        /// btnNextUrl control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnNextUrl;
        
        /// <summary>
        /// btnPreviousUrl control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnPreviousUrl;
        
        /// <summary>
        /// lblGroups control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblGroups;
        
        /// <summary>
        /// ddlGroups control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DropDownList ddlGroups;
        
        /// <summary>
        /// btnShowAllUrls control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnShowAllUrls;
        
        /// <summary>
        /// lblNumImages control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblNumImages;
        
        /// <summary>
        /// rblNumImages control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.RadioButtonList rblNumImages;
        
        /// <summary>
        /// btnSubmit control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnSubmit;
        
        /// <summary>
        /// cbThumbnails control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.CheckBox cbThumbnails;
        
        /// <summary>
        /// ddlThumbnailsResize control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DropDownList ddlThumbnailsResize;
        
        /// <summary>
        /// lblPerRow control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblPerRow;
        
        /// <summary>
        /// ddlPerRow control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DropDownList ddlPerRow;
        
        /// <summary>
        /// cbGroupByUrl control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.CheckBox cbGroupByUrl;
        
        /// <summary>
        /// phImages control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.PlaceHolder phImages;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\AppeventParser\AppEventWeb\Common\BasePage.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Security.Principal;
using System.Data;
using System.Drawing;
using System.Diagnostics;
using System.Web;
using System.Data.SqlClient;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Configuration;

namespace AppEventWeb
{
	/// <summary>
	/// Summary description for BasePage.
	/// </summary>
	public class BasePage:System.Web.UI.Page
	{
		protected SqlConnection SQLConnection = null;

		protected enum EventTypes {Service, Source, Computer, Type, ID};

		public BasePage()
		{
			
		}

		override protected void OnInit(EventArgs e)
		{

		}

		override protected void OnUnload(EventArgs e)
		{
			CloseSQL();
		}

		/// <summary>
		/// Initial SQL connection
		/// </summary>
		/// <returns></returns>
		public bool InitSQL()
		{
			return InitSQL(ConfigurationSettings.AppSettings["SQLConnectionString"]);
		}
		public bool InitSQL(string ConnectionString)
		{
			try 
			{
				if (SQLConnection == null)
				{
					SQLConnection = new SqlConnection(ConnectionString);
					SQLConnection.Open();

				}
				return true;
			}
			catch (Exception e)
			{
				Debug.WriteLine(e.Message);
				return false;
			}

		}
		public void CloseSQL()
		{
			if (SQLConnection != null)
			{
				SQLConnection.Close();
				SQLConnection.Dispose();
				SQLConnection = null;
			}
		}
		/// <summary>
		/// 
		/// </summary>
		/// <param name="ServiceName"></param>
		/// <returns></returns>
		public DateTime GetMaxEventDate(string ServiceName, string StartDate, bool IncludeSystemEvents)
		{
			string SQL="select Max(EntryDate) as MaxTime from ApplicationEvents "+
						"inner join Servers on ApplicationEvents.Computer=Servers.ServerName "+
						"inner join ZoneServices on ZoneServices.ID=Servers.ZoneServiceID "+
						"WHERE EntryDate >= '"+StartDate+"' "+
						"AND Source not in (Select Source from ServiceEventFilters where ZoneServiceID=ZoneServices.ID) ";
			if (ServiceName!=null && ServiceName!=string.Empty)
						SQL+="AND ZoneServices.Service='"+ServiceName+"' ";
			if (!IncludeSystemEvents)
				SQL+="and Source not in (Select Source from SystemEventFilters where FilterOut=1) ";

			SqlDataAdapter sqlDA = new SqlDataAdapter(SQL, SQLConnection);
			sqlDA.SelectCommand.CommandTimeout=60*5;
			DataSet sqlDS = new DataSet();
			DataTable dt=null;
			sqlDA.Fill(sqlDS);
			dt=sqlDS.Tables[0];
			if (dt.Rows[0]["MaxTime"] == System.DBNull.Value)
				return Convert.ToDateTime(StartDate);
			else
				return Convert.ToDateTime(dt.Rows[0]["MaxTime"].ToString());
		}
		public SqlDataReader GetHourlyGraphData(DateTime StartDate, string Service, string Source, string Computer, string Type, string EventID,
			bool IncludeSystemEvents, bool IncludeInfo, bool IncludeWarning, bool IncludeError)
		{
			return GetGraphData("GetHourlyGraphData", StartDate, Service, Source, Computer, Type, EventID, IncludeSystemEvents, IncludeInfo, IncludeWarning, IncludeError);
		}

		public SqlDataReader GetDailyGraphData(DateTime StartDate, string Service, string Source, string Computer, string Type, string EventID,
			bool IncludeSystemEvents, bool IncludeInfo, bool IncludeWarning, bool IncludeError)
		{
			return GetGraphData("GetDailyGraphData", StartDate, Service, Source, Computer, Type, EventID, IncludeSystemEvents, IncludeInfo, IncludeWarning, IncludeError);
		}
		public SqlDataReader GetGraphData(string SPToCall, DateTime StartDate, string Service, string Source, string Computer, string Type, string EventID,
											bool IncludeSystemEvents, bool IncludeInfo, bool IncludeWarning, bool IncludeError)
		{
			SqlDataReader SDR=null;
			//CloseSQL();
			//InitSQL();
			try
			{
				SqlCommand sqlCmd = new SqlCommand(SPToCall, SQLConnection );
				sqlCmd.CommandTimeout=60*10;
				sqlCmd.CommandType=CommandType.StoredProcedure;

				sqlCmd.Parameters.Add(new SqlParameter("@StartDate",SqlDbType.DateTime));
				sqlCmd.Parameters.Add(new SqlParameter("@Service",SqlDbType.VarChar,50));
				sqlCmd.Parameters.Add(new SqlParameter("@Source",SqlDbType.VarChar,64));
				sqlCmd.Parameters.Add(new SqlParameter("@Computer",SqlDbType.VarChar,16));
				sqlCmd.Parameters.Add(new SqlParameter("@Type",SqlDbType.VarChar,16));
				sqlCmd.Parameters.Add(new SqlParameter("@EventID",SqlDbType.Int));
				sqlCmd.Parameters.Add(new SqlParameter("@IncludeSystemEvents",SqlDbType.Bit));
				sqlCmd.Parameters.Add(new SqlParameter("@IncludeInfo",SqlDbType.Bit));
				sqlCmd.Parameters.Add(new SqlParameter("@IncludeWarning",SqlDbType.Bit));
				sqlCmd.Parameters.Add(new SqlParameter("@IncludeError",SqlDbType.Bit));

				sqlCmd.Parameters["@StartDate"].Value = StartDate;
				sqlCmd.Parameters["@Service"].Value = Service;
				sqlCmd.Parameters["@Source"].Value = Source;
				sqlCmd.Parameters["@Computer"].Value = Computer;
				sqlCmd.Parameters["@Type"].Value = Type;
				if (EventID!=null)
					sqlCmd.Parameters["@EventID"].Value = Convert.ToInt32(EventID);
				sqlCmd.Parameters["@IncludeSystemEvents"].Value = IncludeSystemEvents;
				sqlCmd.Parameters["@IncludeInfo"].Value = IncludeInfo;
				sqlCmd.Parameters["@IncludeWarning"].Value = IncludeWarning;
				sqlCmd.Parameters["@IncludeError"].Value = IncludeError;

				SDR = sqlCmd.ExecuteReader();

			}
			catch (Exception e)
			{				
				Debug.WriteLine(e.ToString());
			}
			return SDR;
		}

		public DataTable GetHourlyTreeData(DateTime StartDate, string Service, bool IncludeSystemEvents, bool IncludeInfo, bool IncludeWarning, bool IncludeError)
		{
			return GetTreeData("GetHourlyTreeData", StartDate, Service, IncludeSystemEvents, IncludeInfo, IncludeWarning, IncludeError);
		}

		public DataTable GetDailyTreeData(DateTime StartDate, string Service, bool IncludeSystemEvents, bool IncludeInfo, bool IncludeWarning, bool IncludeError)
		{
			return GetTreeData("GetDailyTreeData", StartDate, Service, IncludeSystemEvents, IncludeInfo, IncludeWarning, IncludeError);
		}

		protected DataTable GetTreeData(string SPToCall, DateTime StartDate, string Service, bool IncludeSystemEvents, bool IncludeInfo, bool IncludeWarning, bool IncludeError)
		{
			DataSet sqlDS;
			DataTable dt=null;

			try
			{
				
				SqlCommand sqlCmd = new SqlCommand(SPToCall, SQLConnection );
				sqlCmd.CommandTimeout=60*10;
				sqlCmd.CommandType=CommandType.StoredProcedure;

				SqlDataAdapter sqlDA = new SqlDataAdapter(sqlCmd);

				sqlCmd.Parameters.Add(new SqlParameter("@StartDate",SqlDbType.DateTime));
				sqlCmd.Parameters.Add(new SqlParameter("@Service",SqlDbType.VarChar,50));
				sqlCmd.Parameters.Add(new SqlParameter("@IncludeSystemEvents",SqlDbType.Bit));
				sqlCmd.Parameters.Add(new SqlParameter("@IncludeInfo",SqlDbType.Bit));
				sqlCmd.Parameters.Add(new SqlParameter("@IncludeWarning",SqlDbType.Bit));
				sqlCmd.Parameters.Add(new SqlParameter("@IncludeError",SqlDbType.Bit));

				sqlCmd.Parameters["@StartDate"].Value = StartDate;
				sqlCmd.Parameters["@Service"].Value = Service;
				sqlCmd.Parameters["@IncludeSystemEvents"].Value = IncludeSystemEvents;
				sqlCmd.Parameters["@IncludeInfo"].Value = IncludeInfo;
				sqlCmd.Parameters["@IncludeWarning"].Value = IncludeWarning;
				sqlCmd.Parameters["@IncludeError"].Value = IncludeError;

				sqlDS = new DataSet();
				sqlDA.Fill(sqlDS);
				dt=sqlDS.Tables[0];

			}
			catch (Exception e)
			{				
				Debug.WriteLine(e.ToString());
			}
			return dt;
		}
		/// <summary>
		/// Slap up the wait animation so the user knows something is happening. 
		/// </summary>
		public void BlastWaitGraphics()
		{
			Response.Write("<div id='mydiv' align='center'><IMG ID=BusyGif src=images/busy.gif width=120 height=20>");
			Response.Write("</div>");
			Response.Write("<script language=javascript>document.body.bgColor='#2287bb';mydiv.style.visibility = 'visible';");
			Response.Write("function HideWait(){mydiv.style.display='none';window.clearInterval();}");
			Response.Write("</script>");
            //object strCopyID = Page.Session;
			Response.Flush();
            //Page.Session.Add("SessionID",strCopyID);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\BrowserShots\BrowserShotsWebsite\BrowserShotsWebsite\Machine.aspx.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Xml;
using System.Data;

namespace Test.Common.Utilities.BrowserShotsWebsite
{
    public partial class Machine : System.Web.UI.Page
    {
        /// <summary>
        /// This class allows viewing of the machines that are used in browsershots
        /// and allows them to be updated
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void Page_Load(object sender, EventArgs e)
        {
            BindXMLFile();
        }

        /// <summary>
        /// Binds the machine list xml file to the datagrid
        /// </summary>
        void BindXMLFile()
        {
            string folder = Paths.GetFilesPath();
            DataSet ds = new DataSet();
            ds.ReadXml(folder + Paths.GetMachinesFile());
            dgMachines.DataSource = ds;
            dgMachines.DataBind();
        }

        /// <summary>
        /// Adds buttons to the datagrid
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void dgMachines_DataBound(object sender, DataGridItemEventArgs e)
        {

            if (e.Item.ItemType != ListItemType.Header && e.Item.ItemType != ListItemType.Footer)
            {
                DataView dv = new DataView((DataTable)((DataSet)dgMachines.DataSource).Tables[0]);
                DataColumnCollection dc = dv.Table.Columns;

                Button btnDelete = new Button();
                btnDelete.ID = "btnDelete";
                btnDelete.Text = "Delete";
                btnDelete.CausesValidation = false;
                btnDelete.Click += new System.EventHandler(btnDelete_Click);
                e.Item.Cells[4].Controls.Add(btnDelete);

                Button btnUpdateDelay = new Button();
                btnUpdateDelay.ID = "btnUpdateDelay";
                btnUpdateDelay.Text = "Update Delay";
                btnUpdateDelay.CausesValidation = false;
                btnUpdateDelay.Click += new System.EventHandler(btnUpdateDelay_Click);
                e.Item.Cells[5].Controls.Add(btnUpdateDelay);

            }
        }
        /// <summary>
        /// Deletes a machine from the xml file
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void btnDelete_Click(Object sender, EventArgs e)
        {
            DataSet ds = (DataSet)dgMachines.DataSource;
            DataTable dt = ds.Tables[0];
            DataView dv = new DataView(dt);
            DataColumnCollection dc = dv.Table.Columns;
            DataGridItem dgi = ((DataGridItem)(((Button)sender).Parent.Parent));

            string Name = dgi.Cells[dc.IndexOf(dc["Name"])].Text;
            string OperatingSystem = dgi.Cells[dc.IndexOf(dc["OperatingSystem"])].Text;
            string Browser = dgi.Cells[dc.IndexOf(dc["Browser"])].Text;
            DeleteNode(Name, OperatingSystem, Browser);
            BindXMLFile();
        }

        /// <summary>
        /// Updates the delay used by this machine to open a webpage
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void btnUpdateDelay_Click(object sender, EventArgs e)
        {
            DataSet ds = (DataSet)dgMachines.DataSource;
            DataTable dt = ds.Tables[0];
            DataView dv = new DataView(dt);
            DataColumnCollection dc = dv.Table.Columns;
            DataGridItem dgi = ((DataGridItem)(((Button)sender).Parent.Parent));

            string Name = dgi.Cells[dc.IndexOf(dc["Name"])].Text;
            string OperatingSystem = dgi.Cells[dc.IndexOf(dc["OperatingSystem"])].Text;
            string Browser = dgi.Cells[dc.IndexOf(dc["Browser"])].Text;
            string folder = Paths.GetFilesPath();
            string delay = tbUpdateDelay.Text;

            uint Num;
            bool isNum = uint.TryParse(delay, out Num);
            if (!isNum)
                return;

            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(folder + Paths.GetMachinesFile());

            XmlNodeList nodes = xDoc.SelectNodes(Paths.GetMachineNodes());
            foreach (XmlElement node in nodes)
            {
                if (node.Attributes["Name"].Value == Name && node.Attributes["OperatingSystem"].Value == OperatingSystem && node.Attributes["Browser"].Value == Browser)
                    node.SetAttribute("Delay", delay);
            }
            xDoc.Save(folder + Paths.GetMachinesFile());
            BindXMLFile();
        }

        /// <summary>
        /// Deletes a machine from the xml file
        /// </summary>
        /// <param name="Name"></param>
        /// <param name="OperatingSystem"></param>
        /// <param name="Browser"></param>
        void DeleteNode(string Name, string OperatingSystem, string Browser)
        {
            string folder = Paths.GetFilesPath();
            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(folder + Paths.GetMachinesFile());

            XmlNodeList nodes = xDoc.SelectNodes(Paths.GetMachineNodes());
            XmlNode parentNode = xDoc.SelectSingleNode(Paths.GetRemoteClientsNode());
            foreach (XmlNode node in nodes)
            {
                if (node.Attributes["Name"].Value == Name && node.Attributes["OperatingSystem"].Value == OperatingSystem && node.Attributes["Browser"].Value == Browser)
                    parentNode.RemoveChild(node);
            }
            xDoc.Save(folder + Paths.GetMachinesFile());
        }

        /// <summary>
        /// Adds a machine to the xml file
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void btnSubmit_Click(object sender, EventArgs e)
        {
            string folder = Paths.GetFilesPath();
            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(folder + Paths.GetMachinesFile());
            XmlNode node = xDoc.SelectSingleNode(Paths.GetRemoteClientsNode());
            XmlElement xNode = xDoc.CreateElement("Machine");
            xNode.SetAttribute("Name", tbName.Text);
            xNode.SetAttribute("OperatingSystem", txtOperatingSystem.Text);
            xNode.SetAttribute("Browser", txtBrowser.Text);
            xNode.SetAttribute("Delay", tbDelay.Text);
            xNode.SetAttribute("Active", "false");
            xNode.SetAttribute("Date", "");
            node.AppendChild(xNode);
            xDoc.Save(folder + Paths.GetMachinesFile());
            BindXMLFile();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\BrowserShots\BrowserShotsWebsite\BrowserShotsWebsite\MasterPage.Master.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.IO;

namespace Test.Common.Utilities.BrowserShotsWebsite
{
    public partial class MasterPage : System.Web.UI.MasterPage
    {
        protected void Page_Load(object sender, EventArgs e)
        {

        }
        void DownloadFile()
        {
            string filepath = Paths.GetFilesPath() + Paths.GetDocumentation();
            FileInfo file = new FileInfo(filepath);

            if (file.Exists)
            {
                // Clear the content of the response
                Response.ClearContent();

                // Add the file name and attachment, which will force the open/cancel/save dialog to show, to the header
                Response.AddHeader("Content-Disposition", "attachment; filename=" + file.Name);

                // Add the file size into the response header
                Response.AddHeader("Content-Length", file.Length.ToString());

                // Set the ContentType
                Response.ContentType = "application/ms-word";

                // Write the file into the response
                Response.WriteFile(file.FullName);

                // Flush the response
                Response.Flush();

                // End the response
                Response.End();
            }
        }
        protected void btnDocumentation_Click(object sender, EventArgs e)
        {
            DownloadFile();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\BrowserShots\BrowserShotsWebsite\BrowserShotsWebsite\MasterPage.Master.designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Test.Common.Utilities.BrowserShotsWebsite {
    
    
    public partial class MasterPage {
        
        /// <summary>
        /// head control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.ContentPlaceHolder head;
        
        /// <summary>
        /// form1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.HtmlControls.HtmlForm form1;
        
        /// <summary>
        /// Menu1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Menu Menu1;
        
        /// <summary>
        /// ContentPlaceHolder1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.ContentPlaceHolder ContentPlaceHolder1;
        
        /// <summary>
        /// btnDocumentation control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnDocumentation;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\BrowserShots\BrowserShotsWebsite\BrowserShotsWebsite\Machine.aspx.designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Test.Common.Utilities.BrowserShotsWebsite {
    
    
    public partial class Machine {
        
        /// <summary>
        /// lblCurrentMachines control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblCurrentMachines;
        
        /// <summary>
        /// lblUpdateDelay control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblUpdateDelay;
        
        /// <summary>
        /// tbUpdateDelay control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox tbUpdateDelay;
        
        /// <summary>
        /// dgMachines control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DataGrid dgMachines;
        
        /// <summary>
        /// lblNewMachine control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblNewMachine;
        
        /// <summary>
        /// lblName control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblName;
        
        /// <summary>
        /// tbName control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox tbName;
        
        /// <summary>
        /// rfvName control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.RequiredFieldValidator rfvName;
        
        /// <summary>
        /// lblOperatingSystem control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblOperatingSystem;
        
        /// <summary>
        /// txtOperatingSystem control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox txtOperatingSystem;
        
        /// <summary>
        /// rfvOperatingSystem control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.RequiredFieldValidator rfvOperatingSystem;
        
        /// <summary>
        /// lblBrowser control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblBrowser;
        
        /// <summary>
        /// txtBrowser control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox txtBrowser;
        
        /// <summary>
        /// rfvBrowser control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.RequiredFieldValidator rfvBrowser;
        
        /// <summary>
        /// lblDelay control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblDelay;
        
        /// <summary>
        /// tbDelay control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox tbDelay;
        
        /// <summary>
        /// rfvDelay control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.RequiredFieldValidator rfvDelay;
        
        /// <summary>
        /// RegularExpressionValidator1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.RegularExpressionValidator RegularExpressionValidator1;
        
        /// <summary>
        /// btnSubmit control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnSubmit;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\BrowserShots\BrowserShotsWebsite\BrowserShotsWebsite\ModifyUrls.aspx.designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Test.Common.Utilities.BrowserShotsWebsite {
    
    
    public partial class ModifyUrls {
        
        /// <summary>
        /// lblModifyUrls control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblModifyUrls;
        
        /// <summary>
        /// lblURL control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblURL;
        
        /// <summary>
        /// lblOptional control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblOptional;
        
        /// <summary>
        /// lblGroup control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblGroup;
        
        /// <summary>
        /// lblDelay control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblDelay;
        
        /// <summary>
        /// tbUrl control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox tbUrl;
        
        /// <summary>
        /// rfvURL control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.RequiredFieldValidator rfvURL;
        
        /// <summary>
        /// tbGroup control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox tbGroup;
        
        /// <summary>
        /// tbDelay control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox tbDelay;
        
        /// <summary>
        /// btnAddUrl control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnAddUrl;
        
        /// <summary>
        /// lblUpdateDelay control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblUpdateDelay;
        
        /// <summary>
        /// tbUpdateDelay control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox tbUpdateDelay;
        
        /// <summary>
        /// dgUrls control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DataGrid dgUrls;
        
        /// <summary>
        /// btnViewAll control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnViewAll;
        
        /// <summary>
        /// lblGroups control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblGroups;
        
        /// <summary>
        /// ddlGroups control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DropDownList ddlGroups;
        
        /// <summary>
        /// lblAddMultipleUrls control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblAddMultipleUrls;
        
        /// <summary>
        /// tbNewUrls control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox tbNewUrls;
        
        /// <summary>
        /// lblGp control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblGp;
        
        /// <summary>
        /// tbGp control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox tbGp;
        
        /// <summary>
        /// lblDlay control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblDlay;
        
        /// <summary>
        /// tbDlay control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox tbDlay;
        
        /// <summary>
        /// btnAddMultipleUrls control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnAddMultipleUrls;
        
        /// <summary>
        /// lblDeleteGroup control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblDeleteGroup;
        
        /// <summary>
        /// lbDeleteGroup control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.ListBox lbDeleteGroup;
        
        /// <summary>
        /// btnDeleteGroup control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnDeleteGroup;
        
        /// <summary>
        /// lblModify control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblModify;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\BrowserShots\BrowserShotsWebsite\BrowserShotsWebsite\ModifyUrls.aspx.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Collections;
using System.Xml;
using System.Data;
using System.Reflection;
using System.Text;

namespace Test.Common.Utilities.BrowserShotsWebsite
{
    /// <summary>
    /// This class allows viewing of the urls that are used in browsershots
    /// and allows them to be updated
    /// </summary>
    public partial class ModifyUrls : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {
            if (!IsPostBack)
            {
                Session["group"] = null;
                DataBindListBox();
                InsertGroups();
            }
            BindDataGrid();
        }

        /// <summary>
        /// Binds the data to the datagrid for a selected group
        /// </summary>
        void BindDataGrid()
        {
            dgUrls.DataSource = GetAllUrls();
            dgUrls.DataBind();
        }

        /// <summary>
        /// Gets url groups from the xml file and inserts then in the dropdown list
        /// </summary>
        void InsertGroups()
        {
            string folder = Paths.GetFilesPath();
            string group = string.Empty;
            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(folder + Paths.GetUrlFile());

            XmlNodeList nodes = xDoc.SelectNodes(Paths.GetUrlGroupNodes());
            ddlGroups.Items.Add(Paths.GetShowAllGroupsPhrase());
            foreach (XmlNode node in nodes)
            {
                group = node.Attributes["group"].Value;
                ddlGroups.Items.Add(group);
            }
        }

        /// <summary>
        /// This method is used to page through the datagrid
        /// </summary>
        /// <param name="source"></param>
        /// <param name="e"></param>
        protected void Paging_DataGrid(object source, System.Web.UI.WebControls.DataGridPageChangedEventArgs e)
        {
            dgUrls.CurrentPageIndex = e.NewPageIndex;
            BindDataGrid();
        }

        /// <summary>
        /// Adds buttons to the datagrid
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void dgUrls_DataBound(object sender, DataGridItemEventArgs e)
        {

            if (e.Item.ItemType != ListItemType.Header && e.Item.ItemType != ListItemType.Footer)
            {
                DataTable dt = new DataTable();
                ArrayList al = (ArrayList)dgUrls.DataSource;
                dt = Paths.ConvertObjectToDataTableSchema(al[0]);
                Paths.FillData(al, dt);
                DataView dv = new DataView(dt);
                DataColumnCollection dc = dv.Table.Columns;

                Button btnDelete = new Button();
                btnDelete.ID = "btnDelete";
                btnDelete.Text = "Delete";
                btnDelete.CausesValidation = false;
                btnDelete.Click += new System.EventHandler(btnDeleteUrl_Click);
                e.Item.Cells[3].Controls.Add(btnDelete);

                Button btnUpdateDelay = new Button();
                btnUpdateDelay.ID = "btnUpdateDelay";
                btnUpdateDelay.Text = "Update Delay";
                btnUpdateDelay.CausesValidation = false;
                btnUpdateDelay.Click += new System.EventHandler(btnUpdateDelay_Click);
                e.Item.Cells[4].Controls.Add(btnUpdateDelay);
            }
        }

        /// <summary>
        /// This is a helper method to bind an arraylist to a datagrid
        /// </summary>
        /// <param name="o"></param>
        /// <returns></returns>
        //public static DataTable ConvertObjectToDataTableSchema(Object o)
        //{
        //    DataTable dt = new DataTable();
        //    PropertyInfo[] properties = o.GetType().GetProperties();

        //    foreach (PropertyInfo property in properties)
        //    {
        //        DataColumn dc = new DataColumn(property.Name);
        //        dc.DataType = property.PropertyType; dt.Columns.Add(dc);
        //    }
        //    return dt;
        //}

        ///// <summary>
        ///// This is a helper method to bind an arraylist to a datagrid
        ///// </summary>
        ///// <param name="arrayList"></param>
        ///// <param name="dt"></param>
        //private static void FillData(ArrayList arrayList, DataTable dt)
        //{
        //    foreach (Object o in arrayList)
        //    {
        //        DataRow dr = dt.NewRow();
        //        PropertyInfo[] properties = o.GetType().GetProperties();

        //        foreach (PropertyInfo property in properties)
        //        {
        //            dr[property.Name] = property.GetValue(o, null);
        //        }
        //        dt.Rows.Add(dr);
        //    }
        //}

        /// <summary>
        /// Gets the urls from the xml file and binds them to the datagrid
        /// </summary>
        /// <param name="url"></param>
        /// <param name="group"></param>
        /// <param name="delay"></param>
        void InsertUrl(string url, string group, string delay)
        {
            string folder = Paths.GetFilesPath();
            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(folder + Paths.GetUrlFile());

            uint Num;
            bool isNum = uint.TryParse(delay, out Num);
            if (!isNum && delay != "")
                return;
            XmlNodeList nodes = xDoc.SelectNodes(Paths.GetUrlGroupNodes());
            if (group == "")
                group = "none";
            bool groupExists = false;
            foreach (XmlNode xNode in nodes)
            {
                if (xNode.Attributes["group"].Value == group)
                    groupExists = true;
            }
            if (!groupExists)
            {
                XmlNode nodeUrlsParent = xDoc.SelectSingleNode(Paths.GetUrlsParentNode());
                XmlElement newGroupNode = xDoc.CreateElement("urlGroup");
                newGroupNode.SetAttribute("group", group);
                newGroupNode.SetAttribute("active", "false");
                nodeUrlsParent.AppendChild(newGroupNode);
            }
            XmlNode node = xDoc.SelectSingleNode("//Urls/urlGroup[@group='" + group + "']");
            XmlElement newNode = xDoc.CreateElement("url");
            newNode.InnerText = url;
            if (delay != "")
                newNode.SetAttribute("delay", delay);
            node.AppendChild(newNode);
            xDoc.Save(folder + Paths.GetUrlFile());
            lblModify.Visible = true;
            DataBindListBox();
            BindDataGrid();
        }

        /// <summary>
        /// This method will return all the urls stored in the xml file
        /// </summary>
        /// <returns></returns>
        ArrayList GetAllUrls()
        {
            ArrayList urls = new ArrayList();
            string folder = Paths.GetFilesPath();
            string url = string.Empty;
            string group = string.Empty;
            string delay = string.Empty;
            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(folder + Paths.GetUrlFile());

            XmlNodeList nodes = xDoc.SelectNodes(Paths.GetUrlNodes());
            if (Session["group"] != null)
            {
                string groupValue = Session["group"].ToString();
                if (groupValue != Paths.GetShowAllGroupsPhrase())
                    nodes = xDoc.SelectNodes("//Urls/urlGroup[@group='" + groupValue + "']/url");
            }
            foreach (XmlNode node in nodes)
            {
                url = node.InnerText.ToString();
                group = node.ParentNode.Attributes["group"].Value;
                if (node.Attributes.Count > 0)
                    delay = node.Attributes["delay"].Value;
                else
                    delay = string.Empty;
                urls.Add(new urlType(url, group, delay));
            }

            return urls;
        }

        /// <summary>
        /// Adds a new url to the xml file
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void btnAddUrl_Click(object sender, EventArgs e)
        {
            string url = tbUrl.Text;
            string group = tbGroup.Text;
            string delay = tbDelay.Text;
            InsertUrl(url, group, delay);
            ddlGroups.Items.Clear();
            InsertGroups();
        }

        /// <summary>
        /// Deletes a group and all its urls from the xml file
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void btnDeleteGroup_Click(object sender, EventArgs e)
        {
            string folder = Paths.GetFilesPath();
            string group = lbDeleteGroup.SelectedValue;

            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(folder + Paths.GetUrlFile());

            XmlNodeList groupNode = xDoc.SelectNodes(Paths.GetUrlGroupNodes());
            foreach (XmlNode node in groupNode)
            {
                if (group == node.Attributes["group"].Value)
                {
                    node.ParentNode.RemoveChild(node);
                }
            }
            xDoc.Save(folder + Paths.GetUrlFile());
            lblModify.Visible = true;
            DataBindListBox();
            BindDataGrid();
            ddlGroups.Items.Clear();
            InsertGroups();
        }

        /// <summary>
        /// Deletes a url from the xml file
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void btnDeleteUrl_Click(object sender, EventArgs e)
        {
            DataTable dt = new DataTable();
            ArrayList al = (ArrayList)dgUrls.DataSource;
            dt = Paths.ConvertObjectToDataTableSchema(al[0]);
            DataView dv = new DataView(dt);
            DataColumnCollection dc = dv.Table.Columns;
            DataGridItem dgi = ((DataGridItem)(((Button)sender).Parent.Parent));
            string url = dgi.Cells[dc.IndexOf(dc["Url"])].Text;
            string folder = Paths.GetFilesPath();

            if (url == "")
                return;
            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(folder + Paths.GetUrlFile());

            XmlNodeList nodes = xDoc.SelectNodes(Paths.GetUrlGroupNodes());
            foreach (XmlNode node in nodes)
            {
                foreach (XmlNode urlNode in node.ChildNodes)
                    if (url == urlNode.InnerText.ToString())
                        node.RemoveChild(urlNode);
            }
            xDoc.Save(folder + Paths.GetUrlFile());
            lblModify.Visible = true;
            DataBindListBox();
            BindDataGrid();
        }

        /// <summary>
        /// Updates the delay that a url uses for opening the browser
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void btnUpdateDelay_Click(object sender, EventArgs e)
        {
            DataTable dt = new DataTable();
            ArrayList al = (ArrayList)dgUrls.DataSource;
            dt = Paths.ConvertObjectToDataTableSchema(al[0]);
            DataView dv = new DataView(dt);
            DataColumnCollection dc = dv.Table.Columns;
            DataGridItem dgi = ((DataGridItem)(((Button)sender).Parent.Parent));
            string url = dgi.Cells[dc.IndexOf(dc["Url"])].Text;
            string folder = Paths.GetFilesPath();
            string delay = tbUpdateDelay.Text;
            uint Num;
            bool isNum = uint.TryParse(delay, out Num);
            if (!isNum && delay != "")
                return;
            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(folder + Paths.GetUrlFile());

            XmlNodeList nodes = xDoc.SelectNodes(Paths.GetUrlGroupNodes());
            foreach (XmlNode node in nodes)
            {
                foreach (XmlElement urlNode in node.ChildNodes)
                {
                    if (url == urlNode.InnerText.ToString())
                    {
                        urlNode.RemoveAllAttributes();
                        urlNode.SetAttribute("delay", delay);
                        break;
                    }
                }
            }
            xDoc.Save(folder + Paths.GetUrlFile());
            lblModify.Visible = true;
            DataBindListBox();
            BindDataGrid();
        }

        /// <summary>
        /// Binds the list of groups to the ones in the xml file
        /// </summary>
        void DataBindListBox()
        {
            lbDeleteGroup.DataSource = GetGroups();
            lbDeleteGroup.DataBind();
        }

        /// <summary>
        /// Gets the groups from the xml file
        /// </summary>
        /// <returns></returns>
        ArrayList GetGroups()
        {
            ArrayList alGroups = new ArrayList();
            string folder = Paths.GetFilesPath();
            string group = string.Empty;
            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(folder + Paths.GetUrlFile());

            XmlNodeList nodes = xDoc.SelectNodes(Paths.GetUrlGroupNodes());
            foreach (XmlNode node in nodes)
            {
                group = node.Attributes["group"].Value;
                alGroups.Add(group);
            }
            alGroups.Remove("none");
            return alGroups;
        }

        /// <summary>
        /// Toggles between paging and viewing all the urls
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void btnViewAll_Click(object sender, EventArgs e)
        {
            if (Session["ViewAllPassed"] == null)
            {
                Session["ViewAllPassed"] = "true";
            }
            if (Session["ViewAllPassed"].ToString() == "true")
            {
                Session["ViewAllPassed"] = "false";
                dgUrls.AllowPaging = false;
                btnViewAll.Text = "Allow Paging";
            }
            else
            {
                Session["ViewAllPassed"] = "true";
                dgUrls.AllowPaging = true;
                btnViewAll.Text = "View All";
            }
            BindDataGrid();
        }

        /// <summary>
        /// Adds multiple urls to the xml file
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void btnAddMultipleUrls_Click(object sender, EventArgs e)
        {
            string[] urls = tbNewUrls.Text.ToString().Split("\n".ToCharArray());
            string group = tbGp.Text;
            string delay = tbDlay.Text;
            foreach (string url in urls)
            {
                string urlNew = url.Replace("\r", "");
                InsertUrl(urlNew, group, delay);
            }
            ddlGroups.Items.Clear();
            InsertGroups();
        }

        /// <summary>
        /// Shows urls in the datagrid based on what group is slected in the dropdown list
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void ddlGroups_SelectedIndexChanged(object sender, EventArgs e)
        {
            Session["group"] = ddlGroups.SelectedValue;
            BindDataGrid();
        }
    }

    /// <summary>
    /// This class is used to store urls.
    /// It is used when the data is bound to the datagrid.
    /// </summary>
    class urlType
    {
        string url;
        string group;
        string delay;

        public urlType(string url, string group, string delay)
        {
            this.url = url;
            this.group = group;
            this.delay = delay;
        }
        public string Url
        {
            get { return url; }
        }

        public string Group
        {
            get { return group; }
        }

        public string Delay
        {
            get { return delay; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\BrowserShots\BrowserShotsWebsite\BrowserShotsWebsite\ShowImage.aspx.designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Test.Common.Utilities.BrowserShotsWebsite {
    
    
    public partial class ShowImage {
        
        /// <summary>
        /// Head1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.HtmlControls.HtmlHead Head1;
        
        /// <summary>
        /// form1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.HtmlControls.HtmlForm form1;
        
        /// <summary>
        /// imgBrowserShot control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Image imgBrowserShot;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\BrowserShots\BrowserShotsWebsite\BrowserShotsWebsite\Start.aspx.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Diagnostics;
using System.Xml;
using System.Collections;
using System.Data;

namespace Test.Common.Utilities.BrowserShotsWebsite
{
    /// <summary>
    /// This class is used to start running the browser shots on the client computers
    /// </summary>
    public partial class Start : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {
            ShowMachinesAndBrowsers();
            if (!IsPostBack)
            {
                InsertRegistryValues();
                InsertGroups();
                SetActiveMachines();
            }
            BindDataGrid();
            MaintainScrollPositionOnPostBack = true;
        }

        /// <summary>
        /// Inserts the registry values into controls on the webpage from the xml file
        /// </summary>
        void InsertRegistryValues()
        {
            string folder = Paths.GetFilesPath();
            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(folder + Paths.GetRegistryFile());

            XmlNode screenSizeXNode = xDoc.SelectSingleNode(Paths.GetRegistryScreenSizeXNodes());
            lbScreenSize.Items.Clear();
            int i = 0;
            foreach (XmlNode node in screenSizeXNode.ChildNodes)
            {
                lbScreenSize.Items.Add(node.InnerText);
                if (node.Attributes["active"].Value == "true")
                    lbScreenSize.Items[i].Selected = true;
                i++;
            }
            XmlNode colorDepthNode = xDoc.SelectSingleNode(Paths.GetRegistryColorDepthNodes());
            lbColorDepth.Items.Clear();
            i = 0;
            foreach (XmlNode node in colorDepthNode.ChildNodes)
            {
                lbColorDepth.Items.Add(node.InnerText);
                if (node.Attributes["active"].Value == "true")
                    lbColorDepth.Items[i].Selected = true;
                i++;
            }
            XmlNode javaScriptNode = xDoc.SelectSingleNode(Paths.GetRegistryJavaScriptNodes());
            lbJavascript.Items.Clear();
            i = 0;
            foreach (XmlNode node in javaScriptNode.ChildNodes)
            {
                lbJavascript.Items.Add(node.InnerText);
                if (node.Attributes["active"].Value == "true")
                    lbJavascript.Items[i].Selected = true;
                i++;
            }
            XmlNode activeXNode = xDoc.SelectSingleNode(Paths.GetRegistryActiveXNodes());
            lbActiveX.Items.Clear();
            i = 0;
            foreach (XmlNode node in activeXNode.ChildNodes)
            {
                lbActiveX.Items.Add(node.InnerText);
                if (node.Attributes["active"].Value == "true")
                    lbActiveX.Items[i].Selected = true;
                i++;
            }
            XmlNode disableScriptDebuggingNode = xDoc.SelectSingleNode(Paths.GetRegistryDisableScriptDebuggingNodes());
            lbDisableScriptDebugging.Items.Clear();
            i = 0;
            foreach (XmlNode node in disableScriptDebuggingNode.ChildNodes)
            {
                lbDisableScriptDebugging.Items.Add(node.InnerText);
                if (node.Attributes["active"].Value == "true")
                    lbDisableScriptDebugging.Items[i].Selected = true;
                i++;
            }
            XmlNode displayErrorDialogNode = xDoc.SelectSingleNode(Paths.GetRegistryDisplayErrorDialogNodes());
            lbDisplayErrorDialog.Items.Clear();
            i = 0;
            foreach (XmlNode node in displayErrorDialogNode.ChildNodes)
            {
                lbDisplayErrorDialog.Items.Add(node.InnerText);
                if (node.Attributes["active"].Value == "true")
                    lbDisplayErrorDialog.Items[i].Selected = true;
                i++;
            }
            XmlNode warnOnZoneCrossingNode = xDoc.SelectSingleNode(Paths.GetRegistryWarnOnZoneCrossingNodes());
            lbWarnOnZoneCrossing.Items.Clear();
            i = 0;
            foreach (XmlNode node in warnOnZoneCrossingNode.ChildNodes)
            {
                lbWarnOnZoneCrossing.Items.Add(node.InnerText);
                if (node.Attributes["active"].Value == "true")
                    lbWarnOnZoneCrossing.Items[i].Selected = true;
                i++;
            }
            XmlNode limitedUserPrivilegesNode = xDoc.SelectSingleNode(Paths.GetRegistryLimitedUserPrivilegesNodes());
            lbLimitedUserPrivileges.Items.Clear();
            i = 0;
            foreach (XmlNode node in limitedUserPrivilegesNode.ChildNodes)
            {
                lbLimitedUserPrivileges.Items.Add(node.InnerText);
                if (node.Attributes["active"].Value == "true")
                    lbLimitedUserPrivileges.Items[i].Selected = true;
                i++;
            }
        }

        /// <summary>
        /// Starts the browser shots on the client computers by updating
        /// the xml value which services on the client periodically check
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void btnStart_Click(object sender, EventArgs e)
        {
            AddNodeToQueue();
            BindDataGrid();
        }
        /// <summary>
        /// Starts the browser shots on the client computers by updating
        /// the xml value which services on the client periodically check 
        /// </summary>
        void AddNodeToQueue()
        {
            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(Paths.GetFilesPath() + Paths.GetQueueFile());
            XmlNode node = xDoc.SelectSingleNode(Paths.GetQueueNode());
            ArrayList machines = GetMachineList();
            XmlElement screenSizeXNode = xDoc.CreateElement("ScreenSizeX");
            int[] screenSizeYValues = { 768, 800, 600, 864 };
            XmlElement screenSizeYNode = xDoc.CreateElement("ScreenSizeY");
            int i = 0;
            foreach (ListItem item in lbScreenSize.Items)
            {
                XmlElement textNodeX = xDoc.CreateElement("text");
                textNodeX.InnerText = item.Text;
                textNodeX.SetAttribute("active", item.Selected ? "true" : "false");
                screenSizeXNode.AppendChild(textNodeX);
                XmlElement textNodeY = xDoc.CreateElement("text");
                textNodeY.InnerText = screenSizeYValues[i].ToString();
                textNodeY.SetAttribute("active", item.Selected ? "true" : "false");
                screenSizeYNode.AppendChild(textNodeY);
                i++;
            }
            XmlElement colorDepthNode = xDoc.CreateElement("ColorDepth");
            foreach (ListItem item in lbColorDepth.Items)
            {
                XmlElement textNode = xDoc.CreateElement("text");
                textNode.InnerText = item.Text;
                textNode.SetAttribute("active", item.Selected ? "true" : "false");
                colorDepthNode.AppendChild(textNode);
            }
            XmlElement javaScriptNode = xDoc.CreateElement("JavaScript");
            foreach (ListItem item in lbJavascript.Items)
            {
                XmlElement textNode = xDoc.CreateElement("text");
                textNode.InnerText = item.Text;
                textNode.SetAttribute("active", item.Selected ? "true" : "false");
                javaScriptNode.AppendChild(textNode);
            }
            XmlElement activeXNode = xDoc.CreateElement("ActiveX");
            foreach (ListItem item in lbActiveX.Items)
            {
                XmlElement textNode = xDoc.CreateElement("text");
                textNode.InnerText = item.Text;
                textNode.SetAttribute("active", item.Selected ? "true" : "false");
                activeXNode.AppendChild(textNode);
            }
            XmlElement disableScriptDebuggingNode = xDoc.CreateElement("DisableScriptDebugging");
            foreach (ListItem item in lbDisableScriptDebugging.Items)
            {
                XmlElement textNode = xDoc.CreateElement("text");
                textNode.InnerText = item.Text;
                textNode.SetAttribute("active", item.Selected ? "true" : "false");
                disableScriptDebuggingNode.AppendChild(textNode);
            }
            XmlElement displayErrorDialogNode = xDoc.CreateElement("DisplayErrorDialog");
            foreach (ListItem item in lbDisplayErrorDialog.Items)
            {
                XmlElement textNode = xDoc.CreateElement("text");
                textNode.InnerText = item.Text;
                textNode.SetAttribute("active", item.Selected ? "true" : "false");
                displayErrorDialogNode.AppendChild(textNode);
            }
            XmlElement warnOnZoneCrossingNode = xDoc.CreateElement("WarnOnZoneCrossing");
            foreach (ListItem item in lbWarnOnZoneCrossing.Items)
            {
                XmlElement textNode = xDoc.CreateElement("text");
                textNode.InnerText = item.Text;
                textNode.SetAttribute("active", item.Selected ? "true" : "false");
                warnOnZoneCrossingNode.AppendChild(textNode);
            }
            XmlElement limitedUserPrivilegesNode = xDoc.CreateElement("LimitedUserPrivileges");
            foreach (ListItem item in lbLimitedUserPrivileges.Items)
            {
                XmlElement textNode = xDoc.CreateElement("text");
                textNode.InnerText = item.Text;
                textNode.SetAttribute("active", item.Selected ? "true" : "false");
                limitedUserPrivilegesNode.AppendChild(textNode);
            }

            XmlElement regNode = xDoc.CreateElement("Registry");
            regNode.AppendChild(screenSizeXNode);
            regNode.AppendChild(screenSizeYNode);
            regNode.AppendChild(colorDepthNode);
            regNode.AppendChild(javaScriptNode);
            regNode.AppendChild(activeXNode);
            regNode.AppendChild(disableScriptDebuggingNode);
            regNode.AppendChild(displayErrorDialogNode);
            regNode.AppendChild(warnOnZoneCrossingNode);
            regNode.AppendChild(limitedUserPrivilegesNode);
            foreach (string machine in machines)
            {
                XmlElement itemNode = xDoc.CreateElement("item");
                string os = string.Empty;
                string browser = string.Empty;
                GetMachineInfo(machine, ref os, ref browser);
                itemNode.SetAttribute("MachineName", machine);
                itemNode.SetAttribute("Date", DateTime.Now.ToString());
                itemNode.SetAttribute("OS", os);
                itemNode.SetAttribute("Browser", browser);
                XmlNode newRegNode = xDoc.ImportNode(regNode, true);
                itemNode.AppendChild(newRegNode);
                XmlElement urlGroupsNode = xDoc.CreateElement("UrlGroups");
                foreach (ListItem item in lbGroups.Items)
                {
                    if (item.Selected)
                    {
                        XmlElement groupNode = xDoc.CreateElement("Group");
                        groupNode.InnerText = item.Text;
                        urlGroupsNode.AppendChild(groupNode);
                    }
                }
                itemNode.AppendChild(urlGroupsNode);
                node.AppendChild(itemNode);
            }

            xDoc.Save(Paths.GetFilesPath() + Paths.GetQueueFile());
        }
        /// <summary>
        /// Gets the OS and Browser that this machine will use.
        /// </summary>
        /// <param name="machineName"></param>
        /// <param name="oS"></param>
        /// <param name="browser"></param>
        void GetMachineInfo(string machineName, ref string oS, ref string browser)
        {
            XmlDocument xDoc = new XmlDocument();
            string folder = Paths.GetFilesPath();
            xDoc.Load(folder + Paths.GetMachinesFile());
            XmlNodeList nodes = xDoc.SelectNodes(Paths.GetMachineNodes());

            foreach (XmlNode node in nodes)
            {
                if (node.Attributes["Name"].Value.ToUpper() == machineName.ToUpper())
                {
                    oS = node.Attributes["OperatingSystem"].Value;
                    browser = node.Attributes["Browser"].Value;
                    break;
                }
            }
        }

        /// <summary>
        /// Gets information about the machines and their browsers from the xml file
        /// and displays them on the web page.
        /// </summary>
        void ShowMachinesAndBrowsers()
        {
            string folder = Paths.GetFilesPath();
            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(folder + Paths.GetMachinesFile());

            XmlNodeList nodes = xDoc.SelectNodes(Paths.GetMachineNodes());
            ArrayList configs = new ArrayList();
            ArrayList OpSystems = new ArrayList();
            foreach (XmlNode xNode in nodes)
            {
                string os = xNode.Attributes["OperatingSystem"].Value;
                if (!OpSystems.Contains(os))
                    OpSystems.Add(os);
                string browser = xNode.Attributes["Browser"].Value.Replace("IExplore", "IE");
                string config = os + " " + browser;
                if (!configs.Contains(config))
                    configs.Add(config);
            }
            phMachines.Controls.Add(new LiteralControl("<table><tr>"));
            foreach (string os in OpSystems)
            {
                Label lb = new Label();
                lb.ID = "lbl" + os;
                lb.Text = os;
                lb.Style.Add("font-size", "x-large");
                phMachines.Controls.Add(new LiteralControl("<td valign=\"top\">"));
                phMachines.Controls.Add(lb);
                CheckBoxList cbl = new CheckBoxList();
                cbl.ID = "cbl" + os;
                cbl.Style.Add("font-size", "larger");
                foreach (string sOperatingSystem in configs)
                {
                    if (sOperatingSystem.StartsWith(os))
                    {
                        cbl.Items.Add(new ListItem(sOperatingSystem.Substring(sOperatingSystem.IndexOf(" ") + 1)));
                    }
                }
                phMachines.Controls.Add(cbl);
                phMachines.Controls.Add(new LiteralControl("</td>"));
            }
            phMachines.Controls.Add(new LiteralControl("</tr></table>"));
        }

        /// <summary>
        /// Gets the url groups from the xml file and displays them on the webpage.
        /// </summary>
        void InsertGroups()
        {
            string folder = Paths.GetFilesPath();
            string group = string.Empty;
            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(folder + Paths.GetUrlFile());

            XmlNodeList nodes = xDoc.SelectNodes(Paths.GetUrlGroupNodes());
            int i = 0;
            foreach (XmlNode node in nodes)
            {
                group = node.Attributes["group"].Value;
                lbGroups.Items.Add(group);
                if (node.Attributes["active"].Value.ToLower() == "true")
                    lbGroups.Items[i].Selected = true;
                i++;
            }
        }

        /// <summary>
        /// Gets the machines and their browsers from the xml file
        /// </summary>
        /// <returns></returns>
        ArrayList GetMachineList()
        {
            ArrayList machines = new ArrayList();
            string sOperatingSystem = string.Empty;
            string sBrowser = string.Empty;
            XmlDocument xDoc = new XmlDocument();
            string folder = Paths.GetFilesPath();
            xDoc.Load(folder + Paths.GetMachinesFile());
            XmlNodeList nodes = xDoc.SelectNodes(Paths.GetMachineNodes());

            foreach (Control control in phMachines.Controls)
            {
                if (control.ID != null && control.ID.StartsWith("cbl") && control is CheckBoxList)
                {
                    CheckBoxList cbl = (CheckBoxList)control;
                    for (int j = 0; j < cbl.Items.Count; j++)
                    {
                        if (cbl.Items[j].Selected)
                        {
                            sOperatingSystem = cbl.ID.Substring(3);
                            sBrowser = cbl.Items[j].Text;
                            if (sBrowser.StartsWith("IE"))
                                sBrowser = sBrowser.Replace("IE", "IExplore");
                            foreach (XmlNode node in nodes)
                            {
                                if (node.Attributes["OperatingSystem"].Value.ToUpper() == sOperatingSystem.ToUpper() && node.Attributes["Browser"].Value.ToUpper() == sBrowser.ToUpper())
                                {
                                    machines.Add(node.Attributes["Name"].Value);
                                }
                            }
                        }
                    }
                }
            }
            return machines;
        }

        /// <summary>
        /// Sets which machines will run browser shots based on values in the xml file
        /// </summary>
        void SetActiveMachines()
        {
            string sOperatingSystem = string.Empty;
            string sBrowser = string.Empty;
            XmlDocument xDoc = new XmlDocument();
            string folder = Paths.GetFilesPath();
            xDoc.Load(folder + Paths.GetMachinesFile());
            XmlNodeList nodes = xDoc.SelectNodes(Paths.GetMachineNodes());

            foreach (Control control in phMachines.Controls)
            {
                if (control.ID != null && control.ID.StartsWith("cbl") && control is CheckBoxList)
                {
                    CheckBoxList cbl = (CheckBoxList)control;
                    for (int j = 0; j < cbl.Items.Count; j++)
                    {
                        sOperatingSystem = cbl.ID.Substring(3);
                        sBrowser = cbl.Items[j].Text;
                        if (sBrowser.StartsWith("IE"))
                            sBrowser = sBrowser.Replace("IE", "IExplore");
                        foreach (XmlNode node in nodes)
                        {
                            if (node.Attributes["OperatingSystem"].Value.ToUpper() == sOperatingSystem.ToUpper() && node.Attributes["Browser"].Value.ToUpper() == sBrowser.ToUpper() && node.Attributes["Active"].Value.ToLower() == "true")
                            {
                                cbl.Items[j].Selected = true;
                            }
                        }
                    }
                }
            }
        }
        /// <summary>
        /// Binds the data to the datagrid
        /// </summary>
        void BindDataGrid()
        {
            GetAllRequests();
            dgWaitingRequests.DataSource = GetAllRequests();
            dgWaitingRequests.DataBind();
        }
        /// <summary>
        /// This method will get all the requests stored in the xml file
        /// </summary>
        /// <returns></returns>
        ArrayList GetAllRequests()
        {
            ArrayList requests = new ArrayList();
            string folder = Paths.GetFilesPath();
            string time = string.Empty;
            string os = string.Empty;
            string browser = string.Empty;
            string groups = string.Empty;
            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(folder + Paths.GetQueueFile());

            XmlNode rootNode = xDoc.SelectSingleNode(Paths.GetQueueNode());

            foreach (XmlNode node in rootNode.ChildNodes)
            {
                time = node.Attributes["Date"].Value;
                os = node.Attributes["OS"].Value;
                browser = node.Attributes["Browser"].Value;
                XmlNode urlGroupNodes = node.ChildNodes[1];
                groups = string.Empty;
                foreach (XmlNode groupNode in urlGroupNodes)
                {
                    groups += groupNode.InnerText + ",";
                }
                groups = groups.Substring(0, groups.Length - 1);
                requests.Add(new requestType(time, os, browser, groups));
            }

            return requests;
        }

        /// <summary>
        /// Adds a delete buttons to the datagrid
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void dgRequests_DataBound(object sender, DataGridItemEventArgs e)
        {

            if (e.Item.ItemType != ListItemType.Header && e.Item.ItemType != ListItemType.Footer)
            {
                DataTable dt = new DataTable();
                ArrayList al = (ArrayList)dgWaitingRequests.DataSource;
                dt = Paths.ConvertObjectToDataTableSchema(al[0]);
                Paths.FillData(al, dt);
                DataView dv = new DataView(dt);
                DataColumnCollection dc = dv.Table.Columns;

                Button btnDelete = new Button();
                btnDelete.ID = "btnDelete";
                btnDelete.Text = "Delete";
                btnDelete.CausesValidation = false;
                btnDelete.Click += new System.EventHandler(btnDeleteRequest_Click);
                e.Item.Cells[4].Controls.Add(btnDelete);
            }
        }

        /// <summary>
        /// Deletes a request from the xml file
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void btnDeleteRequest_Click(object sender, EventArgs e)
        {
            DataTable dt = new DataTable();
            ArrayList al = (ArrayList)dgWaitingRequests.DataSource;
            dt = Paths.ConvertObjectToDataTableSchema(al[0]);
            DataView dv = new DataView(dt);
            DataColumnCollection dc = dv.Table.Columns;
            DataGridItem dgi = ((DataGridItem)(((Button)sender).Parent.Parent));
            string date = dgi.Cells[dc.IndexOf(dc["Date"])].Text;
            string oS = dgi.Cells[dc.IndexOf(dc["OS"])].Text;
            string browser = dgi.Cells[dc.IndexOf(dc["Browser"])].Text;
            string userName = dgi.Cells[dc.IndexOf(dc["UserName"])].Text;
            string folder = Paths.GetFilesPath();

            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(folder + Paths.GetQueueFile());

            XmlNode rootNode = xDoc.SelectSingleNode(Paths.GetQueueNode());
            foreach (XmlNode node in rootNode.ChildNodes)
            {
                if (date == node.Attributes["Date"].Value && oS == node.Attributes["OS"].Value &&
                    browser == node.Attributes["Browser"].Value && userName == node.Attributes["UserName"].Value)
                    rootNode.RemoveChild(node);
            }
            xDoc.Save(folder + Paths.GetQueueFile());
            BindDataGrid();
        }
    }

    /// <summary>
    /// This class is used to store urls.
    /// It is used when the data is bound to the datagrid.
    /// </summary>
    class requestType
    {
        string date;
        string os;
        string browser;
        string groups;

        public requestType(string date, string os, string browser, string groups)
        {
            this.os = os;
            this.date = date;
            this.browser = browser;
            this.groups = groups;
        }
        public string Date
        {
            get { return date; }
        }

        public string Os
        {
            get { return os; }
        }

        public string Browser
        {
            get { return browser; }
        }

        public string Groups
        {
            get { return groups; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\BrowserShots\BrowserShotsWebsite\BrowserShotsWebsite\Paths.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Configuration;
using System.Collections;
using System.Data;
using System.Reflection;
using System.Text;

/// <summary>
/// This class contains methods that are used through the rest of the program
/// </summary>
public class Paths
{
    /// <summary>
    /// These methods allow access to data in the app.config file
    /// </summary>
    /// <returns></returns>
    //public static string GetPath()
    //{
    //    return ConfigurationManager.AppSettings["Path"];
    //}
    public static string GetDirectoryInfoPath()
    {
        return ConfigurationManager.AppSettings["DirectoryInfoPath"];
    }
    public static string GetThumbnailPath()
    {
        return ConfigurationManager.AppSettings["ThumbnailPath"];
    }
    public static string GetScreenShotPath()
    {
        return ConfigurationManager.AppSettings["ScreenShotPath"];
    }
    public static string GetMachinesFile()
    {
        return ConfigurationManager.AppSettings["MachinesFile"];
    }
    public static string GetRegistryFile()
    {
        return ConfigurationManager.AppSettings["RegistryFile"];
    }
    public static string GetImageUrl()
    {
        return ConfigurationManager.AppSettings["ImageUrl"];
    }
    public static string GetImageUrlThumbnails()
    {
        return ConfigurationManager.AppSettings["ImageUrlThumbnails"];
    }
    //public static string GetUrlSubPath()
    //{
    //    return ConfigurationManager.AppSettings["UrlSubPath"];
    //}
    public static string GetFilesPath()
    {
        return ConfigurationManager.AppSettings["FilesPath"];
    }
    public static string GetUrlFile()
    {
        return ConfigurationManager.AppSettings["UrlFile"];
    }
    public static string GetUrlNodes()
    {
        return ConfigurationManager.AppSettings["UrlNodes"];
    }
    public static string GetUrlGroupNodes()
    {
        return ConfigurationManager.AppSettings["UrlGroupNodes"];
    }
    public static string GetDocumentation()
    {
        return ConfigurationManager.AppSettings["Documentation"];
    }
    public static string GetMachineNodes()
    {
        return ConfigurationManager.AppSettings["MachineNodes"];
    }
    public static string GetRemoteClientsNode()
    {
        return ConfigurationManager.AppSettings["RemoteClientsNode"];
    }
    public static string GetUrlsParentNode()
    {
        return ConfigurationManager.AppSettings["UrlsParentNode"];
    }
    public static string GetRegistryScreenSizeXNodes()
    {
        return ConfigurationManager.AppSettings["RegistryScreenSizeXNodes"];
    }
    public static string GetRegistryScreenSizeYNodes()
    {
        return ConfigurationManager.AppSettings["RegistryScreenSizeYNodes"];
    }
    public static string GetRegistryColorDepthNodes()
    {
        return ConfigurationManager.AppSettings["RegistryColorDepthNodes"];
    }
    public static string GetRegistryJavaScriptNodes()
    {
        return ConfigurationManager.AppSettings["RegistryJavaScriptNodes"];
    }
    public static string GetRegistryActiveXNodes()
    {
        return ConfigurationManager.AppSettings["RegistryActiveXNodes"];
    }
    public static string GetRegistryDisableScriptDebuggingNodes()
    {
        return ConfigurationManager.AppSettings["RegistryDisableScriptDebuggingNodes"];
    }
    public static string GetRegistryDisplayErrorDialogNodes()
    {
        return ConfigurationManager.AppSettings["RegistryDisplayErrorDialogNodes"];
    }
    public static string GetRegistryWarnOnZoneCrossingNodes()
    {
        return ConfigurationManager.AppSettings["RegistryWarnOnZoneCrossingNodes"];
    }
    public static string GetRegistryLimitedUserPrivilegesNodes()
    {
        return ConfigurationManager.AppSettings["RegistryLimitedUserPrivilegesNodes"];
    }
    public static string GetRegistryUserNameNode()
    {
        return ConfigurationManager.AppSettings["RegistryUserNameNode"];
    }
    public static string GetRegistryAskForPasswordNode()
    {
        return ConfigurationManager.AppSettings["AskForPasswordNode"];
    }
    public static string GetMaxLengthFolderName()
    {
        return ConfigurationManager.AppSettings["MaxLengthFolderName"];
    }
    public static string GetThumbnailWidthSize()
    {
        return ConfigurationManager.AppSettings["ThumbnailWidthSize"];
    }
    public static string GetShowAllGroupsPhrase()
    {
        return ConfigurationManager.AppSettings["ShowAllGroupsPhrase"];
    }
    public static string GetQueueFile()
    {
        return ConfigurationManager.AppSettings["mBrowserShotsQueue"].ToString();
    }
    public static string GetQueueNode()
    {
        return ConfigurationManager.AppSettings["mQueueNode"].ToString();
    }

    /// <summary>
    /// This is a helper method to bind an arraylist to a datagrid
    /// </summary>
    /// <param name="o"></param>
    /// <returns></returns>
    public static DataTable ConvertObjectToDataTableSchema(Object o)
    {
        DataTable dt = new DataTable();
        PropertyInfo[] properties = o.GetType().GetProperties();

        foreach (PropertyInfo property in properties)
        {
            DataColumn dc = new DataColumn(property.Name);
            dc.DataType = property.PropertyType; dt.Columns.Add(dc);
        }
        return dt;
    }

    /// <summary>
    /// This is a helper method to bind an arraylist to a datagrid
    /// </summary>
    /// <param name="arrayList"></param>
    /// <param name="dt"></param>
    public static void FillData(ArrayList arrayList, DataTable dt)
    {
        foreach (Object o in arrayList)
        {
            DataRow dr = dt.NewRow();
            PropertyInfo[] properties = o.GetType().GetProperties();

            foreach (PropertyInfo property in properties)
            {
                dr[property.Name] = property.GetValue(o, null);
            }
            dt.Rows.Add(dr);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\BrowserShots\BrowserShotsWebsite\BrowserShotsWebsite\Start.aspx.designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Test.Common.Utilities.BrowserShotsWebsite {
    
    
    public partial class Start {
        
        /// <summary>
        /// lblTitle control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblTitle;
        
        /// <summary>
        /// phMachines control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.PlaceHolder phMachines;
        
        /// <summary>
        /// lblScreenSize control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblScreenSize;
        
        /// <summary>
        /// lbScreenSize control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.ListBox lbScreenSize;
        
        /// <summary>
        /// lblColorDepth control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblColorDepth;
        
        /// <summary>
        /// lbColorDepth control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.ListBox lbColorDepth;
        
        /// <summary>
        /// lblJavascript control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblJavascript;
        
        /// <summary>
        /// lbJavascript control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.ListBox lbJavascript;
        
        /// <summary>
        /// lblActiveX control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblActiveX;
        
        /// <summary>
        /// lbActiveX control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.ListBox lbActiveX;
        
        /// <summary>
        /// lblDisableScriptDebugging control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblDisableScriptDebugging;
        
        /// <summary>
        /// lbDisableScriptDebugging control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.ListBox lbDisableScriptDebugging;
        
        /// <summary>
        /// lblDisplayErrorDialog control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblDisplayErrorDialog;
        
        /// <summary>
        /// lbDisplayErrorDialog control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.ListBox lbDisplayErrorDialog;
        
        /// <summary>
        /// lblWarnOnZoneCrossing control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblWarnOnZoneCrossing;
        
        /// <summary>
        /// lbWarnOnZoneCrossing control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.ListBox lbWarnOnZoneCrossing;
        
        /// <summary>
        /// lblLimitedUserPrivileges control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblLimitedUserPrivileges;
        
        /// <summary>
        /// lbLimitedUserPrivileges control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.ListBox lbLimitedUserPrivileges;
        
        /// <summary>
        /// lblGroups control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblGroups;
        
        /// <summary>
        /// lbGroups control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.ListBox lbGroups;
        
        /// <summary>
        /// btnStart control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnStart;
        
        /// <summary>
        /// lblWaitingRequests control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblWaitingRequests;
        
        /// <summary>
        /// dgWaitingRequests control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DataGrid dgWaitingRequests;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\BrowserShots\BrowserShotsWebsite\BrowserShotsWebsite\ShowImage.aspx.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Web.UI;
using System.Web.UI.WebControls;

namespace Test.Common.Utilities.BrowserShotsWebsite
{
    /// <summary>
    /// This class is used to show the thumbnail images in a seperate browser
    /// </summary>
    public partial class ShowImage : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {
            string FileName = Request.QueryString["FileName"];
            if (Request.QueryString.Count > 1)
                FileName = Request.QueryString.ToString().Substring("FileName=".Length).Replace("%3b", ";").Replace("%3d", "=");
            imgBrowserShot.ImageUrl = Paths.GetImageUrl() + FileName + ".png";
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\BrowserShots\Installer\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\BrowserShots\TakeBackupScreenShot\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\BrowserShots\BrowserShotsWebsite\BrowserShotsWebsite\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("BrowserShotsWebsite")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("MSIT")]
//[assembly: AssemblyProduct("BrowserShotsWebsite")]
//[assembly: AssemblyCopyright("Copyright © MSIT 2009")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("3d5900ae-111a-45be-96b3-d9e4606ca793")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
//[assembly: AssemblyVersion("1.0.0.0")]
//[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\BrowserShots\ViewBrowserShots\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\BrowserShots\Installer\Installer\Program.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Configuration;

namespace Test.Common.Utilities.Installer
{
    class Program
    {
        static void Main(string[] args)
        {
            string targetFilePath = GetTargetFilePath();
            System.IO.Directory.CreateDirectory(targetFilePath);

            string filePath = GetFilePath();
            DirectoryInfo di = new DirectoryInfo(filePath);
            FileInfo[] fileInfo = di.GetFiles();
            foreach (FileInfo file in fileInfo)
            {
                if(!file.Name.StartsWith("Installer"))
                    System.IO.File.Copy(filePath + "\\" + file.Name, targetFilePath + "\\" + file.Name, true);
            }
            System.Diagnostics.Process.Start(targetFilePath + "\\" + GetReadmeFile());
            System.Diagnostics.Process.Start(targetFilePath + "\\" + GetBrowserShotsService());
        }
        static string GetTargetFilePath()
        {
            return ConfigurationSettings.AppSettings["mTargetFilePath"];
        }
        static string GetFilePath()
        {
            return ConfigurationSettings.AppSettings["mFilePath"];
        }
        static string GetReadmeFile()
        {
            return ConfigurationSettings.AppSettings["mReadmeFile"];
        }
        static string GetBrowserShotsService()
        {
            return ConfigurationSettings.AppSettings["mBrowserShotsService"];
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\BrowserShots\Installer\Installer\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Installer")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("MSIT")]
//[assembly: AssemblyProduct("Installer")]
//[assembly: AssemblyCopyright("Copyright © MSIT 2008")]
//[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("3df80aab-a861-4782-b742-4ebdf6fd4f68")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
//[assembly: AssemblyVersion("1.0.0.0")]
//[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\BrowserShots\TakeBackupScreenShot\TakeBackupScreenShot\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("TakeBackupScreenShot")]
[assembly: AssemblyDescription("")]
//[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("MSIT")]
//[assembly: AssemblyProduct("TakeBackupScreenShot")]
//[assembly: AssemblyCopyright("Copyright © MSIT 2008")]
//[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("e315783c-0b20-4009-83f3-636e76eb3d0a")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
//[assembly: AssemblyVersion("1.0.0.0")]
//[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\BrowserShots\TakeBackupScreenShot\TakeBackupScreenShot\Program.cs ===
﻿using System;
using System.Collections;
using System.Text;
using System.Drawing.Imaging;
using System.Drawing;
using System.Windows.Forms;
using System.Runtime.InteropServices;
using System.IO;
using System.Configuration;


namespace Test.Common.Utilities.TakeBackupScreenShot
{
    /// <summary>
    /// This program will take a screenshot of the webpage.
    /// It is used when the full page screenshot fails
    /// </summary>
    class Program
    {
        #region Console Window property stuff
        [DllImport("kernel32.dll", ExactSpelling = true)]
        private static extern IntPtr GetConsoleWindow();

        private static IntPtr ThisConsole = GetConsoleWindow();

        [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        private static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);
        private const int HIDE = 0;
        private const int MAXIMIZE = 3;
        private const int MINIMIZE = 6;
        private const int RESTORE = 9;
        #endregion
        static void Main(string[] args)
        {
            ShowWindow(ThisConsole, HIDE); //Hides Console Window
            // The arguments are the different properties of the webpage to be taken
            string name = string.Empty;
            string operatingSystem = args[0];
            string browser = args[1];
            string screenSize = args[2];
            string colorDepth = args[3];
            if (args.Length > 5)
            {
                string javaScript = args[4];
                string activeX = args[5];
                string disableScriptDebugging = args[6];
                string displayErrorDialog = args[7];
                string warnOnZone = args[8];
                string zoom = args[9];
                string sTextSize = args[10];
                string limitedUserPriveleges = args[11];
                string url = args[12].Replace(":", "").Replace("/", "").Replace("?", "").Replace("%", "");

                name = "OS;" + operatingSystem + ";BR;" + browser + ";SS;" + screenSize + ";CD;" + colorDepth + ";JV;" + javaScript[0] + ";AX;" + activeX[0] + ";DSC;" + disableScriptDebugging[0] + ";DED;" + displayErrorDialog[0] + ";WZC;" + warnOnZone[0] + ";Z;" + zoom[0] + ";TS;" + sTextSize + ";LUP;" + limitedUserPriveleges[0] + ";URL;" + url + ";";
            }
            else
            {
                string url = args[4].Replace(":", "").Replace("/", "").Replace("?", "").Replace("%", "");
                name = "OS;" + operatingSystem + ";BR;" + browser + ";SS;" + screenSize + ";CD;" + colorDepth + ";URL;" + url + ";";
            }

            string folder = GetFolder();

            if (name.Length + folder.Length >= GetMaxFolderNameSize() + 1)
                name = name.Substring(0, GetMaxFolderNameSize() - folder.Length);

            System.Threading.Thread.Sleep(2000);
            Rectangle scrBounds = Screen.GetBounds(new Point(0, 0));
            int screenWidth = scrBounds.Width;
            int screenHeight = scrBounds.Height;

            using (Bitmap bmpScreenShot = new Bitmap(screenWidth, screenHeight))
            {
                using (Graphics gfx = Graphics.FromImage((Image)bmpScreenShot))
                {
                    try
                    {
                        gfx.CopyFromScreen(0, 0, 0, 0, new Size(screenWidth, screenHeight), CopyPixelOperation.SourceCopy);
                        bmpScreenShot.Save(folder + name + ".png", ImageFormat.Png);
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine(ex.Message);
                        using (Bitmap b1 = new Bitmap(GetErrorBitmap()))
                        {
                            try
                            {
                                b1.Save(folder + name + ".png", ImageFormat.Png);
                                Console.WriteLine("Copying error bitmap");
                            }
                            catch (Exception exc)
                            {
                                Console.WriteLine(exc.Message);
                                System.Threading.Thread.Sleep(5000);
                            }
                        }
                    }
                }
            }
        }
        static string GetFolder()
        {
            return ConfigurationSettings.AppSettings["mFolder"];
        }
        static int GetMaxFolderNameSize()
        {
            return Convert.ToInt32(ConfigurationSettings.AppSettings["mMaxFolderNameSize"]);
        }
        static string GetErrorBitmap()
        {
            return ConfigurationSettings.AppSettings["mErrorBitmap"];
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\BrowserShots\ViewBrowserShots\ViewBrowserShots\Default.aspx.cs ===
﻿using System;
using System.Collections;
using System.Configuration;
using System.Data;
using System.Linq;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.HtmlControls;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Xml.Linq;
using System.Xml;
using System.IO;

namespace Test.Common.Utilities.ViewBrowserShots
{
    public partial class _Default : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {
            if (!IsPostBack)
            {
                InsertUrls();
                InsertGroups();
                InsertRegistryValues();
            }
            ShowMachinesAndBrowsers();
            MaintainScrollPositionOnPostBack = true;
        }

        /// <summary>
        /// Submit button to display image of selected url
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void btnSubmit_Click(object sender, EventArgs e)
        {
            string selectedUrl = ddlURL.SelectedValue;
            DisplayImageOfTheSelectedUrl(selectedUrl);
        }

        /// <summary>
        /// Gets all the registry values from the xml file
        /// </summary>
        void InsertRegistryValues()
        {
            string folder = Paths.GetFilesPath();
            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(folder + Paths.GetRegistryFile());

            XmlNode screenSizeXNode = xDoc.SelectSingleNode(Paths.GetRegistryScreenSizeXNodes());
            ddlScreenSize.Items.Clear();
            foreach (XmlNode node in screenSizeXNode.ChildNodes)
            {
                ddlScreenSize.Items.Add(node.InnerText);
            }
            ddlScreenSize.Items.Add("All");
            XmlNode colorDepthNode = xDoc.SelectSingleNode(Paths.GetRegistryColorDepthNodes());
            ddlColorDepth.Items.Clear();
            foreach (XmlNode node in colorDepthNode.ChildNodes)
            {
                ddlColorDepth.Items.Add(node.InnerText);
            }
            ddlColorDepth.Items.Add("Both");
            XmlNode javaScriptNode = xDoc.SelectSingleNode(Paths.GetRegistryJavaScriptNodes());
            ddlJavascript.Items.Clear();
            foreach (XmlNode node in javaScriptNode.ChildNodes)
            {
                ddlJavascript.Items.Add(node.InnerText);
            }
            ddlJavascript.Items.Add("Both");
            XmlNode activeXNode = xDoc.SelectSingleNode(Paths.GetRegistryActiveXNodes());
            ddlActiveX.Items.Clear();
            foreach (XmlNode node in activeXNode.ChildNodes)
            {
                ddlActiveX.Items.Add(node.InnerText);
            }
            ddlActiveX.Items.Add("Both");
            XmlNode disableScriptDebuggingNode = xDoc.SelectSingleNode(Paths.GetRegistryDisableScriptDebuggingNodes());
            ddlDisableScriptDebugging.Items.Clear();
            foreach (XmlNode node in disableScriptDebuggingNode.ChildNodes)
            {
                ddlDisableScriptDebugging.Items.Add(node.InnerText);
            }
            ddlDisableScriptDebugging.Items.Add("Both");
            XmlNode displayErrorDialogNode = xDoc.SelectSingleNode(Paths.GetRegistryDisplayErrorDialogNodes());
            ddlDisplayErrorDialog.Items.Clear();
            foreach (XmlNode node in displayErrorDialogNode.ChildNodes)
            {
                ddlDisplayErrorDialog.Items.Add(node.InnerText);
            }
            ddlDisplayErrorDialog.Items.Add("Both");
            XmlNode warnOnZoneCrossingNode = xDoc.SelectSingleNode(Paths.GetRegistryWarnOnZoneCrossingNodes());
            ddlWarnOnZoneCrossing.Items.Clear();
            foreach (XmlNode node in warnOnZoneCrossingNode.ChildNodes)
            {
                ddlWarnOnZoneCrossing.Items.Add(node.InnerText);
            }
            ddlWarnOnZoneCrossing.Items.Add("Both");
            XmlNode zoomNode = xDoc.SelectSingleNode(Paths.GetZoomNodes());
            ddlZoom.Items.Clear();
            foreach (XmlNode node in zoomNode.ChildNodes)
            {
                ddlZoom.Items.Add(node.InnerText);
            }
            ddlZoom.Items.Add("All");
            XmlNode textSizeNode = xDoc.SelectSingleNode(Paths.GetTextSizeNodes());
            ddlTextSize.Items.Clear();
            foreach (XmlNode node in textSizeNode.ChildNodes)
            {
                ddlTextSize.Items.Add(node.InnerText);
            }
            ddlTextSize.Items.Add("All");
            XmlNode limitedUserPrivilegesNode = xDoc.SelectSingleNode(Paths.GetRegistryLimitedUserPrivilegesNodes());
            ddlLimitedUserPrivileges.Items.Clear();
            foreach (XmlNode node in limitedUserPrivilegesNode.ChildNodes)
            {
                ddlLimitedUserPrivileges.Items.Add(node.InnerText);
            }
        }
        /// <summary>
        /// This method will display the image of the selected url
        /// </summary>
        /// <param name="selectedUrl"></param>
        /// <returns>Number of items displayed</returns>
        int DisplayImageOfTheSelectedUrl(string selectedUrl)
        {
            ArrayList fileNames = new ArrayList();
            string operatingSystem = string.Empty;
            string browser = string.Empty;
            ArrayList alOperatingSystem = new ArrayList();
            string sOperatingSystem;

            foreach (Control control in phMachines.Controls)
            {
                Console.WriteLine(control.ID);
                if (control.ID != null && control.ID.StartsWith("cbl") && control is CheckBoxList)
                {
                    CheckBoxList cbl = (CheckBoxList)control;
                    for (int j = 0; j < cbl.Items.Count; j++)
                    {
                        if (cbl.Items[j].Selected)
                        {
                            sOperatingSystem = cbl.ID.Substring(3) + " " + cbl.Items[j].Text;
                            alOperatingSystem.Add(sOperatingSystem);
                        }
                    }
                }
            }

            string newActiveScriptSetting = ddlJavascript.SelectedValue;
            string newActiveXSetting = ddlActiveX.SelectedValue;
            string disableScriptDebugging = ddlDisableScriptDebugging.SelectedValue;
            string errorDlgDisplayedOnEveryError = ddlDisplayErrorDialog.SelectedValue;
            string warnOnZoneCrossing = ddlWarnOnZoneCrossing.SelectedValue;
            string zoom = ddlZoom.SelectedValue;
            string textSize = ddlTextSize.SelectedValue;
            string limitedUserPrivileges = ddlLimitedUserPrivileges.SelectedValue;
            string newXResolution = ddlScreenSize.SelectedValue;
            string colorDepth = ddlColorDepth.SelectedValue;
            string url = selectedUrl.Replace(":", "").Replace("/", "").Replace("?", "").Replace("%", "");

            Label lbUrl = new Label();
            lbUrl.ID = "lbUrl";
            lbUrl.Text = "URL: " + selectedUrl;

            phImages.Controls.Add(new LiteralControl("<br/><br/>"));
            phImages.Controls.Add(lbUrl);
            phImages.Controls.Add(new LiteralControl("<br/>"));

            string[] xRes = newXResolution.Split(' ');
            string[] color = colorDepth.Split(' ');
            ArrayList arrayListxRes = new ArrayList();
            if (xRes[0] == "All")
            {
                foreach (ListItem item in ddlScreenSize.Items)
                {
                    if (item.Text != "All")
                    {
                        string[] aXRes = item.Text.Split(' ');
                        arrayListxRes.Add(aXRes[0]);

                    }
                }
            }
            else
            {
                arrayListxRes.Add(xRes[0]);
            }

            ArrayList arrayListColor = new ArrayList();
            if (color[0] == "Both")
            {
                foreach (ListItem item in ddlColorDepth.Items)
                {
                    if (item.Text != "Both")
                    {
                        string[] aColorDepth = item.Text.Split(' ');
                        arrayListColor.Add(aColorDepth[0]);

                    }
                }
            }
            else
            {
                arrayListColor.Add(color[0]);
            }

            ArrayList arrayListActiveScriptSetting = new ArrayList();
            if (newActiveScriptSetting == "Both")
            {
                foreach (ListItem item in ddlJavascript.Items)
                {
                    if (item.Text != "Both")
                    {
                        string[] aActiveScriptSetting = item.Text.Split(' ');
                        arrayListActiveScriptSetting.Add(aActiveScriptSetting[0]);

                    }
                }
            }
            else
            {
                arrayListActiveScriptSetting.Add(newActiveScriptSetting);
            }

            ArrayList arrayListActiveXSetting = new ArrayList();
            if (newActiveXSetting == "Both")
            {
                foreach (ListItem item in ddlActiveX.Items)
                {
                    if (item.Text != "Both")
                    {
                        string[] aActiveX = item.Text.Split(' ');
                        arrayListActiveXSetting.Add(aActiveX[0]);

                    }
                }
            }
            else
            {
                arrayListActiveXSetting.Add(newActiveXSetting);
            }

            ArrayList arrayListDisableScriptDebugging = new ArrayList();
            if (disableScriptDebugging == "Both")
            {
                foreach (ListItem item in ddlDisableScriptDebugging.Items)
                {
                    if (item.Text != "Both")
                    {
                        string[] aDisableScriptDebugging = item.Text.Split(' ');
                        arrayListDisableScriptDebugging.Add(aDisableScriptDebugging[0]);
                    }
                }
            }
            else
            {
                arrayListDisableScriptDebugging.Add(disableScriptDebugging);
            }

            ArrayList arrayListErrorDlgDisplayedOnEveryError = new ArrayList();
            if (errorDlgDisplayedOnEveryError == "Both")
            {
                foreach (ListItem item in ddlDisplayErrorDialog.Items)
                {
                    if (item.Text != "Both")
                    {
                        string[] aErrorDlgDisplayedOnEveryError = item.Text.Split(' ');
                        arrayListErrorDlgDisplayedOnEveryError.Add(aErrorDlgDisplayedOnEveryError[0]);
                    }
                }
            }
            else
            {
                arrayListErrorDlgDisplayedOnEveryError.Add(errorDlgDisplayedOnEveryError);
            }

            ArrayList arrayListWarnOnZoneCrossing = new ArrayList();
            if (warnOnZoneCrossing == "Both")
            {
                foreach (ListItem item in ddlWarnOnZoneCrossing.Items)
                {
                    if (item.Text != "Both")
                    {
                        string[] aWarnOnZoneCrossing = item.Text.Split(' ');
                        arrayListWarnOnZoneCrossing.Add(aWarnOnZoneCrossing[0]);
                    }
                }
            }
            else
            {
                arrayListWarnOnZoneCrossing.Add(warnOnZoneCrossing);
            }

            ArrayList arrayListZoom = new ArrayList();
            if(zoom == "All")
            {
                foreach (ListItem item in ddlZoom.Items)
                {
                    if (item.Text != "All")
                    {
                        string[] aZoom = item.Text.Split(' ');
                        arrayListZoom.Add(aZoom[0]);
                    }
                }
            }
            else
            {
                arrayListZoom.Add(zoom);
            }

            ArrayList arrayListTextSize = new ArrayList();
            if (textSize == "All")
            {
                foreach (ListItem item in ddlTextSize.Items)
                {
                    if (item.Text != "All")
                    {
                        string[] aTextSize = item.Text.Split(' ');
                        arrayListTextSize.Add(aTextSize[0]);
                    }
                }
            }
            else
            {
                arrayListTextSize.Add(textSize);
            }

            ArrayList arrayListLimitedUserPrivileges = new ArrayList();
            if (limitedUserPrivileges == "Both")
            {
                foreach (ListItem item in ddlLimitedUserPrivileges.Items)
                {
                    if (item.Text != "Both")
                    {
                        string[] aLimitedUserPrivileges = item.Text.Split(' ');
                        arrayListLimitedUserPrivileges.Add(aLimitedUserPrivileges[0]);
                    }
                }
            }
            else
            {
                arrayListLimitedUserPrivileges.Add(limitedUserPrivileges);
            }

            string name = string.Empty;
            string longName = string.Empty;
            string folder = Paths.GetScreenShotPath();

            foreach (string os in alOperatingSystem)
            {
                foreach (string sXRes in arrayListxRes)
                {
                    foreach (string sColor in arrayListColor)
                    {
                        if (os.Contains("Firefox"))
                        {
                            string[] sOS = os.Split(' ');
                            operatingSystem = sOS[0];
                            browser = sOS[1];
                            name = "OS;" + operatingSystem + ";BR;" + browser + ";SS;" + sXRes + ";CD;" + sColor + ";URL;" + url + ";";
                            longName = "OS: " + operatingSystem + " BR: " + browser + " SS: " + sXRes + " CD: " + sColor;

                            if (name.Length + folder.Length > Convert.ToInt32(Paths.GetMaxLengthFolderName()))
                                name = name.Substring(0, Convert.ToInt32(Paths.GetMaxLengthFolderName()) - folder.Length);

                            fileNames.Add(new names(name, longName));
                            continue;
                        }
                        foreach (string sNewActiveScriptSetting in arrayListActiveScriptSetting)
                        {
                            foreach (string sNewActiveXSetting in arrayListActiveXSetting)
                            {
                                foreach (string sDisableScriptDebugging in arrayListDisableScriptDebugging)
                                {
                                    foreach (string sErrorDlgDisplayedOnEveryError in arrayListErrorDlgDisplayedOnEveryError)
                                    {
                                        foreach (string sWarnOnZoneCrossing in arrayListWarnOnZoneCrossing)
                                        {
                                            foreach (string sZoom in arrayListZoom)
                                            {
                                                foreach (string sTextSize in arrayListTextSize)
                                                {
                                                    foreach (string sLimitedUserPrivileges in arrayListLimitedUserPrivileges)
                                                    {
                                                        string[] sOS = os.Split(' ');
                                                        operatingSystem = sOS[0];
                                                        browser = sOS[1];
                                                        name = "OS;" + operatingSystem + ";BR;" + browser + ";SS;" + sXRes + ";CD;" + sColor + ";JV;" + sNewActiveScriptSetting[0] + ";AX;" + sNewActiveXSetting[0] + ";DSC;" + sDisableScriptDebugging[0] + ";DED;" + sErrorDlgDisplayedOnEveryError[0] + ";WZC;" + sWarnOnZoneCrossing[0] + ";Z;" + sZoom[0] + ";TS;" + sTextSize[0] + ";LUP;" + sLimitedUserPrivileges[0] + ";URL;" + url + ";";
                                                        longName = "OS: " + operatingSystem + " BR: " + browser + " SS: " + sXRes + " CD: " + sColor + " JS: " + sNewActiveScriptSetting + " AX: " + sNewActiveXSetting + " DSD: " + sDisableScriptDebugging + " DED: " + sErrorDlgDisplayedOnEveryError + " WZC: " + sWarnOnZoneCrossing + " Z:" + sZoom + " TS:" + sTextSize + " LUP: " + sLimitedUserPrivileges;

                                                        if (name.Length + folder.Length > Convert.ToInt32(Paths.GetMaxLengthFolderName()))
                                                            name = name.Substring(0, Convert.ToInt32(Paths.GetMaxLengthFolderName()) - folder.Length);

                                                        fileNames.Add(new names(name, longName));
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            int i = 0;
            string date = string.Empty;
            phImages.Controls.Add(new LiteralControl("<table>"));
            int fileNum = 0, picsPerRow = 1, currentPic = 0;
            if (cbThumbnails.Checked)
                picsPerRow = Convert.ToInt32(ddlPerRow.SelectedValue);
            string resize = ddlThumbnailsResize.SelectedValue;
            int iResize = Convert.ToInt32(resize.Substring(0, resize.Length - 1));
            foreach (names fileName in fileNames)
            {
                date = GetDateOfFile(fileName.Name);
                if (date == null)
                {
                    Label lblNameNotFound = new Label();
                    lblNameNotFound.ID = "lbDate" + i;
                    lblNameNotFound.Text = fileName.LongName + " NOT FOUND";

                    phImages.Controls.Add(new LiteralControl("<br/>"));
                    phImages.Controls.Add(lblNameNotFound);

                    continue;
                }

                Label lbDate = new Label();
                lbDate.ID = "lbDate" + i;
                lbDate.Text = "Date: " + date;

                Label lbName = new Label();
                lbName.ID = "lbDate" + i;
                lbName.Text = fileName.LongName;

                if (cbThumbnails.Checked)
                {
                    System.Drawing.Image FullsizeImage = System.Drawing.Image.FromFile(Paths.GetScreenShotPath() + fileName.Name + ".png");
                    int width = FullsizeImage.Width * iResize / 100;
                    int height = FullsizeImage.Height * iResize / 100;
                    System.Drawing.Image ThumbnailImage = FullsizeImage.GetThumbnailImage(width, height, null, IntPtr.Zero);
                    FullsizeImage.Dispose();
                    System.IO.FileStream fs = System.IO.File.Open(Paths.GetThumbnailPath() + fileName.Name + ".png", FileMode.OpenOrCreate);
                    ThumbnailImage.Save(fs, System.Drawing.Imaging.ImageFormat.Png);
                    fs.Close();
                    ThumbnailImage.Dispose();
                }
                Image im = new Image();
                im.ID = "im" + i;

                im.ImageUrl = Paths.GetImageUrl() + fileName.Name + ".png";
                if (cbThumbnails.Checked)
                {
                    im.ImageUrl = Paths.GetImageUrlThumbnails() + fileName.Name + ".png";
                }

                HyperLink hLink = new HyperLink();
                hLink.ID = "hl" + i;
                hLink.Text = "Show";
                string windowName = "subwindow" + i;
                hLink.NavigateUrl = "javascript:window.open('ShowImage.aspx?FileName=" + fileName.Name + "','" + windowName + "', 'menubar=1,resizable=1, scrollbars=1, width=500,height=500'); void('');";

                if (fileNum % picsPerRow == 0)
                {
                    phImages.Controls.Add(new LiteralControl("<tr>"));
                }
                currentPic++;
                phImages.Controls.Add(new LiteralControl("<td>"));
                phImages.Controls.Add(new LiteralControl("<br/>"));
                phImages.Controls.Add(lbDate);
                phImages.Controls.Add(new LiteralControl("<br/>"));
                phImages.Controls.Add(lbName);
                phImages.Controls.Add(new LiteralControl("<br/>"));
                if (cbThumbnails.Checked)
                {
                    phImages.Controls.Add(hLink);
                    phImages.Controls.Add(new LiteralControl("<br/>"));
                }
                phImages.Controls.Add(im);
                phImages.Controls.Add(new LiteralControl("<br/>"));
                phImages.Controls.Add(new LiteralControl("</td>"));
                if (currentPic == picsPerRow || fileNum + 1 == fileNames.Count)
                {
                    phImages.Controls.Add(new LiteralControl("</tr>"));
                    currentPic = 0;
                }
                i++;
                fileNum++;
            }
            phImages.Controls.Add(new LiteralControl("</table>"));


            return fileNames.Count;
        }


        int DisplayImagesOfAllUrls(int maxNumImages)
        {
            ArrayList fileNames = new ArrayList();
            string operatingSystem = string.Empty;
            string browser = string.Empty;
            ArrayList alOperatingSystem = new ArrayList();
            string sOperatingSystem;

            foreach (Control control in phMachines.Controls)
            {
                Console.WriteLine(control.ID);
                if (control.ID != null && control.ID.StartsWith("cbl") && control is CheckBoxList)
                {
                    CheckBoxList cbl = (CheckBoxList)control;
                    for (int j = 0; j < cbl.Items.Count; j++)
                    {
                        if (cbl.Items[j].Selected)
                        {
                            sOperatingSystem = cbl.ID.Substring(3) + " " + cbl.Items[j].Text;
                            alOperatingSystem.Add(sOperatingSystem);
                        }
                    }
                }
            }

            string newActiveScriptSetting = ddlJavascript.SelectedValue;
            string newActiveXSetting = ddlActiveX.SelectedValue;
            string disableScriptDebugging = ddlDisableScriptDebugging.SelectedValue;
            string errorDlgDisplayedOnEveryError = ddlDisplayErrorDialog.SelectedValue;
            string warnOnZoneCrossing = ddlWarnOnZoneCrossing.SelectedValue;
            string limitedUserPrivileges = ddlLimitedUserPrivileges.SelectedValue;
            string newXResolution = ddlScreenSize.SelectedValue;
            string colorDepth = ddlColorDepth.SelectedValue;

            string[] xRes = newXResolution.Split(' ');
            string[] color = colorDepth.Split(' ');
            ArrayList arrayListxRes = new ArrayList();
            if (xRes[0] == "All")
            {
                foreach (ListItem item in ddlScreenSize.Items)
                {
                    if (item.Text != "All")
                    {
                        string[] aXRes = item.Text.Split(' ');
                        arrayListxRes.Add(aXRes[0]);
                    }
                }
            }
            else
            {
                arrayListxRes.Add(xRes[0]);
            }

            ArrayList arrayListColor = new ArrayList();
            if (color[0] == "Both")
            {
                foreach (ListItem item in ddlColorDepth.Items)
                {
                    if (item.Text != "Both")
                    {
                        string[] aColorDepth = item.Text.Split(' ');
                        arrayListColor.Add(aColorDepth[0]);

                    }
                }
            }
            else
            {
                arrayListColor.Add(color[0]);
            }

            ArrayList arrayListActiveScriptSetting = new ArrayList();
            if (newActiveScriptSetting == "Both")
            {
                foreach (ListItem item in ddlJavascript.Items)
                {
                    if (item.Text != "Both")
                    {
                        string[] aActiveScriptSetting = item.Text.Split(' ');
                        arrayListActiveScriptSetting.Add(aActiveScriptSetting[0]);

                    }
                }
            }
            else
            {
                arrayListActiveScriptSetting.Add(newActiveScriptSetting);
            }

            ArrayList arrayListActiveXSetting = new ArrayList();
            if (newActiveXSetting == "Both")
            {
                foreach (ListItem item in ddlActiveX.Items)
                {
                    if (item.Text != "Both")
                    {
                        string[] aActiveX = item.Text.Split(' ');
                        arrayListActiveXSetting.Add(aActiveX[0]);

                    }
                }
            }
            else
            {
                arrayListActiveXSetting.Add(newActiveXSetting);
            }

            ArrayList arrayListDisableScriptDebugging = new ArrayList();
            if (disableScriptDebugging == "Both")
            {
                foreach (ListItem item in ddlDisableScriptDebugging.Items)
                {
                    if (item.Text != "Both")
                    {
                        string[] aDisableScriptDebugging = item.Text.Split(' ');
                        arrayListDisableScriptDebugging.Add(aDisableScriptDebugging[0]);
                    }
                }
            }
            else
            {
                arrayListDisableScriptDebugging.Add(disableScriptDebugging);
            }

            ArrayList arrayListErrorDlgDisplayedOnEveryError = new ArrayList();
            if (errorDlgDisplayedOnEveryError == "Both")
            {
                foreach (ListItem item in ddlDisplayErrorDialog.Items)
                {
                    if (item.Text != "Both")
                    {
                        string[] aErrorDlgDisplayedOnEveryError = item.Text.Split(' ');
                        arrayListErrorDlgDisplayedOnEveryError.Add(aErrorDlgDisplayedOnEveryError[0]);
                    }
                }
            }
            else
            {
                arrayListErrorDlgDisplayedOnEveryError.Add(errorDlgDisplayedOnEveryError);
            }

            ArrayList arrayListWarnOnZoneCrossing = new ArrayList();
            if (warnOnZoneCrossing == "Both")
            {
                foreach (ListItem item in ddlWarnOnZoneCrossing.Items)
                {
                    if (item.Text != "Both")
                    {
                        string[] aWarnOnZoneCrossing = item.Text.Split(' ');
                        arrayListWarnOnZoneCrossing.Add(aWarnOnZoneCrossing[0]);
                    }
                }
            }
            else
            {
                arrayListWarnOnZoneCrossing.Add(warnOnZoneCrossing);
            }

            ArrayList arrayListLimitedUserPrivileges = new ArrayList();
            if (limitedUserPrivileges == "Both")
            {
                foreach (ListItem item in ddlLimitedUserPrivileges.Items)
                {
                    if (item.Text != "Both")
                    {
                        string[] aLimitedUserPrivileges = item.Text.Split(' ');
                        arrayListLimitedUserPrivileges.Add(aLimitedUserPrivileges[0]);
                    }
                }
            }
            else
            {
                arrayListLimitedUserPrivileges.Add(limitedUserPrivileges);
            }

            string name = string.Empty;
            string longName = string.Empty;
            string folder = Paths.GetScreenShotPath();

            foreach (ListItem item in ddlURL.Items)
            {
                if (fileNames.Count > maxNumImages)
                    break;
                string selectedUrl = item.Text.ToString();
                string url = selectedUrl.Replace(":", "").Replace("/", "").Replace("?", "").Replace("%", "");
                foreach (string os in alOperatingSystem)
                {
                    foreach (string sXRes in arrayListxRes)
                    {
                        foreach (string sColor in arrayListColor)
                        {
                            if (os.Contains("Firefox"))
                            {
                                string[] sOS = os.Split(' ');
                                operatingSystem = sOS[0];
                                browser = sOS[1];
                                name = "OS;" + operatingSystem + ";BR;" + browser + ";SS;" + sXRes + ";CD;" + sColor + ";URL;" + url + ";";
                                longName = "OS: " + operatingSystem + " BR: " + browser + " SS: " + sXRes + " CD: " + sColor;

                                if (name.Length + folder.Length > Convert.ToInt32(Paths.GetMaxLengthFolderName()))
                                    name = name.Substring(0, Convert.ToInt32(Paths.GetMaxLengthFolderName()) - folder.Length);

                                fileNames.Add(new names(name, longName));
                                continue;
                            }
                            foreach (string sNewActiveScriptSetting in arrayListActiveScriptSetting)
                            {
                                foreach (string sNewActiveXSetting in arrayListActiveXSetting)
                                {
                                    foreach (string sDisableScriptDebugging in arrayListDisableScriptDebugging)
                                    {
                                        foreach (string sErrorDlgDisplayedOnEveryError in arrayListErrorDlgDisplayedOnEveryError)
                                        {
                                            foreach (string sWarnOnZoneCrossing in arrayListWarnOnZoneCrossing)
                                            {
                                                foreach (string sLimitedUserPrivileges in arrayListLimitedUserPrivileges)
                                                {
                                                    string[] sOS = os.Split(' ');
                                                    operatingSystem = sOS[0];
                                                    browser = sOS[1];
                                                    name = "OS;" + operatingSystem + ";BR;" + browser + ";SS;" + sXRes + ";CD;" + sColor + ";JV;" + sNewActiveScriptSetting[0] + ";AX;" + sNewActiveXSetting[0] + ";DSC;" + sDisableScriptDebugging[0] + ";DED;" + sErrorDlgDisplayedOnEveryError[0] + ";WZC;" + sWarnOnZoneCrossing[0] + ";LUP;" + sLimitedUserPrivileges[0] + ";URL;" + url + ";";
                                                    longName = "OS: " + operatingSystem + " BR: " + browser + " SS: " + sXRes + " CD: " + sColor + " JS: " + sNewActiveScriptSetting + " AX: " + sNewActiveXSetting + " DSD: " + sDisableScriptDebugging + " DED: " + sErrorDlgDisplayedOnEveryError + " WZC: " + sWarnOnZoneCrossing + " LUP: " + sLimitedUserPrivileges;

                                                    if (name.Length + folder.Length > Convert.ToInt32(Paths.GetMaxLengthFolderName()))
                                                        name = name.Substring(0, Convert.ToInt32(Paths.GetMaxLengthFolderName()) - folder.Length);

                                                    fileNames.Add(new names(name, longName));
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            int i = 0;
            string date = string.Empty;
            phImages.Controls.Add(new LiteralControl("<table>"));
            int fileNum = 0, picsPerRow = 1, currentPic = 0;
            if (cbThumbnails.Checked)
                picsPerRow = Convert.ToInt32(ddlPerRow.SelectedValue);
            string resize = ddlThumbnailsResize.SelectedValue;
            int iResize = Convert.ToInt32(resize.Substring(0, resize.Length - 1));
            foreach (names fileName in fileNames)
            {
                date = GetDateOfFile(fileName.Name);
                if (date == null)
                {
                    Label lblNameNotFound = new Label();
                    lblNameNotFound.ID = "lbDate" + i;
                    lblNameNotFound.Text = fileName.LongName + " NOT FOUND";

                    phImages.Controls.Add(new LiteralControl("<br/>"));
                    phImages.Controls.Add(lblNameNotFound);

                    continue;
                }

                Label lbDate = new Label();
                lbDate.ID = "lbDate" + i;
                lbDate.Font.Size = 10;
                lbDate.Text = "Date: " + date;

                string selectedUrl = fileName.Name.Substring(fileName.Name.IndexOf("URL;") + 4).Replace(";", "");
                //selectedUrl = selectedUrl.Substring(selectedUrl.IndexOf("com") + 3);
                int index = selectedUrl.IndexOf("http");
                if (index >= 0)
                    selectedUrl = selectedUrl.Substring(index + 4);

                Label lbUrl = new Label();
                lbUrl.ID = "lbUrl" + i;
                lbUrl.Font.Size = 10;
                lbUrl.Text = "URL: " + selectedUrl;

                Label lbName = new Label();
                lbName.ID = "lbDate" + i;
                lbName.Font.Size = 10;
                lbName.Text = fileName.LongName;

                if (cbThumbnails.Checked)
                {
                    System.Drawing.Image FullsizeImage = System.Drawing.Image.FromFile(Paths.GetScreenShotPath() + fileName.Name + ".png");
                    int width = FullsizeImage.Width * iResize / 100;
                    int height = FullsizeImage.Height * iResize / 100;
                    System.Drawing.Image ThumbnailImage = FullsizeImage.GetThumbnailImage(width, height, null, IntPtr.Zero);
                    FullsizeImage.Dispose();
                    System.IO.FileStream fs = System.IO.File.Open(Paths.GetThumbnailPath() + fileName.Name + ".png", FileMode.OpenOrCreate);
                    ThumbnailImage.Save(fs, System.Drawing.Imaging.ImageFormat.Png);
                    fs.Close();
                    ThumbnailImage.Dispose();
                }
                Image im = new Image();
                im.ID = "im" + i;

                im.ImageUrl = Paths.GetImageUrl() + fileName.Name + ".png";
                if (cbThumbnails.Checked)
                {
                    im.ImageUrl = Paths.GetImageUrlThumbnails() + fileName.Name + ".png";
                }

                HyperLink hLink = new HyperLink();
                hLink.ID = "hl" + i;
                hLink.Text = "Show";
                string windowName = "subwindow" + i;
                hLink.NavigateUrl = "javascript:window.open('ShowImage.aspx?FileName=" + fileName.Name + "','" + windowName + "', 'menubar=1,resizable=1, scrollbars=1, width=500,height=500'); void('');";

                if (fileNum % picsPerRow == 0)
                {
                    phImages.Controls.Add(new LiteralControl("<tr>"));
                }
                currentPic++;
                phImages.Controls.Add(new LiteralControl("<td>"));
                phImages.Controls.Add(new LiteralControl("<br/>"));
                phImages.Controls.Add(lbDate);
                phImages.Controls.Add(new LiteralControl("<br/>"));
                phImages.Controls.Add(lbUrl);
                phImages.Controls.Add(new LiteralControl("<br/>"));
                phImages.Controls.Add(lbName);
                phImages.Controls.Add(new LiteralControl("<br/>"));
                if (cbThumbnails.Checked)
                {
                    phImages.Controls.Add(hLink);
                    phImages.Controls.Add(new LiteralControl("<br/>"));
                }
                phImages.Controls.Add(im);
                phImages.Controls.Add(new LiteralControl("<br/>"));
                phImages.Controls.Add(new LiteralControl("</td>"));
                if (currentPic == picsPerRow || fileNum + 1 == fileNames.Count)
                {
                    phImages.Controls.Add(new LiteralControl("</tr>"));
                    currentPic = 0;
                }
                i++;
                fileNum++;
            }
            phImages.Controls.Add(new LiteralControl("</table>"));

            return fileNames.Count;
        }

        /// <summary>
        /// Gets date of the image file to be displayed on the webpage
        /// </summary>
        /// <param name="fileName"></param>
        /// <returns></returns>
        string GetDateOfFile(string fileName)
        {
            string date = string.Empty;
            DirectoryInfo di = new DirectoryInfo(Paths.GetDirectoryInfoPath());
            FileInfo[] fileInfo = di.GetFiles();
            foreach (FileInfo file in fileInfo)
            {
                if (file.Name.ToUpper() == (fileName + ".png").ToUpper())
                {
                    date = file.LastWriteTime.ToString();
                    return date;
                }
            }

            return null;
        }

        /// <summary>
        /// Gets all the urls from the xml file and inserts them in the dropdown list
        /// </summary>
        void InsertUrls()
        {
            string folder = Paths.GetFilesPath();
            string url = string.Empty;
            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(folder + Paths.GetUrlFile());

            XmlNodeList nodes = xDoc.SelectNodes(Paths.GetUrlNodes());
            foreach (XmlNode node in nodes)
            {
                url = node.InnerText.ToString();
                ddlURL.Items.Add(url);
            }
        }

        /// <summary>
        /// Gets all the urls from the xml file, filtered by group, and inserts them in the dropdown list
        /// </summary>
        /// <param name="groupValue"></param>
        void InsertUrls(string groupValue)
        {
            ddlURL.Items.Clear();
            if (groupValue == Paths.GetShowAllGroupsPhrase())
            {
                btnShowAllUrls.Visible = false;
                rblNumImages.Visible = false;
                lblNumImages.Visible = false;
                InsertUrls();
                return;
            }
            btnShowAllUrls.Visible = true;
            rblNumImages.Visible = true;
            lblNumImages.Visible = true;
            string folder = Paths.GetFilesPath();
            string url = string.Empty;
            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(folder + Paths.GetUrlFile());

            XmlNodeList nodes = xDoc.SelectNodes("//Urls/urlGroup[@group='" + groupValue + "']/url");
            foreach (XmlNode node in nodes)
            {
                url = node.InnerText.ToString();
                ddlURL.Items.Add(url);
            }
        }

        /// <summary>
        /// Gets all the groups from the xml file and inserts them in the dropdown list
        /// </summary>
        void InsertGroups()
        {
            string folder = Paths.GetFilesPath();
            string group = string.Empty;
            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(folder + Paths.GetUrlFile());

            XmlNodeList nodes = xDoc.SelectNodes(Paths.GetUrlGroupNodes());
            ddlGroups.Items.Add(Paths.GetShowAllGroupsPhrase());
            foreach (XmlNode node in nodes)
            {
                group = node.Attributes["group"].Value;
                ddlGroups.Items.Add(group);
            }
        }

        /// <summary>
        /// Shows all the machines with their browsers from the xml file
        /// </summary>
        void ShowMachinesAndBrowsers()
        {
            string folder = Paths.GetFilesPath();
            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(folder + Paths.GetMachinesFile());

            XmlNodeList nodes = xDoc.SelectNodes(Paths.GetMachineNodes());
            ArrayList configs = new ArrayList();
            ArrayList OpSystems = new ArrayList();
            foreach (XmlNode xNode in nodes)
            {
                string os = xNode.Attributes["OperatingSystem"].Value;
                if (!OpSystems.Contains(os))
                    OpSystems.Add(os);
                string browser = xNode.Attributes["Browser"].Value.Replace("IExplore", "IE");
                string config = os + " " + browser;
                if (!configs.Contains(config))
                    configs.Add(config);
            }
            phMachines.Controls.Add(new LiteralControl("<table><tr>"));
            foreach (string os in OpSystems)
            {
                Label lb = new Label();
                lb.ID = "lbl" + os;
                lb.Text = os;
                lb.Style.Add("font-size", "x-large");
                phMachines.Controls.Add(new LiteralControl("<td valign=\"top\">"));
                phMachines.Controls.Add(lb);
                CheckBoxList cbl = new CheckBoxList();
                cbl.ID = "cbl" + os;
                cbl.Style.Add("font-size", "larger");
                foreach (string sOperatingSystem in configs)
                {
                    if (sOperatingSystem.StartsWith(os))
                    {
                        cbl.Items.Add(new ListItem(sOperatingSystem.Substring(sOperatingSystem.IndexOf(" ") + 1)));
                    }
                }
                phMachines.Controls.Add(cbl);
                phMachines.Controls.Add(new LiteralControl("</td>"));
            }
            phMachines.Controls.Add(new LiteralControl("</tr></table>"));
        }

        /// <summary>
        /// Shows the next url image
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void btnNextUrl_Click(object sender, EventArgs e)
        {
            int count = ddlURL.Items.Count;
            if (ddlURL.SelectedIndex < 0)
                ddlURL.SelectedIndex = 0;
            else
            {
                ddlURL.SelectedIndex = (ddlURL.SelectedIndex + 1) % count;
            }
            string selectedUrl = ddlURL.SelectedValue;
            DisplayImageOfTheSelectedUrl(selectedUrl);
        }

        /// <summary>
        /// Shows the previous url image
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void btnPreviousUrl_Click(object sender, EventArgs e)
        {
            int count = ddlURL.Items.Count;
            int selectedIndex = ddlURL.SelectedIndex - 1;

            if (selectedIndex < 0)
                selectedIndex = count - 1;

            ddlURL.SelectedIndex = selectedIndex;
            string selectedUrl = ddlURL.SelectedValue;
            DisplayImageOfTheSelectedUrl(selectedUrl);
        }

        /// <summary>
        /// Updates the urls based on the group selected
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void ddlGroups_SelectedIndexChanged(object sender, EventArgs e)
        {
            string groupValue = ddlGroups.SelectedValue;
            InsertUrls(groupValue);
        }

        /// <summary>
        /// Shows the images of all urls in the group selected
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void btnShowAllUrls_Click(object sender, EventArgs e)
        {
            int count = 0;
            string maximum = rblNumImages.SelectedValue;
            int maxNumImages = 0;
            if (maximum == "No Limit")
                maxNumImages = 10000;
            else
                maxNumImages = Convert.ToInt32(maximum);
            if (!cbThumbnails.Checked || cbGroupByUrl.Checked)
            {
                foreach (ListItem item in ddlURL.Items)
                {
                    string url = item.Text.ToString();
                    count += DisplayImageOfTheSelectedUrl(url);
                    if (count > maxNumImages)
                        break;
                }
            }
            else
            {
                DisplayImagesOfAllUrls(maxNumImages);
            }
        }

        /// <summary> 
        /// To show controls associated with thumbnails.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        public void ThumbnailsCheck_Clicked(Object sender, EventArgs e)
        {
            if (cbThumbnails.Checked)
            {
                ddlThumbnailsResize.Visible = true;
                cbGroupByUrl.Visible = true;
                lblPerRow.Visible = true;
                ddlPerRow.Visible = true;
            }
            else
            {
                ddlThumbnailsResize.Visible = false;
                cbGroupByUrl.Visible = false;
                lblPerRow.Visible = false;
                ddlPerRow.Visible = false;
            }
        }
    }

    /// <summary>
    /// This class is used for storing images.
    /// Longname is how the url image is stored on the server
    /// Name is how it's displayed on the webpage
    /// </summary>
    class names
    {
        string name;
        string longName;

        public names(string name, string longName)
        {
            this.name = name;
            this.longName = longName;
        }
        public string Name
        {
            get { return name; }
        }
        public string LongName
        {
            get { return longName; }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\BrowserShots\ViewBrowserShots\ViewBrowserShots\Default.aspx.designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Test.Common.Utilities.ViewBrowserShots {
    
    
    public partial class _Default {
        
        /// <summary>
        /// lblTitle control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblTitle;
        
        /// <summary>
        /// phMachines control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.PlaceHolder phMachines;
        
        /// <summary>
        /// lblScreenSize control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblScreenSize;
        
        /// <summary>
        /// ddlScreenSize control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DropDownList ddlScreenSize;
        
        /// <summary>
        /// lblColorDepth control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblColorDepth;
        
        /// <summary>
        /// ddlColorDepth control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DropDownList ddlColorDepth;
        
        /// <summary>
        /// lblJavascript control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblJavascript;
        
        /// <summary>
        /// ddlJavascript control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DropDownList ddlJavascript;
        
        /// <summary>
        /// lblActiveX control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblActiveX;
        
        /// <summary>
        /// ddlActiveX control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DropDownList ddlActiveX;
        
        /// <summary>
        /// lblDisableScriptDebugging control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblDisableScriptDebugging;
        
        /// <summary>
        /// ddlDisableScriptDebugging control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DropDownList ddlDisableScriptDebugging;
        
        /// <summary>
        /// lblDisplayErrorDialog control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblDisplayErrorDialog;
        
        /// <summary>
        /// ddlDisplayErrorDialog control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DropDownList ddlDisplayErrorDialog;
        
        /// <summary>
        /// lblWarnOnZoneCrossing control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblWarnOnZoneCrossing;
        
        /// <summary>
        /// ddlWarnOnZoneCrossing control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DropDownList ddlWarnOnZoneCrossing;
        
        /// <summary>
        /// lblZoom control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblZoom;
        
        /// <summary>
        /// ddlZoom control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DropDownList ddlZoom;
        
        /// <summary>
        /// lblTextSize control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblTextSize;
        
        /// <summary>
        /// ddlTextSize control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DropDownList ddlTextSize;
        
        /// <summary>
        /// lblLimitedUserPrivileges control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblLimitedUserPrivileges;
        
        /// <summary>
        /// ddlLimitedUserPrivileges control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DropDownList ddlLimitedUserPrivileges;
        
        /// <summary>
        /// lblURL control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblURL;
        
        /// <summary>
        /// ddlURL control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DropDownList ddlURL;
        
        /// <summary>
        /// btnNextUrl control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnNextUrl;
        
        /// <summary>
        /// btnPreviousUrl control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnPreviousUrl;
        
        /// <summary>
        /// lblGroups control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblGroups;
        
        /// <summary>
        /// ddlGroups control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DropDownList ddlGroups;
        
        /// <summary>
        /// btnShowAllUrls control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnShowAllUrls;
        
        /// <summary>
        /// lblNumImages control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblNumImages;
        
        /// <summary>
        /// rblNumImages control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.RadioButtonList rblNumImages;
        
        /// <summary>
        /// btnSubmit control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnSubmit;
        
        /// <summary>
        /// cbThumbnails control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.CheckBox cbThumbnails;
        
        /// <summary>
        /// ddlThumbnailsResize control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DropDownList ddlThumbnailsResize;
        
        /// <summary>
        /// lblPerRow control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblPerRow;
        
        /// <summary>
        /// ddlPerRow control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DropDownList ddlPerRow;
        
        /// <summary>
        /// cbGroupByUrl control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.CheckBox cbGroupByUrl;
        
        /// <summary>
        /// phImages control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.PlaceHolder phImages;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\BrowserShots\ViewBrowserShots\ViewBrowserShots\Machine.aspx.cs ===
﻿using System;
using System.Collections;
using System.Configuration;
using System.Data;
using System.Linq;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.HtmlControls;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Xml.Linq;
using System.Xml;

namespace Test.Common.Utilities.ViewBrowserShots
{
    public partial class Machine : System.Web.UI.Page
    {
        /// <summary>
        /// This class allows viewing of the machines that are used in browsershots
        /// and allows them to be updated
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void Page_Load(object sender, EventArgs e)
        {
            BindXMLFile();
        }

        /// <summary>
        /// Binds the machine list xml file to the datagrid
        /// </summary>
        void BindXMLFile()
        {
            string folder = Paths.GetFilesPath();
            DataSet ds = new DataSet();
            ds.ReadXml(folder + Paths.GetMachinesFile());
            if (ds.Tables.Count > 0)
            {
                dgMachines.DataSource = ds;
                dgMachines.DataBind();
            }
        }

        /// <summary>
        /// Adds buttons to the datagrid
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void dgMachines_DataBound(object sender, DataGridItemEventArgs e)
        {

            if (e.Item.ItemType != ListItemType.Header && e.Item.ItemType != ListItemType.Footer)
            {
                DataView dv = new DataView((DataTable)((DataSet)dgMachines.DataSource).Tables[0]);
                DataColumnCollection dc = dv.Table.Columns;

                Button btnDelete = new Button();
                btnDelete.ID = "btnDelete";
                btnDelete.Text = "Delete";
                btnDelete.CausesValidation = false;
                btnDelete.Click += new System.EventHandler(btnDelete_Click);
                e.Item.Cells[4].Controls.Add(btnDelete);

                Button btnUpdateDelay = new Button();
                btnUpdateDelay.ID = "btnUpdateDelay";
                btnUpdateDelay.Text = "Update Delay";
                btnUpdateDelay.CausesValidation = false;
                btnUpdateDelay.Click += new System.EventHandler(btnUpdateDelay_Click);
                e.Item.Cells[5].Controls.Add(btnUpdateDelay);

            }
        }
        /// <summary>
        /// Deletes a machine from the xml file
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void btnDelete_Click(Object sender, EventArgs e)
        {
            DataSet ds = (DataSet)dgMachines.DataSource;
            DataTable dt = ds.Tables[0];
            DataView dv = new DataView(dt);
            DataColumnCollection dc = dv.Table.Columns;
            DataGridItem dgi = ((DataGridItem)(((Button)sender).Parent.Parent));

            string Name = dgi.Cells[dc.IndexOf(dc["Name"])].Text;
            string OperatingSystem = dgi.Cells[dc.IndexOf(dc["OperatingSystem"])].Text;
            string Browser = dgi.Cells[dc.IndexOf(dc["Browser"])].Text;
            DeleteNode(Name, OperatingSystem, Browser);
            BindXMLFile();
        }

        /// <summary>
        /// Updates the delay used by this machine to open a webpage
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void btnUpdateDelay_Click(object sender, EventArgs e)
        {
            DataSet ds = (DataSet)dgMachines.DataSource;
            DataTable dt = ds.Tables[0];
            DataView dv = new DataView(dt);
            DataColumnCollection dc = dv.Table.Columns;
            DataGridItem dgi = ((DataGridItem)(((Button)sender).Parent.Parent));

            string Name = dgi.Cells[dc.IndexOf(dc["Name"])].Text;
            string OperatingSystem = dgi.Cells[dc.IndexOf(dc["OperatingSystem"])].Text;
            string Browser = dgi.Cells[dc.IndexOf(dc["Browser"])].Text;
            string folder = Paths.GetFilesPath();
            string delay = tbUpdateDelay.Text;

            uint Num;
            bool isNum = uint.TryParse(delay, out Num);
            if (!isNum)
                return;

            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(folder + Paths.GetMachinesFile());

            XmlNodeList nodes = xDoc.SelectNodes(Paths.GetMachineNodes());
            foreach (XmlElement node in nodes)
            {
                if (node.Attributes["Name"].Value == Name && node.Attributes["OperatingSystem"].Value == OperatingSystem && node.Attributes["Browser"].Value == Browser)
                    node.SetAttribute("Delay", delay);
            }
            xDoc.Save(folder + Paths.GetMachinesFile());
            BindXMLFile();
        }

        /// <summary>
        /// Deletes a machine from the xml file
        /// </summary>
        /// <param name="Name"></param>
        /// <param name="OperatingSystem"></param>
        /// <param name="Browser"></param>
        void DeleteNode(string Name, string OperatingSystem, string Browser)
        {
            string folder = Paths.GetFilesPath();
            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(folder + Paths.GetMachinesFile());

            XmlNodeList nodes = xDoc.SelectNodes(Paths.GetMachineNodes());
            XmlNode parentNode = xDoc.SelectSingleNode(Paths.GetRemoteClientsNode());
            foreach (XmlNode node in nodes)
            {
                if (node.Attributes["Name"].Value == Name && node.Attributes["OperatingSystem"].Value == OperatingSystem && node.Attributes["Browser"].Value == Browser)
                    parentNode.RemoveChild(node);
            }
            xDoc.Save(folder + Paths.GetMachinesFile());
        }

        /// <summary>
        /// Adds a machine to the xml file
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void btnSubmit_Click(object sender, EventArgs e)
        {
            string folder = Paths.GetFilesPath();
            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(folder + Paths.GetMachinesFile());
            XmlNode node = xDoc.SelectSingleNode(Paths.GetRemoteClientsNode());
            XmlElement xNode = xDoc.CreateElement("Machine");
            xNode.SetAttribute("Name", tbName.Text);
            xNode.SetAttribute("OperatingSystem", txtOperatingSystem.Text);
            xNode.SetAttribute("Browser", txtBrowser.Text);
            xNode.SetAttribute("Delay", tbDelay.Text);
            xNode.SetAttribute("Active", "false");
            xNode.SetAttribute("Date", "");
            node.AppendChild(xNode);
            xDoc.Save(folder + Paths.GetMachinesFile());
            BindXMLFile();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\BrowserShots\ViewBrowserShots\ViewBrowserShots\ModifyUrls.aspx.cs ===
﻿using System;
using System.Collections;
using System.Configuration;
using System.Data;
using System.Linq;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.HtmlControls;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Xml.Linq;
using System.Xml;

namespace Test.Common.Utilities.ViewBrowserShots
{
    public partial class ModifyUrls : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {
            if (!IsPostBack)
            {
                Session["group"] = null;
                DataBindListBox();
                InsertGroups();
            }
            BindDataGrid(false);
        }

        /// <summary>
        /// Binds the data to the datagrid for a selected group
        /// </summary>
        void BindDataGrid(bool resetPageIndex)
        {
            dgUrls.DataSource = GetAllUrls();
            if (resetPageIndex)
                dgUrls.CurrentPageIndex = 0;
            dgUrls.DataBind();
        }

        /// <summary>
        /// Gets url groups from the xml file and inserts then in the dropdown list
        /// </summary>
        void InsertGroups()
        {
            string folder = Paths.GetFilesPath();
            string group = string.Empty;
            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(folder + Paths.GetUrlFile());

            XmlNodeList nodes = xDoc.SelectNodes(Paths.GetUrlGroupNodes());
            ddlGroups.Items.Add(Paths.GetShowAllGroupsPhrase());
            foreach (XmlNode node in nodes)
            {
                group = node.Attributes["group"].Value;
                ddlGroups.Items.Add(group);
            }
        }

        /// <summary>
        /// This method is used to page through the datagrid
        /// </summary>
        /// <param name="source"></param>
        /// <param name="e"></param>
        protected void Paging_DataGrid(object source, System.Web.UI.WebControls.DataGridPageChangedEventArgs e)
        {
            dgUrls.CurrentPageIndex = e.NewPageIndex;
            BindDataGrid(false);
        }

        /// <summary>
        /// Adds buttons to the datagrid
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void dgUrls_DataBound(object sender, DataGridItemEventArgs e)
        {

            if (e.Item.ItemType != ListItemType.Header && e.Item.ItemType != ListItemType.Footer)
            {
                DataTable dt = new DataTable();
                ArrayList al = (ArrayList)dgUrls.DataSource;
                dt = Paths.ConvertObjectToDataTableSchema(al[0]);
                Paths.FillData(al, dt);
                DataView dv = new DataView(dt);
                DataColumnCollection dc = dv.Table.Columns;

                Button btnDelete = new Button();
                btnDelete.ID = "btnDelete";
                btnDelete.Text = "Delete";
                btnDelete.CausesValidation = false;
                btnDelete.Click += new System.EventHandler(btnDeleteUrl_Click);
                e.Item.Cells[3].Controls.Add(btnDelete);

                Button btnUpdateDelay = new Button();
                btnUpdateDelay.ID = "btnUpdateDelay";
                btnUpdateDelay.Text = "Update Delay";
                btnUpdateDelay.CausesValidation = false;
                btnUpdateDelay.Click += new System.EventHandler(btnUpdateDelay_Click);
                e.Item.Cells[4].Controls.Add(btnUpdateDelay);
            }
        }

        /// <summary>
        /// This is a helper method to bind an arraylist to a datagrid
        /// </summary>
        /// <param name="o"></param>
        /// <returns></returns>
        //public static DataTable ConvertObjectToDataTableSchema(Object o)
        //{
        //    DataTable dt = new DataTable();
        //    PropertyInfo[] properties = o.GetType().GetProperties();

        //    foreach (PropertyInfo property in properties)
        //    {
        //        DataColumn dc = new DataColumn(property.Name);
        //        dc.DataType = property.PropertyType; dt.Columns.Add(dc);
        //    }
        //    return dt;
        //}

        ///// <summary>
        ///// This is a helper method to bind an arraylist to a datagrid
        ///// </summary>
        ///// <param name="arrayList"></param>
        ///// <param name="dt"></param>
        //private static void FillData(ArrayList arrayList, DataTable dt)
        //{
        //    foreach (Object o in arrayList)
        //    {
        //        DataRow dr = dt.NewRow();
        //        PropertyInfo[] properties = o.GetType().GetProperties();

        //        foreach (PropertyInfo property in properties)
        //        {
        //            dr[property.Name] = property.GetValue(o, null);
        //        }
        //        dt.Rows.Add(dr);
        //    }
        //}

        /// <summary>
        /// Gets the urls from the xml file and binds them to the datagrid
        /// </summary>
        /// <param name="url"></param>
        /// <param name="group"></param>
        /// <param name="delay"></param>
        void InsertUrl(string url, string group, string delay)
        {
            string folder = Paths.GetFilesPath();
            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(folder + Paths.GetUrlFile());

            uint Num;
            bool isNum = uint.TryParse(delay, out Num);
            if (!isNum && delay != "")
                return;
            XmlNodeList nodes = xDoc.SelectNodes(Paths.GetUrlGroupNodes());
            if (group == "")
                group = "none";
            bool groupExists = false;
            foreach (XmlNode xNode in nodes)
            {
                if (xNode.Attributes["group"].Value == group)
                    groupExists = true;
            }
            if (!groupExists)
            {
                XmlNode nodeUrlsParent = xDoc.SelectSingleNode(Paths.GetUrlsParentNode());
                XmlElement newGroupNode = xDoc.CreateElement("urlGroup");
                newGroupNode.SetAttribute("group", group);
                newGroupNode.SetAttribute("active", "false");
                nodeUrlsParent.AppendChild(newGroupNode);
            }
            XmlNode node = xDoc.SelectSingleNode("//Urls/urlGroup[@group='" + group + "']");
            XmlElement newNode = xDoc.CreateElement("url");
            newNode.InnerText = url;
            if (delay != "")
                newNode.SetAttribute("delay", delay);
            node.AppendChild(newNode);
            xDoc.Save(folder + Paths.GetUrlFile());
            lblModify.Visible = true;
            DataBindListBox();
            BindDataGrid(false);
        }

        /// <summary>
        /// This method will return all the urls stored in the xml file
        /// </summary>
        /// <returns></returns>
        ArrayList GetAllUrls()
        {
            ArrayList urls = new ArrayList();
            string folder = Paths.GetFilesPath();
            string url = string.Empty;
            string group = string.Empty;
            string delay = string.Empty;
            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(folder + Paths.GetUrlFile());

            XmlNodeList nodes = xDoc.SelectNodes(Paths.GetUrlNodes());
            if (Session["group"] != null)
            {
                string groupValue = Session["group"].ToString();
                if (groupValue != Paths.GetShowAllGroupsPhrase())
                    nodes = xDoc.SelectNodes("//Urls/urlGroup[@group='" + groupValue + "']/url");
            }
            foreach (XmlNode node in nodes)
            {
                url = node.InnerText.ToString();
                group = node.ParentNode.Attributes["group"].Value;
                if (node.Attributes.Count > 0)
                    delay = node.Attributes["delay"].Value;
                else
                    delay = string.Empty;
                urls.Add(new urlType(url, group, delay));
            }

            return urls;
        }

        /// <summary>
        /// Adds a new url to the xml file
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void btnAddUrl_Click(object sender, EventArgs e)
        {
            string url = tbUrl.Text;
            string group = tbGroup.Text;
            string delay = tbDelay.Text;
            InsertUrl(url, group, delay);
            ddlGroups.Items.Clear();
            InsertGroups();
        }

        /// <summary>
        /// Deletes a group and all its urls from the xml file
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void btnDeleteGroup_Click(object sender, EventArgs e)
        {
            string folder = Paths.GetFilesPath();
            string group = lbDeleteGroup.SelectedValue;

            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(folder + Paths.GetUrlFile());

            XmlNodeList groupNode = xDoc.SelectNodes(Paths.GetUrlGroupNodes());
            foreach (XmlNode node in groupNode)
            {
                if (group == node.Attributes["group"].Value)
                {
                    node.ParentNode.RemoveChild(node);
                }
            }
            xDoc.Save(folder + Paths.GetUrlFile());
            lblModify.Visible = true;
            DataBindListBox();
            BindDataGrid(false);
            ddlGroups.Items.Clear();
            InsertGroups();
        }

        /// <summary>
        /// Deletes a url from the xml file
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void btnDeleteUrl_Click(object sender, EventArgs e)
        {
            DataTable dt = new DataTable();
            ArrayList al = (ArrayList)dgUrls.DataSource;
            dt = Paths.ConvertObjectToDataTableSchema(al[0]);
            DataView dv = new DataView(dt);
            DataColumnCollection dc = dv.Table.Columns;
            DataGridItem dgi = ((DataGridItem)(((Button)sender).Parent.Parent));
            string url = dgi.Cells[dc.IndexOf(dc["Url"])].Text;
            string folder = Paths.GetFilesPath();

            if (url == "")
                return;
            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(folder + Paths.GetUrlFile());

            XmlNodeList nodes = xDoc.SelectNodes(Paths.GetUrlGroupNodes());
            foreach (XmlNode node in nodes)
            {
                foreach (XmlNode urlNode in node.ChildNodes)
                    if (url == urlNode.InnerText.ToString())
                        node.RemoveChild(urlNode);
            }
            xDoc.Save(folder + Paths.GetUrlFile());
            lblModify.Visible = true;
            DataBindListBox();
            BindDataGrid(false);
        }

        /// <summary>
        /// Updates the delay that a url uses for opening the browser
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void btnUpdateDelay_Click(object sender, EventArgs e)
        {
            DataTable dt = new DataTable();
            ArrayList al = (ArrayList)dgUrls.DataSource;
            dt = Paths.ConvertObjectToDataTableSchema(al[0]);
            DataView dv = new DataView(dt);
            DataColumnCollection dc = dv.Table.Columns;
            DataGridItem dgi = ((DataGridItem)(((Button)sender).Parent.Parent));
            string url = dgi.Cells[dc.IndexOf(dc["Url"])].Text;
            string folder = Paths.GetFilesPath();
            string delay = tbUpdateDelay.Text;
            uint Num;
            bool isNum = uint.TryParse(delay, out Num);
            if (!isNum && delay != "")
                return;
            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(folder + Paths.GetUrlFile());

            XmlNodeList nodes = xDoc.SelectNodes(Paths.GetUrlGroupNodes());
            foreach (XmlNode node in nodes)
            {
                foreach (XmlElement urlNode in node.ChildNodes)
                {
                    if (url == urlNode.InnerText.ToString())
                    {
                        urlNode.RemoveAllAttributes();
                        urlNode.SetAttribute("delay", delay);
                        break;
                    }
                }
            }
            xDoc.Save(folder + Paths.GetUrlFile());
            lblModify.Visible = true;
            DataBindListBox();
            BindDataGrid(false);
        }

        /// <summary>
        /// Binds the list of groups to the ones in the xml file
        /// </summary>
        void DataBindListBox()
        {
            lbDeleteGroup.DataSource = GetGroups();
            lbDeleteGroup.DataBind();
        }

        /// <summary>
        /// Gets the groups from the xml file
        /// </summary>
        /// <returns></returns>
        ArrayList GetGroups()
        {
            ArrayList alGroups = new ArrayList();
            string folder = Paths.GetFilesPath();
            string group = string.Empty;
            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(folder + Paths.GetUrlFile());

            XmlNodeList nodes = xDoc.SelectNodes(Paths.GetUrlGroupNodes());
            foreach (XmlNode node in nodes)
            {
                group = node.Attributes["group"].Value;
                alGroups.Add(group);
            }
            alGroups.Remove("none");
            return alGroups;
        }

        /// <summary>
        /// Toggles between paging and viewing all the urls
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void btnViewAll_Click(object sender, EventArgs e)
        {
            if (Session["ViewAllPassed"] == null)
            {
                Session["ViewAllPassed"] = "true";
            }
            if (Session["ViewAllPassed"].ToString() == "true")
            {
                Session["ViewAllPassed"] = "false";
                dgUrls.AllowPaging = false;
                btnViewAll.Text = "Allow Paging";
            }
            else
            {
                Session["ViewAllPassed"] = "true";
                dgUrls.AllowPaging = true;
                btnViewAll.Text = "View All";
            }
            BindDataGrid(false);
        }

        /// <summary>
        /// Adds multiple urls to the xml file
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void btnAddMultipleUrls_Click(object sender, EventArgs e)
        {
            string[] urls = tbNewUrls.Text.ToString().Split("\n".ToCharArray());
            string group = tbGp.Text;
            string delay = tbDlay.Text;
            foreach (string url in urls)
            {
                string urlNew = url.Replace("\r", "");
                InsertUrl(urlNew, group, delay);
            }
            ddlGroups.Items.Clear();
            InsertGroups();
        }

        /// <summary>
        /// Shows urls in the datagrid based on what group is slected in the dropdown list
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void ddlGroups_SelectedIndexChanged(object sender, EventArgs e)
        {
            Session["group"] = ddlGroups.SelectedValue;
            BindDataGrid(true);
        }
    }

    /// <summary>
    /// This class is used to store urls.
    /// It is used when the data is bound to the datagrid.
    /// </summary>
    class urlType
    {
        string url;
        string group;
        string delay;

        public urlType(string url, string group, string delay)
        {
            this.url = url;
            this.group = group;
            this.delay = delay;
        }
        public string Url
        {
            get { return url; }
        }

        public string Group
        {
            get { return group; }
        }

        public string Delay
        {
            get { return delay; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\BrowserShots\ViewBrowserShots\ViewBrowserShots\Machine.aspx.designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Test.Common.Utilities.ViewBrowserShots {
    
    
    public partial class Machine {
        
        /// <summary>
        /// lblCurrentMachines control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblCurrentMachines;
        
        /// <summary>
        /// lblUpdateDelay control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblUpdateDelay;
        
        /// <summary>
        /// tbUpdateDelay control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox tbUpdateDelay;
        
        /// <summary>
        /// dgMachines control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DataGrid dgMachines;
        
        /// <summary>
        /// lblNewMachine control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblNewMachine;
        
        /// <summary>
        /// lblName control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblName;
        
        /// <summary>
        /// tbName control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox tbName;
        
        /// <summary>
        /// rfvName control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.RequiredFieldValidator rfvName;
        
        /// <summary>
        /// lblOperatingSystem control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblOperatingSystem;
        
        /// <summary>
        /// txtOperatingSystem control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox txtOperatingSystem;
        
        /// <summary>
        /// rfvOperatingSystem control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.RequiredFieldValidator rfvOperatingSystem;
        
        /// <summary>
        /// lblBrowser control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblBrowser;
        
        /// <summary>
        /// txtBrowser control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox txtBrowser;
        
        /// <summary>
        /// rfvBrowser control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.RequiredFieldValidator rfvBrowser;
        
        /// <summary>
        /// lblDelay control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblDelay;
        
        /// <summary>
        /// tbDelay control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox tbDelay;
        
        /// <summary>
        /// rfvDelay control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.RequiredFieldValidator rfvDelay;
        
        /// <summary>
        /// RegularExpressionValidator1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.RegularExpressionValidator RegularExpressionValidator1;
        
        /// <summary>
        /// btnSubmit control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnSubmit;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\BrowserShots\ViewBrowserShots\ViewBrowserShots\ModifyUrls.aspx.designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Test.Common.Utilities.ViewBrowserShots {
    
    
    public partial class ModifyUrls {
        
        /// <summary>
        /// lblModifyUrls control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblModifyUrls;
        
        /// <summary>
        /// lblURL control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblURL;
        
        /// <summary>
        /// lblOptional control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblOptional;
        
        /// <summary>
        /// lblGroup control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblGroup;
        
        /// <summary>
        /// lblDelay control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblDelay;
        
        /// <summary>
        /// tbUrl control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox tbUrl;
        
        /// <summary>
        /// rfvURL control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.RequiredFieldValidator rfvURL;
        
        /// <summary>
        /// tbGroup control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox tbGroup;
        
        /// <summary>
        /// tbDelay control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox tbDelay;
        
        /// <summary>
        /// btnAddUrl control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnAddUrl;
        
        /// <summary>
        /// lblUpdateDelay control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblUpdateDelay;
        
        /// <summary>
        /// tbUpdateDelay control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox tbUpdateDelay;
        
        /// <summary>
        /// dgUrls control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DataGrid dgUrls;
        
        /// <summary>
        /// btnViewAll control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnViewAll;
        
        /// <summary>
        /// lblGroups control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblGroups;
        
        /// <summary>
        /// ddlGroups control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DropDownList ddlGroups;
        
        /// <summary>
        /// lblAddMultipleUrls control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblAddMultipleUrls;
        
        /// <summary>
        /// lblInstructions control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblInstructions;
        
        /// <summary>
        /// tbNewUrls control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox tbNewUrls;
        
        /// <summary>
        /// lblGp control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblGp;
        
        /// <summary>
        /// tbGp control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox tbGp;
        
        /// <summary>
        /// lblDlay control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblDlay;
        
        /// <summary>
        /// tbDlay control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox tbDlay;
        
        /// <summary>
        /// btnAddMultipleUrls control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnAddMultipleUrls;
        
        /// <summary>
        /// lblDeleteGroup control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblDeleteGroup;
        
        /// <summary>
        /// lbDeleteGroup control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.ListBox lbDeleteGroup;
        
        /// <summary>
        /// btnDeleteGroup control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnDeleteGroup;
        
        /// <summary>
        /// lblModify control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblModify;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\BrowserShots\ViewBrowserShots\ViewBrowserShots\ShowImage.aspx.cs ===
﻿using System;
using System.Collections;
using System.Configuration;
using System.Data;
using System.Linq;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.HtmlControls;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Xml.Linq;

namespace Test.Common.Utilities.ViewBrowserShots
{
    public partial class ShowImage : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {
            string FileName = Request.QueryString["FileName"];
            if (Request.QueryString.Count > 1)
                FileName = Request.QueryString.ToString().Substring("FileName=".Length).Replace("%3b", ";").Replace("%3d", "=");
            imgBrowserShot.ImageUrl = Paths.GetImageUrl() + FileName + ".png";
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\BrowserShots\ViewBrowserShots\ViewBrowserShots\Site1.Master.cs ===
﻿using System;
using System.Collections;
using System.Configuration;
using System.Data;
using System.Linq;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.HtmlControls;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Xml.Linq;
using System.IO;

namespace Test.Common.Utilities.ViewBrowserShots
{
    public partial class Site1 : System.Web.UI.MasterPage
    {
        protected void Page_Load(object sender, EventArgs e)
        {

        }
        void DownloadFile()
        {
            string filepath = Paths.GetFilesPath() + Paths.GetDocumentation();
            FileInfo file = new FileInfo(filepath);

            if (file.Exists)
            {
                // Clear the content of the response
                Response.ClearContent();

                // Add the file name and attachment, which will force the open/cancel/save dialog to show, to the header
                Response.AddHeader("Content-Disposition", "attachment; filename=" + file.Name);

                // Add the file size into the response header
                Response.AddHeader("Content-Length", file.Length.ToString());

                // Set the ContentType
                Response.ContentType = "application/ms-word";

                // Write the file into the response
                Response.WriteFile(file.FullName);

                // Flush the response
                Response.Flush();

                // End the response
                Response.End();
            }
        }
        protected void btnDocumentation_Click(object sender, EventArgs e)
        {
            DownloadFile();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\BrowserShots\ViewBrowserShots\ViewBrowserShots\ShowImage.aspx.designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Test.Common.Utilities.ViewBrowserShots {
    
    
    public partial class ShowImage {
        
        /// <summary>
        /// form1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.HtmlControls.HtmlForm form1;
        
        /// <summary>
        /// imgBrowserShot control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Image imgBrowserShot;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\CreateHosts\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\BrowserShots\ViewBrowserShots\ViewBrowserShots\Site1.Master.designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Test.Common.Utilities.ViewBrowserShots {
    
    
    public partial class Site1 {
        
        /// <summary>
        /// Head1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.HtmlControls.HtmlHead Head1;
        
        /// <summary>
        /// head control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.ContentPlaceHolder head;
        
        /// <summary>
        /// form1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.HtmlControls.HtmlForm form1;
        
        /// <summary>
        /// Menu1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Menu Menu1;
        
        /// <summary>
        /// ContentPlaceHolder1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.ContentPlaceHolder ContentPlaceHolder1;
        
        /// <summary>
        /// btnDocumentation control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnDocumentation;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\BrowserShots\ViewBrowserShots\ViewBrowserShots\Paths.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Configuration;
using System.Collections;
//using System.Xml;
using System.Data;
using System.Reflection;
using System.Text;

/// <summary>
/// This class contains methods that are used through the rest of the program
/// </summary>
public class Paths
{
    /// <summary>
    /// These methods allow access to data in the app.config file
    /// </summary>
    /// <returns></returns>
    public static string GetDirectoryInfoPath()
    {
        return ConfigurationManager.AppSettings["DirectoryInfoPath"];
    }
    public static string GetThumbnailPath()
    {
        return ConfigurationManager.AppSettings["ThumbnailPath"];
    }
    public static string GetScreenShotPath()
    {
        return ConfigurationManager.AppSettings["ScreenShotPath"];
    }
    public static string GetMachinesFile()
    {
        return ConfigurationManager.AppSettings["MachinesFile"];
    }
    public static string GetRegistryFile()
    {
        return ConfigurationManager.AppSettings["RegistryFile"];
    }
    public static string GetImageUrl()
    {
        return ConfigurationManager.AppSettings["ImageUrl"];
    }
    public static string GetImageUrlThumbnails()
    {
        return ConfigurationManager.AppSettings["ImageUrlThumbnails"];
    }
    public static string GetFilesPath()
    {
        return ConfigurationManager.AppSettings["FilesPath"];
    }
    public static string GetUrlFile()
    {
        return ConfigurationManager.AppSettings["UrlFile"];
    }
    public static string GetUrlNodes()
    {
        return ConfigurationManager.AppSettings["UrlNodes"];
    }
    public static string GetUrlGroupNodes()
    {
        return ConfigurationManager.AppSettings["UrlGroupNodes"];
    }
    public static string GetDocumentation()
    {
        return ConfigurationManager.AppSettings["Documentation"];
    }
    public static string GetMachineNodes()
    {
        return ConfigurationManager.AppSettings["MachineNodes"];
    }
    public static string GetRemoteClientsNode()
    {
        return ConfigurationManager.AppSettings["RemoteClientsNode"];
    }
    public static string GetUrlsParentNode()
    {
        return ConfigurationManager.AppSettings["UrlsParentNode"];
    }
    public static string GetRegistryScreenSizeXNodes()
    {
        return ConfigurationManager.AppSettings["RegistryScreenSizeXNodes"];
    }
    public static string GetRegistryScreenSizeYNodes()
    {
        return ConfigurationManager.AppSettings["RegistryScreenSizeYNodes"];
    }
    public static string GetRegistryColorDepthNodes()
    {
        return ConfigurationManager.AppSettings["RegistryColorDepthNodes"];
    }
    public static string GetRegistryJavaScriptNodes()
    {
        return ConfigurationManager.AppSettings["RegistryJavaScriptNodes"];
    }
    public static string GetRegistryActiveXNodes()
    {
        return ConfigurationManager.AppSettings["RegistryActiveXNodes"];
    }
    public static string GetRegistryDisableScriptDebuggingNodes()
    {
        return ConfigurationManager.AppSettings["RegistryDisableScriptDebuggingNodes"];
    }
    public static string GetRegistryDisplayErrorDialogNodes()
    {
        return ConfigurationManager.AppSettings["RegistryDisplayErrorDialogNodes"];
    }
    public static string GetRegistryWarnOnZoneCrossingNodes()
    {
        return ConfigurationManager.AppSettings["RegistryWarnOnZoneCrossingNodes"];
    }
    public static string GetZoomNodes()
    {
        return ConfigurationManager.AppSettings["RegistryZoomNodes"];
    }
    public static string GetTextSizeNodes()
    {
        return ConfigurationManager.AppSettings["RegistryTextSizeNodes"];
    }
    public static string GetRegistryLimitedUserPrivilegesNodes()
    {
        return ConfigurationManager.AppSettings["RegistryLimitedUserPrivilegesNodes"];
    }
    public static string GetMaxLengthFolderName()
    {
        return ConfigurationManager.AppSettings["MaxLengthFolderName"];
    }
    public static string GetThumbnailWidthSize()
    {
        return ConfigurationManager.AppSettings["ThumbnailWidthSize"];
    }
    public static string GetShowAllGroupsPhrase()
    {
        return ConfigurationManager.AppSettings["ShowAllGroupsPhrase"];
    }
    public static string GetQueueFile()
    {
        return ConfigurationManager.AppSettings["mBrowserShotsQueue"].ToString();
    }
    public static string GetQueueNode()
    {
        return ConfigurationManager.AppSettings["mQueueNode"].ToString();
    }
    public static string GetCurrentRequestsNode()
    {
        return ConfigurationManager.AppSettings["mCurrentRequestsNode"].ToString();
    }

    /// <summary>
    /// This is a helper method to bind an arraylist to a datagrid
    /// </summary>
    /// <param name="o"></param>
    /// <returns></returns>
    public static DataTable ConvertObjectToDataTableSchema(Object o)
    {
        DataTable dt = new DataTable();
        PropertyInfo[] properties = o.GetType().GetProperties();

        foreach (PropertyInfo property in properties)
        {
            DataColumn dc = new DataColumn(property.Name);
            dc.DataType = property.PropertyType; dt.Columns.Add(dc);
        }
        return dt;
    }

    /// <summary>
    /// This is a helper method to bind an arraylist to a datagrid
    /// </summary>
    /// <param name="arrayList"></param>
    /// <param name="dt"></param>
    public static void FillData(ArrayList arrayList, DataTable dt)
    {
        foreach (Object o in arrayList)
        {
            DataRow dr = dt.NewRow();
            PropertyInfo[] properties = o.GetType().GetProperties();

            foreach (PropertyInfo property in properties)
            {
                dr[property.Name] = property.GetValue(o, null);
            }
            dt.Rows.Add(dr);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\CreateHosts\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("CreateHosts")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("f17ff325-bb7b-48c9-b03f-7d76d4862b88")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\BrowserShots\ViewBrowserShots\ViewBrowserShots\Start.aspx.cs ===
﻿using System;
using System.Collections;
using System.Configuration;
using System.Data;
using System.Linq;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.HtmlControls;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Xml.Linq;
using System.Xml;
using System.IO;

namespace Test.Common.Utilities.ViewBrowserShots
{
    public partial class Start : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {
            ShowMachinesAndBrowsers();
            if (!IsPostBack)
            {
                InsertRegistryValues();
                InsertGroups();
                SetActiveMachines();
            }
            BindDataGrid();
            MaintainScrollPositionOnPostBack = true;
        }

        /// <summary>
        /// Inserts the registry values into controls on the webpage from the xml file
        /// </summary>
        void InsertRegistryValues()
        {
            string folder = Paths.GetFilesPath();
            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(folder + Paths.GetRegistryFile());

            XmlNode screenSizeXNode = xDoc.SelectSingleNode(Paths.GetRegistryScreenSizeXNodes());
            lbScreenSize.Items.Clear();
            int i = 0;
            foreach (XmlNode node in screenSizeXNode.ChildNodes)
            {
                lbScreenSize.Items.Add(node.InnerText);
                if (node.Attributes["active"].Value == "true")
                    lbScreenSize.Items[i].Selected = true;
                i++;
            }
            XmlNode colorDepthNode = xDoc.SelectSingleNode(Paths.GetRegistryColorDepthNodes());
            lbColorDepth.Items.Clear();
            i = 0;
            foreach (XmlNode node in colorDepthNode.ChildNodes)
            {
                lbColorDepth.Items.Add(node.InnerText);
                if (node.Attributes["active"].Value == "true")
                    lbColorDepth.Items[i].Selected = true;
                i++;
            }
            XmlNode javaScriptNode = xDoc.SelectSingleNode(Paths.GetRegistryJavaScriptNodes());
            lbJavascript.Items.Clear();
            i = 0;
            foreach (XmlNode node in javaScriptNode.ChildNodes)
            {
                lbJavascript.Items.Add(node.InnerText);
                if (node.Attributes["active"].Value == "true")
                    lbJavascript.Items[i].Selected = true;
                i++;
            }
            XmlNode activeXNode = xDoc.SelectSingleNode(Paths.GetRegistryActiveXNodes());
            lbActiveX.Items.Clear();
            i = 0;
            foreach (XmlNode node in activeXNode.ChildNodes)
            {
                lbActiveX.Items.Add(node.InnerText);
                if (node.Attributes["active"].Value == "true")
                    lbActiveX.Items[i].Selected = true;
                i++;
            }
            XmlNode disableScriptDebuggingNode = xDoc.SelectSingleNode(Paths.GetRegistryDisableScriptDebuggingNodes());
            lbDisableScriptDebugging.Items.Clear();
            i = 0;
            foreach (XmlNode node in disableScriptDebuggingNode.ChildNodes)
            {
                lbDisableScriptDebugging.Items.Add(node.InnerText);
                if (node.Attributes["active"].Value == "true")
                    lbDisableScriptDebugging.Items[i].Selected = true;
                i++;
            }
            XmlNode displayErrorDialogNode = xDoc.SelectSingleNode(Paths.GetRegistryDisplayErrorDialogNodes());
            lbDisplayErrorDialog.Items.Clear();
            i = 0;
            foreach (XmlNode node in displayErrorDialogNode.ChildNodes)
            {
                lbDisplayErrorDialog.Items.Add(node.InnerText);
                if (node.Attributes["active"].Value == "true")
                    lbDisplayErrorDialog.Items[i].Selected = true;
                i++;
            }
            XmlNode warnOnZoneCrossingNode = xDoc.SelectSingleNode(Paths.GetRegistryWarnOnZoneCrossingNodes());
            lbWarnOnZoneCrossing.Items.Clear();
            i = 0;
            foreach (XmlNode node in warnOnZoneCrossingNode.ChildNodes)
            {
                lbWarnOnZoneCrossing.Items.Add(node.InnerText);
                if (node.Attributes["active"].Value == "true")
                    lbWarnOnZoneCrossing.Items[i].Selected = true;
                i++;
            }
            XmlNode zoomNode = xDoc.SelectSingleNode(Paths.GetZoomNodes());
            lbZoom.Items.Clear();
            i = 0;
            foreach (XmlNode node in zoomNode.ChildNodes)
            {
                lbZoom.Items.Add(node.InnerText);
                if (node.Attributes["active"].Value == "true")
                    lbZoom.Items[i].Selected = true;
                i++;
            }
            XmlNode textSizeNode = xDoc.SelectSingleNode(Paths.GetTextSizeNodes());
            lbTextSize.Items.Clear();
            i = 0;
            foreach (XmlNode node in textSizeNode.ChildNodes)
            {
                lbTextSize.Items.Add(node.InnerText);
                if (node.Attributes["active"].Value == "true")
                    lbTextSize.Items[i].Selected = true;
                i++;
            }
            XmlNode limitedUserPrivilegesNode = xDoc.SelectSingleNode(Paths.GetRegistryLimitedUserPrivilegesNodes());
            lbLimitedUserPrivileges.Items.Clear();
            i = 0;
            foreach (XmlNode node in limitedUserPrivilegesNode.ChildNodes)
            {
                lbLimitedUserPrivileges.Items.Add(node.InnerText);
                if (node.Attributes["active"].Value == "true")
                    lbLimitedUserPrivileges.Items[i].Selected = true;
                i++;
            }
        }

        /// <summary>
        /// Starts the browser shots on the client computers by updating
        /// the xml value which services on the client periodically check
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void btnStart_Click(object sender, EventArgs e)
        {
            AddNodeToQueue();
            BindDataGrid();
        }
        /// <summary>
        /// Starts the browser shots on the client computers by updating
        /// the xml value which services on the client periodically check 
        /// </summary>
        void AddNodeToQueue()
        {
            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(Paths.GetFilesPath() + Paths.GetQueueFile());
            XmlNode node = xDoc.SelectSingleNode(Paths.GetQueueNode());
            ArrayList machines = GetMachineList();
            XmlElement screenSizeXNode = xDoc.CreateElement("ScreenSizeX");
            int[] screenSizeYValues = { 768, 800, 600, 864 };
            XmlElement screenSizeYNode = xDoc.CreateElement("ScreenSizeY");
            int i = 0;
            foreach (ListItem item in lbScreenSize.Items)
            {
                XmlElement textNodeX = xDoc.CreateElement("text");
                textNodeX.InnerText = item.Text;
                textNodeX.SetAttribute("active", item.Selected ? "true" : "false");
                screenSizeXNode.AppendChild(textNodeX);
                XmlElement textNodeY = xDoc.CreateElement("text");
                textNodeY.InnerText = screenSizeYValues[i].ToString();
                textNodeY.SetAttribute("active", item.Selected ? "true" : "false");
                screenSizeYNode.AppendChild(textNodeY);
                i++;
            }
            XmlElement colorDepthNode = xDoc.CreateElement("ColorDepth");
            foreach (ListItem item in lbColorDepth.Items)
            {
                XmlElement textNode = xDoc.CreateElement("text");
                textNode.InnerText = item.Text;
                textNode.SetAttribute("active", item.Selected ? "true" : "false");
                colorDepthNode.AppendChild(textNode);
            }
            XmlElement javaScriptNode = xDoc.CreateElement("JavaScript");
            foreach (ListItem item in lbJavascript.Items)
            {
                XmlElement textNode = xDoc.CreateElement("text");
                textNode.InnerText = item.Text;
                textNode.SetAttribute("active", item.Selected ? "true" : "false");
                javaScriptNode.AppendChild(textNode);
            }
            XmlElement activeXNode = xDoc.CreateElement("ActiveX");
            foreach (ListItem item in lbActiveX.Items)
            {
                XmlElement textNode = xDoc.CreateElement("text");
                textNode.InnerText = item.Text;
                textNode.SetAttribute("active", item.Selected ? "true" : "false");
                activeXNode.AppendChild(textNode);
            }
            XmlElement disableScriptDebuggingNode = xDoc.CreateElement("DisableScriptDebugging");
            foreach (ListItem item in lbDisableScriptDebugging.Items)
            {
                XmlElement textNode = xDoc.CreateElement("text");
                textNode.InnerText = item.Text;
                textNode.SetAttribute("active", item.Selected ? "true" : "false");
                disableScriptDebuggingNode.AppendChild(textNode);
            }
            XmlElement displayErrorDialogNode = xDoc.CreateElement("DisplayErrorDialog");
            foreach (ListItem item in lbDisplayErrorDialog.Items)
            {
                XmlElement textNode = xDoc.CreateElement("text");
                textNode.InnerText = item.Text;
                textNode.SetAttribute("active", item.Selected ? "true" : "false");
                displayErrorDialogNode.AppendChild(textNode);
            }
            XmlElement warnOnZoneCrossingNode = xDoc.CreateElement("WarnOnZoneCrossing");
            foreach (ListItem item in lbWarnOnZoneCrossing.Items)
            {
                XmlElement textNode = xDoc.CreateElement("text");
                textNode.InnerText = item.Text;
                textNode.SetAttribute("active", item.Selected ? "true" : "false");
                warnOnZoneCrossingNode.AppendChild(textNode);
            }
            XmlElement zoomNode = xDoc.CreateElement("Zoom");
            foreach (ListItem item in lbZoom.Items)
            {
                XmlElement textNode = xDoc.CreateElement("text");
                textNode.InnerText = item.Text;
                textNode.SetAttribute("active", item.Selected ? "true" : "false");
                zoomNode.AppendChild(textNode);
            }
            XmlElement textSizeNode = xDoc.CreateElement("TextSize");
            foreach (ListItem item in lbTextSize.Items)
            {
                XmlElement textNode = xDoc.CreateElement("text");
                textNode.InnerText = item.Text;
                textNode.SetAttribute("active", item.Selected ? "true" : "false");
                textSizeNode.AppendChild(textNode);
            }
            XmlElement limitedUserPrivilegesNode = xDoc.CreateElement("LimitedUserPrivileges");
            foreach (ListItem item in lbLimitedUserPrivileges.Items)
            {
                XmlElement textNode = xDoc.CreateElement("text");
                textNode.InnerText = item.Text;
                textNode.SetAttribute("active", item.Selected ? "true" : "false");
                limitedUserPrivilegesNode.AppendChild(textNode);
            }

            XmlElement regNode = xDoc.CreateElement("Registry");
            regNode.AppendChild(screenSizeXNode);
            regNode.AppendChild(screenSizeYNode);
            regNode.AppendChild(colorDepthNode);
            regNode.AppendChild(javaScriptNode);
            regNode.AppendChild(activeXNode);
            regNode.AppendChild(disableScriptDebuggingNode);
            regNode.AppendChild(displayErrorDialogNode);
            regNode.AppendChild(warnOnZoneCrossingNode);
            regNode.AppendChild(zoomNode);
            regNode.AppendChild(textSizeNode);
            regNode.AppendChild(limitedUserPrivilegesNode);
            foreach (MachineInfo machine in machines)
            {
                XmlElement itemNode = xDoc.CreateElement("item");
                string os = string.Empty;
                string browser = string.Empty;
                GetMachineInfo(machine.MachineName, ref os, ref browser);
                itemNode.SetAttribute("MachineName", machine.MachineName);
                itemNode.SetAttribute("Date", DateTime.Now.ToString());
                itemNode.SetAttribute("OS", os);
                itemNode.SetAttribute("Browser", machine.Browser);
                XmlNode newRegNode = xDoc.ImportNode(regNode, true);
                itemNode.AppendChild(newRegNode);
                XmlElement urlGroupsNode = xDoc.CreateElement("UrlGroups");
                foreach (ListItem item in lbGroups.Items)
                {
                    if (item.Selected)
                    {
                        XmlElement groupNode = xDoc.CreateElement("Group");
                        groupNode.InnerText = item.Text;
                        urlGroupsNode.AppendChild(groupNode);
                    }
                }
                itemNode.AppendChild(urlGroupsNode);
                node.AppendChild(itemNode);
            }

            xDoc.Save(Paths.GetFilesPath() + Paths.GetQueueFile());
        }
        /// <summary>
        /// Gets the OS and Browser that this machine will use.
        /// </summary>
        /// <param name="machineName"></param>
        /// <param name="oS"></param>
        /// <param name="browser"></param>
        void GetMachineInfo(string machineName, ref string oS, ref string browser)
        {
            XmlDocument xDoc = new XmlDocument();
            string folder = Paths.GetFilesPath();
            xDoc.Load(folder + Paths.GetMachinesFile());
            XmlNodeList nodes = xDoc.SelectNodes(Paths.GetMachineNodes());

            foreach (XmlNode node in nodes)
            {
                if (node.Attributes["Name"].Value.ToUpper() == machineName.ToUpper())
                {
                    oS = node.Attributes["OperatingSystem"].Value;
                    browser = node.Attributes["Browser"].Value;
                    break;
                }
            }
        }

        /// <summary>
        /// Gets information about the machines and their browsers from the xml file
        /// and displays them on the web page.
        /// </summary>
        void ShowMachinesAndBrowsers()
        {
            string folder = Paths.GetFilesPath();
            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(folder + Paths.GetMachinesFile());

            XmlNodeList nodes = xDoc.SelectNodes(Paths.GetMachineNodes());
            ArrayList configs = new ArrayList();
            ArrayList OpSystems = new ArrayList();
            foreach (XmlNode xNode in nodes)
            {
                string os = xNode.Attributes["OperatingSystem"].Value;
                if (!OpSystems.Contains(os))
                    OpSystems.Add(os);
                string browser = xNode.Attributes["Browser"].Value.Replace("IExplore", "IE");
                string config = os + " " + browser;
                if (!configs.Contains(config))
                    configs.Add(config);
            }
            phMachines.Controls.Add(new LiteralControl("<table><tr>"));
            foreach (string os in OpSystems)
            {
                Label lb = new Label();
                lb.ID = "lbl" + os;
                lb.Text = os;
                lb.Style.Add("font-size", "x-large");
                phMachines.Controls.Add(new LiteralControl("<td valign=\"top\">"));
                phMachines.Controls.Add(lb);
                CheckBoxList cbl = new CheckBoxList();
                cbl.ID = "cbl" + os;
                cbl.Style.Add("font-size", "larger");
                foreach (string sOperatingSystem in configs)
                {
                    if (sOperatingSystem.StartsWith(os))
                    {
                        cbl.Items.Add(new ListItem(sOperatingSystem.Substring(sOperatingSystem.IndexOf(" ") + 1)));
                    }
                }
                phMachines.Controls.Add(cbl);
                phMachines.Controls.Add(new LiteralControl("</td>"));
            }
            phMachines.Controls.Add(new LiteralControl("</tr></table>"));
        }

        /// <summary>
        /// Gets the url groups from the xml file and displays them on the webpage.
        /// </summary>
        void InsertGroups()
        {
            string folder = Paths.GetFilesPath();
            string group = string.Empty;
            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(folder + Paths.GetUrlFile());

            XmlNodeList nodes = xDoc.SelectNodes(Paths.GetUrlGroupNodes());
            int i = 0;
            foreach (XmlNode node in nodes)
            {
                group = node.Attributes["group"].Value;
                lbGroups.Items.Add(group);
                if (node.Attributes["active"].Value.ToLower() == "true")
                    lbGroups.Items[i].Selected = true;
                i++;
            }
        }

        /// <summary>
        /// Gets the machines and their browsers from the xml file
        /// </summary>
        /// <returns></returns>
        ArrayList GetMachineList()
        {
            ArrayList machines = new ArrayList();
            string sOperatingSystem = string.Empty;
            string sBrowser = string.Empty;
            XmlDocument xDoc = new XmlDocument();
            string folder = Paths.GetFilesPath();
            xDoc.Load(folder + Paths.GetMachinesFile());
            XmlNodeList nodes = xDoc.SelectNodes(Paths.GetMachineNodes());

            foreach (Control control in phMachines.Controls)
            {
                if (control.ID != null && control.ID.StartsWith("cbl") && control is CheckBoxList)
                {
                    CheckBoxList cbl = (CheckBoxList)control;
                    for (int j = 0; j < cbl.Items.Count; j++)
                    {
                        if (cbl.Items[j].Selected)
                        {
                            sOperatingSystem = cbl.ID.Substring(3);
                            sBrowser = cbl.Items[j].Text;
                            if (sBrowser.StartsWith("IE"))
                                sBrowser = sBrowser.Replace("IE", "IExplore");
                            foreach (XmlNode node in nodes)
                            {
                                if (node.Attributes["OperatingSystem"].Value.ToUpper() == sOperatingSystem.ToUpper() && node.Attributes["Browser"].Value.ToUpper() == sBrowser.ToUpper())
                                {
                                    machines.Add(new MachineInfo(node.Attributes["Name"].Value, sBrowser));
                                }
                            }
                        }
                    }
                }
            }
            return machines;
        }

        /// <summary>
        /// Sets which machines will run browser shots based on values in the xml file
        /// </summary>
        void SetActiveMachines()
        {
            string sOperatingSystem = string.Empty;
            string sBrowser = string.Empty;
            XmlDocument xDoc = new XmlDocument();
            string folder = Paths.GetFilesPath();
            xDoc.Load(folder + Paths.GetMachinesFile());
            XmlNodeList nodes = xDoc.SelectNodes(Paths.GetMachineNodes());

            foreach (Control control in phMachines.Controls)
            {
                if (control.ID != null && control.ID.StartsWith("cbl") && control is CheckBoxList)
                {
                    CheckBoxList cbl = (CheckBoxList)control;
                    for (int j = 0; j < cbl.Items.Count; j++)
                    {
                        sOperatingSystem = cbl.ID.Substring(3);
                        sBrowser = cbl.Items[j].Text;
                        if (sBrowser.StartsWith("IE"))
                            sBrowser = sBrowser.Replace("IE", "IExplore");
                        foreach (XmlNode node in nodes)
                        {
                            if (node.Attributes["OperatingSystem"].Value.ToUpper() == sOperatingSystem.ToUpper() && node.Attributes["Browser"].Value.ToUpper() == sBrowser.ToUpper() && node.Attributes["Active"].Value.ToLower() == "true")
                            {
                                cbl.Items[j].Selected = true;
                            }
                        }
                    }
                }
            }
        }
        /// <summary>
        /// Binds the data to the datagrid
        /// </summary>
        void BindDataGrid()
        {
            dgWaitingRequests.DataSource = GetAllRequests();
            dgWaitingRequests.DataBind();
            dgCurrent.DataSource = GetAllCurrentlyRunningRequests();
            dgCurrent.DataBind();
        }
        /// <summary>
        /// This method will get all the requests stored in the xml file
        /// </summary>
        /// <returns></returns>
        ArrayList GetAllRequests()
        {
            ArrayList requests = new ArrayList();
            string folder = Paths.GetFilesPath();
            string time = string.Empty;
            string os = string.Empty;
            string browser = string.Empty;
            string groups = string.Empty;
            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(folder + Paths.GetQueueFile());

            XmlNode rootNode = xDoc.SelectSingleNode(Paths.GetQueueNode());

            foreach (XmlNode node in rootNode.ChildNodes)
            {
                time = node.Attributes["Date"].Value;
                os = node.Attributes["OS"].Value;
                browser = node.Attributes["Browser"].Value;
                XmlNode urlGroupNodes = node.ChildNodes[1];
                groups = string.Empty;
                foreach (XmlNode groupNode in urlGroupNodes)
                {
                    groups += groupNode.InnerText + ",";
                }
                groups = groups.Substring(0, groups.Length - 1);
                requests.Add(new requestType(time, os, browser, groups));
            }

            return requests;
        }

        ArrayList GetAllCurrentlyRunningRequests()
        {
            ArrayList requests = new ArrayList();
            string folder = Paths.GetFilesPath();
            string time = string.Empty;
            string os = string.Empty;
            string browser = string.Empty;
            string groups = string.Empty;
            string startTime = string.Empty;
            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(folder + Paths.GetQueueFile());

            XmlNode rootNode = xDoc.SelectSingleNode(Paths.GetCurrentRequestsNode());

            foreach (XmlNode node in rootNode.ChildNodes)
            {
                time = node.Attributes["Date"].Value;
                os = node.Attributes["OS"].Value;
                browser = node.Attributes["Browser"].Value;
                groups = node.Attributes["UrlGroups"].Value;
                startTime = node.Attributes["StartTime"].Value;
                requests.Add(new requestType(time, os, browser, groups, startTime));
            }

            return requests;
        }

        /// <summary>
        /// Adds a delete buttons to the datagrid
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void dgRequests_DataBound(object sender, DataGridItemEventArgs e)
        {

            if (e.Item.ItemType != ListItemType.Header && e.Item.ItemType != ListItemType.Footer)
            {
                DataTable dt = new DataTable();
                ArrayList al = (ArrayList)dgWaitingRequests.DataSource;
                dt = Paths.ConvertObjectToDataTableSchema(al[0]);
                Paths.FillData(al, dt);
                DataView dv = new DataView(dt);
                DataColumnCollection dc = dv.Table.Columns;

                Button btnDelete = new Button();
                btnDelete.ID = "btnDelete";
                btnDelete.Text = "Delete";
                btnDelete.CausesValidation = false;
                btnDelete.Click += new System.EventHandler(btnDeleteRequest_Click);
                e.Item.Cells[4].Controls.Add(btnDelete);
            }
        }

        /// <summary>
        /// Deletes a request from the xml file
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void btnDeleteRequest_Click(object sender, EventArgs e)
        {
            DataTable dt = new DataTable();
            ArrayList al = (ArrayList)dgWaitingRequests.DataSource;
            dt = Paths.ConvertObjectToDataTableSchema(al[0]);
            DataView dv = new DataView(dt);
            DataColumnCollection dc = dv.Table.Columns;
            DataGridItem dgi = ((DataGridItem)(((Button)sender).Parent.Parent));
            string date = dgi.Cells[dc.IndexOf(dc["Date"])].Text;
            string oS = dgi.Cells[dc.IndexOf(dc["OS"])].Text;
            string browser = dgi.Cells[dc.IndexOf(dc["Browser"])].Text;
            string folder = Paths.GetFilesPath();

            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(folder + Paths.GetQueueFile());

            XmlNode rootNode = xDoc.SelectSingleNode(Paths.GetQueueNode());
            foreach (XmlNode node in rootNode.ChildNodes)
            {
                if (date == node.Attributes["Date"].Value && oS == node.Attributes["OS"].Value &&
                    browser == node.Attributes["Browser"].Value)
                    rootNode.RemoveChild(node);
            }
            xDoc.Save(folder + Paths.GetQueueFile());
            BindDataGrid();
        }
    }

    /// <summary>
    /// This class is used to store urls.
    /// It is used when the data is bound to the datagrid.
    /// </summary>
    class requestType
    {
        string date;
        string os;
        string browser;
        string groups;
        string startTime;

        public requestType(string date, string os, string browser, string groups)
        {
            this.os = os;
            this.date = date;
            this.browser = browser;
            this.groups = groups;
        }
        public requestType(string date, string os, string browser, string groups, string startTime)
        {
            this.os = os;
            this.date = date;
            this.browser = browser;
            this.groups = groups;
            this.startTime = startTime;
        }
        public string Date
        {
            get { return date; }
        }

        public string Os
        {
            get { return os; }
        }

        public string Browser
        {
            get { return browser; }
        }

        public string Groups
        {
            get { return groups; }
        }

        public string StartTime
        {
            get { return startTime; }
        }
    }

    class MachineInfo
    {
        string machineName;
        string browser;

        public MachineInfo(string machineName, string browser)
        {
            this.machineName = machineName;
            this.browser = browser;
        }
        public string MachineName
        {
            get { return machineName; }
        }
        public string Browser
        {
            get { return browser; }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\EventMonitoring\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\BrowserShots\ViewBrowserShots\ViewBrowserShots\Start.aspx.designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Test.Common.Utilities.ViewBrowserShots {
    
    
    public partial class Start {
        
        /// <summary>
        /// lblTitle control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblTitle;
        
        /// <summary>
        /// phMachines control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.PlaceHolder phMachines;
        
        /// <summary>
        /// lblScreenSize control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblScreenSize;
        
        /// <summary>
        /// lbScreenSize control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.ListBox lbScreenSize;
        
        /// <summary>
        /// lblColorDepth control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblColorDepth;
        
        /// <summary>
        /// lbColorDepth control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.ListBox lbColorDepth;
        
        /// <summary>
        /// lblJavascript control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblJavascript;
        
        /// <summary>
        /// lbJavascript control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.ListBox lbJavascript;
        
        /// <summary>
        /// lblActiveX control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblActiveX;
        
        /// <summary>
        /// lbActiveX control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.ListBox lbActiveX;
        
        /// <summary>
        /// lblDisableScriptDebugging control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblDisableScriptDebugging;
        
        /// <summary>
        /// lbDisableScriptDebugging control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.ListBox lbDisableScriptDebugging;
        
        /// <summary>
        /// lblDisplayErrorDialog control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblDisplayErrorDialog;
        
        /// <summary>
        /// lbDisplayErrorDialog control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.ListBox lbDisplayErrorDialog;
        
        /// <summary>
        /// lblWarnOnZoneCrossing control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblWarnOnZoneCrossing;
        
        /// <summary>
        /// lbWarnOnZoneCrossing control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.ListBox lbWarnOnZoneCrossing;
        
        /// <summary>
        /// lblZoom control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblZoom;
        
        /// <summary>
        /// lbZoom control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.ListBox lbZoom;
        
        /// <summary>
        /// lblTextSize control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblTextSize;
        
        /// <summary>
        /// lbTextSize control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.ListBox lbTextSize;
        
        /// <summary>
        /// lblLimitedUserPrivileges control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblLimitedUserPrivileges;
        
        /// <summary>
        /// lbLimitedUserPrivileges control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.ListBox lbLimitedUserPrivileges;
        
        /// <summary>
        /// lblGroups control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblGroups;
        
        /// <summary>
        /// lbGroups control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.ListBox lbGroups;
        
        /// <summary>
        /// btnStart control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button btnStart;
        
        /// <summary>
        /// lblWaitingRequests control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblWaitingRequests;
        
        /// <summary>
        /// dgWaitingRequests control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DataGrid dgWaitingRequests;
        
        /// <summary>
        /// lblCurrent control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label lblCurrent;
        
        /// <summary>
        /// dgCurrent control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DataGrid dgCurrent;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\CreateHosts\Exceptions.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Runtime.Serialization;

namespace CreateHosts
{
    [Serializable()]
    public class CreateHostsException : Exception
    {
        //Set the constructors and allow message and innerexception to be overriden
        public CreateHostsException()
            : base() { }

        public CreateHostsException(string message) : base(message) { }

        public CreateHostsException(string message, Exception innerException) : base(message, innerException) { }

        protected CreateHostsException(SerializationInfo info, StreamingContext context) : base(info, context) { }

        public override string Message
        {
            get
            {
                return base.Message;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\BrowserShots\ViewBrowserShots\ViewBrowserShots\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("ViewBrowserShots")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("Microsoft")]
//[assembly: AssemblyProduct("ViewBrowserShots")]
//[assembly: AssemblyCopyright("Copyright © Microsoft 2009")]
//[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("3d5900ae-111a-45be-96b3-d9e4606ca793")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
//[assembly: AssemblyVersion("1.0.0.0")]
//[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\FakeNotificationGenerator\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\EventMonitoring\EventMonitoring\Program.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml;
using System.Configuration;
using System.IO;
using System.Diagnostics;
using System.Data.SqlClient;
using System.Drawing;
using System.Data;
namespace XMLTest
{
    class Program
    {
        static int Main(string[] args)
        {
            #region Declear all Global variables.
            int exitCode = 0;
            int NoOfRowsInFinalResult =0;
            //with the help of this switch we can generate more logs which will be usefull for debugging.
            string wantFullLog = "no";

            if (ConfigurationSettings.AppSettings["wantFullLog"].ToLower() == "yes" || ConfigurationSettings.AppSettings["wantFullLog"].ToLower() == "y")
            {
                wantFullLog = "yes";

            }

            string systemDrive = Directory.GetDirectoryRoot(Environment.SystemDirectory);
            //create a directory which will hold all the test results.
            string LogFoldername = ConfigurationSettings.AppSettings["NameOfTheFolderContainingLogFiles"];
            if (!Directory.Exists(systemDrive + "AlertMonitorResults" + LogFoldername))
            {
                try
                {
                    Directory.CreateDirectory(systemDrive + "AlertMonitorResults" + LogFoldername);

                }
                catch (Exception ex)
                {
                    Console.WriteLine(ex.Message);
                    exitCode = 2;
                }
            }

            string logFileName = systemDrive + "AlertMonitorResults"+LogFoldername+"\\LogFile.txt";
            FileInfo fileInfoLogFile = new FileInfo(logFileName);
            FileStream fileStreamLogFile = new FileStream(logFileName, FileMode.Create);
            StreamWriter addLogStreamWrite = new StreamWriter(fileStreamLogFile);

            if (wantFullLog == "yes")
            {
                addLogStreamWrite.WriteLine("Till now we have successfully created the Log file.");
            }

            string alertResultFilename = systemDrive + "AlertMonitorResults" + LogFoldername + "\\AlertResults.txt";
            FileInfo fileInfoAlertResults = new FileInfo(alertResultFilename);
            FileStream fileStreamAlertResultFile = new FileStream(alertResultFilename, FileMode.Create);
            StreamWriter addAlertsStreamWriter = new StreamWriter(fileStreamAlertResultFile);

            string finalResultFileName = systemDrive + "AlertMonitorResults" + LogFoldername + "\\FinalResults.txt";
            FileInfo fileInfoFinalResult = new FileInfo(finalResultFileName);
            FileStream fileStreamFinalResult = new FileStream(finalResultFileName, FileMode.Create);
            StreamWriter addResultStreamWriter = new StreamWriter(fileStreamFinalResult);
            int countOfFinalResult = 1;




            int noofParametersPassed = args.Length;
            int errorPercentThreshold = 10;
            int errorThreshold = 3000;
            int warningPercentThreshold = 10;
            int warningThreshold = 3000;
            int alertLogCount = 100;
            string switchTocalculateAlert = "and";

            //DateTime time1 = DateTime.Now.AddMinutes(-15);
            //DateTime time2 = DateTime.Now.AddHours(-1).AddMinutes(-15);
            //DateTime time3 = DateTime.Now.AddHours(-2).AddMinutes(-15);

            DateTime time1 = DateTime.Now.AddMinutes(-15);
            DateTime time2 = DateTime.Now.AddHours(-1).AddMinutes(-15);
            DateTime time3 = DateTime.Now.AddHours(-2).AddMinutes(-15);



            addResultStreamWriter.WriteLine("Application Eventlog Count Report for MSN/MSGR Games Production Servers.");
            addResultStreamWriter.WriteLine(" ");
            addResultStreamWriter.WriteLine(string.Format("The current count is from {0} to {1}", time2.ToString(), time1.ToString()));
            addResultStreamWriter.WriteLine();
            addResultStreamWriter.WriteLine(string.Format("The Previous count is from {0} to {1}", time3.ToString(), time2.ToString()));
            addResultStreamWriter.WriteLine("*************************************************************************************");
            addResultStreamWriter.WriteLine(" ");
            addResultStreamWriter.WriteLine("NO.   MACHINE NAME             TYPE        CURRENT-COUNT   PREVIOUS-COUNT    DIFF");
            addResultStreamWriter.WriteLine();

            string connectionString = ConfigurationSettings.AppSettings["connectionString"];
            SqlConnection sqlconnectn = new SqlConnection(connectionString);


            string errorWarningCount5 = string.Empty;
            string errorWarningCount6 = string.Empty;
            string condition = string.Empty;
            string computerName = string.Empty;

            if (noofParametersPassed != 0)
            {
                //Writing Help for this tool
                #region Help
                if (args[0] == "?" || args[0] == "/?" || args[0] == "help" || args[0] == "Help" || args[0] == "HELP")
                {
                    exitCode = 3;
                    Console.WriteLine("This tool takes 6 parameters as input and all are optional");
                    Console.WriteLine("EventMonitoring.exe /errorPercentThreshold: /errorThreshold: /warningPercentThreshold: /warningThreshold: /alertLogCount: /switch:");
                    Console.WriteLine("Example:");
                    Console.WriteLine("EventMonitoring.exe /errorPercentThreshold:10 /errorThreshold:3000 /warningPercentThreshold:15 /warningThreshold:4000 /alertLogCount:100 /switch:or");
                    Console.WriteLine("");

                    return exitCode;

                }
                #endregion help

                else
                {
                    //Parsing the passed parameter values.
                    #region Parsing the input parameters.
                    string[] ch = new string[5];
                    string argutype;
                    char[] sep = new char[] { ':' };
                    ch = args[0].Split(sep);


                    for (int i = 0; i <= args.Length - 1; i++)
                    {
                        ch = args[i].Split(sep);
                        argutype = ch[0];
                        // Console.WriteLine(ch[1]);

                        if (argutype.ToLower() == "/errorPercentThreshold".ToLower())
                        {
                            errorPercentThreshold = Convert.ToInt32(ch[1]);
                            if (wantFullLog == "yes")
                            {
                                addLogStreamWrite.WriteLine("Value " + ch[1] + " has been passed through the command line for /errorPercentThreshold  parameter. ");
                            }
                        }
                        else
                        {
                            if (argutype.ToLower() == "/errorThreshold".ToLower())
                            {
                                errorThreshold = Convert.ToInt32(ch[1]);
                            }
                            else
                            {
                                if (argutype.ToLower() == "/warningPercentThreshold".ToLower())
                                {
                                    warningPercentThreshold = Convert.ToInt32(ch[1]);
                                }
                                else
                                {
                                    if (argutype.ToLower() == "/warningThreshold".ToLower())
                                    {
                                        warningThreshold = Convert.ToInt32(ch[1]);
                                    }
                                    else
                                    {
                                        if (argutype.ToLower() == "/alertLogCount".ToLower())
                                        {
                                            alertLogCount = Convert.ToInt32(ch[1]);
                                        }
                                        else
                                        {
                                            if (argutype.ToLower() == "/switch".ToLower())
                                            {
                                                switchTocalculateAlert = ch[1].ToLower();

                                            }
                                        }
                                    }
                                }
                            }
                        }




                    }

                    #endregion Parsing the input parameters.

                }
            }

            int errorPercentThresholdPassed = errorPercentThreshold;
            int errorThresholdPassed = errorThreshold;
            int warningPercentThresholdPassed = warningPercentThreshold;
            int warningThresholdPassed = warningThreshold;
            int alertLogCountPassed = alertLogCount;
            string switchTocalculateAlertPassed = switchTocalculateAlert;

            if (wantFullLog == "yes")
            {
                addLogStreamWrite.WriteLine("Total no. of parameters passed to EvenMonitor are " + noofParametersPassed.ToString());

                addLogStreamWrite.WriteLine("After the parsing of the parameters their default values are as below :-");
                addLogStreamWrite.WriteLine("errorThreshold : " + errorThreshold);
                addLogStreamWrite.WriteLine("errorPercentThreshold : " + errorPercentThreshold);
                addLogStreamWrite.WriteLine("warningThreshold : " + warningThreshold);
                addLogStreamWrite.WriteLine("warningPercentThreshold : " + warningPercentThreshold);
                addLogStreamWrite.WriteLine("switchTocalculateAlert : " + switchTocalculateAlert);


            }

            XmlDocument xmlDoc = new XmlDocument();

            #endregion Declear all Global variables.

            #region main Logic.

            try
            {
                xmlDoc.Load(ConfigurationSettings.AppSettings["PathOfSeverFilters"]);

                if (wantFullLog == "yes")
                {
                    addLogStreamWrite.WriteLine(ConfigurationSettings.AppSettings["PathOfSeverFilters"] + "XMLDoc has been successfully loaded.");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
                addLogStreamWrite.WriteLine(ex.Message);
                exitCode = 4;
            }

            XmlNodeList xmlNodeListServers = xmlDoc.GetElementsByTagName("server");

            try
            {

                for (int i = 0; i < xmlNodeListServers.Count; i++)
                {
                    // Console.ReadLine();

                    errorPercentThreshold = errorPercentThresholdPassed;
                    errorThreshold = errorThresholdPassed;
                    warningPercentThreshold = warningPercentThresholdPassed;
                    warningThreshold = warningThresholdPassed;
                    alertLogCount = alertLogCountPassed;
                    switchTocalculateAlert = switchTocalculateAlertPassed;

                    computerName = xmlNodeListServers.Item(i).SelectSingleNode("name").InnerText;
                    if (xmlNodeListServers.Item(i).SelectSingleNode("errorThreshold").InnerText.Trim() != "")
                    {
                        errorThreshold = Convert.ToInt32(xmlNodeListServers.Item(i).SelectSingleNode("errorThreshold").InnerText.Trim());
                    }
                    if (xmlNodeListServers.Item(i).SelectSingleNode("errorPercentThreshold").InnerText.Trim() != "")
                    {
                        errorPercentThreshold = Convert.ToInt32(xmlNodeListServers.Item(i).SelectSingleNode("errorPercentThreshold").InnerText.Trim());
                    }
                    if (xmlNodeListServers.Item(i).SelectSingleNode("warningThreshold").InnerText.Trim() != "")
                    {
                        warningThreshold = Convert.ToInt32(xmlNodeListServers.Item(i).SelectSingleNode("warningThreshold").InnerText.Trim());
                    }
                    if (xmlNodeListServers.Item(i).SelectSingleNode("warningPercentThreshold").InnerText.Trim() != "")
                    {
                        warningPercentThreshold = Convert.ToInt32(xmlNodeListServers.Item(i).SelectSingleNode("warningPercentThreshold").InnerText.Trim());
                    }
                    if (xmlNodeListServers.Item(i).SelectSingleNode("switchTocalculateAlert").InnerText.Trim() != "")
                    {
                        switchTocalculateAlert = xmlNodeListServers.Item(i).SelectSingleNode("switchTocalculateAlert").InnerText.Trim();
                    }


                    Console.WriteLine(computerName);
                    errorWarningCount5 = "select computer,Type,count(*) From ApplicationEvents where (Type= 'Error' or Type= 'warning') and EntryDate between" + " " + "'" + time2 + "'" + " " + "and" + " " + "'" + time1 + "'";

                    errorWarningCount6 = "select computer,Type,count(*) From ApplicationEvents where (Type= 'Error' or Type= 'warning') and EntryDate between" + " " + "'" + time3 + "'" + " " + "and" + " " + "'" + time2 + "'";

                    condition = string.Empty;

                    XmlNodeList xmlNodeListIgnoreChild = xmlNodeListServers.Item(i).SelectSingleNode("ignore").ChildNodes;

                    foreach (XmlNode xmlNodeIgnore in xmlNodeListIgnoreChild)
                    {

                        if (xmlNodeIgnore.InnerText != "")
                        {
                            //Console.WriteLine(xmlNodeIgnore.Name);
                            if (xmlNodeIgnore.Name == "ID")
                            {
                                condition = condition + " and " + xmlNodeIgnore.Name + " != " + xmlNodeIgnore.InnerText;
                            }
                            else
                            {
                                condition = condition + " and " + xmlNodeIgnore.Name + " not like " + "'" + xmlNodeIgnore.InnerText + "'";

                            }


                        }

                    }
                    // Console.WriteLine(condition);

                    errorWarningCount5 = errorWarningCount5 + condition + " " + " and computer like" + " " + "'" + computerName + "'" + " " + "Group By Computer,Type Order By computer,Type";

                    errorWarningCount6 = errorWarningCount6 + condition + " " + " and computer like" + " " + "'" + computerName + "'" + " " + "Group By Computer,Type Order By computer,Type";
                    if (wantFullLog == "yes")
                    {
                        addLogStreamWrite.WriteLine("Tool is processing the Server " + computerName);
                        addLogStreamWrite.WriteLine("Values of the parameters for this computer are as below:");
                        addLogStreamWrite.WriteLine("errorThreshold : " + errorThreshold);
                        addLogStreamWrite.WriteLine("errorPercentThreshold : " + errorPercentThreshold);
                        addLogStreamWrite.WriteLine("warningThreshold : " + warningThreshold);
                        addLogStreamWrite.WriteLine("warningPercentThreshold : " + warningPercentThreshold);
                        addLogStreamWrite.WriteLine("switchTocalculateAlert : " + switchTocalculateAlert);

                        addLogStreamWrite.WriteLine("Value of the condition variable which is used in the query is " + condition);
                        addLogStreamWrite.WriteLine("Vaule of the query one is " + errorWarningCount5);
                        addLogStreamWrite.WriteLine("Vaule of the query two is " + errorWarningCount6);

                    }

                    #region The main logic of calculating the diff between two query

                    if (wantFullLog == "yes")
                    {
                        addLogStreamWrite.WriteLine("Calculating the diff between the results of the two queries and creating the new table");
                    }


                    SqlDataAdapter errorwarningSqlDataAdapter = new SqlDataAdapter(errorWarningCount5, sqlconnectn);
                    errorwarningSqlDataAdapter.SelectCommand.CommandTimeout = 60 * 5;
                    DataTable tableT1 = new DataTable();
                    DataTable tableT2 = new DataTable();
                    DataTable tableT3 = new DataTable();

                    errorwarningSqlDataAdapter.Fill(tableT1);
                    
                    //using the same sqlDataAdapter to execute the second query.
                    errorwarningSqlDataAdapter = new SqlDataAdapter(errorWarningCount6, sqlconnectn);
                    errorwarningSqlDataAdapter.SelectCommand.CommandTimeout = 60 * 5;
                    errorwarningSqlDataAdapter.Fill(tableT2);
              
                    //Defining the sructure of the table3 which contains the data of table1 and table2.
                    tableT3.Columns.Add("Computer", typeof(string));
                    tableT3.Columns.Add("Type", typeof(string));
                    tableT3.Columns.Add("CurrentCount", typeof(int));
                    tableT3.Columns.Add("PreviousCount", typeof(int));
                    tableT3.Columns.Add("Difference", typeof(int));

                    int countTable1 = 0;
                    int countTable2 = 0;
                    bool matchFound = false;

                    //Iterating through both the tables tableT1 and tableT2 and storing the result in tableT3.

                    #region new logic to  merge two tables.
                 
                    while (countTable1 <= tableT1.Rows.Count - 1)
                    {
                        matchFound = false;
                        countTable2 = 0;
                        while (countTable2 <= tableT2.Rows.Count - 1)
                        {
                            if (tableT1.Rows[countTable1][0].ToString() == tableT2.Rows[countTable2][0].ToString())
                            {
                                if (tableT1.Rows[countTable1][1].ToString() == tableT2.Rows[countTable2][1].ToString())
                                {
                                    matchFound = true;
                                    Console.WriteLine(string.Format("same computer found {0}", tableT1.Rows[countTable1][0].ToString()));
                                    DataRow row;
                                    row = tableT3.NewRow();
                                    row[0] = tableT1.Rows[countTable1][0].ToString();
                                    row[1] = tableT1.Rows[countTable1][1].ToString();
                                    row[2] = (int)tableT1.Rows[countTable1][2];
                                    row[3] = (int)tableT2.Rows[countTable2][2];
                                    row[4] = (int)tableT1.Rows[countTable1][2] - (int)tableT2.Rows[countTable2][2];
                                    tableT3.Rows.Add(row);
                                    tableT2.Rows[countTable2].Delete();
                                    //countTable2++;
                                   // break;
                                }
                                else
                                {
                                    countTable2++;
                                }
                            }
                            else
                            {
                                countTable2++;
                            }

                            tableT2.AcceptChanges();

                        }
                        //tableT2.AcceptChanges();
                        if (!matchFound)
                        {
                            //Add the row from Table1 to Table3
                            DataRow leftrowinTable1;
                            leftrowinTable1 = tableT3.NewRow();
                            leftrowinTable1[0] = tableT1.Rows[countTable1][0].ToString();
                            leftrowinTable1[1] = tableT1.Rows[countTable1][1].ToString();
                            leftrowinTable1[2] = (int)tableT1.Rows[countTable1][2];
                            leftrowinTable1[3] = 0;
                            leftrowinTable1[4] = (int)tableT1.Rows[countTable1][2];
                            tableT3.Rows.Add(leftrowinTable1);

                        }

                        countTable1++;
                    }
                    //add the remaining rows form Table2 to Table3.
                    if (tableT2.Rows.Count > 0)
                    {
                        countTable2 = 0;
                        while (countTable2 != tableT2.Rows.Count)
                        {
                            DataRow leftrowinTable2;
                            leftrowinTable2 = tableT3.NewRow();
                            leftrowinTable2[0] = tableT2.Rows[countTable2][0].ToString();
                            leftrowinTable2[1] = tableT2.Rows[countTable2][1].ToString();
                            leftrowinTable2[2] = 0;
                            leftrowinTable2[3] = (int)tableT2.Rows[countTable2][2];
                            leftrowinTable2[4] = -1 * (int)tableT2.Rows[countTable2][2];
                            tableT3.Rows.Add(leftrowinTable2);

                            Console.WriteLine("Left out of table2");
                            countTable2++;
                        }


                    }
                    #endregion End of new logic to merge two tables.

                    clspercentage objofPercentage = new clspercentage();
                    bool alert = false;
                    bool thresholdNoReached = false;
                    bool thresholdPercentagReached = false;
                    string alertComputer = string.Empty;
                    string alertType = string.Empty;
                    string alertCount = string.Empty;
                    string alertPercentage = string.Empty;
                    #region calculating Alert.

                    if (wantFullLog == "yes")
                    {
                        addLogStreamWrite.WriteLine("Calculating the alert.");
                    }
                                       
                    for (int k = 0; k < tableT3.Rows.Count; k++)
                    {
                        if ((int)tableT3.Rows[k][4] > 0)
                        {

                            if (switchTocalculateAlert.ToLower() == "or")
                            {
                                #region OR logic
                                if (tableT3.Rows[k][1].ToString() == "Error")
                                {
                                    if ((int)tableT3.Rows[k][4] >= errorThreshold)
                                    {
                                        exitCode = 1;
                                        alert = true;
                                        alertComputer = tableT3.Rows[k][0].ToString();
                                        alertType = tableT3.Rows[k][1].ToString();
                                        alertCount = tableT3.Rows[k][4].ToString();
                                        thresholdNoReached = true;
                                        break;

                                    }
                                    else
                                    {
                                        if (objofPercentage.CalculatePercentage((int)tableT3.Rows[k][2], (int)tableT3.Rows[k][3]) >= errorPercentThreshold)
                                        {
                                            exitCode = 1;
                                            alert = true;
                                            alertComputer = tableT3.Rows[k][0].ToString();
                                            alertType = tableT3.Rows[k][1].ToString();
                                            alertPercentage = objofPercentage.CalculatePercentage((int)tableT3.Rows[k][2], (int)tableT3.Rows[k][3]).ToString();
                                            thresholdPercentagReached = true;
                                            break;

                                        }
                                    }

                                }
                                else
                                {
                                    if (tableT3.Rows[k][1].ToString() == "Warning")
                                    {


                                        if ((int)tableT3.Rows[k][4] >= warningThreshold)
                                        {
                                            exitCode = 1;
                                            alert = true;
                                            alertComputer = tableT3.Rows[k][0].ToString();
                                            alertType = tableT3.Rows[k][1].ToString();
                                            alertCount = tableT3.Rows[k][4].ToString();
                                            thresholdNoReached = true;

                                            break;
                                        }
                                        else
                                        {
                                            if ((objofPercentage.CalculatePercentage((int)tableT3.Rows[k][2], (int)tableT3.Rows[k][3]) >= warningPercentThreshold))
                                            {
                                                exitCode = 1;
                                                alert = true;
                                                alertComputer = tableT3.Rows[k][0].ToString();
                                                alertType = tableT3.Rows[k][1].ToString();
                                                alertPercentage = objofPercentage.CalculatePercentage((int)tableT3.Rows[k][2], (int)tableT3.Rows[k][3]).ToString();
                                                thresholdPercentagReached = true;

                                                break;

                                            }
                                        }
                                    }
                                    else
                                    {
                                        exitCode = 5;
                                        Console.WriteLine("The event type is not of either Error type or Warning Type.");
                                    }

                                }

                                #endregion OR logic
                            }
                            else
                            {
                                #region AND logic
                                if (switchTocalculateAlert.ToLower() == "and")
                                {
                                    if (tableT3.Rows[k][1].ToString() == "Error")
                                    {
                                        if ((int)tableT3.Rows[k][4] >= errorThreshold && objofPercentage.CalculatePercentage((int)tableT3.Rows[k][2], (int)tableT3.Rows[k][3]) >= errorPercentThreshold)
                                        {
                                            exitCode = 1;
                                            alert = true;
                                            alertComputer = tableT3.Rows[k][0].ToString();
                                            alertType = tableT3.Rows[k][1].ToString();
                                            alertCount = tableT3.Rows[k][4].ToString();
                                            alertPercentage = objofPercentage.CalculatePercentage((int)tableT3.Rows[k][2], (int)tableT3.Rows[k][3]).ToString();
                                            thresholdNoReached = true;
                                            break;

                                        }

                                    }
                                    else
                                    {
                                        if (tableT3.Rows[k][1].ToString() == "Warning")
                                        {

                                            if ((int)tableT3.Rows[k][4] >= warningThreshold && objofPercentage.CalculatePercentage((int)tableT3.Rows[k][2], (int)tableT3.Rows[k][3]) >= warningPercentThreshold)
                                            {
                                                exitCode = 1;
                                                alert = true;
                                                alertComputer = tableT3.Rows[k][0].ToString();
                                                alertType = tableT3.Rows[k][1].ToString();
                                                alertCount = tableT3.Rows[k][4].ToString();
                                                alertPercentage = objofPercentage.CalculatePercentage((int)tableT3.Rows[k][2], (int)tableT3.Rows[k][3]).ToString();
                                                thresholdNoReached = true;

                                                break;
                                            }
                                        }
                                        else
                                        {
                                            exitCode = 5;
                                            Console.WriteLine("The event type is not of either Error type or Warning Type.");

                                        }

                                    }

                                }
                                else
                                {
                                    exitCode = 6;
                                    Console.WriteLine("The value of switch provided is neither OR nor AND. Please provide the correct value or do not provide anything so that it will use the default value OR.");
                                }

                                #endregion AND logic

                            }

                        }

                        //We can write logic to handle the negative percentage here.

                    }
                    if (wantFullLog == "yes")
                    {
                        addLogStreamWrite.WriteLine("Alert calculation is done.");
                    }
                    #endregion calculating Alert.

                    #region Generating AlertLog if Alert found.
                    #region creating body of the mail. Adding to the Final Result file.
                    if (alert)
                    {
                        addResultStreamWriter.WriteLine("********** ALERT HAS BEEN FOUND ON " + computerName + " FOR " + alertType + " **********");

                    }
                    //incrementing the value of the counter NoOfRowsInFinalResult.
                    for (int j = 0; j < tableT3.Rows.Count; j++)
                    {
                        NoOfRowsInFinalResult++;
                        Console.WriteLine(tableT3.Rows[j][4].ToString());
                        addResultStreamWriter.Write(countOfFinalResult.ToString().PadRight(5));
                        addResultStreamWriter.Write(tableT3.Rows[j][0].ToString().PadRight(25));
                        addResultStreamWriter.Write(tableT3.Rows[j][1].ToString().PadRight(15));
                        addResultStreamWriter.Write(tableT3.Rows[j][2].ToString().PadRight(15));
                        addResultStreamWriter.Write(tableT3.Rows[j][3].ToString().PadRight(15));
                        addResultStreamWriter.Write(tableT3.Rows[j][4].ToString().PadRight(15));
                        addResultStreamWriter.WriteLine();
                        countOfFinalResult++;

                    }

                    #endregion creating body of the mail. Adding to the Final Result file.

                    if (alert)
                    {
                        if (wantFullLog == "yes")
                        {
                            addLogStreamWrite.WriteLine("Generating alert log for " + alertComputer);
                        }
                        string alertlogQuery = "select * from dbo.applicationEvents where type = " + "'" + alertType + "'" + " and Computer = " + "'" + alertComputer + "'" + " and entrydate between '" + time2 + "'" + " " + "and" + " " + "'" + time1 + "'" + " " + condition;

                        SqlCommand alertSqlcommand = new SqlCommand(alertlogQuery, sqlconnectn);
                        alertSqlcommand.CommandTimeout = 60 * 5;

                        try
                        {
                            sqlconnectn.Open();
                        }
                        catch (Exception ex)
                        {
                            exitCode = 7;
                            Console.WriteLine("Sqlconnenction could not be established in Alertlog block" + ex.Message);
                        }

                        SqlDataReader alertDataReader = alertSqlcommand.ExecuteReader();
                        int noOfrowsRequiredinAlertLog = 0;

                        if (thresholdNoReached)
                        {
                            addAlertsStreamWriter.WriteLine(string.Format("The server {0} is hitting more {1} events. {2} more events has been logged last hour. Exact figures can be found in the body of the mail.", alertComputer, alertType, alertCount));
                        }
                        if (thresholdPercentagReached)
                        {
                            addAlertsStreamWriter.WriteLine(string.Format("The server {0} is hitting more {1} events. {2}% more events has been logged last hour. Exact figures can be found in the body of the mail.", alertComputer, alertType, alertPercentage));

                        }

                        addAlertsStreamWriter.WriteLine();
                        addAlertsStreamWriter.WriteLine("No.     UID            ENTRY-DATE           TYPE    CATEGORY    ID     SOURCE               USER         COMPUTER         EVENT-DETAILS      ");
                        while (alertDataReader.Read())
                        {
                            addAlertsStreamWriter.Write(noOfrowsRequiredinAlertLog.ToString());
                            addAlertsStreamWriter.Write(":->");
                            addAlertsStreamWriter.Write(alertDataReader[0].ToString().PadRight(15));
                            addAlertsStreamWriter.Write(alertDataReader[1].ToString().PadRight(20));
                            addAlertsStreamWriter.Write("    ");
                            addAlertsStreamWriter.Write(alertDataReader[2].ToString().PadRight(10));
                            addAlertsStreamWriter.Write("   ");
                            addAlertsStreamWriter.Write(alertDataReader[3].ToString().PadRight(3));
                            addAlertsStreamWriter.Write("   ");

                            addAlertsStreamWriter.Write(alertDataReader[4].ToString().PadRight(7));
                            addAlertsStreamWriter.Write(alertDataReader[5].ToString().PadRight(25));
                            addAlertsStreamWriter.Write(alertDataReader[6].ToString().PadRight(7));
                            addAlertsStreamWriter.Write(alertDataReader[7].ToString().PadRight(20));
                            addAlertsStreamWriter.Write(alertDataReader[8].ToString());
                            addAlertsStreamWriter.WriteLine();
                            addAlertsStreamWriter.WriteLine("***********************************************************************");

                            if (noOfrowsRequiredinAlertLog == alertLogCount)
                            {
                                break;
                            }
                            noOfrowsRequiredinAlertLog++;

                        }
                        addAlertsStreamWriter.WriteLine("========================================================================");
                        addAlertsStreamWriter.WriteLine("========================================================================");
                        addAlertsStreamWriter.WriteLine("====================ALERT FOR NEXT SERVER===========================");

                        alertDataReader.Close();
                    }

                    sqlconnectn.Close();

                    #endregion Generating AlertLog if Alert found.
                    #endregion The main logic of calculating the diff between two query

                    Console.WriteLine(errorWarningCount5);
                    Console.WriteLine("Second Query");
                    Console.WriteLine(errorWarningCount6);
                    Console.WriteLine("======================================");
                    if (wantFullLog == "yes")
                    {
                        addLogStreamWrite.WriteLine("********** Log for the next Server **********");
                    }

                }
                //If tableT3 is empty return with the erorr message Database does not contains data for the following time. It may be bacuase database is not getting updated.

                if (NoOfRowsInFinalResult == 0)
                {
                    addResultStreamWriter.WriteLine("Database does not contains data for the current time. It may be bacuase database is not getting updated.");
                    
                    exitCode = 9;

                }
                
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
                addLogStreamWrite.WriteLine(ex.Message);
                exitCode = 8;
            }

            #endregion Main Logic.

            if (wantFullLog == "yes")
            {
                addLogStreamWrite.WriteLine("End of the LOG.");
            }
            addLogStreamWrite.Flush();
            addLogStreamWrite.Close();
            addAlertsStreamWriter.Flush();
            addAlertsStreamWriter.Close();
            addResultStreamWriter.Flush();
            addResultStreamWriter.Close();
            return exitCode;
        }
    }
    class clspercentage
    {
        public int CalculatePercentage(int error1, int error2)
        {
            int errorsOnFirstHr = error1;
            int errorsOnSecondHr = error2;
            int percentageChange = 0;
            int diffOferrors = 0;

            diffOferrors = errorsOnFirstHr - errorsOnSecondHr;
            if (diffOferrors < 0)
            {
                diffOferrors = diffOferrors * -1;
            }

            if (errorsOnSecondHr > 0)
            {
                percentageChange = (diffOferrors * 100) / errorsOnSecondHr;
            }
            else
            {
                percentageChange = (diffOferrors * 100) /1;
            }

            return percentageChange;


        }

        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\EventMonitoring\EventMonitoring\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("EventMonitoring")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("MSIT")]
//[assembly: AssemblyProduct("EventMonitoring")]
//[assembly: AssemblyCopyright("Copyright © MSIT 2008")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("2e18407c-7d2f-49ae-a210-d0597371c631")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
//[assembly: AssemblyVersion("1.0.0.0")]
//[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\CreateHosts\Program.cs ===
﻿using System;
using System.Text;
using System.IO;
using System.Net;
using System.Globalization;

using Microsoft.Win32;

/*
 * Created By: bradking
 * Owner: bradking
 * Description: This console application will replace your current hosts file with a hosts file
 *  that will enable users to access all necessary servers for Xbox.com test environments. There is also
 *  an option that will allow you to overwrite proxy settings in IE so that you can access all the necessary servers
 *  through the corporate proxy.
 */
namespace CreateHosts
{
    class Program
    {
        //Declare string variables
        public static string responseStatus, responseData = "";

        /// <summary>
        /// Launches the main console window and handles user inputs
        /// </summary>
        static void Main(string[] args)
        {
            //Declare an app error handler to catch all exceptions and deliver the message in a formatted manner
            AppDomain currentDomain = AppDomain.CurrentDomain;
            currentDomain.UnhandledException +=new UnhandledExceptionEventHandler(CreateHostsHandler);



            if (args.Length > 0)
            {
                foreach (string arg in args)
                {
                    //Depending on the argument we update
                    switch (arg)
                    {
                        case "/a":
                            //Call the change hosts function passing in the URI to the hosts.exe on the sharepoint
                            CreateHosts();
                            UpdateIEProxy();
                            UpdateFFProxy();
                            return;
                        case "/hosts":
                            CreateHosts();
                            break;
                        case "/ie":
                             UpdateIEProxy();
                            break;
                        case "/ff":
                            UpdateFFProxy();
                            break;
                        default:
                            break;
                    }
                }
            }
            else
            {
                //Call the change hosts function and proxy exception function
                CreateHosts();
                SetProxyExceptions();
 
                //Wait for user input before closing the console app
                Console.WriteLine();
                Console.WriteLine("Press any key to exit.");
                Console.ReadKey();
            }
        }

        /// <summary>
        /// This method prompts the user to set their proxy exceptions for a variety of browser types
        /// </summary>
        /// <param name="arg">And argument that will skip the questions and just enable proxy exceptions for all browsers</param>
        public static void SetProxyExceptions()
        {
            //Ask the user if they want to overwrite their IE settings
            StringBuilder chooseBrowserUpdates = new StringBuilder();
            chooseBrowserUpdates.AppendLine("What browser(s) would you like to set proxy exceptions for?");
            chooseBrowserUpdates.AppendLine("1. Internet Explorer");
            chooseBrowserUpdates.AppendLine("2. Firefox");
            chooseBrowserUpdates.AppendLine("3. All Browsers");
            chooseBrowserUpdates.Append("Please enter a number from the list: ");
            Console.Write(chooseBrowserUpdates);

            //Read the number and perform proxy exceptions updates for the appropriate browser(s)
            switch (Console.ReadLine().ToLower(CultureInfo.CurrentCulture).Trim().ToString())
            {
                case "1":
                    UpdateIEProxy();
                    return;
                case "2":
                    UpdateFFProxy();
                    return;
                case "3":
                case "all":
                    UpdateIEProxy();
                    UpdateFFProxy();
                    return;
                default:
                    Console.WriteLine("");
                    Console.WriteLine("Your settings have NOT been updated!");
                    return;
            }
        }

        /// <summary>
        /// This method grabs the latest hosts.txt entries from the sharepoint site and replaces
        /// the local users hosts with the new data.
        /// </summary>
        public static void CreateHosts()
        {
            Console.WriteLine("Give me a moment to update your hosts file...");

            //Set a URI to a global HOSTS configuration stored on the Xbox.com sharepoint site
            //TODO: Configure this app so that the URI isn't hardcoded
            Uri hostsUri = new Uri(@"http://sharepoint/sites/xboxcomscrum/test/Shared%20Documents/Configuration%20Documents/hosts.txt");

            //Set the paths to the files we want to manipulate as streams
            string oldHosts = Environment.ExpandEnvironmentVariables("%windir%") + "\\system32\\drivers\\etc\\hosts";
            string newHosts = Path.GetTempFileName();

            //Create a stream and stream writer for the temp file that we use to copy hosts data into
            FileStream newHostsFile = new FileStream(newHosts, FileMode.Create, FileAccess.ReadWrite);
            StreamWriter newHostsStream = new StreamWriter(newHostsFile);

            /*
             * If we recieve a 200 code from the sharepoint URI where we get the hosts information then we continue
             * and write the information from the hosts file to our newHosts file stream. We then replace the old hosts
             * file with the new one.
             */
            if (GetURIResponse(hostsUri) == HttpStatusCode.OK.ToString())
            {
                newHostsStream.Write(Program.responseData);
                newHostsStream.Close();

                //Replace the hosts file with the temp file
                if (!CreateHostsFile(newHosts, oldHosts))
                    throw new CreateHostsException("The old hosts file could not be replaced!");
            }
            else
            {
                throw new CreateHostsException("The URI used returned the following status " + Program.responseStatus.ToString());
            }
        }

        /// <summary>
        /// This method takes a URI parameter and returns the status and data from the URI.
        /// The status is placed in the global variable rsStatus and the data is returned in rsFromServer.
        /// Both of these variables can be accessed from any method inside of this project.
        /// </summary>
        /// <param name="hURI">A valid URI to any location</param>
        /// <returns>The return status of the URI called</returns>
        public static string GetURIResponse(Uri Uri)
        {
            //Create a request for the URI
            WebRequest request = WebRequest.Create(Uri.ToString());

            //Set the credentials to the current network level
            request.Credentials = CredentialCache.DefaultNetworkCredentials;

            //Capture the response from the request
            HttpWebResponse response = (HttpWebResponse)request.GetResponse();

            //Get the stream returned from the server
            Stream dataStream = response.GetResponseStream();
            Program.responseStatus = response.StatusDescription;

            //Since we succeeded in getting data we scrape it into text
            StreamReader reader = new StreamReader(dataStream);
            Program.responseData = reader.ReadToEnd();
            
            //Close out all objects
            reader.Close();
            dataStream.Close();
            response.Close();

            //Return the stream containing the hosts file information
            return Program.responseStatus;
        }

        /// <summary>
        /// Performs a file replacement of an old file with a new one
        /// </summary>
        /// <param name="newFile">The new file you want to replace the old one with.</param>
        /// <param name="oldFile">The old file that you no longer care about and just want to be friends with.</param>
        public static bool CreateHostsFile(string newFile, string oldFile)
        {
            //Set a boolean to track the success of the replace method (default to false)
            bool fileReplaced = false;

            //Overwrite the hosts file with the new one we've generated
            FileInfo fileInfo = new FileInfo(newFile);
  
            //Remove the .txt file extension from the temporary hosts file as the default hosts file has no extension.
            fileInfo.CopyTo(Path.ChangeExtension(oldFile, ""), true);
            fileInfo.Delete(); //Delete the temporary file we created

            //Write out to the console to inform the user that the replacement succeeded.
            Console.WriteLine("Hosts file successfully updated!");
            Console.WriteLine();

            //Set the file replaced status to true.
            fileReplaced = true;

            //Return the boolean status
            return fileReplaced;
        }

        /// <summary>
        /// Replaces or copies a new user.js file into a Firefox users profile directory
        /// </summary>
        /// <param name="file">The name of the file you want to insert</param>
        /// <returns></returns>
        public static bool CreateUserFile(string filePath, string fileContents)
        {
            //Set a boolean to track the success of the replace method (default to false)
            bool fileCreated = false;

            //Create the new user.js file
            try
            {
                FileInfo fileInfo = new FileInfo(filePath + @"\user.js");
                StreamWriter fileStream = fileInfo.CreateText();

                //Write the string contents to the file and close the stream
                fileStream.Write(fileContents);
                fileStream.Close();

                //Set the file replaced status to true.
                fileCreated = true;
            }
            catch
            {
                throw;
            }
                       
            //Return the boolean status
            return fileCreated;
        }

        /// <summary>
        /// Performs an update of the Internet Explorer proxy settings
        /// </summary>
        public static void UpdateIEProxy()
        {
            //Set static registry path entries for the Internet Explorer settings we want to change
            string IEPath = @"Software\Microsoft\Windows\CurrentVersion\Internet Settings\";
            string IEPathConnections = @"Software\Microsoft\Windows\CurrentVersion\Internet Settings\Connections\";
            string strProxyServer = "itgproxy.redmond.corp.microsoft.com:80";
            //Set a URI to a global PROXY configuration stored on the Xbox.com sharepoint site
            //TODO: Configure this app so that the URI isn't hardcoded
            Uri proxyExceptionsURI = new Uri(@"http://sharepoint/sites/xboxcomscrum/test/Shared%20Documents/Configuration%20Documents/proxyexceptions.txt");

            //Open the keys that we want to edit in the registry
            RegistryKey regKeyIEProxy = Registry.CurrentUser.OpenSubKey(IEPath, true);
            RegistryKey regKeyIEConnections = Registry.CurrentUser.OpenSubKey(IEPathConnections, true);
                
            //Enable the Proxy
            regKeyIEProxy.SetValue("ProxyEnable", "1", RegistryValueKind.DWord);
            
            //Set the ProxyServer value
            regKeyIEProxy.SetValue("ProxyServer", strProxyServer);
            
            //Get the current proxy exception list from the web
            string HttpStatus = GetURIResponse(proxyExceptionsURI);
            if (HttpStatus != HttpStatusCode.OK.ToString() )
            {
                throw new CreateHostsException("The Uri for proxy exceptions returned the following HTTP status: " + HttpStatus);
            }

            //Set the ProxyException value with the value we got from the proxy table on the Xbox.com sharepoint site
            regKeyIEProxy.SetValue("ProxyOverride", Program.responseData);

            /*
            * Determine if the Automatcially Detect Settings checkbox is enabled in IE.
            * If so, we change the byte value to 2E which will uncheck the box.
            * Otherwise we just leave the setting alone
            */
            byte[] disableAutoDetect = regKeyIEConnections.GetValue("DefaultConnectionSettings") as byte[];

            //The value for this checkbox is different by OS (XP or Vista/Server)
            switch (Environment.OSVersion.Version.Major)
            { 
                case 5:
                    disableAutoDetect[8] = 1; //Windows XP
                    break;
                case 6:
                    disableAutoDetect[8] = 3; //Windows Vista/Server
                    break; 
            }

            //Set the Default Connection Settings
            regKeyIEConnections.SetValue("DefaultConnectionSettings", disableAutoDetect);
                            
            //Display a message that the settings were updated
            Console.WriteLine("");
            Console.WriteLine("IE settings successfully updated!");
        }

        /// <summary>
        /// Performs an update of the Firefox proxy settings
        /// </summary>
        public static void UpdateFFProxy()
        {
            /*
             * ---- From http://www.mozilla.org/unix/customizing.html#prefs ----
             * Normal prefs are kept in prefs.js in the user's profile directory 
             * (which is overwritten by Mozilla every time a pref is changed), 
             * but here's a tip: prefs or other JavaScript that you don't want overwritten (e.g. comments) 
             * can be put in a file called user.js in the same directory, which is under the user's control 
             * and is read but never written by Mozilla.
             * 
             * One caution with using user.js: prefs set to non-default values in user.js are also 
             * written to prefs.js, so removing or commenting out pref settings in user.js doesn't 
             * necessarily cause Mozilla to stop using your previous pref setting. If you change user.js 
             * and aren't getting the results you expect, be sure to check prefs.js to make sure it 
             * isn't setting a conflicting value.
             */

            //Set a URI to a global users file that we will copy to all FF profiles. We append this data with the current exception list as well
            //TODO: Configure this app so that the URI isn't hardcoded
            Uri userUri = new Uri(@"http://sharepoint/sites/xboxcomscrum/test/Shared%20Documents/Configuration%20Documents/user.txt");
            Uri proxyExceptionsUri = new Uri(@"http://sharepoint/sites/xboxcomscrum/test/Shared%20Documents/Configuration%20Documents/proxyexceptions.txt");
            
            //Create a string to hold the contents of the user file
            StringBuilder userContents = new StringBuilder(String.Empty);

            //Get the current user.js file data from the sharepoint site
            if (GetURIResponse(userUri) == HttpStatusCode.OK.ToString())
            {
                //Write the default user.js file data to our string
                userContents.AppendLine(Program.responseData.ToString());
            }
            else
            {
                throw new CreateHostsException("The Uri for the user file returned the following HTTP status: " + Program.responseStatus);
            }
            
            //Get the latest proxy exception data from the sharepoint site
            if (GetURIResponse(proxyExceptionsUri) == HttpStatusCode.OK.ToString())
            {
                //Write the current proxy exceptions to our string
                userContents.AppendLine("user_pref(\"network.proxy.no_proxies_on\", \"" 
                    + Program.responseData + "\");");
            }
            else
            {
                throw new CreateHostsException("The Uri for the user file returned the following HTTP status: " + Program.responseStatus);
            }

            //Get a list of all directories within the Firefox Profiles path
            string[] subdirEntries = Directory.GetDirectories(Environment.ExpandEnvironmentVariables("%appdata%") 
                + @"\Mozilla\Firefox\Profiles");

            //For each directory in the directory we want to scan for the proxy exceptions file
            foreach (string subdir in subdirEntries)
            {
                //Replace the old users.js file with our new one
                if (!CreateUserFile(subdir, userContents.ToString()))
                {    
                    throw new CreateHostsException("The user file could not be added or replace for the following directory: " + subdir.ToString());
                }
            }

            //Display a message that the settings were updated
            Console.WriteLine("");
            Console.WriteLine("Firefox settings successfully updated!");
        }

        /// <summary>
        /// A general exception handler called whenever any function in the app generates an error in code
        /// </summary>
        /// <param name="sender">The sender object information</param>
        /// <param name="args">Any arguments passed to the unhandled acception</param>
        static void CreateHostsHandler(object sender, UnhandledExceptionEventArgs args)
        {
            Exception e = (Exception)args.ExceptionObject;
            Console.WriteLine("The following exception occured: " + e.Message);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\FakeNotificationGenerator\FakeNotificationGenerator\Form1.cs ===
﻿using System;
using System.Windows.Forms;
using Test.Common.Library.FakeNotificationsLib;

namespace Test.Common.Utilities.FakeNotificationGenerator
{
    public partial class Form1 : Form
    {
        public Form1()
        {
            InitializeComponent();
                       
        }

        private void Form1_Load(object sender, EventArgs e)
        {
            cmboxNotification.SelectedIndex = 0;
            cmboxPlatform.SelectedIndex = 3;
        }

      
        private void btnCreate_Click(object sender, EventArgs e)
        {
          
            Notifications objNotification = new Notifications();

            //Assigning the default values to few variables.
            uint GameID = 7777;
            uint GameVarient = 100;
            string SessionId = string.Empty;
            
            //Verify XUID and From fields.
            if (txtXuid.Text.Trim() == "" || txtFrom.Text.Trim() == "")
            {
                MessageBox.Show("Please make sure XUID and From fields should not be empty.");
                return;
            }
            else
            {
                if (txtGameID.Text.Trim() != "")
                {
                    GameID = Convert.ToUInt32(txtGameID.Text.Trim());
                }
                if (txtGameVarient.Text.Trim() != "")
                {
                    GameVarient = Convert.ToUInt32(txtGameVarient.Text.Trim());
                }
                if (txtSessionId.Text.Trim() != "")
                {
                    SessionId = txtSessionId.Text.Trim();
                }

                switch (cmboxNotification.SelectedIndex)
                {
                    case 0:
                        objNotification.CreateNotification(Notifications.NotificationType.Invitation, txtXuid.Text, txtFrom.Text, Convert.ToInt32(cmboxPlatform.SelectedItem.ToString()), GameID, GameVarient, SessionId);
                        break;
                    case 1:
                        objNotification.CreateNotification(Notifications.NotificationType.GameOver, txtXuid.Text, txtFrom.Text, Convert.ToInt32(cmboxPlatform.SelectedItem.ToString()), GameID, GameVarient, SessionId);
                        break;
                    case 2:
                        objNotification.CreateNotification(Notifications.NotificationType.GameTie, txtXuid.Text, txtFrom.Text, Convert.ToInt32(cmboxPlatform.SelectedItem.ToString()), GameID, GameVarient, SessionId);
                        break;
                    case 3:
                        objNotification.CreateNotification(Notifications.NotificationType.MessageWaiting, txtXuid.Text, txtFrom.Text, Convert.ToInt32(cmboxPlatform.SelectedItem.ToString()), GameID, GameVarient, SessionId);
                        break;
                    case 4:
                        objNotification.CreateNotification(Notifications.NotificationType.Nudge, txtXuid.Text, txtFrom.Text, Convert.ToInt32(cmboxPlatform.SelectedItem.ToString()), GameID, GameVarient, SessionId);
                        break;
                    case 5:
                        objNotification.CreateNotification(Notifications.NotificationType.Warning, txtXuid.Text, txtFrom.Text, Convert.ToInt32(cmboxPlatform.SelectedItem.ToString()), GameID, GameVarient, SessionId);
                        break;
                    case 6:
                        objNotification.CreateNotification(Notifications.NotificationType.YouLose, txtXuid.Text, txtFrom.Text, Convert.ToInt32(cmboxPlatform.SelectedItem.ToString()), GameID, GameVarient, SessionId);
                        break;
                    case 7:
                        objNotification.CreateNotification(Notifications.NotificationType.YourTurn, txtXuid.Text, txtFrom.Text, Convert.ToInt32(cmboxPlatform.SelectedItem.ToString()), GameID, GameVarient, SessionId);
                        break;
                    case 8:
                        objNotification.CreateNotification(Notifications.NotificationType.YouWin, txtXuid.Text, txtFrom.Text, Convert.ToInt32(cmboxPlatform.SelectedItem.ToString()), GameID, GameVarient, SessionId);
                        break;
                    default:
                        break;
                }

            }

            txtResult.Text = "Notification with SessionID (GUID): " + objNotification.GUID + " NotificationID: " + objNotification.NotificationID + " has been created for the user with  XUID: " + txtXuid.Text + "  from user: " + txtFrom.Text + " .";
            MessageBox.Show("Notification has been created. Please find the details about the Notification in the Textbox below.");
            
        }

        private void btnDeleteNotification_Click(object sender, EventArgs e)
        {
            if (txtXuid.Text.Trim() == "")
            {
                MessageBox.Show("Please make sure XUID field should not be empty. It is mandatory to delete the notifications.");
                return;
            }

            Notifications objNotification = new Notifications();
            objNotification.DeleteNotificaiton(txtXuid.Text.Trim());
            txtResult.Text = "All the Notifications for the user with XUID: " + txtXuid.Text.Trim() + "  has been deleted.";
            MessageBox.Show("All the Notifications for the user has been deleted. Please find the details in the Textbox below.");
            
        }

       
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\FakeNotificationGenerator\FakeNotificationGenerator\Form1.Designer.cs ===
﻿namespace Test.Common.Utilities.FakeNotificationGenerator
{
    partial class Form1
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.lblXuid = new System.Windows.Forms.Label();
            this.txtXuid = new System.Windows.Forms.TextBox();
            this.btnCreate = new System.Windows.Forms.Button();
            this.txtFrom = new System.Windows.Forms.TextBox();
            this.lblFrom = new System.Windows.Forms.Label();
            this.lblNotificationType = new System.Windows.Forms.Label();
            this.cmboxNotification = new System.Windows.Forms.ComboBox();
            this.label1 = new System.Windows.Forms.Label();
            this.cmboxPlatform = new System.Windows.Forms.ComboBox();
            this.lblGameID = new System.Windows.Forms.Label();
            this.txtGameID = new System.Windows.Forms.TextBox();
            this.lblGameVarient = new System.Windows.Forms.Label();
            this.txtGameVarient = new System.Windows.Forms.TextBox();
            this.btnDeleteNotification = new System.Windows.Forms.Button();
            this.txtResult = new System.Windows.Forms.TextBox();
            this.lblSessionId = new System.Windows.Forms.Label();
            this.txtSessionId = new System.Windows.Forms.TextBox();
            this.SuspendLayout();
            // 
            // lblXuid
            // 
            this.lblXuid.AutoSize = true;
            this.lblXuid.Location = new System.Drawing.Point(56, 59);
            this.lblXuid.Name = "lblXuid";
            this.lblXuid.Size = new System.Drawing.Size(33, 13);
            this.lblXuid.TabIndex = 0;
            this.lblXuid.Text = "XUID";
            // 
            // txtXuid
            // 
            this.txtXuid.Location = new System.Drawing.Point(203, 51);
            this.txtXuid.Name = "txtXuid";
            this.txtXuid.Size = new System.Drawing.Size(100, 20);
            this.txtXuid.TabIndex = 1;
            // 
            // btnCreate
            // 
            this.btnCreate.Location = new System.Drawing.Point(203, 236);
            this.btnCreate.Name = "btnCreate";
            this.btnCreate.Size = new System.Drawing.Size(113, 23);
            this.btnCreate.TabIndex = 2;
            this.btnCreate.Text = "Create Notification";
            this.btnCreate.UseVisualStyleBackColor = true;
            this.btnCreate.Click += new System.EventHandler(this.btnCreate_Click);
            // 
            // txtFrom
            // 
            this.txtFrom.Location = new System.Drawing.Point(203, 90);
            this.txtFrom.Name = "txtFrom";
            this.txtFrom.Size = new System.Drawing.Size(100, 20);
            this.txtFrom.TabIndex = 3;
            // 
            // lblFrom
            // 
            this.lblFrom.AutoSize = true;
            this.lblFrom.Location = new System.Drawing.Point(59, 93);
            this.lblFrom.Name = "lblFrom";
            this.lblFrom.Size = new System.Drawing.Size(30, 13);
            this.lblFrom.TabIndex = 4;
            this.lblFrom.Text = "From";
            // 
            // lblNotificationType
            // 
            this.lblNotificationType.AutoSize = true;
            this.lblNotificationType.Location = new System.Drawing.Point(338, 51);
            this.lblNotificationType.Name = "lblNotificationType";
            this.lblNotificationType.Size = new System.Drawing.Size(87, 13);
            this.lblNotificationType.TabIndex = 5;
            this.lblNotificationType.Text = "Notification Type";
            // 
            // cmboxNotification
            // 
            this.cmboxNotification.FormattingEnabled = true;
            this.cmboxNotification.Items.AddRange(new object[] {
            "Invitation",
            "GameOver",
            "GameTie",
            "MessageWaiting",
            "Nudge",
            "Warning",
            "YouLose",
            "YourTurn",
            "YouWin"});
            this.cmboxNotification.Location = new System.Drawing.Point(464, 51);
            this.cmboxNotification.Name = "cmboxNotification";
            this.cmboxNotification.Size = new System.Drawing.Size(121, 21);
            this.cmboxNotification.TabIndex = 6;
            // 
            // label1
            // 
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(341, 92);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(45, 13);
            this.label1.TabIndex = 7;
            this.label1.Text = "Platform";
            // 
            // cmboxPlatform
            // 
            this.cmboxPlatform.FormattingEnabled = true;
            this.cmboxPlatform.Items.AddRange(new object[] {
            "1",
            "2",
            "4",
            "6"});
            this.cmboxPlatform.Location = new System.Drawing.Point(464, 88);
            this.cmboxPlatform.Name = "cmboxPlatform";
            this.cmboxPlatform.Size = new System.Drawing.Size(121, 21);
            this.cmboxPlatform.TabIndex = 8;
            // 
            // lblGameID
            // 
            this.lblGameID.AutoSize = true;
            this.lblGameID.Location = new System.Drawing.Point(62, 131);
            this.lblGameID.Name = "lblGameID";
            this.lblGameID.Size = new System.Drawing.Size(49, 13);
            this.lblGameID.TabIndex = 9;
            this.lblGameID.Text = "Game ID";
            // 
            // txtGameID
            // 
            this.txtGameID.Location = new System.Drawing.Point(203, 131);
            this.txtGameID.Name = "txtGameID";
            this.txtGameID.Size = new System.Drawing.Size(100, 20);
            this.txtGameID.TabIndex = 10;
            // 
            // lblGameVarient
            // 
            this.lblGameVarient.AutoSize = true;
            this.lblGameVarient.Location = new System.Drawing.Point(344, 131);
            this.lblGameVarient.Name = "lblGameVarient";
            this.lblGameVarient.Size = new System.Drawing.Size(71, 13);
            this.lblGameVarient.TabIndex = 11;
            this.lblGameVarient.Text = "Game Varient";
            // 
            // txtGameVarient
            // 
            this.txtGameVarient.Location = new System.Drawing.Point(464, 130);
            this.txtGameVarient.Name = "txtGameVarient";
            this.txtGameVarient.Size = new System.Drawing.Size(121, 20);
            this.txtGameVarient.TabIndex = 12;
            // 
            // btnDeleteNotification
            // 
            this.btnDeleteNotification.Location = new System.Drawing.Point(464, 236);
            this.btnDeleteNotification.Name = "btnDeleteNotification";
            this.btnDeleteNotification.Size = new System.Drawing.Size(121, 23);
            this.btnDeleteNotification.TabIndex = 13;
            this.btnDeleteNotification.Text = "Delete Notification";
            this.btnDeleteNotification.UseVisualStyleBackColor = true;
            this.btnDeleteNotification.Click += new System.EventHandler(this.btnDeleteNotification_Click);
            // 
            // txtResult
            // 
            this.txtResult.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.txtResult.ForeColor = System.Drawing.Color.FromArgb(((int)(((byte)(0)))), ((int)(((byte)(0)))), ((int)(((byte)(192)))));
            this.txtResult.Location = new System.Drawing.Point(203, 297);
            this.txtResult.Multiline = true;
            this.txtResult.Name = "txtResult";
            this.txtResult.ReadOnly = true;
            this.txtResult.Size = new System.Drawing.Size(382, 78);
            this.txtResult.TabIndex = 14;
            // 
            // lblSessionId
            // 
            this.lblSessionId.AutoSize = true;
            this.lblSessionId.Location = new System.Drawing.Point(59, 175);
            this.lblSessionId.Name = "lblSessionId";
            this.lblSessionId.Size = new System.Drawing.Size(55, 13);
            this.lblSessionId.TabIndex = 15;
            this.lblSessionId.Text = "SessionID";
            // 
            // txtSessionId
            // 
            this.txtSessionId.Location = new System.Drawing.Point(203, 175);
            this.txtSessionId.Name = "txtSessionId";
            this.txtSessionId.Size = new System.Drawing.Size(100, 20);
            this.txtSessionId.TabIndex = 16;
            // 
            // Form1
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(822, 429);
            this.Controls.Add(this.txtSessionId);
            this.Controls.Add(this.lblSessionId);
            this.Controls.Add(this.txtResult);
            this.Controls.Add(this.btnDeleteNotification);
            this.Controls.Add(this.txtGameVarient);
            this.Controls.Add(this.lblGameVarient);
            this.Controls.Add(this.txtGameID);
            this.Controls.Add(this.lblGameID);
            this.Controls.Add(this.cmboxPlatform);
            this.Controls.Add(this.label1);
            this.Controls.Add(this.cmboxNotification);
            this.Controls.Add(this.lblNotificationType);
            this.Controls.Add(this.lblFrom);
            this.Controls.Add(this.txtFrom);
            this.Controls.Add(this.btnCreate);
            this.Controls.Add(this.txtXuid);
            this.Controls.Add(this.lblXuid);
            this.Name = "Form1";
            this.Text = "Form1";
            this.Load += new System.EventHandler(this.Form1_Load);
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.Label lblXuid;
        private System.Windows.Forms.TextBox txtXuid;
        private System.Windows.Forms.Button btnCreate;
        private System.Windows.Forms.TextBox txtFrom;
        private System.Windows.Forms.Label lblFrom;
        private System.Windows.Forms.Label lblNotificationType;
        private System.Windows.Forms.ComboBox cmboxNotification;
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.ComboBox cmboxPlatform;
        private System.Windows.Forms.Label lblGameID;
        private System.Windows.Forms.TextBox txtGameID;
        private System.Windows.Forms.Label lblGameVarient;
        private System.Windows.Forms.TextBox txtGameVarient;
        private System.Windows.Forms.Button btnDeleteNotification;
        private System.Windows.Forms.TextBox txtResult;
        private System.Windows.Forms.Label lblSessionId;
        private System.Windows.Forms.TextBox txtSessionId;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\FakeNotificationGenerator\FakeNotificationGenerator\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("FakeNotificationGenerator")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("Microsoft Corp.")]
//[assembly: AssemblyProduct("FakeNotificationGenerator")]
//[assembly: AssemblyCopyright("Copyright © Microsoft Corp. 2009")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("6e8f2ebd-a6a5-4db7-b51d-74ece9e80206")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
//[assembly: AssemblyVersion("1.0.0.0")]
//[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\FakeNotificationsMaker\FakeNotificationsMaker\App.xaml.cs ===
﻿using System;
using System.Collections.Generic;
using System.Configuration;
using System.Data;
using System.Linq;
using System.Windows;

namespace FakeNotificationsMaker
{
    /// <summary>
    /// Interaction logic for App.xaml
    /// </summary>
    public partial class App : Application
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\FakeNotificationGenerator\FakeNotificationGenerator\Program.cs ===
﻿using System;
using System.Windows.Forms;

namespace Test.Common.Utilities.FakeNotificationGenerator
{
    static class Program
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new Form1());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\FakeNotificationGenerator\FakeNotificationGenerator\Properties\Settings.Designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Test.Common.Utilities.FakeNotificationGenerator.Properties {
    
    
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "9.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {
        
        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
        
        public static Settings Default {
            get {
                return defaultInstance;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\FakeNotificationGenerator\FakeNotificationGenerator\Properties\Resources.Designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Test.Common.Utilities.FakeNotificationGenerator.Properties {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "2.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Test.Common.Utilities.FakeNotificationGenerator.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\IISLogAnalyzer\IISLogAnalyzerDaemon\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\FakeNotificationsMaker\FakeNotificationsMaker\obj\Debug\App.g.cs ===
﻿#pragma checksum "..\..\App.xaml" "{406ea660-64cf-4c82-b6f0-42d48172a799}" "17CF2E557FA858997C41E66D050EF1A8"
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Windows;
using System.Windows.Automation;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Ink;
using System.Windows.Input;
using System.Windows.Markup;
using System.Windows.Media;
using System.Windows.Media.Animation;
using System.Windows.Media.Effects;
using System.Windows.Media.Imaging;
using System.Windows.Media.Media3D;
using System.Windows.Media.TextFormatting;
using System.Windows.Navigation;
using System.Windows.Shapes;


namespace FakeNotificationsMaker {
    
    
    /// <summary>
    /// App
    /// </summary>
    public partial class App : System.Windows.Application {
        
        /// <summary>
        /// InitializeComponent
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public void InitializeComponent() {
            
            #line 4 "..\..\App.xaml"
            this.StartupUri = new System.Uri("Window1.xaml", System.UriKind.Relative);
            
            #line default
            #line hidden
        }
        
        /// <summary>
        /// Application Entry Point.
        /// </summary>
        [System.STAThreadAttribute()]
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public static void Main() {
            FakeNotificationsMaker.App app = new FakeNotificationsMaker.App();
            app.InitializeComponent();
            app.Run();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\FakeNotificationsMaker\FakeNotificationsMaker\obj\Debug\Window1.g.cs ===
﻿#pragma checksum "..\..\Window1.xaml" "{406ea660-64cf-4c82-b6f0-42d48172a799}" "2275D7BF87A86B65882C5DD60B6E5777"
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Windows;
using System.Windows.Automation;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Ink;
using System.Windows.Input;
using System.Windows.Markup;
using System.Windows.Media;
using System.Windows.Media.Animation;
using System.Windows.Media.Effects;
using System.Windows.Media.Imaging;
using System.Windows.Media.Media3D;
using System.Windows.Media.TextFormatting;
using System.Windows.Navigation;
using System.Windows.Shapes;


namespace FakeNotificationsMaker {
    
    
    /// <summary>
    /// Window1
    /// </summary>
    public partial class Window1 : System.Windows.Window, System.Windows.Markup.IComponentConnector {
        
        
        #line 6 "..\..\Window1.xaml"
        internal System.Windows.Controls.TextBox txtXuid;
        
        #line default
        #line hidden
        
        
        #line 7 "..\..\Window1.xaml"
        internal System.Windows.Controls.Label label1;
        
        #line default
        #line hidden
        
        
        #line 11 "..\..\Window1.xaml"
        internal System.Windows.Controls.ComboBox combStatus;
        
        #line default
        #line hidden
        
        
        #line 14 "..\..\Window1.xaml"
        internal System.Windows.Controls.ComboBoxItem mem1;
        
        #line default
        #line hidden
        
        
        #line 15 "..\..\Window1.xaml"
        internal System.Windows.Controls.ComboBoxItem mem2;
        
        #line default
        #line hidden
        
        
        #line 18 "..\..\Window1.xaml"
        internal System.Windows.Controls.ComboBox comType;
        
        #line default
        #line hidden
        
        
        #line 19 "..\..\Window1.xaml"
        internal System.Windows.Controls.ComboBoxItem comboBoxItem44;
        
        #line default
        #line hidden
        
        
        #line 20 "..\..\Window1.xaml"
        internal System.Windows.Controls.ComboBoxItem comboBoxItem55;
        
        #line default
        #line hidden
        
        
        #line 21 "..\..\Window1.xaml"
        internal System.Windows.Controls.ComboBoxItem comboBoxItem66;
        
        #line default
        #line hidden
        
        
        #line 22 "..\..\Window1.xaml"
        internal System.Windows.Controls.ComboBoxItem comboBoxItem42;
        
        #line default
        #line hidden
        
        
        #line 23 "..\..\Window1.xaml"
        internal System.Windows.Controls.ComboBoxItem comboBoxItem53;
        
        #line default
        #line hidden
        
        
        #line 24 "..\..\Window1.xaml"
        internal System.Windows.Controls.ComboBoxItem comboBoxItem61;
        
        #line default
        #line hidden
        
        
        #line 25 "..\..\Window1.xaml"
        internal System.Windows.Controls.ComboBoxItem comboBoxItem47;
        
        #line default
        #line hidden
        
        
        #line 26 "..\..\Window1.xaml"
        internal System.Windows.Controls.ComboBoxItem comboBoxItem51;
        
        #line default
        #line hidden
        
        
        #line 27 "..\..\Window1.xaml"
        internal System.Windows.Controls.ComboBoxItem comboBoxItem62;
        
        #line default
        #line hidden
        
        
        #line 28 "..\..\Window1.xaml"
        internal System.Windows.Controls.ComboBoxItem comboBoxItem41;
        
        #line default
        #line hidden
        
        
        #line 29 "..\..\Window1.xaml"
        internal System.Windows.Controls.ComboBoxItem comboBoxItem54;
        
        #line default
        #line hidden
        
        
        #line 30 "..\..\Window1.xaml"
        internal System.Windows.Controls.ComboBoxItem comboBoxItem67;
        
        #line default
        #line hidden
        
        
        #line 31 "..\..\Window1.xaml"
        internal System.Windows.Controls.ComboBoxItem comboBoxItem40;
        
        #line default
        #line hidden
        
        
        #line 32 "..\..\Window1.xaml"
        internal System.Windows.Controls.ComboBoxItem comboBoxItem58;
        
        #line default
        #line hidden
        
        
        #line 33 "..\..\Window1.xaml"
        internal System.Windows.Controls.ComboBoxItem comboBoxItem60;
        
        #line default
        #line hidden
        
        
        #line 34 "..\..\Window1.xaml"
        internal System.Windows.Controls.ComboBoxItem comboBoxItem49;
        
        #line default
        #line hidden
        
        
        #line 35 "..\..\Window1.xaml"
        internal System.Windows.Controls.ComboBoxItem comboBoxItem59;
        
        #line default
        #line hidden
        
        
        #line 38 "..\..\Window1.xaml"
        internal System.Windows.Controls.ComboBox combGameid;
        
        #line default
        #line hidden
        
        
        #line 39 "..\..\Window1.xaml"
        internal System.Windows.Controls.ComboBoxItem comboBoxItem7;
        
        #line default
        #line hidden
        
        
        #line 40 "..\..\Window1.xaml"
        internal System.Windows.Controls.ComboBoxItem comboBoxItem8;
        
        #line default
        #line hidden
        
        
        #line 41 "..\..\Window1.xaml"
        internal System.Windows.Controls.ComboBoxItem comboBoxItem9;
        
        #line default
        #line hidden
        
        
        #line 42 "..\..\Window1.xaml"
        internal System.Windows.Controls.ComboBoxItem comboBoxItem10;
        
        #line default
        #line hidden
        
        
        #line 43 "..\..\Window1.xaml"
        internal System.Windows.Controls.ComboBoxItem comboBoxItem11;
        
        #line default
        #line hidden
        
        
        #line 44 "..\..\Window1.xaml"
        internal System.Windows.Controls.ComboBoxItem comboBoxItem12;
        
        #line default
        #line hidden
        
        
        #line 45 "..\..\Window1.xaml"
        internal System.Windows.Controls.ComboBoxItem comboBoxItem13;
        
        #line default
        #line hidden
        
        
        #line 46 "..\..\Window1.xaml"
        internal System.Windows.Controls.ComboBoxItem comboBoxItem14;
        
        #line default
        #line hidden
        
        
        #line 48 "..\..\Window1.xaml"
        internal System.Windows.Controls.Label label2;
        
        #line default
        #line hidden
        
        
        #line 49 "..\..\Window1.xaml"
        internal System.Windows.Controls.Label label3;
        
        #line default
        #line hidden
        
        
        #line 50 "..\..\Window1.xaml"
        internal System.Windows.Controls.Label label4;
        
        #line default
        #line hidden
        
        
        #line 51 "..\..\Window1.xaml"
        internal System.Windows.Controls.Label label5;
        
        #line default
        #line hidden
        
        
        #line 52 "..\..\Window1.xaml"
        internal System.Windows.Controls.Button btnReceive;
        
        #line default
        #line hidden
        
        
        #line 53 "..\..\Window1.xaml"
        internal System.Windows.Controls.Label label6;
        
        #line default
        #line hidden
        
        
        #line 54 "..\..\Window1.xaml"
        internal System.Windows.Controls.ComboBox comEnv;
        
        #line default
        #line hidden
        
        
        #line 55 "..\..\Window1.xaml"
        internal System.Windows.Controls.ComboBoxItem comboBoxItem15;
        
        #line default
        #line hidden
        
        
        #line 56 "..\..\Window1.xaml"
        internal System.Windows.Controls.ComboBoxItem comboBoxItem16;
        
        #line default
        #line hidden
        
        
        #line 59 "..\..\Window1.xaml"
        internal System.Windows.Controls.ListBox listBox1;
        
        #line default
        #line hidden
        
        
        #line 60 "..\..\Window1.xaml"
        internal System.Windows.Controls.Button btnDel;
        
        #line default
        #line hidden
        
        
        #line 62 "..\..\Window1.xaml"
        internal System.Windows.Controls.ComboBox comNo_no;
        
        #line default
        #line hidden
        
        
        #line 63 "..\..\Window1.xaml"
        internal System.Windows.Controls.ComboBoxItem comboBoxItema;
        
        #line default
        #line hidden
        
        
        #line 64 "..\..\Window1.xaml"
        internal System.Windows.Controls.ComboBoxItem comboBoxItemb;
        
        #line default
        #line hidden
        
        
        #line 65 "..\..\Window1.xaml"
        internal System.Windows.Controls.ComboBoxItem comboBoxItemc;
        
        #line default
        #line hidden
        
        
        #line 66 "..\..\Window1.xaml"
        internal System.Windows.Controls.ComboBoxItem comboBoxItemd;
        
        #line default
        #line hidden
        
        
        #line 67 "..\..\Window1.xaml"
        internal System.Windows.Controls.ComboBoxItem comboBoxIteme;
        
        #line default
        #line hidden
        
        
        #line 68 "..\..\Window1.xaml"
        internal System.Windows.Controls.ComboBoxItem comboBoxItemf;
        
        #line default
        #line hidden
        
        
        #line 69 "..\..\Window1.xaml"
        internal System.Windows.Controls.ComboBoxItem comboBoxItem1g;
        
        #line default
        #line hidden
        
        
        #line 70 "..\..\Window1.xaml"
        internal System.Windows.Controls.ComboBoxItem comboBoxItem18h;
        
        #line default
        #line hidden
        
        
        #line 71 "..\..\Window1.xaml"
        internal System.Windows.Controls.ComboBoxItem comboBoxItem17i;
        
        #line default
        #line hidden
        
        
        #line 72 "..\..\Window1.xaml"
        internal System.Windows.Controls.ComboBoxItem comboBoxItem18j;
        
        #line default
        #line hidden
        
        
        #line 74 "..\..\Window1.xaml"
        internal System.Windows.Controls.Button btnClose;
        
        #line default
        #line hidden
        
        private bool _contentLoaded;
        
        /// <summary>
        /// InitializeComponent
        /// </summary>
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public void InitializeComponent() {
            if (_contentLoaded) {
                return;
            }
            _contentLoaded = true;
            System.Uri resourceLocater = new System.Uri("/FakeNotificationsMaker;component/window1.xaml", System.UriKind.Relative);
            
            #line 1 "..\..\Window1.xaml"
            System.Windows.Application.LoadComponent(this, resourceLocater);
            
            #line default
            #line hidden
        }
        
        [System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Design", "CA1033:InterfaceMethodsShouldBeCallableByChildTypes")]
        void System.Windows.Markup.IComponentConnector.Connect(int connectionId, object target) {
            switch (connectionId)
            {
            case 1:
            
            #line 4 "..\..\Window1.xaml"
            ((FakeNotificationsMaker.Window1)(target)).Loaded += new System.Windows.RoutedEventHandler(this.Window_Loaded);
            
            #line default
            #line hidden
            return;
            case 2:
            this.txtXuid = ((System.Windows.Controls.TextBox)(target));
            return;
            case 3:
            this.label1 = ((System.Windows.Controls.Label)(target));
            return;
            case 4:
            this.combStatus = ((System.Windows.Controls.ComboBox)(target));
            return;
            case 5:
            this.mem1 = ((System.Windows.Controls.ComboBoxItem)(target));
            return;
            case 6:
            this.mem2 = ((System.Windows.Controls.ComboBoxItem)(target));
            return;
            case 7:
            this.comType = ((System.Windows.Controls.ComboBox)(target));
            return;
            case 8:
            this.comboBoxItem44 = ((System.Windows.Controls.ComboBoxItem)(target));
            return;
            case 9:
            this.comboBoxItem55 = ((System.Windows.Controls.ComboBoxItem)(target));
            return;
            case 10:
            this.comboBoxItem66 = ((System.Windows.Controls.ComboBoxItem)(target));
            return;
            case 11:
            this.comboBoxItem42 = ((System.Windows.Controls.ComboBoxItem)(target));
            return;
            case 12:
            this.comboBoxItem53 = ((System.Windows.Controls.ComboBoxItem)(target));
            return;
            case 13:
            this.comboBoxItem61 = ((System.Windows.Controls.ComboBoxItem)(target));
            return;
            case 14:
            this.comboBoxItem47 = ((System.Windows.Controls.ComboBoxItem)(target));
            return;
            case 15:
            this.comboBoxItem51 = ((System.Windows.Controls.ComboBoxItem)(target));
            return;
            case 16:
            this.comboBoxItem62 = ((System.Windows.Controls.ComboBoxItem)(target));
            return;
            case 17:
            this.comboBoxItem41 = ((System.Windows.Controls.ComboBoxItem)(target));
            return;
            case 18:
            this.comboBoxItem54 = ((System.Windows.Controls.ComboBoxItem)(target));
            return;
            case 19:
            this.comboBoxItem67 = ((System.Windows.Controls.ComboBoxItem)(target));
            return;
            case 20:
            this.comboBoxItem40 = ((System.Windows.Controls.ComboBoxItem)(target));
            return;
            case 21:
            this.comboBoxItem58 = ((System.Windows.Controls.ComboBoxItem)(target));
            return;
            case 22:
            this.comboBoxItem60 = ((System.Windows.Controls.ComboBoxItem)(target));
            return;
            case 23:
            this.comboBoxItem49 = ((System.Windows.Controls.ComboBoxItem)(target));
            return;
            case 24:
            this.comboBoxItem59 = ((System.Windows.Controls.ComboBoxItem)(target));
            return;
            case 25:
            this.combGameid = ((System.Windows.Controls.ComboBox)(target));
            return;
            case 26:
            this.comboBoxItem7 = ((System.Windows.Controls.ComboBoxItem)(target));
            return;
            case 27:
            this.comboBoxItem8 = ((System.Windows.Controls.ComboBoxItem)(target));
            return;
            case 28:
            this.comboBoxItem9 = ((System.Windows.Controls.ComboBoxItem)(target));
            return;
            case 29:
            this.comboBoxItem10 = ((System.Windows.Controls.ComboBoxItem)(target));
            return;
            case 30:
            this.comboBoxItem11 = ((System.Windows.Controls.ComboBoxItem)(target));
            return;
            case 31:
            this.comboBoxItem12 = ((System.Windows.Controls.ComboBoxItem)(target));
            return;
            case 32:
            this.comboBoxItem13 = ((System.Windows.Controls.ComboBoxItem)(target));
            return;
            case 33:
            this.comboBoxItem14 = ((System.Windows.Controls.ComboBoxItem)(target));
            return;
            case 34:
            this.label2 = ((System.Windows.Controls.Label)(target));
            return;
            case 35:
            this.label3 = ((System.Windows.Controls.Label)(target));
            return;
            case 36:
            this.label4 = ((System.Windows.Controls.Label)(target));
            return;
            case 37:
            this.label5 = ((System.Windows.Controls.Label)(target));
            return;
            case 38:
            this.btnReceive = ((System.Windows.Controls.Button)(target));
            
            #line 52 "..\..\Window1.xaml"
            this.btnReceive.Click += new System.Windows.RoutedEventHandler(this.btnReceive_Click);
            
            #line default
            #line hidden
            return;
            case 39:
            this.label6 = ((System.Windows.Controls.Label)(target));
            return;
            case 40:
            this.comEnv = ((System.Windows.Controls.ComboBox)(target));
            return;
            case 41:
            this.comboBoxItem15 = ((System.Windows.Controls.ComboBoxItem)(target));
            return;
            case 42:
            this.comboBoxItem16 = ((System.Windows.Controls.ComboBoxItem)(target));
            return;
            case 43:
            this.listBox1 = ((System.Windows.Controls.ListBox)(target));
            return;
            case 44:
            this.btnDel = ((System.Windows.Controls.Button)(target));
            
            #line 60 "..\..\Window1.xaml"
            this.btnDel.Click += new System.Windows.RoutedEventHandler(this.btnDel_Click);
            
            #line default
            #line hidden
            return;
            case 45:
            this.comNo_no = ((System.Windows.Controls.ComboBox)(target));
            return;
            case 46:
            this.comboBoxItema = ((System.Windows.Controls.ComboBoxItem)(target));
            return;
            case 47:
            this.comboBoxItemb = ((System.Windows.Controls.ComboBoxItem)(target));
            return;
            case 48:
            this.comboBoxItemc = ((System.Windows.Controls.ComboBoxItem)(target));
            return;
            case 49:
            this.comboBoxItemd = ((System.Windows.Controls.ComboBoxItem)(target));
            return;
            case 50:
            this.comboBoxIteme = ((System.Windows.Controls.ComboBoxItem)(target));
            return;
            case 51:
            this.comboBoxItemf = ((System.Windows.Controls.ComboBoxItem)(target));
            return;
            case 52:
            this.comboBoxItem1g = ((System.Windows.Controls.ComboBoxItem)(target));
            return;
            case 53:
            this.comboBoxItem18h = ((System.Windows.Controls.ComboBoxItem)(target));
            return;
            case 54:
            this.comboBoxItem17i = ((System.Windows.Controls.ComboBoxItem)(target));
            return;
            case 55:
            this.comboBoxItem18j = ((System.Windows.Controls.ComboBoxItem)(target));
            return;
            case 56:
            this.btnClose = ((System.Windows.Controls.Button)(target));
            
            #line 74 "..\..\Window1.xaml"
            this.btnClose.Click += new System.Windows.RoutedEventHandler(this.btnClose_Click);
            
            #line default
            #line hidden
            return;
            }
            this._contentLoaded = true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\FakeNotificationsMaker\FakeNotificationsMaker\Window1.xaml.cs ===
﻿using System;
using System.Collections.Generic;
using System.Windows;
using System.Windows.Documents;
using Test.Common.Library;
using AsyncMultiplayer.NotificationService;
using System.Threading;

namespace FakeNotificationsMaker
{
    /// <summary>
    /// Interaction logic for Window1.xaml
    /// </summary>
    public partial class Window1 : Window
    {
        FakeNotification fakeNote = null;
        string xuid = string.Empty;

        public Window1()
        {
            InitializeComponent();
        }

        // This button to call GetNotifications method
        private void btnReceive_Click(object sender, RoutedEventArgs e)
        {
            // Disble the buton after the user click it
            btnReceive.IsEnabled = false;

            // Call GetNotification method
            GetNotification();

            // Enable the buton after the method call
            btnReceive.IsEnabled = true; ;
        }

        // This this method calls the remote methods Send,Receive and display the notification in a listbox
        public void GetNotification()
        {
            // Declaring a list to assin to the listbox which display notifications
            List<string> sb = new List<string>();

            // Get the environment value from the combo box
            FakeNotification.Environment env = (FakeNotification.Environment)comEnv.SelectionBoxItem;

            // intialize an instance  of FakeNotification
            fakeNote = new FakeNotification(env);

            // Getting the values from the UI
            FakeNotification.GameId gameId = (FakeNotification.GameId)combGameid.SelectionBoxItem;
            Notification.NotificationStatus nStatus = (Notification.NotificationStatus)combStatus.SelectionBoxItem;
            Notification.NotificationType nType = (Notification.NotificationType)comType.SelectionBoxItem;
            int howmany = (int)comNo_no.SelectionBoxItem;
            xuid = txtXuid.Text;
            string xuidValue = IntializeXuid(xuid);
            try
            {
                if (xuidValue != "")
                {
                    fakeNote.Send(nType, xuidValue, howmany, nStatus, gameId);
                    NotificationList notifications = fakeNote.Receive(xuidValue, howmany);
                    sb = fakeNote.Display(notifications);
                    listBox1.ItemsSource = sb;
                }
            }
            catch (Exception ex)
            {
                sb.Add(ex.Message.ToString());
                listBox1.ItemsSource = sb;
            }
        }

        // This method calls the remote methods Delete which delete all the notification
        public void DeleteAllNotification()
        {
            // Get the environment value from the combo box
            FakeNotification.Environment env = (FakeNotification.Environment)comEnv.SelectionBoxItem;

            // intialize an instance  of FakeNotification
            fakeNote = new FakeNotification(env);
            listBox1.ItemsSource = null;
            xuid = txtXuid.Text;
            if (xuid != "")
            {
                fakeNote.Delete(xuid);
            }
        }

        // This method checks xuid field has a valid value
        public string IntializeXuid(string xuid)
        {
            if (xuid == "" || xuid == null || xuid.Length > 16)
            {
                MessageBox.Show("please enter a valid value for Xuid field");
            }

            return xuid;
        }

        // Selecting the default values for combobox
        private void Window_Loaded(object sender, RoutedEventArgs e)
        {
            this.combStatus.SelectedIndex = 0;
            this.comType.SelectedIndex = 0;
            this.comEnv.SelectedIndex = 0;
            this.combGameid.SelectedIndex = 0;
            this.comNo_no.SelectedIndex = 0;
        }

        // Delete button calls delete method to delete all notifications
        private void btnDel_Click(object sender, RoutedEventArgs e)
        {
            btnDel.IsEnabled = false;
            // Call DeleteAllNotification method
            DeleteAllNotification();

            btnDel.IsEnabled = true;
        }

        // Populate combobox for Notification Type at run time
        private void comType_Loaded(object sender, RoutedEventArgs e)
        {
            foreach (Notification.NotificationType type in Enum.GetValues(typeof(Notification.NotificationType)))
            {
                comType.Items.Add(type);
            }
        }

        // Populate combobox for Notification status at run time
        private void combStatus_Loaded(object sender, EventArgs e)
        {
            foreach (Notification.NotificationStatus status in Enum.GetValues(typeof(Notification.NotificationStatus)))
            {
                combStatus.Items.Add(status);
            }
        }

        // Populate combobox for Notification environment at run time
        private void comEnv__Loaded(object sender, EventArgs e)
        {
            foreach (FakeNotification.Environment env in Enum.GetValues(typeof(FakeNotification.Environment)))
            {
                comEnv.Items.Add(env);
            }
        }

        // Populate combobox for GameId at run time
        private void combGameid__Loaded(object sender, EventArgs e)
        {
            foreach (FakeNotification.GameId game in Enum.GetValues(typeof(FakeNotification.GameId)))
            {
                combGameid.Items.Add(game);
            }
        }

        // Populate combobox for number of Notification  at run time
        private void comNo_Loaded(object sender, EventArgs e)
        {
            for (int i = 1; i < 11; i++)
                comNo_no.Items.Add(i);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\FakeNotificationsMaker\FakeNotificationsMaker\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Resources;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Windows;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("FakeNotificationsMaker")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("FakeNotificationsMaker")]
[assembly: AssemblyCopyright("Copyright © Microsoft 2010")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

//In order to begin building localizable applications, set 
//<UICulture>CultureYouAreCodingWith</UICulture> in your .csproj file
//inside a <PropertyGroup>.  For example, if you are using US english
//in your source files, set the <UICulture> to en-US.  Then uncomment
//the NeutralResourceLanguage attribute below.  Update the "en-US" in
//the line below to match the UICulture setting in the project file.

//[assembly: NeutralResourcesLanguage("en-US", UltimateResourceFallbackLocation.Satellite)]


[assembly: ThemeInfo(
    ResourceDictionaryLocation.None, //where theme specific resource dictionaries are located
    //(used if a resource is not found in the page, 
    // or application resource dictionaries)
    ResourceDictionaryLocation.SourceAssembly //where the generic resource dictionary is located
    //(used if a resource is not found in the page, 
    // app, or any theme specific resource dictionaries)
)]


// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\FakeNotificationsMaker\FakeNotificationsMaker\Properties\Resources.Designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace FakeNotificationsMaker.Properties
{


    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "2.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources
    {

        private static global::System.Resources.ResourceManager resourceMan;

        private static global::System.Globalization.CultureInfo resourceCulture;

        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources()
        {
        }

        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager
        {
            get
            {
                if ((resourceMan == null))
                {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("FakeNotificationsMaker.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }

        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture
        {
            get
            {
                return resourceCulture;
            }
            set
            {
                resourceCulture = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\IISLogAnalyzer\IISLogAnalyzerDaemon\IISLogAnalyzerDaemon\ConfigurationLayer.cs ===
﻿using System;
using System.Configuration;
using System.Text;

namespace Test.Common.Utilities.IISLogAnalyzerDaemon
{
    /// <summary>
    /// Layer to read the various configurations from App.Config
    /// </summary>
    internal class ConfigurationLayer
    {
        private string LogFileLocation;
        private string ProcessingStore;
        private string ImportPackageName;
        private string ProcessPackageName;
        private string ShrinkDatabasePackageName;
        private DateTime LastLogLookupTimeStamp;
        private int ProcessingChunk;
        private bool EventLogOnError;
        private bool EventLogOnEmptyLogQueue;
        private bool SkipLastLogFile;

        /// <summary>
        /// Initialize a new instance of ConfigurationLayer and read in the configuration values.
        /// </summary>
        public ConfigurationLayer()
        {
            //Read App.Config
            try
            {
                LogFileLocation = ConfigurationManager.AppSettings["IISLogFileLocation"];
                ProcessingStore = ConfigurationManager.AppSettings["SSISProcessingStore"];
                ImportPackageName = ConfigurationManager.AppSettings["SSISImportPackageName"];
                ProcessPackageName = ConfigurationManager.AppSettings["SSISProcessPackageName"];
                ShrinkDatabasePackageName = ConfigurationManager.AppSettings["SSISShrinkDatabasePackageName"];
                ProcessingChunk = int.Parse(ConfigurationManager.AppSettings["ProcessingChunk"]);
                EventLogOnError = Convert.ToBoolean(ConfigurationManager.AppSettings["EnableEventLogOnError"]);
                EventLogOnEmptyLogQueue = Convert.ToBoolean(ConfigurationManager.AppSettings["EnableEventLogOnNoAvailableLogs"]);
                SkipLastLogFile = Convert.ToBoolean(ConfigurationManager.AppSettings["SkipLastLogFile"]);

                if (String.IsNullOrEmpty(ConfigurationManager.AppSettings["LastLogLookupTimeStamp"]))
                    LastLogLookupTimeStamp = DateTime.Now;
                else
                    LastLogLookupTimeStamp = DateTime.Parse(ConfigurationManager.AppSettings["LastLogLookupTimeStamp"]);
                
                //Strip off trailing '\' from IIS Log path
                if (LogFileLocation.Substring(LogFileLocation.Length - 1) == "\\")
                    LogFileLocation = LogFileLocation.Substring(0, LogFileLocation.Length - 1);
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// The location containing the IIS Logs to process.
        /// </summary>
        public string IISLogFileLocation
        {
            get { return LogFileLocation; }
        }

        /// <summary>
        /// The location of the SSIS Processing Store.
        /// </summary>
        public string SSISProcessingStore
        {
            get { return ProcessingStore; }
        }

        /// <summary>
        /// Get or set the timestamp of the last IIS Log to be processed.
        /// </summary>
        public DateTime LastLookupTimeStamp
        {
            get { return LastLogLookupTimeStamp; }

            set
            {
                LastLogLookupTimeStamp = value;

                try
                {
                    //Set value in App.Config
                    Configuration AppConfig = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.None);
                    AppConfig.AppSettings.Settings.Remove("LastLogLookupTimeStamp");
                    AppConfig.AppSettings.Settings.Add("LastLogLookupTimeStamp", LastLookupTimeStamp.ToString());

                    //Save App.Config
                    AppConfig.Save(ConfigurationSaveMode.Modified);

                    // Force reload
                    ConfigurationManager.RefreshSection("appSettings");
                }
                catch (Exception)
                {
                    throw;
                }
            }
        }

        /// <summary>
        /// The SSIS Import Package name.
        /// </summary>
        public string SSISImportPackageName
        {
            get { return ImportPackageName; }
        }

        /// <summary>
        /// The SSIS processing Package name.
        /// </summary>
        public string SSISProcessPackageName
        {
            get { return ProcessPackageName; }
        }

        /// <summary>
        /// The SSIS Shrink Database Package name.
        /// </summary>
        public string SSISShrinkDatabasePackageName
        {
            get { return ShrinkDatabasePackageName; }
        }

        /// <summary>
        /// The number of IIS Log files to be processed as a batch.
        /// </summary>
        public int IISLogProcessingChunk
        {
            get { return ProcessingChunk; }
        }

        /// <summary>
        /// Specifies whether to log an event on application error.
        /// </summary>
        public bool LogEventOnError
        {
            get { return EventLogOnError; }
        }

        /// <summary>
        /// Specifies whether to log an event when no logs are found.
        /// </summary>
        public bool LogEventOnEmptyLogQueue
        {
            get { return EventLogOnEmptyLogQueue; }
        }

        /// <summary>
        /// Indicates whether to skip the last IIS log file in the process queue.
        /// Necessary when real time logs are generated in the same share by IIS.
        /// Last file will be locked by IIS, as it is the current log file.
        /// </summary>
        public bool SkipLastLog
        {
            get { return SkipLastLogFile; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\FakeNotificationsMaker\FakeNotificationsMaker\Properties\Settings.Designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace FakeNotificationsMaker.Properties
{


    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "9.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase
    {

        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));

        public static Settings Default
        {
            get
            {
                return defaultInstance;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\LEOCodeCoverageTool\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\IISLogAnalyzer\IISLogAnalyzerDaemon\IISLogAnalyzerDaemon\IISLogFileInteractionLayer.cs ===
﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace Test.Common.Utilities.IISLogAnalyzerDaemon
{
    /// <summary>
    /// A Layer for interacting with the IIS Logs
    /// </summary>
    class IISLogFileInteractionLayer
    {
        private DirectoryInfo IISLogFileLocation;

        /// <summary>
        /// Instantiate a new object of the IISLogFileInteractionLayer
        /// </summary>
        /// <param name="LogLocation">The share containing the IIS Logs.</param>
        public IISLogFileInteractionLayer(string LogLocation)
        {
            try
            {
                IISLogFileLocation = new DirectoryInfo(LogLocation);
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Get a list of IIS Log File names generated after the Start Date, sorted on the specified criteria.
        /// </summary>
        /// <param name="StartTimeStamp">The Start Timestamp</param>
        /// <param name="SortListOn">Indicates the attribute to sort the list on.</param>
        /// <param name="SkipLastFile">Indicates whether to skip the last log in the queue.</param>
        /// <returns>An array of System.String containing the file names of the logs to process.</returns>
        public string[] GetLogFileNames(DateTime StartTimeStamp, CompareAttribute SortListOn, bool SkipLastFile)
        {
            ArrayList LogFileList = new ArrayList();
            ArrayList LogFileNameList = new ArrayList();

            foreach (FileInfo LogFile in IISLogFileLocation.GetFiles("*.log"))
            {
                //Add files having timestamp greater or equal than last access time stamp
                DateTime FileLastAccessTimeStamp = LogFile.LastWriteTime.Date +
                                                   new TimeSpan(LogFile.LastWriteTime.Hour,
                                                                LogFile.LastWriteTime.Minute,
                                                                LogFile.LastWriteTime.Second);          //All this to remove the Milliseconds

                if (DateTime.Compare(FileLastAccessTimeStamp, StartTimeStamp) > 0)
                    LogFileList.Add(LogFile);
            }

            //Sort the FileList
            if (LogFileList.Count > 1)
                Array.Sort((FileInfo[])LogFileList.ToArray(typeof(FileInfo)), new FileInfoComparer(SortListOn));

            foreach (FileInfo LogFile in LogFileList)
                LogFileNameList.Add(LogFile.FullName);

            if (SkipLastFile)
            {
                if (LogFileNameList.Count > 0)
                    LogFileNameList.RemoveAt(LogFileNameList.Count - 1);
            }

            if (LogFileNameList.Count > 0)
                return (string[])LogFileNameList.ToArray(typeof(System.String));
            else
                return null;
        }

        /// <summary>
        /// Copy over the specified IIS Log file to the DTS Processing Store.
        /// </summary>
        /// <param name="LogFile">The IIS Log file to be staged.</param>
        /// <param name="DTSProcessingStore">The path to the DTS Processing Store.</param>
        public void CopyLogFileToDTSProcessingStore(string LogFile, string DTSProcessingStore)
        {
            try
            {
                if (!Directory.Exists(DTSProcessingStore))
                    Directory.CreateDirectory(DTSProcessingStore);

                //Delete the old log file, if it already exists
                if (File.Exists(DTSProcessingStore + "\\IISLog.log"))
                    File.Delete(DTSProcessingStore + "\\IISLog.log");

                //Copy over IIS log for processing
                File.Copy(LogFile, DTSProcessingStore + "\\IISLog.log");
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Get the Last Write Timestamp of the specified IIS Log File.
        /// </summary>
        /// <param name="LogFile">The IIS Log file.</param>
        /// <returns></returns>
        public DateTime GetLogFileTimeStamp(string LogFile)
        {
            FileInfo IISLogFile;
            DateTime LogTimeStamp;

            try
            {
                IISLogFile = new FileInfo(LogFile);
                LogTimeStamp = IISLogFile.LastWriteTime.Date +
                               new TimeSpan(IISLogFile.LastWriteTime.Hour,
                                            IISLogFile.LastWriteTime.Minute,
                                            IISLogFile.LastWriteTime.Second);

                return LogTimeStamp;
            }
            catch (Exception)
            {
                throw;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\IISLogAnalyzer\IISLogAnalyzerDaemon\IISLogAnalyzerDaemon\Daemon.cs ===
﻿using System;
using System.Text;
using System.Reflection;
using System.Diagnostics;

namespace Test.Common.Utilities.IISLogAnalyzerDaemon
{
    public class Daemon
    {
        private static Logger AnalyzerLogger;
        private static IISLogFileInteractionLayer AnalyzerIISLogLayer;
        private static ConfigurationLayer AnalyzerConfig;
        private static SSISExecuterLayer SSISExecuter;

        static void Main(string[] args)
        {
            PrintWelcome();

            #region Declare local objects
            DateTime LastIISLogLookupTimeStamp;                     //The Timestamp of the last IIS Log to be processed
            String[] LogFilesToProcess;                             //The List of IIS Logs to be processed
            String IISLogFileProcessingLocation;                    //The location where the IIS Log will be staged for SSIS
            int LogProcessingBatchSize;                             //The number of IIS Logs which will be processed as a batch
            int CurrentBatchSize;                                   //The current size of the batch
            bool EventLogOnError;                                   //Specifies whether to log an event on application error
            bool EventLogOnEmptyLogQueue;                           //Specifies whether to log an event when no logs are found.
            bool SkipLastLogFile;                                   //Specifies whether to skip the last IIS log file in queue.
            #endregion

            #region Instantiate Base Objects
            try
            {
                AnalyzerLogger = new Logger("IISLogAnalyzerDaemon_" + DateTime.Now.ToString().Replace('/', '-').Replace(':', '-') + ".log");
            }
            catch (Exception Error)
            {
                Console.ForegroundColor = ConsoleColor.Red;
                Console.WriteLine("ERROR: A Fatal error has occured.");
                Console.WriteLine("ERROR: " + Error.Message);
                if (Error.InnerException != null)
                    Console.WriteLine("ERROR: " + Error.InnerException.ToString());
                Console.WriteLine("ERROR: " + Error.StackTrace.ToString());
                Console.ResetColor();
                return;
            }
            #endregion

            #region Instantiate other objects
            try
            {
                AnalyzerConfig = new ConfigurationLayer();
                AnalyzerIISLogLayer = new IISLogFileInteractionLayer(AnalyzerConfig.IISLogFileLocation);
                EventLogOnError = AnalyzerConfig.LogEventOnError;
                EventLogOnEmptyLogQueue = AnalyzerConfig.LogEventOnEmptyLogQueue;
                LastIISLogLookupTimeStamp = AnalyzerConfig.LastLookupTimeStamp;
                IISLogFileProcessingLocation = Assembly.GetExecutingAssembly().Location.Substring(0,
                    Assembly.GetExecutingAssembly().Location.LastIndexOf('\\') + 1) + AnalyzerConfig.SSISProcessingStore;
                SSISExecuter = new SSISExecuterLayer(IISLogFileProcessingLocation,
                                                     AnalyzerConfig.SSISImportPackageName,
                                                     AnalyzerConfig.SSISProcessPackageName,
                                                     AnalyzerConfig.SSISShrinkDatabasePackageName,
                                                     AnalyzerLogger);
                LogProcessingBatchSize = AnalyzerConfig.IISLogProcessingChunk;
                SkipLastLogFile = AnalyzerConfig.SkipLastLog;
                CurrentBatchSize = 0;
            }
            catch (Exception Error)
            {
                Console.ForegroundColor = ConsoleColor.Red;
                Console.WriteLine("ERROR: An Error occured while instantiating objects.");
                Console.WriteLine("ERROR: " + Error.Message);
                Console.WriteLine("ERROR: Check log for more details.");
                AnalyzerLogger.WriteToLog("ERROR: An Error occured while instantiating objects.");
                AnalyzerLogger.WriteToLog("ERROR: " + Error.ToString());
                AnalyzerLogger.CloseLog();
                Console.ResetColor();
                return;
            }
            #endregion

            #region Fetch list of IIS Logs to process
            Console.ForegroundColor = ConsoleColor.White;
            Console.WriteLine("INFO: Building IIS Log File list to process ...");
            AnalyzerLogger.WriteToLog("INFO: Building IIS Log File list to process ...");
            try
            {
                LogFilesToProcess = AnalyzerIISLogLayer.GetLogFileNames(LastIISLogLookupTimeStamp,
                                                                        CompareAttribute.LastWriteTime,
                                                                        SkipLastLogFile);
                if (LogFilesToProcess != null)
                {
                    Console.WriteLine("INFO: " + LogFilesToProcess.Length.ToString() + " IIS Log Files to process.");
                    AnalyzerLogger.WriteToLog("INFO: " + LogFilesToProcess.Length.ToString() + " IIS Log Files to process.");
                }
                else
                {
                    Console.WriteLine("INFO: No IIS Log files to process!");
                    if (EventLogOnEmptyLogQueue)
                        AnalyzerLogger.WriteToLog("INFO: No IIS Log files to process!", EventLogEntryType.Warning);
                    else
                        AnalyzerLogger.WriteToLog("INFO: No IIS Log files to process!");
                    AnalyzerLogger.CloseLog();
                    return;
                }
            }
            catch (Exception Error)
            {
                Console.ForegroundColor = ConsoleColor.Red;
                Console.WriteLine("ERROR: An Error occured while building IIS Log file list.");
                Console.WriteLine("ERROR: " + Error.Message);
                Console.WriteLine("ERROR: Check log for more details.");
                if (EventLogOnError)
                    AnalyzerLogger.WriteToLog("ERROR: Error while building IIS Log file list. Error returned was: " + Error.ToString(), EventLogEntryType.Error);
                else
                {

                    AnalyzerLogger.WriteToLog("ERROR: An Error occured while building IIS Log file list.");
                    AnalyzerLogger.WriteToLog("ERROR: " + Error.ToString());
                }
                AnalyzerLogger.CloseLog();
                Console.ResetColor();
                return;
            }
            #endregion

            #region Import Data and Process
            foreach (string LogFile in LogFilesToProcess)
            {
                CurrentBatchSize += 1;

                Console.ForegroundColor = ConsoleColor.White;
                Console.WriteLine("INFO: Importing " + LogFile.Substring(LogFile.LastIndexOf('\\') + 1) + " ...");
                AnalyzerLogger.WriteToLog("INFO: Importing " + LogFile.Substring(LogFile.LastIndexOf('\\') + 1) + " ...");

                #region Stage Log File for Processing
                try
                {
                    Console.WriteLine("INFO: Staging ...");
                    AnalyzerLogger.WriteToLog("INFO: Setting IIS Log Timestamp as Last lookup timestamp.");
                    if (DateTime.Compare(LastIISLogLookupTimeStamp, AnalyzerIISLogLayer.GetLogFileTimeStamp(LogFile)) < 0)
                        LastIISLogLookupTimeStamp = AnalyzerIISLogLayer.GetLogFileTimeStamp(LogFile);
                    AnalyzerLogger.WriteToLog("INFO: Copying IIS Log: " + LogFile + " to " + IISLogFileProcessingLocation);
                    StageIISLogFileForProcessing(LogFile, IISLogFileProcessingLocation);
                    AnalyzerLogger.WriteToLog("INFO: Log File copied successfully.");
                }
                catch (Exception Error)
                {
                    Console.ForegroundColor = ConsoleColor.Red;
                    Console.WriteLine("ERROR: An Error occured while staging the IIS Log File.");
                    Console.WriteLine("ERROR: " + Error.Message);
                    Console.WriteLine("ERROR: Check log for more details.");
                    if (EventLogOnError)
                        AnalyzerLogger.WriteToLog("ERROR: Error while staging IIS Log File. Error returned was: " + Error.ToString(), EventLogEntryType.Error);
                    else
                    {
                        AnalyzerLogger.WriteToLog("ERROR: An Error occured while staging the IIS Log File.");
                        AnalyzerLogger.WriteToLog("ERROR: " + Error.ToString());
                    }
                    AnalyzerLogger.CloseLog();
                    Console.ResetColor();
                    return;
                }
                #endregion

                #region Run DTS Package to import data
                try
                {
                    Console.WriteLine("INFO: Importing Data from Log ...");
                    AnalyzerLogger.WriteToLog("INFO: Running importer DTS package on " + IISLogFileProcessingLocation + "\\IISLog.log");
                    if (!ImportIISLogData())
                    {
                        Console.ForegroundColor = ConsoleColor.Yellow;
                        Console.WriteLine("WARN: Importing process returned with errors.");
                        Console.WriteLine("WARN: Data might be missed from this log.");
                        Console.ForegroundColor = ConsoleColor.White;
                        if (EventLogOnError)
                            AnalyzerLogger.WriteToLog("WARN: The DTS Package execution returned error. Data might be missed.", EventLogEntryType.Warning);
                        else
                        {
                            AnalyzerLogger.WriteToLog("WARN: The DTS Package execution returned error.");
                            AnalyzerLogger.WriteToLog("WARN: Data might be missed from this log.");
                        }
                    }
                }
                catch (Exception Error)
                {
                    Console.ForegroundColor = ConsoleColor.Red;
                    Console.WriteLine("ERROR: An Error occured while importing data from the IIS Log File.");
                    Console.WriteLine("ERROR: " + Error.Message);
                    Console.WriteLine("ERROR: Check log for more details.");
                    if (EventLogOnError)
                        AnalyzerLogger.WriteToLog("ERROR: Error while impoting data. Error returned was: " + Error.ToString(), EventLogEntryType.Error);
                    else
                    {
                        AnalyzerLogger.WriteToLog("ERROR: An Error occured while importing data from the IIS Log File.");
                        AnalyzerLogger.WriteToLog("ERROR: " + Error.ToString());
                    }
                    AnalyzerLogger.CloseLog();
                    Console.ResetColor();
                    return;
                }
                #endregion

                #region Process Data
                if (CurrentBatchSize == LogProcessingBatchSize)
                {
                    Console.ForegroundColor = ConsoleColor.White;
                    Console.WriteLine("INFO: Processing imported data batch ...");
                    AnalyzerLogger.WriteToLog("INFO: Processing imported data batch ...");
                    try
                    {
                        AnalyzerLogger.WriteToLog("INFO: Running processor DTS package.");
                        if (!ProcessIISLogData())
                        {
                            Console.ForegroundColor = ConsoleColor.Yellow;
                            Console.WriteLine("WARN: Processing returned with error(s).");
                            Console.WriteLine("WARN: Check the SSIS Logs.");
                            Console.ForegroundColor = ConsoleColor.White;
                            if (EventLogOnError)
                                AnalyzerLogger.WriteToLog("WARN: Processing returned with error(s). Check SSIS Log output.", EventLogEntryType.Warning);
                            else
                            {
                                AnalyzerLogger.WriteToLog("WARN: Processing returned with error(s).");
                                AnalyzerLogger.WriteToLog("WARN: Check SSIS Log output.");
                            }
                        }
                    }
                    catch (Exception Error)
                    {
                        Console.ForegroundColor = ConsoleColor.Red;
                        Console.WriteLine("ERROR: An Error occured while processing data from the IIS Log File(s).");
                        Console.WriteLine("ERROR: " + Error.Message);
                        Console.WriteLine("ERROR: Check log for more details.");
                        if (EventLogOnError)
                            AnalyzerLogger.WriteToLog("ERROR: Error while processing IIS Log data. Error returned was: " + Error.ToString(), EventLogEntryType.Error);
                        else
                        {
                            AnalyzerLogger.WriteToLog("ERROR: An Error occured while processing data from the IIS Log File(s).");
                            AnalyzerLogger.WriteToLog("ERROR: " + Error.ToString());
                        }
                        AnalyzerLogger.CloseLog();
                        Console.ResetColor();
                        return;
                    }

                    AnalyzerLogger.WriteToLog("INFO: Setting new LastLookup Timestamp in config file.");
                    AnalyzerConfig.LastLookupTimeStamp = LastIISLogLookupTimeStamp;
                    CurrentBatchSize = 0;
                }
                #endregion
            }
            #endregion

            #region Final Data Processing for leftovers
            Console.ForegroundColor = ConsoleColor.White;
            Console.WriteLine("INFO: Running final Processing sequence ...");
            AnalyzerLogger.WriteToLog("INFO: Running final Processing sequence ...");
            try
            {
                AnalyzerLogger.WriteToLog("INFO: Running processor DTS package.");
                if (!ProcessIISLogData())
                {
                    Console.ForegroundColor = ConsoleColor.Yellow;
                    Console.WriteLine("WARN: Processing returned with error(s).");
                    Console.WriteLine("WARN: Check the SSIS Logs.");
                    Console.ForegroundColor = ConsoleColor.White;
                    if (EventLogOnError)
                        AnalyzerLogger.WriteToLog("WARN: Processing returned with error(s). Check SSIS Log output.", EventLogEntryType.Warning);
                    else
                    {
                        AnalyzerLogger.WriteToLog("WARN: Processing returned with error(s).");
                        AnalyzerLogger.WriteToLog("WARN: Check SSIS Log output.");
                    }
                }
            }
            catch (Exception Error)
            {
                Console.ForegroundColor = ConsoleColor.Red;
                Console.WriteLine("ERROR: An Error occured while processing data from the IIS Log File(s).");
                Console.WriteLine("ERROR: " + Error.Message);
                Console.WriteLine("ERROR: Check log for more details.");
                if (EventLogOnError)
                    AnalyzerLogger.WriteToLog("ERROR: Error while processing IIS Log data. Error returned was: " + Error.ToString(), EventLogEntryType.Error);
                else
                {
                    AnalyzerLogger.WriteToLog("ERROR: An Error occured while processing data from the IIS Log File(s).");
                    AnalyzerLogger.WriteToLog("ERROR: " + Error.ToString());
                }
                AnalyzerLogger.CloseLog();
                Console.ResetColor();
                return;
            }

            AnalyzerLogger.WriteToLog("INFO: Setting new LastLookup Timestamp in config file.->" + LastIISLogLookupTimeStamp.ToString());
            AnalyzerConfig.LastLookupTimeStamp = LastIISLogLookupTimeStamp;
            #endregion

            #region Shrink and Cleanup
            Console.ForegroundColor = ConsoleColor.White;
            Console.WriteLine("INFO: Shrinking Database ...");
            AnalyzerLogger.WriteToLog("INFO: Shrinking Database ...");
            try
            {
                if (!ShrinkDatabase())
                {
                    Console.ForegroundColor = ConsoleColor.Yellow;
                    Console.WriteLine("WARN: Database Shrink operation returned with error(s).");
                    Console.WriteLine("WARN: Check the SSIS Logs.");
                    Console.ForegroundColor = ConsoleColor.White;
                    if (EventLogOnError)
                        AnalyzerLogger.WriteToLog("WARN: Database Shrink operation returned with error(s). Check SSIS log output.", EventLogEntryType.Warning);
                    else
                    {
                        AnalyzerLogger.WriteToLog("WARN: Database Shrink operation returned with error(s).");
                        AnalyzerLogger.WriteToLog("WARN: Check SSIS Log output.");
                    }
                }
            }
            catch (Exception Error)
            {
                Console.ForegroundColor = ConsoleColor.Red;
                Console.WriteLine("ERROR: An Error occured while shrinking the database.");
                Console.WriteLine("ERROR: " + Error.Message);
                Console.WriteLine("ERROR: Check log for more details.");
                if (EventLogOnError)
                    AnalyzerLogger.WriteToLog("ERROR: Error while shrinking database. Error returned was: " + Error.ToString(), EventLogEntryType.Error);
                else
                {
                    AnalyzerLogger.WriteToLog("ERROR: An Error occured while shrinking the database.");
                    AnalyzerLogger.WriteToLog("ERROR: " + Error.ToString());
                }
                AnalyzerLogger.CloseLog();
                Console.ResetColor();
                return;
            }

            AnalyzerLogger.WriteToLog("INFO: ************************************ Processing Complete **********************************");
            AnalyzerLogger.CloseLog();
            AnalyzerLogger = null;
            AnalyzerIISLogLayer = null;
            AnalyzerConfig = null;
            SSISExecuter = null;
            #endregion

        }

        /// <summary>
        /// Print Welcome Message
        /// </summary>
        public static void PrintWelcome()
        {
            Console.ForegroundColor = ConsoleColor.White;
            Console.Clear();
            Console.WriteLine("IIS Log Analyzer Daemon v" + Assembly.GetCallingAssembly().GetName().Version.ToString());
            Console.WriteLine("(C) Microsoft Corporation. For Internal Use only.");
            Console.WriteLine(" ");
            Console.ResetColor();
        }

        /// <summary>
        /// Stage the specified IIS Log for import via SSIS Package.
        /// </summary>
        /// <param name="IISLogFile">The IIS Log File to process.</param>
        /// <param name="LogProcessingStore">The path to the processing store.</param>
        public static void StageIISLogFileForProcessing(string IISLogFile, string LogProcessingStore)
        {
            try
            {
                AnalyzerIISLogLayer.CopyLogFileToDTSProcessingStore(IISLogFile, LogProcessingStore);
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Start importing data from the staged IIS Log file.
        /// </summary>
        /// <returns>True if success, False if errors.</returns>
        public static bool ImportIISLogData()
        {
            try
            {
                return SSISExecuter.ImportIISLogData();
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Start processing the imported Log data.
        /// </summary>
        /// <returns>True if success, False if errors.</returns>
        public static bool ProcessIISLogData()
        {
            try
            {
                return SSISExecuter.ProcessIISLogData();
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Shrink Database
        /// </summary>
        /// <returns>True if success, False if errors.</returns>
        public static bool ShrinkDatabase()
        {
            try
            {
                return SSISExecuter.ShrinkDatabase();
            }
            catch (Exception)
            {
                throw;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\IISLogAnalyzer\IISLogAnalyzerDaemon\IISLogAnalyzerDaemon\FileInfoComparer.cs ===
﻿using System;
using System.Collections;
using System.Text;
using System.IO;

namespace Test.Common.Utilities.IISLogAnalyzerDaemon
{
    /// <summary>
    /// Indicates the attribute by which the comparison will be done.
    /// </summary>
    public enum CompareAttribute
    {
        /// <summary>
        /// Compare on the name of the file.
        /// </summary>
        FileName,
        /// <summary>
        /// Compare on the last write timestamp.
        /// </summary>
        LastWriteTime
    }

    /// <summary>
    /// Represents the comparer class for sorting FileInfo.
    /// </summary>
    public class FileInfoComparer : IComparer
    {
        private CompareAttribute m_CompareOn;

        /// <summary>
        /// Initializes a new instance of the FileInfoComparer class
        /// with the specified compare attribute.
        /// </summary>
        /// <param name="CompareOn">The attribute to compare on.</param>
        public FileInfoComparer(CompareAttribute CompareOn)
        {
            m_CompareOn = CompareOn;
        }

        /// <summary>
        /// Sets the attribute to compare on.
        /// </summary>
        public CompareAttribute CompareOn
        {
            set { m_CompareOn = value; }
        }

        /// <summary>
        /// Compares the specified FileInfo objects based on the compare attribute.
        /// </summary>
        /// <param name="FileInfo1">The first FileInfo object.</param>
        /// <param name="FileInfo2">The second FileInfo object.</param>
        /// <returns>An interger indication the result of the comparison.</returns>
        public int Compare(object FileInfo1, object FileInfo2)
        {
            FileInfo m_File1 = (FileInfo)FileInfo1;
            FileInfo m_File2 = (FileInfo)FileInfo2;

            switch (m_CompareOn)
            {
                case CompareAttribute.FileName:
                    return String.Compare(m_File1.Name, m_File2.Name, true);
                case CompareAttribute.LastWriteTime:
                    return DateTime.Compare(m_File1.LastWriteTime, m_File2.LastWriteTime);
                default:
                    return String.Compare(m_File1.Name, m_File2.Name, true);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\IISLogAnalyzer\IISLogAnalyzerDaemon\IISLogAnalyzerDaemon\Logger.cs ===
﻿using System;
using System.IO;
using System.Text;
using System.Diagnostics;

namespace Test.Common.Utilities.IISLogAnalyzerDaemon
{
    class Logger
    {
        private StreamWriter ILogger;

        /// <summary>
        /// Instantiate a new Log File.
        /// </summary>
        public Logger(string LogFileName)
        {
            try
            {
                if (File.Exists(LogFileName))
                    ILogger = File.AppendText(LogFileName);
                else
                    ILogger = File.CreateText(LogFileName);
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Write message to Log File.
        /// </summary>
        /// <param name="LogMessage">The Message to log.</param>
        public void WriteToLog(string LogMessage)
        {
            ILogger.WriteLine(DateTime.Now.ToString() + " " + LogMessage);
            ILogger.Flush();
        }

        /// <summary>
        /// Write message to Log file and to the Event log with the specified EventType.
        /// </summary>
        /// <param name="LogMessage">The Message to log.</param>
        /// <param name="EventLevel">The event level to log in Event Log.</param>
        public void WriteToLog(string LogMessage, EventLogEntryType EventLevel)
        {
            ILogger.WriteLine(DateTime.Now.ToString() + " " + LogMessage);
            ILogger.Flush();

            if (!EventLog.SourceExists("IISLogAnalyzerDaemon"))
                EventLog.CreateEventSource("IISLogAnalyzerDaemon", "Application");

            EventLog.WriteEntry("IISLogAnalyzerDaemon", LogMessage, EventLevel);
        }

        /// <summary>
        /// Closes the Log File.
        /// </summary>
        public void CloseLog()
        {
            try
            {
                ILogger.Close();
            }
            catch (Exception)
            {
                throw;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\IISLogAnalyzer\IISLogAnalyzerDaemon\IISLogAnalyzerDaemon\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("IISLogAnalyzerDaemon")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("")]
//[assembly: AssemblyProduct("")]
//[assembly: AssemblyCopyright("")]
//[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("15a96bdf-6157-4ed9-9670-2dd94173b159")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
//[assembly: AssemblyVersion("1.0.0.1")]
//[assembly: AssemblyFileVersion("1.0.0.1")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\IISLogAnalyzer\IISLogAnalyzerDaemon\IISLogAnalyzerDaemon\SSISExecuterLayer.cs ===
﻿using System;
using System.Diagnostics;
using System.Text;
using System.IO;

namespace Test.Common.Utilities.IISLogAnalyzerDaemon
{
    /// <summary>
    /// Layer for interacting with the SSIS Packages.
    /// </summary>
    internal class SSISExecuterLayer
    {
        string SSISPackageLocation;
        string SSISImporterPackage;
        string SSISProcessorPackage;
        string SSISShrinkDatabasePackage;
        Process SSISExecuterProcess;
        Logger SSISLogger;

        /// <summary>
        /// Instantiate a new object of the SSISExecuterLayer.
        /// </summary>
        /// <param name="SSISStore">The path to the SSIS Store containg the SSIS Packages.</param>
        /// <param name="SSISImportPackageName">The Package Name for importing IIS Log Data.</param>
        /// <param name="SSISProcessPackageName">The Package Name for processing the imported data.</param>
        /// <param name="ExecutionLogFile">The Log file where debug information will be written.</param>
        public SSISExecuterLayer(string SSISStore, string SSISImportPackageName, string SSISProcessPackageName, string SSISShrinkDatabasePackageName, Logger ExecutionLogFile)
        {
            SSISPackageLocation = SSISStore;
            SSISImporterPackage = SSISStore + "\\" + SSISImportPackageName;
            SSISProcessorPackage = SSISStore + "\\" + SSISProcessPackageName;
            SSISShrinkDatabasePackage = SSISStore + "\\" + SSISShrinkDatabasePackageName;
            SSISExecuterProcess = new Process();
            SSISLogger = ExecutionLogFile;
        }

        /// <summary>
        /// Different Execution Modes for SSIS Packages.
        /// </summary>
        enum SSISExecutionMode
        {
            Import,
            Process,
            ShrinkDatabase
        }

        /// <summary>
        /// Execute the specified SSIS Package.
        /// </summary>
        /// <param name="ExecutionMode">The mode in which to execute the packages.</param>
        /// <returns></returns>
        private bool ExecuteSSISPackage(SSISExecutionMode ExecutionMode)
        {
            string SSISExecutionOutputString = String.Empty;
            bool PackageExecutionOutcome = true;

            //Setup the process
            SSISExecuterProcess.StartInfo.FileName = "dtexec.exe";
            SSISExecuterProcess.StartInfo.UseShellExecute = false;
            SSISExecuterProcess.StartInfo.RedirectStandardOutput = true;
            SSISExecuterProcess.StartInfo.WorkingDirectory = SSISPackageLocation;
            switch (ExecutionMode)
            {
                case SSISExecutionMode.Import:
                    SSISExecuterProcess.StartInfo.Arguments = "/f \"" + SSISImporterPackage + "\" /CHECKPOINTING OFF  /REPORTING EWC";
                    break;
                case SSISExecutionMode.Process:
                    SSISExecuterProcess.StartInfo.Arguments = "/f \"" + SSISProcessorPackage + "\" /CHECKPOINTING OFF  /REPORTING EWC";
                    break;
                case SSISExecutionMode.ShrinkDatabase:
                    SSISExecuterProcess.StartInfo.Arguments = "/f \"" + SSISShrinkDatabasePackage + "\" /CHECKPOINTING OFF  /REPORTING EWC";
                    break;
            }

            SSISLogger.WriteToLog("SSIS: Executing command dtexec.exe " + SSISExecuterProcess.StartInfo.Arguments);
            SSISLogger.WriteToLog("SSIS DEBUG: Working Directory: " + SSISExecuterProcess.StartInfo.WorkingDirectory);
            try
            {
                //Execute SSIS package
                SSISExecuterProcess.Start();
                SSISExecutionOutputString = SSISExecuterProcess.StandardOutput.ReadToEnd();
                SSISExecuterProcess.WaitForExit();

                SSISLogger.WriteToLog("SSIS: " + SSISExecutionOutputString);
                SSISLogger.WriteToLog("SSIS: Checking for possible error output ...");

                if (CheckForOutputErrors(SSISExecutionOutputString))
                {
                    SSISLogger.WriteToLog("SSIS: One or more possible error conditions detected.");
                    PackageExecutionOutcome = false;
                }
            }
            catch (Exception)
            {
                SSISLogger.WriteToLog("SSIS: " + SSISExecutionOutputString);
                throw;
            }

            return PackageExecutionOutcome;
        }

        /// <summary>
        /// Import IIS Log data to database.
        /// </summary>
        /// <returns></returns>
        public bool ImportIISLogData()
        {
            if (!File.Exists(SSISPackageLocation + "\\IISLog.log"))
                throw new FileNotFoundException("The IIS Log was not found.");

            try
            {
                return ExecuteSSISPackage(SSISExecutionMode.Import);
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Process the imported IIS Log Data.
        /// </summary>
        /// <returns></returns>
        public bool ProcessIISLogData()
        {
            try
            {
                return ExecuteSSISPackage(SSISExecutionMode.Process);
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Shrink the Database.
        /// </summary>
        /// <returns></returns>
        public bool ShrinkDatabase()
        {
            try
            {
                return ExecuteSSISPackage(SSISExecutionMode.ShrinkDatabase);
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Check for standard output errors from dtexec.exe.
        /// </summary>
        /// <param name="OutputText">The output text for the app to be analyzed.</param>
        /// <returns></returns>
        private bool CheckForOutputErrors(string OutputText)
        {
            bool IsError = false;

            //Check for known error conditions
            //Error:
            if (OutputText.IndexOf("Error:") != -1)
                IsError = true;

            //End Error
            if (OutputText.IndexOf("End Error") != -1)
                IsError = true;

            return IsError;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\LEOCodeCoverageTool\LEOCodeCoverageTool\BBCoverLayer.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Diagnostics;
using System.IO;

namespace Wgx.Test.Solutions.Shared.Utilities.WGXCodeCoverageTool
{
    /// <summary>
    /// Layer around the Magellan BBCover Tool.
    /// </summary>
    internal class BBCoverLayer
    {
        private string CustomVersionNumber;
        private string CoverageSQLServerName;
        private string CoverageSQLServerUsername;
        private string CoverageSQLServerPassword;
        private string CoverageDatabaseName;
        private string TempStageLocation;
        private string[] ExcludedFiles;
        private string[] ExcludedFolders;
        private string[] BinFolderFiles;
        private Process BBCoverExecutable;
        private DirectoryInfo BinFolderPath;
        private Logger BBCoverLogger;
        private FileIOManager BBCoverIOManager;
        private bool InstrumentationErrorFlag;

        /// <summary>
        /// Instantiate a new object of BBCoverLayer
        /// </summary>
        /// <param name="BinaryRootPath">The path to the root of the folder containing the binaries.</param>
        /// <param name="VersionTag">The custom version tag.</param>
        /// <param name="DatabaseServer">The SQL Database Server name hosting the Code Coverage database.</param>
        /// <param name="DatabaseName">The Code Coverage SQL Database name.</param>
        /// <param name="DatabaseUsername">The Username to connect to the SQL Database Server.</param>
        /// <param name="DatabasePassword">The Password for the username to connect to the SQL Database Server.</param>
        /// <param name="ExcludedFileList">A list of all files excluded from instrumentation.</param>
        /// <param name="ExcludedFolderList">A list of all folders excluded from instrumentation.</param>
        /// <param name="InstrumentedBuildStageLocation">The temporary location where the Instrumented build will be staged.</param>
        public BBCoverLayer(string BinaryRootPath, string VersionTag, string DatabaseServer, string DatabaseName, string DatabaseUsername,
                            string DatabasePassword, string[] ExcludedFileList, string[] ExcludedFolderList, string InstrumentedBuildStageLocation)
        {
            //Set params
            CustomVersionNumber = VersionTag;
            CoverageSQLServerName = DatabaseServer;
            CoverageSQLServerUsername = DatabaseUsername;
            CoverageSQLServerPassword = DatabasePassword;
            CoverageDatabaseName = DatabaseName;
            ExcludedFiles = ExcludedFileList;
            ExcludedFolders = ExcludedFolderList;
            TempStageLocation = InstrumentedBuildStageLocation;
            BBCoverIOManager = new FileIOManager();
            InstrumentationErrorFlag = false;

            //Set Logger
            try
            {
                BBCoverLogger = new Logger("BBCoverRun_" + DateTime.Now.Month.ToString() + "-" +
                                            DateTime.Now.Day.ToString() + "-" +
                                            DateTime.Now.Year.ToString() + "_" +
                                            DateTime.Now.Hour.ToString() +
                                            DateTime.Now.Minute.ToString() +
                                            DateTime.Now.Millisecond.ToString() +
                                            ".log");
            }
            catch (Exception)
            {
                throw;
            }

            //Set Binary Folder & Logger, clear out stage folder.
            try
            {
                BinFolderPath = new DirectoryInfo(BinaryRootPath);
                BBCoverLogger.WriteToLog("INFO: Deleting Temporary Staging location ...");
                BBCoverIOManager.DeleteFolder(TempStageLocation);
            }
            catch (Exception Error)
            {
                BBCoverLogger.WriteToLog("ERROR: " + Error.Message);
                if (Error.InnerException != null)
                    BBCoverLogger.WriteToLog("ERROR: " + Error.InnerException.ToString());
                BBCoverLogger.WriteToLog("ERROR: " + Error.StackTrace.ToString());
                BBCoverLogger.CloseLog();
                throw;
            }

            if (!BinFolderPath.Exists)
            {
                BBCoverLogger.WriteToLog("ERROR: The specified Binary Folder does not exists.");
                BBCoverLogger.CloseLog();
                throw new DirectoryNotFoundException("The specified Binary Folder does not exists.");
            }

            //Set Process to execute BBCover
            try
            {
                BBCoverExecutable = new Process();
                BBCoverExecutable.StartInfo.FileName = "bbcover.exe";
                BBCoverExecutable.StartInfo.UseShellExecute = false;
                BBCoverExecutable.StartInfo.RedirectStandardOutput = true;
            }
            catch (Exception Error)
            {
                BBCoverLogger.WriteToLog("ERROR: " + Error.Message);
                if (Error.InnerException != null)
                    BBCoverLogger.WriteToLog("ERROR: " + Error.InnerException.ToString());
                BBCoverLogger.WriteToLog("ERROR: " + Error.StackTrace.ToString());
                BBCoverLogger.CloseLog();
                throw;
            }
        }

        /// <summary>
        /// Start the Instrumentation Process.
        /// </summary>
        /// <returns>True is instrumentation process succeeded without any errors, else false.</returns>
        public bool StartInstrumentation()
        {
            string BinRootFolderPath = BinFolderPath.FullName;
            bool IsFileInstrumented;

            //Start File Enumeration
            BBCoverLogger.WriteToLog("INFO: Enumerating all files in the specified binary folder ...");
            try
            {
                BinFolderFiles = BBCoverIOManager.EnumerateTargetFolderFiles(BinRootFolderPath);
            }
            catch (Exception Error)
            {
                BBCoverLogger.WriteToLog("ERROR: " + Error.Message);
                if (Error.InnerException != null)
                    BBCoverLogger.WriteToLog("ERROR: " + Error.InnerException.ToString());
                BBCoverLogger.WriteToLog("ERROR: " + Error.StackTrace.ToString());
                BBCoverLogger.CloseLog();
                throw;
            }

            //Start Instrumentation
            BBCoverLogger.WriteToLog("INFO: Starting instrumentation of the specified binary folder ...");
            foreach (string BinaryFile in BinFolderFiles)
            {
                try
                {
                    IsFileInstrumented = InstrumentBinary(BinaryFile);
                    BBCoverLogger.WriteToLog("DEBUG: Binary Instrumentation returned " + IsFileInstrumented.ToString());
                }
                catch (Exception Error)
                {
                    BBCoverLogger.WriteToLog("ERROR: " + Error.Message);
                    if (Error.InnerException != null)
                        BBCoverLogger.WriteToLog("ERROR: " + Error.InnerException.ToString());
                    BBCoverLogger.WriteToLog("ERROR: " + Error.StackTrace.ToString());
                    BBCoverLogger.CloseLog();
                    throw;
                }

                //Check if file was actually instrumented. If not then just copy over to stage
                if (!IsFileInstrumented)
                {
                    try
                    {
                        BBCoverIOManager.CopyBinary(BinaryFile, TempStageLocation + "\\" + ExtractBinaryPath(BinaryFile).Substring(BinaryFile.IndexOf(@"\") + 1));
                        BBCoverLogger.WriteToLog("DEBUG: File copied over from source without instrumentation.");
                    }
                    catch (Exception Error)
                    {
                        BBCoverLogger.WriteToLog("ERROR: " + Error.Message);
                        if (Error.InnerException != null)
                            BBCoverLogger.WriteToLog("ERROR: " + Error.InnerException.ToString());
                        BBCoverLogger.WriteToLog("ERROR: " + Error.StackTrace.ToString());
                        BBCoverLogger.CloseLog();
                        throw;
                    }
                }
            }

            return InstrumentationErrorFlag;
        }

        /// <summary>
        /// Instrument the specified binary.
        /// </summary>
        /// <param name="FullBinaryFileName">The full path to the source binary file, including the filename.</param>
        /// <returns></returns>
        private bool InstrumentBinary(string FullBinaryFileName)
        {
            string BBCoverOutputStream = null;
            string BinaryFileName = null;
            string BinaryFilePath = null;
            bool IsBinaryInstrumented = false;

            BinaryFileName = ExtractBinaryFileName(FullBinaryFileName);
            BinaryFilePath = ExtractBinaryPath(FullBinaryFileName);

            //Log File Name and Path
            BBCoverLogger.WriteToLog("INFO: Source Binary Filename = " + BinaryFileName);
            BBCoverLogger.WriteToLog("INFO: Source Binary Path = " + BinaryFilePath);

            if (IsFileExcluded(BinaryFileName) || IsFolderExcluded(BinaryFilePath))
            {
                if (IsFolderExcluded(BinaryFilePath))
                    BBCoverOutputStream = "WARN: Folder " + BinaryFilePath + " is excluded. Will not process.";
                else
                    BBCoverOutputStream = "WARN: File " + BinaryFileName + " is excluded. Will Not process.";
            }
            else
            {
                if (String.Compare("pdb", BinaryFileName.Substring(BinaryFileName.Length - 3), true) == 0)
                {
                    //Skip symbol pdb files
                    BBCoverOutputStream = "WARN: Symbol file " + BinaryFileName + " encountered. Skipping.";
                    IsBinaryInstrumented = true;
                }
                else
                {
                    //Instrument
                    try
                    {
                        BBCoverExecutable.StartInfo.Arguments = "/i \"" + FullBinaryFileName + "\"" +
                                                                " /o \"" + BinaryFileName + "\"" +
                                                                " /OutputDir \"" + TempStageLocation + "\\" + BinaryFilePath.Substring(BinaryFilePath.IndexOf(@"\") + 1) + "\"" +
                                                                " /db \"Server=" + CoverageSQLServerName +
                                                                ";Database=" + CoverageDatabaseName +
                                                                ";UserID=" + CoverageSQLServerUsername +
                                                                ";Password=" + CoverageSQLServerPassword + "\"" +
                                                                " /CustomVer \"" + CustomVersionNumber + "\"" +
                                                                " /verbose";

                        BBCoverLogger.WriteToLog("INFO: Running BBCover.exe " + BBCoverExecutable.StartInfo.Arguments);
                        
                        //Execute BBCover
                        BBCoverExecutable.Start();
                        BBCoverOutputStream = BBCoverExecutable.StandardOutput.ReadToEnd();
                        BBCoverExecutable.WaitForExit();

                        //Check for possible Error output
                        if (CheckForMagellanErrors(BBCoverOutputStream))
                        {
                            InstrumentationErrorFlag = true;                //Set Error Flag
                            BBCoverLogger.WriteToLog("DEBUG: Magellan error check returned TRUE.");
                        }
                        else
                        {
                            IsBinaryInstrumented = true;
                            BBCoverLogger.WriteToLog("DEBUG: Magellan error check returned FALSE.");
                        }
                    }
                    catch (Exception)
                    {
                        throw;
                    }
                }
            }

            BBCoverLogger.WriteToLog(BBCoverOutputStream);
            return IsBinaryInstrumented;
        }

        /// <summary>
        /// Check if File has been specifically excluded from instrumentation.
        /// </summary>
        /// <param name="BinaryFileName">The name of the Binary file.</param>
        /// <returns></returns>
        private bool IsFileExcluded(string BinaryFileName)
        {
            bool IsExcluded = false;

            foreach (string ExcludedFile in ExcludedFiles)
            {
                //Check if Exclusion is WildCard exclusion.
                if (IsWildCardExclusion(ExcludedFile))
                {
                    if (BinaryFileName.Length >= GetWildCardExtension(ExcludedFile).Length)
                    {
                        if (String.Compare(BinaryFileName.Substring(BinaryFileName.Length - GetWildCardExtension(ExcludedFile).Length),
                            GetWildCardExtension(ExcludedFile), true) == 0)
                            IsExcluded = true;
                    }
                }
                else
                {
                    if (String.Compare(BinaryFileName, ExcludedFile, true) == 0)
                        IsExcluded = true;
                }
            }
            BBCoverLogger.WriteToLog("DEBUG: File Exclusion Check returned " + IsExcluded.ToString());
            return IsExcluded;
        }

        /// <summary>
        /// Check if Folder has been specifically excluded from instrumentation.
        /// </summary>
        /// <param name="FolderName">The name of the Folder.</param>
        /// <returns></returns>
        private bool IsFolderExcluded(string FolderName)
        {
            bool IsExcluded = false;

            //Check if its a subfolder under root and only then compare.
            if (FolderName.Length > BinFolderPath.FullName.Length)
            {
                //Stip off Bin Root Folder from FolderName
                FolderName = FolderName.Substring(BinFolderPath.FullName.Length + 1);

                foreach (string ExcludedFolder in ExcludedFolders)
                {
                    if (ExcludedFolder.Length <= FolderName.Length)
                        if (String.Compare(FolderName.Substring(0, ExcludedFolder.Length), ExcludedFolder, true) == 0)
                            IsExcluded = true;
                }
            }
            BBCoverLogger.WriteToLog("DEBUG: Folder Exclusion Check returned " + IsExcluded.ToString());
            return IsExcluded;
        }

        /// <summary>
        /// Check if the Exclusion entry is a Wild card exclusion.
        /// </summary>
        /// <param name="ExclusionString">The Exclusion entry string.</param>
        /// <returns></returns>
        private bool IsWildCardExclusion(string ExclusionString)
        {
            bool IsWildCard = false;

            if (ExclusionString.Substring(0, 2) == "*.")
                IsWildCard = true;
            return IsWildCard;
        }

        /// <summary>
        /// Get the extension of the Wild Card exclusion string.
        /// </summary>
        /// <param name="WildCardExclusionString">The Wild Card Exclusion string entry.</param>
        /// <returns></returns>
        private string GetWildCardExtension(string WildCardExclusionString)
        {
            return WildCardExclusionString.Substring(WildCardExclusionString.IndexOf("*.") + 2);
        }

        /// <summary>
        /// Get the Binary File name from the full binary path.
        /// </summary>
        /// <param name="FullBinaryPath">The full path of the Binary File, including the file name.</param>
        /// <returns></returns>
        private string ExtractBinaryFileName(string FullBinaryPath)
        {
            return FullBinaryPath.Substring(FullBinaryPath.LastIndexOf(@"\") + 1);
        }

        /// <summary>
        /// Get the Path of the Binay file from the full binary path.
        /// </summary>
        /// <param name="FullBinaryPath">The full path of the Binary File, including the file name.</param>
        /// <returns></returns>
        private string ExtractBinaryPath(string FullBinaryPath)
        {
            return FullBinaryPath.Substring(0, FullBinaryPath.LastIndexOf(@"\"));
        }

        /// <summary>
        /// Check for any error conditions in the Magellan Tool output.
        /// </summary>
        /// <param name="MagellanToolOutputString">The output string from the Magellan Tool.</param>
        /// <returns></returns>
        private bool CheckForMagellanErrors(string MagellanToolOutputString)
        {
            bool IsError = false;

            //Check for known error conditions
            //MagCore: Error
            if (MagellanToolOutputString.IndexOf("MagCore: Error") != -1)
                IsError = true;

            //MAGELLAN: ERROR
            if (MagellanToolOutputString.IndexOf("MAGELLAN: ERROR") != -1)
                IsError = true;

            //Unable to locate correct PDB for
            if (MagellanToolOutputString.IndexOf("Unable to locate correct PDB for") != -1)
                IsError = true;

            return IsError;
        }
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\PLTScheduler\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\LEOCodeCoverageTool\LEOCodeCoverageTool\FileIOManager.cs ===
﻿using System;
using System.Collections;
using System.Text;
using System.IO;

namespace Wgx.Test.Solutions.Shared.Utilities.WGXCodeCoverageTool
{
    internal class FileIOManager
    {
        /// <summary>
        /// Instantiate a new instance of FileIOManager
        /// </summary>
        public FileIOManager()
        {
        }

        /// <summary>
        /// Enumerate all the files in the specified Target folder.
        /// </summary>
        /// <param name="TargetFolder">The Target folder path.</param>
        /// <returns></returns>
        public string[] EnumerateTargetFolderFiles(string TargetFolder)
        {
            if (!Directory.Exists(TargetFolder))
                throw new DirectoryNotFoundException("The specified Binary Folder does not exists.");

            try
            {
                return (string[])EnemurateContents(TargetFolder).ToArray(typeof(String));
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Copies the specified Binary to the specified destination folder.
        /// </summary>
        /// <param name="SourceBinaryPath">The full path to the source binary, including the file name.</param>
        /// <param name="DestinationPath">The destination path. Do not include the file name.</param>
        public void CopyBinary(string SourceBinaryPath, string DestinationPath)
        {
            string BinaryFileName = null;

            //Strip off trailing '\' from Destination path
            if (DestinationPath.Substring(DestinationPath.Length - 1) == "\\")
                DestinationPath = DestinationPath.Substring(0, DestinationPath.Length - 1);


            BinaryFileName = SourceBinaryPath.Substring(SourceBinaryPath.LastIndexOf(@"\") + 1);

            //Check if Destination folder exists. If not, create it
            if (!Directory.Exists(DestinationPath))
                Directory.CreateDirectory(DestinationPath);

            //Copy the file
            try
            {
                File.Copy(SourceBinaryPath, DestinationPath + @"\" + BinaryFileName, true);
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Deletes the specified target folder.
        /// </summary>
        /// <param name="TargetFolder">The target folder to be deleted.</param>
        public void DeleteFolder(string TargetFolder)
        {
            if (TargetFolder.Substring(TargetFolder.Length - 1) == "\\")
                TargetFolder = TargetFolder.Substring(0, TargetFolder.Length - 1);

            if (!Directory.Exists(TargetFolder))
                return;

            try
            {
                //Reset All File attributes
                ResetFileAttributesToNormal(new DirectoryInfo(TargetFolder));

                //Delete Target Folder
                Directory.Delete(TargetFolder, true);
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Resets the attributes of all the files under specified folder to normal.
        /// </summary>
        /// <param name="TargetFolder">The Target Folder.</param>
        private void ResetFileAttributesToNormal(DirectoryInfo TargetFolder)
        {
            if (!TargetFolder.Exists)
                return;

            try
            {
                //Process all files in the folder
                foreach (FileInfo File in TargetFolder.GetFiles())
                    File.Attributes = FileAttributes.Normal;

                //Now process all subfolders
                foreach (DirectoryInfo SubDirectory in TargetFolder.GetDirectories())
                    ResetFileAttributesToNormal(SubDirectory);
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Enumerate the Contents of the specified Folder.
        /// </summary>
        /// <param name="Folder">The folder to enumerate.</param>
        /// <returns></returns>
        private ArrayList EnemurateContents(string Folder)
        {
            ArrayList FileList = new ArrayList();
            try
            {
                DirectoryInfo SourceDirectory = new DirectoryInfo(Folder);

                // Add Filenames to list
                foreach (FileInfo File in SourceDirectory.GetFiles())
                    FileList.Add(File.FullName);

                // Traverse each subdirectory using recursion.
                foreach (DirectoryInfo SourceSubDirectory in SourceDirectory.GetDirectories())
                    FileList.AddRange(EnemurateContents(SourceSubDirectory.FullName));
            }
            catch (Exception)
            {
                throw;
            }

            return FileList;
        }

       
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\LEOCodeCoverageTool\LEOCodeCoverageTool\CodeCoverageTool.cs ===
﻿using System;
using System.Text;
using System.Reflection;

namespace Wgx.Test.Solutions.Shared.Utilities.WGXCodeCoverageTool
{
    class CodeCoverageTool
    {
        private static Logger WGXCCLogger;
        private static ConfigurationLayer WGXCCConfig;
        private static BBCoverLayer WGXCCInstrumentationObject;
        private static CoverCmdLayer WGXCCCoverageDataCollectorObject;

        static void Main(string[] args)
        {
            //Print Welcome message
            PrintWelcome();

            //Setup variables
            int OperationMode = 0;                          //1=Instrumentation, 2=Collect Coverage Data
            string Version = "";                            //Custom Version string for Instrumentation
            string BinaryPath = "";                         //Path containing the binaries to be instrumented
            bool VFlag = false;                             //Flag to indicate /V option was passed
            bool BPFlag = false;                            //Flag to indicate /BP option was passed
            bool TaskOutcomeErrorFlag;                      //Flag to determine error condition of instrumentation or CC collect. True if errors else false.

            //Instantiate logger
            try
            {
                WGXCCLogger = new Logger("LEOCodeCoverageTool.log");
            }
            catch (Exception Error)
            {
                Console.ForegroundColor = ConsoleColor.Red;
                Console.WriteLine("ERROR: A Fatal error occured while creating log.");
                Console.WriteLine("ERROR: " + Error.ToString());
                Console.ResetColor();
                return;
            }

            //Instantiate Config
            try
            {
                WGXCCConfig = new ConfigurationLayer();
            }
            catch (Exception Error)
            {
                Console.ForegroundColor = ConsoleColor.Red;
                Console.WriteLine("ERROR: A Fatal error occured while reading configuration.");
                Console.WriteLine("ERROR: " + Error.ToString());
                WGXCCLogger.WriteToLog("ERROR: A Fatal error occured while reading configuration.");
                WGXCCLogger.WriteToLog("ERROR: " + Error.ToString());
                Console.ResetColor();
                return;
            }

            //Check if any arguments were passed
            if (args.Length == 0)
            {
                Console.ForegroundColor = ConsoleColor.Red;
                Console.WriteLine("ERROR: No input arguments were specified.");
                PrintHelp();
                WGXCCLogger.WriteToLog("ERROR: No input arguments were specified.");
                WGXCCLogger.CloseLog();
                Console.ResetColor();
                return;
            }

            #region Check for valid CommandLine arguments and set respective flags
            Console.ForegroundColor = ConsoleColor.White;
            Console.WriteLine("INFO: Checking arguments ...");
            foreach (string CommandLineArgument in args)
            {
                bool ArgumentParsed = false;

                // /I
                if (CommandLineArgument.IndexOf("/i", StringComparison.CurrentCultureIgnoreCase) != -1)
                {
                    if (OperationMode != 0)
                    {
                        Console.ForegroundColor = ConsoleColor.Red;
                        Console.WriteLine("ERROR: The /i and /c arguments cannot be specified together.");
                        PrintHelp();
                        Console.ResetColor();
                        WGXCCLogger.WriteToLog("ERROR: The /i and /c arguments cannot be specified together.");
                        WGXCCLogger.CloseLog();
                        return;
                    }
                    WGXCCLogger.WriteToLog("INFO: /I passed. Instrumentation mode selected.");
                    Console.WriteLine("INFO: Instrumentation mode selected.");
                    OperationMode = 1;
                    ArgumentParsed = true;
                }

                // /C
                if (CommandLineArgument.IndexOf("/c", StringComparison.CurrentCultureIgnoreCase) != -1)
                {
                    if (OperationMode != 0)
                    {
                        Console.ForegroundColor = ConsoleColor.Red;
                        Console.WriteLine("ERROR: The /i and /c arguments cannot be specified together.");
                        PrintHelp();
                        Console.ResetColor();
                        WGXCCLogger.WriteToLog("ERROR: The /i and /c arguments cannot be specified together.");
                        WGXCCLogger.CloseLog();
                        return;
                    }
                    WGXCCLogger.WriteToLog("INFO: /C passed. Collect Coverage data mode selected.");
                    Console.WriteLine("INFO: Collect Coverage data mode selected.");
                    OperationMode = 2;
                    ArgumentParsed = true;
                }

                // /BP
                if (CommandLineArgument.IndexOf("/bp:", StringComparison.CurrentCultureIgnoreCase) != -1)
                {
                    WGXCCLogger.WriteToLog("INFO: /BP passed. Setting Binary Path.");
                    BinaryPath = CommandLineArgument.Substring(CommandLineArgument.IndexOf(':') + 1);
                    //Strip off trailing '\' from Binary path
                    if (BinaryPath.Substring(BinaryPath.Length - 1) == "\\")
                        BinaryPath = BinaryPath.Substring(0, BinaryPath.Length - 1);
                    BPFlag = true;
                    WGXCCLogger.WriteToLog("INFO: Binary Path is " + BinaryPath);
                    Console.WriteLine("INFO: Binary Path is " + BinaryPath);
                    ArgumentParsed = true;
                }

                // /V
                if (CommandLineArgument.IndexOf("/v:", StringComparison.CurrentCultureIgnoreCase) != -1)
                {
                    WGXCCLogger.WriteToLog("INFO: /V passed. Setting Version string.");
                    Version = CommandLineArgument.Substring(CommandLineArgument.IndexOf(':') + 1);
                    VFlag = true;
                    WGXCCLogger.WriteToLog("INFO: Version String is " + Version);
                    Console.WriteLine("INFO: Version String is " + Version);
                    ArgumentParsed = true;
                }

                if (!ArgumentParsed)
                {
                    Console.ForegroundColor = ConsoleColor.Red;
                    Console.WriteLine("ERROR: Unknown argument '" + CommandLineArgument + "' encountered.");
                    PrintHelp();
                    WGXCCLogger.WriteToLog("ERROR: Unknown argument '" + CommandLineArgument + "' encountered.");
                    WGXCCLogger.CloseLog();
                    Console.ResetColor();
                    return;
                }
            }
            #endregion

            #region Check if required arguments are passed from CommandLine
            switch (OperationMode)
            {
                case 1:
                    WGXCCLogger.WriteToLog("INFO: Checking param for Instrumentation mode.");
                    if (!BPFlag)
                    {
                        Console.ForegroundColor = ConsoleColor.Red;
                        Console.WriteLine("ERROR: /BP argument is missing.");
                        Console.WriteLine("ERROR: Binary Path must be specified via /BP switch.");
                        PrintHelp();
                        Console.ResetColor();
                        WGXCCLogger.WriteToLog("ERROR: /BP argument missing.");
                        WGXCCLogger.WriteToLog("ERROR: Binary Path must be specified via /BP switch.");
                        WGXCCLogger.CloseLog();
                        return;
                    }

                    if (!VFlag)
                    {
                        Console.ForegroundColor = ConsoleColor.Red;
                        Console.WriteLine("ERROR: /V argument is missing.");
                        Console.WriteLine("ERROR: Custom Version string must be specified via /V switch.");
                        PrintHelp();
                        Console.ResetColor();
                        WGXCCLogger.WriteToLog("ERROR: /V argument is missing.");
                        WGXCCLogger.WriteToLog("ERROR: Custom Version string must be specified via /V switch.");
                        WGXCCLogger.CloseLog();
                        return;
                    }
                    break;
                case 2:
                    WGXCCLogger.WriteToLog("INFO: Checking param for Collect Coverage Data mode.");
                    if (BPFlag)
                    {
                        Console.ForegroundColor = ConsoleColor.Yellow;
                        Console.WriteLine("WARN: /BP argument is not required. Ignoring!");
                        Console.ResetColor();
                        WGXCCLogger.WriteToLog("WARN: /BP argument is not required. Ignoring!");
                    }
                    if (VFlag)
                    {
                        Console.ForegroundColor = ConsoleColor.Yellow;
                        Console.WriteLine("WARN: /V argument is not required. Ignoring!");
                        Console.ResetColor();
                        WGXCCLogger.WriteToLog("WARN: /V argument is not required. Ignoring!");
                    }
                    break;
            }
            #endregion

            #region Begin Operations
            switch (OperationMode)
            {
                case 1:
                    //Instrumentation
                    Console.ForegroundColor = ConsoleColor.White;
                    Console.WriteLine("INFO: Instrumenting specified build ...");
                    Console.ResetColor();
                    WGXCCLogger.WriteToLog("INFO: Starting Instrumentation of the specified build ...");

                    try
                    {
                        WGXCCInstrumentationObject = new BBCoverLayer(BinaryPath,
                                                                    Version,
                                                                    WGXCCConfig.CoverageDatabaseServerName,
                                                                    WGXCCConfig.CoverageDatabaseName,
                                                                    WGXCCConfig.CoverageDatabaseUserName,
                                                                    WGXCCConfig.CoverageDatabaseUserPassword,
                                                                    WGXCCConfig.GetExcludedFiles(),
                                                                    WGXCCConfig.GetExcludedFolders(),
                                                                    WGXCCConfig.CoverageBuildStageLocation);
                        TaskOutcomeErrorFlag = WGXCCInstrumentationObject.StartInstrumentation();
                    }
                    catch (Exception Error)
                    {
                        Console.ForegroundColor = ConsoleColor.Red;
                        Console.WriteLine("ERROR: An Error occured while instrumenting.");
                        Console.WriteLine("ERROR: " + Error.Message);
                        Console.WriteLine("ERROR: Check BBCover log for more details.");
                        WGXCCLogger.WriteToLog("ERROR: An Error occured while instrumenting.");
                        WGXCCLogger.WriteToLog("ERROR: " + Error.ToString());
                        WGXCCLogger.WriteToLog("ERROR: Check BBCover log for more details.");
                        WGXCCLogger.CloseLog();
                        Console.ResetColor();
                        return;
                    }

                    //Check if any error occured in the instrumentation
                    if (TaskOutcomeErrorFlag)
                    {
                        Console.ForegroundColor = ConsoleColor.Yellow;
                        Console.WriteLine("WARN: The instrumentation process reported one or more failures.");
                        Console.WriteLine("WARN: Check the BBCover log for more details.");
                        Console.ResetColor();
                        WGXCCLogger.WriteToLog("WARN: The instrumentation process reported one or more failures.");
                        WGXCCLogger.WriteToLog("WARN: Check the BBCover log for more details.");
                    }
                    else
                    {
                        Console.ForegroundColor = ConsoleColor.White;
                        Console.WriteLine("INFO: The build has been successfully instrumented");
                        Console.WriteLine("INFO: and staged at " + WGXCCConfig.CoverageBuildStageLocation);
                        WGXCCLogger.WriteToLog("INFO: The build has been successfully instrumented and staged at " + WGXCCConfig.CoverageBuildStageLocation);
                        Console.ResetColor();
                    }
                    break;
                case 2:
                    //Collect Coverage data
                    Console.ForegroundColor = ConsoleColor.White;
                    Console.WriteLine("INFO: Collecting Code Coverage Data ...");
                    Console.ResetColor();
                    WGXCCLogger.WriteToLog("INFO: Collecting Code Coverage Data ...");

                    try
                    {
                        WGXCCCoverageDataCollectorObject = new CoverCmdLayer(WGXCCConfig.CoverageDatabaseServerName,
                                                                           WGXCCConfig.CoverageDatabaseName,
                                                                           WGXCCConfig.CoverageDatabaseUserName,
                                                                           WGXCCConfig.CoverageDatabaseUserPassword,
                                                                           WGXCCConfig.CoverageTraceName);
                        TaskOutcomeErrorFlag = WGXCCCoverageDataCollectorObject.GatherCoverageData();
                    }
                    catch (Exception Error)
                    {
                        Console.ForegroundColor = ConsoleColor.Red;
                        Console.WriteLine("ERROR: An Error occured while collecting Coverage Data.");
                        Console.WriteLine("ERROR: " + Error.Message);
                        Console.WriteLine("ERROR: Check CoverCmd log for more details.");
                        WGXCCLogger.WriteToLog("ERROR: An Error occured while collecting Coverage Data.");
                        WGXCCLogger.WriteToLog("ERROR: " + Error.ToString());
                        WGXCCLogger.WriteToLog("ERROR: Check CoverCmd log for more details.");
                        WGXCCLogger.CloseLog();
                        Console.ResetColor();
                        return;
                    }

                    //Check if any error occured in the collection process
                    if (TaskOutcomeErrorFlag)
                    {
                        Console.ForegroundColor = ConsoleColor.Yellow;
                        Console.WriteLine("WARN: The Coverage Collection process reported one or more failures.");
                        Console.WriteLine("WARN: Check the CoverCmd log for more details.");
                        Console.ResetColor();
                        WGXCCLogger.WriteToLog("WARN: The Coverage Collection process reported one or more failures.");
                        WGXCCLogger.WriteToLog("WARN: Check the CoverCmd log for more details.");
                    }
                    else
                    {
                        Console.ForegroundColor = ConsoleColor.White;
                        Console.WriteLine("INFO: The Coverage Data has been successfully collected.");
                        WGXCCLogger.WriteToLog("INFO: The Coverage Data has been successfully collected.");
                        Console.ResetColor();
                    }
                    break;
            } 
            #endregion

            return;
        }

        public static void PrintWelcome()
        {
            Console.ForegroundColor = ConsoleColor.White;
            Console.Clear();
            Console.WriteLine("WGX Code Coverage Tool v" + Assembly.GetCallingAssembly().GetName().Version.ToString());
            Console.WriteLine("(C) Microsoft Corporation. For Internal Use only.");
            Console.WriteLine(" ");
            Console.ResetColor();
        }

        public static void PrintHelp()
        {
            Console.ForegroundColor = ConsoleColor.White;
            Console.WriteLine(" ");
            Console.WriteLine("HELP: Usage:");
            Console.WriteLine("HELP:   WGXCodeCoverageTool.exe [mode] [options]");
            Console.WriteLine("HELP: where - ");
            Console.WriteLine("HELP:   [mode] is one of the following:");
            Console.WriteLine("HELP:    /i - Instrumentation mode. This will instrument the binary.");
            Console.WriteLine("HELP:    /c - Collect Code Coverage data mode. This will collect coverage data.");
            Console.WriteLine("HELP:");
            Console.WriteLine("HELP:   [options] are:");
            Console.WriteLine("HELP:    For Instrumentation mode:");
            Console.WriteLine("HELP:    /bp:<Build_Root_Path> - This points to the root of the build to");
            Console.WriteLine("HELP:                            be instrumented.");
            Console.WriteLine("HELP:    /v:<Custom_version_Tag> - This is the custom version info that");
            Console.WriteLine("HELP:                      you want the coverage data to be filed under.");
            Console.WriteLine("HELP:    For Collect Coverage Data mode:");
            Console.WriteLine("HELP:     No additional options are necessary.");
            Console.WriteLine(" ");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\LEOCodeCoverageTool\LEOCodeCoverageTool\ConfigurationLayer.cs ===
﻿using System;
using System.Collections;
using System.Configuration;
using System.Xml;
using System.Text;
using System.IO;


namespace Wgx.Test.Solutions.Shared.Utilities.WGXCodeCoverageTool
{
    /// <summary>
    /// Layer to read the various configurations from App.Config and other config XMLs
    /// </summary>
    internal class ConfigurationLayer
    {
        private string DatabaseServerName;
        private string DatabaseUserName;
        private string DatabaseUserPassword;
        private string DatabaseName;
        private string CodeCoverageTraceName;
        private string TemporaryInstrumentedStageLocation;
        private ArrayList ExcludedFiles = null;
        private ArrayList ExcludedFolders = null;
        private XmlDocument ExclusionXML = null;
        private XmlNodeList ExclusionFileList = null;
        private XmlNodeList ExclusionFolderList = null;

        /// <summary>
        /// Initialize a new instance of ConfigurationLayer and read in the configuration values.
        /// </summary>
        public ConfigurationLayer()
        {
            //Read App.Config
            try
            {
                DatabaseServerName = ConfigurationManager.AppSettings["CodeCoverageDatabaseServer"].ToString();
                DatabaseUserName = ConfigurationManager.AppSettings["CodeCoverageDatabaseUsername"].ToString();
                DatabaseUserPassword = ConfigurationManager.AppSettings["CodeCoverageDatabaseUserPassword"].ToString();
                DatabaseName = ConfigurationManager.AppSettings["CodeCoverageDatabaseName"].ToString();
                TemporaryInstrumentedStageLocation = ConfigurationManager.AppSettings["InstrumentedStageLocation"].ToString();
                CodeCoverageTraceName = ConfigurationManager.AppSettings["CodeCoverageTraceName"].ToString();

                //Strip off trailing '\' from Stage path
                if (TemporaryInstrumentedStageLocation.Substring(TemporaryInstrumentedStageLocation.Length - 1) == "\\")
                    TemporaryInstrumentedStageLocation = TemporaryInstrumentedStageLocation.Substring(0, TemporaryInstrumentedStageLocation.Length - 1);
            }
            catch (Exception)
            {
                throw;
            }

            //Read Exclusion XML
            if (File.Exists("Exclusion.xml"))
            {
                try
                {
                    ExclusionXML = new XmlDocument();
                    ExclusionXML.Load("Exclusion.xml");
                    ExclusionFileList = ExclusionXML.GetElementsByTagName("File");
                    ExclusionFolderList = ExclusionXML.GetElementsByTagName("Folder");
                    ExcludedFiles = new ArrayList();
                    ExcludedFolders = new ArrayList();

                    //Populate excluded File list
                    foreach (XmlNode FileName in ExclusionFileList)
                        ExcludedFiles.Add(FileName.InnerText);

                    //Populate excluded Folder list
                    foreach (XmlNode FolderName in ExclusionFolderList)
                    {
                        if (FolderName.InnerText.Substring(FolderName.InnerText.Length - 1) == "\\")
                            ExcludedFolders.Add(FolderName.InnerText.Substring(0, FolderName.InnerText.Length - 1));
                        else
                            ExcludedFolders.Add(FolderName.InnerText);
                    }

                    ExclusionFileList = null;
                    ExclusionFolderList = null;
                    ExclusionXML = null;
                }
                catch (Exception)
                {
                    throw;
                }
            }
        }

        /// <summary>
        /// Get the Excluded File List for instrumentation.
        /// </summary>
        /// <returns></returns>
        public string[] GetExcludedFiles()
        {
            if (ExcludedFiles == null)
                return null;
            else
                return (string[])ExcludedFiles.ToArray(typeof(string));
        }

        /// <summary>
        /// Get the Excluded Folder List for instrumentation.
        /// </summary>
        /// <returns></returns>
        public string[] GetExcludedFolders()
        {
            if (ExcludedFolders == null)
                return null;
            else
                return (string[])ExcludedFolders.ToArray(typeof(string));
        }

        public string CoverageDatabaseServerName
        {
            get { return DatabaseServerName; }
        }

        public string CoverageDatabaseUserName
        {
            get { return DatabaseUserName; }
        }

        public string CoverageDatabaseUserPassword
        {
            get { return DatabaseUserPassword; }
        }

        public string CoverageDatabaseName
        {
            get { return DatabaseName; }
        }

        public string CoverageBuildStageLocation
        {
            get { return TemporaryInstrumentedStageLocation; }
        }

        public string CoverageTraceName
        {
            get { return CodeCoverageTraceName; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\LEOCodeCoverageTool\LEOCodeCoverageTool\CoverCmdLayer.cs ===
﻿using System;
using System.Diagnostics;
using System.Text;

namespace Wgx.Test.Solutions.Shared.Utilities.WGXCodeCoverageTool
{
    internal class CoverCmdLayer
    {
        private string CoverageSQLServerName;
        private string CoverageSQLServerUsername;
        private string CoverageSQLServerPassword;
        private string CoverageDatabaseName;
        private string CoverageTraceName;
        private bool CoverCmdErrorFlag;
        private Logger CoverCmdLogger;
        private Process CoverCmdExecutable;

        /// <summary>
        /// Instantiate a new object of CoverCmdLayer
        /// </summary>
        /// <param name="DatabaseServer">The SQL Database Server name hosting the Code Coverage database.</param>
        /// <param name="DatabaseName">The Code Coverage SQL Database name.</param>
        /// <param name="DatabaseUsername">The Username to connect to the SQL Database Server.</param>
        /// <param name="DatabasePassword">The Password for the username to connect to the SQL Database Server.</param>
        /// <param name="TraceName">The Trace name which will be associated with the code coverage data.</param>
        public CoverCmdLayer(string DatabaseServer, string DatabaseName, string DatabaseUsername, string DatabasePassword, string TraceName)
        {
            //Set Params
            CoverageSQLServerName = DatabaseServer;
            CoverageSQLServerUsername = DatabaseUsername;
            CoverageSQLServerPassword = DatabasePassword;
            CoverageDatabaseName = DatabaseName;
            CoverageTraceName = TraceName;
            CoverCmdErrorFlag = false;

            //Set Objects
            try
            {
                CoverCmdLogger = new Logger("CoverCmdRun_" + DateTime.Now.Month.ToString() + "-" +
                            DateTime.Now.Day.ToString() + "-" +
                            DateTime.Now.Year.ToString() + "_" +
                            DateTime.Now.Hour.ToString() +
                            DateTime.Now.Minute.ToString() +
                            DateTime.Now.Millisecond.ToString() +
                            ".log");
            }
            catch (Exception)
            {
                throw;
            }

            //Set Process to execute CoverCmd
            try
            {
                CoverCmdExecutable = new Process();
                CoverCmdExecutable.StartInfo.FileName = "covercmd.exe";
                CoverCmdExecutable.StartInfo.UseShellExecute = false;
                CoverCmdExecutable.StartInfo.RedirectStandardOutput = true;
            }
            catch (Exception Error)
            {
                CoverCmdLogger.WriteToLog("ERROR: " + Error.Message);
                if (Error.InnerException != null)
                    CoverCmdLogger.WriteToLog("ERROR: " + Error.InnerException.ToString());
                CoverCmdLogger.WriteToLog("ERROR: " + Error.StackTrace.ToString());
                CoverCmdLogger.CloseLog();
                throw;
            }
        }

        /// <summary>
        /// Start the Coverage Data gathering process.
        /// </summary>
        /// <returns></returns>
        public bool GatherCoverageData()
        {
            string CoverCmdOutputString;

            //Start gathering coverage data
            CoverCmdLogger.WriteToLog("INFO: Gathering Coverage data ...");

            try
            {
                CoverCmdExecutable.StartInfo.Arguments = "/save " +
                                                         "/as \"" + CoverageTraceName + "\" " +
                                                         "/session ALL " +
                                                         "/db \"Server=" + CoverageSQLServerName +
                                                         ";Database=" + CoverageDatabaseName +
                                                         ";UserID=" + CoverageSQLServerUsername +
                                                         ";Password=" + CoverageSQLServerPassword + "\"" +
                                                         " /setverbose on";

                CoverCmdLogger.WriteToLog("INFO: Running command covercmd.exe " + CoverCmdExecutable.StartInfo.Arguments);

                //Execute CoverCmd
                CoverCmdExecutable.Start();
                CoverCmdOutputString = CoverCmdExecutable.StandardOutput.ReadToEnd();
                CoverCmdExecutable.WaitForExit();

                //Check for possible Error Output
                if (CheckForMagellanErrors(CoverCmdOutputString))
                {
                    CoverCmdErrorFlag = true;                //Set Error Flag
                    CoverCmdLogger.WriteToLog("DEBUG: Magellan error check returned TRUE.");
                }
                else
                    CoverCmdLogger.WriteToLog("DEBUG: Magellan error check returned FALSE.");
            }
            catch (Exception Error)
            {
                CoverCmdLogger.WriteToLog("ERROR: " + Error.Message);
                if (Error.InnerException != null)
                    CoverCmdLogger.WriteToLog("ERROR: " + Error.InnerException.ToString());
                CoverCmdLogger.WriteToLog("ERROR: " + Error.StackTrace.ToString());
                CoverCmdLogger.CloseLog();
                throw;
            }

            CoverCmdLogger.WriteToLog("INFO: " + CoverCmdOutputString);
            return CoverCmdErrorFlag;
        }

        /// <summary>
        /// Check for any error conditions in the Magellan Tool output.
        /// </summary>
        /// <param name="MagellanToolOutputString">The output string from the Magellan Tool.</param>
        /// <returns></returns>
        private bool CheckForMagellanErrors(string MagellanToolOutputString)
        {
            bool IsError = false;

            //Check for known error conditions
            //MagCore: Error
            if (MagellanToolOutputString.IndexOf("MagCore: Error") != -1)
                IsError = true;

            //MAGELLAN: ERROR
            if (MagellanToolOutputString.IndexOf("MAGELLAN: ERROR") != -1)
                IsError = true;

            //COVERCMD: Failed to save coverage information
            if (MagellanToolOutputString.IndexOf("COVERCMD: Failed to save coverage information") != -1)
                IsError = true;

            return IsError;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\LEOCodeCoverageTool\LEOCodeCoverageTool\Logger.cs ===
﻿using System;
using System.Text;
using System.IO;

namespace Wgx.Test.Solutions.Shared.Utilities.WGXCodeCoverageTool
{
    internal class Logger
    {
        private StreamWriter ILogger;

        /// <summary>
        /// Instantiate a new Log File.
        /// </summary>
        public Logger(string LogFileName)
        {
            try
            {
                if (File.Exists(LogFileName))
                    ILogger = File.AppendText(LogFileName);
                else
                    ILogger = File.CreateText(LogFileName);
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Write message to Log File.
        /// </summary>
        /// <param name="LogMessage">The Message to log.</param>
        public void WriteToLog(string LogMessage)
        {
            try
            {
                ILogger.WriteLine(DateTime.Now.ToString() + " " + LogMessage);
                ILogger.Flush();
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Closes the Log File.
        /// </summary>
        public void CloseLog()
        {
            try
            {
                ILogger.Close();
            }
            catch (Exception)
            {
                throw;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\PLTScheduler\PLTScheduler\Configuration.cs ===
﻿using System;
using System.Text;

namespace Test.Common.Utilities.PLTScheduler
{
    /// <summary>
    /// Represents the tool configuration.
    /// </summary>
    public class Configuration
    {
        /// <summary>
        /// The environments to test.
        /// E.g. INT, PPE, PROD
        /// </summary>
        public string[] Environments
        {
            get;
            set;
        }

        /// <summary>
        /// The type of PLT Tests to run.
        /// E.g. PLT1, PLT2
        /// </summary>
        public string[] PLTTypes
        {
            get;
            set;
        }

        /// <summary>
        /// The network types to test the target page on.
        /// </summary>
        public string[] NetworkTypes
        {
            get;
            set;
        }

        /// <summary>
        /// The path where the log files from this run will be stored.
        /// </summary>
        public string LogDumpLocation
        {
            get;
            set;
        }

        /// <summary>
        /// The number of days to keep the log files.
        /// Older files will be automatically deteleted.
        /// </summary>
        public int DaysToKeepLogFiles
        {
            get;
            set;
        }

        /// <summary>
        /// The settings for the external tools.
        /// </summary>
        public ExternalToolConfiguration ExternalToolSettings
        {
            get;
            set;
        }

        /// <summary>
        /// The settings for the database module.
        /// </summary>
        public DatabaseConfiguration DatabaseSettings
        {
            get;
            set;
        }

        /// <summary>
        /// The settings for mail module.
        /// </summary>
        public MailConfiguration MailSettings
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Represents the database configuration.
    /// </summary>
    public class DatabaseConfiguration
    {
        /// <summary>
        /// Indicates whether to upload the results to a database.
        /// </summary>
        public bool UploadToDatabase
        {
            get;
            set;
        }

        /// <summary>
        /// Represents the connection string for the SQL Server Database.
        /// </summary>
        public string SqlDatabaseConnectionString
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Represents the mailer configurations.
    /// </summary>
    public class MailConfiguration
    {
        /// <summary>
        /// The server name of the SMTP Server.
        /// </summary>
        public string SmtpServer
        {
            get;
            set;
        }

        /// <summary>
        /// The port number of the SMTP Server.
        /// </summary>
        public int SmtpPort
        {
            get;
            set;
        }

        /// <summary>
        /// The alias to send reports to.
        /// </summary>
        public string EmailTo
        {
            get;
            set;
        }

        /// <summary>
        /// The alias to send error reports to.
        /// </summary>
        public string EmailErrorsTo
        {
            get;
            set;
        }

        /// <summary>
        /// The sender alias of email reports.
        /// </summary>
        public string EmailFrom
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Represents the external tool configurations.
    /// </summary>
    public class ExternalToolConfiguration
    {
        /// <summary>
        /// The path and the file name mask for the PLT config ini files.
        /// </summary>
        public string PLTConfigFileMask
        {
            get;
            set;
        }

        /// <summary>
        /// The path and the file mask for Network Emulator Windows Toolkit
        /// profiles.
        /// </summary>
        public string NEWTProfileFileMask
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\LEOCodeCoverageTool\LEOCodeCoverageTool\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("WGXCodeCoverageTool")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("Microsoft Corporation")]
//[assembly: AssemblyProduct("WGXCodeCoverageTool")]
//[assembly: AssemblyCopyright("Copyright © Microsoft Corporation 2008")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("d56366ec-6c77-4ed9-9dfe-10e9910f7cf6")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
//[assembly: AssemblyVersion("1.0.0.1")]
//[assembly: AssemblyFileVersion("1.0.0.1")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\PLTScheduler\PLTScheduler\DatabasePLTData.cs ===
﻿using System;
using System.Text;

namespace Test.Common.Utilities.PLTScheduler
{
    /// <summary>
    /// Represents the PLT data for a link
    /// that can be uploaded to the database.
    /// </summary>
    public class DatabasePLTData
    {
        /// <summary>
        /// The Environment where the PLT data was captured.
        /// </summary>
        public string Environment
        {
            get;
            set;
        }

        /// <summary>
        /// The type of network on which the PLT data was captured.
        /// </summary>
        public string NetworkType
        {
            get;
            set;
        }

        /// <summary>
        /// The type of PLT test.
        /// </summary>
        public string PLTType
        {
            get;
            set;
        }

        /// <summary>
        /// The timestamp when the plt data was captured.
        /// </summary>
        public DateTime CaptureTime
        {
            get;
            set;
        }

        /// <summary>
        /// The link that was tested.
        /// </summary>
        public string HRef
        {
            get;
            set;
        }

        /// <summary>
        /// The Page Load Time in seconds.
        /// </summary>
        public float PLT
        {
            get;
            set;
        }

        /// <summary>
        /// The percent availability of the page.
        /// </summary>
        public int Availability
        {
            get;
            set;
        }

        /// <summary>
        /// Then number of errors on the page.
        /// </summary>
        public int ErrorCount
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\PLTScheduler\PLTScheduler\ConfigurationLayer.cs ===
﻿using System;
using System.IO;
using System.Text;
using System.Xml.Serialization;

namespace Test.Common.Utilities.PLTScheduler
{
    /// <summary>
    /// Represents the layer to interact with the tool configuration.
    /// </summary>
    public class ConfigurationLayer
    {
        private Configuration g_Config = null;

        /// <summary>
        /// Initializes a new instance of the configuration layer
        /// with the default configuration settings.
        /// </summary>
        public ConfigurationLayer()
        {
            g_Config = new Configuration()
            {
                DatabaseSettings = new DatabaseConfiguration()
                {
                    SqlDatabaseConnectionString= "Data Source=RTCGMUXSQLSGS01;Integrated Security=True;Pooling=False;Initial Catalog=PLTData",
                    UploadToDatabase = true
                },
                MailSettings = new MailConfiguration()
                {
                    EmailErrorsTo = "v-sour@microsoft.com",
                    EmailFrom = "v-sour@microsoft.com",
                    EmailTo = "v-sour@microsoft.com",
                    SmtpPort = 25,
                    SmtpServer = "SMTPHost"
                },
                ExternalToolSettings = new ExternalToolConfiguration()
                {
                    NEWTProfileFileMask = "C:\\Program Files\\Network Emulator for Windows Toolkit\\profiles\\{0}.xml",
                    PLTConfigFileMask = "ini\\{0}_{1}_PLTConfig.ini",
                },
                Environments = new string[] { "PPE", "PROD" },
                NetworkTypes = new string[] { "100Mbw", "56kModem" },
                PLTTypes = new string[] { "PLT1", "PLT2" },
                DaysToKeepLogFiles = 15,
                LogDumpLocation = @"\\SECGMUXUTLSGA01\Tools\PLTTrace",
            };
        }

        /// <summary>
        /// Initializes a new instance of the configuration layer
        /// and loads the configuration from the specified config file.
        /// </summary>
        /// <param name="ConfigurationFilename">The file to load the configuration from.</param>
        public ConfigurationLayer(string ConfigurationFilename)
        {
            XmlSerializer m_Serializer = new XmlSerializer(typeof(Configuration));

            try
            {
                using (TextReader m_Reader = new StreamReader(ConfigurationFilename))
                {
                    g_Config = (Configuration)m_Serializer.Deserialize(m_Reader);
                }
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Gets the loaded configuration.
        /// </summary>
        /// <returns>An object of Configuration class representing the loaded config.</returns>
        public Configuration GetConfiguration()
        {
            return g_Config;
        }

        /// <summary>
        /// Saves the loaded configuration to the specified XML file.
        /// </summary>
        /// <param name="SaveFileName">The name of the XML file.</param>
        public void SaveConfiguration(string SaveFileName)
        {
            XmlSerializer m_Serializer = new XmlSerializer(typeof(Configuration));

            using (TextWriter m_Writer = new StreamWriter(SaveFileName))
            {
                m_Serializer.Serialize(m_Writer, g_Config);
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\PLTScheduler\PLTScheduler\DatabaseLayer.cs ===
﻿using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Text;

namespace Test.Common.Utilities.PLTScheduler
{
    /// <summary>
    /// Represents the database interaction layer
    /// </summary>
    public class DatabaseLayer
    {
        private readonly string g_DatabaseConnectionString = String.Empty;
        private SqlConnection g_DatabaseConnection = null;

        /// <summary>
        /// Initializes a new instance of the Database layer.
        /// </summary>
        /// <param name="DatabaseConnectionString">The connection string to connect to the SQL Server database.</param>
        public DatabaseLayer(string DatabaseConnectionString)
        {
            g_DatabaseConnectionString = DatabaseConnectionString;
        }

        /// <summary>
        /// Uploads the PLT data to the database.
        /// </summary>
        /// <param name="PLTData">The PLT Data to upload.</param>
        public void UploadPLTData(List<DatabasePLTData> PLTData)
        {
            SqlCommand m_SPCommand = null;

            try
            {
                ConnectDatabase();

                //Create command
                m_SPCommand = new SqlCommand();
                m_SPCommand.Connection = g_DatabaseConnection;
                m_SPCommand.CommandText = "spAddPLTData";
                m_SPCommand.CommandType = CommandType.StoredProcedure;

                foreach (DatabasePLTData m_Item in PLTData)
                {
                    m_SPCommand.Parameters.Add(new SqlParameter("@Environment", SqlDbType.VarChar)).Value = m_Item.Environment;
                    m_SPCommand.Parameters.Add(new SqlParameter("@NetworkType", SqlDbType.VarChar)).Value = m_Item.NetworkType;
                    m_SPCommand.Parameters.Add(new SqlParameter("@PLTType", SqlDbType.VarChar)).Value = m_Item.PLTType;
                    m_SPCommand.Parameters.Add(new SqlParameter("@CaptureTime", SqlDbType.DateTime)).Value = m_Item.CaptureTime;
                    m_SPCommand.Parameters.Add(new SqlParameter("@HRef", SqlDbType.VarChar)).Value = m_Item.HRef;
                    m_SPCommand.Parameters.Add(new SqlParameter("@Plt", SqlDbType.Float)).Value = m_Item.PLT;
                    m_SPCommand.Parameters.Add(new SqlParameter("@Availability", SqlDbType.Int)).Value = m_Item.Availability;
                    m_SPCommand.Parameters.Add(new SqlParameter("@ErrorCount", SqlDbType.Int)).Value = m_Item.ErrorCount;

                    m_SPCommand.ExecuteNonQuery();
                    m_SPCommand.Parameters.Clear();
                }
            }
            catch (Exception)
            {
                throw;
            }
            finally
            {
                DisconnectDatabase();
            }
        }

        /// <summary>
        /// Establish connection with Database
        /// </summary>
        private void ConnectDatabase()
        {
            if (g_DatabaseConnection == null)
            {
               
                g_DatabaseConnection = new SqlConnection(g_DatabaseConnectionString);

                try
                {
                    g_DatabaseConnection.Open();
                }
                catch (Exception)
                {
                    throw;
                }
            }
        }

        /// <summary>
        /// Closes the connection with Database
        /// </summary>
        private void DisconnectDatabase()
        {
            try
            {
                g_DatabaseConnection.Close();
                g_DatabaseConnection = null;
            }
            catch { }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\PLTScheduler\PLTScheduler\LogTransportLayer.cs ===
﻿using System;
using System.IO;
using System.Text;

namespace Test.Common.Utilities.PLTScheduler
{
    /// <summary>
    /// Represents the transport layer for all log files.
    /// </summary>
    public class LogTransportLayer
    {
        string g_LogDumpLocation = "";
        int g_DaysToKeepLogs;
        private const string G_REPORTFOLDER = @"\reports\";

        /// <summary>
        /// Initializes a new instance of the LogTransportLayer class.
        /// </summary>
        /// <param name="Config"></param>
        public LogTransportLayer(Configuration Config)
        {
            g_LogDumpLocation = Config.LogDumpLocation;
            g_DaysToKeepLogs = Config.DaysToKeepLogFiles;
        }

        /// <summary>
        /// Creates a log folder for copying the log files.
        /// </summary>
        public void CreateLogFolder()
        {
            string m_TimeStamp = DateTime.Now.Year.ToString() + "-" +
                                 DateTime.Now.Month.ToString() + "-" +
                                 DateTime.Now.Day.ToString();

            g_LogDumpLocation += "\\" + m_TimeStamp;
            try
            {
                if (!Directory.Exists(g_LogDumpLocation))
                    Directory.CreateDirectory(g_LogDumpLocation);
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Gets the path where the log files were archived.
        /// </summary>
        public string LogArchiveLocation
        {
            get { return g_LogDumpLocation; }
        }

        /// <summary>
        /// Moves all available log files to the log dump location.
        /// </summary>
        public void MoveAllLogFiles()
        {
            try
            {
                //Move debug.log and error.log to report folder
                if (File.Exists(Directory.GetCurrentDirectory() + "\\PLTDaemonDebugLog.log"))
                    File.Move(Directory.GetCurrentDirectory() + "\\PLTDaemonDebugLog.log",
                        Directory.GetCurrentDirectory() + G_REPORTFOLDER + "PLTDaemonDebugLog.log");

                if (File.Exists(Directory.GetCurrentDirectory() + "\\HTTPWatchDebugLog.log"))
                    File.Move(Directory.GetCurrentDirectory() + "\\HTTPWatchDebugLog.log",
                              Directory.GetCurrentDirectory() + G_REPORTFOLDER + "HTTPWatchDebugLog.log");

                //Now copy the entire report folder to dump location
                CopyDirectory(Directory.GetCurrentDirectory() + G_REPORTFOLDER,
                              g_LogDumpLocation);

            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Deletes all log folder older than the log retention period.
        /// </summary>
        public void PurgeLogFolder()
        {
            try
            {
                foreach (string m_Directory in Directory.GetDirectories(g_LogDumpLocation))
                {
                    string m_DirectoryName = m_Directory.Substring(m_Directory.LastIndexOf("\\") + 1);
                    if ((DateTime.Now - GetDateTimeFromFolderName(m_DirectoryName)).Days > g_DaysToKeepLogs)
                        Directory.Delete(m_Directory, true);
                }
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Gets the folder date timestamp from the folder name.
        /// </summary>
        /// <param name="FolderName">The name of the folder.</param>
        /// <returns></returns>
        private DateTime GetDateTimeFromFolderName(string FolderName)
        {
            DateTime m_FolderDate;
            DateTime.TryParse(FolderName, out m_FolderDate);

            return m_FolderDate;
        }

        /// <summary>
        /// Copies the contents of the source directory to the destination directory.
        /// </summary>
        /// <param name="SourceDirectory">The directory to copy from.</param>
        /// <param name="DestinationDirectory">The directory to copy to.</param>
        private void CopyDirectory(string SourceDirectory, string DestinationDirectory)
        {
            string[] m_FSEntries;

            if (DestinationDirectory[DestinationDirectory.Length - 1] != Path.DirectorySeparatorChar)
                DestinationDirectory += Path.DirectorySeparatorChar;

            if (!Directory.Exists(DestinationDirectory))
                Directory.CreateDirectory(DestinationDirectory);

            m_FSEntries = Directory.GetFileSystemEntries(SourceDirectory);

            foreach (string m_FSEntry in m_FSEntries)
            {
                if (Directory.Exists(m_FSEntry))
                    CopyDirectory(m_FSEntry, DestinationDirectory + Path.GetFileName(m_FSEntry));
                else
                    File.Copy(m_FSEntry, DestinationDirectory + Path.GetFileName(m_FSEntry), true);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\PLTScheduler\PLTScheduler\Logger.cs ===
﻿using System;
using System.IO;
using System.Text;

namespace Test.Common.Utilities.PLTScheduler
{
    /// <summary>
    /// Represents the logger for the Daemon.
    /// </summary>
    public class Logger
    {
        private StreamWriter g_LogFile = null;
        private readonly string G_LOGFILENAME = String.Empty;

        /// <summary>
        /// The level of the log entry being written.
        /// </summary>
        public enum LogLevel
        {
            /// <summary>
            /// Informational message.
            /// </summary>
            Message = 1,
            /// <summary>
            /// Warning message.
            /// </summary>
            Warning = 2,
            /// <summary>
            /// Exception message.
            /// </summary>
            Exception = 3
        }

        /// <summary>
        /// Initializes a new instance of the Daemon Logger with the specified
        /// log file name.
        /// </summary>
        /// <param name="LogFileName">The name of the Log File.</param>
        public Logger(string LogFileName)
        {
            G_LOGFILENAME = LogFileName;
            try
            {
                g_LogFile = new StreamWriter(G_LOGFILENAME, false);
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Gets the name of the Log File.
        /// </summary>
        public string LogFileName
        {
            get { return G_LOGFILENAME; }
        }

        /// <summary>
        /// Closes this log file.
        /// </summary>
        public void Close()
        {
            try
            {
                g_LogFile.Close();
                g_LogFile = null;
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Writes a log entry to the log file with the specified
        /// Logentry level.
        /// </summary>
        /// <param name="Level">The level of the log entry being written.</param>
        /// <param name="LogEntry">The log entry to write to the log file.</param>
        public void WriteLine(LogLevel Level, string LogEntry)
        {
            string m_TimeStamp = DateTime.Now.ToString() + " ";

            try
            {
                if (!String.IsNullOrEmpty(LogEntry))
                {
                    switch (Level)
                    {
                        case LogLevel.Warning:
                            g_LogFile.WriteLine(m_TimeStamp + "WARN: " + LogEntry);
                            break;
                        case LogLevel.Message:
                            g_LogFile.WriteLine(m_TimeStamp + "INFO: " + LogEntry);
                            break;
                        case LogLevel.Exception:
                            g_LogFile.WriteLine(m_TimeStamp + "ERROR: " + LogEntry);
                            break;
                    }
                    g_LogFile.Flush();
                }
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Writes a log entry for the specified thread to the log file with the specified
        /// Logentry level.
        /// </summary>
        /// <param name="Level">The level of the log entry being written.</param>
        /// <param name="ThreadName">The name of the thread for which this entry is being logged.</param>
        /// <param name="LogEntry">The log entry to write to the log file.</param>
        public void WriteLine(LogLevel Level, string ThreadName, string LogEntry)
        {
            string m_TimeStamp = DateTime.Now.ToString() + " ";

            try
            {
                if (!String.IsNullOrEmpty(LogEntry))
                {
                    switch (Level)
                    {
                        case LogLevel.Warning:
                            g_LogFile.WriteLine(m_TimeStamp + ThreadName + "::WARN: " + LogEntry);
                            break;
                        case LogLevel.Message:
                            g_LogFile.WriteLine(m_TimeStamp + ThreadName + "::INFO: " + LogEntry);
                            break;
                        case LogLevel.Exception:
                            g_LogFile.WriteLine(m_TimeStamp + ThreadName + "::ERROR: " + LogEntry);
                            break;
                    }
                    g_LogFile.Flush();
                }
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Writes the specified Exception to the log file.
        /// </summary>
        /// <param name="Error">The exception to write to the log file.</param>
        public void WriteLine(Exception Error)
        {
            string m_TimeStamp = DateTime.Now.ToString() + " ";

            try
            {
                g_LogFile.WriteLine(m_TimeStamp + "ERROR: " + Error);
                g_LogFile.Flush();
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Writes the specified Exception to the log file for the specified thread.
        /// </summary>
        /// <param name="ThreadName">The name of the thread for which this entry is being logged.</param>
        /// <param name="Error">The exception to write to the log file.</param>
        public void WriteLine(string ThreadName, Exception Error)
        {
            string m_TimeStamp = DateTime.Now.ToString() + " ";

            try
            {
                g_LogFile.WriteLine(m_TimeStamp + ThreadName + "::ERROR: " + Error);
                g_LogFile.Flush();
            }
            catch (Exception)
            {
                throw;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\PLTScheduler\PLTScheduler\Mailer.cs ===
﻿using System;
using System.Text;
using System.Net.Mail;

namespace Test.Common.Utilities.PLTScheduler
{
    /// <summary>
    /// Represents the tool mailing capabilities.
    /// </summary>
    public static class Mailer
    {
        /// <summary>
        /// Emails a HTML report..
        /// </summary>
        /// <param name="Subject">The subject of the mail.</param>
        /// <param name="HTMLMailContent">The HTML content of the mail.</param>
        /// <param name="Config">The tool configuration object.</param>
        public static void SendReportMail(string Subject, StringBuilder HTMLMailContent, Configuration Config, Logger ToolLogger)
        {
            try
            {
                SendMail(Subject,
                         HTMLMailContent.ToString(),
                         Config.MailSettings.EmailTo,
                         Config.MailSettings.EmailFrom,
                         Config.MailSettings.SmtpServer,
                         Config.MailSettings.SmtpPort
                        );
            }
            catch (Exception Error)
            {
                ToolLogger.WriteLine(Logger.LogLevel.Exception, "An error occured while sending mail.");
                ToolLogger.WriteLine(Error);
                throw;
            }
        }

        /// <summary>
        /// Emails an error content.
        /// </summary>
        /// <param name="Subject">The subject of the mail.</param>
        /// <param name="HTMLMailContent">The HTML content of the mail.</param>
        /// <param name="Config">The tool configuration object.</param>
        public static void SendErrorMail(string Subject, string HTMLMailContent, Configuration Config)
        {
            try
            {
                SendMail(Subject,
                         HTMLMailContent,
                         Config.MailSettings.EmailErrorsTo,
                         Config.MailSettings.EmailFrom,
                         Config.MailSettings.SmtpServer,
                         Config.MailSettings.SmtpPort
                        );
            }
            catch { }
        }

        /// <summary>
        /// Sends the final completion mail.
        /// </summary>
        /// <param name="Subject">The subject of the mail.</param>
        /// <param name="Content">The content of the mail.</param>
        /// <param name="Config">The tool configuration object.</param>
        /// <param name="LogFile">The tool log filename and location.</param>
        public static void SendCompletionMail(string Subject, string Content, Configuration Config, string LogFile)
        {
            try
            {
                Attachment m_LogAttachment = new Attachment(LogFile);

                SendMail(Subject,
                         Content,
                         Config.MailSettings.EmailErrorsTo,
                         Config.MailSettings.EmailFrom,
                         Config.MailSettings.SmtpServer,
                         Config.MailSettings.SmtpPort,
                         m_LogAttachment
                        );
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Sends a mail.
        /// </summary>
        /// <param name="Subject">The subject of the mail.</param>
        /// <param name="Content">The HTML content of the mail.</param>
        /// <param name="To">Mail receipient.</param>
        /// <param name="From">Mail sender.</param>
        /// <param name="SMTPServer">The SMTP Server name.</param>
        /// <param name="SMTPPort">The SMTP Server port number.</param>
        private static void SendMail(string Subject, string Content, string To, string From, string SMTPServer, int SMTPPort)
        {
            try
            {
                SendMail(Subject, Content, To, From, SMTPServer, SMTPPort, null);
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Sends a mail.
        /// </summary>
        /// <param name="Subject">The subject of the mail.</param>
        /// <param name="Content">The HTML content of the mail.</param>
        /// <param name="To">Mail receipient.</param>
        /// <param name="From">Mail sender.</param>
        /// <param name="SMTPServer">The SMTP Server name.</param>
        /// <param name="SMTPPort">The SMTP Server port number.</param>
        /// <param name="MailAttachment">The attachment for the mail.</param>
        private static void SendMail(string Subject, string Content, string To, string From,
            string SMTPServer, int SMTPPort, Attachment MailAttachment)
        {
            try
            {
                MailMessage m_EmailMessage = new MailMessage(From, To);
                SmtpClient m_MailClient = new SmtpClient(SMTPServer, SMTPPort);

                m_EmailMessage.Subject = Subject;
                m_EmailMessage.IsBodyHtml = true;
                m_EmailMessage.Body = Content;
                if (MailAttachment != null)
                    m_EmailMessage.Attachments.Add(MailAttachment);
                m_MailClient.UseDefaultCredentials = true;

                m_MailClient.Send(m_EmailMessage);
            }
            catch (Exception)
            {
                throw;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\PLTScheduler\PLTScheduler\LinkPLTStats.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;

namespace Test.Common.Utilities.PLTScheduler
{
    /// <summary>
    /// Represents the PLT stats for a link.
    /// </summary>
    public class LinkPLTStats
    {
        /// <summary>
        /// The number of iterations made during the PLT1 test.
        /// NOTE: PLTs > 60 will not be added to this iteration count.
        /// </summary>
        public int IterationsPLT1
        {
            get;
            set;
        }

        /// <summary>
        /// The number of iterations made during the PLT2 test.
        /// NOTE: PLTs > 60 will not be added to this iteration count.
        /// </summary>
        public int IterationsPLT2
        {
            get;
            set;
        }

        /// <summary>
        /// The total page load time 1 (PLT1) across all iterations.
        /// </summary>
        public float TotalPLT1
        {
            get;
            set;
        }

        /// <summary>
        /// The total page load time 2 (PLT2) across all iterations.
        /// </summary>
        public float TotalPLT2
        {
            get;
            set;
        }

        /// <summary>
        /// The total availability of the page across all iterations.
        /// </summary>
        public long TotalAvailability
        {
            get;
            set;
        }

        /// <summary>
        /// The number of total iterations for all PLT Tests.
        /// </summary>
        public int TotalIterations
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\PLTScheduler\PLTScheduler\ReportLayer.cs ===
﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.IO;

namespace Test.Common.Utilities.PLTScheduler
{
    /// <summary>
    /// Represents the runtime reporting layer.
    /// </summary>
    public static class ReportLayer
    {
        private const string G_MASTER_REPORTFILE = "Cumulative_PLTReport.csv";
        private const string G_REPORTFOLDER = @"\reports\";

        /// <summary>
        /// Compiles the cumulative report for all the tests.
        /// </summary>
        /// <param name="Config">The tool configuration object.</param>
        /// <param name="ToolLogger">The tool logger object.</param>
        public static void CompileCumulativeReport(Configuration Config, Logger ToolLogger)
        {
            StreamWriter m_MasterReportWriter = null;
            string m_ReadLine = String.Empty;

            try
            {
                m_MasterReportWriter = new StreamWriter(Directory.GetCurrentDirectory() + G_REPORTFOLDER + G_MASTER_REPORTFILE);
                foreach (string m_Environment in Config.Environments)
                {
                    foreach (string m_NetworkType in Config.NetworkTypes)
                    {
                        foreach (string m_PLTType in Config.PLTTypes)
                        {
                            StreamReader m_ReportFileReader = new StreamReader(string.Format("{3}{0}_{1}_{2}.csv",
                                                                               m_Environment,
                                                                               m_NetworkType,
                                                                               m_PLTType,
                                                                               Directory.GetCurrentDirectory() + G_REPORTFOLDER));

                            while (!m_ReportFileReader.EndOfStream)
                            {
                                m_ReadLine = m_ReportFileReader.ReadLine();
                                m_ReadLine = string.Format("{0},{1},{2},{3}", m_Environment, m_NetworkType, m_PLTType, m_ReadLine);
                                m_MasterReportWriter.WriteLine(m_ReadLine);
                                m_MasterReportWriter.Flush();
                                m_ReadLine = String.Empty;
                            }

                            m_ReportFileReader.Close();
                            m_ReportFileReader = null;
                        }
                    }
                }
                m_MasterReportWriter.Close();
            }
            catch (Exception Error)
            {
                ToolLogger.WriteLine(Logger.LogLevel.Exception, "An error occured while trying compile Cumulative Report.");
                ToolLogger.WriteLine(Error);
                throw;
            }
        }

        /// <summary>
        /// Archives the specified report file to the environment file
        /// and deletes the report file.
        /// </summary>
        /// <param name="ReportFile">The Report File to archive.</param>
        /// <param name="Environment">The environment to which the report belongs.</param>
        /// <param name="NetworkType">The network type to which the report belongs.</param>
        /// <param name="PLTType">The plt type to which the report belongs.</param>
        /// <param name="ToolLogger">The tool logger object.</param>
        public static void ArchiveToEnvironmentReport(string ReportFile, string Environment, string NetworkType, string PLTType, Logger ToolLogger)
        {
            StreamWriter m_ReportWriter = null;
            StreamReader m_ReportReader = null;
            try
            {
                m_ReportReader = new StreamReader(Directory.GetCurrentDirectory() + G_REPORTFOLDER + "\\" + ReportFile);
                m_ReportWriter = new StreamWriter(string.Format("{3}{0}_{1}_{2}.csv",
                                                                Environment,
                                                                NetworkType,
                                                                PLTType,
                                                                Directory.GetCurrentDirectory() + G_REPORTFOLDER));

                while (!m_ReportReader.EndOfStream)
                {
                    m_ReportWriter.WriteLine(m_ReportReader.ReadLine());
                    m_ReportWriter.Flush();
                }
                m_ReportWriter.Close();
                m_ReportReader.Close();
                m_ReportReader = null;
                m_ReportWriter = null;

                //Delete original report file
                File.Delete(Directory.GetCurrentDirectory() + G_REPORTFOLDER + "\\" + ReportFile);
            }
            catch (Exception Error)
            {
                ToolLogger.WriteLine(Logger.LogLevel.Exception, "An error occured while trying to archive '" + ReportFile + "' to environment file.");
                ToolLogger.WriteLine(Error);
                throw;
            }
        }

        /// <summary>
        /// Compiles the report for the specified environment and network type.
        /// </summary>
        /// <param name="Environment">The environment to compile report for.</param>
        /// <param name="NetworkType">The network type to compile report for.</param>
        /// <param name="Config">The tool configuration object.</param>
        /// <param name="ToolLogger">The tool logger object.</param>
        /// <param name="DefaultPageTimeOut">The default page timeout in seconds. Any pages that did not load will be assigned this PLT value.</param>
        public static IDictionary<string, LinkPLTStats> CompileReportForEnvironment(string Environment, string NetworkType,
            Configuration Config, Logger ToolLogger)
        {
            IDictionary<string, LinkPLTStats> m_EnvironmentReport = new Dictionary<string, LinkPLTStats>();
            StreamReader m_ReportReader = null;

            ToolLogger.WriteLine(Logger.LogLevel.Message, "Compiliing report for " + Environment + " on " + NetworkType + " connection.");

            try
            {
                foreach (string m_PLTType in Config.PLTTypes)
                {
                    m_ReportReader = new StreamReader(string.Format("{3}{0}_{1}_{2}.csv",
                                                                Environment,
                                                                NetworkType,
                                                                m_PLTType,
                                                                Directory.GetCurrentDirectory() + G_REPORTFOLDER)
                                                      );
                    while (!m_ReportReader.EndOfStream)
                    {
                        string[] m_ReadLineElements = m_ReportReader.ReadLine().Split(',');
                        long m_TotalAvailability =
                            long.TryParse(m_ReadLineElements[3], out m_TotalAvailability) == true ? m_TotalAvailability : 0;
                        float m_TotalPLT = float.Parse(m_ReadLineElements[2]);

                        if (!m_EnvironmentReport.ContainsKey(m_ReadLineElements[1]))
                        {
                            switch (m_PLTType)
                            {
                                case "PLT1":
                                    if (m_TotalPLT < 60.0)
                                    {
                                        m_EnvironmentReport.Add(m_ReadLineElements[1],
                                                                new LinkPLTStats()
                                                                {
                                                                    IterationsPLT1 = 1,
                                                                    IterationsPLT2 = 0,
                                                                    TotalAvailability = m_TotalAvailability,
                                                                    TotalPLT2 = 0,
                                                                    TotalPLT1 = m_TotalPLT,
                                                                    TotalIterations = 1
                                                                }
                                                               );
                                    }
                                    else
                                    {
                                        m_EnvironmentReport.Add(m_ReadLineElements[1],
                                                                new LinkPLTStats()
                                                                {
                                                                    IterationsPLT1 = 0,
                                                                    IterationsPLT2 = 0,
                                                                    TotalAvailability = m_TotalAvailability,
                                                                    TotalPLT2 = 0,
                                                                    TotalPLT1 = 0,
                                                                    TotalIterations = 1
                                                                }
                                                               );
                                    }
                                    break;
                                case "PLT2":
                                    if (m_TotalPLT < 60.0)
                                    {
                                        m_EnvironmentReport.Add(m_ReadLineElements[1],
                                                                new LinkPLTStats()
                                                                {
                                                                    IterationsPLT2 = 1,
                                                                    IterationsPLT1 = 0,
                                                                    TotalAvailability = m_TotalAvailability,
                                                                    TotalPLT2 = m_TotalPLT,
                                                                    TotalPLT1 = 0,
                                                                    TotalIterations = 1
                                                                }
                                                               );
                                    }
                                    else
                                    {
                                        m_EnvironmentReport.Add(m_ReadLineElements[1],
                                                                new LinkPLTStats()
                                                                {
                                                                    IterationsPLT2 = 0,
                                                                    IterationsPLT1 = 0,
                                                                    TotalAvailability = m_TotalAvailability,
                                                                    TotalPLT2 = 0,
                                                                    TotalPLT1 = 0,
                                                                    TotalIterations = 1
                                                                }
                                                               );
                                    }
                                    break;
                            }
                        }
                        else
                        {
                            m_EnvironmentReport[m_ReadLineElements[1]].TotalAvailability += m_TotalAvailability;
                            m_EnvironmentReport[m_ReadLineElements[1]].TotalIterations++;
                            switch (m_PLTType)
                            {
                                case "PLT1":
                                    if (m_TotalPLT < 60.0)
                                    {
                                        m_EnvironmentReport[m_ReadLineElements[1]].IterationsPLT1++;
                                        m_EnvironmentReport[m_ReadLineElements[1]].TotalPLT1 += m_TotalPLT;
                                    }
                                    break;
                                case "PLT2":
                                    if (m_TotalPLT < 60.0)
                                    {
                                        m_EnvironmentReport[m_ReadLineElements[1]].IterationsPLT2++;
                                        m_EnvironmentReport[m_ReadLineElements[1]].TotalPLT2 += m_TotalPLT;
                                    }
                                    break;
                            }
                        }
                    }
                }
                m_ReportReader.Close();
                m_ReportReader = null;
            }
            catch (Exception Error)
            {
                ToolLogger.WriteLine(Logger.LogLevel.Exception, "An error occured while trying to compile environment report for " + Environment + "(" + NetworkType + ").");
                ToolLogger.WriteLine(Error);
                throw;
            }

            return m_EnvironmentReport;
        }

        /// <summary>
        /// Gets an object for the cumulative PLT data
        /// which can be uploaded to the database.
        /// </summary>
        /// <param name="DefaultPageTimeOut">The default page timeout in seconds. Any pages that did not load will be assigned this PLT value.</param>
        /// <returns>A list of DatabasePLTData objects.</returns>
        public static List<DatabasePLTData> GetCumulativeDatabaseData()
        {
            List<DatabasePLTData> m_CumulativeDBObj = new List<DatabasePLTData>();
            StreamReader m_CumulativeReportReader = null;

            if (File.Exists(Directory.GetCurrentDirectory() + G_REPORTFOLDER + G_MASTER_REPORTFILE))
            {
                try
                {
                    m_CumulativeReportReader = new StreamReader(Directory.GetCurrentDirectory() + G_REPORTFOLDER + G_MASTER_REPORTFILE);

                    while (!m_CumulativeReportReader.EndOfStream)
                    {
                        string[] m_PLTElements = m_CumulativeReportReader.ReadLine().Split(',');
                        if (m_PLTElements.Length >= 7)
                        {
                            DatabasePLTData m_PLTData = new DatabasePLTData()
                            {
                                Environment = m_PLTElements[0],
                                NetworkType = m_PLTElements[1],
                                PLTType = m_PLTElements[2],
                                CaptureTime = DateTime.Parse(m_PLTElements[3]),
                                HRef = m_PLTElements[4],
                                Availability = int.Parse(m_PLTElements[6]),
                                PLT = float.Parse(m_PLTElements[5]),
                                ErrorCount = int.Parse(m_PLTElements[7])
                            };

                            m_CumulativeDBObj.Add(m_PLTData);
                        }
                    }
                }
                catch (Exception)
                {
                    throw;
                }
                finally
                {
                    m_CumulativeReportReader.Close();
                    m_CumulativeReportReader = null;
                }
            }

            return m_CumulativeDBObj;
        }

        /// <summary>
        /// Gererates the HTML Report for the PLT Data of the specified environment and Network Type.
        /// </summary>
        /// <param name="PLTData">The PLT Statistical data.</param>
        /// <param name="Environment">The environment for which the report will be generated.</param>
        /// <param name="NetworkType">The network type for which the report will be generated.</param>
        /// <param name="TotalRunTime">The total test run time.</param>
        /// <param name="ToolLogger">The tool logger object.</param>
        /// <returns>An object of StringBuilder representing the HTML Report.</returns>
        public static StringBuilder GenerateHTMLReport(IDictionary<string, LinkPLTStats> PLTData, string Environment, string NetworkType,
            TimeSpan TotalRunTime, Logger ToolLogger)
        {
            StringBuilder m_HTMLReport = new StringBuilder();
            int m_RowCount = 0;

            //Create the total runtime string
            string m_RunTime = TotalRunTime.Days > 0 ? TotalRunTime.Days.ToString() + " days " : "";
            m_RunTime += TotalRunTime.Hours > 0 ? TotalRunTime.Hours.ToString() + " hours " : "";
            m_RunTime += TotalRunTime.Minutes > 0 ? TotalRunTime.Minutes.ToString() + " minutes " : "";
            m_RunTime += TotalRunTime.Seconds > 0 ? TotalRunTime.Seconds.ToString() + " seconds" : "";
            m_RunTime = string.IsNullOrEmpty(m_RunTime) ? "0 Minutes" : m_RunTime;

            try
            {
                m_HTMLReport.AppendLine(@"<table style=""width: 800px"" cellspacing=""0"">");
                m_HTMLReport.AppendLine(@"  <tr>");
                m_HTMLReport.AppendLine(@"      <td colspan=""2"" style=""border: 1px solid #000000; font-family: Arial Black; font-size: 18px; color: #FFFFFF; background-color: #000000;"">Page Load Time Test Results</td>");
                m_HTMLReport.AppendLine(@"  </tr>");
                m_HTMLReport.AppendLine(@"  <tr>");
                m_HTMLReport.AppendLine(@"      <td style=""font-family: Tahoma; font-size: 13px; width: 50%; padding-top: 2px; padding-bottom: 2px; padding-left: 3px; background-color: #548DD0; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-right-color: #000000; border-bottom-color: #000000; border-left-color: #000000;"">");
                m_HTMLReport.AppendLine(@"        <strong>Environment: " + Environment + "</strong></td>");
                m_HTMLReport.AppendLine(@"      <td style=""font-family: Tahoma; font-size: 13px; width: 50%; padding-top: 2px; padding-bottom: 2px; padding-left: 3px; background-color: #548DD0; border-bottom-style: solid; border-right-style: solid; border-right-width: 1px; border-bottom-width: 1px; border-right-color: #000000; border-bottom-color: #000000; border-left-color: #000000;"">");
                m_HTMLReport.AppendLine(@"        <strong>Network Type: " + NetworkType + "</strong></td>");
                m_HTMLReport.AppendLine(@"  </tr>");
                m_HTMLReport.AppendLine(@"  <tr>");
                m_HTMLReport.AppendLine(@"      <td colspan=""2"" style=""font-family: Tahoma; font-size: 13px; width: 50%; padding-top: 2px; padding-bottom: 2px; padding-left: 3px; background-color: #99BBE3; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-right-color: #000000; border-bottom-color: #000000; border-left-color: #000000;"">");
                m_HTMLReport.AppendLine(@"        <strong>Test Run Time: " + m_RunTime + "</strong></td>");
                m_HTMLReport.AppendLine(@"  </tr>");
                m_HTMLReport.AppendLine(@"</table>");
                m_HTMLReport.AppendLine(@"<table cellspacing=""0"" style=""width: 800px"">");
                m_HTMLReport.AppendLine(@"  <tr>");
                m_HTMLReport.AppendLine(@"      <td style=""border-left: 1px solid #000000; border-right: 1px solid #000000; border-bottom: 1px solid #000000; font-family: Tahoma; font-size: 10px; font-weight: bold; background-color: #808080; padding-bottom: 2px; padding-top: 2px; padding-left: 2px; color: #FFFFFF; width: 500px;"" valign=""top"">Target URL</td>");
                m_HTMLReport.AppendLine(@"      <td style=""border-right: 1px solid #000000; border-bottom: 1px solid #000000; font-family: Tahoma; font-size: 10px; font-weight: bold; background-color: #808080; padding-bottom: 2px; padding-top: 2px; padding-left: 2px; color: #FFFFFF; width: 60px;"" valign=""top"" align=""center"">");
                m_HTMLReport.AppendLine(@"         <span style=""font-family: Tahoma; font-size: 10px; font-weight: bold; color: #FFFFFF;"">PLT1</span><br/>");
                m_HTMLReport.AppendLine(@"         <span style=""font-family: Tahoma; font-size: 10px; font-weight: bold; color: #FFFFFF;"">Average</span></td>");
                m_HTMLReport.AppendLine(@"      <td style=""border-right: 1px solid #000000; border-bottom: 1px solid #000000; font-family: Tahoma; font-size: 10px; font-weight: bold; background-color: #808080; padding-bottom: 2px; padding-top: 2px; padding-left: 2px; color: #FFFFFF; width: 60px;"" valign=""top"" align=""center"">");
                m_HTMLReport.AppendLine(@"         <span style=""font-family: Tahoma; font-size: 10px; font-weight: bold; color: #FFFFFF;"">PLT1</span><br/>");
                m_HTMLReport.AppendLine(@"         <span style=""font-family: Tahoma; font-size: 10px; font-weight: bold; color: #FFFFFF;"">Iteration</span></td>");
                m_HTMLReport.AppendLine(@"      <td style=""border-right: 1px solid #000000; border-bottom: 1px solid #000000; font-family: Tahoma; font-size: 10px; font-weight: bold; background-color: #808080; padding-bottom: 2px; padding-top: 2px; padding-left: 2px; color: #FFFFFF; width: 60px;"" valign=""top"" align=""center"">");
                m_HTMLReport.AppendLine(@"         <span style=""font-family: Tahoma; font-size: 10px; font-weight: bold; color: #FFFFFF;"">PLT2</span><br/>");
                m_HTMLReport.AppendLine(@"         <span style=""font-family: Tahoma; font-size: 10px; font-weight: bold; color: #FFFFFF;"">Average</span></td>");
                m_HTMLReport.AppendLine(@"      <td style=""border-right: 1px solid #000000; border-bottom: 1px solid #000000; font-family: Tahoma; font-size: 10px; font-weight: bold; background-color: #808080; padding-bottom: 2px; padding-top: 2px; padding-left: 2px; color: #FFFFFF; width: 60px;"" valign=""top"" align=""center"">");
                m_HTMLReport.AppendLine(@"         <span style=""font-family: Tahoma; font-size: 10px; font-weight: bold; color: #FFFFFF;"">PLT2</span><br/>");
                m_HTMLReport.AppendLine(@"         <span style=""font-family: Tahoma; font-size: 10px; font-weight: bold; color: #FFFFFF;"">Iteration</span></td>");
                m_HTMLReport.AppendLine(@"      <td style=""border-right: 1px solid #000000; border-bottom: 1px solid #000000; font-family: Tahoma; font-size: 10px; font-weight: bold; background-color: #808080; padding-bottom: 2px; padding-top: 2px; padding-left: 2px; color: #FFFFFF; width: 60px;"" valign=""top"" align=""center"">");
                m_HTMLReport.AppendLine(@"         <span style=""font-family: Tahoma; font-size: 10px; font-weight: bold; color: #FFFFFF;"">Percent</span><br/>");
                m_HTMLReport.AppendLine(@"         <span style=""font-family: Tahoma; font-size: 10px; font-weight: bold; color: #FFFFFF;"">Availability</span></td>");
                m_HTMLReport.AppendLine(@"  </tr>");

                //Create the data row

                foreach (KeyValuePair<string, LinkPLTStats> m_DataRow in PLTData)
                {
                    float m_AvgAvailability = 0f;

                    //Evaluate Row Color
                    string m_RowColor = (m_RowCount % 2) == 0 ? "#FFFFFF" : "#F1F1F1";
                    m_RowColor = m_DataRow.Value.IterationsPLT1 == m_DataRow.Value.IterationsPLT2 ? m_RowColor : "#FFFF00";

                    if (m_DataRow.Value.TotalIterations != 0)
                    {
                        m_AvgAvailability = (float)(m_DataRow.Value.TotalAvailability / m_DataRow.Value.TotalIterations);
                        m_RowColor = m_AvgAvailability < 100 ? "#FF0000" : m_RowColor;
                    }

                    m_HTMLReport.AppendLine(@"  <tr>");
                    m_HTMLReport.AppendFormat(@"    <td style=""background-color: {0}; border-left: 1px solid #000000; border-right: 1px solid #000000; border-bottom: 1px solid #000000; width: 500px; font-family: Tahoma; font-size: 11px; color: #000000; overflow: auto; padding-left: 2px; padding-top: 2px; padding-bottom: 2px; word-break:break-all;"">", m_RowColor);
                    m_HTMLReport.AppendLine(m_DataRow.Key + "</td>");
                    m_HTMLReport.AppendFormat(@"    <td style=""background-color: {0}; border-right: 1px solid #000000; border-bottom: 1px solid #000000; width: 60px; font-family: Tahoma; font-size: 11px; color: #000000; text-align: center; overflow: auto; padding-left: 2px; padding-top: 2px; padding-bottom: 2px; word-break:break-all;"">", m_RowColor);
                    if (m_DataRow.Value.IterationsPLT1 != 0)
                    {
                        float m_AvgPLT1 = (float)(m_DataRow.Value.TotalPLT1 / m_DataRow.Value.IterationsPLT1);
                        m_HTMLReport.AppendFormat("{0:F2}s</td>", m_AvgPLT1);
                        m_HTMLReport.AppendLine();
                    }
                    else
                        m_HTMLReport.AppendLine(@"--</td>");
                    m_HTMLReport.AppendFormat(@"    <td style=""background-color: {0}; border-right: 1px solid #000000; border-bottom: 1px solid #000000; width: 60px; font-family: Tahoma; font-size: 11px; color: #000000; text-align: center; overflow: auto; padding-left: 2px; padding-top: 2px; padding-bottom: 2px; word-break:break-all;"">", m_RowColor);
                    m_HTMLReport.AppendLine(m_DataRow.Value.IterationsPLT1.ToString() + "</td>");
                    m_HTMLReport.AppendFormat(@"    <td style=""background-color: {0}; border-right: 1px solid #000000; border-bottom: 1px solid #000000; width: 60px; font-family: Tahoma; font-size: 11px; color: #000000; text-align: center; overflow: auto; padding-left: 2px; padding-top: 2px; padding-bottom: 2px; word-break:break-all;"">", m_RowColor);

                    if (m_DataRow.Value.IterationsPLT2 != 0)
                    {
                        float m_AvgPLT2 = (float)(m_DataRow.Value.TotalPLT2 / m_DataRow.Value.IterationsPLT2);
                        m_HTMLReport.AppendFormat("{0:F2}s</td>", m_AvgPLT2);
                        m_HTMLReport.AppendLine();
                    }
                    else
                        m_HTMLReport.AppendLine(@"--</td>");

                    m_HTMLReport.AppendFormat(@"    <td style=""background-color: {0}; border-right: 1px solid #000000; border-bottom: 1px solid #000000; width: 60px; font-family: Tahoma; font-size: 11px; color: #000000; text-align: center; overflow: auto; padding-left: 2px; padding-top: 2px; padding-bottom: 2px; word-break:break-all;"">", m_RowColor);
                    m_HTMLReport.AppendLine(m_DataRow.Value.IterationsPLT2.ToString() + "</td>");
                    m_HTMLReport.AppendFormat(@"    <td style=""background-color: {0}; border-right: 1px solid #000000; border-bottom: 1px solid #000000; width: 60px; font-family: Tahoma; font-size: 11px; color: #000000; text-align: center; overflow: auto; padding-left: 2px; padding-top: 2px; padding-bottom: 2px; word-break:break-all;"">", m_RowColor);

                    if (m_DataRow.Value.IterationsPLT1 == 0 && m_DataRow.Value.IterationsPLT2 == 0)
                        m_HTMLReport.AppendLine(@"--</td>");
                    else
                    {
                        m_HTMLReport.AppendFormat("{0:F2}</td>", m_AvgAvailability);
                        m_HTMLReport.AppendLine();
                    }
                    m_HTMLReport.AppendLine(@"  </tr>");

                    m_RowCount++;
                }
                m_HTMLReport.AppendLine(@"</table>");

                return m_HTMLReport;
            }
            catch (Exception Error)
            {
                ToolLogger.WriteLine(Logger.LogLevel.Exception, "An error occured while creating HTML report for " + Environment + "(" + NetworkType + ").");
                ToolLogger.WriteLine(Error);
                throw;
            }
        }

        /// <summary>
        /// Generates the HTML Error report for the specified exception.
        /// </summary>
        /// <param name="Error">The exception object.</param>
        /// <returns>A string representing the HTML Report.</returns>
        public static string GererateRuntimeErrorReport(Exception Error)
        {
            StringBuilder m_ErrorReport = new StringBuilder();

            try
            {
                m_ErrorReport.AppendLine(@"<table style=""width: 800px"" cellspacing=""0"">");
                m_ErrorReport.AppendLine(@"  <tr>");
                m_ErrorReport.AppendLine(@"    <td style=""border: 1px solid #000000; font-family: Arial Black; font-size: 18px; color: #FFFFFF; background-color: #FF0000;"">PLT Scheduler Runtime Error</td>");
                m_ErrorReport.AppendLine(@"  </tr>");
                m_ErrorReport.AppendLine(@"  <tr>");
                m_ErrorReport.AppendLine(@"    <td style=""word-break: break-all; border-bottom: 1px solid #000000; border-right: 1px solid #000000;border-left: 1px solid #000000; font-family: Tahoma; font-size: 13px; color: #000000; background-color: #FFFFFF;"">");
                m_ErrorReport.AppendLine(@"    A runtime error has occurred in PLT Scheduler. The exception encountered was:<br /><br />");
                m_ErrorReport.AppendLine(@"       <span style=""color: #FF4A4A;"">" + Error.ToString() + "</span></td>");
                m_ErrorReport.AppendLine(@"  </tr>");
                m_ErrorReport.AppendLine(@"</table>");
            }
            catch (Exception)
            {
                return String.Empty;
            }
            return m_ErrorReport.ToString();
        }

        /// <summary>
        /// Removes all log files from the previous run, if any.
        /// </summary>
        public static void RemoveAllLogs()
        {
            try
            {
                //Delete all csv files in root folder
                foreach (string m_CSVFile in Directory.GetFiles(Directory.GetCurrentDirectory(), "*.csv"))
                    File.Delete(m_CSVFile);

                //Delete logs in report folder
                if (Directory.Exists(Directory.GetCurrentDirectory() + G_REPORTFOLDER))
                {
                    Directory.Delete(Directory.GetCurrentDirectory() + G_REPORTFOLDER, true);

                    //Recreate folder
                    Directory.CreateDirectory(Directory.GetCurrentDirectory() + G_REPORTFOLDER);
                }

                //Delete perf folder
                if (Directory.Exists(Directory.GetCurrentDirectory() + "\\perf"))
                    Directory.Delete(Directory.GetCurrentDirectory() + "\\perf", true);

                //Delete debug.log & error.log
                if (File.Exists(Directory.GetCurrentDirectory() + "\\debug.log"))
                    File.Delete(Directory.GetCurrentDirectory() + "\\debug.log");

                if (File.Exists(Directory.GetCurrentDirectory() + "\\error.log"))
                    File.Exists(Directory.GetCurrentDirectory() + "\\error.log");
            }
            catch { }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\PLTScheduler\PLTScheduler\PLTAbstractionLayer.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Diagnostics;
using System.IO;
using Test.Common.Library.NetworkEmulator;
using Test.Common.Library.PageLoadTimeDaemon;

namespace Test.Common.Utilities.PLTScheduler
{
    /// <summary>
    /// Represents the interaction layer with the PLT Tool.
    /// </summary>
    public class PLTAbstractionLayer
    {
        private Configuration g_Config = null;
        private string[] g_Environments = null;
        private string[] g_NetworkTypes = null;
        private string[] g_PLTTypes = null;
        private Logger g_Logger = null;

        /// <summary>
        /// Initializes a new instance of the PLTRunner class.
        /// </summary>
        /// <param name="Config">The tool configuration object.</param>
        public PLTAbstractionLayer(Configuration Config)
        {
            //Init Logger
            try
            {
                g_Logger = new Logger("PLTScheduler.log");
            }
            catch (Exception)
            {
                throw;
            }

            //Init other objects.
            try
            {
                g_Config = Config;
                g_Environments = g_Config.Environments;
                g_NetworkTypes = g_Config.NetworkTypes;
                g_PLTTypes = g_Config.PLTTypes;
            }
            catch (Exception Error)
            {
                g_Logger.WriteLine(Logger.LogLevel.Exception, "Error occured while initializing PLT Abstraction layer.");
                g_Logger.WriteLine(Error);
                throw;
            }
        }

        /// <summary>
        /// Runs the PLT tests.
        /// </summary>
        public void RunPLT()
        {
            NetworkEmulation m_Emulator = null;
            DateTime m_StartTime;
            bool m_CumulativeCompiled = false;

            try
            {
                Init();

                #region Process each Network Type
                foreach (string m_NetworkType in g_Config.NetworkTypes)
                {
                    //Start emulator
                    string m_EmulationProfileFile = string.Format(g_Config.ExternalToolSettings.NEWTProfileFileMask,
                                                                  m_NetworkType);
                    m_Emulator = new NetworkEmulation(m_EmulationProfileFile);
                    g_Logger.WriteLine(Logger.LogLevel.Message, m_EmulationProfileFile + " loaded.");
                    m_Emulator.StartEmulation();
                    g_Logger.WriteLine(Logger.LogLevel.Message, "Network emulation started for " + m_NetworkType);

                    #region Process each Environment
                    foreach (string m_Environment in g_Config.Environments)
                    {
                        //Set the start time
                        m_StartTime = DateTime.Now;

                        #region Process each PLT Type
                        foreach (string m_PLTType in g_Config.PLTTypes)
                        {

                            //Run the PLT Tool
                            try
                            {
                                RunPLTTool(m_NetworkType, m_Environment, m_PLTType);
                            }
                            catch (Exception Error)
                            {
                                g_Logger.WriteLine(Logger.LogLevel.Exception, "Error occured in PLT Module.");
                                g_Logger.WriteLine(Error);
                                throw;          //High pri issue. Tests cannot complete!!
                            }

                            ReportLayer.ArchiveToEnvironmentReport(string.Format("TestResults_{0}.csv", m_PLTType),
                                                                   m_Environment,
                                                                   m_NetworkType,
                                                                   m_PLTType,
                                                                   g_Logger);
                            g_Logger.WriteLine(Logger.LogLevel.Message, "The log file '" +
                                               string.Format("TestResults_{0}.csv", m_Environment, m_PLTType) +
                                               " has been successfully archived.");
                        }
                        #endregion

                        #region Send mail for the environment
                        try
                        {
                            Mailer.SendReportMail("PLT Report for " + m_Environment + " [" + m_NetworkType + "]",
                                                   ReportLayer.GenerateHTMLReport(ReportLayer.CompileReportForEnvironment(m_Environment,
                                                                                                                          m_NetworkType,
                                                                                                                          g_Config,
                                                                                                                          g_Logger),
                                                                                  m_Environment,
                                                                                  m_NetworkType,
                                                                                  DateTime.Now - m_StartTime,
                                                                                  g_Logger),
                                                   g_Config,
                                                   g_Logger);
                            g_Logger.WriteLine(Logger.LogLevel.Message, "The HTML report for " + m_Environment + " [" + m_NetworkType + "] was sent successfully.");
                        }
                        catch
                        {
                            g_Logger.WriteLine(Logger.LogLevel.Warning, "The report mail was not sent.");
                        }
                        #endregion
                    }
                    #endregion

                    //Stop Emulation
                    m_Emulator.StopEmulation();
                    m_Emulator = null;
                    g_Logger.WriteLine(Logger.LogLevel.Message, "Network emulation stopped.");
                }
                #endregion

                #region Compile Cumulative Report
                try
                {
                    Console.WriteLine("INFO: Compiling Cumulative Report ...");
                    ReportLayer.CompileCumulativeReport(g_Config, g_Logger);
                    m_CumulativeCompiled = true;
                }
                catch
                {
                    g_Logger.WriteLine(Logger.LogLevel.Warning, "The Cumulative PLT Report was not generated.");
                }
                #endregion

                #region Upload to Database
                try
                {
                    if (g_Config.DatabaseSettings.UploadToDatabase && m_CumulativeCompiled)
                    {
                        Console.WriteLine("INFO: Uploading cumulative data to database ...");
                        DatabaseLayer m_DBLayer = new DatabaseLayer(g_Config.DatabaseSettings.SqlDatabaseConnectionString);

                        m_DBLayer.UploadPLTData(ReportLayer.GetCumulativeDatabaseData());
                        g_Logger.WriteLine(Logger.LogLevel.Message, "The cumulative PLT data was successfully uploaded to database.");
                    }
                }
                catch (Exception Error)
                {
                    g_Logger.WriteLine(Logger.LogLevel.Exception, "Error occured while uploading the cumulative data to database.");
                    g_Logger.WriteLine(Error);
                }
                #endregion

                #region Archive and Purge Log Files
                try
                {
                    Console.WriteLine("INFO: Archiving and Purging log files ...");
                    string m_LogArchiveLocation = ArchiveAndPurgeLogs();
                    g_Logger.WriteLine(Logger.LogLevel.Message, "The logs were successfully archived to '" + m_LogArchiveLocation + "'");
                }
                catch
                {
                    g_Logger.WriteLine(Logger.LogLevel.Warning, "The logs were not archived.");
                }
                #endregion
            }
            catch (Exception)
            {
                throw;
            }
            finally
            {
                g_Logger.Close();
                g_Logger = null;
            }
        }

        /// <summary>
        /// Archives all the logs from this run to the log dump location.
        /// </summary>
        private string ArchiveAndPurgeLogs()
        {
            LogTransportLayer m_LogArchiver = null;

            try
            {
                m_LogArchiver = new LogTransportLayer(g_Config);
                m_LogArchiver.PurgeLogFolder();

                if (!string.IsNullOrEmpty(g_Config.LogDumpLocation))
                {
                    m_LogArchiver.CreateLogFolder();
                    m_LogArchiver.MoveAllLogFiles();
                }
                return m_LogArchiver.LogArchiveLocation;
            }
            catch (Exception Error)
            {
                g_Logger.WriteLine(Logger.LogLevel.Exception, "An error occured while archiving and purging operation.");
                g_Logger.WriteLine(Error);
                throw;
            }
        }

        /// <summary>
        /// Initializes the environment for running the tool.
        /// </summary>
        private void Init()
        {
            try
            {
                //Kill Browsers
                KillProcess("iexplore.exe");
                g_Logger.WriteLine(Logger.LogLevel.Message, "Init::IE killed.");

                //Clear all log files
                ReportLayer.RemoveAllLogs();
                g_Logger.WriteLine(Logger.LogLevel.Message, "Init::Logs cleared.");
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Kills the specified process if running.
        /// </summary>
        /// <param name="ProcessName">The process name.</param>
        private void KillProcess(string ProcessName)
        {
            try
            {
                string[] m_ProcessArray = ProcessName.Replace("/", "\\").Split('\\');
                string execName = m_ProcessArray[m_ProcessArray.Length - 1].Trim().Replace(".exe", "");
                Process[] processes = Process.GetProcessesByName(execName);
                foreach (Process proc in processes)
                    proc.Kill();
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Run the PLT Tool for the specified network type,
        /// environment and plt type.
        /// </summary>
        /// <param name="NetworkType">The network type.</param>
        /// <param name="Environment">The environment.</param>
        /// <param name="PLTType">The plt type.</param>
        private void RunPLTTool(string NetworkType, string Environment, string PLTType)
        {
            PLTMonitor m_PLTDaemon = null;

            try
            {
                g_Logger.WriteLine(Logger.LogLevel.Message, string.Format("INFO: Running {0} for {1} emulating {2}.",
                                                                          PLTType,
                                                                          Environment,
                                                                          NetworkType
                                                                         )
                                  );
                //Init PLT Monitor
                m_PLTDaemon = new PLTMonitor(string.Format(g_Config.ExternalToolSettings.PLTConfigFileMask,
                                                           Environment,
                                                           PLTType),
                                             NetworkType,
                                             Environment
                                            );

                m_PLTDaemon.StartPLTTests();
                m_PLTDaemon.SaveResultsToCSV();
                m_PLTDaemon.Dispose();
                m_PLTDaemon = null;
                g_Logger.WriteLine(Logger.LogLevel.Message, "The PLT Tests were executed successfully.");
            }
            catch (Exception Error)
            {
                g_Logger.WriteLine(Logger.LogLevel.Exception, "Error occured in ::RunPLTTool");
                g_Logger.WriteLine(Error);
                throw;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\PLTScheduler\PLTScheduler\Scheduler.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Diagnostics;

namespace Test.Common.Utilities.PLTScheduler
{
    class Scheduler
    {
        private const string G_DEFAULT_CONFIG_FILENAME = "PLTSchdConfig.xml";
        private static string g_ConfigFileName = String.Empty;
        private static ConfigurationLayer g_Config = null;

        enum ParserResult
        {
            UnknownCommand,
            TooManyParameters,
            NormalExecution,
            SaveConfigOnly
        }

        [STAThread]
        static void Main(string[] args)
        {
            PrintWelcome();

            if (CheckForDuplicateProcess())
            {
                Console.WriteLine("ERROR: Another instance of the tool is already running.");
                return;
            }

            switch (ParseCommand(args))
            {
                case ParserResult.TooManyParameters:
                    Console.WriteLine("ERROR: Too many parameters.");
                    return;
                case ParserResult.UnknownCommand:
                    Console.WriteLine("ERROR: The command is unknown.");
                    return;
                case ParserResult.SaveConfigOnly:
                    g_Config = new ConfigurationLayer();
                    g_Config.SaveConfiguration("SampleConfig.xml");
                    Console.WriteLine("INFO: The default configuration has been saved to 'SampleConfig.xml'");
                    return;
                case ParserResult.NormalExecution:
                    PLTAbstractionLayer m_PLTRunner = null;
                    //Check if config file exists
                    if (!File.Exists(g_ConfigFileName))
                    {
                        Console.WriteLine("ERROR: The config file '" + g_ConfigFileName + "' does not exists.");
                        return;
                    }
                    try
                    {
                        g_Config = new ConfigurationLayer(g_ConfigFileName);
                        Console.WriteLine("INFO: Configuration successfully loaded from '" + g_ConfigFileName + "'");

                        m_PLTRunner = new PLTAbstractionLayer(g_Config.GetConfiguration());
                        Console.WriteLine("INFO: Running PLT Tests ...");
                        m_PLTRunner.RunPLT();

                        //Send completion status
                        Mailer.SendCompletionMail("PLTScheduler has completed processing",
                                                   "The daemon finished processing all the defined environments at " +
                                                   DateTime.Now.ToString() + ". The log for this run is attached.",
                                                   g_Config.GetConfiguration(),
                                                   Directory.GetCurrentDirectory() + "\\PLTScheduler.log"
                                                 );
                        Console.WriteLine("INFO: Completion email sent.");
                    }
                    catch (Exception Error)
                    {
                        Console.WriteLine("ERROR: An error has occured.");
                        Console.WriteLine("ERROR: " + Error);
                        Mailer.SendErrorMail("Runtime error occured in PLTScheduler",
                                              ReportLayer.GererateRuntimeErrorReport(Error),
                                              g_Config.GetConfiguration()
                                             );
                        return;
                    }
                    break;
            }
        }

        /// <summary>
        /// Parses the command line.
        /// </summary>
        /// <param name="CommandArray">An array of command line arguments.</param>
        /// <returns></returns>
        private static ParserResult ParseCommand(string[] CommandArray)
        {
            string m_Command = String.Empty;

            if (CommandArray.Length > 2)
                return ParserResult.TooManyParameters;

            if (CommandArray.Length == 0)
            {
                g_ConfigFileName = G_DEFAULT_CONFIG_FILENAME;
                return ParserResult.NormalExecution;
            }
            else
            {
                m_Command = CommandArray[0].ToLower();
                switch (m_Command)
                {
                    case "-savedefault":
                        return ParserResult.SaveConfigOnly;
                    case "-config":
                        g_ConfigFileName = CommandArray[1];
                        return ParserResult.NormalExecution;
                    default:
                        return ParserResult.UnknownCommand;
                }
            }
        }

        /// <summary>
        /// Prints the welcome message.
        /// </summary>
        private static void PrintWelcome()
        {
            Console.WriteLine("PLT Scheduler");
            Console.WriteLine("(C) Microsoft Corporation. For internal use only.");
            Console.WriteLine(" ");
        }

        /// <summary>
        /// Checks if the tool is already running.
        /// </summary>
        /// <returns>True if the tool is already running, else false.</returns>
        private static bool CheckForDuplicateProcess()
        {
            int m_ProcessCount = 0;

            Process[] m_DuplicateProcesses
                = Process.GetProcessesByName(Process.GetCurrentProcess().ProcessName);

            foreach (Process m_Process in m_DuplicateProcesses)
            {
                if (m_Process.ProcessName == Process.GetCurrentProcess().ProcessName)
                    m_ProcessCount++;
            }

            if (m_ProcessCount > 1)
                return true;
            else
                return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\QueueMon\ServiceBrokerMonitor\Agent.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml.Linq;
using System.Net.Mail;
using System.IO;

namespace ServiceBrokerMonitor
{
    public class Agent
    {
        const string config = "Environment.xml";
        int threshold;
        List<BrokerQueue> brokerQueues;

        public string CurrentEnvironment { get; private set; }
        public string DropLocation { get; private set; }

        /// <summary>
        /// 
        /// </summary>
        public List<BrokerQueue> BrokerQueues
        {
            get
            {
                return this.brokerQueues;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="environment"></param>
        public Agent(string environment)
        {
            if (!string.IsNullOrEmpty(environment))
            {
                CurrentEnvironment = environment;
            }
            Initialize();
        }

        /// <summary>
        /// 
        /// </summary>
        private void Initialize()
        {
            brokerQueues = new List<BrokerQueue>();
            
            XElement xe = XElement.Load(config).Element(CurrentEnvironment);
            List<XElement> queues = xe.Element("sb").Descendants().ToList();
            threshold = Convert.ToInt32(xe.Element("sb").Attribute("threshold").Value);
            DropLocation = xe.Element("drop").Value;

            foreach (var queue in queues)
            {
                BrokerQueue bq = new BrokerQueue();
                bq.Name = queue.Attribute("queue").Value;
                bq.Principal = queue.Attribute("principal").Value;
                bq.Failover = queue.Attribute("failover").Value;
                bq.Database = queue.Attribute("database").Value;

                brokerQueues.Add(bq);
            }


        }


        /// <summary>
        /// 
        /// </summary>
        public void RunCheck()
        {
            if (brokerQueues== null)
            {
                Initialize();
            }

            for (int i = 0; i < brokerQueues.Count; i++)
            {
                brokerQueues[i] = BrokerMonitor.GetQueueDetails(brokerQueues[i]);
            }

            DropStatusXml();

            if (IsMailRequired(threshold))
            {
               //SendMail();
            }
                        
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="messageThreshold"></param>
        /// <returns></returns>
        private bool IsMailRequired(int messageThreshold)
        {
            bool mailRequired = false;

            foreach (var item in this.BrokerQueues)
            {
                if (item.Status != QueueStatus.Enabled || item.MessageCount > messageThreshold)
                {
                    mailRequired = true;
                    break;
                }
            }

            return mailRequired;
        }


        private void DropStatusXml()
        {
            if (!Directory.Exists(DropLocation))
            {
                return;
            }

            XElement xe = new XElement("queues",
                                        from queue in this.BrokerQueues
                                        select
                                        new XElement(queue.Name, new XAttribute("size", queue.MessageCount),
                                                                 new XAttribute("status", queue.Status),
                                                                 new XAttribute("database", queue.Database ?? string.Empty),
                                                                 new XAttribute("error", queue.Error ?? string.Empty)));
            string fileName = string.Format("queuemon_{0}_{1}.xml", this.CurrentEnvironment, DateTime.Now.ToString("yyyy.MM.dd-HH.mm"));

           File.WriteAllText(Path.Combine(DropLocation, fileName), xe.ToString());
        }

        /// <summary>
        /// 
        /// </summary>
        public void SendMail()
        {
            MailAgent ma = new MailAgent(CurrentEnvironment);
            List<string> mailDetails = ma.GetSubjectAndBody(this.BrokerQueues);
            ma.SendMail(mailDetails[0], mailDetails[1]);
        }

       

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\RemoteFileStager\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\PLTScheduler\PLTScheduler\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("PLTSched")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("e4365501-faf8-4d6d-8e4a-b2399d780286")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\QueueMon\ServiceBrokerMonitor\Program.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace ServiceBrokerMonitor
{
    class Program
    {
        static string environment;

        static void Main(string[] args)
        {
            ProcessArgs(args);
            
            try
            {
                Agent a = new Agent(environment);
                Console.WriteLine("Retrieving queue details...");                
                a.RunCheck();
                DisplayQueue(a.BrokerQueues);
            }
            catch(Exception ex)
            {
                Console.WriteLine(ex.Message);
                Console.WriteLine(ex.StackTrace);
            }
        }


        static void ProcessArgs(string[] args)
        {
            if (args.Length < 1 || args.Length > 2)
            {
                Console.WriteLine();
                Console.WriteLine("Usage: QueueMon.exe <environment>");
                Console.WriteLine("       <environment> : environment in Environment.xml");
                Environment.Exit(0);
            }
            environment = args[0];
        }

        static void DisplayQueue(List<BrokerQueue> bqs)
        {
            Console.WriteLine();
            Console.WriteLine("********************************QueueStatus***************************************");
            foreach (var item in bqs)
            {
                Console.WriteLine(String.Format("Queue: {0}     Status: {1}     MessageCount: {2}   Error: {3}", item.Name, item.Status, item.MessageCount.ToString(),item.Error));
            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\QueueMon\ServiceBrokerMonitor\MailAgent.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Net.Mail;
using System.Xml.Linq;

namespace ServiceBrokerMonitor
{
    public class MailAgent
    {

        MailMessage message;
        string SmtpHost;
        string Env;
        
        const string styleInfo = @"<style type=""text/css"">" +
                         "table{font-family: tahoma;font-size: 11px;background-color: #FCFCF5;border: 1px #ccc solid;border-collapse: collapse;}" +
                         "td.headstyle{ text-align: center;background-color: #CCF4F4;border: 1px #ccc solid;font-family: tahoma;font-size: 12px;padding: .6em; border: 1px #ccc solid; }" +
                         "td.leftdatastyle{ text-align: left;background-color: #FCFCF5;border: 1px #ccc solid;font-family: tahoma;font-size: 11px;padding: .6em; border: 1px #ccc solid; }" +
                         "td.centerdatastyle{ text-align: center;background-color: #FCFCF5;border: 1px #ccc solid;font-family: tahoma;font-size: 11px;padding: .6em; border: 1px #ccc solid; }" +
                         "td,th{padding: .4em; border: 1px #ccc solid;}" +
                         "</style>";

        const string ErrorString = @"<font color=""blue""><tr><td class=""leftdatastyle"">{0}</td><td class=""centerdatastyle"">{1}</td><td class=""leftdatastyle"">{2}</td><td class=""leftdatastyle"">{3}</td><td class=""leftdatastyle"">{4}</td></tr></font>";
        const string ResultString = @"<tr><td class=""leftdatastyle"">{0}</td><td class=""centerdatastyle"">{1}</td><td class=""leftdatastyle"">{2}</td><td class=""leftdatastyle"">{3}</td><td class=""leftdatastyle"">{4}</td></tr>";
        /// <summary>
        /// 
        /// </summary>
        public MailAgent(string environment)
        {
            this.Env = environment;
            XElement element = XElement.Load("Environment.xml").Element(environment).Element("mail");

            MailAddress fromAddress = new MailAddress(element.Attribute("from").Value);
            MailAddress toAddress = new MailAddress(element.Attribute("to").Value);
            MailAddress ccAddress = new MailAddress(element.Attribute("cc").Value);
            SmtpHost = element.Attribute("smtp").Value;

            this.message = new MailMessage(fromAddress, toAddress);
            this.message.CC.Add(ccAddress);
            
        }

        /// <summary>
        /// 
        /// </summary>
        public void SendMail(string subject, string body)
        {
            SmtpClient smtpClient = new SmtpClient(SmtpHost);
            smtpClient.UseDefaultCredentials = true;
            smtpClient.DeliveryMethod = SmtpDeliveryMethod.Network;

            message.IsBodyHtml = true;
            message.Body = body;
            message.Subject = subject;
            
            smtpClient.Send(message);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="queueDetails"></param>
        /// <returns></returns>
        public List<string> GetSubjectAndBody(List<BrokerQueue> queueDetails)
        {
            List<string> lst = new List<string>();

            string subject = "ALERT: Service broker queue size has exceeded threshold";

            foreach (var item in queueDetails)
            {
                if (item.Status != QueueStatus.Enabled)
                {
                    subject = "ALERT: One or more service broker queues are not enabled";
                    break;
                }
            }

            StringBuilder body = new StringBuilder();
            body.Append("<head><body><font face=tahoma size=2>");
            body.Append(styleInfo);
            body.Append("<table border=\"1\">");
            body.Append(@"<tr><td class=""headstyle"">Queue</td><td class=""headstyle"">Status</td><td class=""headstyle"">Messages</td><td class=""headstyle"">Database</td><td class=""headstyle"">Error</td></tr>");

            foreach (var queueDetail in queueDetails)
            {
                body.Append(String.Format(ErrorString, queueDetail.Name,
                                                       queueDetail.Status.ToString(),
                                                       queueDetail.MessageCount,
                                                       queueDetail.Database,
                                                       queueDetail.Error));
            }
            body.Append("</table><br><br><br>");
            body.Append("</font></body></html>");
            
            lst.Add(subject.ToString());
            lst.Add(body.ToString());

            return lst;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\QueueMon\ServiceBrokerMonitor\BrokerQueue.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace ServiceBrokerMonitor
{
    /// <summary>
    /// 
    /// </summary>
    public class BrokerQueue
    {
        /// <summary>
        /// 
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// 
        /// </summary>
        public string Database { get; set; }

        /// <summary>
        /// 
        /// </summary>
        public string Principal { get; set; }

        /// <summary>
        /// 
        /// </summary>
        public string Failover { get; set; }
        
        /// <summary>
        /// 
        /// </summary>
        public QueueStatus Status { get; set; }

        /// <summary>
        /// 
        /// </summary>
        public int MessageCount { get; set; }

        /// <summary>
        /// 
        /// </summary>
        public string Error { get; set; }

        /// <summary>
        /// 
        /// </summary>
        public string OldestMessageDateTime { get; set; }

        /// <summary>
        /// 
        /// </summary>
        public string NewestMessageDateTime { get; set; }

    }

    public enum QueueStatus
    {
        Enabled,
        Disabled,
        Unreachable        
    }

    public enum QueryType
    {
        DBStatus,
        QStatus,
        MessageCount    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\QueueMon\ServiceBrokerMonitor\BrokerMonitor.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Data.SqlClient;
using System.Data;
using System.ServiceProcess;
using System.Configuration;
using System.Xml.Linq;

namespace ServiceBrokerMonitor
{
    public static class BrokerMonitor
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="server"></param>
        /// <param name="failoverpartner"></param>
        /// <param name="database"></param>
        /// <param name="queue"></param>
        /// <returns></returns>
        public static QueueStatus GetQueueStatus(string server, string failoverpartner, string database, string queue)
        {
            bool enabled = false;

            using (SqlConnection conn = new SqlConnection(GetConnectionString(server,failoverpartner, database)))
            {
                conn.Open();
                using (SqlCommand comm = new SqlCommand())
                {
                    comm.CommandText = GetQuery(database, queue, QueryType.QStatus);
                    comm.Connection = conn;
                    enabled = (bool)comm.ExecuteScalar();
                }
            }

            if (enabled)
            {
                return QueueStatus.Enabled;
            }
            
            return QueueStatus.Disabled;
        }

        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="server"></param>
        /// <param name="failoverpartner"></param>
        /// <param name="database"></param>
        /// <param name="queue"></param>
        /// <returns></returns>
        public static int GetQueueLength(string server,  string failoverpartner, string database, string queue)
        {
            int count = 0;

            using (SqlConnection conn = new SqlConnection(GetConnectionString(server, failoverpartner, database)))
            {
                conn.Open();
                using (SqlCommand comm = new SqlCommand())
                {
                    SqlDataReader reader = null;
                    comm.CommandText = GetQuery(database, queue, QueryType.MessageCount);
                    comm.Connection = conn;
                    reader = comm.ExecuteReader();

                    while (reader.Read())
                    {
                        count = Convert.ToInt32(reader["rows"].ToString());
                    }

                }
            }
           
            return count;
        }

        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="server"></param>
        /// <param name="failoverPartner"></param>
        /// <param name="database"></param>
        /// <returns></returns>
        public static string GetConnectionString(string server, string failoverPartner, string database)
        {
            SqlConnectionStringBuilder sqlsb = new SqlConnectionStringBuilder();
            sqlsb.DataSource = server;
            sqlsb.InitialCatalog = database;
            sqlsb.FailoverPartner = failoverPartner;
            sqlsb.IntegratedSecurity = true;

            return sqlsb.ToString();
        }

        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="database"></param>
        /// <param name="queueName"></param>
        /// <param name="queryType"></param>
        /// <returns></returns>
        private static string GetQuery(string database, string queueName, QueryType queryType)
        {
            switch (queryType)
            {
                case QueryType.DBStatus:
                    
                    return String.Format(@"SELECT state FROM [master].[sys].[databases] WHERE name = '{0}'", database);
                
                case QueryType.QStatus:
                    
                    return String.Format(@"SELECT is_receive_enabled FROM sys.service_queues WHERE name = '{0}'", queueName);

                case QueryType.MessageCount:

                    return String.Format(@"SELECT rows FROM sys.partitions P
                                           INNER JOIN sys.internal_tables IT ON IT.object_id = P.object_id
                                           WHERE IT.parent_object_id = (SELECT TOP 1 OBJECT_ID FROM sys.service_queues WHERE name = '{0}')
                                           AND P.index_id IN (1, 0)", queueName);
                default:
                    return null;
            }
            
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="bq"></param>
        /// <returns></returns>
        public static BrokerQueue GetQueueDetails(BrokerQueue bq)
        {
            try
            {
                bq.Status = BrokerMonitor.GetQueueStatus(bq.Principal, bq.Failover, bq.Database, bq.Name);
                bq.MessageCount = BrokerMonitor.GetQueueLength(bq.Principal, bq.Failover, bq.Database, bq.Name);
            }
            catch (Exception ex)
            {
                bq.Status = QueueStatus.Unreachable;
                bq.MessageCount = -1;
                bq.Error = ex.Message;
            }

            return bq;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\QueueMon\ServiceBrokerMonitor\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("ServiceBrokerMonitor")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("ServiceBrokerMonitor")]
[assembly: AssemblyCopyright("Copyright © Microsoft 2010")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("b911b7d8-aee7-4941-b6ba-e8d16c59dc53")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\SitesPostDeploymentCheck\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\RemoteFileStager\RemoteFileStager\ExclusionHandler.cs ===
﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Xml;
using System.IO;
using System.Text;

namespace Test.Common.Utilities.RemoteFileStager
{
    /// <summary>
    /// Class to handle all exclusions
    /// </summary>
    internal class ExclusionHandler
    {
        private ArrayList ExcludedFiles = null;
        private ArrayList ExcludedResponseStrings = null;
        private ArrayList ExcludedResponseCodes = null;

        /// <summary>
        /// Instantiate a new object of ExclusionHandler.
        /// </summary>
        public ExclusionHandler()
        {
            XmlDocument ExclusionXML = null;
            XmlNodeList ExclusionFileList = null;
            XmlNodeList ExclusionResponseList = null;
            XmlNodeList ExclusionResponseCodeList = null;

            //Read Exclusion XML
            if (File.Exists("Exclusion.xml"))
            {
                try
                {
                    ExclusionXML = new XmlDocument();
                    ExclusionXML.Load("Exclusion.xml");
                    ExclusionFileList = ExclusionXML.GetElementsByTagName("File");
                    ExclusionResponseList = ExclusionXML.GetElementsByTagName("Response");
                    ExclusionResponseCodeList = ExclusionXML.GetElementsByTagName("Code");
                    ExcludedFiles = new ArrayList();
                    ExcludedResponseStrings = new ArrayList();
                    ExcludedResponseCodes = new ArrayList();

                    //Populate excluded File list
                    foreach (XmlNode FileName in ExclusionFileList)
                        ExcludedFiles.Add(FileName.InnerText);

                    //Populate excluded Response Strings
                    foreach (XmlNode Response in ExclusionResponseList)
                        ExcludedResponseStrings.Add(Response.InnerText);

                    //Populate excluded Response Codes
                    foreach (XmlNode ResponseCode in ExclusionResponseCodeList)
                        ExcludedResponseCodes.Add(int.Parse(ResponseCode.InnerText));

                    ExclusionFileList = null;
                    ExclusionResponseList = null;
                    ExclusionResponseCodeList = null;
                    ExclusionXML = null;
                }
                catch (Exception)
                {
                    throw;
                }
            }
        }

        /// <summary>
        /// Get the Excluded File List for instrumentation.
        /// </summary>
        /// <returns></returns>
        public string[] GetExcludedFiles()
        {
            if (ExcludedFiles == null)
                return null;
            else
                return (string[])ExcludedFiles.ToArray(typeof(string));
        }

        /// <summary>
        /// Get the Excluded Response String List.
        /// </summary>
        /// <returns></returns>
        public string[] GetExcludedResponseStrings()
        {
            if (ExcludedResponseStrings == null)
                return null;
            else
                return (string[])ExcludedResponseStrings.ToArray(typeof(string));
        }

        /// <summary>
        /// Get the Excluded Response Code List.
        /// </summary>
        /// <returns></returns>
        public int[] GetExcludedResponseCodes()
        {
            if (ExcludedResponseCodes == null)
                return null;
            else
                return (int[])ExcludedResponseCodes.ToArray(typeof(int));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\RemoteFileStager\RemoteFileStager\InternetCacheLayer.cs ===
﻿using System;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.ComTypes;

namespace Test.Common.Utilities.RemoteFileStager
{
    /// <summary>
    /// Layer for accessing the Internet Cache on local machine.
    /// Code was adopted from http://support.microsoft.com/kb/326201
    /// </summary>
    class InternetCacheLayer
    {
        // Indicates that all of the cache groups in the user's system should be enumerated
        const int CACHEGROUP_SEARCH_ALL = 0x0;
        // Indicates that all the cache entries that are associated with the cache group
        // should be deleted, unless the entry belongs to another cache group.
        const int CACHEGROUP_FLAG_FLUSHURL_ONDELETE = 0x2;
        // File not found.
        const int ERROR_FILE_NOT_FOUND = 0x2;
        // No more items have been found.
        const int ERROR_NO_MORE_ITEMS = 259;
        // Pointer to a GROUPID variable
        long groupId = 0;

        // For PInvoke: Contains information about an entry in the Internet cache
        [StructLayout(LayoutKind.Explicit, Size = 80)]
        public struct INTERNET_CACHE_ENTRY_INFOA
        {
            [FieldOffset(0)]
            public uint dwStructSize;
            [FieldOffset(4)]
            public IntPtr lpszSourceUrlName;
            [FieldOffset(8)]
            public IntPtr lpszLocalFileName;
            [FieldOffset(12)]
            public uint CacheEntryType;
            [FieldOffset(16)]
            public uint dwUseCount;
            [FieldOffset(20)]
            public uint dwHitRate;
            [FieldOffset(24)]
            public uint dwSizeLow;
            [FieldOffset(28)]
            public uint dwSizeHigh;
            [FieldOffset(32)]
            public System.Runtime.InteropServices.ComTypes.FILETIME LastModifiedTime;
            [FieldOffset(40)]
            public System.Runtime.InteropServices.ComTypes.FILETIME ExpireTime;
            [FieldOffset(48)]
            public System.Runtime.InteropServices.ComTypes.FILETIME LastAccessTime;
            [FieldOffset(56)]
            public System.Runtime.InteropServices.ComTypes.FILETIME LastSyncTime;
            [FieldOffset(64)]
            public IntPtr lpHeaderInfo;
            [FieldOffset(68)]
            public uint dwHeaderInfoSize;
            [FieldOffset(72)]
            public IntPtr lpszFileExtension;
            [FieldOffset(76)]
            public uint dwReserved;
            [FieldOffset(76)]
            public uint dwExemptDelta;
        }

        // For PInvoke: Initiates the enumeration of the cache groups in the Internet cache
        [DllImport(@"wininet", SetLastError = true, CharSet = CharSet.Auto, EntryPoint = "FindFirstUrlCacheGroup", CallingConvention = CallingConvention.StdCall)]
        public static extern IntPtr FindFirstUrlCacheGroup(int dwFlags,
                                                           int dwFilter,
                                                           IntPtr lpSearchCondition,
                                                           int dwSearchCondition,
                                                           ref long lpGroupId,
                                                           IntPtr lpReserved);

        // For PInvoke: Retrieves the next cache group in a cache group enumeration
        [DllImport(@"wininet", SetLastError = true, CharSet = CharSet.Auto, EntryPoint = "FindNextUrlCacheGroup", CallingConvention = CallingConvention.StdCall)]
        public static extern bool FindNextUrlCacheGroup(IntPtr hFind,
                                                        ref long lpGroupId,
                                                        IntPtr lpReserved);

        // For PInvoke: Releases the specified GROUPID and any associated state in the cache index file
        [DllImport(@"wininet", SetLastError = true, CharSet = CharSet.Auto, EntryPoint = "DeleteUrlCacheGroup", CallingConvention = CallingConvention.StdCall)]
        public static extern bool DeleteUrlCacheGroup(long GroupId,
                                                      int dwFlags,
                                                      IntPtr lpReserved);

        // For PInvoke: Begins the enumeration of the Internet cache
        [DllImport(@"wininet", SetLastError = true, CharSet = CharSet.Auto, EntryPoint = "FindFirstUrlCacheEntryA", CallingConvention = CallingConvention.StdCall)]
        public static extern IntPtr FindFirstUrlCacheEntry([MarshalAs(UnmanagedType.LPTStr)] string lpszUrlSearchPattern,
                                                            IntPtr lpFirstCacheEntryInfo,
                                                            ref int lpdwFirstCacheEntryInfoBufferSize);

        // For PInvoke: Retrieves the next entry in the Internet cache
        [DllImport(@"wininet", SetLastError = true, CharSet = CharSet.Auto, EntryPoint = "FindNextUrlCacheEntryA", CallingConvention = CallingConvention.StdCall)]
        public static extern bool FindNextUrlCacheEntry(IntPtr hFind,
                                                        IntPtr lpNextCacheEntryInfo,
                                                        ref int lpdwNextCacheEntryInfoBufferSize);

        // For PInvoke: Removes the file that is associated with the source name from the cache, if the file exists
        [DllImport(@"wininet", SetLastError = true, CharSet = CharSet.Auto, EntryPoint = "DeleteUrlCacheEntryA", CallingConvention = CallingConvention.StdCall)]
        public static extern bool DeleteUrlCacheEntry(IntPtr lpszUrlName);

        /// <summary>
        /// Instantiate a new object of InternetCacheLayer
        /// </summary>
        public InternetCacheLayer()
        {
        }

        public void ClearInternetCache()
        {
            // Local variables
            int cacheEntryInfoBufferSizeInitial = 0;
            int cacheEntryInfoBufferSize = 0;
            IntPtr cacheEntryInfoBuffer = IntPtr.Zero;
            INTERNET_CACHE_ENTRY_INFOA internetCacheEntry;
            IntPtr enumHandle = IntPtr.Zero;
            bool returnValue = false;

            // Delete the groups first.
            // Groups may not always exist on the system.
            // By default, a URL does not belong to any group. Therefore, that cache may become
            // empty even when the CacheGroup APIs are not used because the existing URL does not belong to any group.			
            enumHandle = FindFirstUrlCacheGroup(0, CACHEGROUP_SEARCH_ALL, IntPtr.Zero, 0, ref groupId, IntPtr.Zero);
            // If there are no items in the Cache, you are finished.
            if (enumHandle != IntPtr.Zero && ERROR_NO_MORE_ITEMS == Marshal.GetLastWin32Error())
                return;

            // Loop through Cache Group, and then delete entries.
            while (true)
            {
                // Delete a particular Cache Group.
                returnValue = DeleteUrlCacheGroup(groupId, CACHEGROUP_FLAG_FLUSHURL_ONDELETE, IntPtr.Zero);
                if (!returnValue && ERROR_FILE_NOT_FOUND == Marshal.GetLastWin32Error())
                {
                    returnValue = FindNextUrlCacheGroup(enumHandle, ref groupId, IntPtr.Zero);
                }

                if (!returnValue && (ERROR_NO_MORE_ITEMS == Marshal.GetLastWin32Error() || ERROR_FILE_NOT_FOUND == Marshal.GetLastWin32Error()))
                    break;
            }

            // Start to delete URLs that do not belong to any group.
            enumHandle = FindFirstUrlCacheEntry(null, IntPtr.Zero, ref cacheEntryInfoBufferSizeInitial);
            if (enumHandle != IntPtr.Zero && ERROR_NO_MORE_ITEMS == Marshal.GetLastWin32Error())
                return;

            cacheEntryInfoBufferSize = cacheEntryInfoBufferSizeInitial;
            cacheEntryInfoBuffer = Marshal.AllocHGlobal(cacheEntryInfoBufferSize);
            enumHandle = FindFirstUrlCacheEntry(null, cacheEntryInfoBuffer, ref cacheEntryInfoBufferSizeInitial);

            while (true)
            {
                internetCacheEntry = (INTERNET_CACHE_ENTRY_INFOA)Marshal.PtrToStructure(cacheEntryInfoBuffer, typeof(INTERNET_CACHE_ENTRY_INFOA));

                cacheEntryInfoBufferSizeInitial = cacheEntryInfoBufferSize;
                returnValue = DeleteUrlCacheEntry(internetCacheEntry.lpszSourceUrlName);
                if (!returnValue)
                {
                    returnValue = FindNextUrlCacheEntry(enumHandle, cacheEntryInfoBuffer, ref cacheEntryInfoBufferSizeInitial);
                }
                if (!returnValue && ERROR_NO_MORE_ITEMS == Marshal.GetLastWin32Error())
                {
                    break;
                }
                if (!returnValue && cacheEntryInfoBufferSizeInitial > cacheEntryInfoBufferSize)
                {
                    cacheEntryInfoBufferSize = cacheEntryInfoBufferSizeInitial;
                    cacheEntryInfoBuffer = Marshal.ReAllocHGlobal(cacheEntryInfoBuffer, (IntPtr)cacheEntryInfoBufferSize);
                    returnValue = FindNextUrlCacheEntry(enumHandle, cacheEntryInfoBuffer, ref cacheEntryInfoBufferSizeInitial);
                }
            }
            Marshal.FreeHGlobal(cacheEntryInfoBuffer);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\RemoteFileStager\RemoteFileStager\LocalBuildLayer.cs ===
﻿using System;
using System.Collections;
using System.IO;
using System.Text;

namespace Test.Common.Utilities.RemoteFileStager
{
    /// <summary>
    /// Layer for local build interaction.
    /// </summary>
    internal class LocalBuildLayer
    {
        private ArrayList BuildFileList;
        private string[] ExcludedFiles;
        private DirectoryInfo LocalBuildRootPath;

        public LocalBuildLayer(string BuildRootPath, string[] ExclusionList)
        {
            LocalBuildRootPath = new DirectoryInfo(BuildRootPath);

            //Check if folder exists
            if (!LocalBuildRootPath.Exists)
                throw new DirectoryNotFoundException("The specified local build root path does not exists.");

            ExcludedFiles = ExclusionList;

            //Populate File List
            try
            {
                BuildFileList = CreateBuildFileList(LocalBuildRootPath);
                
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Get the local build file list.
        /// </summary>
        /// <returns></returns>
        public string[] GetBuildFileList()
        {
            return (string[])BuildFileList.ToArray(typeof(string));
        }

        
        private ArrayList CreateBuildFileList(DirectoryInfo BuildPath)
        {
            ArrayList FileList = new ArrayList();

            try
            {
                // Add Filenames to list
                foreach (FileInfo File in BuildPath.GetFiles())
                {
                    //Check if file is not excluded and only then add
                    if (!IsFileExcluded(File.Name))
                        FileList.Add(File.FullName.Substring(LocalBuildRootPath.FullName.Length + 1));
                }

                // Traverse each subdirectory using recursion.
                foreach (DirectoryInfo SourceSubDirectory in BuildPath.GetDirectories())
                    FileList.AddRange(CreateBuildFileList(new DirectoryInfo(SourceSubDirectory.FullName)));
            }
            catch (Exception)
            {
                throw;
            }

            return FileList;
        }

        /// <summary>
        /// Check if File has been specifically excluded from instrumentation.
        /// </summary>
        /// <param name="BinaryFileName">The name of the Binary file.</param>
        /// <returns></returns>
        private bool IsFileExcluded(string BinaryFileName)
        {
            bool IsExcluded = false;

            foreach (string ExcludedFile in ExcludedFiles)
            {
                //Check if Exclusion is WildCard exclusion.
                if (IsWildCardExclusion(ExcludedFile))
                {
                    if (BinaryFileName.Length >= GetWildCardExtension(ExcludedFile).Length)
                    {
                        if (String.Compare(BinaryFileName.Substring(BinaryFileName.Length - GetWildCardExtension(ExcludedFile).Length),
                            GetWildCardExtension(ExcludedFile), true) == 0)
                            IsExcluded = true;
                    }
                }
                else
                {
                    if (String.Compare(BinaryFileName, ExcludedFile, true) == 0)
                        IsExcluded = true;
                }
            }
            return IsExcluded;
        }

        /// <summary>
        /// Check if the Exclusion entry is a Wild card exclusion.
        /// </summary>
        /// <param name="ExclusionString">The Exclusion entry string.</param>
        /// <returns></returns>
        private bool IsWildCardExclusion(string ExclusionString)
        {
            bool IsWildCard = false;

            if (ExclusionString.Substring(0, 2) == "*.")
                IsWildCard = true;
            return IsWildCard;
        }

        /// <summary>
        /// Get the extension of the Wild Card exclusion string.
        /// </summary>
        /// <param name="WildCardExclusionString">The Wild Card Exclusion string entry.</param>
        /// <returns></returns>
        private string GetWildCardExtension(string WildCardExclusionString)
        {
            return WildCardExclusionString.Substring(WildCardExclusionString.IndexOf("*.") + 2);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\RemoteFileStager\RemoteFileStager\Logger.cs ===
﻿using System;
using System.Text;
using System.IO;

namespace Test.Common.Utilities.RemoteFileStager
{
    class Logger
    {
        private StreamWriter ILogger;

        /// <summary>
        /// Instantiate a new Log File.
        /// </summary>
        public Logger(string LogFileName)
        {
            try
            {
                if (File.Exists(LogFileName))
                    ILogger = File.AppendText(LogFileName);
                else
                    ILogger = File.CreateText(LogFileName);
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Write message to Log File.
        /// </summary>
        /// <param name="LogMessage">The Message to log.</param>
        public void WriteToLog(string LogMessage)
        {
            ILogger.WriteLine(DateTime.Now.ToString() + " " + LogMessage);
            ILogger.Flush();
        }

        /// <summary>
        /// Closes the Log File.
        /// </summary>
        public void CloseLog()
        {
            try
            {
                ILogger.Close();
            }
            catch (Exception)
            {
                throw;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\RemoteFileStager\RemoteFileStager\RemoteFileStager.cs ===
﻿using System;
using System.Text;
using System.Reflection;

namespace Test.Common.Utilities.RemoteFileStager
{
    class RemoteFileStager
    {
        private static ExclusionHandler ExclusionFileHandler;
        private static LocalBuildLayer LocalBuild;
        private static Logger StageLog;
        private static InternetCacheLayer INETCache;

        static int Main(string[] args)
        {
            //Print Welcome message
            PrintWelcome();

            //Setup variables
            string LocalBinaryPath = "";                    //Path to the local build
            string RemoteURI = "";                          //The base URI to the Remote WebSite.
            string LocalStagePath = "";                     //The local Stage Path
            string RequestStringToAppend = "";              //The request string to append to outgoing requests
            string[] LocalBuildFileList;                    //The File list for the local build
            bool URIFlag = false;                           //Flag to indicate /U option was passed
            bool BPFlag = false;                            //Flag to indicate /BP option was passed
            bool SPFlag = false;                            //Flag to indicate /SP option was passed
            int TotalFiles = 0;                             //The total number of files to be processed
            int ProcessedFileCount = 0;                     //Number of Files already processed
            double PercentComplete = 0.0;                   //The completion %
            int ProgramExitCode = 0;                        //The exit code of this tool
            int[] ResponseCodesToIgnore = null;             //The Response Codes that we will ignore and not log errors

            #region Instantiate Initial Objects
            try
            {
                StageLog = new Logger("RemoteFileStager.log");
            }
            catch (Exception Error)
            {
                ProgramExitCode = 1;
                Console.ForegroundColor = ConsoleColor.Red;
                Console.WriteLine("ERROR: A Fatal error has occured, while creating log.");
                Console.WriteLine("ERROR: " + Error.Message);
                if (Error.InnerException != null)
                    Console.WriteLine("ERROR: " + Error.InnerException.ToString());
                Console.WriteLine("ERROR: " + Error.StackTrace.ToString());
                Console.ResetColor();
                return (ProgramExitCode);
            } 
            #endregion

            #region Check if any arguments were passed
            if (args.Length == 0)
            {
                ProgramExitCode = 2;
                Console.ForegroundColor = ConsoleColor.Red;
                Console.WriteLine("ERROR: No input arguments were specified.");
                PrintHelp();
                StageLog.WriteToLog("ERROR: No input arguments were specified.");
                LogExitCodeMessage(ProgramExitCode);
                StageLog.CloseLog();
                Console.ResetColor();
                return (ProgramExitCode);
            } 
            #endregion

            #region Check for valid CommandLine arguments and set respective flags
            Console.ForegroundColor = ConsoleColor.White;
            Console.WriteLine("INFO: Checking arguments ...");
            foreach (string CommandLineArgument in args)
            {
                bool ArgumentParsed = false;

                // /BP
                if (CommandLineArgument.IndexOf("/bp:", StringComparison.CurrentCultureIgnoreCase) != -1)
                {
                    StageLog.WriteToLog("INFO: /BP passed. Setting Local Build Path.");
                    LocalBinaryPath = CommandLineArgument.Substring(CommandLineArgument.IndexOf(':') + 1);
                    //Strip off trailing '\' from Binary path
                    if (LocalBinaryPath.Substring(LocalBinaryPath.Length - 1) == "\\")
                        LocalBinaryPath = LocalBinaryPath.Substring(0, LocalBinaryPath.Length - 1);
                    BPFlag = true;
                    StageLog.WriteToLog("INFO: Binary Path is " + LocalBinaryPath);
                    Console.WriteLine("INFO: Binary Path is " + LocalBinaryPath);
                    ArgumentParsed = true;
                }

                // /U
                if (CommandLineArgument.IndexOf("/u:", StringComparison.CurrentCultureIgnoreCase) != -1)
                {
                    StageLog.WriteToLog("INFO: /U passed. Setting Remote URL.");
                    RemoteURI = CommandLineArgument.Substring(CommandLineArgument.IndexOf(':') + 1);
                    RemoteURI = ReformatURL(RemoteURI);                 //Reformat the URL to standard form.
                    URIFlag = true;
                    StageLog.WriteToLog("INFO: Remote URL is " + RemoteURI);
                    Console.WriteLine("INFO: Remote URL is " + RemoteURI);
                    ArgumentParsed = true;
                }

                // /SP
                if (CommandLineArgument.IndexOf("/sp:", StringComparison.CurrentCultureIgnoreCase) != -1)
                {
                    StageLog.WriteToLog("INFO: /SP passed. Setting Local Stage Path.");
                    LocalStagePath = CommandLineArgument.Substring(CommandLineArgument.IndexOf(':') + 1);
                    //Strip off trailing '\' from Stage path
                    if (LocalStagePath.Substring(LocalStagePath.Length - 1) == "\\")
                        LocalStagePath = LocalStagePath.Substring(0, LocalStagePath.Length - 1);
                    SPFlag = true;
                    StageLog.WriteToLog("INFO: Stage Path is " + LocalStagePath);
                    Console.WriteLine("INFO: Stage Path is " + LocalStagePath);
                    ArgumentParsed = true;
                }

                // /RS
                if (CommandLineArgument.IndexOf("/rs:", StringComparison.CurrentCultureIgnoreCase) != -1)
                {
                    StageLog.WriteToLog("INFO: /RS passed. Setting Optional Request String.");
                    RequestStringToAppend = CommandLineArgument.Substring(CommandLineArgument.IndexOf(':') + 1);
                    StageLog.WriteToLog("INFO: Optional Request String is " + RequestStringToAppend);
                    Console.WriteLine("INFO: Optional Request String is " + RequestStringToAppend);
                    ArgumentParsed = true;
                }

                if (!ArgumentParsed)
                {
                    ProgramExitCode = 2;
                    Console.ForegroundColor = ConsoleColor.Red;
                    Console.WriteLine("ERROR: Unknown argument '" + CommandLineArgument + "' encountered.");
                    PrintHelp();
                    StageLog.WriteToLog("ERROR: Unknown argument '" + CommandLineArgument + "' encountered.");
                    StageLog.CloseLog();
                    Console.ResetColor();
                    return (ProgramExitCode);
                }
            }
            #endregion

            #region Check if required arguments are passed from CommandLine
            if (!BPFlag)
            {
                ProgramExitCode = 2;
                Console.ForegroundColor = ConsoleColor.Red;
                Console.WriteLine("ERROR: /BP argument is missing.");
                Console.WriteLine("ERROR: Local Binary Path must be specified via /BP switch.");
                PrintHelp();
                Console.ResetColor();
                StageLog.WriteToLog("ERROR: /BP argument missing.");
                StageLog.WriteToLog("ERROR: Local Binary Path must be specified via /BP switch.");
                LogExitCodeMessage(ProgramExitCode);
                StageLog.CloseLog();
                return (ProgramExitCode);
            }

            if (!URIFlag)
            {
                ProgramExitCode = 2;
                Console.ForegroundColor = ConsoleColor.Red;
                Console.WriteLine("ERROR: /U argument is missing.");
                Console.WriteLine("ERROR: Remote URL must be specified via /U switch.");
                PrintHelp();
                Console.ResetColor();
                StageLog.WriteToLog("ERROR: /U argument is missing.");
                StageLog.WriteToLog("ERROR: Remote URL must be specified via /U switch.");
                LogExitCodeMessage(ProgramExitCode);
                StageLog.CloseLog();
                return (ProgramExitCode);
            }

            if (!SPFlag)
            {
                ProgramExitCode = 2;
                Console.ForegroundColor = ConsoleColor.Red;
                Console.WriteLine("ERROR: /SP argument is missing.");
                Console.WriteLine("ERROR: Local Stage Path must be specified via /SP switch.");
                PrintHelp();
                Console.ResetColor();
                StageLog.WriteToLog("ERROR: /SP argument missing.");
                StageLog.WriteToLog("ERROR: Local Stage Path must be specified via /SP switch.");
                LogExitCodeMessage(ProgramExitCode);
                StageLog.CloseLog();
                return (ProgramExitCode);
            }

            #endregion

            #region Create Objects, get Build File List, IgnoredResponseCodes and clean INET Cache
            Console.ForegroundColor = ConsoleColor.White;
            try
            {
                ExclusionFileHandler = new ExclusionHandler();
                LocalBuild = new LocalBuildLayer(LocalBinaryPath, ExclusionFileHandler.GetExcludedFiles());
                Console.WriteLine("INFO: Creating local build file list ...");
                StageLog.WriteToLog("INFO: Creating local build file list ...");
                LocalBuildFileList = LocalBuild.GetBuildFileList();
                LocalBuildFileList = ConvertLocalFileListToRemote(LocalBuildFileList);          //Convert to standard internet format
                ResponseCodesToIgnore = ExclusionFileHandler.GetExcludedResponseCodes();
            }
            catch (Exception Error)
            {
                ProgramExitCode = 1;
                Console.ForegroundColor = ConsoleColor.Red;
                Console.WriteLine("ERROR: An Error has occured.");
                Console.WriteLine("ERROR: " + Error.Message);
                Console.WriteLine("ERROR: Check Log for more details.");
                StageLog.WriteToLog("ERROR: " + Error.Message);
                if (Error.InnerException != null)
                    StageLog.WriteToLog("ERROR: " + Error.InnerException.ToString());
                StageLog.WriteToLog("ERROR: " + Error.StackTrace.ToString());
                LogExitCodeMessage(ProgramExitCode);
                StageLog.CloseLog();
                Console.ResetColor();
                return (ProgramExitCode);
            } 
            #endregion

            #region Clean INET Cache
            //NOTE: This skip routine workaround was introduced because the pInvoke layer
            //that cleans the INET Cache throws an error on IE8 in DeleteUrlCacheEntry.
            //We will remove this once we figure out an alternate way to clean the INET cache.
            //For now we will just skip on fail.
            try
            {
                INETCache = new InternetCacheLayer();
                Console.WriteLine("INFO: Clearing the Local Internet Cache ...");
                StageLog.WriteToLog("INFO: Clearing the Local Internet Cache ...");
                INETCache.ClearInternetCache();                 //Clean the Internet Cache
            }
            catch (Exception Error)
            {
                Console.ForegroundColor = ConsoleColor.Yellow;
                Console.WriteLine("WARN: An error occured while cleaning the INET cache.");
                Console.WriteLine("WARN: Check Log for more details.");
                StageLog.WriteToLog("WARN: An error occured while cleaning the INET cache.");
                StageLog.WriteToLog("ERROR: " + Error.Message);
                if (Error.InnerException != null)
                    StageLog.WriteToLog("ERROR: " + Error.InnerException.ToString());
                StageLog.WriteToLog("ERROR: " + Error.StackTrace.ToString());
                Console.ResetColor();
            }
            #endregion

            #region Download Files
            TotalFiles = LocalBuildFileList.Length;
            Console.ForegroundColor = ConsoleColor.White;
            Console.Write("INFO: Downloading files .... 0% done.            \r");
            foreach (string BuildFile in LocalBuildFileList)
            {
                RemoteBuildLayer RemoteWeb = null;
                bool IsRequestCreated = false;

                //Establish Connection with Remote Site
                try
                {
                    StageLog.WriteToLog("INFO: Creating Request to Remote Site:" + RemoteURI);
                    RemoteWeb = new RemoteBuildLayer(RemoteURI, BuildFile, ExclusionFileHandler.GetExcludedResponseStrings(), RequestStringToAppend);
                    IsRequestCreated = true;
                }
                catch (Exception Error)
                {
                    StageLog.WriteToLog("ERROR: Error occured while creating Request to " + RemoteURI);
                    StageLog.WriteToLog("ERROR: " + Error.Message);
                    if (Error.InnerException != null)
                        StageLog.WriteToLog("ERROR: " + Error.InnerException.ToString());
                    StageLog.WriteToLog("ERROR: " + Error.StackTrace.ToString());

                    //Set the Program Exit Code
                    ProgramExitCode = 3;
                }
                
                //Download content
                if (IsRequestCreated)
                {
                    try
                    {
                        StageLog.WriteToLog("INFO: Downloading .." + RemoteURI + '/' + BuildFile + RequestStringToAppend);
                        RemoteWeb.DownloadFile(LocalStagePath);
                    }
                    catch (System.Net.WebException WebError)
                    {
                        //Get the Response & Status Codes
                        System.Net.HttpWebResponse HttpWebErrorResponse = (System.Net.HttpWebResponse)WebError.Response;
                        int ResponseStatusCode;
                        bool IsWebErrorIgnored = false;

                        StageLog.WriteToLog("ERROR: A Web error occured while downloading " + RemoteURI + "/" + BuildFile + RequestStringToAppend);
                        StageLog.WriteToLog("ERROR: " + WebError.Message);
                        if (WebError.InnerException != null)
                            StageLog.WriteToLog("ERROR: " + WebError.InnerException.ToString());
                        StageLog.WriteToLog("ERROR: " + WebError.StackTrace);

                        //Check if its a connection failure
                        if (WebError.Status != System.Net.WebExceptionStatus.ProtocolError && WebError.Status != System.Net.WebExceptionStatus.Success)
                        {
                            StageLog.WriteToLog("ERROR: Connection Level error encountered.");
                            StageLog.WriteToLog("ERROR: Error type returned: " + WebError.Status.ToString());

                            //Set ProgramExitCode
                            if (ProgramExitCode == 4)
                                ProgramExitCode = 5;            //There's already a download failure in bucket
                            else
                                ProgramExitCode = 3;
                        }
                        else
                        {
                            ResponseStatusCode = (int)HttpWebErrorResponse.StatusCode;
                            StageLog.WriteToLog("ERROR: Response Status Code received: " + ResponseStatusCode.ToString() + "-" + HttpWebErrorResponse.StatusCode.ToString());
                            StageLog.WriteToLog("ERROR: Response Status Description received: " + HttpWebErrorResponse.StatusCode.ToString());

                            //Analyse Status Code and set ProgramExitCode appropriately
                            foreach (int IgnoredResponseCode in ResponseCodesToIgnore)
                            {
                                if (ResponseStatusCode == IgnoredResponseCode)
                                {
                                    StageLog.WriteToLog("INFO: This Error Response will be ignored due to exclusion.");
                                    IsWebErrorIgnored = true;
                                }
                            }

                            if (!IsWebErrorIgnored)
                            {
                                if (ProgramExitCode == 3)
                                    ProgramExitCode = 5;                //There's already a connection error in bucket
                                else
                                    ProgramExitCode = 4;
                            }
                        }
                    }
                    catch (Exception Error)
                    {
                        StageLog.WriteToLog("ERROR: Error occured while downloading " + RemoteURI + "/" + BuildFile);
                        StageLog.WriteToLog("ERROR: " + Error.Message);
                        if (Error.InnerException != null)
                            StageLog.WriteToLog("ERROR: " + Error.InnerException.ToString());
                        StageLog.WriteToLog("ERROR: " + Error.StackTrace.ToString());
                        if (ProgramExitCode == 0)
                            ProgramExitCode = 6;
                    }
                }
                ProcessedFileCount++;
                PercentComplete = ((double)ProcessedFileCount / (double)TotalFiles) * 100;
                Console.Write("INFO: Downloading files .... " + PercentComplete.ToString("0.##") + "% done.       \r");
            } 
            #endregion

            #region Final Message and Cleanup
            if (ProgramExitCode!=0)
            {
                Console.ForegroundColor = ConsoleColor.Yellow;
                Console.WriteLine("WARN: One or more download tasks resulted in an non-excluded error.");
                Console.WriteLine("WARN: Please check the Log file for more details.");
                Console.ResetColor();
                StageLog.WriteToLog("WARN: One or more download tasks resulted in an non-excluded error.");
            }
            else
            {
                Console.ForegroundColor = ConsoleColor.White;
                Console.WriteLine("INFO: All the required build files have been downloaded ");
                Console.WriteLine("INFO: and staged to '" + LocalStagePath + "' successfully.");
                Console.ResetColor();
                StageLog.WriteToLog("INFO: All required files downloaded and staged to '" + LocalStagePath + "' successfully.");
            }

            LogExitCodeMessage(ProgramExitCode);
            LocalBuild = null;
            ExclusionFileHandler = null;
            StageLog.CloseLog();
            #endregion

            return (ProgramExitCode);
        }

        /// <summary>
        /// Prints the Welcome Text.
        /// </summary>
        private static void PrintWelcome()
        {
            Console.ForegroundColor = ConsoleColor.White;
            Console.Clear();
            Console.WriteLine("Remote File Stager v" + Assembly.GetCallingAssembly().GetName().Version.ToString());
            Console.WriteLine("(C) Microsoft Corporation. For Internal Use only.");
            Console.WriteLine(" ");
            Console.ResetColor();
        }

        /// <summary>
        /// Prints the Help Text.
        /// </summary>
        private static void PrintHelp()
        {
            Console.ForegroundColor = ConsoleColor.White;
            Console.WriteLine(" ");
            Console.WriteLine("HELP: Usage:");
            Console.WriteLine("HELP:   RemoteFileStager.exe [options]");
            Console.WriteLine("HELP: where - ");
            Console.WriteLine("HELP: [options] are:");
            Console.WriteLine("HELP:   /bp:<Build_Root_Path> - This is the local path to the root of the build");
            Console.WriteLine("HELP:                           to be compared to.");
            Console.WriteLine("HELP:   /u:<Remote_URL>       - This is the base remote URL hosting the build.");
            Console.WriteLine("HELP:                           Files will be downloaded from here.");
            Console.WriteLine("HELP:   /sp:<Stage_Path>      - This is the local path under which the ");
            Console.WriteLine("HELP:                           downloaded files will be staged.");
            Console.WriteLine("HELP:   /rs:<Response_String> - An optional string that will be appended to all");
            Console.WriteLine("HELP:                           outgoing Request Strings.");
            Console.WriteLine(" ");
        }

        /// <summary>
        /// Converts File List in the local file system format to remote URL file system format.
        /// </summary>
        /// <param name="LocalFileList">The List of all the local files</param>
        /// <returns></returns>
        private static string[] ConvertLocalFileListToRemote(string[] LocalFileList)
        {
            string[] RemoteFileList = new string[LocalFileList.Length];
            int i = 0;

            foreach (string FileName in LocalFileList)
            {
                RemoteFileList[i] = FileName.Replace('\\', '/');
                i++;
            }

            return RemoteFileList;
        }

        /// <summary>
        /// Format URL to standard notation.
        /// </summary>
        /// <param name="UnformattedURL">The RAW unformatted URL string</param>
        /// <returns></returns>
        private static string ReformatURL(string UnformattedURL)
        {
            string FormattedURL = UnformattedURL;

            //Replace all '\' with '/'
            FormattedURL = FormattedURL.Replace('\\', '/');

            //Strip off leading '//' if any
            if (FormattedURL.Length > 2)
                if (String.Compare(FormattedURL.Substring(0, 2), "//", true) == 0)
                    FormattedURL = FormattedURL.Substring(2);
            
            //Check if http:// already exists.
            if (FormattedURL.Length > 7)
            {
                if (String.Compare(FormattedURL.Substring(0, 7), "http://", true) != 0)
                    FormattedURL = "http://" + FormattedURL;
            }
            else
                FormattedURL = "http://" + FormattedURL;

            
            //Strip off trailing '/'
            if (FormattedURL.Substring(FormattedURL.Length - 1) == "/")
                FormattedURL = FormattedURL.Substring(0, FormattedURL.Length - 1);

            return FormattedURL;
        }

        /// <summary>
        /// Log the exit code and its description.
        /// </summary>
        /// <param name="ExitCode">The Exit Code.</param>
        private static void LogExitCodeMessage(int ExitCode)
        {
            switch (ExitCode)
            {
                case 0:
                    StageLog.WriteToLog("INFO: Program exiting with code 0 (SUCCESS)");
                    break;
                case 1:
                    StageLog.WriteToLog("INFO: Program exiting with code 1 (ERROR_IN_OBJECT_INITIALIZATION)");
                    break;
                case 2:
                    StageLog.WriteToLog("INFO: Program exiting with code 2 (INVALID_ARGUMENTS)");
                    break;
                case 3:
                    StageLog.WriteToLog("INFO: Program exiting with code 3 (FATAL_ERROR_WHILE_ESTABLISHING_CONNECTION)");
                    break;
                case 4:
                    StageLog.WriteToLog("INFO: Program exiting with code 4 (FATAL_ERROR_WHILE_DOWNLOADING)");
                    break;
                case 5:
                    StageLog.WriteToLog("INFO: Program exiting with code 5 (FATAL_ERROR_WHILE_CONNECTING_AND_DOWNLOADING)");
                    break;
                case 6:
                    StageLog.WriteToLog("INFO: Program exiting with code 6 (GENERAL_ERROR)");
                    break;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\SitesPostDeploymentCheck\TestCollection.cs ===
﻿namespace SitesPostDeploymentCheck
{
    using System.Collections.Generic;

    /// <summary>
    /// Represents a collection of tests
    /// </summary>
    public class TestCollection
    {
        /// <summary>
        /// Gets or sets the list of tests per environment
        /// </summary>
        public List<TestsPerEnvironment> Tests { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\SitesPostDeploymentCheck\SitesPostDeploymentCheck.cs ===
﻿namespace SitesPostDeploymentCheck
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Net;
    using System.Text;

    /// <summary>
    /// Does a quick post-deployment check for Xbox.com sites
    /// </summary>
    public class SitesPostDeploymentCheck
    {
        /// <summary>
        /// Converts a given status code to its integer equivalent (example: 200 - OK, 404 - Not Found, etc.)
        /// </summary>
        /// <param name="statusCode">the status code</param>
        /// <returns>the number that the code represents</returns>
        private static int ConvertStatusCode(HttpStatusCode statusCode)
        {
            switch (statusCode)
            {
                case HttpStatusCode.OK:
                    return 200;
                case HttpStatusCode.Unauthorized:
                    return 401;
                case HttpStatusCode.Forbidden:
                    return 403;
                case HttpStatusCode.NotFound:
                    return 404;
            }

            // Otherwise, return a 0 for now
            return 0;
        }

        /// <summary>
        /// Retrieves a web page, given the provided URL, which is returned as a string
        /// </summary>
        /// <param name="url">the URL of the page to fetch (example: http://games.xbox.com)</param>
        /// <param name="statusCodeResult">out value of the status code result</param>
        /// <returns>a string containing the contains of the web request</returns>
        private static string GetWebPage(string url, out int statusCodeResult)
        {
            StringBuilder sb = new StringBuilder();
            byte[] buf = new byte[8192];
            string tempString = null;
            int count = 0;

            // Create the request and response
            HttpWebRequest req = (HttpWebRequest)HttpWebRequest.Create(new Uri(url));
            HttpWebResponse res = (HttpWebResponse)req.GetResponse();

            // Save the status code
            statusCodeResult = ConvertStatusCode(res.StatusCode);

            if (res.StatusCode != HttpStatusCode.OK)
            {
                // If not OK, then don't bother getting the page content
                return null;
            }

            Stream resStream = res.GetResponseStream();

            // Read from the stream until there is no more to read
            do
            {
                count = resStream.Read(buf, 0, buf.Length);

                if (count != 0)
                {
                    tempString = Encoding.ASCII.GetString(buf, 0, count);
                    sb.Append(tempString);
                }
            }
            while (count > 0);

            // Return the final string
            return sb.ToString();
        }

        /// <summary>
        /// Verifies a page by checking that it contains the expected text
        /// </summary>
        /// <param name="url">the URL of the page to check</param>
        /// <param name="expectedStatusCode">the expected status code</param>
        /// <param name="expectedText">the expected text</param>
        /// <returns>a boolean result of the check</returns>
        private static bool VerifyPage(string url, int expectedStatusCode, string expectedText)
        {
            string actualResult;
            int actualStatusCode;

            Console.WriteLine(String.Format("Checking URL: {0}", url));

            try
            {
                actualResult = GetWebPage(url, out actualStatusCode);
            }
            catch (Exception e)
            {
                if (expectedStatusCode == 401)
                {
                    if (e.Message.Contains("(401) Unauthorized"))
                    {
                        // In this case, we're fine
                        return true;
                    }
                }

                Console.WriteLine("--- TEST FAILED ---");
                Console.WriteLine(String.Format("Exception loading page: {0}", e.Message));
                Console.WriteLine(e.StackTrace);
                return false;
            }

            // Match the status codes
            if (expectedStatusCode != actualStatusCode)
            {
                Console.WriteLine("--- TEST FAILED ---");
                Console.WriteLine("Status code incorrect");
                Console.WriteLine(String.Format("Expected: {0}", expectedStatusCode));
                Console.WriteLine(String.Format("Actual: {0}", actualStatusCode));
                return false;
            }

            // If expected text isn't empty, then check the text of the page
            if (!expectedText.Equals(string.Empty))
            {
                if (!actualResult.Contains(expectedText))
                {
                    Console.WriteLine("--- TEST FAILED ---");
                    Console.WriteLine("Expected text not found");
                    Console.WriteLine(String.Format("Expected: {0}", expectedText));
                    Console.WriteLine(String.Format("Actual: {0}", actualResult));
                    return false;
                }
            }

            return true;
        }

        /// <summary>
        /// Runs tests against the given environment
        /// </summary>
        /// <param name="environment">the environment to run the test on (dev, storax, test, stress, int2, partner, cert, prod)</param>
        /// <param name="siteToTest">the site component to test</param>
        /// <returns>exit code that the application should return (tests passed or failed)</returns>
        private static int RunTests(string environment, string siteToTest)
        {
            int testFailures = 0;

            List<SmokeTest> siteTests = XmlUtility.LoadTests(environment, siteToTest);

            try
            {
                Console.WriteLine("---------------------");
                Console.WriteLine("RUNNING TESTS");
                Console.WriteLine("---------------------");

                foreach (SmokeTest test in siteTests)
                {
                    // Check each page and if it ever fails, increment the number of test failures
                    if (!VerifyPage(test.URL, test.ExpectedStatusCode, test.ExpectedText))
                    {
                        testFailures++;
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine("Exception encountered: " + ex.Message);
                Console.WriteLine(ex.StackTrace);

                testFailures++;
            }

            Console.WriteLine("---------------------");
            Console.WriteLine("TEST RESULTS");
            Console.WriteLine("---------------------");
            Console.WriteLine(String.Format("# of Tests: {0}", siteTests.Count));
            Console.WriteLine(String.Format("# Passed: {0}", siteTests.Count - testFailures));
            Console.WriteLine(String.Format("# Failed: {0}", testFailures));

            if (testFailures == 0)
            {
                // Everything passes
                return 0;
            }
            else
            {
                // We have at least one failure
                return 1;
            }
        }

        /// <summary>
        /// Main section
        /// </summary>
        /// <param name="args">args passed via command-line</param>
        /// <returns>exit code of 0 (pass) or 1 (fail)</returns>
        private static int Main(string[] args)
        {
            if (args.Length < 2)
            {
                Console.WriteLine("--------------------------------");
                Console.WriteLine("SitesPostDeploymentCheck Utility");
                Console.WriteLine("--------------------------------");
                Console.WriteLine("USAGE:");
                Console.WriteLine("\tSitesPostDeploymentCheck.exe [environment] [site]");
                Console.WriteLine("\n\t[environment] = livenoob | storax | testnet | stress | int2 | partnernet | certnet | prod");
                Console.WriteLine("\n\t[site] = all | cosmos | dante | games | marketplace | myxbox");
                Console.WriteLine("EXAMPLE:");
                Console.WriteLine("\tSitesPostDeploymentCheck.exe testnet marketplace");
                Console.WriteLine("\t\tTests Marketplace sites under TestNet");
                return 1;
            }

            return RunTests(args[0].ToLower(), args[1].ToLower());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\RemoteFileStager\RemoteFileStager\RemoteBuildLayer.cs ===
﻿using System;
using System.Text;
using System.Net;
using System.Net.Cache;
using System.IO;

namespace Test.Common.Utilities.RemoteFileStager
{
    /// <summary>
    /// Layer for Remote Build access over HTTP.
    /// </summary>
    internal class RemoteBuildLayer
    {
        private HttpWebRequest WebRequestObject;
        private string RemoteFilePath;
        private string[] ExcludedResponses;

        /// <summary>
        /// Instantiate a new object of the RemoteBuildLayer.
        /// </summary>
        /// <param name="RemoteBaseURI">The Base URI of the remote site.</param>
        /// <param name="RemoteBuildFile">The relative path to the Remote Build file to be accessed.</param>
        /// <param name="ResponsesToIgnore">The List of responses to ignore, for which no file will be staged.</param>
        public RemoteBuildLayer(string RemoteBaseURI, string RemoteBuildFile, string[] ResponsesToIgnore)
        {
            //Set Cache Policy
            RequestCachePolicy CachePolicy = new RequestCachePolicy(RequestCacheLevel.BypassCache);

            RemoteFilePath = RemoteBuildFile;
            ExcludedResponses = ResponsesToIgnore;
            
            try
            {
                //Create the Request Object
                WebRequestObject = (HttpWebRequest)WebRequest.Create(RemoteBaseURI + '/' + RemoteFilePath);
                WebRequestObject.CachePolicy = CachePolicy;
                WebRequestObject.Credentials = System.Net.CredentialCache.DefaultCredentials;
                WebRequestObject.UserAgent = "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; Trident/4.0)";
            }
            catch (Exception)
            {
                throw;
            }
        }

        /// <summary>
        /// Instantiate a new object of the RemoteBuildLayer.
        /// </summary>
        /// <param name="RemoteBaseURI">The Base URI of the remote site.</param>
        /// <param name="RemoteBuildFile">The relative path to the Remote Build file to be accessed.</param>
        /// <param name="ResponsesToIgnore">The List of responses to ignore, for which no file will be staged.</param>
        /// <param name="RequestStringToAppend">An optional string to append to the Request String.</param>
        public RemoteBuildLayer(string RemoteBaseURI, string RemoteBuildFile, string[] ResponsesToIgnore, string RequestStringToAppend)
        {
            //Set Cache Policy
            RequestCachePolicy CachePolicy = new RequestCachePolicy(RequestCacheLevel.BypassCache);

            RemoteFilePath = RemoteBuildFile;
            ExcludedResponses = ResponsesToIgnore;

            try
            {
                //Create the Request Object
                WebRequestObject = (HttpWebRequest)WebRequest.Create(RemoteBaseURI + '/' + RemoteFilePath + RequestStringToAppend);
                WebRequestObject.CachePolicy = CachePolicy;
                WebRequestObject.Credentials = System.Net.CredentialCache.DefaultCredentials;
                WebRequestObject.UserAgent = "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; Trident/4.0)";
            }
            catch (Exception)
            {
                throw;
            }
        }
        
        /// <summary>
        /// Download a copy of the Remote File to the Local Download Folder.
        /// </summary>
        /// <param name="LocalDownloadFolder">The Local folder where the remote file will be downloaded.</param>
        public void DownloadFile(string LocalDownloadFolder)
        {
            HttpWebResponse WebResponseObject;
            Stream HttpResponseStream = null;
            FileStream LocalFileStream = null;
            ASCIIEncoding ByteEncoder = new ASCIIEncoding();
            byte[] ReadBuffer = new byte[1024];                 //Read 1KB data at a time
            string BuildFileName = ExtractBinaryFileName(RemoteFilePath);
            string BuildFilePath = LocalDownloadFolder + '\\' + ExtractBinaryPath(RemoteFilePath).Replace('/', '\\');
            int BytesRead = 0;
            StringBuilder ResponseString = new StringBuilder();            //Use StringBuilder, since System.String is not mutable

            //Check if Local Download Folder exists. If not, then create it
            if (!Directory.Exists(LocalDownloadFolder))
                Directory.CreateDirectory(LocalDownloadFolder);
            //Check if the Build File Path exists. If not, then create it
            if (!Directory.Exists(BuildFilePath))
                Directory.CreateDirectory(BuildFilePath);

            try
            {
                WebResponseObject = (HttpWebResponse)WebRequestObject.GetResponse();
                HttpResponseStream = WebResponseObject.GetResponseStream();
                LocalFileStream = new FileStream(BuildFilePath + '\\' + BuildFileName, FileMode.Create, FileAccess.Write);

                BytesRead = HttpResponseStream.Read(ReadBuffer, 0, 1024);
                while (BytesRead != 0)
                {
                    ResponseString.Append(ByteEncoder.GetString(ReadBuffer));
                    LocalFileStream.Write(ReadBuffer, 0, BytesRead);
                    BytesRead = HttpResponseStream.Read(ReadBuffer, 0, 1024);
                }
                LocalFileStream.Close();
            }
            catch (WebException WebError)
            {
                if (LocalFileStream != null)
                    LocalFileStream.Close();
                throw new WebException(WebError.Message, WebError.InnerException, WebError.Status, WebError.Response);
            }
            catch (Exception)
            {
                if (LocalFileStream != null)
                    LocalFileStream.Close();
                throw;
            }

            //Check if Response is among the excluded Responses
            foreach (string Response in ExcludedResponses)
            {
                if (ResponseString.Length >= Response.Length)
                    if (String.Compare(Response, ResponseString.ToString(0, Response.Length), true) == 0)
                        File.Delete(BuildFilePath + '\\' + BuildFileName);
            }
        }

        /// <summary>
        /// Get the Binary File name from the full binary path.
        /// </summary>
        /// <param name="FullBinaryPath">The full path of the Binary File, including the file name.</param>
        /// <returns></returns>
        private string ExtractBinaryFileName(string FullBinaryPath)
        {
            return FullBinaryPath.Substring(FullBinaryPath.LastIndexOf(@"/") + 1);
        }

        /// <summary>
        /// Get the Path of the Binay file from the full binary path.
        /// </summary>
        /// <param name="FullBinaryPath">The full path of the Binary File, including the file name.</param>
        /// <returns></returns>
        private string ExtractBinaryPath(string FullBinaryPath)
        {
            if (FullBinaryPath.LastIndexOf(@"/") == -1)                 //File is at root
                return "";
            else
                return FullBinaryPath.Substring(0, FullBinaryPath.LastIndexOf(@"/"));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\RemoteFileStager\RemoteFileStager\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("RemoteFileStager")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("")]
//[assembly: AssemblyProduct("RemoteFileStager")]
//[assembly: AssemblyCopyright("")]
//[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("6889d405-d330-4fdd-bc65-a5d5c0e132df")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
//[assembly: AssemblyVersion("")]
//[assembly: AssemblyFileVersion("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\SitesPostDeploymentCheck\SmokeTest.cs ===
﻿namespace SitesPostDeploymentCheck
{
    /// <summary>
    /// Represents a smoke test
    /// </summary>
    public class SmokeTest
    {
        /// <summary>
        /// Gets or sets site that this tests
        /// </summary>
        public string SiteComponent { get; set; }

        /// <summary>
        /// Gets or sets the URL to the page to test
        /// </summary>
        public string URL { get; set; }

        /// <summary>
        /// Gets or sets the expected status code
        /// </summary>
        public int ExpectedStatusCode { get; set; }

        /// <summary>
        /// Gets or sets the expected text (and String.Empty if don't care)
        /// </summary>
        public string ExpectedText { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\TakeScreenShot\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\URLBasedTests\CheckEmailsForUrlBasedTests\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\SitesPostDeploymentCheck\TestsPerEnvironment.cs ===
﻿namespace SitesPostDeploymentCheck
{
    using System.Collections.Generic;

    /// <summary>
    /// Represents a set of tests for an environment
    /// </summary>
    public class TestsPerEnvironment
    {
        /// <summary>
        /// Gets or sets the environment
        /// </summary>
        public string Environment { get; set; }

        /// <summary>
        /// Gets or sets the list of tests
        /// </summary>
        public List<SmokeTest> TestList { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\SitesPostDeploymentCheck\XmlUtility.cs ===
﻿namespace SitesPostDeploymentCheck
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Xml.Serialization;

    /// <summary>
    /// Utility for reading the XML file
    /// </summary>
    public static class XmlUtility
    {
        /// <summary>
        /// Sets up the tests to run
        /// </summary>
        /// <param name="environment">the environment to verify</param>
        /// <param name="siteToTest">the site component to test</param>
        /// <returns>a list of smoke tests</returns>
        public static List<SmokeTest> LoadTests(string environment, string siteToTest)
        {
            List<SmokeTest> smokeTests = new List<SmokeTest>();

            TestCollection testCollection = GetTestCollection();

            // Iterate through every list of tests in the XML file
            foreach (TestsPerEnvironment testsPerEnvironment in testCollection.Tests)
            {
                // Only check the list if it matches the environment we want to test
                if (testsPerEnvironment.Environment.ToLower().Equals(environment.ToLower()))
                {
                    foreach (SmokeTest test in testsPerEnvironment.TestList)
                    {
                        // Only add the test if it's the for the site we want to test (or for all)
                        if (test.SiteComponent.ToLower().Equals(siteToTest.ToLower()) || siteToTest.Equals("all"))
                        {
                            smokeTests.Add(test);
                        }
                    }
                }
            }

            return smokeTests;
        }

        /// <summary>
        /// Loads the required environment and profile data from XML files.
        /// </summary>
        /// <returns>the TestCollection representing the XML file</returns>
        public static TestCollection GetTestCollection()
        {
            TestCollection testCollection = null;

            // Check for SmokeTests.xml file
            if (!File.Exists(@"SmokeTests.xml"))
            {
                throw new FileNotFoundException("The file 'SmokeTests.xml' does not exist.");
            }

            testCollection = (TestCollection)LoadXmlObject(typeof(TestCollection), "SmokeTests.xml");

            return testCollection;
        }

        /// <summary>
        /// Load an object from the specified XML file.
        /// </summary>
        /// <param name="typeOfObject">The type of the object to load.</param>
        /// <param name="xmlFileName">The XML filename which contains the serialized object.</param>
        /// <returns>An object which is stored in the specified XML file.</returns>
        public static object LoadXmlObject(Type typeOfObject, string xmlFileName)
        {
            XmlSerializer serializer = new XmlSerializer(typeOfObject);
            object stateObject;

            using (TextReader reader = new StreamReader(xmlFileName))
            {
                stateObject = serializer.Deserialize(reader);
            }

            return stateObject;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\URLBasedTests\UrlBasedTestService\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\SitesPostDeploymentCheck\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("SitesPostDeploymentCheck")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("67eb16ab-2b77-4c53-a81f-f4ac851d33f3")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\TakeScreenShot\TakeScreenShot\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("TakeScreenShot")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("MSIT")]
//[assembly: AssemblyProduct("TakeScreenShot")]
//[assembly: AssemblyCopyright("Copyright © MSIT 2008")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("42e75683-05df-460a-9f0a-c60eac70eea3")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
//[assembly: AssemblyVersion("1.0.0.0")]
//[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\URLBasedTests\CheckEmailsForUrlBasedTests\CheckEmailsForUrlBasedTests\Program.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Net;
using System.Net.NetworkInformation;
using System.Net.Mail;
using System.IO;
using System.Xml;
using System.Collections;
using System.Configuration;

// This program will check that the url based tests on the various
// machines were run recently. If not, it will send an email alert.
namespace Test.Common.Utilities.CheckEmailsForUrlBasedTests
{
    class Program
    {
        static string emailNodePath;
        static int sleepInMilliseconds;
        static int checksPerDay;
        static string folder;
        static string responseTextFile;
        static string machineNodes;
        static ArrayList EmailListTo;
        static string emailFrom;
        static void Main(string[] args)
        {
            emailNodePath = ConfigurationSettings.AppSettings["emailNode"].ToString();
            sleepInMilliseconds = Convert.ToInt32(ConfigurationSettings.AppSettings["sleepInMilliseconds"].ToString());
            checksPerDay = Convert.ToInt32(ConfigurationSettings.AppSettings["checksPerDay"].ToString());
            folder = ConfigurationSettings.AppSettings["folder"].ToString();
            responseTextFile = ConfigurationSettings.AppSettings["responseTextFile"].ToString();
            machineNodes = ConfigurationSettings.AppSettings["machineNodes"].ToString();
            ArrayList MachineObjects = GetMachineObjects();
            EmailListTo = new ArrayList();
            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(responseTextFile);
            XmlNode emailNode = xDoc.SelectSingleNode(emailNodePath);
            foreach (XmlNode childNode in emailNode)
            {
                if (childNode.Name == "emailFrom")
                    emailFrom = childNode.InnerText;
                else if (childNode.Name == "emailTo")
                    EmailListTo.Add(childNode.InnerText);
            }
            int i = 0;
            try
            {
                while (true)
                {
                    i++;
                    CheckThatEmailIsActive(MachineObjects, i);
                    System.Threading.Thread.Sleep(sleepInMilliseconds);
                    i %= checksPerDay;
                }
            }
            catch (Exception e)
            {
                Console.WriteLine(e.Message);
            }
        }

        /// <summary>
        /// Get the most recent run for this machine
        /// </summary>
        /// <param name="machine"></param>
        /// <returns></returns>
        static string GetMostRecentRun(string machine)
        {
            string date = string.Empty;

            XmlDocument xDoc = new XmlDocument();
            xDoc.Load(responseTextFile);
            XmlNodeList NodeMachines = xDoc.SelectNodes(machineNodes);
            foreach (XmlNode node in NodeMachines)
            {
                if (machine == node.Attributes["name"].Value)
                {
                    date = node.Attributes["DateOfRun"].Value;
                    break;
                }
            }

            return date;
        }

        /// <summary>
        /// This code will loop through all the machines running url browser tests and
        /// make sure they had a recent run. Otherwise will send an email alert.
        /// </summary>
        /// <param name="MachineObjects">The machines that are running url browser tests</param>
        /// <param name="i"></param>
        static void CheckThatEmailIsActive(ArrayList MachineObjects, int i)
        {
            foreach (MachinesObject machineObject in MachineObjects)
            {
                string date = string.Empty;
                int period = Convert.ToInt32(machineObject.Period);
                int minutes = period / (1000 * 60);
                if (i * sleepInMilliseconds % period != 0)
                    continue;
                bool timeIsRecent = true;

                date = GetMostRecentRun(machineObject.Machines);
                
                if (date != null)
                {
                    DateTime lastDate = Convert.ToDateTime(date);
                    DateTime timeNow = DateTime.Now;

                    TimeSpan span = timeNow.Subtract(lastDate);
                    if (span.TotalMinutes > (minutes + 90))
                    {
                        timeIsRecent = false;
                    }
                }

                if (!timeIsRecent)
                    SendEmail(timeIsRecent, date, machineObject.EmailTitle, machineObject.Machines);
            }
        }

        /// <summary>
        /// Sends email if a machine has not run url based test recently.
        /// </summary>
        /// <param name="timeIsRecent"></param>
        /// <param name="lastDate"></param>
        /// <param name="title"></param>
        /// <param name="machine"></param>
        static void SendEmail(bool timeIsRecent, string lastDate, string title, string machine)
        {
            string smtpServer = "smtphost.redmond.corp.microsoft.com";
            string body = "<p>test</p>";
            body = "<p>Last run of the url based test is old: " + lastDate + "</p>";
            body += "<p>This is running on the machine " + machine + ". You can log on with the username ztest01 to investigate.</p>";
            try
            {
                SmtpClient smtpClient = new SmtpClient(smtpServer);
                MailMessage mailMessage = new MailMessage(emailFrom, emailFrom);
                mailMessage.To.Clear();
                foreach (string et in EmailListTo)
                {
                    mailMessage.To.Add(et);
                }
                mailMessage.Subject = "MSN/MSGR Games " + title + " EMAIL STOPPED " + DateTime.Now;
                mailMessage.IsBodyHtml = true;
                mailMessage.Body = body;
                mailMessage.Priority = MailPriority.Normal;
                smtpClient.UseDefaultCredentials = true;
                smtpClient.DeliveryMethod = SmtpDeliveryMethod.Network;
                smtpClient.Send(mailMessage);
            }

            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
                
            }
        }

        /// <summary>
        /// Gets all the machines that are running url based tests.
        /// </summary>
        /// <returns></returns>
        static ArrayList GetMachineObjects()
        {
            XmlDocument xDoc = new XmlDocument();
            ArrayList MachineObjects = new ArrayList();
            xDoc.Load(responseTextFile);
            XmlNodeList NodeMachines = xDoc.SelectNodes(machineNodes);
            string machine = string.Empty;
            string emailTitle = string.Empty;
            string period = string.Empty;
            string dateOfRun = string.Empty;
            foreach (XmlNode node in NodeMachines)
            {
                machine = node.Attributes["name"].Value;
                period = node.Attributes["period"].Value;
                emailTitle = node.Attributes["title"].Value;
                dateOfRun = node.Attributes["DateOfRun"].Value;

                MachineObjects.Add(new MachinesObject(machine, period, emailTitle, dateOfRun));
            }
            return MachineObjects;
        }
    }


    class MachinesObject
    {
        string machines;
        string period;
        string emailTitle;
        string dateOfRun;

        public MachinesObject(string machines, string period, string emailTitle, string dateOfRun)
        {
            this.machines = machines;
            this.period = period;
            this.emailTitle = emailTitle;
            this.dateOfRun = dateOfRun;
        }
        public string Machines
        {
            get { return machines; }
        }
        public string Period
        {
            get { return period; }
        }
        public string EmailTitle
        {
            get { return emailTitle; }
        }
        public string DateOfRun
        {
            get { return dateOfRun; }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\TakeScreenShot\TakeScreenShot\Program.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.WLX.CXP.WebPageGrabber;
using System.Threading;
//using System.Drawing;
//using System.Drawing.Imaging;
//using System.Windows.Forms;

namespace Test.Common.Utilities.TakeScreenShot
{
    class Program
    {
        [STAThread]
        static int Main(string[] args)
        {
          // Console.ReadLine();
            int exitcode = 0;
            string url = "http://zone.msn.com";
            string pathOfScreeShot = string.Empty;
            int delay = 15;
          
            #region parsing input parameters.
            if (args.Length > 0)
            {
                if (args[0] == "?" || args[0] == "/?" || args[0].ToLower() == "help" || args[0] == "Help" || args[0] == "HELP")
                {
                    exitcode = 100;
                    Console.WriteLine("This tool takes 3 input paramters and all are optional.You can or can not provide any of these parameters.");
                    Console.WriteLine("These parameters are :: /url: /delay: /resultpath");
                    Console.WriteLine("An example.");
                    Console.WriteLine("TakeScreenShot.exe /url:http://msn.com /delay:15 /resultpath:c:\\screenshots\\screenshot1.png");
                    return exitcode;

                }

                else
                {
                    string[] ch = new string[5];
                    string argutype;
                    char[] sep = new char[] { ':' };
                    ch = args[0].Split(sep);


                    for (int i = 0; i <= args.Length - 1; i++)
                    {
                        ch = args[i].Split(sep);
                        argutype = ch[0];
                        Console.WriteLine(argutype + ": " + ch[1]);

                        if (argutype.ToLower() == "/url")
                        {
                            url = "http:" + ch[2];
                        }
                        else
                        {
                            if (argutype.ToLower() == "/delay")
                            {
                                delay = Convert.ToInt32(ch[1]);
                            }
                            else
                            {
                                if (argutype.ToLower() == "/resultpath")
                                {
                                    if (ch.Length > 2)
                                    {
                                        pathOfScreeShot = ch[1] + ":" + ch[2];
                                    }
                                    else
                                    {
                                        pathOfScreeShot = ch[1];
                                    }
                                }
                            }

                        }
                    }
                }


            }
            #endregion parsing input parameters.

           // objpercentage.createScreenShot(url,delay);
            #region using webGrabber
            GrabberOptions options = GrabberOptions.Default;
            options.Delay = delay;
            if (pathOfScreeShot == string.Empty)
            {
                exitcode = 1;
                Console.WriteLine("Please provide the ResultPath. For more options type TakeSceenShot.exe ?");
                return exitcode;
                //options.Outputfile = "C:\\AlertReporting\\EventTrends.png";
            }
            else
            {
                options.Outputfile = pathOfScreeShot;
            }
            try
            {
                BrowserControlDriver.Ie7Driver.FullPageScreenShot(url, options);
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);

            }
            #endregion using webGrabber

            return exitcode;
           
        }


    }

   
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\URLBasedTests\UrlBasedTestsExe\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\URLBasedTests\CheckEmailsForUrlBasedTests\CheckEmailsForUrlBasedTests\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("CheckEmailsForUrlBasedTests")]
[assembly: AssemblyDescription("")]
//[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("MSIT")]
//[assembly: AssemblyProduct("CheckEmailsForUrlBasedTests")]
//[assembly: AssemblyCopyright("Copyright © MSIT 2009")]
//[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("5500a215-5526-4ff2-b0f8-5841e088c547")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
//[assembly: AssemblyVersion("1.0.0.0")]
//[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\URLBasedTests\UrlBasedTestsWebsite\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\URLBasedTests\UrlBasedTestService\UrlBasedTestService\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("UrlBasedTestService")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("MSIT")]
//[assembly: AssemblyProduct("UrlBasedTestService")]
//[assembly: AssemblyCopyright("Copyright © MSIT 2009")]
//[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("d6cb57bc-6e5c-4d1c-9cfa-a882773d26a3")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
//[assembly: AssemblyVersion("1.0.0.0")]
//[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\TestSource\Common\Utilities\URLBasedTests\UrlBasedTestService\UrlBasedTestService\Program.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.Diagnostics;
using System.IO;
using System.Xml;
using System.Configuration;
using System.Threading;

// This program schedules to run the url based test based on configured values

namespace Test.Common.Utilities.UrlBasedTestService
{
    class Program
    {
        static string urlBasedTestExe;  // The executable that will be schedule to run
        static string urlBasedTestExeFiddler;  // The fiddler executable that will be schedule to run
        static string urlBasedTestExeName; // name of fiddler url based test executable
        static string urlBasedTestExeFiddlerName; // name of fiddler url based test executable
        static string responseTextFile; // File where the values are configured
        static string machineNodes; // Path to the nodes in the config value
        static string LogFile; // Log file that keeps track of exception and errors
        static string LogFileOld; // Temporily keeps old log values when the current log file is cleaned
        static string Log_MissingText; // Log