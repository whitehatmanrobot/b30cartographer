har * const           s_rgszVerifyPhases[];
    #endif
};

// ---------------------------------------------------------------------------------------
// Inlines
// ---------------------------------------------------------------------------------------

INLINE void * XoSysAlloc(size_t cb, ULONG tag)
{
#ifdef XNET_FEATURE_VMEM
    if (VMemIsEnabled())
        return(VMemAlloc(cb));
#endif
#ifdef XONLINE_FEATURE_WINDOWS
    return(LocalAlloc(LMEM_FIXED, cb));
#else
    return(ExAllocatePoolWithTag(cb, tag));
#endif
}

INLINE void XoSysFree(void * pv)
{
    if (pv != NULL)
    {
    #ifdef XNET_FEATURE_VMEM
        if (VMemIsEnabled())
        {
            VMemFree(pv);
            return;
        }
    #endif

    #ifdef XONLINE_FEATURE_WINDOWS
        LocalFree(pv);
    #else
        ExFreePool(pv);
    #endif
    }
}

INLINE void * CXo::SysAlloc(size_t cb, ULONG tag)
{
    void * pv = XoSysAlloc(cb, tag);

#ifdef XNET_FEATURE_ASSERT
    XnLeakAdd(&m_LeakInfo, pv, cb, tag);
#endif

    return(pv);
}

INLINE void * CXo::SysAllocZ(size_t cb, ULONG tag)
{
    void * pv = XoSysAlloc(cb, tag);

    if (pv != NULL)
    {
        #ifdef XNET_FEATURE_ASSERT
        XnLeakAdd(&m_LeakInfo, pv, cb, tag);
        #endif

        memset(pv, 0, cb);
    }

    return(pv);
}

INLINE void CXo::SysFree(void * pv)
{
    #ifdef XNET_FEATURE_ASSERT
    XnLeakDel(&m_LeakInfo, pv);
    #endif

    XoSysFree(pv);
}

#ifdef XONLINE_FEATURE_XBOX
extern CXo * g_pXo;
#define GetXo()      g_pXo
#define GetXoRef()  &g_pXo
#endif

// ---------------------------------------------------------------------------------------

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xrlutil.cpp ===
/*++

Copyright (c) Microsoft Corporation

Author:
    Keith Lau (keithlau)

Description:
	Module implementing common functionality for asynchronous XRL

Module Name:

    xrlutil.c

--*/

#include "xonp.h"
#include "xonver.h"

//
// Request strings - all are ANSI. HTTP headers are always ANSI. These 
// strings are used for request packets
//
const char XRL_HEADER_GET_AND_AGENT[] =	"GET %s HTTP/1.1\r\nUser-Agent: %x/1.0\r\n";
const char XRL_HEADER_POST_AND_AGENT[] =	"POST %s HTTP/1.0\r\nUser-Agent: %x/1.0\r\n";
const char XRL_HEADER_HOST[] =				"Host: %d.%d.%d.%d\r\n";
const char XRL_HEADER_CONTENT_LENGTH[] =	"Content-Length: %I64u\r\n";
const char XRL_HEADER_IFRANGE[] =			"If-Range: %s\r\n";
const char XRL_HEADER_RANGE[] =			"Range: bytes=%s-\r\n";
const char XRL_HEADER_AUTHORIZATION[] =	"Authorization: %s %s=\"%d.%d\",%s=\"%s\",%s=\"%s\"\r\n";
const char XRL_HEADER_RETURN[] =			"\r\n";
const char XRL_HEADER_CONTENTLENGTH[] =    "Content-Length:";
const char XRL_HEADER_DATE[] =             "Date:";
const char XRL_HEADER_LASTMODIFIED[] =     "Last-Modified:";
const char XRL_HEADER_HTTP[] =             "HTTP";
const char XRL_HEADER_XERR[] =             "X-Err:";

// Assume 100GB limit, nice for alignment too.
#define MAX_FILESIZE_SIZE			12

#define	MAX_TIME_SIZE				40

const char * const g_rgszDays[] = 
{
	"Sun", "Mon", "Tue", "Wed", 
	"Thu", "Fri", "Sat" 
};

const char * const g_rgszMonths[] = 
{
	"", "Jan", "Feb", "Mar", "Apr", "May", "Jun", 
	"Jul", "Aug", "Sep", "Oct", "Nov", "Dec" 
};

HRESULT CXo::XRL_FileTimeAsString(LPSTR pBuffer, DWORD * pcbBuffer, PFILETIME pft)
{
    // We'll use RFC 1123 (actually a subset)
    // Sun, 06 Nov 1994 08:49:37 GMT
    //
    SYSTEMTIME  st;

    // check the buffer size
    if (MAX_TIME_SIZE > *pcbBuffer)
        return(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));


    // BUGBUG (michaelw) We should probably make sure the following succeeds but it sucks for callers
    // to have to check our return.  Consider using an Assert
    FileTimeToSystemTime(pft, &st);

    // assemble the final string
    *pcbBuffer = sprintf(pBuffer, "%s, %02d %s %4d %02d:%02d:%02d GMT", 
    			g_rgszDays[st.wDayOfWeek], st.wDay, g_rgszMonths[st.wMonth], 
    			st.wYear, st.wHour, st.wMinute, st.wSecond);
    pBuffer[*pcbBuffer] = '\0';

    return(S_OK);
}

BOOL CXo::XRL_FileTimeFromString(LPCSTR sz, PFILETIME pft)
{
    // Assumes RFC 1123
    // Sun, 06 Nov 1994 08:49:37 GMT
    // 01234567890123456789012345678
    //           1         2

    char    timebuf[30];
    WORD    i;
    SYSTEMTIME st;

    // A quick format check
    if (strlen(sz) != 29)
    return FALSE;

    // Make a copy so we can modify it
    strcpy(timebuf, sz);

    if (timebuf[3] != ',' || timebuf[4] != ' ' 
            || timebuf[11] != ' ' || timebuf[16] != ' ' 
            || timebuf[19] != ':' || timebuf[22] != ':' 
            || timebuf[25] != ' ' || timebuf[26] != 'G' 
            || timebuf[27] != 'M' || timebuf[28] != 'T')
        return FALSE;

    // Setup string terminators for atoi
    timebuf[7] = '\0';
    timebuf[16] = '\0';
    timebuf[19] = '\0';
    timebuf[22] = '\0';
    timebuf[25] = '\0';


    // Get the day of the week
    ZeroMemory(&st, sizeof(st));
    for ( i = 0 ; i < 7 ; i++)
    {
        if (memcmp(g_rgszDays[i], timebuf, 3) == 0)
        break;
    }

    if (i == 7)
        return FALSE;

    st.wDayOfWeek = i;

    // Get the day of the month
    st.wDay = (WORD)atol(timebuf + 5);

    if (st.wDay == 0)
        return FALSE;

    // Get the month
    for (i = 1 ; i < 13 ; i++)
    {
        if (memcmp(g_rgszMonths[i], timebuf + 8, 3) == 0)
            break;
    }

    if (i == 13)
        return FALSE;

    st.wMonth = i;

    // Get the year
    st.wYear = (WORD)atol(timebuf + 12);

    // Get the hours, minutes, seconds
    st.wHour = (WORD)atol(timebuf + 17);
    st.wMinute = (WORD)atol(timebuf + 20);
    st.wSecond = (WORD)atol(timebuf + 23);

    return (SystemTimeToFileTime(&st, pft) == 1);
}

//
// Helper function to insert authentication headers into an HTTP
// request packet.
//
#if 0
HRESULT XRL_InsertAuthHeaders(
			XRL					xrlRelative,
			DWORD				cbRelative,
			char				**ppBuffer, 
			PXAPPSERVICEINFO	pServiceInfo
			)
{
	BOOL    fRetVal;
	DWORD   dwEncodedTicketLen;
	BYTE    encryptedAuthenticator[XCRYPT_HEADER_SIZE+sizeof(XAUTHENTICATOR)];
	DWORD   cbEncryptedAuthenticator;
	BYTE    encodedAuthenticator[BASE64_ENCODE_BUFFER_SIZE(sizeof(encryptedAuthenticator))];
	BYTE    encodedTicket[BASE64_ENCODE_BUFFER_SIZE(X_MAX_TICKET_SIZE)];
	XAUTHENTICATOR authenticator;
	XCRYPT_STATE_BUFFER xcryptState;
	XC_ONLINE_INFO_STRUCT* pOnlineInfo = XonlineGetInfo();

	// base 64 encode the ticket
	fRetVal = Base64Encode((BYTE *)pServiceInfo->ticket, 
							pServiceInfo->dwTicketLen, encodedTicket);
	Assert(fRetVal);

	// This value was originally u.tDelta
	// Add the current Xbox time to get the corrected UTC time
	// of the authentication server.
	pServiceInfo->u.tTimestamp += time(NULL);

	// Use session key for MAC and encryption
	XcryptInitialize(pServiceInfo->serviceInfo.sessionKey, X_KEY_LEN, &xcryptState);

	// Fill in the authenticator
	authenticator.qwXboxID = pOnlineInfo->XboxID;
	XcryptComputeMAC(&xcryptState, xrlRelative, cbRelative, authenticator.pURLMAC);
	authenticator.tAuthTime = pServiceInfo->u.tTimestamp;

	// encrypt the authenticator
	XcryptEncrypt(&xcryptState, (BYTE *)&authenticator, sizeof(authenticator),
					encryptedAuthenticator, &cbEncryptedAuthenticator );
    Assert(cbEncryptedAuthenticator == sizeof(encryptedAuthenticator));

	// base64 encode the encrypted authenticator
	fRetVal = Base64Encode((BYTE *)&encryptedAuthenticator, cbEncryptedAuthenticator, 
					encodedAuthenticator);
	Assert(fRetVal);

	// Add authentication stuff to the HTTP header
	*ppBuffer += sprintf(*ppBuffer, XRL_HEADER_AUTHORIZATION, 
				X_AUTH_SCHEME, X_VERSION_TOKEN, 
				XONLINE_PROTOCOL_VERSION_MAJOR, XONLINE_PROTOCOL_VERSION_MINOR,
				X_TICKET_TOKEN, encodedTicket,
				X_AUTH_TOKEN, encodedAuthenticator);
	return(S_OK);				
}
#endif

//
// Helper function to build an HTTP GET request header, optionally
// with resume semantics using the If-Range header.
//
HRESULT CXo::XRL_BuildGetRequestWithResume(
			DWORD				dwServiceID,
			LPCSTR				szResourcePath,
			DWORD				dwIPAddress,
			char				*pBuffer, 
			DWORD				*pcbBuffer, 
			PBYTE				pbExtraHeaders,
			DWORD				cbExtraHeaders,
			FILETIME			*pModifiedSince, 
			LARGE_INTEGER		liResumeFrom
			)
{
    HRESULT hr = S_OK;
    DWORD	cbRelative;
    DWORD   cbBuffNeeded;
    DWORD   cbTime;
	DWORD   cbEncodedTicket;
    char    chTimeGMT[40];
    char	chResumeFrom[MAX_FILESIZE_SIZE];
    char	*pBufEnd;
    PBYTE	pbIP;
    
    Assert(NULL != pBuffer);
    Assert(NULL != pcbBuffer);
    Assert(NULL != szResourcePath);
    
    // start by doing the GMT time conversion if requested
    if ( pModifiedSince != NULL )
    {
        cbTime = sizeof(chTimeGMT);
        XRL_FileTimeAsString(chTimeGMT, &cbTime, pModifiedSince);
    }

    // Calculate the amount of buffer we will need to hold the request.
    // We might ask for a little more than we really need, but that's OK
    // Return with an error if the supplied buffer is too small
    cbRelative = strlen(szResourcePath);
    cbBuffNeeded = sizeof(XRL_HEADER_GET_AND_AGENT) + 5;
    cbBuffNeeded += cbRelative;

    // HTTP/1.1 requires the Host header
    cbBuffNeeded += sizeof(XRL_HEADER_HOST) + 3;

	// Account for any extra headers
	if (pbExtraHeaders)
		cbBuffNeeded += cbExtraHeaders;

#if 0    
    // Add length of authentication related stuff if needed
    if (pServiceInfo->u.dwRequiresAuthentication)
    {
        cbEncodedTicket = BASE64_ENCODE_BUFFER_SIZE(pServiceInfo->dwTicketLen);
        cbBuffNeeded += sizeof(XRL_HEADER_AUTHORIZATION) - 1;
        cbBuffNeeded += cbEncodedTicket;
        cbBuffNeeded += BASE64_ENCODE_BUFFER_SIZE(XCRYPT_HEADER_SIZE+sizeof(XAUTHENTICATOR));
        cbBuffNeeded += 10; // strlen(X_TICKET_TOKEN) + strlen(X_AUTH_TOKEN)
    }
#endif    
    
    // Use the If-Range headers to resume if a last modification time was
    // supplied
    if ( pModifiedSince != NULL )
    {
        cbBuffNeeded += sizeof(XRL_HEADER_IFRANGE) - 1;
        cbBuffNeeded += cbTime;
       	cbBuffNeeded += sizeof(XRL_HEADER_RANGE) - 1;
       	cbBuffNeeded += sprintf(chResumeFrom, "%I64u", liResumeFrom);
    }
    cbBuffNeeded += sizeof(XRL_HEADER_RETURN);

    // do any math to account for authentication headers here

    // check if there is enough buffer space
    if (*pcbBuffer < cbBuffNeeded)
    {
        // set the buffer needed into the response
        *pcbBuffer = cbBuffNeeded;
        return(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));
    }

    // build the send request
    pBufEnd = pBuffer;
    pBufEnd += sprintf(pBufEnd, XRL_HEADER_GET_AND_AGENT, szResourcePath, dwServiceID);

	// Build the required Host: header, as required by HTTP/1.1.
    pbIP = (PBYTE)&dwIPAddress;
    pBufEnd += sprintf(pBufEnd, XRL_HEADER_HOST, pbIP[0], pbIP[1], pbIP[2], pbIP[3]);

    // if the modified header was requested, then add it too
    if (pModifiedSince != NULL)
    {        
        pBufEnd += sprintf(pBufEnd, XRL_HEADER_IFRANGE, chTimeGMT);
        pBufEnd += sprintf(pBufEnd, XRL_HEADER_RANGE, chResumeFrom);
    }

#if 0
    // if authentication is required, then add it to header
    if (pServiceInfo->u.dwRequiresAuthentication)
    {
    	XRL_InsertAuthHeaders(xrlRelative, cbRelative, &pBufEnd, pServiceInfo);
    }
#endif    

	// Add in any extra headers here
	if (pbExtraHeaders)
	{
		MoveMemory(pBufEnd, pbExtraHeaders, cbExtraHeaders);
		pBufEnd += cbExtraHeaders;
	}

    // close the request
    pBufEnd += sprintf(pBufEnd, XRL_HEADER_RETURN);

    Assert((DWORD)(pBufEnd - pBuffer) <= cbBuffNeeded);
    
    // set the final actual size
    *pcbBuffer = pBufEnd - pBuffer;

    return(S_OK);
}

//
// Helper function to build an HTTP POST request header.
//
HRESULT CXo::XRL_BuildPostRequest(
			DWORD			dwServiceID,
			LPCSTR			szTargetPath,
			DWORD			dwIPAddress,
			char			*pBuffer, 
			DWORD			*pcbBuffer, 
			PBYTE			pbExtraHeaders,
			DWORD			cbExtraHeaders,
			ULARGE_INTEGER	uliFileSize			
			)
{
    HRESULT hr = S_OK;
    DWORD   cbRelative;
    DWORD   cbBuffNeeded;
	DWORD   cbEncodedTicket;
    char	*pBufEnd;
    
    Assert(NULL != pBuffer);
    Assert(NULL != pcbBuffer);
    Assert(NULL != szTargetPath);
    
    // Calculate the amount of buffer we will need to hold the request.
    // We might ask for a little more than we really need, but that's OK
    // Return with an error if the supplied buffer is too small
    cbRelative = strlen(szTargetPath);
    cbBuffNeeded = sizeof(XRL_HEADER_POST_AND_AGENT) + 5;
    cbBuffNeeded += cbRelative;

    // HTTP/1.1 requires the Host header
    //cbBuffNeeded += sizeof(XRL_HEADER_HOST) + 3;

	// Account for any extra headers
	if (pbExtraHeaders)
		cbBuffNeeded += cbExtraHeaders;

#if 0    
    // Add length of authentication related stuff if needed
    if (pServiceInfo->u.dwRequiresAuthentication)
    {
        cbEncodedTicket = BASE64_ENCODE_BUFFER_SIZE(pServiceInfo->dwTicketLen);
        cbBuffNeeded += sizeof(XRL_HEADER_AUTHORIZATION) - 1;
        cbBuffNeeded += cbEncodedTicket;
        cbBuffNeeded += BASE64_ENCODE_BUFFER_SIZE(XCRYPT_HEADER_SIZE+sizeof(XAUTHENTICATOR));
        cbBuffNeeded += 10; // strlen(X_TICKET_TOKEN) + strlen(X_AUTH_TOKEN)
    }
#endif    
    
    cbBuffNeeded += sizeof(XRL_HEADER_CONTENT_LENGTH) + MAX_FILESIZE_SIZE;
    cbBuffNeeded += sizeof(XRL_HEADER_RETURN);

    // do any math to account for authentication headers here

    // check if there is enough buffer space
    if (*pcbBuffer < cbBuffNeeded)
    {
        // set the buffer needed into the response
        *pcbBuffer = cbBuffNeeded;
        return(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));
    }

    // build the send request
    pBufEnd = pBuffer;
    pBufEnd += sprintf(pBufEnd, XRL_HEADER_POST_AND_AGENT, szTargetPath, dwServiceID);

	// Build the required Host: header, as required by HTTP/1.1.
    //pbIP = (PBYTE)&dwIPAddress;
    //pBufEnd += sprintf(pBufEnd, XRL_HEADER_HOST, pbIP[0], pbIP[1], pbIP[2], pbIP[3]);

#if 0
    // if authentication is required, then add it to header
    if (pServiceInfo->u.dwRequiresAuthentication)
    {
    	XRL_InsertAuthHeaders(xrlRelative, cbRelative, &pBufEnd, pServiceInfo);
    }
#endif    

	// Fill in the content length header
    pBufEnd += sprintf(pBufEnd, XRL_HEADER_CONTENT_LENGTH, 
    			uliFileSize.QuadPart);

	// Add in any extra headers here
	if (pbExtraHeaders)
	{
		MoveMemory(pBufEnd, pbExtraHeaders, cbExtraHeaders);
		pBufEnd += cbExtraHeaders;
	}

    // Close the request
    pBufEnd += sprintf(pBufEnd, XRL_HEADER_RETURN);

    Assert((DWORD)(pBufEnd - pBuffer) <= cbBuffNeeded);
    
    // set the final actual size
    *pcbBuffer = pBufEnd - pBuffer;

    return(S_OK);
}

HRESULT    CXo::XRL_LookupServiceIPAddress(
			PXONLINE_SERVICE_INFO	pService,
			SOCKADDR_IN 			*psockaddr
			)
{
    Assert(NULL != pService);
    Assert(NULL != psockaddr);

    // copy over the found address into the socket address structure
    ZeroMemory(psockaddr, sizeof(SOCKADDR_IN));

    // we must set the internet flag
    psockaddr->sin_family = AF_INET;

    // bring in the port number from the previous lookup
    psockaddr->sin_port = htons(pService->wServicePort);

    // bring over the IP address from the previous lookup
    psockaddr->sin_addr.S_un.S_addr = pService->serviceIP.S_un.S_addr;

    return(S_OK);
}

//
// Helper function to skip the host portion of an XRL string
// and return the beginning of the URI portion. This call 
// assumes that the first element in the XRL is a host address.
// The host address is treated as a string and is not further 
// processed to determine what kind of address it is.
//
// Note: cbXRL and *pcbURI do NOT include any NULL terminator,
// and pbXRL does NOT have to be NULL-terminated.
//
HRESULT CXo::XRL_SkipToURI(
			PBYTE		pbXRL,
			DWORD		cbXRL,
			PBYTE		*ppbURI,
			DWORD		*pcbURI
			)
{
	*ppbURI = NULL;
	*pcbURI = 0;

	while (cbXRL--)
	{
		if (*pbXRL == '/')
		{
			*ppbURI = pbXRL;
			*pcbURI = cbXRL + 1;
			return(S_OK);
		}
		pbXRL++;
	}
	return(HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
}

//
// Helper function to convert a host string into a 4-byte
// IP address. The following heuristics are used:
//
// 1) The string must have exactly four components separated
//    by periods ('.').
// 2) Each component must only consist of numerals (0-9), with
//    no spaces in between.
// 3) Each component must enumerate to a value between 0-255.
//
// Note: cbHost does NOT include any NULL terminators, and 
// pbHost does NOT have to be NULL-terminated.
//
HRESULT CXo::XRL_ConvertToIPAddressAndPort(
			PBYTE		pbHost,
			DWORD		cbHost,
			DWORD		*pdwIPAddress,
			WORD		*pwPort
			)
{
	DWORD	dwComponent = 0;
	DWORD	dwValue = 0;
	DWORD	dwIP = 0;
	DWORD	dwPort = 0;
	BOOL	fEmpty = TRUE;
	BOOL	fHasPort = FALSE;

	*pdwIPAddress = 0;
	*pwPort = 80;
	
	while (cbHost--)
	{
		// 1) Max 4 components (0-3)
		if (dwComponent > 3)
			goto Error;

		// 2) Must be numeric
		if ((*pbHost >= '0') && (*pbHost <= '9'))
		{
			dwValue *= 10;
			dwValue += (*pbHost - '0');

			// 3) Must not exceed 255
			if (dwValue > 255)
				goto Error;

			fEmpty = FALSE;
		}
		else if (*pbHost == '.')
		{
			// Put it into the IP Address using 32-bit rotate
			Assert(dwValue <= 255);
			dwIP |= dwValue;
			dwIP = _rotr(dwIP, 8);
			dwValue = 0;
			dwComponent++;
			fEmpty = TRUE;
		}
		else if (*pbHost == ':')
		{
			fHasPort = TRUE;
			break;
		}
		else
			goto Error;

		pbHost++;
	}

	// Finish the last component
	if ((dwComponent == 3) && !fEmpty)
	{
		// Put it into the IP Address using 32-bit rotate
		Assert(dwValue <= 255);
		dwIP |= dwValue;
		dwIP = _rotr(dwIP, 8);

		// Return the IP
		*pdwIPAddress = dwIP;

		// Now see if we have a port number as well
		if (fHasPort && cbHost && (*pbHost == ':'))
		{
			pbHost++;
			while (cbHost--)
			{
				if ((*pbHost < '0') || (*pbHost > '9'))
					goto Error;
				dwPort *= 10;
				dwPort += (*pbHost - '0');
				if (dwPort > 0xffff)
					goto Error;

				pbHost++;
			}
			
			// Return the port
			*pwPort = (WORD)(dwPort & 0xffff);
		}
		
		return(S_OK);
	}
	
Error:
	return(HRESULT_FROM_WIN32(ERROR_BAD_NETPATH));
}

//
// Helper function to look up the XRL service address, and create
// a socket connection
//
HRESULT CXo::XRL_AsyncConnect(PXRL_ASYNC pxrlasync)
{
    HRESULT     		hr = S_OK;
    SOCKET				socketTemp = INVALID_SOCKET;
    PXONLINETASK_SOCKIO	psockio = &(pxrlasync->sockio);
  
    int				serr;
    SOCKADDR_IN		sockaddr;
    LINGER			l_linger;

    // Get the XRL's target IP address
    hr = XRL_LookupServiceIPAddress(&pxrlasync->serviceInfo, &sockaddr);
    if (FAILED(hr))
        goto Error;

    // Open up the socket to the target address. This socket uses TCP over IP
    socketTemp = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
    if (socketTemp == INVALID_SOCKET)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Error;
    }

	// If the requested connection is insecure, then we will set the 
	// insecure status of the socket.
	if (pxrlasync->dwFlags & XRL_CONNECTION_INSECURE)
	{
		XnSetInsecure(socketTemp);
	}

	// We immiediately hand this socket over to the socket I/O context. This
	// way, when we free the parent XRL_ASYNC structure, we will also free 
	// this socket
    StreamConnectInitializeContext(socketTemp, 
    			pxrlasync->xontask.hEventWorkAvailable, psockio);

    // Initiate the connection asynchronously
    hr = StreamConnectBegin(&sockaddr, psockio);
    if (FAILED(hr))
    	goto Error;

Cleanup:
	return(hr);

Error:
	goto Cleanup;
}			

//
// This function parses one header starting from the specified
/// starting position in the receive buffer.
// 
// Arguments (pxrlasync->):
//
// pStart - pointer to beginning of header string to parse
// dwHTTPResponseCode - receives the HTTP response
// uliContentLenght - receives the content length
// ftLastModified - receives the tast modified time
// ftResponse - receives the server response timestamp
//
// Return Values:
//
// This function either returns TRUE if there are no more headers
// to parse, or FALSE to indicate more headers.
//
BOOL CXo::XRL_ParseOneHeader(LPSTR pStart, PXRL_ASYNC pxrlasync)
{
    DWORD		dwEnd = 0;
    char*		pEnd;
    BOOL		fRetVal;
    ULONGLONG	ull;

#if 0    
    DWORD   dwDecodedSauthLen;
    XCRYPT_STATE_BUFFER xcryptState;
    BYTE    decryptedSauth[sizeof(time_t)];
    DWORD   cbDecryptedSauth;
#endif    
    
    Assert(NULL != pStart);
    Assert(NULL != pxrlasync);

    // scan forward over any whitespace - this means NO HEADER FOLDING
    while ( (*pStart == ' ') || (*pStart == '\t') )
        pStart++;

    // test if this is the last header
    if ( pStart[0] == '\0' || (pStart[0] == '\r' && pStart[1] == '\n') )
        return TRUE;

    // test for the header string
    if ( _strnicmp(pStart, XRL_HEADER_CONTENTLENGTH, sizeof(XRL_HEADER_CONTENTLENGTH)-1) == 0)
    {
        // found the header. Move to the start of the data
        pStart += (sizeof(XRL_HEADER_CONTENTLENGTH)-1);

        // scan forward over any whitespace - this means NO HEADER FOLDING
        while ( (*pStart == ' ') || (*pStart == '\t') )
            pStart++;

        // get the data
        pxrlasync->uliContentLength.QuadPart = _atoi64(pStart);

        // we are done. return false because this is not the end header.
        return FALSE;
    }

    // test for the header string - remember the sizeof includes the null
    if ( _strnicmp(pStart, XRL_HEADER_LASTMODIFIED, sizeof(XRL_HEADER_LASTMODIFIED)-1) == 0 )
    {
        // found the header. Move to the start of the data
        pStart += (sizeof(XRL_HEADER_LASTMODIFIED)-1);

        // scan forward over any whitespace - this means NO HEADER FOLDING
        while ( (*pStart == ' ') || (*pStart == '\t') )
            pStart++;

        // get the string as a FILETIME value
        XRL_FileTimeFromString(pStart, &(pxrlasync->ftLastModified));

        // we are done. return false because this is not the end header.
        return FALSE;
    }

    // test for the header string
    if ( _strnicmp(pStart, XRL_HEADER_DATE, sizeof(XRL_HEADER_DATE)-1) == 0 )
    {
        // found the header. Move to the start of the data
        pStart += (sizeof(XRL_HEADER_DATE)-1);

        // scan forward over any whitespace - this means NO HEADER FOLDING
        while ( (*pStart == ' ') || (*pStart == '\t') )
            pStart++;

        // get the string as a FILETIME value
        XRL_FileTimeFromString(pStart, &(pxrlasync->ftResponse));

        // we are done. return false because this is not the end header.
        return FALSE;
    }

#if 0
    // check if this is the authentication response.
    if ( _strnicmp(pStart, XRL_HEADER_AUTHEN_INFO, sizeof(XRL_HEADER_AUTHEN_INFO)-1) == 0 )
    {
        // found the authentication response. Move to the start of the data
        pStart += (sizeof(XRL_HEADER_DATE)-1);

        // scan forward to find start of sauth
        pStart = strstr(pStart, XRL_HEADER_SAUTH_START);
        if (pStart == NULL)
        {
            return FALSE;
        }
        pStart += (sizeof(XRL_HEADER_SAUTH_START)-1);
        
        // scan forward to find end of sauth
        pEnd = strchr(pStart, '\"');
        if (pEnd == NULL)
        {
            return FALSE;
        }

        // base64decode the sauth
        fRetVal = Base64Decode( pStart, pEnd - pStart, pStart, &dwDecodedSauthLen );
        if (!fRetVal)
        {
            return FALSE;
        }

        // Check sauth length
        if ( dwDecodedSauthLen != XCRYPT_HEADER_SIZE + sizeof(decryptedSauth) )
        {
            return FALSE;
        }

        // decrypt with the session key
        XcryptInitialize( pServiceInfo->serviceInfo.sessionKey, X_KEY_LEN, &xcryptState );
        
        // decrypt sauth and check if sauth looks decent
        if ( !XcryptDecrypt( &xcryptState,
                pStart, dwDecodedSauthLen,
                decryptedSauth, &cbDecryptedSauth ) )
        {
            return FALSE;
        }
        Assert( cbDecryptedSauth == sizeof(decryptedSauth) );

        // Check if timestamp matches what we sent
        if ( *((time_t*)decryptedSauth) == pServiceInfo->u.tTimestamp )
        {
            // Response sauth is good, remember that.
            // We now have mutual authentication and will trust this server.
            pServiceInfo->u.dwServerNotTrusted = FALSE;
        }
        
        // we are done. return false because this is not the end header.
        return FALSE;
    }
#endif    

    // check if this is the X-Err code
    if ( _strnicmp(pStart, XRL_HEADER_XERR, sizeof(XRL_HEADER_XERR)-1) == 0 )
    {
        // This is the optional X-Err code. Move to the start of the data
        // the code starts after the first space character
        while ( (*pStart != ' ') && (*pStart !='\0') )
            pStart++;

        // scan forward over any whitespace - this means NO HEADER FOLDING
        while ( (*pStart == ' ') || (*pStart == '\t') )
            pStart++;

        // get the X-Err: code
        HexStringToUlonglong(pStart, strlen(pStart), &ull);
        pxrlasync->hrXErr = (DWORD)ull;

        // we are done. return false because this is not the end header.
        return FALSE;
    }

    // check if this is the main response code.
    // check this last. If the others are found, then code is short-circuited.
    if ( _strnicmp(pStart, XRL_HEADER_HTTP, sizeof(XRL_HEADER_HTTP)-1) == 0 )
    {
        // found the main response code. Move to the start of the data
        // the code starts after the first space character
        while ( (*pStart != ' ') && (*pStart !='\0') )
            pStart++;

        // scan forward over any whitespace - this means NO HEADER FOLDING
        while ( (*pStart == ' ') || (*pStart == '\t') )
            pStart++;

        // turn the second space into a null too
        dwEnd = 0;
        while ( (pStart[dwEnd] != ' ') && (pStart[dwEnd] != '\0') )
            dwEnd++;
        pStart[dwEnd] = '\0';

        // get the response code
        pxrlasync->dwExtendedStatus = atoi(pStart);

        // Set a default code if the HTTP code is any error
        if (XONLINEDOWNLOAD_EXSTATUS_ANYERROR(pxrlasync->dwExtendedStatus))
        	pxrlasync->hrXErr = HRESULT_FROM_WIN32(ERROR_SERVICE_SPECIFIC_ERROR);

        // we are done. return false because this is not the end header.
        return FALSE;
    }

    // this is not the last header
    return FALSE;
}

//
// This function processes the data in the current receive buffer
// and either parses its headers (if in header mode), or dumps
// the HTTP content to the buffer. During the transition from header
// mode to content mode, this function returns the HTTP response code
// 
// Arguments (pxrlasync->):
//
// pBuffer -  buffer to containg the data to process
// dwCurrent - The number of received bytes in the buffer
// uliContentLength - receives the expected CONTENT length.
// uliTotal - The cumulative length of CONTENT received (excl. headers)
// dwNewBytesRead - amount of new data read
//
// Return Values:
//
// This function either returns S_OK if the data was processed
// successfully. E_FAIL is returned if a hard error had occurred.
//
HRESULT CXo::XRL_ProcessHttp(PXRL_ASYNC pxrlasync, DWORD dwNewBytesRead, BOOL * pfDoneHeaders)
{
    HRESULT	hr = S_OK;

	*pfDoneHeaders = FALSE;
	
	// Process if there is actual data read
	if (IS_HEADER_MODE(pxrlasync))
	{
		PBYTE				pbData = pxrlasync->pBuffer;
		PBYTE				pbStart = pbData;
		DWORD				dwBytesLeft;
		
		// Iterate through the data
		dwBytesLeft = pxrlasync->dwCurrent + dwNewBytesRead;
		while ((dwBytesLeft > 1) && IS_HEADER_MODE(pxrlasync))
		{
			if ((pbData[0] == '\r') && (pbData[1] == '\n'))
			{
				// Found a line break here, terminate this string
				// by directly modifying the buffer.
				*pbData++ = '\0';
				*pbData++ = '\0';
				dwBytesLeft -= 2;

				// Pares this line, and see if we are done headers
				// Note: If the response is coming from an ISAPI extension,
				// IIS 5 might return a response that does not contain a trailing
				// empty line (i.e. CRLF). We need to handle this case.
				if (XRL_ParseOneHeader((LPSTR)pbStart, pxrlasync) || !dwBytesLeft)
				{
					// Done processing headers
					pxrlasync->dwTemp &= (~XRL_FLAG_HEADER_MODE);
					*pfDoneHeaders = TRUE;
#if 0
					// Make sure we trust this server
	                if (pxrlasync->serviceinfo.u.dwServerNotTrusted)
	                {
	                    hr = HRESULT_FROM_WIN32(ERROR_TRUST_FAILURE);
	                    goto Error;
	                }
#endif	                

					// Whatever remains becomes content
					CopyMemory(pxrlasync->pBuffer, pbData, dwBytesLeft);
					pxrlasync->dwCurrent = dwBytesLeft;

					break;
				}

				// Setup for next header line
				pbStart = pbData;
			}
			else
			{
				pbData++;
				dwBytesLeft--;
			}
			
		}	// while (dwBytesLeft > 1 && IS_HEADER_MODE(pxrlasync))

		if (IS_HEADER_MODE(pxrlasync))
		{
			// Any leftover data would become part of the next header
			pxrlasync->dwCurrent = (pbData - pbStart) + dwBytesLeft;
			MoveMemory(pxrlasync->pBuffer, pbStart, pxrlasync->dwCurrent);
		}
		
	}	// if (IS_HEADER_MODE(pxrlasync))

#if 0
Cleanup:
#endif

	// Return the result code in xontask->hr
	return(hr);

#if 0
Error:
	hrReturn = E_FAIL;
	goto Cleanup;
#endif	
}

//
// Generic function to create an event if hEventWorkAvailable is not
// supplied by the caller.
//
// This function also optionally returns the event handle just in case 
// some other component needs to share this handle. If an event is 
// already specified, an event is not created, and the original handle
// is returned as output.
//
HRESULT CXo::XRL_CreateWorkEventIfNecessary(PXRL_ASYNC pxrlasync, HANDLE * pHandle)
{
	if (!pxrlasync->xontask.hEventWorkAvailable)
	{
		pxrlasync->xontask.hEventWorkAvailable = 
					CreateEvent(NULL, FALSE, FALSE, NULL);
		if (!pxrlasync->xontask.hEventWorkAvailable)
		{
			return(HRESULT_FROM_WIN32(GetLastError()));
		}

		pxrlasync->dwFlags |= XRL_HEVENT_CREATED_BY_API;
	}

	if (pHandle)
		*pHandle = pxrlasync->xontask.hEventWorkAvailable;
		
	return(S_OK);
}

//
// Generic function for cleanup
//
void CXo::XRL_CleanupHandler(PXRL_ASYNC pxrlasync)
{
	PXRL_EXTENSION	pxrlext;

	// Close the socket
	if ((pxrlasync->sockio.socket != INVALID_SOCKET) &&
		(pxrlasync->sockio.socket != 0))
	{
		closesocket(pxrlasync->sockio.socket);
		pxrlasync->sockio.socket = INVALID_SOCKET;
	}

	// Close any open files
	if ((pxrlasync->fileio.hFile != INVALID_HANDLE_VALUE) &&
		(pxrlasync->fileio.hFile != NULL))
	{
		CloseHandle(pxrlasync->fileio.hFile);
		pxrlasync->fileio.hFile = INVALID_HANDLE_VALUE;
	}

	// Propagate cleanup to extensions ...
	pxrlext = &pxrlasync->xrlext;
	if (pxrlasync->fDownload)
	{
		// Cleanup download tasks
		if (pxrlext->dl.pfnCleanup)
        {
			(this->*(pxrlext->dl.pfnCleanup))(pxrlasync);
        }
	}
	else
	{
		// Cleanup upload tasks
		if (pxrlext->ul.pfnCleanup)
        {
			(this->*(pxrlext->ul.pfnCleanup))(pxrlasync);
        }
	}

	// Free the event handle if we allocated one
	if (pxrlasync->dwFlags & XRL_HEVENT_CREATED_BY_API)
	{
		CloseHandle(pxrlasync->xontask.hEventWorkAvailable);
		pxrlasync->xontask.hEventWorkAvailable = NULL;
		pxrlasync->dwFlags &= (~XRL_HEVENT_CREATED_BY_API);
	}
}

//
// Function to determine if the amount of disk space currently
// available is sufficient to finish the download. If the specified
// file already exists, this also accounts for the disk space
// currenlty used by that file.
//
// This function also performs some basic checks on the file name path
// to make sure it is at least well-formed.
//
// Arguments:
//
// szFilename - name of the target file
// uliFileSize - expected size of the file
//
// Return Values:
//
// This function returns S_OK if the amount of disk space available
// is greater than or equal to uliFileSize. If the required disk
// space is not available, then S_FALSE is returned. E_FAIL is
// returned on any hard error. Note that since multiple dowloads 
// may be executing, it is possible to run out of disk space later
// on, even this check returns S_OK.
//
HRESULT CXo::XRL_CheckDiskSpaceAccurate(char *szFilename, ULARGE_INTEGER uliFileSize)
{
	HRESULT			hr = S_OK;
	char			szFolder[MAX_PATH];
	char			*pCurrent;
	DWORD			dwLength;
	ULARGE_INTEGER	uliDiskFree, uliTemp;
    WIN32_FILE_ATTRIBUTE_DATA   fileAttributes;

	// Do some rudimentary check for the filename
	dwLength = strlen(szFilename);
	if (!dwLength || (szFilename[dwLength - 1] == '\\'))
		return(E_INVALIDARG);

	// Walk backwards to find a backslash
	pCurrent = szFilename + dwLength;
	while (pCurrent > szFilename)
		if (*(--pCurrent) == '\\')
			break;

	// See if we found a backslash			
	if (pCurrent == szFilename)
		return(E_INVALIDARG);
		
	// The path up to the backslash is the parent folder name
	dwLength = pCurrent - szFilename;
	strncpy(szFolder, szFilename, dwLength);
	szFolder[dwLength - 1] = '\0';

	// OK, now check disk space available
	if (!GetDiskFreeSpaceEx(
				szFolder,
				&uliDiskFree,
				&uliTemp,
				NULL))
	{
		// unable to test the disk space at all
		return(HRESULT_FROM_WIN32(GetLastError()));
	}

	// If this is not enough, see if the file already exists, and
	// account for that space if so.
	if (uliDiskFree.QuadPart < uliFileSize.QuadPart)
	{
		if (GetFileAttributesEx(
					szFilename,
					GetFileExInfoStandard,
					&fileAttributes))
		{
			// we got the info on the file. Add the existing size to the freespace
			// then we get the real freespace that is available.
			uliTemp.LowPart = fileAttributes.nFileSizeLow;
			uliTemp.HighPart = fileAttributes.nFileSizeHigh;
			uliDiskFree.QuadPart += uliTemp.QuadPart;
		}

		if (uliDiskFree.QuadPart < uliFileSize.QuadPart)
			return(HRESULT_FROM_WIN32(ERROR_DISK_FULL));
	}

	return(S_OK);
}

//
// Define the main do work function
//
HRESULT CXo::XRL_MainContinue(
			XONLINETASK_HANDLE		hTask, 
			const PFNXRL_HANDLER	rgpfnxrlHandlers[],
			DWORD					dwFinalState
			)
{
	HRESULT			hr = S_OK;
	PXRL_ASYNC		pxrlasync = (PXRL_ASYNC)hTask;
	DWORD			dwPreviousState;

	Assert(hTask != NULL);

	// Always signal the event. If we actually do any async work, we 
	// will reset the event. This makes sure we don't stall
	if (pxrlasync->xontask.hEventWorkAvailable)
		SetEvent(pxrlasync->xontask.hEventWorkAvailable);

	// Save the previous state
	dwPreviousState = pxrlasync->dwCurrentState;
	
	if (pxrlasync->dwCurrentState < dwFinalState)
	{
		// Call our handler to do more work
		hr = (this->*(rgpfnxrlHandlers[pxrlasync->dwCurrentState]))(pxrlasync);
	}
	else if (pxrlasync->dwCurrentState != dwFinalState)
	{
		AssertSz(FALSE, "XRL_MainContinue: Bad state");
		pxrlasync->dwCurrentState = dwFinalState;
		pxrlasync->hrFinal = E_NOTIMPL;
	}

	// When the next state is xrldtmDone, we set the flag so we don't
	// continue.
	if (pxrlasync->dwCurrentState == dwFinalState)
	{
		// Indicate that we are done and return the final code
		if (SUCCEEDED(pxrlasync->hrFinal))
		{
			// We will pass thru the X-Err information if the server
			// explicitly returned a value other than S_OK.
			if (pxrlasync->hrXErr != S_OK)
				pxrlasync->hrFinal = pxrlasync->hrXErr;
			else
				pxrlasync->hrFinal = XONLINETASK_S_SUCCESS;
		}

		hr = pxrlasync->hrFinal;
		goto Exit;
	}

	// We see if the state has changed, if yes, then refresh our timestamp
	if (pxrlasync->dwCurrentState != dwPreviousState)
	{
		pxrlasync->dwLastStateChange = GetTickCount();
	}

	// At the end of this timeslice, see if a timeout has occurred
	if ((pxrlasync->dwTimeoutMs) &&
		((GetTickCount() - pxrlasync->dwLastStateChange) > pxrlasync->dwTimeoutMs))
	{
		// Indicate that we are done and return the final code
		pxrlasync->dwCurrentState = dwFinalState;
		hr = pxrlasync->hrFinal = HRESULT_FROM_WIN32(ERROR_TIMEOUT);
	}

Exit:	
	return(hr);
}

//
// Define the main close function
//
VOID CXo::XRL_MainClose(XONLINETASK_HANDLE hTask)
{
	PXRL_ASYNC		pxrlasync = (PXRL_ASYNC)hTask;

	Assert(hTask != NULL);

	// Release all resources and leave
	XRL_CleanupHandler(pxrlasync);
	SysFree(pxrlasync);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\accounts\main.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 ****************************************************************************/

#include "xonp.h"
#include "testutil.h"
#include "testui.h"
#include "time.h"


void CreateTempUsers()
{
    HRESULT              hr     = S_OK;
    XONLINETASK_HANDLE   hTask;
    DWORD                cUsers = 0;
    
    
    while (true)
    {
    
        __asm int 3;
    
        DebugPrint("Creating user %d", ++cUsers);
        
        XONLINE_USER user;
        WCHAR buf[16] = {0};
    
        ZeroMemory(&user, sizeof(XONLINE_USER));
        
        srand(time(NULL));
        wsprintfA(user.name, "test%x", rand());
        strcpy(user.kingdom, "Earth");
    
    
        hr = _XOnlineAccountTempCreate(&user, NULL, &hTask);
        if (FAILED(hr))
        {
             __asm int 3;
        }
        
        do
        {
            hr = XOnlineTaskContinue(hTask);
               
            if (FAILED(hr))
    
            {
    	            __asm int 3;
            }
        } while (hr == XONLINETASK_S_RUNNING);
    
    
        if (SUCCEEDED(hr))
        {
            _XOnlineAccountTempCreateGetResults(hTask, &user);
        }
        
        XOnlineTaskClose(hTask);
    
    }
    
}


void GetTags()
{
    HRESULT              hr                  = S_OK;
    XONLINETASK_HANDLE   hTask;
    LPWSTR               rgszTags            = NULL;
    WORD                 wTagCount           = 0;
    
    while (true)
    {
        __asm int 3;

		//hr = _XOnlineGetTags(103, 5, L"slamb", NULL, &hTask);
		hr = _XOnlineGetTags(103, 20, NULL, NULL, &hTask);

        if (FAILED(hr))
        {
             __asm int 3;
        }
        
        do
        {
            hr = XOnlineTaskContinue(hTask);
        
            if (FAILED(hr))
            {
    	            __asm int 3;
            }
        } 
        while (hr == XONLINETASK_S_RUNNING);
		
    
        if (SUCCEEDED(hr))
        {
            hr = _XOnlineGetTagsResults(hTask, &rgszTags, &wTagCount);
            if (FAILED(hr))
            {
                __asm int 3;
            }

            for (int i = 0; i < wTagCount; i++)
            {
                DebugPrint("name %d: %ls\n", i, rgszTags + i*XONLINE_KINGDOM_SIZE);
            }
        }

        
        XOnlineTaskClose(hTask);


    }
}



void ReserveName()
{
    HRESULT              hr                 = S_OK;
    XONLINETASK_HANDLE   hTask;
    PUSER_XNAME          pNames              = NULL;
    DWORD                dwNameCount          = 0;
    
    while (true)
    {
        hr = _XOnlineReserveName(L"slamb", L"Dev", 5, 103, NULL, &hTask);

        if (FAILED(hr))
        {
             __asm int 3;
        }
        
        do
        {
            hr = XOnlineTaskContinue(hTask);
        
            if (FAILED(hr))
            {
    	            __asm int 3;
            }
        } 
        while (hr == XONLINETASK_S_RUNNING);
    
    
        if (SUCCEEDED(hr))
        {
            hr = _XOnlineGetReserveNameResults(hTask, &pNames, &dwNameCount);
            if (FAILED(hr))
            {
                __asm int 3;
            }

            for (DWORD i = 0; i < dwNameCount; i++)
            {
                DebugPrint("tag %d: %ls.%ls\n", i, pNames[i].wszNickname, pNames[i].wszRealm);
            }
        }

        
        XOnlineTaskClose(hTask);


    }
}

void CreateUsers()
{
    HRESULT              hr                 = S_OK;
    XONLINETASK_HANDLE   hTask;
    USER_ACCOUNT_INFO    acctInfo;
    XONLINE_USER         user;

    
    while (true)
    {
        ZeroMemory(&acctInfo, sizeof(USER_ACCOUNT_INFO));

        __asm int 3;
    
        
        srand(time(NULL));
        wsprintfW(acctInfo.wszNickname, L"User%x", rand());
        wcscpy(acctInfo.wszKingdom, L"Dev");

        wcscpy(acctInfo.wszFirstName, L"Joe");
        wcscpy(acctInfo.wszLastName, L"Shmo");
        wcscpy(acctInfo.wszStreet1, L"1 Microsoft Way");
        wcscpy(acctInfo.wszCity, L"Redmond");
        wcscpy(acctInfo.wszState, L"WA");
        acctInfo.bCountryId = 103;
        wcscpy(acctInfo.wszPostalCode, L"98072");
        wcscpy(acctInfo.wszPhonePrefix, L"425");
        wcscpy(acctInfo.wszPhoneNumber, L"703-8716");
        
        wcscpy(acctInfo.wszCardHolder, L"Joe Shmo");
        wcscpy(acctInfo.wszCardNumber, L"4111111111111111");

        SYSTEMTIME st;
        ZeroMemory(&st, sizeof(SYSTEMTIME));
        st.wYear = 2003;
        st.wMonth = 2;
        
        SystemTimeToFileTime(&st, &(acctInfo.ftCardExpiration));
        
        hr = _XOnlineCreateAccount(&acctInfo, NULL, &hTask);
        if (FAILED(hr))
        {
             __asm int 3;
        }
        
        do
        {
            hr = XOnlineTaskContinue(hTask);
        
            if (FAILED(hr))
            {
    	            __asm int 3;
            }
        } 
        while (hr == XONLINETASK_S_RUNNING);
    
    
        if (SUCCEEDED(hr))
        {
            
            ZeroMemory(&user, sizeof(XONLINE_USER));
            hr = _XOnlineGetCreateAccountResults(hTask, &user);
            if (FAILED(hr))
            {
                __asm int 3;
            }

            DebugPrint("Created user %s.%s (0x%016x)\n", user.name, user.kingdom, user.xuid.qwUserID);
        }

        
        XOnlineTaskClose(hTask);


    }
}



//
// Define the services needed
//
#define NUM_SERVICES	1
DWORD			g_rgServices[NUM_SERVICES] =
{
	XONLINE_USER_ACCOUNT_SERVICE
};



void __cdecl main()
{
    HRESULT              hr                = S_OK;
    DWORD                dwError           = 0;
    HANDLE               hEvent            = NULL;
    WSADATA              WsaData;
    DWORD                dwWorkFlags;
    DWORD i;
    XNADDR xna;
    XONLINETASK_HANDLE   hLogon;
    DWORD n;
    XONLINE_USER Users[8];

	XONLINE_STARTUP_PARAMS	xosp = { 0 };

	XNetStartupParams 	xnsp = { sizeof(XNetStartupParams), 
								XNET_STARTUP_BYPASS_SECURITY };

    DebugPrint("Loading XBox network stack...\n");
    dwError = XNetStartup(&xnsp);
    if (dwError != NO_ERROR)
    {
	    DebugPrint("Failed XNetStartup with %d\n", dwError);
        return;
    }

    DebugPrint("Calling XOnlineStartup...\n");
    hr = XOnlineStartup(&xosp);
    if (FAILED(hr))
    {
        DebugPrint("Error %08x returned by XOnlineStartup\n", hr);
        return;
    }

    	// Initialize services
	hr = XOnlineLogonWrapper(g_rgServices, NUM_SERVICES, &hLogon);
	if (FAILED(hr))
	{
        DebugPrint("Cannot Logon (%08x), check c:\\xonline.ini\n", hr);
        return;
	}

    // 
    // tests
    //

    //CreateTempUsers();
    //CreateUsers();
    //GetTags();
    ReserveName();


    

    // 
    // cleanup
    //
   
    XOnlineTaskClose(hLogon);
    
    WSACleanup();
    XNetCleanup();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\snap\krb5.h ===
#ifndef _KRB5_Module_H_
#define _KRB5_Module_H_

#include "msber.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct KERB_PA_PAC_REQUEST_EX_pac_sections_s * PKERB_PA_PAC_REQUEST_EX_pac_sections;

typedef struct KERB_KDC_REQUEST_BODY_encryption_type_s * PKERB_KDC_REQUEST_BODY_encryption_type;

typedef struct KERB_PRINCIPAL_NAME_name_string_s * PKERB_PRINCIPAL_NAME_name_string;

typedef struct PKERB_HOST_ADDRESSES_s * PPKERB_HOST_ADDRESSES;

typedef struct PKERB_AUTHORIZATION_DATA_s * PPKERB_AUTHORIZATION_DATA;

typedef struct PKERB_LAST_REQUEST_s * PPKERB_LAST_REQUEST;

typedef struct PKERB_TICKET_EXTENSIONS_s * PPKERB_TICKET_EXTENSIONS;

typedef struct PKERB_PREAUTH_DATA_LIST_s * PPKERB_PREAUTH_DATA_LIST;

typedef struct PKERB_ETYPE_INFO_s * PPKERB_ETYPE_INFO;

typedef struct KERB_KDC_ISSUED_AUTH_DATA_elements_s * PKERB_KDC_ISSUED_AUTH_DATA_elements;

typedef struct KERB_PA_PK_AS_REQ2_trusted_certifiers_s * PKERB_PA_PK_AS_REQ2_trusted_certifiers;

typedef struct KERB_PA_PK_AS_REQ2_user_certs_s * PKERB_PA_PK_AS_REQ2_user_certs;

typedef struct KERB_PA_PK_AS_REP2_kdc_cert_s * PKERB_PA_PK_AS_REP2_kdc_cert;

typedef struct KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data_s * PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data;

typedef struct KERB_KDC_REPLY_preauth_data_s * PKERB_KDC_REPLY_preauth_data;

typedef struct KERB_KDC_REQUEST_preauth_data_s * PKERB_KDC_REQUEST_preauth_data;

typedef struct KERB_PA_COMPOUND_IDENTITY_s * PKERB_PA_COMPOUND_IDENTITY;

typedef struct KERB_PA_PK_AS_REQ_trusted_certifiers_s * PKERB_PA_PK_AS_REQ_trusted_certifiers;

typedef struct KERB_ENCRYPTED_CRED_ticket_info_s * PKERB_ENCRYPTED_CRED_ticket_info;

typedef struct KERB_CRED_tickets_s * PKERB_CRED_tickets;

typedef struct KERB_KDC_REQUEST_BODY_additional_tickets_s * PKERB_KDC_REQUEST_BODY_additional_tickets;

typedef ASN1ztcharstring_t KERB_PRINCIPAL_NAME_name_string_Seq;

typedef ASN1int32_t KERB_KDC_REQUEST_BODY_encryption_type_Seq;

typedef ASN1int32_t KERB_PA_PAC_REQUEST_EX_pac_sections_Seq;

typedef ASN1ztcharstring_t KERB_REALM;

typedef PPKERB_AUTHORIZATION_DATA PKERB_AUTHORIZATION_DATA_LIST;
#define PKERB_AUTHORIZATION_DATA_LIST_PDU 0
#define SIZE_KRB5_Module_PDU_0 sizeof(PKERB_AUTHORIZATION_DATA_LIST)

typedef ASN1bitstring_t KERB_KDC_OPTIONS;

typedef ASN1generalizedtime_t KERB_TIME;

typedef ASN1intx_t KERB_SEQUENCE_NUMBER_LARGE;

typedef ASN1uint32_t KERB_SEQUENCE_NUMBER;

typedef ASN1bitstring_t KERB_TICKET_FLAGS;

typedef ASN1bitstring_t KERB_AP_OPTIONS;

typedef ASN1open_t NOCOPYANY;

typedef ASN1int32_t KERB_CERTIFICATE_SERIAL_NUMBER;

typedef PPKERB_AUTHORIZATION_DATA PKERB_IF_RELEVANT_AUTH_DATA;
#define PKERB_IF_RELEVANT_AUTH_DATA_PDU 1
#define SIZE_KRB5_Module_PDU_1 sizeof(PKERB_IF_RELEVANT_AUTH_DATA)

typedef struct KERB_PA_PAC_REQUEST_EX_pac_sections_s {
    PKERB_PA_PAC_REQUEST_EX_pac_sections next;
    KERB_PA_PAC_REQUEST_EX_pac_sections_Seq value;
} KERB_PA_PAC_REQUEST_EX_pac_sections_Element, *KERB_PA_PAC_REQUEST_EX_pac_sections;

typedef struct KERB_KDC_REQUEST_BODY_encryption_type_s {
    PKERB_KDC_REQUEST_BODY_encryption_type next;
    KERB_KDC_REQUEST_BODY_encryption_type_Seq value;
} KERB_KDC_REQUEST_BODY_encryption_type_Element, *KERB_KDC_REQUEST_BODY_encryption_type;

typedef struct PKERB_TICKET_EXTENSIONS_Seq {
    ASN1int32_t te_type;
    ASN1octetstring_t te_data;
} PKERB_TICKET_EXTENSIONS_Seq;

typedef struct KERB_PRINCIPAL_NAME_name_string_s {
    PKERB_PRINCIPAL_NAME_name_string next;
    KERB_PRINCIPAL_NAME_name_string_Seq value;
} KERB_PRINCIPAL_NAME_name_string_Element, *KERB_PRINCIPAL_NAME_name_string;

typedef struct PKERB_LAST_REQUEST_Seq {
    ASN1int32_t last_request_type;
    KERB_TIME last_request_value;
} PKERB_LAST_REQUEST_Seq;

typedef struct PKERB_AUTHORIZATION_DATA_Seq {
    ASN1int32_t auth_data_type;
    ASN1octetstring_t auth_data;
} PKERB_AUTHORIZATION_DATA_Seq;

typedef struct PKERB_HOST_ADDRESSES_Seq {
    ASN1int32_t address_type;
    ASN1octetstring_t address;
} PKERB_HOST_ADDRESSES_Seq;

typedef struct KERB_HOST_ADDRESS {
    ASN1int32_t addr_type;
    ASN1octetstring_t address;
} KERB_HOST_ADDRESS;

typedef struct PKERB_HOST_ADDRESSES_s {
    PPKERB_HOST_ADDRESSES next;
    PKERB_HOST_ADDRESSES_Seq value;
} PKERB_HOST_ADDRESSES_Element, *PKERB_HOST_ADDRESSES;

typedef struct PKERB_AUTHORIZATION_DATA_s {
    PPKERB_AUTHORIZATION_DATA next;
    PKERB_AUTHORIZATION_DATA_Seq value;
} PKERB_AUTHORIZATION_DATA_Element, *PKERB_AUTHORIZATION_DATA;

typedef struct PKERB_LAST_REQUEST_s {
    PPKERB_LAST_REQUEST next;
    PKERB_LAST_REQUEST_Seq value;
} PKERB_LAST_REQUEST_Element, *PKERB_LAST_REQUEST;

typedef struct KERB_PRINCIPAL_NAME {
    ASN1int32_t name_type;
    PKERB_PRINCIPAL_NAME_name_string name_string;
} KERB_PRINCIPAL_NAME;

typedef struct PKERB_TICKET_EXTENSIONS_s {
    PPKERB_TICKET_EXTENSIONS next;
    PKERB_TICKET_EXTENSIONS_Seq value;
} PKERB_TICKET_EXTENSIONS_Element, *PKERB_TICKET_EXTENSIONS;

typedef struct KERB_TRANSITED_ENCODING {
    ASN1int32_t transited_type;
    ASN1octetstring_t contents;
} KERB_TRANSITED_ENCODING;

typedef struct KERB_PA_DATA {
    ASN1int32_t preauth_data_type;
    ASN1octetstring_t preauth_data;
} KERB_PA_DATA;

typedef struct PKERB_PREAUTH_DATA_LIST_s {
    PPKERB_PREAUTH_DATA_LIST next;
    KERB_PA_DATA value;
} PKERB_PREAUTH_DATA_LIST_Element, *PKERB_PREAUTH_DATA_LIST;
#define PKERB_PREAUTH_DATA_LIST_PDU 2
#define SIZE_KRB5_Module_PDU_2 sizeof(PKERB_PREAUTH_DATA_LIST_Element)

typedef struct KERB_SAFE_BODY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1octetstring_t user_data;
#   define KERB_SAFE_BODY_timestamp_present 0x80
    KERB_TIME timestamp;
#   define KERB_SAFE_BODY_usec_present 0x40
    ASN1int32_t usec;
#   define KERB_SAFE_BODY_sequence_number_present 0x20
    KERB_SEQUENCE_NUMBER sequence_number;
    KERB_HOST_ADDRESS sender_address;
#   define KERB_SAFE_BODY_recipient_address_present 0x10
    KERB_HOST_ADDRESS recipient_address;
} KERB_SAFE_BODY;

typedef struct KERB_ENCRYPTED_PRIV {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1octetstring_t user_data;
#   define KERB_ENCRYPTED_PRIV_timestamp_present 0x80
    KERB_TIME timestamp;
#   define KERB_ENCRYPTED_PRIV_usec_present 0x40
    ASN1int32_t usec;
#   define KERB_ENCRYPTED_PRIV_sequence_number_present 0x20
    KERB_SEQUENCE_NUMBER sequence_number;
    KERB_HOST_ADDRESS sender_address;
#   define KERB_ENCRYPTED_PRIV_recipient_address_present 0x10
    KERB_HOST_ADDRESS recipient_address;
} KERB_ENCRYPTED_PRIV;
#define KERB_ENCRYPTED_PRIV_PDU 3
#define SIZE_KRB5_Module_PDU_3 sizeof(KERB_ENCRYPTED_PRIV)

typedef struct KERB_ENCRYPTED_CRED {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PKERB_ENCRYPTED_CRED_ticket_info ticket_info;
#   define nonce_present 0x80
    ASN1int32_t nonce;
#   define KERB_ENCRYPTED_CRED_timestamp_present 0x40
    KERB_TIME timestamp;
#   define KERB_ENCRYPTED_CRED_usec_present 0x20
    ASN1int32_t usec;
#   define sender_address_present 0x10
    KERB_HOST_ADDRESS sender_address;
#   define KERB_ENCRYPTED_CRED_recipient_address_present 0x8
    KERB_HOST_ADDRESS recipient_address;
} KERB_ENCRYPTED_CRED;
#define KERB_ENCRYPTED_CRED_PDU 4
#define SIZE_KRB5_Module_PDU_4 sizeof(KERB_ENCRYPTED_CRED)

typedef struct KERB_ERROR {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    ASN1int32_t message_type;
#   define client_time_present 0x80
    KERB_TIME client_time;
#   define client_usec_present 0x40
    ASN1int32_t client_usec;
    KERB_TIME server_time;
    ASN1int32_t server_usec;
    ASN1int32_t error_code;
#   define client_realm_present 0x20
    KERB_REALM client_realm;
#   define KERB_ERROR_client_name_present 0x10
    KERB_PRINCIPAL_NAME client_name;
    KERB_REALM realm;
    KERB_PRINCIPAL_NAME server_name;
#   define error_text_present 0x8
    ASN1charstring_t error_text;
#   define error_data_present 0x4
    ASN1octetstring_t error_data;
} KERB_ERROR;
#define KERB_ERROR_PDU 5
#define SIZE_KRB5_Module_PDU_5 sizeof(KERB_ERROR)

typedef struct KERB_ENCRYPTED_DATA {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t encryption_type;
#   define version_present 0x80
    ASN1int32_t version;
    ASN1octetstring_t cipher_text;
} KERB_ENCRYPTED_DATA;
#define KERB_ENCRYPTED_DATA_PDU 6
#define SIZE_KRB5_Module_PDU_6 sizeof(KERB_ENCRYPTED_DATA)

typedef struct KERB_ENCRYPTION_KEY {
    ASN1int32_t keytype;
    ASN1octetstring_t keyvalue;
} KERB_ENCRYPTION_KEY;
#define KERB_ENCRYPTION_KEY_PDU 7
#define SIZE_KRB5_Module_PDU_7 sizeof(KERB_ENCRYPTION_KEY)

typedef struct KERB_CHECKSUM {
    ASN1int32_t checksum_type;
    ASN1octetstring_t checksum;
} KERB_CHECKSUM;
#define KERB_CHECKSUM_PDU 8
#define SIZE_KRB5_Module_PDU_8 sizeof(KERB_CHECKSUM)

typedef struct KERB_ENCRYPTED_TIMESTAMP {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_TIME timestamp;
#   define KERB_ENCRYPTED_TIMESTAMP_usec_present 0x80
    ASN1int32_t usec;
} KERB_ENCRYPTED_TIMESTAMP;
#define KERB_ENCRYPTED_TIMESTAMP_PDU 9
#define SIZE_KRB5_Module_PDU_9 sizeof(KERB_ENCRYPTED_TIMESTAMP)

typedef struct KERB_SALTED_ENCRYPTED_TIMESTAMP {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_TIME timestamp;
#   define KERB_SALTED_ENCRYPTED_TIMESTAMP_usec_present 0x80
    ASN1int32_t usec;
    ASN1octetstring_t salt;
} KERB_SALTED_ENCRYPTED_TIMESTAMP;
#define KERB_SALTED_ENCRYPTED_TIMESTAMP_PDU 10
#define SIZE_KRB5_Module_PDU_10 sizeof(KERB_SALTED_ENCRYPTED_TIMESTAMP)

typedef struct KERB_ETYPE_INFO_ENTRY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t encryption_type;
#   define salt_present 0x80
    ASN1octetstring_t salt;
} KERB_ETYPE_INFO_ENTRY;

typedef struct PKERB_ETYPE_INFO_s {
    PPKERB_ETYPE_INFO next;
    KERB_ETYPE_INFO_ENTRY value;
} PKERB_ETYPE_INFO_Element, *PKERB_ETYPE_INFO;
#define PKERB_ETYPE_INFO_PDU 11
#define SIZE_KRB5_Module_PDU_11 sizeof(PKERB_ETYPE_INFO_Element)

typedef struct KERB_TGT_REQUEST {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    ASN1int32_t message_type;
#   define KERB_TGT_REQUEST_server_name_present 0x80
    KERB_PRINCIPAL_NAME server_name;
#   define server_realm_present 0x40
    KERB_REALM server_realm;
} KERB_TGT_REQUEST;
#define KERB_TGT_REQUEST_PDU 12
#define SIZE_KRB5_Module_PDU_12 sizeof(KERB_TGT_REQUEST)

typedef struct KERB_PKCS_SIGNATURE {
    ASN1int32_t encryption_type;
    ASN1octetstring_t signature;
} KERB_PKCS_SIGNATURE;
#define KERB_PKCS_SIGNATURE_PDU 13
#define SIZE_KRB5_Module_PDU_13 sizeof(KERB_PKCS_SIGNATURE)

typedef struct KERB_ALGORITHM_IDENTIFIER {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1objectidentifier_t algorithm;
#   define parameters_present 0x80
    NOCOPYANY parameters;
} KERB_ALGORITHM_IDENTIFIER;

typedef struct KERB_SIGNATURE {
    KERB_ALGORITHM_IDENTIFIER signature_algorithm;
    ASN1bitstring_t pkcs_signature;
} KERB_SIGNATURE;

typedef struct KERB_PA_PK_AS_REP {
    ASN1choice_t choice;
    union {
#	define dh_signed_data_chosen 1
	ASN1octetstring_t dh_signed_data;
#	define key_package_chosen 2
	ASN1octetstring_t key_package;
    } u;
} KERB_PA_PK_AS_REP;
#define KERB_PA_PK_AS_REP_PDU 14
#define SIZE_KRB5_Module_PDU_14 sizeof(KERB_PA_PK_AS_REP)

typedef struct KERB_ENVELOPED_KEY_PACKAGE {
    ASN1choice_t choice;
    union {
#	define encrypted_data_chosen 1
	KERB_ENCRYPTED_DATA encrypted_data;
#	define pkinit_enveloped_data_chosen 2
	ASN1octetstring_t pkinit_enveloped_data;
    } u;
} KERB_ENVELOPED_KEY_PACKAGE;

typedef struct KERB_REPLY_KEY_PACKAGE2 {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_ENCRYPTION_KEY reply_key;
    ASN1int32_t nonce;
#   define subject_public_key_present 0x80
    ASN1bitstring_t subject_public_key;
} KERB_REPLY_KEY_PACKAGE2;
#define KERB_REPLY_KEY_PACKAGE2_PDU 15
#define SIZE_KRB5_Module_PDU_15 sizeof(KERB_REPLY_KEY_PACKAGE2)

typedef struct KERB_REPLY_KEY_PACKAGE {
    KERB_ENCRYPTION_KEY reply_key;
    ASN1int32_t nonce;
} KERB_REPLY_KEY_PACKAGE;
#define KERB_REPLY_KEY_PACKAGE_PDU 16
#define SIZE_KRB5_Module_PDU_16 sizeof(KERB_REPLY_KEY_PACKAGE)

typedef struct KERB_KDC_DH_KEY_INFO {
    ASN1int32_t nonce;
    ASN1bitstring_t subject_public_key;
} KERB_KDC_DH_KEY_INFO;
#define KERB_KDC_DH_KEY_INFO_PDU 17
#define SIZE_KRB5_Module_PDU_17 sizeof(KERB_KDC_DH_KEY_INFO)

typedef struct KERB_PA_PK_AS_REQ {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1octetstring_t signed_auth_pack;
#   define KERB_PA_PK_AS_REQ_trusted_certifiers_present 0x80
    PKERB_PA_PK_AS_REQ_trusted_certifiers trusted_certifiers;
#   define KERB_PA_PK_AS_REQ_kdc_cert_present 0x40
    ASN1octetstring_t kdc_cert;
#   define encryption_cert_present 0x20
    ASN1octetstring_t encryption_cert;
} KERB_PA_PK_AS_REQ;
#define KERB_PA_PK_AS_REQ_PDU 18
#define SIZE_KRB5_Module_PDU_18 sizeof(KERB_PA_PK_AS_REQ)

typedef struct KERB_KERBEROS_NAME {
    KERB_REALM realm;
    KERB_PRINCIPAL_NAME principal_name;
} KERB_KERBEROS_NAME;

typedef struct KERB_PK_AUTHENTICATOR {
    KERB_PRINCIPAL_NAME kdc_name;
    KERB_REALM kdc_realm;
    ASN1int32_t cusec;
    KERB_TIME client_time;
    ASN1int32_t nonce;
} KERB_PK_AUTHENTICATOR;

typedef struct KERB_SUBJECT_PUBLIC_KEY_INFO {
    KERB_ALGORITHM_IDENTIFIER algorithm;
    ASN1bitstring_t subjectPublicKey;
} KERB_SUBJECT_PUBLIC_KEY_INFO;

typedef struct KERB_DH_PARAMTER {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t prime;
    ASN1int32_t base;
#   define private_value_length_present 0x80
    ASN1int32_t private_value_length;
} KERB_DH_PARAMTER;
#define KERB_DH_PARAMTER_PDU 19
#define SIZE_KRB5_Module_PDU_19 sizeof(KERB_DH_PARAMTER)

typedef struct KERB_CERTIFICATE {
    ASN1int32_t cert_type;
    ASN1octetstring_t cert_data;
} KERB_CERTIFICATE;

typedef struct KERB_TYPED_DATA {
    ASN1int32_t data_type;
    ASN1octetstring_t data_value;
} KERB_TYPED_DATA;
#define KERB_TYPED_DATA_PDU 20
#define SIZE_KRB5_Module_PDU_20 sizeof(KERB_TYPED_DATA)

typedef struct KERB_KDC_ISSUED_AUTH_DATA {
    KERB_SIGNATURE checksum;
    PKERB_KDC_ISSUED_AUTH_DATA_elements elements;
} KERB_KDC_ISSUED_AUTH_DATA;
#define KERB_KDC_ISSUED_AUTH_DATA_PDU 21
#define SIZE_KRB5_Module_PDU_21 sizeof(KERB_KDC_ISSUED_AUTH_DATA)

typedef struct KERB_PA_SERV_REFERRAL {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define referred_server_name_present 0x80
    KERB_PRINCIPAL_NAME referred_server_name;
    KERB_REALM referred_server_realm;
} KERB_PA_SERV_REFERRAL;
#define KERB_PA_SERV_REFERRAL_PDU 22
#define SIZE_KRB5_Module_PDU_22 sizeof(KERB_PA_SERV_REFERRAL)

typedef struct KERB_PA_PAC_REQUEST {
    ASN1bool_t include_pac;
} KERB_PA_PAC_REQUEST;
#define KERB_PA_PAC_REQUEST_PDU 23
#define SIZE_KRB5_Module_PDU_23 sizeof(KERB_PA_PAC_REQUEST)

typedef struct KERB_CHANGE_PASSWORD_DATA {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1octetstring_t new_password;
#   define target_name_present 0x80
    KERB_PRINCIPAL_NAME target_name;
#   define target_realm_present 0x40
    KERB_REALM target_realm;
} KERB_CHANGE_PASSWORD_DATA;
#define KERB_CHANGE_PASSWORD_DATA_PDU 24
#define SIZE_KRB5_Module_PDU_24 sizeof(KERB_CHANGE_PASSWORD_DATA)

typedef struct KERB_ERROR_METHOD_DATA {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t data_type;
#   define data_value_present 0x80
    ASN1octetstring_t data_value;
} KERB_ERROR_METHOD_DATA;
#define KERB_ERROR_METHOD_DATA_PDU 25
#define SIZE_KRB5_Module_PDU_25 sizeof(KERB_ERROR_METHOD_DATA)

typedef struct KERB_EXT_ERROR {
    ASN1int32_t status;
    ASN1int32_t klininfo;
    ASN1int32_t flags;
} KERB_EXT_ERROR;
#define KERB_EXT_ERROR_PDU 26
#define SIZE_KRB5_Module_PDU_26 sizeof(KERB_EXT_ERROR)

typedef struct KERB_PA_FOR_USER {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_PRINCIPAL_NAME userName;
    KERB_REALM userRealm;
    KERB_CHECKSUM cksum;
    ASN1ztcharstring_t authentication_package;
#   define KERB_PA_FOR_USER_authorization_data_present 0x80
    ASN1octetstring_t authorization_data;
} KERB_PA_FOR_USER;
#define KERB_PA_FOR_USER_PDU 27
#define SIZE_KRB5_Module_PDU_27 sizeof(KERB_PA_FOR_USER)

typedef struct KERB_PA_PAC_REQUEST_EX {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t include_pac;
#   define pac_sections_present 0x80
    PKERB_PA_PAC_REQUEST_EX_pac_sections pac_sections;
} KERB_PA_PAC_REQUEST_EX;
#define KERB_PA_PAC_REQUEST_EX_PDU 28
#define SIZE_KRB5_Module_PDU_28 sizeof(KERB_PA_PAC_REQUEST_EX)

typedef struct KERB_KDC_ISSUED_AUTH_DATA_elements_s {
    PKERB_KDC_ISSUED_AUTH_DATA_elements next;
    KERB_PA_DATA value;
} KERB_KDC_ISSUED_AUTH_DATA_elements_Element, *KERB_KDC_ISSUED_AUTH_DATA_elements;

typedef struct KERB_PA_PK_AS_REQ2_trusted_certifiers_s {
    PKERB_PA_PK_AS_REQ2_trusted_certifiers next;
    KERB_PRINCIPAL_NAME value;
} KERB_PA_PK_AS_REQ2_trusted_certifiers_Element, *KERB_PA_PK_AS_REQ2_trusted_certifiers;

typedef struct KERB_PA_PK_AS_REQ2_user_certs_s {
    PKERB_PA_PK_AS_REQ2_user_certs next;
    KERB_CERTIFICATE value;
} KERB_PA_PK_AS_REQ2_user_certs_Element, *KERB_PA_PK_AS_REQ2_user_certs;

typedef struct KERB_PA_PK_AS_REP2_kdc_cert_s {
    PKERB_PA_PK_AS_REP2_kdc_cert next;
    KERB_CERTIFICATE value;
} KERB_PA_PK_AS_REP2_kdc_cert_Element, *KERB_PA_PK_AS_REP2_kdc_cert;

typedef struct KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data_s {
    PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data next;
    KERB_PA_DATA value;
} KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data_Element, *KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data;

typedef struct KERB_KDC_REPLY_preauth_data_s {
    PKERB_KDC_REPLY_preauth_data next;
    KERB_PA_DATA value;
} KERB_KDC_REPLY_preauth_data_Element, *KERB_KDC_REPLY_preauth_data;

typedef struct KERB_KDC_REQUEST_preauth_data_s {
    PKERB_KDC_REQUEST_preauth_data next;
    KERB_PA_DATA value;
} KERB_KDC_REQUEST_preauth_data_Element, *KERB_KDC_REQUEST_preauth_data;

typedef struct KERB_TICKET {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t ticket_version;
    KERB_REALM realm;
    KERB_PRINCIPAL_NAME server_name;
    KERB_ENCRYPTED_DATA encrypted_part;
#   define ticket_extensions_present 0x80
    PPKERB_TICKET_EXTENSIONS ticket_extensions;
} KERB_TICKET;
#define KERB_TICKET_PDU 29
#define SIZE_KRB5_Module_PDU_29 sizeof(KERB_TICKET)

typedef struct KERB_ENCRYPTED_TICKET {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_TICKET_FLAGS flags;
    KERB_ENCRYPTION_KEY key;
    KERB_REALM client_realm;
    KERB_PRINCIPAL_NAME client_name;
    KERB_TRANSITED_ENCODING transited;
    KERB_TIME authtime;
#   define KERB_ENCRYPTED_TICKET_starttime_present 0x80
    KERB_TIME starttime;
    KERB_TIME endtime;
#   define KERB_ENCRYPTED_TICKET_renew_until_present 0x40
    KERB_TIME renew_until;
#   define KERB_ENCRYPTED_TICKET_client_addresses_present 0x20
    PPKERB_HOST_ADDRESSES client_addresses;
#   define KERB_ENCRYPTED_TICKET_authorization_data_present 0x10
    PPKERB_AUTHORIZATION_DATA authorization_data;
} KERB_ENCRYPTED_TICKET;
#define KERB_ENCRYPTED_TICKET_PDU 30
#define SIZE_KRB5_Module_PDU_30 sizeof(KERB_ENCRYPTED_TICKET)

typedef struct KERB_AUTHENTICATOR {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t authenticator_version;
    KERB_REALM client_realm;
    KERB_PRINCIPAL_NAME client_name;
#   define checksum_present 0x80
    KERB_CHECKSUM checksum;
    ASN1int32_t client_usec;
    KERB_TIME client_time;
#   define KERB_AUTHENTICATOR_subkey_present 0x40
    KERB_ENCRYPTION_KEY subkey;
#   define KERB_AUTHENTICATOR_sequence_number_present 0x20
    KERB_SEQUENCE_NUMBER_LARGE sequence_number;
#   define KERB_AUTHENTICATOR_authorization_data_present 0x10
    PPKERB_AUTHORIZATION_DATA authorization_data;
} KERB_AUTHENTICATOR;
#define KERB_AUTHENTICATOR_PDU 31
#define SIZE_KRB5_Module_PDU_31 sizeof(KERB_AUTHENTICATOR)

typedef struct KERB_KDC_REQUEST_BODY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_KDC_OPTIONS kdc_options;
#   define KERB_KDC_REQUEST_BODY_client_name_present 0x80
    KERB_PRINCIPAL_NAME client_name;
    KERB_REALM realm;
#   define KERB_KDC_REQUEST_BODY_server_name_present 0x40
    KERB_PRINCIPAL_NAME server_name;
#   define KERB_KDC_REQUEST_BODY_starttime_present 0x20
    KERB_TIME starttime;
    KERB_TIME endtime;
#   define KERB_KDC_REQUEST_BODY_renew_until_present 0x10
    KERB_TIME renew_until;
    ASN1int32_t nonce;
    PKERB_KDC_REQUEST_BODY_encryption_type encryption_type;
#   define addresses_present 0x8
    PPKERB_HOST_ADDRESSES addresses;
#   define enc_authorization_data_present 0x4
    KERB_ENCRYPTED_DATA enc_authorization_data;
#   define additional_tickets_present 0x2
    PKERB_KDC_REQUEST_BODY_additional_tickets additional_tickets;
} KERB_KDC_REQUEST_BODY;

typedef struct KERB_KDC_REPLY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    ASN1int32_t message_type;
#   define KERB_KDC_REPLY_preauth_data_present 0x80
    PKERB_KDC_REPLY_preauth_data preauth_data;
    KERB_REALM client_realm;
    KERB_PRINCIPAL_NAME client_name;
    KERB_TICKET ticket;
    KERB_ENCRYPTED_DATA encrypted_part;
} KERB_KDC_REPLY;

typedef struct KERB_ENCRYPTED_KDC_REPLY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_ENCRYPTION_KEY session_key;
    PPKERB_LAST_REQUEST last_request;
    ASN1int32_t nonce;
#   define key_expiration_present 0x80
    KERB_TIME key_expiration;
    KERB_TICKET_FLAGS flags;
    KERB_TIME authtime;
#   define KERB_ENCRYPTED_KDC_REPLY_starttime_present 0x40
    KERB_TIME starttime;
    KERB_TIME endtime;
#   define KERB_ENCRYPTED_KDC_REPLY_renew_until_present 0x20
    KERB_TIME renew_until;
    KERB_REALM server_realm;
    KERB_PRINCIPAL_NAME server_name;
#   define KERB_ENCRYPTED_KDC_REPLY_client_addresses_present 0x10
    PPKERB_HOST_ADDRESSES client_addresses;
#   define encrypted_pa_data_present 0x8
    PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data encrypted_pa_data;
} KERB_ENCRYPTED_KDC_REPLY;

typedef struct KERB_AP_REQUEST {
    ASN1int32_t version;
    ASN1int32_t message_type;
    KERB_AP_OPTIONS ap_options;
    KERB_TICKET ticket;
    KERB_ENCRYPTED_DATA authenticator;
} KERB_AP_REQUEST;
#define KERB_AP_REQUEST_PDU 32
#define SIZE_KRB5_Module_PDU_32 sizeof(KERB_AP_REQUEST)

typedef struct KERB_AP_REPLY {
    ASN1int32_t version;
    ASN1int32_t message_type;
    KERB_ENCRYPTED_DATA encrypted_part;
} KERB_AP_REPLY;
#define KERB_AP_REPLY_PDU 33
#define SIZE_KRB5_Module_PDU_33 sizeof(KERB_AP_REPLY)

typedef struct KERB_ENCRYPTED_AP_REPLY {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_TIME client_time;
    ASN1int32_t client_usec;
#   define KERB_ENCRYPTED_AP_REPLY_subkey_present 0x80
    KERB_ENCRYPTION_KEY subkey;
#   define KERB_ENCRYPTED_AP_REPLY_sequence_number_present 0x40
    KERB_SEQUENCE_NUMBER sequence_number;
} KERB_ENCRYPTED_AP_REPLY;
#define KERB_ENCRYPTED_AP_REPLY_PDU 34
#define SIZE_KRB5_Module_PDU_34 sizeof(KERB_ENCRYPTED_AP_REPLY)

typedef struct KERB_SAFE_MESSAGE {
    ASN1int32_t version;
    ASN1int32_t message_type;
    KERB_SAFE_BODY safe_body;
    KERB_CHECKSUM checksum;
} KERB_SAFE_MESSAGE;
#define KERB_SAFE_MESSAGE_PDU 35
#define SIZE_KRB5_Module_PDU_35 sizeof(KERB_SAFE_MESSAGE)

typedef struct KERB_PRIV_MESSAGE {
    ASN1int32_t version;
    ASN1int32_t message_type;
    KERB_ENCRYPTED_DATA encrypted_part;
} KERB_PRIV_MESSAGE;
#define KERB_PRIV_MESSAGE_PDU 36
#define SIZE_KRB5_Module_PDU_36 sizeof(KERB_PRIV_MESSAGE)

typedef struct KERB_CRED {
    ASN1int32_t version;
    ASN1int32_t message_type;
    PKERB_CRED_tickets tickets;
    KERB_ENCRYPTED_DATA encrypted_part;
} KERB_CRED;
#define KERB_CRED_PDU 37
#define SIZE_KRB5_Module_PDU_37 sizeof(KERB_CRED)

typedef struct KERB_CRED_INFO {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    KERB_ENCRYPTION_KEY key;
#   define principal_realm_present 0x80
    KERB_REALM principal_realm;
#   define principal_name_present 0x40
    KERB_PRINCIPAL_NAME principal_name;
#   define flags_present 0x20
    KERB_TICKET_FLAGS flags;
#   define authtime_present 0x10
    KERB_TIME authtime;
#   define KERB_CRED_INFO_starttime_present 0x8
    KERB_TIME starttime;
#   define endtime_present 0x4
    KERB_TIME endtime;
#   define KERB_CRED_INFO_renew_until_present 0x2
    KERB_TIME renew_until;
#   define service_realm_present 0x1
    KERB_REALM service_realm;
#   define service_name_present 0x8000
    KERB_PRINCIPAL_NAME service_name;
#   define KERB_CRED_INFO_client_addresses_present 0x4000
    PPKERB_HOST_ADDRESSES client_addresses;
} KERB_CRED_INFO;

typedef struct KERB_TGT_REPLY {
    ASN1int32_t version;
    ASN1int32_t message_type;
    KERB_TICKET ticket;
} KERB_TGT_REPLY;
#define KERB_TGT_REPLY_PDU 38
#define SIZE_KRB5_Module_PDU_38 sizeof(KERB_TGT_REPLY)

typedef struct KERB_SIGNED_REPLY_KEY_PACKAGE {
    KERB_REPLY_KEY_PACKAGE2 reply_key_package;
    KERB_SIGNATURE reply_key_signature;
} KERB_SIGNED_REPLY_KEY_PACKAGE;
#define KERB_SIGNED_REPLY_KEY_PACKAGE_PDU 39
#define SIZE_KRB5_Module_PDU_39 sizeof(KERB_SIGNED_REPLY_KEY_PACKAGE)

typedef struct KERB_SIGNED_KDC_PUBLIC_VALUE {
    KERB_SUBJECT_PUBLIC_KEY_INFO kdc_public_value;
    KERB_SIGNATURE kdc_public_value_sig;
} KERB_SIGNED_KDC_PUBLIC_VALUE;

typedef struct KERB_TRUSTED_CAS {
    ASN1choice_t choice;
    union {
#	define principal_name_chosen 1
	KERB_KERBEROS_NAME principal_name;
#	define ca_name_chosen 2
	ASN1octetstring_t ca_name;
#	define issuer_and_serial_chosen 3
	ASN1octetstring_t issuer_and_serial;
    } u;
} KERB_TRUSTED_CAS;

typedef struct KERB_AUTH_PACKAGE {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_PK_AUTHENTICATOR pk_authenticator;
#   define client_public_value_present 0x80
    KERB_SUBJECT_PUBLIC_KEY_INFO client_public_value;
} KERB_AUTH_PACKAGE;
#define KERB_AUTH_PACKAGE_PDU 40
#define SIZE_KRB5_Module_PDU_40 sizeof(KERB_AUTH_PACKAGE)

typedef struct KERB_PA_COMPOUND_IDENTITY_s {
    PKERB_PA_COMPOUND_IDENTITY next;
    KERB_TICKET value;
} KERB_PA_COMPOUND_IDENTITY_Element, *KERB_PA_COMPOUND_IDENTITY;
#define KERB_PA_COMPOUND_IDENTITY_PDU 41
#define SIZE_KRB5_Module_PDU_41 sizeof(KERB_PA_COMPOUND_IDENTITY_Element)

typedef struct KERB_PA_PK_AS_REQ_trusted_certifiers_s {
    PKERB_PA_PK_AS_REQ_trusted_certifiers next;
    KERB_TRUSTED_CAS value;
} KERB_PA_PK_AS_REQ_trusted_certifiers_Element, *KERB_PA_PK_AS_REQ_trusted_certifiers;

typedef struct KERB_ENCRYPTED_CRED_ticket_info_s {
    PKERB_ENCRYPTED_CRED_ticket_info next;
    KERB_CRED_INFO value;
} KERB_ENCRYPTED_CRED_ticket_info_Element, *KERB_ENCRYPTED_CRED_ticket_info;

typedef struct KERB_CRED_tickets_s {
    PKERB_CRED_tickets next;
    KERB_TICKET value;
} KERB_CRED_tickets_Element, *KERB_CRED_tickets;

typedef struct KERB_KDC_REQUEST_BODY_additional_tickets_s {
    PKERB_KDC_REQUEST_BODY_additional_tickets next;
    KERB_TICKET value;
} KERB_KDC_REQUEST_BODY_additional_tickets_Element, *KERB_KDC_REQUEST_BODY_additional_tickets;

typedef struct KERB_KDC_REQUEST {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    ASN1int32_t message_type;
#   define KERB_KDC_REQUEST_preauth_data_present 0x80
    PKERB_KDC_REQUEST_preauth_data preauth_data;
    KERB_KDC_REQUEST_BODY request_body;
} KERB_KDC_REQUEST;

typedef KERB_KDC_REQUEST_BODY KERB_MARSHALLED_REQUEST_BODY;
#define KERB_MARSHALLED_REQUEST_BODY_PDU 42
#define SIZE_KRB5_Module_PDU_42 sizeof(KERB_MARSHALLED_REQUEST_BODY)

typedef KERB_KDC_REPLY KERB_AS_REPLY;
#define KERB_AS_REPLY_PDU 43
#define SIZE_KRB5_Module_PDU_43 sizeof(KERB_AS_REPLY)

typedef KERB_KDC_REPLY KERB_TGS_REPLY;
#define KERB_TGS_REPLY_PDU 44
#define SIZE_KRB5_Module_PDU_44 sizeof(KERB_TGS_REPLY)

typedef KERB_ENCRYPTED_KDC_REPLY KERB_ENCRYPTED_AS_REPLY;
#define KERB_ENCRYPTED_AS_REPLY_PDU 45
#define SIZE_KRB5_Module_PDU_45 sizeof(KERB_ENCRYPTED_AS_REPLY)

typedef KERB_ENCRYPTED_KDC_REPLY KERB_ENCRYPTED_TGS_REPLY;
#define KERB_ENCRYPTED_TGS_REPLY_PDU 46
#define SIZE_KRB5_Module_PDU_46 sizeof(KERB_ENCRYPTED_TGS_REPLY)

typedef struct KERB_PA_PK_AS_REP2 {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define key_package_present 0x80
    KERB_ENCRYPTED_DATA key_package;
    KERB_ENVELOPED_KEY_PACKAGE temp_key_package;
#   define signed_kdc_public_value_present 0x40
    KERB_SIGNED_KDC_PUBLIC_VALUE signed_kdc_public_value;
#   define KERB_PA_PK_AS_REP2_kdc_cert_present 0x20
    PKERB_PA_PK_AS_REP2_kdc_cert kdc_cert;
} KERB_PA_PK_AS_REP2;
#define KERB_PA_PK_AS_REP2_PDU 47
#define SIZE_KRB5_Module_PDU_47 sizeof(KERB_PA_PK_AS_REP2)

typedef struct KERB_SIGNED_AUTH_PACKAGE {
    KERB_AUTH_PACKAGE auth_package;
    KERB_SIGNATURE auth_package_signature;
} KERB_SIGNED_AUTH_PACKAGE;

typedef KERB_KDC_REQUEST KERB_AS_REQUEST;
#define KERB_AS_REQUEST_PDU 48
#define SIZE_KRB5_Module_PDU_48 sizeof(KERB_AS_REQUEST)

typedef KERB_KDC_REQUEST KERB_TGS_REQUEST;
#define KERB_TGS_REQUEST_PDU 49
#define SIZE_KRB5_Module_PDU_49 sizeof(KERB_TGS_REQUEST)

typedef struct KERB_PA_PK_AS_REQ2 {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    KERB_SIGNED_AUTH_PACKAGE signed_auth_pack;
#   define user_certs_present 0x80
    PKERB_PA_PK_AS_REQ2_user_certs user_certs;
#   define KERB_PA_PK_AS_REQ2_trusted_certifiers_present 0x40
    PKERB_PA_PK_AS_REQ2_trusted_certifiers trusted_certifiers;
#   define serial_number_present 0x20
    KERB_CERTIFICATE_SERIAL_NUMBER serial_number;
} KERB_PA_PK_AS_REQ2;
#define KERB_PA_PK_AS_REQ2_PDU 50
#define SIZE_KRB5_Module_PDU_50 sizeof(KERB_PA_PK_AS_REQ2)


extern ASN1module_t KRB5_Module;
extern void ASN1CALL KRB5_Module_Startup(void);
extern void ASN1CALL KRB5_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _KRB5_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\snap\krb5.c ===
#include "krbprgma.h" 
#include <windows.h>
#include "krb5.h"

ASN1module_t KRB5_Module = NULL;

static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA_LIST(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_LIST *val);
static int ASN1CALL ASN1Enc_PKERB_IF_RELEVANT_AUTH_DATA(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_IF_RELEVANT_AUTH_DATA *val);
static int ASN1CALL ASN1Enc_KERB_PA_PAC_REQUEST_EX_pac_sections(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PAC_REQUEST_EX_pac_sections *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY_encryption_type(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_encryption_type *val);
static int ASN1CALL ASN1Enc_PKERB_TICKET_EXTENSIONS_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_TICKET_EXTENSIONS_Seq *val);
static int ASN1CALL ASN1Enc_KERB_PRINCIPAL_NAME_name_string(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PRINCIPAL_NAME_name_string *val);
static int ASN1CALL ASN1Enc_PKERB_LAST_REQUEST_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_LAST_REQUEST_Seq *val);
static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_Seq *val);
static int ASN1CALL ASN1Enc_PKERB_HOST_ADDRESSES_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_HOST_ADDRESSES_Seq *val);
static int ASN1CALL ASN1Enc_KERB_HOST_ADDRESS(ASN1encoding_t enc, ASN1uint32_t tag, KERB_HOST_ADDRESS *val);
static int ASN1CALL ASN1Enc_PKERB_HOST_ADDRESSES(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_HOST_ADDRESSES *val);
static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_AUTHORIZATION_DATA *val);
static int ASN1CALL ASN1Enc_PKERB_LAST_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_LAST_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_PRINCIPAL_NAME(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PRINCIPAL_NAME *val);
static int ASN1CALL ASN1Enc_PKERB_TICKET_EXTENSIONS(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_TICKET_EXTENSIONS *val);
static int ASN1CALL ASN1Enc_KERB_TRANSITED_ENCODING(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TRANSITED_ENCODING *val);
static int ASN1CALL ASN1Enc_KERB_PA_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_DATA *val);
static int ASN1CALL ASN1Enc_PKERB_PREAUTH_DATA_LIST(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_PREAUTH_DATA_LIST *val);
static int ASN1CALL ASN1Enc_KERB_SAFE_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SAFE_BODY *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_PRIV(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_PRIV *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_CRED(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_CRED *val);
static int ASN1CALL ASN1Enc_KERB_ERROR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ERROR *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_DATA *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTION_KEY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTION_KEY *val);
static int ASN1CALL ASN1Enc_KERB_CHECKSUM(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CHECKSUM *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TIMESTAMP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TIMESTAMP *val);
static int ASN1CALL ASN1Enc_KERB_SALTED_ENCRYPTED_TIMESTAMP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SALTED_ENCRYPTED_TIMESTAMP *val);
static int ASN1CALL ASN1Enc_KERB_ETYPE_INFO_ENTRY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ETYPE_INFO_ENTRY *val);
static int ASN1CALL ASN1Enc_PKERB_ETYPE_INFO(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_ETYPE_INFO *val);
static int ASN1CALL ASN1Enc_KERB_TGT_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGT_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_PKCS_SIGNATURE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PKCS_SIGNATURE *val);
static int ASN1CALL ASN1Enc_KERB_ALGORITHM_IDENTIFIER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ALGORITHM_IDENTIFIER *val);
static int ASN1CALL ASN1Enc_KERB_SIGNATURE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNATURE *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REP *val);
static int ASN1CALL ASN1Enc_KERB_ENVELOPED_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENVELOPED_KEY_PACKAGE *val);
static int ASN1CALL ASN1Enc_KERB_REPLY_KEY_PACKAGE2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE2 *val);
static int ASN1CALL ASN1Enc_KERB_REPLY_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE *val);
static int ASN1CALL ASN1Enc_KERB_KDC_DH_KEY_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_DH_KEY_INFO *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REQ *val);
static int ASN1CALL ASN1Enc_KERB_KERBEROS_NAME(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KERBEROS_NAME *val);
static int ASN1CALL ASN1Enc_KERB_PK_AUTHENTICATOR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PK_AUTHENTICATOR *val);
static int ASN1CALL ASN1Enc_KERB_SUBJECT_PUBLIC_KEY_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SUBJECT_PUBLIC_KEY_INFO *val);
static int ASN1CALL ASN1Enc_KERB_DH_PARAMTER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_DH_PARAMTER *val);
static int ASN1CALL ASN1Enc_KERB_CERTIFICATE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CERTIFICATE *val);
static int ASN1CALL ASN1Enc_KERB_TYPED_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TYPED_DATA *val);
static int ASN1CALL ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_ISSUED_AUTH_DATA *val);
static int ASN1CALL ASN1Enc_KERB_PA_SERV_REFERRAL(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_SERV_REFERRAL *val);
static int ASN1CALL ASN1Enc_KERB_PA_PAC_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PAC_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_CHANGE_PASSWORD_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CHANGE_PASSWORD_DATA *val);
static int ASN1CALL ASN1Enc_KERB_ERROR_METHOD_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ERROR_METHOD_DATA *val);
static int ASN1CALL ASN1Enc_KERB_EXT_ERROR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_EXT_ERROR *val);
static int ASN1CALL ASN1Enc_KERB_PA_FOR_USER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_FOR_USER *val);
static int ASN1CALL ASN1Enc_KERB_PA_PAC_REQUEST_EX(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PAC_REQUEST_EX *val);
static int ASN1CALL ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA_elements(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_ISSUED_AUTH_DATA_elements *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2_trusted_certifiers(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_trusted_certifiers *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2_user_certs(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_user_certs *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP2_kdc_cert(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REP2_kdc_cert *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REPLY_preauth_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REPLY_preauth_data *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_preauth_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_preauth_data *val);
static int ASN1CALL ASN1Enc_KERB_TICKET(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TICKET *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TICKET(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TICKET *val);
static int ASN1CALL ASN1Enc_KERB_AUTHENTICATOR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AUTHENTICATOR *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REQUEST_BODY *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_KDC_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_KDC_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_AP_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AP_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_AP_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AP_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_AP_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_AP_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_SAFE_MESSAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SAFE_MESSAGE *val);
static int ASN1CALL ASN1Enc_KERB_PRIV_MESSAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PRIV_MESSAGE *val);
static int ASN1CALL ASN1Enc_KERB_CRED(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CRED *val);
static int ASN1CALL ASN1Enc_KERB_CRED_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CRED_INFO *val);
static int ASN1CALL ASN1Enc_KERB_TGT_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGT_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_SIGNED_REPLY_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_REPLY_KEY_PACKAGE *val);
static int ASN1CALL ASN1Enc_KERB_SIGNED_KDC_PUBLIC_VALUE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_KDC_PUBLIC_VALUE *val);
static int ASN1CALL ASN1Enc_KERB_TRUSTED_CAS(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TRUSTED_CAS *val);
static int ASN1CALL ASN1Enc_KERB_AUTH_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AUTH_PACKAGE *val);
static int ASN1CALL ASN1Enc_KERB_PA_COMPOUND_IDENTITY(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_COMPOUND_IDENTITY *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ_trusted_certifiers(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ_trusted_certifiers *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_CRED_ticket_info(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_ENCRYPTED_CRED_ticket_info *val);
static int ASN1CALL ASN1Enc_KERB_CRED_tickets(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_CRED_tickets *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY_additional_tickets(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_additional_tickets *val);
static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_MARSHALLED_REQUEST_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_MARSHALLED_REQUEST_BODY *val);
static int ASN1CALL ASN1Enc_KERB_AS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AS_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_TGS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGS_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_AS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_AS_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TGS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TGS_REPLY *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REP2 *val);
static int ASN1CALL ASN1Enc_KERB_SIGNED_AUTH_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_AUTH_PACKAGE *val);
static int ASN1CALL ASN1Enc_KERB_AS_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AS_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_TGS_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGS_REQUEST *val);
static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REQ2 *val);
static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA_LIST(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_LIST *val);
static int ASN1CALL ASN1Dec_PKERB_IF_RELEVANT_AUTH_DATA(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_IF_RELEVANT_AUTH_DATA *val);
static int ASN1CALL ASN1Dec_KERB_PA_PAC_REQUEST_EX_pac_sections(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PAC_REQUEST_EX_pac_sections *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY_encryption_type(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_encryption_type *val);
static int ASN1CALL ASN1Dec_PKERB_TICKET_EXTENSIONS_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_TICKET_EXTENSIONS_Seq *val);
static int ASN1CALL ASN1Dec_KERB_PRINCIPAL_NAME_name_string(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PRINCIPAL_NAME_name_string *val);
static int ASN1CALL ASN1Dec_PKERB_LAST_REQUEST_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_LAST_REQUEST_Seq *val);
static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_Seq *val);
static int ASN1CALL ASN1Dec_PKERB_HOST_ADDRESSES_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_HOST_ADDRESSES_Seq *val);
static int ASN1CALL ASN1Dec_KERB_HOST_ADDRESS(ASN1decoding_t dec, ASN1uint32_t tag, KERB_HOST_ADDRESS *val);
static int ASN1CALL ASN1Dec_PKERB_HOST_ADDRESSES(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_HOST_ADDRESSES *val);
static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_AUTHORIZATION_DATA *val);
static int ASN1CALL ASN1Dec_PKERB_LAST_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_LAST_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_PRINCIPAL_NAME(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PRINCIPAL_NAME *val);
static int ASN1CALL ASN1Dec_PKERB_TICKET_EXTENSIONS(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_TICKET_EXTENSIONS *val);
static int ASN1CALL ASN1Dec_KERB_TRANSITED_ENCODING(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TRANSITED_ENCODING *val);
static int ASN1CALL ASN1Dec_KERB_PA_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_DATA *val);
static int ASN1CALL ASN1Dec_PKERB_PREAUTH_DATA_LIST(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_PREAUTH_DATA_LIST *val);
static int ASN1CALL ASN1Dec_KERB_SAFE_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SAFE_BODY *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_PRIV(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_PRIV *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_CRED(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_CRED *val);
static int ASN1CALL ASN1Dec_KERB_ERROR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ERROR *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_DATA *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTION_KEY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTION_KEY *val);
static int ASN1CALL ASN1Dec_KERB_CHECKSUM(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CHECKSUM *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TIMESTAMP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TIMESTAMP *val);
static int ASN1CALL ASN1Dec_KERB_SALTED_ENCRYPTED_TIMESTAMP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SALTED_ENCRYPTED_TIMESTAMP *val);
static int ASN1CALL ASN1Dec_KERB_ETYPE_INFO_ENTRY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ETYPE_INFO_ENTRY *val);
static int ASN1CALL ASN1Dec_PKERB_ETYPE_INFO(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_ETYPE_INFO *val);
static int ASN1CALL ASN1Dec_KERB_TGT_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGT_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_PKCS_SIGNATURE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PKCS_SIGNATURE *val);
static int ASN1CALL ASN1Dec_KERB_ALGORITHM_IDENTIFIER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ALGORITHM_IDENTIFIER *val);
static int ASN1CALL ASN1Dec_KERB_SIGNATURE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNATURE *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REP *val);
static int ASN1CALL ASN1Dec_KERB_ENVELOPED_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENVELOPED_KEY_PACKAGE *val);
static int ASN1CALL ASN1Dec_KERB_REPLY_KEY_PACKAGE2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE2 *val);
static int ASN1CALL ASN1Dec_KERB_REPLY_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE *val);
static int ASN1CALL ASN1Dec_KERB_KDC_DH_KEY_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_DH_KEY_INFO *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REQ *val);
static int ASN1CALL ASN1Dec_KERB_KERBEROS_NAME(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KERBEROS_NAME *val);
static int ASN1CALL ASN1Dec_KERB_PK_AUTHENTICATOR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PK_AUTHENTICATOR *val);
static int ASN1CALL ASN1Dec_KERB_SUBJECT_PUBLIC_KEY_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SUBJECT_PUBLIC_KEY_INFO *val);
static int ASN1CALL ASN1Dec_KERB_DH_PARAMTER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_DH_PARAMTER *val);
static int ASN1CALL ASN1Dec_KERB_CERTIFICATE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CERTIFICATE *val);
static int ASN1CALL ASN1Dec_KERB_TYPED_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TYPED_DATA *val);
static int ASN1CALL ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_ISSUED_AUTH_DATA *val);
static int ASN1CALL ASN1Dec_KERB_PA_SERV_REFERRAL(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_SERV_REFERRAL *val);
static int ASN1CALL ASN1Dec_KERB_PA_PAC_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PAC_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_CHANGE_PASSWORD_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CHANGE_PASSWORD_DATA *val);
static int ASN1CALL ASN1Dec_KERB_ERROR_METHOD_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ERROR_METHOD_DATA *val);
static int ASN1CALL ASN1Dec_KERB_EXT_ERROR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_EXT_ERROR *val);
static int ASN1CALL ASN1Dec_KERB_PA_FOR_USER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_FOR_USER *val);
static int ASN1CALL ASN1Dec_KERB_PA_PAC_REQUEST_EX(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PAC_REQUEST_EX *val);
static int ASN1CALL ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA_elements(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_ISSUED_AUTH_DATA_elements *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2_trusted_certifiers(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_trusted_certifiers *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2_user_certs(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_user_certs *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP2_kdc_cert(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REP2_kdc_cert *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REPLY_preauth_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REPLY_preauth_data *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_preauth_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_preauth_data *val);
static int ASN1CALL ASN1Dec_KERB_TICKET(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TICKET *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TICKET(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TICKET *val);
static int ASN1CALL ASN1Dec_KERB_AUTHENTICATOR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AUTHENTICATOR *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REQUEST_BODY *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_KDC_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_KDC_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_AP_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AP_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_AP_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AP_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_AP_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_AP_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_SAFE_MESSAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SAFE_MESSAGE *val);
static int ASN1CALL ASN1Dec_KERB_PRIV_MESSAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PRIV_MESSAGE *val);
static int ASN1CALL ASN1Dec_KERB_CRED(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CRED *val);
static int ASN1CALL ASN1Dec_KERB_CRED_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CRED_INFO *val);
static int ASN1CALL ASN1Dec_KERB_TGT_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGT_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_SIGNED_REPLY_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_REPLY_KEY_PACKAGE *val);
static int ASN1CALL ASN1Dec_KERB_SIGNED_KDC_PUBLIC_VALUE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_KDC_PUBLIC_VALUE *val);
static int ASN1CALL ASN1Dec_KERB_TRUSTED_CAS(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TRUSTED_CAS *val);
static int ASN1CALL ASN1Dec_KERB_AUTH_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AUTH_PACKAGE *val);
static int ASN1CALL ASN1Dec_KERB_PA_COMPOUND_IDENTITY(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_COMPOUND_IDENTITY *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ_trusted_certifiers(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ_trusted_certifiers *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_CRED_ticket_info(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_ENCRYPTED_CRED_ticket_info *val);
static int ASN1CALL ASN1Dec_KERB_CRED_tickets(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_CRED_tickets *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY_additional_tickets(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_additional_tickets *val);
static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_MARSHALLED_REQUEST_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_MARSHALLED_REQUEST_BODY *val);
static int ASN1CALL ASN1Dec_KERB_AS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AS_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_TGS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGS_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_AS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_AS_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TGS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TGS_REPLY *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REP2 *val);
static int ASN1CALL ASN1Dec_KERB_SIGNED_AUTH_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_AUTH_PACKAGE *val);
static int ASN1CALL ASN1Dec_KERB_AS_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AS_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_TGS_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGS_REQUEST *val);
static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REQ2 *val);
static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA_LIST(PKERB_AUTHORIZATION_DATA_LIST *val);
static void ASN1CALL ASN1Free_PKERB_IF_RELEVANT_AUTH_DATA(PKERB_IF_RELEVANT_AUTH_DATA *val);
static void ASN1CALL ASN1Free_KERB_PA_PAC_REQUEST_EX_pac_sections(PKERB_PA_PAC_REQUEST_EX_pac_sections *val);
static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY_encryption_type(PKERB_KDC_REQUEST_BODY_encryption_type *val);
static void ASN1CALL ASN1Free_PKERB_TICKET_EXTENSIONS_Seq(PKERB_TICKET_EXTENSIONS_Seq *val);
static void ASN1CALL ASN1Free_KERB_PRINCIPAL_NAME_name_string(PKERB_PRINCIPAL_NAME_name_string *val);
static void ASN1CALL ASN1Free_PKERB_LAST_REQUEST_Seq(PKERB_LAST_REQUEST_Seq *val);
static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA_Seq(PKERB_AUTHORIZATION_DATA_Seq *val);
static void ASN1CALL ASN1Free_PKERB_HOST_ADDRESSES_Seq(PKERB_HOST_ADDRESSES_Seq *val);
static void ASN1CALL ASN1Free_KERB_HOST_ADDRESS(KERB_HOST_ADDRESS *val);
static void ASN1CALL ASN1Free_PKERB_HOST_ADDRESSES(PPKERB_HOST_ADDRESSES *val);
static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA(PPKERB_AUTHORIZATION_DATA *val);
static void ASN1CALL ASN1Free_PKERB_LAST_REQUEST(PPKERB_LAST_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_PRINCIPAL_NAME(KERB_PRINCIPAL_NAME *val);
static void ASN1CALL ASN1Free_PKERB_TICKET_EXTENSIONS(PPKERB_TICKET_EXTENSIONS *val);
static void ASN1CALL ASN1Free_KERB_TRANSITED_ENCODING(KERB_TRANSITED_ENCODING *val);
static void ASN1CALL ASN1Free_KERB_PA_DATA(KERB_PA_DATA *val);
static void ASN1CALL ASN1Free_PKERB_PREAUTH_DATA_LIST(PPKERB_PREAUTH_DATA_LIST *val);
static void ASN1CALL ASN1Free_KERB_SAFE_BODY(KERB_SAFE_BODY *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_PRIV(KERB_ENCRYPTED_PRIV *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_CRED(KERB_ENCRYPTED_CRED *val);
static void ASN1CALL ASN1Free_KERB_ERROR(KERB_ERROR *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_DATA(KERB_ENCRYPTED_DATA *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTION_KEY(KERB_ENCRYPTION_KEY *val);
static void ASN1CALL ASN1Free_KERB_CHECKSUM(KERB_CHECKSUM *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TIMESTAMP(KERB_ENCRYPTED_TIMESTAMP *val);
static void ASN1CALL ASN1Free_KERB_SALTED_ENCRYPTED_TIMESTAMP(KERB_SALTED_ENCRYPTED_TIMESTAMP *val);
static void ASN1CALL ASN1Free_KERB_ETYPE_INFO_ENTRY(KERB_ETYPE_INFO_ENTRY *val);
static void ASN1CALL ASN1Free_PKERB_ETYPE_INFO(PPKERB_ETYPE_INFO *val);
static void ASN1CALL ASN1Free_KERB_TGT_REQUEST(KERB_TGT_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_PKCS_SIGNATURE(KERB_PKCS_SIGNATURE *val);
static void ASN1CALL ASN1Free_KERB_ALGORITHM_IDENTIFIER(KERB_ALGORITHM_IDENTIFIER *val);
static void ASN1CALL ASN1Free_KERB_SIGNATURE(KERB_SIGNATURE *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP(KERB_PA_PK_AS_REP *val);
static void ASN1CALL ASN1Free_KERB_ENVELOPED_KEY_PACKAGE(KERB_ENVELOPED_KEY_PACKAGE *val);
static void ASN1CALL ASN1Free_KERB_REPLY_KEY_PACKAGE2(KERB_REPLY_KEY_PACKAGE2 *val);
static void ASN1CALL ASN1Free_KERB_REPLY_KEY_PACKAGE(KERB_REPLY_KEY_PACKAGE *val);
static void ASN1CALL ASN1Free_KERB_KDC_DH_KEY_INFO(KERB_KDC_DH_KEY_INFO *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ(KERB_PA_PK_AS_REQ *val);
static void ASN1CALL ASN1Free_KERB_KERBEROS_NAME(KERB_KERBEROS_NAME *val);
static void ASN1CALL ASN1Free_KERB_PK_AUTHENTICATOR(KERB_PK_AUTHENTICATOR *val);
static void ASN1CALL ASN1Free_KERB_SUBJECT_PUBLIC_KEY_INFO(KERB_SUBJECT_PUBLIC_KEY_INFO *val);
static void ASN1CALL ASN1Free_KERB_CERTIFICATE(KERB_CERTIFICATE *val);
static void ASN1CALL ASN1Free_KERB_TYPED_DATA(KERB_TYPED_DATA *val);
static void ASN1CALL ASN1Free_KERB_KDC_ISSUED_AUTH_DATA(KERB_KDC_ISSUED_AUTH_DATA *val);
static void ASN1CALL ASN1Free_KERB_PA_SERV_REFERRAL(KERB_PA_SERV_REFERRAL *val);
static void ASN1CALL ASN1Free_KERB_CHANGE_PASSWORD_DATA(KERB_CHANGE_PASSWORD_DATA *val);
static void ASN1CALL ASN1Free_KERB_ERROR_METHOD_DATA(KERB_ERROR_METHOD_DATA *val);
static void ASN1CALL ASN1Free_KERB_PA_FOR_USER(KERB_PA_FOR_USER *val);
static void ASN1CALL ASN1Free_KERB_PA_PAC_REQUEST_EX(KERB_PA_PAC_REQUEST_EX *val);
static void ASN1CALL ASN1Free_KERB_KDC_ISSUED_AUTH_DATA_elements(PKERB_KDC_ISSUED_AUTH_DATA_elements *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2_trusted_certifiers(PKERB_PA_PK_AS_REQ2_trusted_certifiers *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2_user_certs(PKERB_PA_PK_AS_REQ2_user_certs *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP2_kdc_cert(PKERB_PA_PK_AS_REP2_kdc_cert *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val);
static void ASN1CALL ASN1Free_KERB_KDC_REPLY_preauth_data(PKERB_KDC_REPLY_preauth_data *val);
static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_preauth_data(PKERB_KDC_REQUEST_preauth_data *val);
static void ASN1CALL ASN1Free_KERB_TICKET(KERB_TICKET *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TICKET(KERB_ENCRYPTED_TICKET *val);
static void ASN1CALL ASN1Free_KERB_AUTHENTICATOR(KERB_AUTHENTICATOR *val);
static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY(KERB_KDC_REQUEST_BODY *val);
static void ASN1CALL ASN1Free_KERB_KDC_REPLY(KERB_KDC_REPLY *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_KDC_REPLY(KERB_ENCRYPTED_KDC_REPLY *val);
static void ASN1CALL ASN1Free_KERB_AP_REQUEST(KERB_AP_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_AP_REPLY(KERB_AP_REPLY *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_AP_REPLY(KERB_ENCRYPTED_AP_REPLY *val);
static void ASN1CALL ASN1Free_KERB_SAFE_MESSAGE(KERB_SAFE_MESSAGE *val);
static void ASN1CALL ASN1Free_KERB_PRIV_MESSAGE(KERB_PRIV_MESSAGE *val);
static void ASN1CALL ASN1Free_KERB_CRED(KERB_CRED *val);
static void ASN1CALL ASN1Free_KERB_CRED_INFO(KERB_CRED_INFO *val);
static void ASN1CALL ASN1Free_KERB_TGT_REPLY(KERB_TGT_REPLY *val);
static void ASN1CALL ASN1Free_KERB_SIGNED_REPLY_KEY_PACKAGE(KERB_SIGNED_REPLY_KEY_PACKAGE *val);
static void ASN1CALL ASN1Free_KERB_SIGNED_KDC_PUBLIC_VALUE(KERB_SIGNED_KDC_PUBLIC_VALUE *val);
static void ASN1CALL ASN1Free_KERB_TRUSTED_CAS(KERB_TRUSTED_CAS *val);
static void ASN1CALL ASN1Free_KERB_AUTH_PACKAGE(KERB_AUTH_PACKAGE *val);
static void ASN1CALL ASN1Free_KERB_PA_COMPOUND_IDENTITY(PKERB_PA_COMPOUND_IDENTITY *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ_trusted_certifiers(PKERB_PA_PK_AS_REQ_trusted_certifiers *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_CRED_ticket_info(PKERB_ENCRYPTED_CRED_ticket_info *val);
static void ASN1CALL ASN1Free_KERB_CRED_tickets(PKERB_CRED_tickets *val);
static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY_additional_tickets(PKERB_KDC_REQUEST_BODY_additional_tickets *val);
static void ASN1CALL ASN1Free_KERB_KDC_REQUEST(KERB_KDC_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_MARSHALLED_REQUEST_BODY(KERB_MARSHALLED_REQUEST_BODY *val);
static void ASN1CALL ASN1Free_KERB_AS_REPLY(KERB_AS_REPLY *val);
static void ASN1CALL ASN1Free_KERB_TGS_REPLY(KERB_TGS_REPLY *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_AS_REPLY(KERB_ENCRYPTED_AS_REPLY *val);
static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TGS_REPLY(KERB_ENCRYPTED_TGS_REPLY *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP2(KERB_PA_PK_AS_REP2 *val);
static void ASN1CALL ASN1Free_KERB_SIGNED_AUTH_PACKAGE(KERB_SIGNED_AUTH_PACKAGE *val);
static void ASN1CALL ASN1Free_KERB_AS_REQUEST(KERB_AS_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_TGS_REQUEST(KERB_TGS_REQUEST *val);
static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2(KERB_PA_PK_AS_REQ2 *val);

typedef ASN1BerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[51] = {
    (ASN1EncFun_t) ASN1Enc_PKERB_AUTHORIZATION_DATA_LIST,
    (ASN1EncFun_t) ASN1Enc_PKERB_IF_RELEVANT_AUTH_DATA,
    (ASN1EncFun_t) ASN1Enc_PKERB_PREAUTH_DATA_LIST,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_PRIV,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_CRED,
    (ASN1EncFun_t) ASN1Enc_KERB_ERROR,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_DATA,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTION_KEY,
    (ASN1EncFun_t) ASN1Enc_KERB_CHECKSUM,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_TIMESTAMP,
    (ASN1EncFun_t) ASN1Enc_KERB_SALTED_ENCRYPTED_TIMESTAMP,
    (ASN1EncFun_t) ASN1Enc_PKERB_ETYPE_INFO,
    (ASN1EncFun_t) ASN1Enc_KERB_TGT_REQUEST,
    (ASN1EncFun_t) ASN1Enc_KERB_PKCS_SIGNATURE,
    (ASN1EncFun_t) ASN1Enc_KERB_PA_PK_AS_REP,
    (ASN1EncFun_t) ASN1Enc_KERB_REPLY_KEY_PACKAGE2,
    (ASN1EncFun_t) ASN1Enc_KERB_REPLY_KEY_PACKAGE,
    (ASN1EncFun_t) ASN1Enc_KERB_KDC_DH_KEY_INFO,
    (ASN1EncFun_t) ASN1Enc_KERB_PA_PK_AS_REQ,
    (ASN1EncFun_t) ASN1Enc_KERB_DH_PARAMTER,
    (ASN1EncFun_t) ASN1Enc_KERB_TYPED_DATA,
    (ASN1EncFun_t) ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA,
    (ASN1EncFun_t) ASN1Enc_KERB_PA_SERV_REFERRAL,
    (ASN1EncFun_t) ASN1Enc_KERB_PA_PAC_REQUEST,
    (ASN1EncFun_t) ASN1Enc_KERB_CHANGE_PASSWORD_DATA,
    (ASN1EncFun_t) ASN1Enc_KERB_ERROR_METHOD_DATA,
    (ASN1EncFun_t) ASN1Enc_KERB_EXT_ERROR,
    (ASN1EncFun_t) ASN1Enc_KERB_PA_FOR_USER,
    (ASN1EncFun_t) ASN1Enc_KERB_PA_PAC_REQUEST_EX,
    (ASN1EncFun_t) ASN1Enc_KERB_TICKET,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_TICKET,
    (ASN1EncFun_t) ASN1Enc_KERB_AUTHENTICATOR,
    (ASN1EncFun_t) ASN1Enc_KERB_AP_REQUEST,
    (ASN1EncFun_t) ASN1Enc_KERB_AP_REPLY,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_AP_REPLY,
    (ASN1EncFun_t) ASN1Enc_KERB_SAFE_MESSAGE,
    (ASN1EncFun_t) ASN1Enc_KERB_PRIV_MESSAGE,
    (ASN1EncFun_t) ASN1Enc_KERB_CRED,
    (ASN1EncFun_t) ASN1Enc_KERB_TGT_REPLY,
    (ASN1EncFun_t) ASN1Enc_KERB_SIGNED_REPLY_KEY_PACKAGE,
    (ASN1EncFun_t) ASN1Enc_KERB_AUTH_PACKAGE,
    (ASN1EncFun_t) ASN1Enc_KERB_PA_COMPOUND_IDENTITY,
    (ASN1EncFun_t) ASN1Enc_KERB_MARSHALLED_REQUEST_BODY,
    (ASN1EncFun_t) ASN1Enc_KERB_AS_REPLY,
    (ASN1EncFun_t) ASN1Enc_KERB_TGS_REPLY,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_AS_REPLY,
    (ASN1EncFun_t) ASN1Enc_KERB_ENCRYPTED_TGS_REPLY,
    (ASN1EncFun_t) ASN1Enc_KERB_PA_PK_AS_REP2,
    (ASN1EncFun_t) ASN1Enc_KERB_AS_REQUEST,
    (ASN1EncFun_t) ASN1Enc_KERB_TGS_REQUEST,
    (ASN1EncFun_t) ASN1Enc_KERB_PA_PK_AS_REQ2,
};
typedef ASN1BerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[51] = {
    (ASN1DecFun_t) ASN1Dec_PKERB_AUTHORIZATION_DATA_LIST,
    (ASN1DecFun_t) ASN1Dec_PKERB_IF_RELEVANT_AUTH_DATA,
    (ASN1DecFun_t) ASN1Dec_PKERB_PREAUTH_DATA_LIST,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_PRIV,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_CRED,
    (ASN1DecFun_t) ASN1Dec_KERB_ERROR,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_DATA,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTION_KEY,
    (ASN1DecFun_t) ASN1Dec_KERB_CHECKSUM,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_TIMESTAMP,
    (ASN1DecFun_t) ASN1Dec_KERB_SALTED_ENCRYPTED_TIMESTAMP,
    (ASN1DecFun_t) ASN1Dec_PKERB_ETYPE_INFO,
    (ASN1DecFun_t) ASN1Dec_KERB_TGT_REQUEST,
    (ASN1DecFun_t) ASN1Dec_KERB_PKCS_SIGNATURE,
    (ASN1DecFun_t) ASN1Dec_KERB_PA_PK_AS_REP,
    (ASN1DecFun_t) ASN1Dec_KERB_REPLY_KEY_PACKAGE2,
    (ASN1DecFun_t) ASN1Dec_KERB_REPLY_KEY_PACKAGE,
    (ASN1DecFun_t) ASN1Dec_KERB_KDC_DH_KEY_INFO,
    (ASN1DecFun_t) ASN1Dec_KERB_PA_PK_AS_REQ,
    (ASN1DecFun_t) ASN1Dec_KERB_DH_PARAMTER,
    (ASN1DecFun_t) ASN1Dec_KERB_TYPED_DATA,
    (ASN1DecFun_t) ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA,
    (ASN1DecFun_t) ASN1Dec_KERB_PA_SERV_REFERRAL,
    (ASN1DecFun_t) ASN1Dec_KERB_PA_PAC_REQUEST,
    (ASN1DecFun_t) ASN1Dec_KERB_CHANGE_PASSWORD_DATA,
    (ASN1DecFun_t) ASN1Dec_KERB_ERROR_METHOD_DATA,
    (ASN1DecFun_t) ASN1Dec_KERB_EXT_ERROR,
    (ASN1DecFun_t) ASN1Dec_KERB_PA_FOR_USER,
    (ASN1DecFun_t) ASN1Dec_KERB_PA_PAC_REQUEST_EX,
    (ASN1DecFun_t) ASN1Dec_KERB_TICKET,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_TICKET,
    (ASN1DecFun_t) ASN1Dec_KERB_AUTHENTICATOR,
    (ASN1DecFun_t) ASN1Dec_KERB_AP_REQUEST,
    (ASN1DecFun_t) ASN1Dec_KERB_AP_REPLY,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_AP_REPLY,
    (ASN1DecFun_t) ASN1Dec_KERB_SAFE_MESSAGE,
    (ASN1DecFun_t) ASN1Dec_KERB_PRIV_MESSAGE,
    (ASN1DecFun_t) ASN1Dec_KERB_CRED,
    (ASN1DecFun_t) ASN1Dec_KERB_TGT_REPLY,
    (ASN1DecFun_t) ASN1Dec_KERB_SIGNED_REPLY_KEY_PACKAGE,
    (ASN1DecFun_t) ASN1Dec_KERB_AUTH_PACKAGE,
    (ASN1DecFun_t) ASN1Dec_KERB_PA_COMPOUND_IDENTITY,
    (ASN1DecFun_t) ASN1Dec_KERB_MARSHALLED_REQUEST_BODY,
    (ASN1DecFun_t) ASN1Dec_KERB_AS_REPLY,
    (ASN1DecFun_t) ASN1Dec_KERB_TGS_REPLY,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_AS_REPLY,
    (ASN1DecFun_t) ASN1Dec_KERB_ENCRYPTED_TGS_REPLY,
    (ASN1DecFun_t) ASN1Dec_KERB_PA_PK_AS_REP2,
    (ASN1DecFun_t) ASN1Dec_KERB_AS_REQUEST,
    (ASN1DecFun_t) ASN1Dec_KERB_TGS_REQUEST,
    (ASN1DecFun_t) ASN1Dec_KERB_PA_PK_AS_REQ2,
};
static const ASN1FreeFun_t freefntab[51] = {
    (ASN1FreeFun_t) ASN1Free_PKERB_AUTHORIZATION_DATA_LIST,
    (ASN1FreeFun_t) ASN1Free_PKERB_IF_RELEVANT_AUTH_DATA,
    (ASN1FreeFun_t) ASN1Free_PKERB_PREAUTH_DATA_LIST,
    (ASN1FreeFun_t) ASN1Free_KERB_ENCRYPTED_PRIV,
    (ASN1FreeFun_t) ASN1Free_KERB_ENCRYPTED_CRED,
    (ASN1FreeFun_t) ASN1Free_KERB_ERROR,
    (ASN1FreeFun_t) ASN1Free_KERB_ENCRYPTED_DATA,
    (ASN1FreeFun_t) ASN1Free_KERB_ENCRYPTION_KEY,
    (ASN1FreeFun_t) ASN1Free_KERB_CHECKSUM,
    (ASN1FreeFun_t) ASN1Free_KERB_ENCRYPTED_TIMESTAMP,
    (ASN1FreeFun_t) ASN1Free_KERB_SALTED_ENCRYPTED_TIMESTAMP,
    (ASN1FreeFun_t) ASN1Free_PKERB_ETYPE_INFO,
    (ASN1FreeFun_t) ASN1Free_KERB_TGT_REQUEST,
    (ASN1FreeFun_t) ASN1Free_KERB_PKCS_SIGNATURE,
    (ASN1FreeFun_t) ASN1Free_KERB_PA_PK_AS_REP,
    (ASN1FreeFun_t) ASN1Free_KERB_REPLY_KEY_PACKAGE2,
    (ASN1FreeFun_t) ASN1Free_KERB_REPLY_KEY_PACKAGE,
    (ASN1FreeFun_t) ASN1Free_KERB_KDC_DH_KEY_INFO,
    (ASN1FreeFun_t) ASN1Free_KERB_PA_PK_AS_REQ,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) ASN1Free_KERB_TYPED_DATA,
    (ASN1FreeFun_t) ASN1Free_KERB_KDC_ISSUED_AUTH_DATA,
    (ASN1FreeFun_t) ASN1Free_KERB_PA_SERV_REFERRAL,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) ASN1Free_KERB_CHANGE_PASSWORD_DATA,
    (ASN1FreeFun_t) ASN1Free_KERB_ERROR_METHOD_DATA,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) ASN1Free_KERB_PA_FOR_USER,
    (ASN1FreeFun_t) ASN1Free_KERB_PA_PAC_REQUEST_EX,
    (ASN1FreeFun_t) ASN1Free_KERB_TICKET,
    (ASN1FreeFun_t) ASN1Free_KERB_ENCRYPTED_TICKET,
    (ASN1FreeFun_t) ASN1Free_KERB_AUTHENTICATOR,
    (ASN1FreeFun_t) ASN1Free_KERB_AP_REQUEST,
    (ASN1FreeFun_t) ASN1Free_KERB_AP_REPLY,
    (ASN1FreeFun_t) ASN1Free_KERB_ENCRYPTED_AP_REPLY,
    (ASN1FreeFun_t) ASN1Free_KERB_SAFE_MESSAGE,
    (ASN1FreeFun_t) ASN1Free_KERB_PRIV_MESSAGE,
    (ASN1FreeFun_t) ASN1Free_KERB_CRED,
    (ASN1FreeFun_t) ASN1Free_KERB_TGT_REPLY,
    (ASN1FreeFun_t) ASN1Free_KERB_SIGNED_REPLY_KEY_PACKAGE,
    (ASN1FreeFun_t) ASN1Free_KERB_AUTH_PACKAGE,
    (ASN1FreeFun_t) ASN1Free_KERB_PA_COMPOUND_IDENTITY,
    (ASN1FreeFun_t) ASN1Free_KERB_MARSHALLED_REQUEST_BODY,
    (ASN1FreeFun_t) ASN1Free_KERB_AS_REPLY,
    (ASN1FreeFun_t) ASN1Free_KERB_TGS_REPLY,
    (ASN1FreeFun_t) ASN1Free_KERB_ENCRYPTED_AS_REPLY,
    (ASN1FreeFun_t) ASN1Free_KERB_ENCRYPTED_TGS_REPLY,
    (ASN1FreeFun_t) ASN1Free_KERB_PA_PK_AS_REP2,
    (ASN1FreeFun_t) ASN1Free_KERB_AS_REQUEST,
    (ASN1FreeFun_t) ASN1Free_KERB_TGS_REQUEST,
    (ASN1FreeFun_t) ASN1Free_KERB_PA_PK_AS_REQ2,
};
static const ULONG sizetab[51] = {
    SIZE_KRB5_Module_PDU_0,
    SIZE_KRB5_Module_PDU_1,
    SIZE_KRB5_Module_PDU_2,
    SIZE_KRB5_Module_PDU_3,
    SIZE_KRB5_Module_PDU_4,
    SIZE_KRB5_Module_PDU_5,
    SIZE_KRB5_Module_PDU_6,
    SIZE_KRB5_Module_PDU_7,
    SIZE_KRB5_Module_PDU_8,
    SIZE_KRB5_Module_PDU_9,
    SIZE_KRB5_Module_PDU_10,
    SIZE_KRB5_Module_PDU_11,
    SIZE_KRB5_Module_PDU_12,
    SIZE_KRB5_Module_PDU_13,
    SIZE_KRB5_Module_PDU_14,
    SIZE_KRB5_Module_PDU_15,
    SIZE_KRB5_Module_PDU_16,
    SIZE_KRB5_Module_PDU_17,
    SIZE_KRB5_Module_PDU_18,
    SIZE_KRB5_Module_PDU_19,
    SIZE_KRB5_Module_PDU_20,
    SIZE_KRB5_Module_PDU_21,
    SIZE_KRB5_Module_PDU_22,
    SIZE_KRB5_Module_PDU_23,
    SIZE_KRB5_Module_PDU_24,
    SIZE_KRB5_Module_PDU_25,
    SIZE_KRB5_Module_PDU_26,
    SIZE_KRB5_Module_PDU_27,
    SIZE_KRB5_Module_PDU_28,
    SIZE_KRB5_Module_PDU_29,
    SIZE_KRB5_Module_PDU_30,
    SIZE_KRB5_Module_PDU_31,
    SIZE_KRB5_Module_PDU_32,
    SIZE_KRB5_Module_PDU_33,
    SIZE_KRB5_Module_PDU_34,
    SIZE_KRB5_Module_PDU_35,
    SIZE_KRB5_Module_PDU_36,
    SIZE_KRB5_Module_PDU_37,
    SIZE_KRB5_Module_PDU_38,
    SIZE_KRB5_Module_PDU_39,
    SIZE_KRB5_Module_PDU_40,
    SIZE_KRB5_Module_PDU_41,
    SIZE_KRB5_Module_PDU_42,
    SIZE_KRB5_Module_PDU_43,
    SIZE_KRB5_Module_PDU_44,
    SIZE_KRB5_Module_PDU_45,
    SIZE_KRB5_Module_PDU_46,
    SIZE_KRB5_Module_PDU_47,
    SIZE_KRB5_Module_PDU_48,
    SIZE_KRB5_Module_PDU_49,
    SIZE_KRB5_Module_PDU_50,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */

void ASN1CALL KRB5_Module_Startup(void)
{
    KRB5_Module = ASN1_CreateModule(0x10000, ASN1_BER_RULE_DER, ASN1FLAGS_NOASSERT, 51, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x3562726b);
}

void ASN1CALL KRB5_Module_Cleanup(void)
{
    ASN1_CloseModule(KRB5_Module);
    KRB5_Module = NULL;
}

static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA_LIST(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_LIST *val)
{
    if (!ASN1Enc_PKERB_AUTHORIZATION_DATA(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA_LIST(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_LIST *val)
{
    if (!ASN1Dec_PKERB_AUTHORIZATION_DATA(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA_LIST(PKERB_AUTHORIZATION_DATA_LIST *val)
{
    if (val) {
	ASN1Free_PKERB_AUTHORIZATION_DATA(val);
    }
}

static int ASN1CALL ASN1Enc_PKERB_IF_RELEVANT_AUTH_DATA(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_IF_RELEVANT_AUTH_DATA *val)
{
    if (!ASN1Enc_PKERB_AUTHORIZATION_DATA(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_IF_RELEVANT_AUTH_DATA(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_IF_RELEVANT_AUTH_DATA *val)
{
    if (!ASN1Dec_PKERB_AUTHORIZATION_DATA(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_IF_RELEVANT_AUTH_DATA(PKERB_IF_RELEVANT_AUTH_DATA *val)
{
    if (val) {
	ASN1Free_PKERB_AUTHORIZATION_DATA(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PAC_REQUEST_EX_pac_sections(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PAC_REQUEST_EX_pac_sections *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_PA_PAC_REQUEST_EX_pac_sections f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1BEREncS32(enc, 0x2, f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PAC_REQUEST_EX_pac_sections(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PAC_REQUEST_EX_pac_sections *val)
{
    PKERB_PA_PAC_REQUEST_EX_pac_sections *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_PA_PAC_REQUEST_EX_pac_sections)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1BERDecS32Val(dd, 0x2, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PAC_REQUEST_EX_pac_sections(PKERB_PA_PAC_REQUEST_EX_pac_sections *val)
{
    PKERB_PA_PAC_REQUEST_EX_pac_sections f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY_encryption_type(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_encryption_type *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_KDC_REQUEST_BODY_encryption_type f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000008, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1BEREncS32(enc, 0x2, f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY_encryption_type(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_encryption_type *val)
{
    PKERB_KDC_REQUEST_BODY_encryption_type *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000008, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_KDC_REQUEST_BODY_encryption_type)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1BERDecS32Val(dd, 0x2, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY_encryption_type(PKERB_KDC_REQUEST_BODY_encryption_type *val)
{
    PKERB_KDC_REQUEST_BODY_encryption_type f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_PKERB_TICKET_EXTENSIONS_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_TICKET_EXTENSIONS_Seq *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->te_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->te_data).length, ((val)->te_data).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_TICKET_EXTENSIONS_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_TICKET_EXTENSIONS_Seq *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->te_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->te_data))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_TICKET_EXTENSIONS_Seq(PKERB_TICKET_EXTENSIONS_Seq *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->te_data);
    }
}

static int ASN1CALL ASN1Enc_KERB_PRINCIPAL_NAME_name_string(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PRINCIPAL_NAME_name_string *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_PRINCIPAL_NAME_name_string f;
    ASN1uint32_t nLenOff;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	t = lstrlenA(f->value);
	if (!ASN1DEREncCharString(enc, 0x1b, t, f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PRINCIPAL_NAME_name_string(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PRINCIPAL_NAME_name_string *val)
{
    PKERB_PRINCIPAL_NAME_name_string *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_PRINCIPAL_NAME_name_string)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1BERDecZeroCharString(dd, 0x1b, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PRINCIPAL_NAME_name_string(PKERB_PRINCIPAL_NAME_name_string *val)
{
    PKERB_PRINCIPAL_NAME_name_string f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1ztcharstring_free(f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_PKERB_LAST_REQUEST_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_LAST_REQUEST_Seq *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->last_request_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->last_request_value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_LAST_REQUEST_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_LAST_REQUEST_Seq *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->last_request_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->last_request_value))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_LAST_REQUEST_Seq(PKERB_LAST_REQUEST_Seq *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_Seq *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->auth_data_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->auth_data).length, ((val)->auth_data).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_AUTHORIZATION_DATA_Seq *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->auth_data_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->auth_data))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA_Seq(PKERB_AUTHORIZATION_DATA_Seq *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->auth_data);
    }
}

static int ASN1CALL ASN1Enc_PKERB_HOST_ADDRESSES_Seq(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_HOST_ADDRESSES_Seq *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->address_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->address).length, ((val)->address).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_HOST_ADDRESSES_Seq(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_HOST_ADDRESSES_Seq *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->address_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->address))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_HOST_ADDRESSES_Seq(PKERB_HOST_ADDRESSES_Seq *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->address);
    }
}

static int ASN1CALL ASN1Enc_KERB_HOST_ADDRESS(ASN1encoding_t enc, ASN1uint32_t tag, KERB_HOST_ADDRESS *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->addr_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->address).length, ((val)->address).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_HOST_ADDRESS(ASN1decoding_t dec, ASN1uint32_t tag, KERB_HOST_ADDRESS *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->addr_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->address))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_HOST_ADDRESS(KERB_HOST_ADDRESS *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->address);
    }
}

static int ASN1CALL ASN1Enc_PKERB_HOST_ADDRESSES(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_HOST_ADDRESSES *val)
{
    PPKERB_HOST_ADDRESSES f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_PKERB_HOST_ADDRESSES_Seq(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_HOST_ADDRESSES(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_HOST_ADDRESSES *val)
{
    PPKERB_HOST_ADDRESSES *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PPKERB_HOST_ADDRESSES)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_PKERB_HOST_ADDRESSES_Seq(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_HOST_ADDRESSES(PPKERB_HOST_ADDRESSES *val)
{
    PPKERB_HOST_ADDRESSES f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_PKERB_HOST_ADDRESSES_Seq(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_PKERB_AUTHORIZATION_DATA(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_AUTHORIZATION_DATA *val)
{
    PPKERB_AUTHORIZATION_DATA f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_PKERB_AUTHORIZATION_DATA_Seq(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_AUTHORIZATION_DATA(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_AUTHORIZATION_DATA *val)
{
    PPKERB_AUTHORIZATION_DATA *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PPKERB_AUTHORIZATION_DATA)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_PKERB_AUTHORIZATION_DATA_Seq(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_AUTHORIZATION_DATA(PPKERB_AUTHORIZATION_DATA *val)
{
    PPKERB_AUTHORIZATION_DATA f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_PKERB_AUTHORIZATION_DATA_Seq(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_PKERB_LAST_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_LAST_REQUEST *val)
{
    PPKERB_LAST_REQUEST f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_PKERB_LAST_REQUEST_Seq(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_LAST_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_LAST_REQUEST *val)
{
    PPKERB_LAST_REQUEST *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PPKERB_LAST_REQUEST)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_PKERB_LAST_REQUEST_Seq(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_LAST_REQUEST(PPKERB_LAST_REQUEST *val)
{
    PPKERB_LAST_REQUEST f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_PKERB_LAST_REQUEST_Seq(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_PRINCIPAL_NAME(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PRINCIPAL_NAME *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->name_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME_name_string(enc, 0, &(val)->name_string))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PRINCIPAL_NAME(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PRINCIPAL_NAME *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->name_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME_name_string(dd, 0, &(val)->name_string))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PRINCIPAL_NAME(KERB_PRINCIPAL_NAME *val)
{
    if (val) {
	ASN1Free_KERB_PRINCIPAL_NAME_name_string(&(val)->name_string);
    }
}

static int ASN1CALL ASN1Enc_PKERB_TICKET_EXTENSIONS(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_TICKET_EXTENSIONS *val)
{
    PPKERB_TICKET_EXTENSIONS f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_PKERB_TICKET_EXTENSIONS_Seq(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_TICKET_EXTENSIONS(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_TICKET_EXTENSIONS *val)
{
    PPKERB_TICKET_EXTENSIONS *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PPKERB_TICKET_EXTENSIONS)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_PKERB_TICKET_EXTENSIONS_Seq(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_TICKET_EXTENSIONS(PPKERB_TICKET_EXTENSIONS *val)
{
    PPKERB_TICKET_EXTENSIONS f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_PKERB_TICKET_EXTENSIONS_Seq(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_TRANSITED_ENCODING(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TRANSITED_ENCODING *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->transited_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->contents).length, ((val)->contents).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TRANSITED_ENCODING(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TRANSITED_ENCODING *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->transited_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->contents))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TRANSITED_ENCODING(KERB_TRANSITED_ENCODING *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->contents);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->preauth_data_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->preauth_data).length, ((val)->preauth_data).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->preauth_data_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->preauth_data))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_DATA(KERB_PA_DATA *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->preauth_data);
    }
}

static int ASN1CALL ASN1Enc_PKERB_PREAUTH_DATA_LIST(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_PREAUTH_DATA_LIST *val)
{
    PPKERB_PREAUTH_DATA_LIST f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_PA_DATA(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_PREAUTH_DATA_LIST(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_PREAUTH_DATA_LIST *val)
{
    PPKERB_PREAUTH_DATA_LIST *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PPKERB_PREAUTH_DATA_LIST)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_PA_DATA(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_PREAUTH_DATA_LIST(PPKERB_PREAUTH_DATA_LIST *val)
{
    PPKERB_PREAUTH_DATA_LIST f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_PA_DATA(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_SAFE_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SAFE_BODY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->user_data).length, ((val)->user_data).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->timestamp))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->usec))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1BEREncU32(enc, 0x2, (val)->sequence_number))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->sender_address))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->recipient_address))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SAFE_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SAFE_BODY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->user_data))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->timestamp))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->usec))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecU32Val(dd0, 0x2, (ASN1uint32_t *) &(val)->sequence_number))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->sender_address))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000005) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->recipient_address))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SAFE_BODY(KERB_SAFE_BODY *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->user_data);
	if ((val)->o[0] & 0x80) {
	}
	ASN1Free_KERB_HOST_ADDRESS(&(val)->sender_address);
	if ((val)->o[0] & 0x10) {
	    ASN1Free_KERB_HOST_ADDRESS(&(val)->recipient_address);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_PRIV(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_PRIV *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000001c, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->user_data).length, ((val)->user_data).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->timestamp))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->usec))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1BEREncU32(enc, 0x2, (val)->sequence_number))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->sender_address))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->recipient_address))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_PRIV(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_PRIV *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000001c, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->user_data))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->timestamp))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->usec))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecU32Val(dd0, 0x2, (ASN1uint32_t *) &(val)->sequence_number))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->sender_address))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000005) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->recipient_address))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_PRIV(KERB_ENCRYPTED_PRIV *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->user_data);
	if ((val)->o[0] & 0x80) {
	}
	ASN1Free_KERB_HOST_ADDRESS(&(val)->sender_address);
	if ((val)->o[0] & 0x10) {
	    ASN1Free_KERB_HOST_ADDRESS(&(val)->recipient_address);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_CRED(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_CRED *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000001d, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_CRED_ticket_info(enc, 0, &(val)->ticket_info))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->timestamp))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->usec))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->sender_address))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_HOST_ADDRESS(enc, 0, &(val)->recipient_address))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_CRED(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_CRED *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000001d, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1Dec_KERB_ENCRYPTED_CRED_ticket_info(dd, 0, &(val)->ticket_info))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->timestamp))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->usec))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->sender_address))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000005) {
	(val)->o[0] |= 0x8;
	if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_HOST_ADDRESS(dd0, 0, &(val)->recipient_address))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_CRED(KERB_ENCRYPTED_CRED *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTED_CRED_ticket_info(&(val)->ticket_info);
	if ((val)->o[0] & 0x40) {
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_KERB_HOST_ADDRESS(&(val)->sender_address);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_KERB_HOST_ADDRESS(&(val)->recipient_address);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ERROR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ERROR *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000001e, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->client_time))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->client_usec))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->server_time))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->server_usec))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->error_code))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x20) {
	t = lstrlenA((val)->client_realm);
	if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
	    return 0;
	if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->client_realm))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000008, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->client_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    t = lstrlenA((val)->realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000009, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x8000000a, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->server_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x8) {
	if (!ASN1BEREncExplicitTag(enc, 0x8000000b, &nLenOff0))
	    return 0;
	if (!ASN1DEREncCharString(enc, 0x1b, ((val)->error_text).length, ((val)->error_text).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1BEREncExplicitTag(enc, 0x8000000c, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->error_data).length, ((val)->error_data).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ERROR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ERROR *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000001e, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->client_time))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->client_usec))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->server_time))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->server_usec))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->error_code))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000007) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->client_realm))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000008) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000008, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->client_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000009, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x8000000a, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->server_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000b) {
	(val)->o[0] |= 0x8;
	if (!ASN1BERDecExplicitTag(dd, 0x8000000b, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecCharString(dd0, 0x1b, &(val)->error_text))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000c) {
	(val)->o[0] |= 0x4;
	if (!ASN1BERDecExplicitTag(dd, 0x8000000c, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->error_data))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ERROR(KERB_ERROR *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x20) {
	    ASN1ztcharstring_free((val)->client_realm);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->client_name);
	}
	ASN1ztcharstring_free((val)->realm);
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->server_name);
	if ((val)->o[0] & 0x8) {
	    ASN1charstring_free(&(val)->error_text);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1octetstring_free(&(val)->error_data);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->encryption_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->cipher_text).length, ((val)->cipher_text).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->encryption_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->cipher_text))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_DATA(KERB_ENCRYPTED_DATA *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->cipher_text);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTION_KEY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTION_KEY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->keytype))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->keyvalue).length, ((val)->keyvalue).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTION_KEY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTION_KEY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->keytype))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->keyvalue))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTION_KEY(KERB_ENCRYPTION_KEY *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->keyvalue);
    }
}

static int ASN1CALL ASN1Enc_KERB_CHECKSUM(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CHECKSUM *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->checksum_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->checksum).length, ((val)->checksum).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CHECKSUM(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CHECKSUM *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->checksum_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->checksum))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CHECKSUM(KERB_CHECKSUM *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->checksum);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TIMESTAMP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TIMESTAMP *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->timestamp))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->usec))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TIMESTAMP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TIMESTAMP *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->timestamp))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->usec))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TIMESTAMP(KERB_ENCRYPTED_TIMESTAMP *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_KERB_SALTED_ENCRYPTED_TIMESTAMP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SALTED_ENCRYPTED_TIMESTAMP *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->timestamp))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->usec))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->salt).length, ((val)->salt).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SALTED_ENCRYPTED_TIMESTAMP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SALTED_ENCRYPTED_TIMESTAMP *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->timestamp))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->usec))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->salt))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SALTED_ENCRYPTED_TIMESTAMP(KERB_SALTED_ENCRYPTED_TIMESTAMP *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->salt);
    }
}

static int ASN1CALL ASN1Enc_KERB_ETYPE_INFO_ENTRY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ETYPE_INFO_ENTRY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->encryption_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->salt).length, ((val)->salt).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ETYPE_INFO_ENTRY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ETYPE_INFO_ENTRY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->encryption_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->salt))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ETYPE_INFO_ENTRY(KERB_ETYPE_INFO_ENTRY *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1octetstring_free(&(val)->salt);
	}
    }
}

static int ASN1CALL ASN1Enc_PKERB_ETYPE_INFO(ASN1encoding_t enc, ASN1uint32_t tag, PPKERB_ETYPE_INFO *val)
{
    PPKERB_ETYPE_INFO f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_ETYPE_INFO_ENTRY(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PKERB_ETYPE_INFO(ASN1decoding_t dec, ASN1uint32_t tag, PPKERB_ETYPE_INFO *val)
{
    PPKERB_ETYPE_INFO *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PPKERB_ETYPE_INFO)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_ETYPE_INFO_ENTRY(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PKERB_ETYPE_INFO(PPKERB_ETYPE_INFO *val)
{
    PPKERB_ETYPE_INFO f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_ETYPE_INFO_ENTRY(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_TGT_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGT_REQUEST *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->server_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	t = lstrlenA((val)->server_realm);
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->server_realm))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TGT_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGT_REQUEST *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->server_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->server_realm))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TGT_REQUEST(KERB_TGT_REQUEST *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->server_name);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1ztcharstring_free((val)->server_realm);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_PKCS_SIGNATURE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PKCS_SIGNATURE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->encryption_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->signature).length, ((val)->signature).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PKCS_SIGNATURE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PKCS_SIGNATURE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->encryption_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->signature))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PKCS_SIGNATURE(KERB_PKCS_SIGNATURE *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->signature);
    }
}

static int ASN1CALL ASN1Enc_KERB_ALGORITHM_IDENTIFIER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ALGORITHM_IDENTIFIER *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier(enc, 0x6, &(val)->algorithm))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncOpenType(enc, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ALGORITHM_IDENTIFIER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ALGORITHM_IDENTIFIER *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier(dd, 0x6, &(val)->algorithm))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOpenType2(dd, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ALGORITHM_IDENTIFIER(KERB_ALGORITHM_IDENTIFIER *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->algorithm);
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_SIGNATURE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNATURE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ALGORITHM_IDENTIFIER(enc, 0, &(val)->signature_algorithm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->pkcs_signature).length, ((val)->pkcs_signature).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SIGNATURE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNATURE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ALGORITHM_IDENTIFIER(dd0, 0, &(val)->signature_algorithm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->pkcs_signature))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SIGNATURE(KERB_SIGNATURE *val)
{
    if (val) {
	ASN1Free_KERB_ALGORITHM_IDENTIFIER(&(val)->signature_algorithm);
	ASN1bitstring_free(&(val)->pkcs_signature);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REP *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1DEREncOctetString(enc, 0x80000000, ((val)->u.dh_signed_data).length, ((val)->u.dh_signed_data).value))
	    return 0;
	break;
    case 2:
	if (!ASN1DEREncOctetString(enc, 0x80000001, ((val)->u.key_package).length, ((val)->u.key_package).value))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REP *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x80000000:
	(val)->choice = 1;
	if (!ASN1BERDecOctetString(dec, 0x80000000, &(val)->u.dh_signed_data))
	    return 0;
	break;
    case 0x80000001:
	(val)->choice = 2;
	if (!ASN1BERDecOctetString(dec, 0x80000001, &(val)->u.key_package))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP(KERB_PA_PK_AS_REP *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1octetstring_free(&(val)->u.dh_signed_data);
	    break;
	case 2:
	    ASN1octetstring_free(&(val)->u.key_package);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ENVELOPED_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENVELOPED_KEY_PACKAGE *val)
{
    ASN1uint32_t nLenOff0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->u.encrypted_data))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
	break;
    case 2:
	if (!ASN1DEREncOctetString(enc, 0x80000004, ((val)->u.pkinit_enveloped_data).length, ((val)->u.pkinit_enveloped_data).value))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENVELOPED_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENVELOPED_KEY_PACKAGE *val)
{
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x80000001:
	(val)->choice = 1;
	if (!ASN1BERDecExplicitTag(dec, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->u.encrypted_data))
	    return 0;
	if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	    return 0;
	break;
    case 0x80000004:
	(val)->choice = 2;
	if (!ASN1BERDecOctetString(dec, 0x80000004, &(val)->u.pkinit_enveloped_data))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENVELOPED_KEY_PACKAGE(KERB_ENVELOPED_KEY_PACKAGE *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_KERB_ENCRYPTED_DATA(&(val)->u.encrypted_data);
	    break;
	case 2:
	    ASN1octetstring_free(&(val)->u.pkinit_enveloped_data);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_REPLY_KEY_PACKAGE2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE2 *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->reply_key))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1DEREncBitString(enc, 0x3, ((val)->subject_public_key).length, ((val)->subject_public_key).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_REPLY_KEY_PACKAGE2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE2 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->reply_key))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecBitString(dd0, 0x3, &(val)->subject_public_key))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_REPLY_KEY_PACKAGE2(KERB_REPLY_KEY_PACKAGE2 *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTION_KEY(&(val)->reply_key);
	if ((val)->o[0] & 0x80) {
	    ASN1bitstring_free(&(val)->subject_public_key);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_REPLY_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->reply_key))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_REPLY_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_REPLY_KEY_PACKAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->reply_key))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_REPLY_KEY_PACKAGE(KERB_REPLY_KEY_PACKAGE *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTION_KEY(&(val)->reply_key);
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_DH_KEY_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_DH_KEY_INFO *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->subject_public_key).length, ((val)->subject_public_key).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_DH_KEY_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_DH_KEY_INFO *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->subject_public_key))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_DH_KEY_INFO(KERB_KDC_DH_KEY_INFO *val)
{
    if (val) {
	ASN1bitstring_free(&(val)->subject_public_key);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REQ *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x80000000, ((val)->signed_auth_pack).length, ((val)->signed_auth_pack).value))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_KERB_PA_PK_AS_REQ_trusted_certifiers(enc, 0, &(val)->trusted_certifiers))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1DEREncOctetString(enc, 0x80000003, ((val)->kdc_cert).length, ((val)->kdc_cert).value))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1DEREncOctetString(enc, 0x80000004, ((val)->encryption_cert).length, ((val)->encryption_cert).value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REQ *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecOctetString(dd, 0x80000000, &(val)->signed_auth_pack))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_KERB_PA_PK_AS_REQ_trusted_certifiers(dd, 0, &(val)->trusted_certifiers))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecOctetString(dd, 0x80000003, &(val)->kdc_cert))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecOctetString(dd, 0x80000004, &(val)->encryption_cert))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ(KERB_PA_PK_AS_REQ *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->signed_auth_pack);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_PA_PK_AS_REQ_trusted_certifiers(&(val)->trusted_certifiers);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1octetstring_free(&(val)->kdc_cert);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1octetstring_free(&(val)->encryption_cert);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KERBEROS_NAME(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KERBEROS_NAME *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t t;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    t = lstrlenA((val)->realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->principal_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KERBEROS_NAME(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KERBEROS_NAME *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->principal_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KERBEROS_NAME(KERB_KERBEROS_NAME *val)
{
    if (val) {
	ASN1ztcharstring_free((val)->realm);
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->principal_name);
    }
}

static int ASN1CALL ASN1Enc_KERB_PK_AUTHENTICATOR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PK_AUTHENTICATOR *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->kdc_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    t = lstrlenA((val)->kdc_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->kdc_realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->cusec))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->client_time))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PK_AUTHENTICATOR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PK_AUTHENTICATOR *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->kdc_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->kdc_realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->cusec))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->client_time))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PK_AUTHENTICATOR(KERB_PK_AUTHENTICATOR *val)
{
    if (val) {
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->kdc_name);
	ASN1ztcharstring_free((val)->kdc_realm);
    }
}

static int ASN1CALL ASN1Enc_KERB_SUBJECT_PUBLIC_KEY_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SUBJECT_PUBLIC_KEY_INFO *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ALGORITHM_IDENTIFIER(enc, 0, &(val)->algorithm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->subjectPublicKey).length, ((val)->subjectPublicKey).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SUBJECT_PUBLIC_KEY_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SUBJECT_PUBLIC_KEY_INFO *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ALGORITHM_IDENTIFIER(dd0, 0, &(val)->algorithm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->subjectPublicKey))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SUBJECT_PUBLIC_KEY_INFO(KERB_SUBJECT_PUBLIC_KEY_INFO *val)
{
    if (val) {
	ASN1Free_KERB_ALGORITHM_IDENTIFIER(&(val)->algorithm);
	ASN1bitstring_free(&(val)->subjectPublicKey);
    }
}

static int ASN1CALL ASN1Enc_KERB_DH_PARAMTER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_DH_PARAMTER *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->prime))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->base))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->private_value_length))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_DH_PARAMTER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_DH_PARAMTER *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->prime))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->base))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->private_value_length))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_KERB_CERTIFICATE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CERTIFICATE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->cert_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->cert_data).length, ((val)->cert_data).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CERTIFICATE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CERTIFICATE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->cert_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->cert_data))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CERTIFICATE(KERB_CERTIFICATE *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->cert_data);
    }
}

static int ASN1CALL ASN1Enc_KERB_TYPED_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TYPED_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->data_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->data_value).length, ((val)->data_value).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TYPED_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TYPED_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->data_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->data_value))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TYPED_DATA(KERB_TYPED_DATA *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->data_value);
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_ISSUED_AUTH_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_SIGNATURE(enc, 0, &(val)->checksum))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA_elements(enc, 0, &(val)->elements))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_ISSUED_AUTH_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_SIGNATURE(dd0, 0, &(val)->checksum))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA_elements(dd, 0, &(val)->elements))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_ISSUED_AUTH_DATA(KERB_KDC_ISSUED_AUTH_DATA *val)
{
    if (val) {
	ASN1Free_KERB_SIGNATURE(&(val)->checksum);
	ASN1Free_KERB_KDC_ISSUED_AUTH_DATA_elements(&(val)->elements);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_SERV_REFERRAL(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_SERV_REFERRAL *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->referred_server_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    t = lstrlenA((val)->referred_server_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->referred_server_realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_SERV_REFERRAL(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_SERV_REFERRAL *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->referred_server_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->referred_server_realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_SERV_REFERRAL(KERB_PA_SERV_REFERRAL *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->referred_server_name);
	}
	ASN1ztcharstring_free((val)->referred_server_realm);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PAC_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PAC_REQUEST *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncBool(enc, 0x1, (val)->include_pac))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PAC_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PAC_REQUEST *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBool(dd0, 0x1, &(val)->include_pac))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_KERB_CHANGE_PASSWORD_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CHANGE_PASSWORD_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->new_password).length, ((val)->new_password).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->target_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	t = lstrlenA((val)->target_realm);
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->target_realm))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CHANGE_PASSWORD_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CHANGE_PASSWORD_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->new_password))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->target_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->target_realm))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CHANGE_PASSWORD_DATA(KERB_CHANGE_PASSWORD_DATA *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->new_password);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->target_name);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1ztcharstring_free((val)->target_realm);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ERROR_METHOD_DATA(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ERROR_METHOD_DATA *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->data_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->data_value).length, ((val)->data_value).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ERROR_METHOD_DATA(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ERROR_METHOD_DATA *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->data_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->data_value))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ERROR_METHOD_DATA(KERB_ERROR_METHOD_DATA *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1octetstring_free(&(val)->data_value);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_EXT_ERROR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_EXT_ERROR *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->status))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->klininfo))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->flags))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_EXT_ERROR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_EXT_ERROR *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->status))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->klininfo))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->flags))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_KERB_PA_FOR_USER(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_FOR_USER *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->userName))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    t = lstrlenA((val)->userRealm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->userRealm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_CHECKSUM(enc, 0, &(val)->cksum))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    t = lstrlenA((val)->authentication_package);
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->authentication_package))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->authorization_data).length, ((val)->authorization_data).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_FOR_USER(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_FOR_USER *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->userName))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->userRealm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_CHECKSUM(dd0, 0, &(val)->cksum))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->authentication_package))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->authorization_data))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_FOR_USER(KERB_PA_FOR_USER *val)
{
    if (val) {
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->userName);
	ASN1ztcharstring_free((val)->userRealm);
	ASN1Free_KERB_CHECKSUM(&(val)->cksum);
	ASN1ztcharstring_free((val)->authentication_package);
	if ((val)->o[0] & 0x80) {
	    ASN1octetstring_free(&(val)->authorization_data);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PAC_REQUEST_EX(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PAC_REQUEST_EX *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncBool(enc, 0x1, (val)->include_pac))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_KERB_PA_PAC_REQUEST_EX_pac_sections(enc, 0, &(val)->pac_sections))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PAC_REQUEST_EX(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PAC_REQUEST_EX *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBool(dd0, 0x1, &(val)->include_pac))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_KERB_PA_PAC_REQUEST_EX_pac_sections(dd, 0, &(val)->pac_sections))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PAC_REQUEST_EX(KERB_PA_PAC_REQUEST_EX *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_PA_PAC_REQUEST_EX_pac_sections(&(val)->pac_sections);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_ISSUED_AUTH_DATA_elements(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_ISSUED_AUTH_DATA_elements *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_KDC_ISSUED_AUTH_DATA_elements f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_PA_DATA(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_ISSUED_AUTH_DATA_elements(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_ISSUED_AUTH_DATA_elements *val)
{
    PKERB_KDC_ISSUED_AUTH_DATA_elements *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_KDC_ISSUED_AUTH_DATA_elements)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_PA_DATA(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_ISSUED_AUTH_DATA_elements(PKERB_KDC_ISSUED_AUTH_DATA_elements *val)
{
    PKERB_KDC_ISSUED_AUTH_DATA_elements f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_PA_DATA(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2_trusted_certifiers(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_trusted_certifiers *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_PA_PK_AS_REQ2_trusted_certifiers f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2_trusted_certifiers(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_trusted_certifiers *val)
{
    PKERB_PA_PK_AS_REQ2_trusted_certifiers *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_PA_PK_AS_REQ2_trusted_certifiers)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2_trusted_certifiers(PKERB_PA_PK_AS_REQ2_trusted_certifiers *val)
{
    PKERB_PA_PK_AS_REQ2_trusted_certifiers f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2_user_certs(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_user_certs *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_PA_PK_AS_REQ2_user_certs f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_CERTIFICATE(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2_user_certs(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ2_user_certs *val)
{
    PKERB_PA_PK_AS_REQ2_user_certs *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_PA_PK_AS_REQ2_user_certs)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_CERTIFICATE(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2_user_certs(PKERB_PA_PK_AS_REQ2_user_certs *val)
{
    PKERB_PA_PK_AS_REQ2_user_certs f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_CERTIFICATE(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP2_kdc_cert(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REP2_kdc_cert *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_PA_PK_AS_REP2_kdc_cert f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_CERTIFICATE(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP2_kdc_cert(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REP2_kdc_cert *val)
{
    PKERB_PA_PK_AS_REP2_kdc_cert *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_PA_PK_AS_REP2_kdc_cert)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_CERTIFICATE(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP2_kdc_cert(PKERB_PA_PK_AS_REP2_kdc_cert *val)
{
    PKERB_PA_PK_AS_REP2_kdc_cert f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_CERTIFICATE(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x8000000c, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_PA_DATA(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val)
{
    PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x8000000c, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_PA_DATA(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data *val)
{
    PKERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_PA_DATA(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REPLY_preauth_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REPLY_preauth_data *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_KDC_REPLY_preauth_data f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_PA_DATA(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REPLY_preauth_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REPLY_preauth_data *val)
{
    PKERB_KDC_REPLY_preauth_data *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_KDC_REPLY_preauth_data)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_PA_DATA(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REPLY_preauth_data(PKERB_KDC_REPLY_preauth_data *val)
{
    PKERB_KDC_REPLY_preauth_data f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_PA_DATA(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_preauth_data(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_preauth_data *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_KDC_REQUEST_preauth_data f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_PA_DATA(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_preauth_data(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_preauth_data *val)
{
    PKERB_KDC_REQUEST_preauth_data *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_KDC_REQUEST_preauth_data)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_PA_DATA(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_preauth_data(PKERB_KDC_REQUEST_preauth_data *val)
{
    PKERB_KDC_REQUEST_preauth_data f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_PA_DATA(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_TICKET(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TICKET *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000001, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->ticket_version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    t = lstrlenA((val)->realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->server_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	    return 0;
	if (!ASN1Enc_PKERB_TICKET_EXTENSIONS(enc, 0, &(val)->ticket_extensions))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TICKET(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TICKET *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000001, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->ticket_version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->server_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_PKERB_TICKET_EXTENSIONS(dd0, 0, &(val)->ticket_extensions))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TICKET(KERB_TICKET *val)
{
    if (val) {
	ASN1ztcharstring_free((val)->realm);
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->server_name);
	ASN1Free_KERB_ENCRYPTED_DATA(&(val)->encrypted_part);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_PKERB_TICKET_EXTENSIONS(&(val)->ticket_extensions);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TICKET(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TICKET *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000003, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->flags).length, ((val)->flags).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->key))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    t = lstrlenA((val)->client_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->client_realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->client_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_TRANSITED_ENCODING(enc, 0, &(val)->transited))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->authtime))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->endtime))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000008, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000009, &nLenOff0))
	    return 0;
	if (!ASN1Enc_PKERB_HOST_ADDRESSES(enc, 0, &(val)->client_addresses))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x8000000a, &nLenOff0))
	    return 0;
	if (!ASN1Enc_PKERB_AUTHORIZATION_DATA(enc, 0, &(val)->authorization_data))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TICKET(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TICKET *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000003, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->flags))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->key))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->client_realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->client_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_TRANSITED_ENCODING(dd0, 0, &(val)->transited))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->authtime))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000006) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->endtime))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000008) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000008, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000009) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000009, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_PKERB_HOST_ADDRESSES(dd0, 0, &(val)->client_addresses))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000a) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x8000000a, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_PKERB_AUTHORIZATION_DATA(dd0, 0, &(val)->authorization_data))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TICKET(KERB_ENCRYPTED_TICKET *val)
{
    if (val) {
	ASN1bitstring_free(&(val)->flags);
	ASN1Free_KERB_ENCRYPTION_KEY(&(val)->key);
	ASN1ztcharstring_free((val)->client_realm);
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->client_name);
	ASN1Free_KERB_TRANSITED_ENCODING(&(val)->transited);
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_PKERB_HOST_ADDRESSES(&(val)->client_addresses);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_PKERB_AUTHORIZATION_DATA(&(val)->authorization_data);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_AUTHENTICATOR(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AUTHENTICATOR *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000002, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->authenticator_version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    t = lstrlenA((val)->client_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->client_realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->client_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_CHECKSUM(enc, 0, &(val)->checksum))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->client_usec))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->client_time))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->subkey))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
	    return 0;
	if (!ASN1BEREncSX(enc, 0x2, &(val)->sequence_number))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000008, &nLenOff0))
	    return 0;
	if (!ASN1Enc_PKERB_AUTHORIZATION_DATA(enc, 0, &(val)->authorization_data))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AUTHENTICATOR(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AUTHENTICATOR *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000002, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->authenticator_version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->client_realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->client_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_CHECKSUM(dd0, 0, &(val)->checksum))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->client_usec))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->client_time))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000006) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->subkey))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000007) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecSXVal(dd0, 0x2, &(val)->sequence_number))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000008) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000008, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_PKERB_AUTHORIZATION_DATA(dd0, 0, &(val)->authorization_data))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AUTHENTICATOR(KERB_AUTHENTICATOR *val)
{
    if (val) {
	ASN1ztcharstring_free((val)->client_realm);
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->client_name);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_CHECKSUM(&(val)->checksum);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_KERB_ENCRYPTION_KEY(&(val)->subkey);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1intx_free(&(val)->sequence_number);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_PKERB_AUTHORIZATION_DATA(&(val)->authorization_data);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REQUEST_BODY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->kdc_options).length, ((val)->kdc_options).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->client_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    t = lstrlenA((val)->realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->server_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->endtime))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_KDC_REQUEST_BODY_encryption_type(enc, 0, &(val)->encryption_type))
	return 0;
    if ((val)->o[0] & 0x8) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000009, &nLenOff0))
	    return 0;
	if (!ASN1Enc_PKERB_HOST_ADDRESSES(enc, 0, &(val)->addresses))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1BEREncExplicitTag(enc, 0x8000000a, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->enc_authorization_data))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1Enc_KERB_KDC_REQUEST_BODY_additional_tickets(enc, 0, &(val)->additional_tickets))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REQUEST_BODY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->kdc_options))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->client_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->server_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->endtime))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000006) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1Dec_KERB_KDC_REQUEST_BODY_encryption_type(dd, 0, &(val)->encryption_type))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000009) {
	(val)->o[0] |= 0x8;
	if (!ASN1BERDecExplicitTag(dd, 0x80000009, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_PKERB_HOST_ADDRESSES(dd0, 0, &(val)->addresses))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000a) {
	(val)->o[0] |= 0x4;
	if (!ASN1BERDecExplicitTag(dd, 0x8000000a, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->enc_authorization_data))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000b) {
	(val)->o[0] |= 0x2;
	if (!ASN1Dec_KERB_KDC_REQUEST_BODY_additional_tickets(dd, 0, &(val)->additional_tickets))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY(KERB_KDC_REQUEST_BODY *val)
{
    if (val) {
	ASN1bitstring_free(&(val)->kdc_options);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->client_name);
	}
	ASN1ztcharstring_free((val)->realm);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->server_name);
	}
	if ((val)->o[0] & 0x20) {
	}
	if ((val)->o[0] & 0x10) {
	}
	ASN1Free_KERB_KDC_REQUEST_BODY_encryption_type(&(val)->encryption_type);
	if ((val)->o[0] & 0x8) {
	    ASN1Free_PKERB_HOST_ADDRESSES(&(val)->addresses);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1Free_KERB_ENCRYPTED_DATA(&(val)->enc_authorization_data);
	}
	if ((val)->o[0] & 0x2) {
	    ASN1Free_KERB_KDC_REQUEST_BODY_additional_tickets(&(val)->additional_tickets);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REPLY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_KERB_KDC_REPLY_preauth_data(enc, 0, &(val)->preauth_data))
	    return 0;
    }
    t = lstrlenA((val)->client_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->client_realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->client_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_TICKET(enc, 0, &(val)->ticket))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REPLY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_KERB_KDC_REPLY_preauth_data(dd, 0, &(val)->preauth_data))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->client_realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->client_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_TICKET(dd0, 0, &(val)->ticket))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REPLY(KERB_KDC_REPLY *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_KDC_REPLY_preauth_data(&(val)->preauth_data);
	}
	ASN1ztcharstring_free((val)->client_realm);
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->client_name);
	ASN1Free_KERB_TICKET(&(val)->ticket);
	ASN1Free_KERB_ENCRYPTED_DATA(&(val)->encrypted_part);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_KDC_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_KDC_REPLY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->session_key))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1Enc_PKERB_LAST_REQUEST(enc, 0, &(val)->last_request))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->nonce))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->key_expiration))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->flags).length, ((val)->flags).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->authtime))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->endtime))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000008, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    t = lstrlenA((val)->server_realm);
    if (!ASN1BEREncExplicitTag(enc, 0x80000009, &nLenOff0))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->server_realm))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x8000000a, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->server_name))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x8000000b, &nLenOff0))
	    return 0;
	if (!ASN1Enc_PKERB_HOST_ADDRESSES(enc, 0, &(val)->client_addresses))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(enc, 0, &(val)->encrypted_pa_data))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_KDC_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_KDC_REPLY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->session_key))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1Dec_PKERB_LAST_REQUEST(dd0, 0, &(val)->last_request))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->nonce))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->key_expiration))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->flags))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->authtime))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000006) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->endtime))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000008) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000008, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000009, &dd0, &di0))
	return 0;
    if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->server_realm))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x8000000a, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->server_name))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000b) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x8000000b, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_PKERB_HOST_ADDRESSES(dd0, 0, &(val)->client_addresses))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000c) {
	(val)->o[0] |= 0x8;
	if (!ASN1Dec_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(dd, 0, &(val)->encrypted_pa_data))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_KDC_REPLY(KERB_ENCRYPTED_KDC_REPLY *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTION_KEY(&(val)->session_key);
	ASN1Free_PKERB_LAST_REQUEST(&(val)->last_request);
	if ((val)->o[0] & 0x80) {
	}
	ASN1bitstring_free(&(val)->flags);
	if ((val)->o[0] & 0x40) {
	}
	if ((val)->o[0] & 0x20) {
	}
	ASN1ztcharstring_free((val)->server_realm);
	ASN1Free_KERB_PRINCIPAL_NAME(&(val)->server_name);
	if ((val)->o[0] & 0x10) {
	    ASN1Free_PKERB_HOST_ADDRESSES(&(val)->client_addresses);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_KERB_ENCRYPTED_KDC_REPLY_encrypted_pa_data(&(val)->encrypted_pa_data);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_AP_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AP_REQUEST *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000e, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->ap_options).length, ((val)->ap_options).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_TICKET(enc, 0, &(val)->ticket))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->authenticator))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AP_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AP_REQUEST *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000e, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecBitString(dd0, 0x3, &(val)->ap_options))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_TICKET(dd0, 0, &(val)->ticket))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->authenticator))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AP_REQUEST(KERB_AP_REQUEST *val)
{
    if (val) {
	ASN1bitstring_free(&(val)->ap_options);
	ASN1Free_KERB_TICKET(&(val)->ticket);
	ASN1Free_KERB_ENCRYPTED_DATA(&(val)->authenticator);
    }
}

static int ASN1CALL ASN1Enc_KERB_AP_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AP_REPLY *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000f, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AP_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AP_REPLY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000f, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AP_REPLY(KERB_AP_REPLY *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTED_DATA(&(val)->encrypted_part);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_AP_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_AP_REPLY *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000001b, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->client_time))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->client_usec))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->subkey))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1BEREncU32(enc, 0x2, (val)->sequence_number))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_AP_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_AP_REPLY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000001b, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->client_time))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->client_usec))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->subkey))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecU32Val(dd0, 0x2, (ASN1uint32_t *) &(val)->sequence_number))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_AP_REPLY(KERB_ENCRYPTED_AP_REPLY *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_ENCRYPTION_KEY(&(val)->subkey);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_SAFE_MESSAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SAFE_MESSAGE *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000014, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_SAFE_BODY(enc, 0, &(val)->safe_body))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_CHECKSUM(enc, 0, &(val)->checksum))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SAFE_MESSAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SAFE_MESSAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000014, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_SAFE_BODY(dd0, 0, &(val)->safe_body))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_CHECKSUM(dd0, 0, &(val)->checksum))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SAFE_MESSAGE(KERB_SAFE_MESSAGE *val)
{
    if (val) {
	ASN1Free_KERB_SAFE_BODY(&(val)->safe_body);
	ASN1Free_KERB_CHECKSUM(&(val)->checksum);
    }
}

static int ASN1CALL ASN1Enc_KERB_PRIV_MESSAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PRIV_MESSAGE *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000015, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PRIV_MESSAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PRIV_MESSAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000015, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PRIV_MESSAGE(KERB_PRIV_MESSAGE *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTED_DATA(&(val)->encrypted_part);
    }
}

static int ASN1CALL ASN1Enc_KERB_CRED(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CRED *val)
{
    ASN1uint32_t nExplTagLenOff0;
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000016, &nExplTagLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_CRED_tickets(enc, 0, &(val)->tickets))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nExplTagLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CRED(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CRED *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t pExplTagDec0;
    ASN1octet_t *pbExplTagDataEnd0;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000016, &pExplTagDec0, &pbExplTagDataEnd0))
	return 0;
    if (!ASN1BERDecExplicitTag(pExplTagDec0, 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1Dec_KERB_CRED_tickets(dd, 0, &(val)->tickets))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->encrypted_part))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(pExplTagDec0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, pExplTagDec0, pbExplTagDataEnd0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CRED(KERB_CRED *val)
{
    if (val) {
	ASN1Free_KERB_CRED_tickets(&(val)->tickets);
	ASN1Free_KERB_ENCRYPTED_DATA(&(val)->encrypted_part);
    }
}

static int ASN1CALL ASN1Enc_KERB_CRED_INFO(ASN1encoding_t enc, ASN1uint32_t tag, KERB_CRED_INFO *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTION_KEY(enc, 0, &(val)->key))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	t = lstrlenA((val)->principal_realm);
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->principal_realm))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->principal_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1DEREncBitString(enc, 0x3, ((val)->flags).length, ((val)->flags).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->authtime))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000005, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000006, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->endtime))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000007, &nLenOff0))
	    return 0;
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x1) {
	t = lstrlenA((val)->service_realm);
	if (!ASN1BEREncExplicitTag(enc, 0x80000008, &nLenOff0))
	    return 0;
	if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->service_realm))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[1] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000009, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_PRINCIPAL_NAME(enc, 0, &(val)->service_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[1] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x8000000a, &nLenOff0))
	    return 0;
	if (!ASN1Enc_PKERB_HOST_ADDRESSES(enc, 0, &(val)->client_addresses))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CRED_INFO(ASN1decoding_t dec, ASN1uint32_t tag, KERB_CRED_INFO *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 2);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTION_KEY(dd0, 0, &(val)->key))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->principal_realm))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->principal_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecBitString(dd0, 0x3, &(val)->flags))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->authtime))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000005) {
	(val)->o[0] |= 0x8;
	if (!ASN1BERDecExplicitTag(dd, 0x80000005, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->starttime))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000006) {
	(val)->o[0] |= 0x4;
	if (!ASN1BERDecExplicitTag(dd, 0x80000006, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->endtime))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000007) {
	(val)->o[0] |= 0x2;
	if (!ASN1BERDecExplicitTag(dd, 0x80000007, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecGeneralizedTime(dd0, 0x18, &(val)->renew_until))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000008) {
	(val)->o[0] |= 0x1;
	if (!ASN1BERDecExplicitTag(dd, 0x80000008, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->service_realm))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000009) {
	(val)->o[1] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000009, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_PRINCIPAL_NAME(dd0, 0, &(val)->service_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x8000000a) {
	(val)->o[1] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x8000000a, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_PKERB_HOST_ADDRESSES(dd0, 0, &(val)->client_addresses))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CRED_INFO(KERB_CRED_INFO *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTION_KEY(&(val)->key);
	if ((val)->o[0] & 0x80) {
	    ASN1ztcharstring_free((val)->principal_realm);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->principal_name);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1bitstring_free(&(val)->flags);
	}
	if ((val)->o[0] & 0x10) {
	}
	if ((val)->o[0] & 0x8) {
	}
	if ((val)->o[0] & 0x4) {
	}
	if ((val)->o[0] & 0x2) {
	}
	if ((val)->o[0] & 0x1) {
	    ASN1ztcharstring_free((val)->service_realm);
	}
	if ((val)->o[1] & 0x80) {
	    ASN1Free_KERB_PRINCIPAL_NAME(&(val)->service_name);
	}
	if ((val)->o[1] & 0x40) {
	    ASN1Free_PKERB_HOST_ADDRESSES(&(val)->client_addresses);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_TGT_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGT_REPLY *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_TICKET(enc, 0, &(val)->ticket))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TGT_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGT_REPLY *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_TICKET(dd0, 0, &(val)->ticket))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TGT_REPLY(KERB_TGT_REPLY *val)
{
    if (val) {
	ASN1Free_KERB_TICKET(&(val)->ticket);
    }
}

static int ASN1CALL ASN1Enc_KERB_SIGNED_REPLY_KEY_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_REPLY_KEY_PACKAGE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_REPLY_KEY_PACKAGE2(enc, 0, &(val)->reply_key_package))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_SIGNATURE(enc, 0, &(val)->reply_key_signature))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SIGNED_REPLY_KEY_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_REPLY_KEY_PACKAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_REPLY_KEY_PACKAGE2(dd0, 0, &(val)->reply_key_package))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_SIGNATURE(dd0, 0, &(val)->reply_key_signature))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SIGNED_REPLY_KEY_PACKAGE(KERB_SIGNED_REPLY_KEY_PACKAGE *val)
{
    if (val) {
	ASN1Free_KERB_REPLY_KEY_PACKAGE2(&(val)->reply_key_package);
	ASN1Free_KERB_SIGNATURE(&(val)->reply_key_signature);
    }
}

static int ASN1CALL ASN1Enc_KERB_SIGNED_KDC_PUBLIC_VALUE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_KDC_PUBLIC_VALUE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_SUBJECT_PUBLIC_KEY_INFO(enc, 0, &(val)->kdc_public_value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_SIGNATURE(enc, 0, &(val)->kdc_public_value_sig))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SIGNED_KDC_PUBLIC_VALUE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_KDC_PUBLIC_VALUE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_SUBJECT_PUBLIC_KEY_INFO(dd0, 0, &(val)->kdc_public_value))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_SIGNATURE(dd0, 0, &(val)->kdc_public_value_sig))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SIGNED_KDC_PUBLIC_VALUE(KERB_SIGNED_KDC_PUBLIC_VALUE *val)
{
    if (val) {
	ASN1Free_KERB_SUBJECT_PUBLIC_KEY_INFO(&(val)->kdc_public_value);
	ASN1Free_KERB_SIGNATURE(&(val)->kdc_public_value_sig);
    }
}

static int ASN1CALL ASN1Enc_KERB_TRUSTED_CAS(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TRUSTED_CAS *val)
{
    ASN1uint32_t nLenOff0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_KERBEROS_NAME(enc, 0, &(val)->u.principal_name))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
	break;
    case 2:
	if (!ASN1DEREncOctetString(enc, 0x80000001, ((val)->u.ca_name).length, ((val)->u.ca_name).value))
	    return 0;
	break;
    case 3:
	if (!ASN1DEREncOctetString(enc, 0x80000002, ((val)->u.issuer_and_serial).length, ((val)->u.issuer_and_serial).value))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TRUSTED_CAS(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TRUSTED_CAS *val)
{
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x80000000:
	(val)->choice = 1;
	if (!ASN1BERDecExplicitTag(dec, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_KERBEROS_NAME(dd0, 0, &(val)->u.principal_name))
	    return 0;
	if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	    return 0;
	break;
    case 0x80000001:
	(val)->choice = 2;
	if (!ASN1BERDecOctetString(dec, 0x80000001, &(val)->u.ca_name))
	    return 0;
	break;
    case 0x80000002:
	(val)->choice = 3;
	if (!ASN1BERDecOctetString(dec, 0x80000002, &(val)->u.issuer_and_serial))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TRUSTED_CAS(KERB_TRUSTED_CAS *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_KERB_KERBEROS_NAME(&(val)->u.principal_name);
	    break;
	case 2:
	    ASN1octetstring_free(&(val)->u.ca_name);
	    break;
	case 3:
	    ASN1octetstring_free(&(val)->u.issuer_and_serial);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_AUTH_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AUTH_PACKAGE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_PK_AUTHENTICATOR(enc, 0, &(val)->pk_authenticator))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_SUBJECT_PUBLIC_KEY_INFO(enc, 0, &(val)->client_public_value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AUTH_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AUTH_PACKAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_PK_AUTHENTICATOR(dd0, 0, &(val)->pk_authenticator))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_SUBJECT_PUBLIC_KEY_INFO(dd0, 0, &(val)->client_public_value))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AUTH_PACKAGE(KERB_AUTH_PACKAGE *val)
{
    if (val) {
	ASN1Free_KERB_PK_AUTHENTICATOR(&(val)->pk_authenticator);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_SUBJECT_PUBLIC_KEY_INFO(&(val)->client_public_value);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_COMPOUND_IDENTITY(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_COMPOUND_IDENTITY *val)
{
    PKERB_PA_COMPOUND_IDENTITY f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_TICKET(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_COMPOUND_IDENTITY(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_COMPOUND_IDENTITY *val)
{
    PKERB_PA_COMPOUND_IDENTITY *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_PA_COMPOUND_IDENTITY)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_TICKET(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_COMPOUND_IDENTITY(PKERB_PA_COMPOUND_IDENTITY *val)
{
    PKERB_PA_COMPOUND_IDENTITY f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_TICKET(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ_trusted_certifiers(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ_trusted_certifiers *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_PA_PK_AS_REQ_trusted_certifiers f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_TRUSTED_CAS(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ_trusted_certifiers(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_PA_PK_AS_REQ_trusted_certifiers *val)
{
    PKERB_PA_PK_AS_REQ_trusted_certifiers *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_PA_PK_AS_REQ_trusted_certifiers)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_TRUSTED_CAS(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ_trusted_certifiers(PKERB_PA_PK_AS_REQ_trusted_certifiers *val)
{
    PKERB_PA_PK_AS_REQ_trusted_certifiers f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_TRUSTED_CAS(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_CRED_ticket_info(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_ENCRYPTED_CRED_ticket_info *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_ENCRYPTED_CRED_ticket_info f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_CRED_INFO(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_CRED_ticket_info(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_ENCRYPTED_CRED_ticket_info *val)
{
    PKERB_ENCRYPTED_CRED_ticket_info *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_ENCRYPTED_CRED_ticket_info)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_CRED_INFO(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_CRED_ticket_info(PKERB_ENCRYPTED_CRED_ticket_info *val)
{
    PKERB_ENCRYPTED_CRED_ticket_info f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_CRED_INFO(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_CRED_tickets(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_CRED_tickets *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_CRED_tickets f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_TICKET(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_CRED_tickets(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_CRED_tickets *val)
{
    PKERB_CRED_tickets *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_CRED_tickets)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_TICKET(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_CRED_tickets(PKERB_CRED_tickets *val)
{
    PKERB_CRED_tickets f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_TICKET(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST_BODY_additional_tickets(ASN1encoding_t enc, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_additional_tickets *val)
{
    ASN1uint32_t nLenOff0;
    PKERB_KDC_REQUEST_BODY_additional_tickets f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x8000000b, &nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1Enc_KERB_TICKET(enc, 0, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST_BODY_additional_tickets(ASN1decoding_t dec, ASN1uint32_t tag, PKERB_KDC_REQUEST_BODY_additional_tickets *val)
{
    PKERB_KDC_REQUEST_BODY_additional_tickets *f;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x8000000b, &dd0, &di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd0, 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PKERB_KDC_REQUEST_BODY_additional_tickets)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1Dec_KERB_TICKET(dd, 0, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dd0, dd, di))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REQUEST_BODY_additional_tickets(PKERB_KDC_REQUEST_BODY_additional_tickets *val)
{
    PKERB_KDC_REQUEST_BODY_additional_tickets f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1Free_KERB_TICKET(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_KDC_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_KDC_REQUEST *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->message_type))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_KERB_KDC_REQUEST_preauth_data(enc, 0, &(val)->preauth_data))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_KDC_REQUEST_BODY(enc, 0, &(val)->request_body))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_KDC_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_KDC_REQUEST *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->message_type))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_KERB_KDC_REQUEST_preauth_data(dd, 0, &(val)->preauth_data))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_KDC_REQUEST_BODY(dd0, 0, &(val)->request_body))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_KDC_REQUEST(KERB_KDC_REQUEST *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_KDC_REQUEST_preauth_data(&(val)->preauth_data);
	}
	ASN1Free_KERB_KDC_REQUEST_BODY(&(val)->request_body);
    }
}

static int ASN1CALL ASN1Enc_KERB_MARSHALLED_REQUEST_BODY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_MARSHALLED_REQUEST_BODY *val)
{
    if (!ASN1Enc_KERB_KDC_REQUEST_BODY(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_MARSHALLED_REQUEST_BODY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_MARSHALLED_REQUEST_BODY *val)
{
    if (!ASN1Dec_KERB_KDC_REQUEST_BODY(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_MARSHALLED_REQUEST_BODY(KERB_MARSHALLED_REQUEST_BODY *val)
{
    if (val) {
	ASN1Free_KERB_KDC_REQUEST_BODY(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_AS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AS_REPLY *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000b, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_KDC_REPLY(enc, 0, val))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AS_REPLY *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000b, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_KDC_REPLY(dd0, 0, val))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AS_REPLY(KERB_AS_REPLY *val)
{
    if (val) {
	ASN1Free_KERB_KDC_REPLY(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_TGS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGS_REPLY *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000d, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_KDC_REPLY(enc, 0, val))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TGS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGS_REPLY *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000d, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_KDC_REPLY(dd0, 0, val))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TGS_REPLY(KERB_TGS_REPLY *val)
{
    if (val) {
	ASN1Free_KERB_KDC_REPLY(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_AS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_AS_REPLY *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000019, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_KDC_REPLY(enc, 0, val))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_AS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_AS_REPLY *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000019, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_KDC_REPLY(dd0, 0, val))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_AS_REPLY(KERB_ENCRYPTED_AS_REPLY *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTED_KDC_REPLY(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_ENCRYPTED_TGS_REPLY(ASN1encoding_t enc, ASN1uint32_t tag, KERB_ENCRYPTED_TGS_REPLY *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000001a, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENCRYPTED_KDC_REPLY(enc, 0, val))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_ENCRYPTED_TGS_REPLY(ASN1decoding_t dec, ASN1uint32_t tag, KERB_ENCRYPTED_TGS_REPLY *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000001a, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENCRYPTED_KDC_REPLY(dd0, 0, val))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_ENCRYPTED_TGS_REPLY(KERB_ENCRYPTED_TGS_REPLY *val)
{
    if (val) {
	ASN1Free_KERB_ENCRYPTED_KDC_REPLY(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REP2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REP2 *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_ENCRYPTED_DATA(enc, 0, &(val)->key_package))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_ENVELOPED_KEY_PACKAGE(enc, 0, &(val)->temp_key_package))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1Enc_KERB_SIGNED_KDC_PUBLIC_VALUE(enc, 0, &(val)->signed_kdc_public_value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_KERB_PA_PK_AS_REP2_kdc_cert(enc, 0, &(val)->kdc_cert))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REP2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REP2 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_ENCRYPTED_DATA(dd0, 0, &(val)->key_package))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_ENVELOPED_KEY_PACKAGE(dd0, 0, &(val)->temp_key_package))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_KERB_SIGNED_KDC_PUBLIC_VALUE(dd0, 0, &(val)->signed_kdc_public_value))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x20;
	if (!ASN1Dec_KERB_PA_PK_AS_REP2_kdc_cert(dd, 0, &(val)->kdc_cert))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REP2(KERB_PA_PK_AS_REP2 *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_ENCRYPTED_DATA(&(val)->key_package);
	}
	ASN1Free_KERB_ENVELOPED_KEY_PACKAGE(&(val)->temp_key_package);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_KERB_SIGNED_KDC_PUBLIC_VALUE(&(val)->signed_kdc_public_value);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_KERB_PA_PK_AS_REP2_kdc_cert(&(val)->kdc_cert);
	}
    }
}

static int ASN1CALL ASN1Enc_KERB_SIGNED_AUTH_PACKAGE(ASN1encoding_t enc, ASN1uint32_t tag, KERB_SIGNED_AUTH_PACKAGE *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_AUTH_PACKAGE(enc, 0, &(val)->auth_package))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_SIGNATURE(enc, 0, &(val)->auth_package_signature))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_SIGNED_AUTH_PACKAGE(ASN1decoding_t dec, ASN1uint32_t tag, KERB_SIGNED_AUTH_PACKAGE *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_AUTH_PACKAGE(dd0, 0, &(val)->auth_package))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_SIGNATURE(dd0, 0, &(val)->auth_package_signature))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_SIGNED_AUTH_PACKAGE(KERB_SIGNED_AUTH_PACKAGE *val)
{
    if (val) {
	ASN1Free_KERB_AUTH_PACKAGE(&(val)->auth_package);
	ASN1Free_KERB_SIGNATURE(&(val)->auth_package_signature);
    }
}

static int ASN1CALL ASN1Enc_KERB_AS_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_AS_REQUEST *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000a, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_KDC_REQUEST(enc, 0, val))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_AS_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_AS_REQUEST *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000a, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_KDC_REQUEST(dd0, 0, val))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_AS_REQUEST(KERB_AS_REQUEST *val)
{
    if (val) {
	ASN1Free_KERB_KDC_REQUEST(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_TGS_REQUEST(ASN1encoding_t enc, ASN1uint32_t tag, KERB_TGS_REQUEST *val)
{
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x4000000c, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_KDC_REQUEST(enc, 0, val))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_TGS_REQUEST(ASN1decoding_t dec, ASN1uint32_t tag, KERB_TGS_REQUEST *val)
{
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x4000000c, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_KDC_REQUEST(dd0, 0, val))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_TGS_REQUEST(KERB_TGS_REQUEST *val)
{
    if (val) {
	ASN1Free_KERB_KDC_REQUEST(val);
    }
}

static int ASN1CALL ASN1Enc_KERB_PA_PK_AS_REQ2(ASN1encoding_t enc, ASN1uint32_t tag, KERB_PA_PK_AS_REQ2 *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_KERB_SIGNED_AUTH_PACKAGE(enc, 0, &(val)->signed_auth_pack))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_KERB_PA_PK_AS_REQ2_user_certs(enc, 0, &(val)->user_certs))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_KERB_PA_PK_AS_REQ2_trusted_certifiers(enc, 0, &(val)->trusted_certifiers))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->serial_number))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KERB_PA_PK_AS_REQ2(ASN1decoding_t dec, ASN1uint32_t tag, KERB_PA_PK_AS_REQ2 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_KERB_SIGNED_AUTH_PACKAGE(dd0, 0, &(val)->signed_auth_pack))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_KERB_PA_PK_AS_REQ2_user_certs(dd, 0, &(val)->user_certs))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_KERB_PA_PK_AS_REQ2_trusted_certifiers(dd, 0, &(val)->trusted_certifiers))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->serial_number))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KERB_PA_PK_AS_REQ2(KERB_PA_PK_AS_REQ2 *val)
{
    if (val) {
	ASN1Free_KERB_SIGNED_AUTH_PACKAGE(&(val)->signed_auth_pack);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_KERB_PA_PK_AS_REQ2_user_certs(&(val)->user_certs);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_KERB_PA_PK_AS_REQ2_trusted_certifiers(&(val)->trusted_certifiers);
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\auth\xauthtest.cpp ===
// ---------------------------------------------------------------------------------------
// conline.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#if DBG
#define XNET_FEATURE_TRACE 1
#endif

#include <xapip.h>
#include <xtl.h>
//#include <windows.h>
//#include <xbox.h>
//#include <winsockx.h>
//#include <winsockp.h>
#include <xonlinep.h>
#include <stdlib.h>
#include <stdio.h>
#include <xn.h>
#include <OnlineAccounts.h>

#define Verify(x) do { if (!(x)) DbgBreak(); } while (0)

#ifdef _XBOX
int __cdecl main(int argc, char * argv[])
#else
class CTestXOnline : public COnlineAccounts
{
private:
    CTestXOnline(char * pszXbox = NULL) : COnlineAccounts(pszXbox) {}

	static CTestXOnline* m_pInstance;

public:
    int Main(int argc, char * argv[]);

	static CTestXOnline* Instance( LPSTR szName = NULL ) {
		if ( NULL == m_pInstance )
		{
			m_pInstance = new CTestXOnline( szName );
			ASSERT( m_pInstance );
		}

		return m_pInstance;
	}

	~CTestXOnline( void ) { delete m_pInstance; }
		
};

CTestXOnline* CTestXOnline::m_pInstance = NULL;

int __cdecl main(int argc, char * argv[])
{
    int result = 0;
    char buffer[128];

    sprintf(buffer, "%s@Nic/0", getenv("COMPUTERNAME") );
    //CTestXOnline * pTestXOnline = new CTestXOnline(buffer);
    //pTestXOnline->Main(argc, argv);
	CTestXOnline::Instance(buffer)->Main( argc, argv );
    //delete pTestXOnline;
    return(result);
}

int CTestXOnline::Main(int argc, char * argv[])
#endif
{
    HANDLE hEventWorkAvailable;
    HRESULT hr, hrTask = XONLINETASK_S_SUCCESS;
    HRESULT hrLogon;
    DWORD i,j;
    XONLINE_USER users[XONLINE_MAX_STORED_ONLINE_USERS];
    DWORD cUsers;
	XONLINETASK_HANDLE hTask;
    XONLINETASK_HANDLE  hGetTagsTask;
    LPWSTR rgszTags = NULL;
    WORD  wTagCount = 0;
    DWORD aServices[] = {
        XONLINE_BILLING_OFFERING_SERVICE,
        XONLINE_USER_ACCOUNT_SERVICE,
        XONLINE_AUTO_UPDATE_SERVICE,
        XONLINE_MATCHMAKING_SERVICE,
        };
    DWORD dwDestTickCount;
    
#ifdef XNET_FEATURE_TRACE
    Tag(Verbose) = TAG_ENABLE;
    Tag(Warning) = TAG_ENABLE;

    //ExternTag(ScratchMemoryVerbose);
    //ExternTag(ScratchMemoryAlloc);
    
    //Tag(ScratchMemoryVerbose) = TAG_ENABLE;
    //Tag(ScratchMemoryAlloc) = TAG_ENABLE;
#endif

    //
    // Initialize core peripheral port support
    //
    XInitDevices(0,NULL);

    //
    // Sleep a while to make sure the USB is ready
    //
    Sleep (1000);

    printf("Testing CTestXOnline");

    hr = XOnlineStartup(NULL);
    Verify(hr == S_OK);

	hEventWorkAvailable = CreateEvent(NULL, FALSE, FALSE, NULL);
	Verify(hEventWorkAvailable != NULL);

    RtlZeroMemory( users, sizeof(users) );

#if 0
	hr = COnlineAccounts::Instance()->PopulateUserAccountsHD( NULL, 4 );
	Verify( hr == S_OK );
#endif

    hr = XOnlineGetUsers( &users[0], &cUsers );
    Verify(hr == S_OK);

    hr = XOnlineLogon(users, aServices, sizeof(aServices)/sizeof(DWORD), hEventWorkAvailable, &hTask);
    Verify(hr == S_OK);

    //
	// Pump until logon task completes
	//
	do
	{
	    Sleep(10);
	    
	    WaitForSingleObject(hEventWorkAvailable, INFINITE);

        ResetEvent( hEventWorkAvailable );
        
		hr = XOnlineTaskContinue(hTask);

	} while (hr == XONLINETASK_S_RUNNING);

    hrTask = hr;

    hr = XOnlineTaskClose(hTask);
    Verify(hr == S_OK);

    hr = XOnlineCleanup();
    Verify(hr == S_OK);

    if (FAILED(hrTask))
        printf(" [FAILED %08lX]\n", hrTask);
    else
        printf(" [OK]\n");

    hr = XOnlineStartup(NULL);
    Verify(hr == S_OK);

    hr = XOnlineCleanup();
    Verify(hr == S_OK);

    hr = XOnlineStartup(NULL);
    Verify(hr == S_OK);

    hr = XOnlineCleanup();
    Verify(hr == S_OK);

    hr = XOnlineStartup(NULL);
    Verify(hr == S_OK);

    hr = XOnlineGetUsers( &users[0], &cUsers );
    Verify(hr == S_OK);

    hr = XOnlineCleanup();
    Verify(hr == S_OK);

    for (j=0; j<5; ++j)
    {
        hr = XOnlineStartup(NULL);
        Verify(hr == S_OK);

        hr = XOnlineGetUsers( &users[0], &cUsers );
        Verify(hr == S_OK);

        for (i=0; i<cUsers; ++i)
        {
            TraceSz2( Verbose, "XOnlineGetUsers returned user %s with options 0x%08X", users[i].name, users[i].dwUserOptions);
        }
        
#if 0
#if 0
        users[1].xuid.qwUserID = 0;
        RtlCopyMemory( &users[3], &users[0], sizeof(XONLINE_USER) );
        SetAsGuestNumber(users[3].xuid.dwUserFlags, 1);
#else
        RtlZeroMemory( users, sizeof(users) );
#endif
#endif
        RtlZeroMemory( users, sizeof(users[0]) * j );

        hr = XOnlineLogon( &users[0], aServices, sizeof(aServices)/sizeof(DWORD), hEventWorkAvailable, &hTask );
        Verify(hr == S_OK);

        do
        {
            WaitForSingleObject(hEventWorkAvailable, INFINITE);

            hr = XOnlineTaskContinue(hTask);

        } while (hr == XONLINETASK_S_RUNNING);

        hrLogon = XOnlineLogonTaskGetResults( hTask );

        Verify(SUCCEEDED(hrLogon));

		hr = _XOnlineGetTags(103, 5, NULL, hEventWorkAvailable, &hGetTagsTask);

        Verify(SUCCEEDED(hr));

        do
        {
            WaitForSingleObject(hEventWorkAvailable, INFINITE);

            hr = XOnlineTaskContinue(hTask);

            Verify(SUCCEEDED(hr));

            hr = XOnlineTaskContinue(hGetTagsTask);
        
            Verify(SUCCEEDED(hr));

        } while (hr == XONLINETASK_S_RUNNING);

        if (SUCCEEDED(hr))
        {
            hr = _XOnlineGetTagsResults(hGetTagsTask, &rgszTags, &wTagCount);
            Verify(SUCCEEDED(hr));

            for (int i = 0; i < wTagCount; i++)
            {
                TraceSz2( Verbose, "_XOnlineGetTagsResults returned name %d: %ls", i, rgszTags + i*XONLINE_KINGDOM_SIZE);
            }
        }

        hr = XOnlineTaskClose(hGetTagsTask);
        Verify(hr == S_OK);    

        hr = XOnlineTaskClose( hTask );
        Verify(hr == S_OK);    

        hr = XOnlineCleanup();
        Verify(hr == S_OK);
    }

    #if 0
    hr = XOnlineStartup(NULL);
    Verify(hr == S_OK);

    RtlZeroMemory( users, sizeof(users) );

    hr = XOnlineLogon( &users[0], aServices, sizeof(aServices)/sizeof(DWORD), hEventWorkAvailable, &hTask );
    Verify(hr == S_OK);

    do
    {
        WaitForSingleObject(hEventWorkAvailable, INFINITE);

        hr = XOnlineTaskContinue(hTask);

    } while (hr == XONLINETASK_S_RUNNING);

    dwDestTickCount = GetTickCount()+3000;
    do
    {
        WaitForSingleObject(hEventWorkAvailable, INFINITE);

        XOnlineTaskContinue(hTask);

    } while (GetTickCount() < dwDestTickCount);

    Verify(SUCCEEDED(hr));

    hr = XOnlineLogonTaskGetResults( hTask );
    Verify(SUCCEEDED(hr));

    hr = XOnlineTaskClose( hTask );
    Verify(hr == S_OK);    

    hr = XOnlineGetUsers( &users[0], &cUsers );
    Verify(hr == S_OK);

    for (i=0; i<cUsers; ++i)
    {
        TraceSz2( Verbose, "XOnlineGetUsers returned user %s with options 0x%08X", users[i].name, users[i].dwUserOptions);
    }
    
    hr = XOnlineLogon( &users[0], aServices, sizeof(aServices)/sizeof(DWORD), hEventWorkAvailable, &hTask );
    Verify(hr == S_OK);

    do
    {
        WaitForSingleObject(hEventWorkAvailable, INFINITE);

        hr = XOnlineTaskContinue(hTask);

    } while (hr == XONLINETASK_S_RUNNING);

    dwDestTickCount = GetTickCount()+3000;
    do
    {
        WaitForSingleObject(hEventWorkAvailable, INFINITE);

        XOnlineTaskContinue(hTask);

    } while (GetTickCount() < dwDestTickCount);

    Verify(SUCCEEDED(hr));

    hr = XOnlineLogonTaskGetResults( hTask );
    Verify(SUCCEEDED(hr));

    hr = XOnlineTaskClose( hTask );
    Verify(hr == S_OK);    

    hr = XOnlineCleanup();
    Verify(hr == S_OK);
    #endif
    
    TraceSz( Verbose, "Xbox online auth test passed!");
    
    return 0;
}


HRESULT CheckPIN()
{
    HRESULT hr = E_FAIL;
    DWORD err;
    DWORD i,c;
    DWORD devices;
    XPININPUTHANDLE hPinInputHandle;
    XINPUT_STATE inputState;
    HANDLE hInputDevice;
    BYTE pinByte;
    
    //
    //  Initialize core peripheral port support
    //
    XInitDevices(0,NULL);

    //
    // Get all connected gamepads.
    //
    c = XGetPortCount ();
    devices = XGetDevices (XDEVICE_TYPE_GAMEPAD);
    hInputDevice = 0;
    
    for (i = 0; i < c; i++) {
        if ((1 << i) & devices) {
            //
            // Open the device.
            //
            TraceSz1( Verbose, "Gamepad found on port %u. Opening...", i);
            hInputDevice = XInputOpen(XDEVICE_TYPE_GAMEPAD, XDEVICE_PORT0 + i, XDEVICE_NO_SLOT, NULL);
            if (hInputDevice)
            {
                TraceSz2( Verbose, "Gamepad successfully opened. (%u/%08x)", i, hInputDevice);
                break;
            }
            else
            {
                TraceSz1( Warning, "Gamepad failed opened. (%u)", i );
            }
        }
    }
    if ( hInputDevice == 0 )
    {
        TraceSz( Warning, "Can't find a Gamepad device");
        goto Cleanup;
    }
    
    err = XInputGetState( hInputDevice, &inputState );
    if ( err )
    {
        TraceSz1( Warning, "XInputGetState failed with %X", err);
        goto Cleanup;
    }

    hPinInputHandle = XOnlinePINStartInput( &inputState );
    if ( hPinInputHandle == 0 )
    {
        TraceSz( Warning, "XOnlinePINStartInput failed");
        goto Cleanup;
    }

    //
    // Get 4 key presses
    //
    i = 0;
    while ( i < 4 )
    {
        err = XInputGetState( hInputDevice, &inputState );
        if ( err )
        {
            TraceSz1( Warning, "XInputGetState failed with %X", err);
            goto Cleanup;
        }

        hr = XOnlinePINDecodeInput( hPinInputHandle, &inputState, &pinByte );
        if ( FAILED( hr ) )
        {
            TraceSz1( Warning, "XOnlinePINDecodeInput failed with %X", hr);
            goto Cleanup;
        }
        if ( hr == S_OK )
        {
            TraceSz1( Verbose, "Got PIN byte %d", pinByte );
            ++i;
        }
    }

    XOnlinePINEndInput( hPinInputHandle );
    
    XInputClose( hInputDevice );

    hr = S_OK;

Cleanup:

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\billing\verify\main.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 ****************************************************************************/

#include <xtl.h>
#include <xonlinep.h>
#include <xdbg.h>
#include <stdio.h>
#include "testutil.h"
#include "testui.h"



//
// Define the services needed
//
#define NUM_SERVICES	1
#define NUM_SERVICES	1
DWORD			g_rgServices[NUM_SERVICES] =
{
	{ XONLINE_BILLING_OFFERING_SERVICE }
};


void __cdecl main()
{
    HRESULT              hr                = S_OK;
    DWORD                dwError           = 0;
    HANDLE               hEvent            = NULL;
    WSADATA              WsaData;
    DWORD                dwWorkFlags;
    DWORD i;
    XNADDR xna;
    XONLINETASK_HANDLE   hTask;
    XONLINETASK_HANDLE   hLogon;
    DWORD n;
    XONLINE_USER Users[8];
    DWORD                cUsers = 0;

    XNetStartupParams 	xnsp = { sizeof(XNetStartupParams), 
                            XNET_STARTUP_BYPASS_SECURITY };


	while (true)
    {
    DebugPrint("Loading XBox network stack...\n");
    dwError = XNetStartup(&xnsp);
    if (dwError != NO_ERROR)
    {
        DebugPrint("Failed XNetStartup with %d\n", dwError);
        return;
    }

    DebugPrint( "Starting up XONLINE facilities\n");
    dwError = XOnlineStartup(NULL);
    if(dwError != S_OK)
    {
        DebugPrint("Failed XOnlineStartup with %x\n", dwError);
        return;
    } 


    	// Initialize services
	hr = XOnlineLogonWrapper(g_rgServices, NUM_SERVICES);
	if (FAILED(hr))
	{
            DebugPrint("Cannot Logon (%08x), check c:\\xonline.ini\n", hr);
//        RIP("Failed to initialize services");
        return;
	}


#if 0
    hr = XOnlineGetUsersFromHD( Users, &cUsers );
    if (FAILED(hr))
        __asm int 3;

    hr = XOnlineLogon( Users, g_rgServices, NUM_SERVICES, NULL, &hLogon );
    if (FAILED(hr))
        __asm int 3;
 
    do
    {
        hr = XOnlineTaskContinue(hLogon, GetTickCount()+5000);
        if ( hr != XONLINETASK_S_RUNNING )
        {
            if (hr == XLOGON_S_CONNECTION_ESTABLISHED)
            {
                break;
            }
            else if (hr == XLOGON_E_SERVICE_UNAVAILABLE)
            {
                __asm int 3;
            }
            else if (hr == XLOGON_E_UPDATE_REQUIRED)
            {
                __asm int 3;
            }
            else
            {
                __asm int 3;
            }
        }
    } while (1);
#endif

    __asm int 3;

    
    
    // 
    // now the interesting stuff..
    //
    
    hr = XOnlineOfferingVerifyLicense(0x4, XONLINE_LOGON_ALL, NULL, &hTask);
    if (FAILED(hr))
    {
        __asm int 3;
    }
    
    do
    {
        hr = XOnlineTaskContinue(hTask, GetTickCount() + 2);
    
        if (FAILED(hr))
        {
            __asm int 3;
        }
    } while (hr == XONLINETASK_S_RUNNING);

    
    XOnlineTaskClose(hTask);
    hTask = NULL;
    
    
    WSACleanup();
    XNetCleanup();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\autoupdd\autoupdd.cpp ===
/*++

Copyright (c) Microsoft Corporation

Author:
    Keith Lau (keithlau)

Description:
	Unit test shell for Autoupdate from DVD

Module Name:

    autouppd.cpp

--*/

#include "xonp.h"
#include "testutil.h"
#include "testui.h"

class CXoTest : public CXo
{
public:

    void DisplayStatus(DWORD dwTitleId, XONLINETASK_HANDLE hTask);
    void Test();

};

DWORD					dwPumpCalls = 0;
DWORD					dwIterations = 0;
DWORD					dwCurTitle = 0;

#define MAX_TITLES				4

DWORD	rgdwTitleIds[MAX_TITLES] =
{
	0, 1, 2, 3
};

const WCHAR	wszRebootMsg[] = 
			L"The current title has been successfully updated.\n"
			L"Reboot your Xbox and run this app again, and if\n"
			L"this worked, you will see a message telling you\n"
			L"that Autoreboot worked for TITLE.\n";

WCHAR StatusBuffer[2400];

VOID CXoTest::DisplayStatus(
			DWORD				dwTitleId,
			XONLINETASK_HANDLE	hTask
			)
{
	HRESULT			hr;
	ULARGE_INTEGER	ulin, ulid;
	DWORD			dwPercentDone;

	hr = UpdateFromDVDGetProgress(hTask, &dwPercentDone, &ulin, &ulid);

	BeginNewScene();

	wsprintf(StatusBuffer,
		L"%u pump calls made\r\n"\
		L"%u DVD title Autoupdates performed\r\n"\
		L"Title ID: %u (%08x)\r\n",
		dwPumpCalls, dwIterations, dwTitleId, dwTitleId);
	Xputs(StatusBuffer);

	wsprintf(StatusBuffer, 
			L"  Autoupdate progress %u percent (%I64u / %I64u)\r\n",
			dwPercentDone, ulin, ulid);
	Xputs(StatusBuffer);				

	PresentScene();
}

//
// Implement verification routines to make sure the update happened
// correctly
//
#if 0
HRESULT AutoupdCheckDirsDoWork(
			XONLINETASK_OP		op,
			XONLINETASK_HANDLE	hTask, 
			DWORD				dwMaxExecutionTimeSlice,
			DWORD				*pdwWorkFlags
			)
{
	HRESULT					hr = S_OK;
	PXONLINETASK_DIRCOPY	pdircopy;

	Assert(op == XONLINETASK_DOWORK);
	Assert(hTask != NULL);

	// Locate the containing object
	pdircopy = CONTAINING_RECORD(hTask, XONLINETASK_DIRCOPY, xontaskOnDir);

	// All we do is create the directory
	if (!CreateDirectory(pdircopy->dircrawl.szTarget, NULL))
		hr = HRESULT_FROM_WIN32(GetLastError());

	XONLINETASK_WORKFLAGS_SET_DONT_CONTINUE(pdwWorkFlags);
	return(hr);
}

//
// Simple per-file task handler to do a directory copy
//
HRESULT AutoupdCheckFilesDoWork(
			XONLINETASK_OP		op,
			XONLINETASK_HANDLE	hTask, 
			DWORD				dwMaxExecutionTimeSlice,
			DWORD				*pdwWorkFlags
			)
{
	HRESULT					hr = S_OK;
	PXONLINETASK_DIRCOPY	pdircopy;
	PXONLINETASK_DIRCRAWL	pdircrawl;
	ULARGE_INTEGER			uliSize;
	DWORD					cbSize;
	DWORD					cbTarget;

	Assert(op == XONLINETASK_DOWORK);
	Assert(hTask != NULL);

	// Locate the containing object
	pdircopy = CONTAINING_RECORD(hTask, XONLINETASK_DIRCOPY, xontaskOnFile);
	pdircrawl = &pdircopy->dircrawl;

	// Build the source and target paths for copy, making sure not to overrun
	// the buffers
	pdircrawl = &pdircopy->dircrawl;
	cbSize = strlen(pdircrawl->wfd.cFileName);
	Assert(pdircrawl->szTarget != NULL);
    Assert((pdircrawl->szPath + cbSize) < pdircrawl->cbMax);
    Assert((pdircrawl->szTarget + cbSize) < pdircrawl->cbMax);

	// Build the fill copy paths
	cbSize = pdircrawl->cbPath;
	cbTarget = pdircrawl->cbTarget;
	strcpy(pdircrawl->szPath + cbSize, pdircrawl->wfd.cFileName);
	strcpy(pdircrawl->szTarget + cbTarget, pdircrawl->wfd.cFileName);

	// All we do is create the directory
	if (!CopyFile(pdircrawl->szPath, pdircrawl->szTarget, FALSE))
		hr = HRESULT_FROM_WIN32(GetLastError());
	else
	{
		// Update the statistics
		(pdircopy->dwFilesCopied)++;
		uliSize.u.LowPart = pdircrawl->wfd.nFileSizeLow;
		uliSize.u.HighPart = pdircrawl->wfd.nFileSizeHigh;
		pdircopy->uliBytesCopied.QuadPart += uliSize.QuadPart;
	}

	// Restore the path strings
	pdircrawl->cbPath = cbSize;
	pdircrawl->szPath[cbSize] = '\0';
	pdircrawl->cbTarget = cbTarget;
	pdircrawl->szTarget[cbTarget] = '\0';

	XONLINETASK_WORKFLAGS_SET_DONT_CONTINUE(pdwWorkFlags);
	return(hr);
}

#endif

//======================== The main function
void __cdecl main()
{
    CXoTest XoTest;
    XoTest.Test();
}

void CXoTest::Test()
{
    HRESULT				hr = S_OK;
    HANDLE				hEvent = NULL;
	XONLINETASK_HANDLE	hTask = NULL;
    WCHAR				wszReboot[MAX_PATH];

	hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

	// Initialize graphics stuff
	hr = InitializeGraphics();
	if (FAILED(hr))
	{
        DebugPrint("Cannot initialize graphics (%08x)\n", hr);
        RIP("Failed to initialize graphics");
        return;
	}

	// Initialize text font
	hr = InitializeFont(0xffffffff, 0xff000000, XFONT_OPAQUE);
	if (FAILED(hr))
	{
        DebugPrint("Cannot initialize text (%08x)\n", hr);
        RIP("Failed to initialize text");
        return;
	}

	while (1)
	{
		// Set the title ID
		ChangeCurrentTitleId(rgdwTitleIds[dwCurTitle]);

		// Kick off a title DVD autoupdate ... as simple as that!
		hr = UpdateTitleFromDVD(
					rgdwTitleIds[dwCurTitle], 1, 0, hEvent, &hTask);
		if (FAILED(hr))
		{
			_asm int 3;
		}

		while (1)
		{
			hr = XOnlineTaskContinue(hTask);
			if (XONLINETASK_STATUS_AVAILABLE(hr))
			{
				if (FAILED(hr))
				{
					_asm int 3;
				}

				// Branch out here to tell the user to reboot
				goto PromptReboot;

				// Switch to other title
				dwCurTitle++;
				if (dwCurTitle >= MAX_TITLES)
					dwCurTitle = 0;
				break;
			}
			
			dwPumpCalls++;

			// Display status every x pumps
			DisplayStatus(rgdwTitleIds[dwCurTitle], hTask);
		}

		dwIterations++;
	}


PromptReboot:

	BeginNewScene();

	wcscpy((WCHAR *)wszReboot, (WCHAR *)wszRebootMsg);
	Xputs(wszReboot);

	PresentScene();

	while (1)
		Sleep(1000);

	// Break here
	_asm int 3;

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\billing\xmain.cpp ===
/*++

Copyright (c) Microsoft Corporation

Author:
    Ben Zotto (benzotto), d'apres Keith Lau (keithlau)

Description:
	Dumb Test shell for billing functionality

Module Name:

    xmain.c

--*/

#include <xtl.h>
#include <xonlinep.h>

#include <xdbg.h>
#include <stdio.h>

#include "testutil.h"
#include "testui.h"


//
// Enable this macro if we want to wait for event before pumping
//
//#define WAIT_FOR_EVENT


DWORD					dwPumpCalls = 0;


WCHAR StatusBuffer[2400];


void Initialize()
{
	// do nothing 
}


#define NUM_SERVICES	1
DWORD			g_rgServices[NUM_SERVICES] =
{
	XONLINE_BILLING_OFFERING_SERVICE
};


//======================== The main function
void __cdecl main()
{
    HRESULT				hr=S_OK;

    DWORD				dwWorkFlags;   

    WSADATA				WsaData;
	DWORD				dwError;

	// test stuff -- garbage values for now.
	ULONGLONG qwUserPUID = 0xCAFEBABE;
	DWORD dwOfferingId = 0x3;
	XONLINETASK_HANDLE	hTask;
	XONLINE_STARTUP_PARAMS startParams;
	PXONLINE_USER	rgUsers;
    XONLINETASK_HANDLE	hLogon;

	XNetStartupParams 	xnsp = { sizeof(XNetStartupParams), 
								XNET_STARTUP_BYPASS_SECURITY };

    //_asm int 3;

    DebugPrint("Loading XBox network stack...\n");
    dwError = XNetStartup(&xnsp);
    if (dwError != NO_ERROR)
    {
	    DebugPrint("Failed XNetStartup with %d\n", dwError);
        return;
    }

	DebugPrint( "Starting up XONLINE facilities\n");
	startParams.dwReserved = XNET_STARTUP_BYPASS_SECURITY;

	dwError = XOnlineStartup(NULL);
	if(dwError != S_OK)
    {
	    DebugPrint("Failed XOnlineStartup with %x\n", dwError);
        return;
    } 

	// Initialize services
	hr = XOnlineLogonWrapper(g_rgServices, NUM_SERVICES, &hLogon);
	if (FAILED(hr))
	{
        DebugPrint("Cannot Logon (%08x), check c:\\xonline.ini\n", hr);
        return;
	}

	// Initialize test specific stuff
	Initialize();

	// Initialize graphics stuff
	hr = InitializeGraphics();
	if (FAILED(hr))
	{
        DebugPrint("Cannot initialize graphics (%08x)\n", hr);
        return;
	}

	// Initialize text font  (be sure the tahoma.tff file is on the XDK box)
	hr = InitializeFont(0xffffffff, 0xff000000, XFONT_OPAQUE);
	if (FAILED(hr))
	{
        DebugPrint("Cannot initialize text (%08x)\n", hr);
        return;
	}


	// start by sending the request 

	// AHEM! Hack to force the billing client to allow this user.
	rgUsers = XOnlineGetLogonUsers();		
	rgUsers[0].xuid.qwUserID = qwUserPUID;
	rgUsers[0].xuid.dwUserFlags = 0;

	goto Cancel;
// *** ATTEMPT A DETAILS
	hr = XOnlineOfferingGetDetails( 0, 
									dwOfferingId, 
									0,
									0,  
									NULL,
									XOnlineOfferingDetailsMaxSize(0),
									NULL, 
									&hTask );
	if (FAILED(hr)) 
	{
		DebugPrint("  Details failed (%08x)", hr );
		return;
	}

	while (1) 
	{
		if (hTask)
		{
			dwPumpCalls++;
			hr = XOnlineTaskContinue( hTask );
			if( hr != XONLINETASK_S_RUNNING )
			{
				// task completed, success?
				if( FAILED(hr) ) 
				{
					//bugger.  this shouldn't fail!
					BeginNewScene();
					wsprintf(StatusBuffer, L"   Details failed (%08x) after %u pump calls\r\n",
										   hr, dwPumpCalls );
				
					Xputs(StatusBuffer);				
                    goto Die;
				}
				
				// otherwise, success!
				
				BeginNewScene();
				wsprintf(StatusBuffer, L"   Details succeeded (%08x) after %u pump call(s)\r\n",
										   hr, dwPumpCalls );

				PBYTE details;
				DWORD detlen;
				DWORD scrap;
				XONLINE_PRICE prgross, prnet;
				WCHAR strGross[50];
				WCHAR strNet[50];
				XOnlineOfferingDetailsGetResults( hTask, 
													 &details, 
													 &detlen,
													 &prgross,
													 &prnet );
															
				XOnlineOfferingPriceFormat( &prgross, strGross, &scrap, 0 );
				XOnlineOfferingPriceFormat( &prnet, strNet, &scrap, 0 );
				wsprintf(StatusBuffer, L"   Details succeeded (%08x) after %u pump call(s)\r\n"
									   L"    Blob size: %d\r\n    Currency:%c%c%c\r\n    Gross: %s\r\n    Net: %s\r\n"
									   L"\r\n%s", hr, dwPumpCalls, detlen, prgross.rgchISOCurrencyCode[0], prgross.rgchISOCurrencyCode[1],
									   prgross.rgchISOCurrencyCode[2],strGross, strNet, (WCHAR *)details );

                DebugPrint("Details call succeeded!\n");
				Xputs(StatusBuffer);		
				break;
			}
		}
	}

	// we're done
	XOnlineTaskClose( hTask );
	hTask = NULL;



// *** DO A PURCHASE	
	wsprintf(StatusBuffer, L"   -----------------------------------------------------  \r\n" );
    Xputs(StatusBuffer);		
	
    hr = XOnlineOfferingPurchase( 0, dwOfferingId, NULL, &hTask );
	if (FAILED(hr)) 
	{
		DebugPrint("  Purchase failed (%08x)", hr );
		return;
	}

	while (1) 
	{
		if (hTask)
		{
			dwPumpCalls++;
			hr = XOnlineTaskContinue( hTask );
			if( hr != XONLINETASK_S_RUNNING )
			{
				// task completed, success?
				if( FAILED(hr) ) 
				{
					//bugger.  this shouldn't fail!
					wsprintf(StatusBuffer, L"   ... but Purchase failed (%08x) after %u pump calls\r\n",
										   hr, dwPumpCalls );
				    DebugPrint("Purchase failed!\n");
					Xputs(StatusBuffer);		
					goto Die;
				}
				
				// otherwise, success!
				
				// close task handle
				wsprintf(StatusBuffer, L"   ... and Purchase succeeded (%08x) after %u pump call(s)\r\n",
										   hr, dwPumpCalls );
				DebugPrint("purchase call succeeded!\n");
				Xputs(StatusBuffer);		
				break;
			}
		}
	}

	// we're done
	XOnlineTaskClose( hTask );
	hTask = NULL;

// *** DO A PURCHASE	
	wsprintf(StatusBuffer, L"   -----------------------------------------------------  \r\n" );
    Xputs(StatusBuffer);		

Cancel:
//attempt cancellation of previous offer
    hr = XOnlineOfferingCancel( 0, dwOfferingId, NULL, &hTask );
	if (FAILED(hr)) 
	{
		DebugPrint("  purchase failed (%08x)", hr );
		return;
	}

	while (1) 
	{
		if (hTask)
		{
			dwPumpCalls++;
			hr = XOnlineTaskContinue( hTask );
			if( hr != XONLINETASK_S_RUNNING )
			{
				// task completed, success?
				if( FAILED(hr) ) 
				{
					//bugger.  this shouldn't fail!
					wsprintf(StatusBuffer, L"   Cancel failed (%08x) after %u pump calls\r\n",
										   hr, dwPumpCalls );
				
					Xputs(StatusBuffer);		
					goto Die;
				}
				
				// otherwise, success!
				
				// close task handle
				wsprintf(StatusBuffer, L"   Cancel succeeded (%08x) after %u pump call(s)\r\n",
										   hr, dwPumpCalls );
				
				Xputs(StatusBuffer);		
				goto Die;
			}
		}
	}



Die:
	// we're done
	XOnlineTaskClose( hTask );
	hTask = NULL;
    PresentScene();
    DebugPrint("Unloading XBox network stack...\n");
	XOnlineCleanup();

	// Break here
	_asm int 3;

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\cdtest\xmain.cpp ===
/*++

Copyright (c) Microsoft Corporation

Author:
    Keith Lau (keithlau)

Description:
	Unit test shell for asynchronous XOnlineContentInstall

Module Name:

    xmain.c

--*/

#include "xonp.h"
#include "testutil.h"
#include "testui.h"

//
// Enable this macro if we want to wait for event before pumping
//
//#define WAIT_FOR_EVENT

#define MAX_DOWNLOAD_FILES		4

XONLINEOFFERING_ID	rgOfferingId[] =
{
	100000, 100001, 100002, 100003
};

DWORD	g_dwTitleId = 100;

#define CDTEST_ALL_FILES		"\\*.*"

HRESULT HrFindFiles(
			XONLINEOFFERING_ID	OfferingId,
			DWORD				*pdwFiles
			)
{
	HRESULT	hr = S_OK;
	DWORD	dwTitleId;
	DWORD	cbPath;
	DWORD	dwFiles = 0;
	BOOL	fResult;
	BYTE	szPath[XONLINECONTENT_MAX_PATH];
	HANDLE	hFind = INVALID_HANDLE_VALUE;
	WIN32_FIND_DATA	wfd;

    dwTitleId = XeImageHeader()->Certificate->TitleID;

	cbPath = XONLINECONTENT_MAX_PATH;
	hr = XOnlineContentGetRootDirectory(
				OfferingId, FALSE,	// fUserData
				&cbPath, (CHAR *)szPath);
	if (FAILED(hr))
		return(hr);

	if ((cbPath + strlen(CDTEST_ALL_FILES)) >= XONLINECONTENT_MAX_PATH)
		return(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));

	strcpy((char *)szPath + cbPath, CDTEST_ALL_FILES);
	cbPath += strlen(CDTEST_ALL_FILES);

	hFind = FindFirstFile((LPCSTR)szPath, &wfd);
	if (hFind == INVALID_HANDLE_VALUE)
	{
		if ((GetLastError() == ERROR_FILE_NOT_FOUND) ||
			(GetLastError() == ERROR_PATH_NOT_FOUND))
		{
			*pdwFiles = 0;
			return(S_OK);
		}
		
		return(HRESULT_FROM_WIN32(GetLastError()));
	}
	fResult = TRUE;

	while (fResult)
	{
		if (wfd.cFileName[0] != '.')
			dwFiles++;

		fResult = FindNextFile(hFind, &wfd);
	}

	FindClose(hFind);

	if (GetLastError() != ERROR_NO_MORE_FILES)
	{
		FindClose(hFind);
		return(HRESULT_FROM_WIN32(GetLastError()));
	}

	FindClose(hFind);
	*pdwFiles = dwFiles;
	return(S_OK);
}

typedef enum
{
	INSTALL_DOWNLOAD = 0,
	INSTALL_VERIFY,
	INSTALL_REMOVE,
	INSTALL_MAX
	
} INSTALL_STATES;

const WCHAR *rgwszStates[INSTALL_MAX] =
{
	L"INSTALLING", L"VERIFYING", L"REMOVING"
};

DWORD					dwPumpCalls = 0;
DWORD					dwIterations = 0;
XONLINETASK_HANDLE		rghTask[MAX_DOWNLOAD_FILES];
INSTALL_STATES			rgInstallState[MAX_DOWNLOAD_FILES];

WCHAR StatusBuffer[2400];

VOID DisplayStatus(
			XONLINEOFFERING_ID	OfferingId,
			INSTALL_STATES		is,
			XONLINETASK_HANDLE	hTask
			)
{
	HRESULT			hr;
	ULARGE_INTEGER	ulin, ulid;
	DWORD			dwPercentDone;

	hr = XOnlineContentInstallGetProgress(hTask, 
				&dwPercentDone, &(ulin.QuadPart), &(ulid.QuadPart));

	BeginNewScene();

	wsprintf(StatusBuffer,
		L"%u pump calls made\r\n"\
		L"%u packages downloaded, verified and removed\r\n"\
		L"Content ID: %u\r\n"\
		L"Processing Status: %s\r\n",
		dwPumpCalls, dwIterations, OfferingId, rgwszStates[is]);
	Xputs(StatusBuffer);

	if (is ==INSTALL_DOWNLOAD)
	{
		wsprintf(StatusBuffer, 
				L"  Install progress %u percent (%I64u / %I64u)\r\n",
				dwPercentDone, ulin, ulid);
		Xputs(StatusBuffer);				
	}

	PresentScene();
}

void Initialize()
{
	DWORD i;

	for (i = 0; i < MAX_DOWNLOAD_FILES; i++)
	{
		rghTask[i] = NULL;
		rgInstallState[i] = INSTALL_DOWNLOAD;
	}
}

#define NUM_SERVICES	1
DWORD			g_rgServices[NUM_SERVICES] =
{
	XONLINE_BILLING_OFFERING_SERVICE
};


//======================== The main function
void __cdecl main()
{
    HRESULT				hr;

	ULARGE_INTEGER		uliContentLength;
	CHAR				szPath[MAX_PATH];
	CHAR				szReference[MAX_PATH];
	CHAR				szDownloadLocation[MAX_PATH];
	CHAR				szTime1[MAX_TIME_SIZE];
	CHAR				szTime2[MAX_TIME_SIZE];
	DWORD				dwInitialized;
    DWORD				dwCurTask = 0;
    DWORD				dwReason = 0;
    DWORD				dwError;
    DWORD				dwFiles;
    DWORD				dwSize;
    DWORD				i;

	DWORD				dwStatus;
	FILETIME			ftTime;
	FILETIME			ftLastModified;

	PBYTE				pbBuffer1 = NULL;
	PBYTE				pbBuffer2 = NULL;
    XONLINETASK_HANDLE	hLogon;

	XONLINE_STARTUP_PARAMS	xosp = { 0 };

	XNetStartupParams 	xnsp = { sizeof(XNetStartupParams), 
								XNET_STARTUP_BYPASS_SECURITY };

	// Set up the 'current' Title ID
	ChangeCurrentTitleId(g_dwTitleId);
	
    DebugPrint("Loading XBox network stack...\n");
    dwError = XNetStartup(&xnsp);
    if (dwError != NO_ERROR)
    {
	    DebugPrint("Failed XNetStartup with %d\n", dwError);
        return;
    }

    DebugPrint("Calling XOnlineStartup...\n");
    hr = XOnlineStartup(&xosp);
    if (FAILED(hr))
    {
        DebugPrint("Error %08x returned by XOnlineStartup\n", hr);
        dwReason = 1;
        goto Error;
    }

	// Dump the size of the content download context for info
	DebugPrint("Size of context: %u bytes", 
				sizeof(XONLINETASK_CONTENT_DOWNLOAD));

#if 0
	// Initialize services
	hr = XOnlineLogonWrapper(g_rgServices, NUM_SERVICES, &hLogon);
	if (FAILED(hr))
	{
        DebugPrint("Cannot Logon (%08x), check c:\\xonline.ini\n", hr);
        RIP("Failed to initialize services");
        dwReason = 2;
        goto Error;
	}
#endif	

	// Initialize test specific stuff
	Initialize();

	// Initialize graphics stuff
	hr = InitializeGraphics();
	if (FAILED(hr))
	{
        DebugPrint("Cannot initialize graphics (%08x)\n", hr);
        RIP("Failed to initialize graphics");
        dwReason = 3;
        goto Error;
	}

	// Initialize text font
	hr = InitializeFont(0xffffffff, 0xff000000, XFONT_OPAQUE);
	if (FAILED(hr))
	{
        DebugPrint("Cannot initialize text (%08x)\n", hr);
        RIP("Failed to initialize text");
        dwReason = 4;
        goto Error;
	}

	// Loop downloading packages
	while (1)
	{
		// Start the task if completed
		if (!rghTask[dwCurTask])
		{
			switch (rgInstallState[dwCurTask])
			{
			case INSTALL_DOWNLOAD:

				// Install the content package
			    hr = XOnlineContentInstall(
			    			rgOfferingId[dwCurTask],
							NULL, 
	 		    			&(rghTask[dwCurTask]));

//			    DebugPrint("Installing %u  (hTask = %p)\n", 
//			    			rgOfferingId[dwCurTask], rghTask[dwCurTask]);
			    
		    	AssertSz(SUCCEEDED(hr), "Cannot start install");
			    Assert(rghTask[dwCurTask] != NULL);

			    if (FAILED(hr))
			    {
			    	dwReason = 100;
			    	goto Error;
			    }

				dwIterations++;
//				DebugPrint("Iteration #%u\n", dwIterations);
			    break;

			case INSTALL_VERIFY:
				// Verify the content
				dwSize = XBOX_HD_SECTOR_SIZE * 2;
				hr = XOnlineContentVerify(
			    			rgOfferingId[dwCurTask],
							NULL, &dwSize,
							NULL, 
	 		    			&(rghTask[dwCurTask]));
							
//			    DebugPrint("Verifying %u  (hTask = %p)\n", 
//			    			rgOfferingId[dwCurTask], rghTask[dwCurTask]);
			    
		    	AssertSz(SUCCEEDED(hr), "Cannot start verification");
			    Assert(rghTask[dwCurTask] != NULL);

			    if (FAILED(hr))
			    {
			    	dwReason = 110;
			    	goto Error;
			    }
			    break;
				
			case INSTALL_REMOVE:
				// Remove the content
				hr = XOnlineContentRemove(
			    			rgOfferingId[dwCurTask],
							NULL, 
	 		    			&(rghTask[dwCurTask]));
							
//			    DebugPrint("Removing %u  (hTask = %p)\n", 
//			    			rgOfferingId[dwCurTask], rghTask[dwCurTask]);
			    
		    	AssertSz(SUCCEEDED(hr), "Cannot start removal");
                Assert(rghTask[dwCurTask] != NULL);

			    if (FAILED(hr))
			    {
			    	dwReason = 120;
			    	goto Error;
			    }
			    break;

			default:
				RIP("INVALID State");
			}
		}

		// Display status every x pumps
		if ((dwPumpCalls & 0xff) == 0)
		{
			DisplayStatus(
						rgOfferingId[dwCurTask],
						rgInstallState[dwCurTask], 
						rghTask[dwCurTask]);
		}
		
		// Continue if required
		if (rghTask[dwCurTask])
		{
			hr = XOnlineTaskContinue(rghTask[dwCurTask]);
			if (XONLINETASK_STATUS_AVAILABLE(hr))
			{
				switch (rgInstallState[dwCurTask])
				{
				case INSTALL_DOWNLOAD:
				
					// Download complete ...
				    AssertSz(SUCCEEDED(hr), "Download");

				    if (FAILED(hr))
				    {
				    	dwReason = 200;
				    	goto Error;
				    }

				    hr = HrFindFiles(rgOfferingId[dwCurTask], &dwFiles);
				    Assert(SUCCEEDED(hr) && dwFiles);

//				    DebugPrint("Download got %u files\n", dwFiles);

				    rgInstallState[dwCurTask] = INSTALL_VERIFY;

				    if (FAILED(hr))
				    {
				    	dwReason = 201;
				    	goto Error;
				    }
				    break;

				case INSTALL_VERIFY:

				    if (FAILED(hr))
				    {
				    	dwReason = 210;
				    	goto Error;
				    }

					// Verification complete ...
				    Assert(SUCCEEDED(hr));
				    rgInstallState[dwCurTask] = INSTALL_REMOVE;
					break;

				case INSTALL_REMOVE:
				
				    if (FAILED(hr))
				    {
				    	dwReason = 220;
				    	goto Error;
				    }
				    	
					// Remove complete ...
				    Assert(SUCCEEDED(hr));

				    hr = HrFindFiles(rgOfferingId[dwCurTask], &dwFiles);
				    Assert(FAILED(hr) || !dwFiles);
				    hr = S_OK;

//				    DebugPrint("Remove left %u files\n", dwFiles);
					rgInstallState[dwCurTask] = INSTALL_DOWNLOAD;
				    break;

				default:
					RIP("INVALID State");
				}

				// Close the handle
				XOnlineTaskClose(rghTask[dwCurTask]);
				rghTask[dwCurTask] = NULL;

				if (rgInstallState[dwCurTask] == INSTALL_DOWNLOAD)
				{
					// Next Task
					dwCurTask++;
					if (dwCurTask >= MAX_DOWNLOAD_FILES)
						dwCurTask = 0;
				}
			}
		}

		dwPumpCalls++;
	}

Exit:

    DebugPrint("Shutting down XOnline...\n");
    XOnlineCleanup();

	return;

Error:
	DebugPrint("Error occurred: %08x at %u\n\n", hr, dwReason);
	goto Exit;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\autoupdo\autoupdo.cpp ===
/*++

Copyright (c) Microsoft Corporation

Author:
    Keith Lau (keithlau)

Description:
	Unit test shell for Online Autoupdate

Module Name:

    autoupdo.cpp

--*/

#include "xonp.h"
#include "testutil.h"
#include "testui.h"

DWORD					dwPumpCalls = 0;

const WCHAR	wszRebootMsg[] = 
			L"The current title has been successfully updated ONLINE.\n"
			L"Reboot your Xbox and run this app again, and if\n"
			L"this worked, you will see a message telling you\n"
			L"that Autoreboot worked for TITLE.\n";

WCHAR StatusBuffer[2400];

//======================== The main function
void __cdecl main()
{
    HRESULT				hr = S_OK;
    DWORD				dwError;
    DWORD				dwLastStatusUpdate = 0;
    HANDLE				hEvent = NULL;
	XONLINETASK_HANDLE	hTask = NULL;
    XONLINETASK_HANDLE	hLogon = NULL;
    WCHAR				wszReboot[MAX_PATH];

	XONLINE_STARTUP_PARAMS	xosp = { 0 };

	XNetStartupParams 	xnsp = { sizeof(XNetStartupParams), 
								XNET_STARTUP_BYPASS_SECURITY };

    DebugPrint("Loading XBox network stack...\n");
    dwError = XNetStartup(&xnsp);
    if (dwError != NO_ERROR)
    {
	    DebugPrint("Failed XNetStartup with %d\n", dwError);
        return;
    }

    DebugPrint("Calling XOnlineStartup...\n");
    hr = XOnlineStartup(&xosp);
    if (FAILED(hr))
    {
        DebugPrint("Error %08x returned by XOnlineStartup\n", hr);
        return;
    }

	// Dump the size of the content download context for info
	// DebugPrint("Size of context: %u bytes", sizeof(XONLINETASK_AUTOUPD_ONLINE));

	hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

	// Initialize graphics stuff
	hr = InitializeGraphics();
	if (FAILED(hr))
	{
        DebugPrint("Cannot initialize graphics (%08x)\n", hr);
        RIP("Failed to initialize graphics");
        return;
	}

	// Initialize text font
	hr = InitializeFont(0xffffffff, 0xff000000, XFONT_OPAQUE);
	if (FAILED(hr))
	{
        DebugPrint("Cannot initialize text (%08x)\n", hr);
        RIP("Failed to initialize text");
        return;
	}

	// Just kick off the title update
	hr = XOnlineTitleUpdate(0);

	BeginNewScene();

	wcscpy((WCHAR *)wszReboot, (WCHAR *)wszRebootMsg);
	Xputs(wszReboot);

	PresentScene();

	while (1)
		Sleep(1000);

	// Break here
	_asm int 3;

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\common\testui.h ===
/*++

Copyright (c) Microsoft Corporation

Author:
	Keith Lau (keithlau)

Description:
	Definitions for the test UI functions

Module Name:

    testui.h

--*/

#ifndef __TESTUI_H__
#define __TESTUI_H__

#define XFONT_TRUETYPE 1 
#include <xfont.h>

#ifdef __cplusplus
extern "C" {
#endif

//
// API to initialize D3D8 graphics
//
HRESULT InitializeGraphics();

//
// API to initialize Font support
//
HRESULT InitializeFont(
			D3DCOLOR	TextColor,
			D3DCOLOR	BackgroundColor,
			int			iBkMode
			);

//
// API to start a fresh rendering scene
//
VOID BeginNewScene();

//
// API to print a string to the screen as if the screen is in text mode
// Sorry, no scrolling
//
int Xputs(WCHAR *wszString);

//
// API to render and display a scene
//
VOID PresentScene();

#ifdef __cplusplus
}
#endif

#endif  //__TESTUI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\codesize\sources.inc ===
TARGETPATH=obj
TARGETTYPE=PROGRAM
TARGETNAME=codesize
NO_BINPLACE=1
NTPREFIX=1
INCLUDES=$(INCLUDE);$(SDK_INC_PATH);$(BASEDIR)\private\inc
TARGETLIBS=$(TARGETLIBS)
LINKER_FLAGS=$(LINKER_FLAGS) /map
SOURCES=\
    codesize.cpp\
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\common\pubkey.c ===
BYTE rgbPublicKeyData[] =
{
	0x52, 0x53, 0x41, 0x31, 0x08, 0x01, 0x00, 0x00, 
	0x00, 0x08, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
	0x01, 0x00, 0x01, 0x00, 0xe7, 0x74, 0xac, 0x08, 
	0xdf, 0x33, 0xc7, 0xb4, 0x30, 0xf7, 0x98, 0x58, 
	0x03, 0x87, 0x92, 0x3e, 0xa6, 0x2b, 0x05, 0x61, 
	0x9c, 0x15, 0xc0, 0x64, 0x0f, 0x01, 0xcd, 0x69, 
	0xcf, 0x93, 0x2e, 0xc9, 0xb8, 0xf4, 0xb7, 0x70, 
	0xb5, 0x33, 0x43, 0x9e, 0x6a, 0x88, 0x4f, 0x14, 
	0x3c, 0x21, 0xcb, 0x6c, 0x91, 0xf4, 0x12, 0x80, 
	0xbe, 0xea, 0xe7, 0xb3, 0x08, 0x05, 0xff, 0x43, 
	0x97, 0xd9, 0x51, 0xee, 0x26, 0x97, 0x71, 0x87, 
	0x39, 0x0a, 0x44, 0xb6, 0xff, 0x14, 0xfc, 0x1d, 
	0x94, 0x48, 0x33, 0xe1, 0xa6, 0xc0, 0xf9, 0xf0, 
	0x67, 0xbc, 0x1c, 0xe6, 0x7e, 0xe2, 0x90, 0xa9, 
	0x61, 0x8a, 0xd5, 0xb0, 0x15, 0xbb, 0xa5, 0xce, 
	0x18, 0x73, 0x6d, 0xfa, 0xbe, 0x76, 0xeb, 0xf8, 
	0x78, 0xe2, 0x5f, 0x59, 0xea, 0x3c, 0x02, 0x0c, 
	0x3f, 0x1a, 0xc3, 0xa3, 0x00, 0x85, 0x7b, 0x29, 
	0x4d, 0x9f, 0x3a, 0xdd, 0x52, 0x1b, 0xce, 0x84, 
	0x48, 0x04, 0x6e, 0x72, 0xad, 0x74, 0x9c, 0x95, 
	0xc0, 0x4b, 0xab, 0xa6, 0x0c, 0x44, 0xd2, 0xde, 
	0x70, 0xa1, 0xfa, 0xdb, 0x3c, 0x97, 0xe5, 0xdc, 
	0x38, 0xa5, 0xac, 0x2b, 0xc5, 0xdf, 0xdc, 0xf6, 
	0x2a, 0xcc, 0x58, 0x7a, 0x19, 0x21, 0xfc, 0x95, 
	0x97, 0xdc, 0x4c, 0x4d, 0xf0, 0xbd, 0x42, 0xf7, 
	0x4b, 0x91, 0x1b, 0xb6, 0xbc, 0x30, 0x13, 0x0b, 
	0xcf, 0xd0, 0x1b, 0xbb, 0x25, 0xd4, 0x13, 0x77, 
	0x16, 0x83, 0x26, 0x54, 0xa6, 0x67, 0xaa, 0x40, 
	0x47, 0xe0, 0x11, 0x54, 0xc9, 0x68, 0x8a, 0xb2, 
	0x50, 0xd0, 0x51, 0x9d, 0xe5, 0x45, 0xc4, 0x95, 
	0xc8, 0x45, 0x2c, 0xae, 0x08, 0x7f, 0x4d, 0xd1, 
	0x6f, 0x34, 0xd2, 0xf1, 0x87, 0x4c, 0x16, 0x97, 
	0x0c, 0xfc, 0xcf, 0xd1, 0xb9, 0x1e, 0x7b, 0x4b, 
	0xa4, 0x02, 0xfd, 0xc6, 0xff, 0x2b, 0xf9, 0xc3, 
	0xee, 0xde, 0x12, 0xd7, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00 
};

BYTE *g_rgbPublicKey = rgbPublicKeyData;
const DWORD g_cbPublicKey = sizeof(rgbPublicKeyData);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\codesize\codesize.cpp ===
// ---------------------------------------------------------------------------------------
// codesize.cpp
//
// Test program which links with all of the external entry points of
// the XOnline library.  Used to track the size of the XOnline code.
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#ifdef _XBOX
    #include <xtl.h>
#else
    #include <windows.h>
#endif

#include <winsockx.h>
#include <winsockp.h>
#include <xonlinep.h>
#include <stdio.h>

#ifdef _XBOX
#define CODESIZEINHERIT
#else
#define CODESIZEINHERIT     : public CXOnline
#endif

void __cdecl Ref(DWORD dw, ...)
{
    static DWORD s_dwCount;
    s_dwCount += dw;
}

class CCodeSize CODESIZEINHERIT
{
public:
    void DoRef();
};

void CCodeSize::DoRef()
{
#ifndef XONLINEBASELINE

    #undef  XNETAPI
    #define XNETAPI(ret, fname, arglist, paramlist) Ref(0, fname);
    #undef  XNETAPI_
    #define XNETAPI_(ret, fname, arglist, paramlist) Ref(0, fname);
    #undef  XNETAPIV
    #define XNETAPIV(ret, fname, arglist, paramlist) Ref(0, fname);

    XNETAPILIST()
    SOCKAPILIST()

    #undef  XONAPI
    #define XONAPI(ret, fname, arglist, paramlist) Ref(0, fname);
    #undef  XONAPI_
    #define XONAPI_(ret, fname, arglist, paramlist)
    #undef  XONAPIV
    #define XONAPIV(ret, fname, arglist, paramlist) Ref(0, fname);

    XONLINEAPILIST()

#endif
}

void __cdecl main(int argc, char * argv[])
{
    CCodeSize CodeSize;
    CodeSize.DoRef();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\common\testutil.h ===
/*++

Copyright (c) Microsoft Corporation

Author:
	Keith Lau (keithlau)

Description:
	Private definitions for the content delivery implementation

Module Name:

    testutil.h

--*/

#ifndef __TESTUTIL_H__
#define __TESTUTIL_H__

#ifdef __cplusplus
extern "C" {
#endif

extern BYTE *g_rgbPublicKey;
extern const DWORD g_cbPublicKey;

ULONG DebugPrint(PCHAR Format, ...);

#define	MAX_TIME_SIZE				40

HRESULT ConvertFileTimeAsString(LPSTR pBuffer, DWORD* pcbBuffer, PFILETIME pft);

VOID WINAPI ChangeCurrentTitleId(DWORD dwTitleId);

HRESULT XOnlineLogonWrapper(DWORD* pdwServiceIDs, DWORD cServices, XONLINETASK_HANDLE *phHandle);

void DumpRow(PBYTE pb1, DWORD cbb1, PBYTE pb2, DWORD cbb2);

void DumpBuffers(PBYTE pb1, DWORD cbb1, PBYTE pb2, DWORD cbb2);

HRESULT HrAllocateAndReadFile(char *szFile, PBYTE *ppbBuffer, DWORD *pdwLength);

HRESULT HrFileCompare(char *szFile1, char *szFile2, 
			PBYTE pbBuffer1, PBYTE pbBuffer2, DWORD dwLen);

HRESULT HrFileCompareWithBuffer(char *szFile, 
			PBYTE pbBuffer1, DWORD dwLen1, 
			PBYTE pbBuffer2, DWORD dwLen2);

HRESULT HrTruncateFile(char *szFile, long lBytesToCut);


#ifdef __cplusplus
}
#endif

#endif  //__TESTUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\common\testui.cpp ===
/*++

Copyright (c) Microsoft Corporation

Author:
    Keith Lau (keithlau)

Description:
	Module implementing unit test UI components

Module Name:

    testui.c

--*/

#include <xtl.h>
#include "testui.h"

#define FILE_DATA_DEFAULT_FONT_FILENAME         L"t:\\tahoma.ttf"

//
// Globals for graphics
//
LPDIRECT3DDEVICE8	g_D3d = NULL; // Our rendering device

//
// Globals for text-mode screen
//
const DWORD ScreenWidth = 640;
const DWORD ScreenHeight = 480;
const DWORD XOriginOffset = 30;
const DWORD YOriginOffset = 30;
const DWORD	TextHeight = 16;
const DWORD LinesOfText = (ScreenHeight / TextHeight);

DWORD g_TextVerticalPosition = 0;

//
// API to initialize D3D8 graphics
//
HRESULT WINAPI InitializeGraphics()
{
	HRESULT					hr;
	LPDIRECT3D8				D3dCreate	 = NULL; // Used to create the D3DDevice
	D3DDISPLAYMODE			D3ddm;
	D3DPRESENT_PARAMETERS	D3dpp;

	// Create the D3D object.
		// Register the window class
	D3dCreate = Direct3DCreate8(D3D_SDK_VERSION);
	if (!D3dCreate)
		return(E_FAIL);

	// Get the current desktop display mode, so we can set up a back
	// buffer of the same format
	hr = D3dCreate->GetAdapterDisplayMode(D3DADAPTER_DEFAULT, &D3ddm);
	if (FAILED(hr))
		return(hr);

	// Set up the structure used to create the D3DDevice
	ZeroMemory(&D3dpp, sizeof(D3dpp));
	D3dpp.BackBufferWidth        = ScreenWidth;
	D3dpp.BackBufferHeight       = ScreenHeight;
	D3dpp.BackBufferFormat       = D3DFMT_A8R8G8B8;
	D3dpp.BackBufferCount        = 1;
	D3dpp.EnableAutoDepthStencil = TRUE;
	D3dpp.AutoDepthStencilFormat = D3DFMT_D24S8;
	D3dpp.SwapEffect             = D3DSWAPEFFECT_DISCARD;

	// Create the D3DDevice
	hr = D3dCreate->CreateDevice(0, D3DDEVTYPE_HAL, NULL,
				D3DCREATE_HARDWARE_VERTEXPROCESSING,
				&D3dpp, &g_D3d);
	if (FAILED(hr))
		return(hr);				

	// Turn off culling, so we see the front and back of the triangle
	g_D3d->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);

	// Turn off D3D lighting, since we are providing our own vertex colors
	g_D3d->SetRenderState(D3DRS_LIGHTING, FALSE);

	return(S_OK);
}

XFONT				*xfont;
IDirect3DSurface8*	D3dBackBuffer;

//
// API to initialize Font support
//
HRESULT WINAPI InitializeFont(
			D3DCOLOR	TextColor,
			D3DCOLOR	BackgroundColor,
			int			iBkMode	// XFONT_OPAQUE or XFONTTRANSPARENT
			)
{
	HRESULT				hr;
	
	hr = XFONT_OpenTrueTypeFont(FILE_DATA_DEFAULT_FONT_FILENAME, 4096, &xfont);
	if (FAILED(hr))
		return(hr);

	if (!xfont)
		return(E_FAIL);

	hr = g_D3d->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &D3dBackBuffer); 
	if (FAILED(hr))
		return(hr);

	XFONT_SetTextColor(xfont, TextColor);
	XFONT_SetBkColor(xfont, BackgroundColor);
	XFONT_SetBkMode(xfont, iBkMode);

	return(S_OK);
}

//
// API to start a fresh rendering scene
//
VOID WINAPI BeginNewScene()
{
    D3DXMATRIX	ViewMatrix;
    D3DXMATRIX	ProjMatrix;

	g_D3d->Clear(0, NULL, D3DCLEAR_TARGET, D3DCOLOR_XRGB(0,0,0), 1.0f, 0);

	g_D3d->BeginScene();

	// Set up our view matrix. A view matrix can be defined given an eye point,
	// a point to lookat, and a direction for which way is up. Here, we set the
	// eye five units back along the z-axis and up three units, look at the
	// origin, and define "up" to be in the y-direction.
	D3DXMatrixLookAtLH(&ViewMatrix,
				&D3DXVECTOR3( 4.0f, 4.0f,-10.0f ),
				&D3DXVECTOR3( 4.0f, 4.0f, 0.0f ),
				&D3DXVECTOR3( 0.0f, 1.0f, 0.0f ));
	g_D3d->SetTransform(D3DTS_VIEW, &ViewMatrix);

	// For the projection matrix, we set up a perspective transform (which
	// transforms geometry from 3D view space to 2D viewport space, with
	// a perspective divide making objects smaller in the distance). To build
	// a perpsective transform, we need the field of view (1/4 pi is common),
	// the aspect ratio, and the near and far clipping planes (which define at
	// what distances geometry should be no longer be rendered).
	D3DXMatrixPerspectiveFovLH(&ProjMatrix, 
				1.3f*D3DX_PI/4, 1.0f, 1.0f, 100.0f);
	g_D3d->SetTransform(D3DTS_PROJECTION, &ProjMatrix);

	// Emulate a CLS
	g_TextVerticalPosition = 0;
}

//
// API to render and display a scene
//
VOID WINAPI PresentScene()
{
	g_D3d->EndScene();

	g_D3d->Present(NULL, NULL, NULL, NULL);
}

//
// API to print a string to the screen as if the screen is in text mode
// Sorry, no scrolling
//
int WINAPI Xputs(WCHAR *wszString)
{
	WCHAR *pwcBegin = wszString; 
	
	while ((*wszString) && (g_TextVerticalPosition < LinesOfText))
	{
		if ((*wszString == L'\r') || (*wszString == L'\n'))
		{
			*wszString++ = L'\0';
			XFONT_TextOut(xfont, D3dBackBuffer, pwcBegin, -1, XOriginOffset, 
						YOriginOffset + (g_TextVerticalPosition * TextHeight));
			g_TextVerticalPosition++;

			while ((*wszString == L'\r') || (*wszString == L'\n'))
				*wszString++;
			pwcBegin = wszString;
		}
		else
			wszString++;
	}

	if ((g_TextVerticalPosition < LinesOfText) &&
		(!*wszString) && (wszString > pwcBegin))
	{
		// Print the last line
		XFONT_TextOut(xfont, D3dBackBuffer, pwcBegin, -1, XOriginOffset, 
					YOriginOffset + (g_TextVerticalPosition * TextHeight));
		g_TextVerticalPosition++;
	}

	return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\common\testutil.cpp ===
/*++

Copyright (c) Microsoft Corporation

Author:
    Keith Lau (keithlau)

Description:
	Module implementing utility functions for unti tests

Module Name:

    testutil.c

--*/

#include <xapip.h>
#include <xtl.h>
#include <stdio.h>
#include <xonlinep.h>

#include "testutil.h"

#include "pubkey.c"

static char *rgszDays[] = 
{
	"Sun", "Mon", "Tue", "Wed", 
	"Thu", "Fri", "Sat" 
};

static char *rgszMonths[] = 
{
	"", "Jan", "Feb", "Mar", "Apr", "May", "Jun", 
	"Jul", "Aug", "Sep", "Oct", "Nov", "Dec" 
};

HRESULT ConvertFileTimeAsString(LPSTR pBuffer, DWORD* pcbBuffer, PFILETIME pft)
{
    // We'll use RFC 1123 (actually a subset)
    // Sun, 06 Nov 1994 08:49:37 GMT
    //
    SYSTEMTIME  st;

    // check the buffer size
    if (MAX_TIME_SIZE > *pcbBuffer)
        return(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));


    // BUGBUG (michaelw) We should probably make sure the following succeeds but it sucks for callers
    // to have to check our return.  Consider using an Assert
    FileTimeToSystemTime(pft, &st);

    // assemble the final string
    *pcbBuffer = sprintf(pBuffer, "%s, %02d %s %4d %02d:%02d:%02d GMT", 
    			rgszDays[st.wDayOfWeek], st.wDay, rgszMonths[st.wMonth], 
    			st.wYear, st.wHour, st.wMinute, st.wSecond);
    pBuffer[*pcbBuffer] = '\0';

    return(S_OK);
}

//
// Function to change the Title ID
//
VOID WINAPI ChangeCurrentTitleId(
			DWORD	dwTitleId
			)
{
	XeImageHeader()->Certificate->TitleID = dwTitleId;
}

//
// Wrapper function for XOnlineLogon
//
HRESULT XOnlineLogonWrapper(
            DWORD* pdwServiceIDs,
			DWORD cServices,
            XONLINETASK_HANDLE *phLogon
			)
{
	HRESULT				hr = S_OK;
	DWORD				dwWorkFlags;
	XONLINE_USER Users[4];
        DWORD i;
                                                
	for (i = 0; i < 4; i += 1)
	{
		Users[i].xuid.qwUserID = 0;
	}
	
	// Initialize services
	hr = XOnlineLogon(Users, pdwServiceIDs, cServices, NULL, phLogon);
	if (FAILED(hr))
        goto Exit;

	// Pump until logon returns
	while( (hr = XOnlineTaskContinue(*phLogon)) == XONLINETASK_S_RUNNING );
	 
Exit:
	return(hr);
}			

void DumpRow(PBYTE pb1, DWORD cbb1, PBYTE pb2, DWORD cbb2)
{
	BYTE	rgbRow[80];
	BYTE	b;
	DWORD	i;

	memset(rgbRow, ' ', 79);
	rgbRow[79] = '\0';

	for (i = 0; i < 16; i++)
	{
		if (cbb1 > i)
		{
			if ((cbb2 <= i) || (pb1[i] != pb2[i]))
				rgbRow[i*2] = '*';
			else
				rgbRow[i*2] = ' ';

			rgbRow[i*2 + 1] = ((pb1[i] >= 32) && (pb1[i] != '%'))?pb1[i]:'#';
		}

		if (cbb2 > i)
		{
			if ((cbb1 <= i) || (pb1[i] != pb2[i]))
				rgbRow[i*2 + 40] = '*';
			else
				rgbRow[i*2 + 40] = ' ';
			rgbRow[i*2 + 41] = ((pb2[i] >= 32) && (pb2[i] != '%'))?pb2[i]:'#';
		}
	}

	DebugPrint((CHAR *)rgbRow);
	return;
}	
	
void DumpBuffers(PBYTE pb1, DWORD cbb1, PBYTE pb2, DWORD cbb2)
{
	while ((cbb1 > 0) || (cbb2 > 0))
	{
		DumpRow(pb1, cbb1, pb2, cbb2);
		pb1 += 16;
		pb2 += 16;
		if (cbb1 >= 16)
			cbb1 -= 16;
		else
			cbb1 = 0;
			
		if (cbb2 >= 16)
			cbb2 -= 16;
		else
			cbb2 = 0;
	}
	return;	
}

HRESULT HrAllocateAndReadFile(char *szFile, PBYTE *ppbBuffer, DWORD *pdwLength)
{
	HRESULT	hr = S_OK;
	HANDLE	hFile = INVALID_HANDLE_VALUE;
	LARGE_INTEGER liFileSize;
	PBYTE	pbTemp = NULL;
	DWORD	dwRead;

	hFile = CreateFile(szFile, GENERIC_READ, FILE_SHARE_READ, NULL,
				OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
		goto Error;

	if (!GetFileSizeEx(hFile, &liFileSize))
		goto Error;

	pbTemp = (PBYTE) LocalAlloc(LMEM_FIXED, liFileSize.u.LowPart);
	if (!pbTemp)
		goto Error;

	if (!ReadFile(hFile, pbTemp, liFileSize.u.LowPart, &dwRead, NULL))
		goto Error;

	*pdwLength = dwRead;
	*ppbBuffer = pbTemp;

Cleanup:
	if (hFile != INVALID_HANDLE_VALUE)
		CloseHandle(hFile);
	return(hr);

Error:
	hr = HRESULT_FROM_WIN32(GetLastError());
	goto Cleanup;
}

HRESULT HrFileCompare(char *szFile1, char *szFile2, 
			PBYTE pbBuffer1, PBYTE pbBuffer2, DWORD dwLen)
{
	HRESULT	hr = S_OK;
	HANDLE	hFile1 = INVALID_HANDLE_VALUE;
	HANDLE	hFile2 = INVALID_HANDLE_VALUE;
	DWORD	dwRead1, dwRead2, dwTotalRead = 0;

	hFile1 = CreateFile(szFile1, GENERIC_READ, FILE_SHARE_READ, NULL,
				OPEN_EXISTING, FILE_FLAG_NO_BUFFERING | FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (hFile1 == INVALID_HANDLE_VALUE)
		goto Error;

	hFile2 = CreateFile(szFile2, GENERIC_READ, FILE_SHARE_READ, NULL,
				OPEN_EXISTING, FILE_FLAG_NO_BUFFERING | FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (hFile2 == INVALID_HANDLE_VALUE)
		goto Error;

	do
	{
		if (!ReadFile(hFile1, pbBuffer1, dwLen, &dwRead1, NULL))
			goto Error;
		if (!ReadFile(hFile2, pbBuffer2, dwLen, &dwRead2, NULL))
			goto Error;
		if ((dwRead1 != dwRead2) ||
			(memcmp(pbBuffer1, pbBuffer2, dwRead1) != 0))
		{
			DumpBuffers(pbBuffer1, dwRead1, pbBuffer2, dwRead2);
			hr = S_FALSE;
			goto Cleanup;
		}

		dwTotalRead += dwRead1;
		
	} while (dwRead1);

Cleanup:
	if (hFile1 != INVALID_HANDLE_VALUE)
		CloseHandle(hFile1);
	if (hFile2 != INVALID_HANDLE_VALUE)
		CloseHandle(hFile2);
	return(hr);
Error:
	hr = HRESULT_FROM_WIN32(GetLastError());
	goto Cleanup;
}

HRESULT HrFileCompareWithBuffer(char *szFile, 
			PBYTE pbBuffer1, DWORD dwLen1, 
			PBYTE pbBuffer2, DWORD dwLen2)
{
	HRESULT	hr = S_OK;
	HANDLE	hFile = INVALID_HANDLE_VALUE;
	DWORD	dwRead, dwTotalRead = 0;

	hFile = CreateFile(szFile, GENERIC_READ, FILE_SHARE_READ, NULL,
				OPEN_EXISTING, FILE_FLAG_NO_BUFFERING | FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
		goto Error;

	do
	{
		if (!ReadFile(hFile, pbBuffer1, dwLen1, &dwRead, NULL))
			goto Error;
			
		if ((dwRead > dwLen2) ||
			(memcmp(pbBuffer1, pbBuffer2, dwRead) != 0))
		{
			DumpBuffers(pbBuffer1, dwRead, pbBuffer2, dwRead);
			hr = S_FALSE;
			goto Cleanup;
		}

		dwLen2 -= dwRead;
		pbBuffer2 += dwRead;
		dwTotalRead += dwRead;
		
	} while (dwRead);

Cleanup:
	if (hFile != INVALID_HANDLE_VALUE)
		CloseHandle(hFile);
	return(hr);
Error:
	hr = HRESULT_FROM_WIN32(GetLastError());
	goto Cleanup;
}

HRESULT HrTruncateFile(char *szFile, long lBytesToCut)
{
	HRESULT	hr = S_OK;
	HANDLE	hFile = INVALID_HANDLE_VALUE;

	hFile = CreateFile(szFile, GENERIC_WRITE, FILE_SHARE_READ, NULL,
				OPEN_EXISTING, 0, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
		goto Error;

	if (SetFilePointer(hFile, -lBytesToCut, NULL, FILE_END) == 
				INVALID_SET_FILE_POINTER)
		goto Error;

	if (!SetEndOfFile(hFile))
		goto Error;

Cleanup:
	if (hFile != INVALID_HANDLE_VALUE)
		CloseHandle(hFile);
	return(hr);
Error:
	hr = HRESULT_FROM_WIN32(GetLastError());
	goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\cxonline\cxonline.cpp ===
// ---------------------------------------------------------------------------------------
// conline.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include <windows.h>
#include <xbox.h>
#include <winsockx.h>
#include <winsockp.h>
#include <xonlinep.h>
#include <stdlib.h>
#include <stdio.h>

#include <OnlineAccounts.h>

__forceinline void DbgBreak()
{
    _asm int 3;
}

#define Verify(x) do { if (!(x)) DbgBreak(); } while (0)

#ifdef _XBOX
int __cdecl main(int argc, char * argv[])
#else
class CTestXOnline : public COnlineAccounts
{
private:
    CTestXOnline(char * pszXbox = NULL) : COnlineAccounts(pszXbox) {}

	static CTestXOnline* m_pInstance;

public:
    int Main(int argc, char * argv[]);

	static CTestXOnline* Instance( LPSTR szName = NULL ) {
		if ( NULL == m_pInstance )
		{
			m_pInstance = new CTestXOnline( szName );
			ASSERT( m_pInstance );
		}

		return m_pInstance;
	}

	~CTestXOnline( void ) { delete m_pInstance; }
		
};

CTestXOnline* CTestXOnline::m_pInstance = NULL;

int __cdecl main(int argc, char * argv[])
{
    int result = 0;
    char buffer[128];

    sprintf(buffer, "%s@Nic/0", getenv("COMPUTERNAME") );
    //CTestXOnline * pTestXOnline = new CTestXOnline(buffer);
    //pTestXOnline->Main(argc, argv);
	CTestXOnline::Instance(buffer)->Main( argc, argv );
    //delete pTestXOnline;
    return(result);
}

int CTestXOnline::Main(int argc, char * argv[])
#endif
{
    HANDLE hEventWorkAvailable;
    HRESULT hr, hrTask = XONLINETASK_S_SUCCESS;
    XONLINE_USER users[XONLINE_MAX_STORED_ONLINE_USERS];
    DWORD cUsers;
	XONLINETASK_HANDLE hTask;
    DWORD aServices[] = {
        XONLINE_BILLING_OFFERING_SERVICE,
        XONLINE_USER_ACCOUNT_SERVICE,
        XONLINE_AUTO_UPDATE_SERVICE,
        XONLINE_MATCHMAKING_SERVICE,
        };

    printf("Testing CTestXOnline");

    hr = XOnlineStartup(NULL);
    Verify(hr == S_OK);

	hEventWorkAvailable = CreateEvent(NULL, FALSE, FALSE, NULL);
	Verify(hEventWorkAvailable != NULL);

    RtlZeroMemory( users, sizeof(users) );

	hr = COnlineAccounts::Instance()->PopulateUserAccountsHD( NULL, 1 );
	Verify( hr == S_OK );
	
    hr = XOnlineGetUsers( &users[0], &cUsers );
    Verify(hr == S_OK);

    hr = XOnlineLogon(users, aServices, sizeof(aServices)/sizeof(DWORD), hEventWorkAvailable, &hTask);
    Verify(hr == S_OK);

    //
	// Pump until logon task completes
	//
	do
	{
	    Sleep(10);
	    
	    WaitForSingleObject(hEventWorkAvailable, INFINITE);

        ResetEvent( hEventWorkAvailable );
        
		hr = XOnlineTaskContinue(hTask);

	} while (hr == XONLINETASK_S_RUNNING);

    hrTask = hr;

    hr = XOnlineTaskClose(hTask);
    Verify(hr == S_OK);

    hr = XOnlineCleanup();
    Verify(hr == S_OK);

    if (FAILED(hrTask))
        printf(" [FAILED %08lX]\n", hrTask);
    else
        printf(" [OK]\n");

    return (FAILED(hrTask));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\cxonline\sources.inc ===
TARGETPATH=obj
TARGETTYPE=PROGRAM
TARGETNAME=cxonline
USE_LIBCMT=1

MSC_WARNING_LEVEL=/W3 /WX /Ob1

!if defined(GENASM)
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /Fa
!endif

!if $(FREEBUILD) == 0
MSC_OPTIMIZATION=/Odi /Ob1
!endif

LINKER_FLAGS=$(LINKER_FLAGS) /map /IGNORE:4099

SOURCES=\
    cxonline.cpp \
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\dftest\xmain.cpp ===
/*++

Copyright (c) Microsoft Corporation

Author:
    Keith Lau (keithlau)

Description:
	Unit test shell for asynchronous XOnlineDownloadFile

Module Name:

    xmain.c

--*/

#include "xonp.h"
#include "testutil.h"
#include "testui.h"

#define DOWNLOAD_LOCATION		"/xboxfiles/%s"
#define LOCAL_PATH				"t:\\test\\%s"
#define REFERENCE_PATH			"t:\\ref\\%s"

#define MAX_DOWNLOAD_FILES		3

char *rgszFilenames[] =
{
	"wincrypt.h", "xmain.c", "xnetacc.c", "makefile", "asyncxrl.c"
};

DWORD rgdwFileSizes[] = 
{
	576501, 7616, 75968, 247, 56283
};

DWORD	dwPumpCalls = 0;

#define NUM_SERVICES	1
DWORD			g_rgServices[NUM_SERVICES] =
{
	XONLINE_USER_ACCOUNT_SERVICE
};

//======================== The main function
void __cdecl main()
{
    HRESULT				hr;

	XONLINETASK_HANDLE	rghTask[] = { NULL, NULL, NULL, NULL, NULL };
	CHAR				szPath[MAX_PATH];
	CHAR				szReference[MAX_PATH];
	CHAR				szDownloadLocation[MAX_PATH];
	CHAR				szTime1[MAX_TIME_SIZE];
	CHAR				szTime2[MAX_TIME_SIZE];
    DWORD				dwCurTask = 0;
    DWORD				dwIterations = 0;
    DWORD				i;

    WSADATA				WsaData;
	DWORD				dwError;

	DWORD				dwStatus;
	DWORD				cbBuffer;
	FILETIME			ftTime;
	FILETIME			ftLastModified;
	ULARGE_INTEGER		uliContentLength;
	ULARGE_INTEGER		uliTotalReceived;

	HANDLE				hEventWorkAvailable = NULL;

	PBYTE				pbBuffer1 = NULL;
	PBYTE				pbBuffer2 = NULL;

	DWORD				dwInitialized;
    XONLINETASK_HANDLE	hLogon;

	XNetStartupParams	xnsp;

    _asm int 3;

    DebugPrint("Loading XBox network stack...\n");

    ZeroMemory(&xnsp, sizeof(XNetStartupParams));
    xnsp.cfgSizeOfStruct = sizeof(XNetStartupParams);
    xnsp.cfgFlags = XNET_STARTUP_BYPASS_SECURITY;

    dwError = XNetStartup(&xnsp);
    if (dwError != NO_ERROR)
    {
            DebugPrint("Failed XNetStartup with %d\n", dwError);
        return;
    }
    
	XONLINE_STARTUP_PARAMS	xosp = { 0 };
	
    DebugPrint("Calling XOnlineStartup...\n");
    hr = XOnlineStartup(&xosp);
    if (FAILED(hr))
    {
        DebugPrint("Error %08x returned by XOnlineStartup\n", hr);
    	_asm int 3;
        return;
    }

	pbBuffer1 = (PBYTE)LocalAlloc(LMEM_FIXED, 2048);
	if (!pbBuffer1)
	{
        DebugPrint("Cannot allocate memory (%u)\n", GetLastError());
        return;
	}
	pbBuffer2 = (PBYTE)LocalAlloc(LMEM_FIXED, 2048);
	if (!pbBuffer2)
	{
        DebugPrint("Cannot allocate memory (%u)\n", GetLastError());
        return;
	}

	// Create the work event
	hEventWorkAvailable = CreateEvent(NULL, FALSE, FALSE, NULL);
	if (hEventWorkAvailable == NULL)
	{
        DebugPrint("Cannot create work event (%u)\n", GetLastError());
        return;
	}

	// Initialize services
	hr = XOnlineLogonWrapper(g_rgServices, NUM_SERVICES, &hLogon);
	if (FAILED(hr))
	{
        DebugPrint("Cannot Logon (%08x), check c:\\xonline.ini\n", hr);
        AssertSz(SUCCEEDED(hr), "Failed to initialize services");
        return;
	}
	
	// Create out WriteFile thread
	// hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL);

	// Loop downloading files
	while (1)
	{
		dwIterations++;

		// Start the task if completed
		if (!rghTask[dwCurTask])
		{
			// Download the local file
			sprintf(szPath, LOCAL_PATH, rgszFilenames[dwCurTask]);
			sprintf(szDownloadLocation, DOWNLOAD_LOCATION, rgszFilenames[dwCurTask]);
			
		    hr = XOnlineDownloadFile(
		    			XONLINE_USER_ACCOUNT_SERVICE, 
		    			szDownloadLocation, NULL, 
		    			65536, (PBYTE) NULL, 0, 0, szPath, 
		    			0, hEventWorkAvailable, 
 		    			&(rghTask[dwCurTask]));

		    DebugPrint("Downloading %s  (hTask = %p)\n", 
		    			szDownloadLocation, rghTask[dwCurTask]);
		    
	    	AssertSz(SUCCEEDED(hr), "Cannot start download");
		    Assert(rghTask[dwCurTask] != NULL);
		}

		// Continue if required
		if (rghTask[dwCurTask])
		{
			hr = XOnlineTaskContinue(rghTask[dwCurTask]);
			if (XONLINETASK_STATUS_AVAILABLE(hr))
			{
				// Download complete ...
				hr = XOnlineDownloadGetResults(rghTask[dwCurTask], NULL, 
							&cbBuffer, &uliTotalReceived,
							&uliContentLength,
							&dwStatus, &ftTime, &ftLastModified);
			    Assert(SUCCEEDED(hr));

				i = sizeof(szTime1); 
    			ConvertFileTimeAsString(szTime1, &i, &ftTime);
				i = sizeof(szTime2); 
    			ConvertFileTimeAsString(szTime2, &i, &ftLastModified);

				sprintf(szPath, LOCAL_PATH, rgszFilenames[dwCurTask]);
				sprintf(szReference, REFERENCE_PATH, rgszFilenames[dwCurTask]);

			    DebugPrint("[%3u] %s, %I64u bytes. Time: %s   Last modified: %s", 
			    			dwStatus, szPath, uliContentLength.QuadPart, szTime1, szTime2);

				// Make sure reference file and downloaded file match
				hr = HrFileCompare(szPath, szReference, pbBuffer1, pbBuffer2, 2048);

		    	AssertSz(hr == S_OK, "Files dont match");

				// Truncate file and redo
				if (dwIterations & 1)
				{
					hr = HrTruncateFile(szPath, rgdwFileSizes[dwCurTask] >> 1);
				}
				else
				{
					hr = S_OK;
					if (!DeleteFile(szPath))
						hr = HRESULT_FROM_WIN32(GetLastError());
				}
				
		    	AssertSz(SUCCEEDED(hr), "Cannot truncate/delete file");

				// Close the handle
				XOnlineTaskClose(rghTask[dwCurTask]);
				rghTask[dwCurTask] = NULL;
			}
		}

		// Next Task
		dwCurTask++;
		if (dwCurTask >= MAX_DOWNLOAD_FILES)
			dwCurTask = 0;
	}

    DebugPrint("Unloading XOnline ...\n");
    XOnlineCleanup();

	// Break here
	_asm int 3;

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\cryptotest\aes.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    aes.h

Abstract:

    This module contains the public data structures and API definitions
    needed to utilize the low-level AES encryption routines


Author:

    Scott Field (SField) 09-October-2000

Revision History:

--*/


#ifndef __AES_H__
#define __AES_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

#ifdef __cplusplus
extern "C" {
#endif


#define AES_MAXROUNDS   (14)

typedef struct {
    int             rounds; // keytab data ends up padded.
    unsigned char   keytabenc[AES_MAXROUNDS+1][4][4];
    unsigned char   keytabdec[AES_MAXROUNDS+1][4][4];
} AESTable;

#define CRYPT_AES128_ROUNDS             10
#define CRYPT_AES192_ROUNDS             12
#define CRYPT_AES256_ROUNDS             14

#define AES_TABLESIZE   (sizeof(AESTable))
#define AES_BLOCKLEN    (16)
#define AES_KEYSIZE     (32)


void
RSA32API
aes(
    BYTE    *pbOut,
    BYTE    *pbIn,
    void    *keyin,
    int     op
    );

void
RSA32API
aeskey(
    AESTable    *KeyTable,
    BYTE        *Key,
    int         rounds
    );



#ifdef __cplusplus
}
#endif

#endif // __AES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\dtmtest\xmain.cpp ===
/*++

Copyright (c) Microsoft Corporation

Author:
    Keith Lau (keithlau)

Description:
	Unit test shell for asynchronous XOnlineDownloadToMemory

Module Name:

    xmain.c

--*/

#include "xonp.h"
#include "testutil.h"
#include "testui.h"

#define DOWNLOAD_LOCATION		"/xboxfiles/%s"
#define REFERENCE_PATH			"t:\\ref\\%s"

#define MAX_DOWNLOAD_FILES		3

char *rgszFilenames[] =
{
	"asyncxrl.c", "makefile", "xmain.c", 
};

DWORD rgdwFileSizes[] = 
{
	56283, 247, 7616, 
};

#define NUM_SERVICES	1
DWORD			g_rgServices[NUM_SERVICES] =
{
	XONLINE_USER_ACCOUNT_SERVICE
};

//======================== The main function
void __cdecl main()
{
    HRESULT				hr;

	XONLINETASK_HANDLE	rghTask[] = { NULL, NULL, NULL, NULL, NULL };
	CHAR				szReference[MAX_PATH];
	CHAR				szDownloadLocation[MAX_PATH];
	CHAR				szTime1[MAX_PATH];
	CHAR				szTime2[MAX_PATH];
    DWORD				dwCurTask = 0;
    DWORD				dwIterations = 0;
    DWORD				i;

    WSADATA				WsaData;
	DWORD				dwError;

	DWORD				dwStatus;
	DWORD				cbBuffer;
	FILETIME			ftTime;
	FILETIME			ftLastModified;
	ULARGE_INTEGER		uliContentLength;
	ULARGE_INTEGER		uliTotalReceived;

	HANDLE				hEventWorkAvailable = NULL;

	PBYTE				pbBuffer = NULL;
	PBYTE				pbDownload = NULL;

	DWORD				dwDownloaded = 0;

	DWORD				dwInitialized;
    XONLINETASK_HANDLE	hLogon;

	XNetStartupParams	xnsp;

    _asm int 3;

    DebugPrint("Loading XBox network stack...\n");

    ZeroMemory(&xnsp, sizeof(XNetStartupParams));
    xnsp.cfgSizeOfStruct = sizeof(XNetStartupParams);
    xnsp.cfgFlags = XNET_STARTUP_BYPASS_SECURITY;

    dwError = XNetStartup(&xnsp);
    if (dwError != NO_ERROR)
    {
            DebugPrint("Failed XNetStartup with %d\n", dwError);
        return;
    }
	
	XONLINE_STARTUP_PARAMS	xosp = { 0 };
	
    DebugPrint("Calling XOnlineStartup...\n");
    hr = XOnlineStartup(&xosp);
    if (FAILED(hr))
    {
        DebugPrint("Error %08x returned by XOnlineStartup\n", hr);
    	_asm int 3;
        return;
    }

	pbBuffer = (PBYTE)LocalAlloc(LMEM_FIXED, 2048);
	if (!pbBuffer)
	{
        DebugPrint("Cannot allocate memory (%u)\n", GetLastError());
        return;
	}

	// Create the work event
	hEventWorkAvailable = CreateEvent(NULL, FALSE, FALSE, NULL);
	if (hEventWorkAvailable == NULL)
	{
        DebugPrint("Cannot create work event (%u)\n", GetLastError());
        return;
	}

	// Initialize services
	hr = XOnlineLogonWrapper(g_rgServices, NUM_SERVICES, &hLogon);
	if (FAILED(hr))
	{
        DebugPrint("Cannot Logon (%08x), check c:\\xonline.ini\n", hr);
        AssertSz(SUCCEEDED(hr), "Failed to initialize services");
        return;
	}

	// Create out WriteFile thread
	// hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL);

	// Loop downloading files
	while (1)
	{
		dwIterations++;

		// Start the task if completed
		if (!rghTask[dwCurTask])
		{
			// Download the local file
			sprintf(szDownloadLocation, DOWNLOAD_LOCATION, rgszFilenames[dwCurTask]);
			
		    hr = XOnlineDownloadToMemory(
		    			XONLINE_USER_ACCOUNT_SERVICE, 
		    			szDownloadLocation, NULL, 65536, 
		    			(PBYTE) NULL, 0,
		    			0, hEventWorkAvailable, &(rghTask[dwCurTask]));

		    DebugPrint("Downloading %s  (hTask = %p)\n", 
		    			szDownloadLocation, rghTask[dwCurTask]);
		    
	    	AssertSz(SUCCEEDED(hr), "Cannot start download");
		    Assert(rghTask[dwCurTask] != NULL);
		}

		// Continue if required
		if (rghTask[dwCurTask])
		{
			hr = XOnlineTaskContinue(rghTask[dwCurTask]);
			if (XONLINETASK_STATUS_AVAILABLE(hr))
			{
				dwDownloaded++;
			
				// Download complete ...
				hr = XOnlineDownloadGetResults(rghTask[dwCurTask], &pbDownload, 
							&cbBuffer, &uliTotalReceived,
							&uliContentLength,
							&dwStatus, &ftTime, &ftLastModified);
			    Assert(SUCCEEDED(hr));

				i = sizeof(szTime1); 
    			ConvertFileTimeAsString(szTime1, &i, &ftTime);
				i = sizeof(szTime2); 
    			ConvertFileTimeAsString(szTime2, &i, &ftLastModified);

				sprintf(szReference, REFERENCE_PATH, rgszFilenames[dwCurTask]);

			    DebugPrint("[%3u] %s, %I64u bytes. Time: %s   Last modified: %s", 
			    			dwStatus, rgszFilenames[dwCurTask], uliContentLength.QuadPart, 
			    			szTime1, szTime2);

				// Make sure reference file and downloaded file match
				hr = HrFileCompareWithBuffer(szReference, pbBuffer, 2048, 
							pbDownload, uliContentLength.u.LowPart);

		    	AssertSz(hr == S_OK, "Files dont match");

				// Close the handle
				XOnlineTaskClose(rghTask[dwCurTask]);
				rghTask[dwCurTask] = NULL;
			}
		}

		// Next Task
		dwCurTask++;
		if (dwCurTask >= MAX_DOWNLOAD_FILES)
			dwCurTask = 0;
	}

    DebugPrint("Unloading XOnline ...\n");
    XOnlineCleanup();
 
	// Break here
	_asm int 3;

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\cryptotest\cryptotest.cpp ===
extern "C" {
    #include <ntos.h>
    #include <init.h>
    #include <hal.h>
    #include <nturtl.h>
    #include <xtl.h>
    #include <xboxp.h>
    #include <xdbg.h>
    #include <phy.h>
    #include <xbeimage.h>
    #include <ldr.h>
};
#include <sha.h>
#include <rc4.h>
#include <rsa.h>
#include <des.h>
#include <tripldes.h>
#include <modes.h>
#include "xcrypt.h"
#include <malloc.h>

#if DBG
extern "C" ULONG XDebugOutLevel;
#endif

//#define AESTEST 1

#ifdef AESTEST
#include "aes.h"
#endif

#define SHA_TEST_LENGTH 64
#define SHA_KA_LENGTH1 3
#define SHA_KA_LENGTH2 56
// #define SHA_KA_LENGTH3 1000000
#define SHA_KA_DIG_LEN 20
#define SHA_REPEAT_LOOP 50000

BOOL shatest()
{
	BYTE text[SHA_TEST_LENGTH];
	BYTE digest[A_SHA_DIGEST_LEN];
	BYTE shaDigest[XC_SERVICE_DIGEST_SIZE];
	A_SHA_CTX ctxt;
	BYTE shaCtxt[XC_SERVICE_SHA_CONTEXT_SIZE];
	DWORD dwStart,dwEnd,i;

	UCHAR ka_txt1[SHA_KA_LENGTH1] = {'a', 'b', 'c'};
	BYTE ka_digest1[SHA_KA_DIG_LEN] = {0xA9, 0x99, 0x3E, 0x36, 0x47, 0x06, 0x81, 0x6A, 0xBA, 0x3E, 0x25, 0x71, 0x78, 0x50, 0xC2, 0x6C, 0x9C, 0xD0, 0xD8, 0x9D};
	UCHAR ka_txt2[SHA_KA_LENGTH2] = {'a', 'b', 'c', 'd', 'b', 'c', 'd', 'e', 'c', 'd', 'e', 'f', 'd', 'e', 'f', 'g', 'e', 'f', 'g', 'h', 
	    'f', 'g', 'h', 'i', 'g', 'h', 'i', 'j', 'h', 'i', 'j', 'k', 'i', 'j', 'k', 'l', 'j', 'k', 'l', 'm', 'k', 'l', 'm', 'n', 'l', 'm', 'n', 'o', 'm', 'n', 'o', 'p', 'n', 'o', 'p', 'q'};
	BYTE ka_digest2[SHA_KA_DIG_LEN] = {0x84, 0x98, 0x3E, 0x44, 0x1C, 0x3B, 0xD2, 0x6E, 0xBA, 0xAE, 0x4A, 0xA1, 0xF9, 0x51, 0x29, 0xE5, 0xE5, 0x46, 0x70, 0xF1};
//	UCHAR ka_txt3[SHA_KA_LENGTH3];
//	BYTE ka_digest3[SHA_KA_DIG_LEN] = {0x34, 0xAA, 0x97, 0x3C, 0xD4, 0xC4, 0xDA, 0xA4, 0xF6, 0x1E, 0xEB, 0x2B, 0xDB, 0xAD, 0x27, 0x31, 0x65, 0x34, 0x01, 0x6F};
    
    ASSERT( sizeof(ctxt) == XC_SERVICE_SHA_CONTEXT_SIZE );
    
    ASSERT( A_SHA_DIGEST_LEN == XC_SERVICE_DIGEST_SIZE );
    ASSERT( SHA_KA_DIG_LEN == XC_SERVICE_DIGEST_SIZE );

/*    for (i=0; i<SHA_KA_LENGTH3; i++)
        ka_txt3[i] = 'a'; */
    
	XNetRandom( text, SHA_TEST_LENGTH );
	RtlZeroMemory( &ctxt, XC_SERVICE_SHA_CONTEXT_SIZE );
	RtlZeroMemory( shaCtxt, XC_SERVICE_SHA_CONTEXT_SIZE );

    dwStart = GetTickCount();
    for(i=0; i<SHA_REPEAT_LOOP; ++i)
    {
        A_SHAInit( &ctxt );
        XcSHAInit( shaCtxt );
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("XcSHAInit", "%d times took %d ms", SHA_REPEAT_LOOP * 2, dwEnd );
    
    if (memcmp( shaCtxt, &ctxt, XC_SERVICE_SHA_CONTEXT_SIZE ) != 0)
    {
        XDBGWRN("Crypto Test", " XcSHAInit result compare failed!");
        return FALSE;
    }
    
    dwStart = GetTickCount();
    for(i=0; i<SHA_REPEAT_LOOP; ++i)
    {
        XcSHAUpdate( shaCtxt, text, SHA_TEST_LENGTH );
        A_SHAUpdate( &ctxt, text, SHA_TEST_LENGTH );
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("XcSHAUpdate", "%d bytes took %d ms", SHA_REPEAT_LOOP * 2 * SHA_TEST_LENGTH, dwEnd );
    
    if (memcmp( shaCtxt, &ctxt, XC_SERVICE_SHA_CONTEXT_SIZE ) != 0)
    {
        XDBGWRN("Crypto Test", " XcSHAUpdate result compare failed!");
        return FALSE;
    }
    
    dwStart = GetTickCount();
    for(i=0; i<SHA_REPEAT_LOOP; ++i)
    {
        XcSHAFinal( shaCtxt, shaDigest );
        A_SHAFinal( &ctxt, digest );
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("XcSHAFinal", "%d times took %d ms", SHA_REPEAT_LOOP * 2, dwEnd );
    
    if (memcmp( shaDigest, digest, XC_SERVICE_DIGEST_SIZE ) != 0)
    {
        XDBGWRN("Crypto Test", " XcSHAFinal result compare failed!");
        return FALSE;
    }

    XcSHAInit( shaCtxt );
    XcSHAUpdate( shaCtxt, ka_txt1, SHA_KA_LENGTH1 );
    XcSHAFinal( shaCtxt, shaDigest );
    if (memcmp( shaDigest, ka_digest1, XC_SERVICE_DIGEST_SIZE ) != 0)
    {
        XDBGWRN("Crypto Test", " SHA known answer test 1 compare failed!");
        return FALSE;
    }

    XcSHAInit( shaCtxt );
    XcSHAUpdate( shaCtxt, ka_txt2, SHA_KA_LENGTH2 );
    XcSHAFinal( shaCtxt, shaDigest );
    if (memcmp( shaDigest, ka_digest2, XC_SERVICE_DIGEST_SIZE ) != 0)
    {
        XDBGWRN("Crypto Test", " SHA known answer test 2 compare failed!");
        return FALSE;
    }

/*    XcSHAInit( shaCtxt );
    XcSHAUpdate( shaCtxt, ka_txt3, SHA_KA_LENGTH3 );
    XcSHAFinal( shaCtxt, shaDigest );
    if (memcmp( shaDigest, ka_digest3, XC_SERVICE_DIGEST_SIZE ) != 0)
    {
        XDBGWRN("Crypto Test", " SHA known answer test 3 compare failed!");
        return FALSE;
    } */
    
    return TRUE;
}

#define RC4_KEY_TEST_LENGTH 16

#define RC4_TEST_LENGTH 64

#define RC4_REPEAT_LOOP 50000

BOOL rc4test()
{
	BYTE key[RC4_KEY_TEST_LENGTH];
	BYTE text[RC4_TEST_LENGTH];
	BYTE text2[RC4_TEST_LENGTH];
	RC4_KEYSTRUCT keyStruct;
	BYTE pbkeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];
	DWORD dwStart,dwEnd,i;
    
    ASSERT( sizeof(keyStruct) == XC_SERVICE_RC4_KEYSTRUCT_SIZE );
    
	XNetRandom( key, RC4_KEY_TEST_LENGTH );
	XNetRandom( text, RC4_TEST_LENGTH );
    memcpy( text2, text, RC4_TEST_LENGTH );
    
    dwStart = GetTickCount();
    for(i=0; i<RC4_REPEAT_LOOP; ++i)
    {
        rc4_key( &keyStruct, RC4_KEY_TEST_LENGTH, key );
        XcRC4Key( pbkeyStruct, RC4_KEY_TEST_LENGTH, key );
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("XcRC4Key", "%d times for %d byte key took %d ms", RC4_REPEAT_LOOP * 2, RC4_KEY_TEST_LENGTH, dwEnd );
    
    if (memcmp( pbkeyStruct, &keyStruct, XC_SERVICE_RC4_KEYSTRUCT_SIZE ) != 0)
    {
        XDBGWRN("Crypto Test", " XcRC4Key result compare failed!");
        return FALSE;
    }
    
    dwStart = GetTickCount();
    for(i=0; i<RC4_REPEAT_LOOP; ++i)
    {
        XcRC4Crypt( pbkeyStruct, RC4_TEST_LENGTH, text );
        rc4( &keyStruct, RC4_TEST_LENGTH, text2 );
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("XcRC4Crypt", "%d bytes took %d ms", RC4_REPEAT_LOOP * 2 * RC4_TEST_LENGTH, dwEnd );
    
    if (memcmp( text, text2, RC4_TEST_LENGTH ) != 0)
    {
        XDBGWRN("Crypto Test", " XcRC4Crypt result compare failed!");
        return FALSE;
    }
    
    if (memcmp( pbkeyStruct, &keyStruct, XC_SERVICE_RC4_KEYSTRUCT_SIZE ) != 0)
    {
        XDBGWRN("Crypto Test", " XcRC4Crypt key struct result compare failed!");
        return FALSE;
    }
    
    return TRUE;
}

BYTE PrivateKeyData[] = 
    {
           0x52,0x53,0x41,0x32,0x08,0x01,0x00,0x00,
           0x00,0x08,0x00,0x00,0xFF,0x00,0x00,0x00,
           0x01,0x00,0x01,0x00,0xA7,0xC1,0xB4,0xFE,
           0x8C,0x26,0x9A,0xCF,0xEC,0xDB,0x9F,0xAA,
           0xF0,0xCF,0x82,0xB8,0xCE,0x0E,0xD8,0x22,
           0x6D,0xDA,0x49,0xD6,0x8A,0x1C,0xFD,0x5E,
           0xAD,0xB4,0xA0,0x3E,0xA6,0xEA,0xB6,0x20,
           0xF0,0xB9,0x2C,0xC3,0x48,0x48,0x1E,0xD2,
           0x2B,0x22,0xA0,0xAF,0xA8,0x3E,0x41,0x95,
           0xB8,0x3D,0x04,0xBF,0x9E,0x58,0x3D,0x7C,
           0xF5,0x92,0x2E,0x0C,0xFD,0x85,0x67,0xC3,
           0xB2,0xE7,0x33,0x7F,0x7E,0x46,0xFC,0x2A,
           0x10,0x77,0xB4,0xB6,0x7B,0x2B,0x7C,0x70,
           0x70,0x33,0x94,0x51,0x0F,0x64,0x9E,0x1A,
           0x37,0x4D,0x5C,0x49,0xB9,0x7E,0xCE,0x1D,
           0x47,0xC7,0x72,0x90,0x61,0xC4,0xEE,0xEF,
           0xF6,0x2C,0x47,0x36,0xCD,0x4B,0x23,0x96,
           0xB2,0x24,0x2C,0xC5,0x6D,0x62,0x08,0x43,
           0x3E,0x16,0xB8,0x86,0x32,0xF3,0x12,0x91,
           0xA2,0xF4,0x42,0x19,0xCC,0xC5,0x5E,0x9C,
           0x75,0x25,0x9C,0x84,0x5A,0xBC,0xE0,0xCE,
           0x15,0x62,0xD5,0xCE,0x3E,0x30,0x1C,0x48,
           0xFA,0x1E,0x67,0xE9,0x06,0xA5,0x9E,0x9C,
           0xAB,0xEE,0x16,0xAA,0x44,0x9D,0x56,0x35,
           0xCA,0xD9,0x5A,0xC4,0xFB,0xA4,0x9A,0x39,
           0xE4,0xFD,0x8B,0x58,0xF1,0xE8,0x0C,0x45,
           0x76,0x80,0x7E,0xBB,0x57,0x68,0x32,0xC9,
           0x9C,0x3E,0x67,0x55,0x28,0xBD,0xB9,0xB4,
           0x6D,0x64,0xF1,0xB6,0x11,0x6B,0x0D,0xE9,
           0xF2,0x04,0x08,0xDB,0x2B,0x42,0x9C,0xC5,
           0x17,0x0D,0x86,0xE9,0x40,0x32,0x75,0x6E,
           0x51,0x7D,0xF6,0x4C,0x7E,0xA8,0x97,0x3A,
           0x95,0x31,0x20,0x7A,0x66,0xBF,0xE2,0x79,
           0xCF,0xC5,0x4A,0xA1,0xDF,0x9A,0x1E,0x52,
           0x8C,0x2B,0xF9,0xAB,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x49,0xFB,0xD0,0x56,
           0x36,0x69,0xEF,0x00,0x98,0x35,0x83,0x42,
           0x42,0xF9,0x14,0x52,0x81,0xF7,0xA9,0x8E,
           0x57,0x95,0xE9,0xA8,0xD6,0x01,0x8B,0x84,
           0x55,0xE9,0xEF,0x2E,0xCC,0x94,0x50,0x11,
           0x97,0x10,0x9E,0xF3,0x18,0xC3,0xAB,0x6E,
           0x04,0x08,0x90,0xD8,0x9D,0x97,0x04,0x37,
           0xB3,0x7E,0x57,0x1C,0xA3,0x97,0xE5,0x5B,
           0x85,0x18,0x8C,0xD2,0xAC,0xE8,0x97,0xF3,
           0x7A,0x19,0xCC,0x93,0xC1,0xCC,0xAE,0x53,
           0x6E,0xCE,0xFC,0x18,0xE3,0xAA,0xB3,0x26,
           0x72,0xA2,0x48,0x52,0xD0,0xCE,0xB2,0xC9,
           0x61,0x8D,0x15,0xB3,0xF7,0xF4,0x9A,0x7B,
           0xF6,0x85,0x93,0xF6,0xCF,0xDD,0x04,0xCA,
           0xC8,0x9A,0xCA,0x40,0xDA,0x9F,0x5D,0x9C,
           0x49,0x43,0x41,0x89,0xB8,0x4C,0xB6,0x0C,
           0x3D,0xE3,0x8F,0xDA,0x00,0x00,0x00,0x00,
           0x6F,0x65,0x54,0xDB,0x9B,0x37,0x53,0xF2,
           0x5C,0xEF,0x3F,0x49,0x5F,0xAC,0x41,0xA9,
           0xAB,0xE4,0x9F,0x49,0xA3,0x1E,0x84,0xEB,
           0x4A,0x8D,0xED,0xBB,0x12,0x0D,0xA4,0xF9,
           0x72,0x3E,0xE3,0x28,0x92,0x44,0xE4,0x1C,
           0x18,0xFF,0xC3,0xCB,0xCE,0xBD,0x78,0x96,
           0x54,0x0B,0x93,0xCF,0x52,0x47,0x0A,0x5C,
           0xD6,0xC6,0x38,0xA1,0xBE,0x22,0x48,0x8A,
           0x36,0xCD,0x79,0x1B,0x4C,0xB2,0xB2,0x84,
           0x7E,0x35,0x22,0x2D,0x3C,0xB6,0xF1,0x10,
           0x73,0x06,0x72,0x0C,0xD8,0x40,0xC6,0xE2,
           0x82,0xD5,0x47,0xF8,0x45,0x02,0xC9,0xA0,
           0x91,0xF6,0x21,0x34,0x52,0x6B,0xEB,0x73,
           0x42,0x11,0xA4,0x1E,0x08,0x6B,0xD2,0x8A,
           0x76,0xE3,0xFA,0x85,0xA8,0x7F,0x89,0xDF,
           0xEB,0xE8,0x4F,0x51,0xB0,0x54,0x6E,0xC9,
           0x00,0x00,0x00,0x00,0xF1,0x60,0x2C,0x21,
           0xB9,0xEE,0x5A,0x12,0x18,0xED,0x07,0x9E,
           0x0D,0x10,0xFC,0x3C,0x72,0xCD,0x5B,0x10,
           0xE2,0xC2,0x11,0x94,0x94,0x3C,0x6A,0xCE,
           0x7C,0xD0,0x52,0x07,0x32,0x6B,0xEF,0xAA,
           0x7A,0x4B,0xD6,0x3A,0x18,0x35,0xE8,0x2B,
           0xFE,0xE9,0x0D,0xF5,0x11,0x01,0xD1,0x4C,
           0x24,0x0B,0xC4,0xC7,0x6A,0xF3,0x26,0xB8,
           0x6E,0x17,0x4F,0xA0,0x61,0x54,0x85,0x4B,
           0x84,0x6C,0xDD,0x94,0xAC,0x60,0x07,0xD8,
           0x78,0xCD,0xFD,0x78,0x33,0xC7,0xB2,0xD1,
           0xF1,0x7A,0xBE,0x5F,0xA9,0x99,0x0F,0xE9,
           0x1B,0xF9,0x95,0x17,0xBB,0xF7,0x41,0x8A,
           0x84,0xA5,0x3B,0xA0,0xC3,0xBD,0x62,0xC4,
           0x16,0xC3,0x56,0x5C,0xCE,0xDE,0x86,0xD9,
           0xB3,0xB3,0x10,0xB5,0x10,0xEE,0x5A,0xE1,
           0xB6,0x95,0xF4,0x1F,0x00,0x00,0x00,0x00,
           0xF9,0x91,0xAE,0xCD,0x61,0xA5,0x8B,0xD4,
           0xDA,0x1F,0xC2,0x97,0x91,0x72,0x22,0x55,
           0xF7,0x4F,0xAF,0x79,0x53,0x1D,0x28,0xF6,
           0x01,0xE0,0xD1,0x96,0x0F,0x0E,0x3C,0xD4,
           0x20,0x9E,0x43,0x96,0x01,0x4D,0x42,0x8C,
           0x78,0x5E,0xCC,0xE3,0xA5,0x65,0xAF,0x4A,
           0xD9,0xE4,0xBD,0x13,0x80,0xF8,0x7F,0x4B,
           0xE5,0x74,0x5C,0x51,0x0F,0xB0,0x50,0x93,
           0x8D,0xA9,0xA8,0xD2,0xEC,0x59,0x56,0x12,
           0xD9,0x18,0xC1,0x0E,0x4C,0x85,0x59,0xFE,
           0x8E,0x9B,0x0F,0x00,0x58,0xF4,0xFE,0x84,
           0x36,0x90,0x27,0x92,0xB0,0xDD,0x0F,0xB8,
           0x23,0x87,0x16,0xC8,0xD2,0x21,0x39,0x84,
           0x17,0x24,0x8F,0xB3,0x7C,0x39,0x33,0xD0,
           0xD7,0xBD,0x76,0xF2,0x8A,0xBA,0xCE,0x66,
           0xDE,0x98,0xE8,0x6A,0x2B,0x7C,0x38,0x41,
           0x00,0x00,0x00,0x00,0xE1,0x34,0x07,0x45,
           0x19,0x30,0xC0,0xC3,0xEC,0x82,0x88,0x6E,
           0x8C,0x39,0xC0,0xBA,0xAC,0x0B,0x34,0x2A,
           0x00,0xB5,0x32,0xED,0xAE,0xA0,0xAB,0x79,
           0x92,0xE7,0x61,0x67,0xA3,0xC4,0x35,0x3A,
           0x55,0x38,0x0C,0x37,0x06,0xE9,0xE1,0x34,
           0x12,0x41,0xEA,0xB2,0x62,0x31,0xA5,0x26,
           0x8A,0x04,0xB2,0x46,0x95,0xCB,0x48,0xCC,
           0xE4,0x81,0x7C,0x15,0x66,0x23,0x2D,0x30,
           0xD5,0xA0,0xEE,0x6D,0x2F,0x0B,0x18,0x9B,
           0xBE,0x98,0xC5,0x2A,0xDA,0x24,0x5F,0xF8,
           0xA5,0xEC,0xFB,0x83,0x76,0x2F,0x8C,0x16,
           0x21,0x4E,0xEA,0x72,0xED,0x81,0xBA,0xC0,
           0x7D,0x19,0x22,0x9A,0x01,0xF3,0x67,0x3B,
           0x01,0xB3,0x2F,0xE1,0xDB,0x4F,0xCA,0xC7,
           0x14,0x8C,0x55,0x3C,0x0B,0x0C,0xB0,0x7C,
           0x97,0xC5,0x02,0x8E,0x00,0x00,0x00,0x00,
           0x91,0x24,0x79,0x59,0x78,0x0B,0x98,0x3B,
           0x2C,0xC3,0xA5,0x1F,0x1D,0x07,0xC7,0xD6,
           0x03,0xF4,0xC6,0x2B,0x2A,0x27,0xB2,0xCB,
           0xB9,0xE8,0xDB,0xE8,0x36,0x04,0x67,0x6A,
           0xCF,0x46,0x50,0x50,0xD7,0xD3,0x24,0x98,
           0x9C,0x20,0xE1,0x26,0xE7,0x22,0x2A,0xD6,
           0x61,0xBD,0xA9,0xD2,0x86,0x81,0x44,0xAE,
           0x12,0x31,0xDB,0xEF,0xC3,0x02,0xCA,0xC1,
           0xB0,0x2F,0x8E,0x2E,0x4B,0x66,0x9A,0x8E,
           0xD9,0x93,0x43,0xF7,0x51,0x69,0x5A,0x5E,
           0x74,0x22,0xEE,0x6B,0x20,0x03,0x61,0xDD,
           0xDE,0xFD,0x72,0x8C,0xA1,0xA4,0xDC,0xAD,
           0x6F,0x99,0x62,0x8B,0xD4,0x4E,0x4C,0xAD,
           0xD8,0x89,0x72,0xD9,0xCF,0x3C,0xC4,0x19,
           0x05,0xBC,0x6A,0x8B,0x15,0x10,0x56,0x6B,
           0x5D,0x5D,0x4F,0x8F,0x26,0xDC,0x1C,0x42,
           0x62,0x16,0x66,0x0B,0x81,0xB2,0x47,0x0F,
           0xDA,0x56,0xD9,0xA5,0x96,0x1B,0x0D,0x82,
           0xEF,0x52,0x10,0x4B,0xD9,0x0A,0x67,0x28,
           0xBC,0x1F,0x8D,0x4B,0xF1,0xB2,0x87,0x00,
           0xC1,0x6E,0x0F,0x08,0xB9,0x1C,0x83,0xBA,
           0x01,0xF4,0x22,0x73,0x16,0x18,0x8B,0x1D,
           0x63,0x00,0xCC,0x78,0x6C,0xF8,0xE5,0x3B,
           0x11,0x45,0xE9,0x66,0x03,0x88,0x7A,0x51,
           0x3D,0x63,0x2A,0x49,0x9A,0xF8,0xF6,0x3D,
           0xE1,0xCB,0x8F,0x40,0x47,0x54,0x5B,0x94,
           0x86,0x2C,0x8B,0xB9,0x86,0xCA,0x0D,0x66,
           0x02,0x95,0x54,0xFD,0x76,0x55,0x32,0x20,
           0xFB,0x76,0xD2,0x36,0x39,0xAF,0x0C,0x82,
           0xDE,0x59,0x88,0xD9,0x1F,0xD2,0x68,0x20,
           0x67,0xDE,0x5A,0xC2,0x56,0x40,0x52,0xF4,
           0x9C,0x36,0xDB,0xE1,0xA7,0x9F,0x0E,0x52,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00
    };

BYTE PublicKeyData[] = 
    {
           0x52,0x53,0x41,0x31,0x08,0x01,0x00,0x00,
           0x00,0x08,0x00,0x00,0xFF,0x00,0x00,0x00,
           0x01,0x00,0x01,0x00,0xA7,0xC1,0xB4,0xFE,
           0x8C,0x26,0x9A,0xCF,0xEC,0xDB,0x9F,0xAA,
           0xF0,0xCF,0x82,0xB8,0xCE,0x0E,0xD8,0x22,
           0x6D,0xDA,0x49,0xD6,0x8A,0x1C,0xFD,0x5E,
           0xAD,0xB4,0xA0,0x3E,0xA6,0xEA,0xB6,0x20,
           0xF0,0xB9,0x2C,0xC3,0x48,0x48,0x1E,0xD2,
           0x2B,0x22,0xA0,0xAF,0xA8,0x3E,0x41,0x95,
           0xB8,0x3D,0x04,0xBF,0x9E,0x58,0x3D,0x7C,
           0xF5,0x92,0x2E,0x0C,0xFD,0x85,0x67,0xC3,
           0xB2,0xE7,0x33,0x7F,0x7E,0x46,0xFC,0x2A,
           0x10,0x77,0xB4,0xB6,0x7B,0x2B,0x7C,0x70,
           0x70,0x33,0x94,0x51,0x0F,0x64,0x9E,0x1A,
           0x37,0x4D,0x5C,0x49,0xB9,0x7E,0xCE,0x1D,
           0x47,0xC7,0x72,0x90,0x61,0xC4,0xEE,0xEF,
           0xF6,0x2C,0x47,0x36,0xCD,0x4B,0x23,0x96,
           0xB2,0x24,0x2C,0xC5,0x6D,0x62,0x08,0x43,
           0x3E,0x16,0xB8,0x86,0x32,0xF3,0x12,0x91,
           0xA2,0xF4,0x42,0x19,0xCC,0xC5,0x5E,0x9C,
           0x75,0x25,0x9C,0x84,0x5A,0xBC,0xE0,0xCE,
           0x15,0x62,0xD5,0xCE,0x3E,0x30,0x1C,0x48,
           0xFA,0x1E,0x67,0xE9,0x06,0xA5,0x9E,0x9C,
           0xAB,0xEE,0x16,0xAA,0x44,0x9D,0x56,0x35,
           0xCA,0xD9,0x5A,0xC4,0xFB,0xA4,0x9A,0x39,
           0xE4,0xFD,0x8B,0x58,0xF1,0xE8,0x0C,0x45,
           0x76,0x80,0x7E,0xBB,0x57,0x68,0x32,0xC9,
           0x9C,0x3E,0x67,0x55,0x28,0xBD,0xB9,0xB4,
           0x6D,0x64,0xF1,0xB6,0x11,0x6B,0x0D,0xE9,
           0xF2,0x04,0x08,0xDB,0x2B,0x42,0x9C,0xC5,
           0x17,0x0D,0x86,0xE9,0x40,0x32,0x75,0x6E,
           0x51,0x7D,0xF6,0x4C,0x7E,0xA8,0x97,0x3A,
           0x95,0x31,0x20,0x7A,0x66,0xBF,0xE2,0x79,
           0xCF,0xC5,0x4A,0xA1,0xDF,0x9A,0x1E,0x52,
           0x8C,0x2B,0xF9,0xAB,0x00,0x00,0x00,0x00,
           0x00,0x00,0x00,0x00
    };

#define PK_KEY_TEST_BIT_LENGTH 2048

#define PK_REPEAT_LOOP 5

BOOL pktest()
{
	BYTE* text1;
	BYTE* text2;
	BYTE* text3;
	BYTE* temp1;
	BYTE* temp2;
	BYTE* prvKey;
	BYTE* pubKey;
	DWORD pubKeySize, prvKeySize;
	DWORD bits;
	DWORD dwStart,dwEnd,i;
	DWORD keyLength,dataLength;
	DWORD result1,result2;
    LPBSAFE_PUB_KEY pPubKey = (LPBSAFE_PUB_KEY)PublicKeyData;
    
    bits = PK_KEY_TEST_BIT_LENGTH;
	result1 = BSafeComputeKeySizes( &pubKeySize, &prvKeySize, &bits );
    ASSERT( result1 );

    ASSERT( pubKeySize == sizeof(PublicKeyData) );
    ASSERT( prvKeySize == sizeof(PrivateKeyData) );

    keyLength = XcPKGetKeyLen( PublicKeyData );
    if (keyLength != pPubKey->keylen)
    {
        XDBGWRN("Crypto Test", " XcPKGetKeyLen return bad length %d!", keyLength);
        return FALSE;
    }

    dataLength = pPubKey->datalen;
    
    XDBGTRC("Crypto Test", "XcPKEncPublic Keylen = %d, datalen = %d", keyLength, dataLength);
    
	text1 = (BYTE*)_alloca( keyLength );
	text2 = (BYTE*)_alloca( keyLength );
	text3 = (BYTE*)_alloca( keyLength );
	temp1 = (BYTE*)_alloca( keyLength );
	temp2 = (BYTE*)_alloca( keyLength );

    RtlZeroMemory( text1, keyLength );
	XNetRandom( text1, dataLength );
	memcpy( text2, text1, keyLength );
	memcpy( text3, text1, keyLength );

    dwStart = GetTickCount();
    for(i=0; i<PK_REPEAT_LOOP; ++i)
    {
        result1 = XcPKEncPublic( PublicKeyData, text1, temp1 );
        result2 = BSafeEncPublic((LPBSAFE_PUB_KEY)PublicKeyData, text2, temp2);
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("XcPKEncPublic", "%d times for %d byte key took %d ms", PK_REPEAT_LOOP * 2, dataLength, dwEnd );
    
    if (!result1 || !result2)
    {
        XDBGWRN("Crypto Test", " XcPKEncPublic failed %d %d!", result1, result2);
        return FALSE;
    }
    
    if (memcmp( temp1, temp2, keyLength ) != 0)
    {
        XDBGWRN("Crypto Test", " XcPKEncPublic result compare failed!");
        return FALSE;
    }
    
    dwStart = GetTickCount();
    for(i=0; i<PK_REPEAT_LOOP; ++i)
    {
        result1 = XcPKDecPrivate( PrivateKeyData, temp1, text1 );
        result2 = BSafeDecPrivate((LPBSAFE_PRV_KEY)PrivateKeyData, temp2, text2 );
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("XcPKDecPrivate", "%d times for %d byte key took %d ms", PK_REPEAT_LOOP * 2, dataLength, dwEnd );
    
    if (!result1 || !result2)
    {
        XDBGWRN("Crypto Test", " XcPKDecPrivate failed %d %d!", result1, result2);
        return FALSE;
    }
    
    if (memcmp( text1, text2, keyLength ) != 0)
    {
        XDBGWRN("Crypto Test", " XcPKDecPrivate result compare failed!");
        return FALSE;
    }
    
    if (memcmp( text1, text3, keyLength ) != 0)
    {
        XDBGWRN("Crypto Test", " XcPKDecPrivate result compare failed!");
        return FALSE;
    }
    
    return TRUE;
}

#define DES_TEST_LENGTH 512

#define DES_REPEAT_LOOP 1000

#define DES_NUM_KA_VECTORS 19

BOOL destest()
{
	BYTE text[DES_TEST_LENGTH];
	BYTE saveText[DES_TEST_LENGTH];
	BYTE saveCText[DES_TEST_LENGTH];
	BYTE key[XC_SERVICE_DES_KEYSIZE];
	BYTE saveKey[XC_SERVICE_DES_KEYSIZE];
	BYTE iv[XC_SERVICE_DES_BLOCKLEN];
	BYTE fb[XC_SERVICE_DES_BLOCKLEN];
	DESTable desTable;
	BYTE XCDESTable[XC_SERVICE_DES_TABLESIZE];
	DWORD dwStart,dwEnd,i,j;

	BYTE ka_keys[DES_NUM_KA_VECTORS][XC_SERVICE_DES_KEYSIZE] = 
		{{0x7C, 0xA1, 0x10, 0x45, 0x4A, 0x1A, 0x6E, 0x57}, 
		 {0x01, 0x31, 0xD9, 0x61, 0x9D, 0xC1, 0x37, 0x6E}, 
		 {0x07, 0xA1, 0x13, 0x3E, 0x4A, 0x0B, 0x26, 0x86}, 
		 {0x38, 0x49, 0x67, 0x4C, 0x26, 0x02, 0x31, 0x9E}, 
		 {0x04, 0xB9, 0x15, 0xBA, 0x43, 0xFE, 0xB5, 0xB6}, 
		 {0x01, 0x13, 0xB9, 0x70, 0xFD, 0x34, 0xF2, 0xCE}, 
		 {0x01, 0x70, 0xF1, 0x75, 0x46, 0x8F, 0xB5, 0xE6}, 
		 {0x43, 0x29, 0x7F, 0xAD, 0x38, 0xE3, 0x73, 0xFE}, 
		 {0x07, 0xA7, 0x13, 0x70, 0x45, 0xDA, 0x2A, 0x16}, 
		 {0x04, 0x68, 0x91, 0x04, 0xC2, 0xFD, 0x3B, 0x2F}, 
		 {0x37, 0xD0, 0x6B, 0xB5, 0x16, 0xCB, 0x75, 0x46}, 
		 {0x1F, 0x08, 0x26, 0x0D, 0x1A, 0xC2, 0x46, 0x5E}, 
		 {0x58, 0x40, 0x23, 0x64, 0x1A, 0xBA, 0x61, 0x76}, 
		 {0x02, 0x58, 0x16, 0x16, 0x46, 0x29, 0xB0, 0x07}, 
		 {0x49, 0x79, 0x3E, 0xBC, 0x79, 0xB3, 0x25, 0x8F}, 
		 {0x4F, 0xB0, 0x5E, 0x15, 0x15, 0xAB, 0x73, 0xA7}, 
		 {0x49, 0xE9, 0x5D, 0x6D, 0x4C, 0xA2, 0x29, 0xBF}, 
		 {0x01, 0x83, 0x10, 0xDC, 0x40, 0x9B, 0x26, 0xD6}, 
		 {0x1C, 0x58, 0x7F, 0x1C, 0x13, 0x92, 0x4F, 0xEF}} ;

	BYTE ka_pts[DES_NUM_KA_VECTORS][8] = 
		{{0x01, 0xA1, 0xD6, 0xD0, 0x39, 0x77, 0x67, 0x42}, 
		 {0x5C, 0xD5, 0x4C, 0xA8, 0x3D, 0xEF, 0x57, 0xDA}, 
		 {0x02, 0x48, 0xD4, 0x38, 0x06, 0xF6, 0x71, 0x72}, 
		 {0x51, 0x45, 0x4B, 0x58, 0x2D, 0xDF, 0x44, 0x0A}, 
		 {0x42, 0xFD, 0x44, 0x30, 0x59, 0x57, 0x7F, 0xA2}, 
		 {0x05, 0x9B, 0x5E, 0x08, 0x51, 0xCF, 0x14, 0x3A}, 
		 {0x07, 0x56, 0xD8, 0xE0, 0x77, 0x47, 0x61, 0xD2}, 
		 {0x76, 0x25, 0x14, 0xB8, 0x29, 0xBF, 0x48, 0x6A}, 
		 {0x3B, 0xDD, 0x11, 0x90, 0x49, 0x37, 0x28, 0x02}, 
		 {0x26, 0x95, 0x5F, 0x68, 0x35, 0xAF, 0x60, 0x9A}, 
		 {0x16, 0x4D, 0x5E, 0x40, 0x4F, 0x27, 0x52, 0x32}, 
		 {0x6B, 0x05, 0x6E, 0x18, 0x75, 0x9F, 0x5C, 0xCA}, 
		 {0x00, 0x4B, 0xD6, 0xEF, 0x09, 0x17, 0x60, 0x62}, 
		 {0x48, 0x0D, 0x39, 0x00, 0x6E, 0xE7, 0x62, 0xF2}, 
		 {0x43, 0x75, 0x40, 0xC8, 0x69, 0x8F, 0x3C, 0xFA}, 
		 {0x07, 0x2D, 0x43, 0xA0, 0x77, 0x07, 0x52, 0x92}, 
		 {0x02, 0xFE, 0x55, 0x77, 0x81, 0x17, 0xF1, 0x2A}, 
		 {0x1D, 0x9D, 0x5C, 0x50, 0x18, 0xF7, 0x28, 0xC2}, 
		 {0x30, 0x55, 0x32, 0x28, 0x6D, 0x6F, 0x29, 0x5A}} ;

	BYTE ka_cts[DES_NUM_KA_VECTORS][8] = 
		{{0x69, 0x0F, 0x5B, 0x0D, 0x9A, 0x26, 0x93, 0x9B},
		 {0x7A, 0x38, 0x9D, 0x10, 0x35, 0x4B, 0xD2, 0x71},
		 {0x86, 0x8E, 0xBB, 0x51, 0xCA, 0xB4, 0x59, 0x9A},
		 {0x71, 0x78, 0x87, 0x6E, 0x01, 0xF1, 0x9B, 0x2A},
		 {0xAF, 0x37, 0xFB, 0x42, 0x1F, 0x8C, 0x40, 0x95},
		 {0x86, 0xA5, 0x60, 0xF1, 0x0E, 0xC6, 0xD8, 0x5B},
		 {0x0C, 0xD3, 0xDA, 0x02, 0x00, 0x21, 0xDC, 0x09},
		 {0xEA, 0x67, 0x6B, 0x2C, 0xB7, 0xDB, 0x2B, 0x7A},
		 {0xDF, 0xD6, 0x4A, 0x81, 0x5C, 0xAF, 0x1A, 0x0F},
		 {0x5C, 0x51, 0x3C, 0x9C, 0x48, 0x86, 0xC0, 0x88},
		 {0x0A, 0x2A, 0xEE, 0xAE, 0x3F, 0xF4, 0xAB, 0x77},
		 {0xEF, 0x1B, 0xF0, 0x3E, 0x5D, 0xFA, 0x57, 0x5A},
		 {0x88, 0xBF, 0x0D, 0xB6, 0xD7, 0x0D, 0xEE, 0x56},
		 {0xA1, 0xF9, 0x91, 0x55, 0x41, 0x02, 0x0B, 0x56},
		 {0x6F, 0xBF, 0x1C, 0xAF, 0xCF, 0xFD, 0x05, 0x56},
		 {0x2F, 0x22, 0xE4, 0x9B, 0xAB, 0x7C, 0xA1, 0xAC},
		 {0x5A, 0x6B, 0x61, 0x2C, 0xC2, 0x6C, 0xCE, 0x4A},
		 {0x5F, 0x4C, 0x03, 0x8E, 0xD1, 0x2B, 0x2E, 0x41},
		 {0x63, 0xFA, 0xC0, 0xD0, 0x34, 0xD9, 0xF7, 0x93}} ;

	BYTE zeroes[] = {0, 0, 0, 0, 0, 0, 0, 0};

    
    ASSERT( sizeof(desTable) == XC_SERVICE_DES_TABLESIZE );
    
	XNetRandom( text, DES_TEST_LENGTH );
	XNetRandom( key, XC_SERVICE_DES_KEYSIZE );
	XNetRandom( iv, XC_SERVICE_DES_BLOCKLEN );

	memcpy(saveKey, key, XC_SERVICE_DES_KEYSIZE);
    XcDESKeyParity(key, XC_SERVICE_DES_KEYSIZE);

    desparityonkey(saveKey, XC_SERVICE_DES_KEYSIZE);
    if (memcmp( key, saveKey, XC_SERVICE_DES_KEYSIZE ) != 0)
    {
        XDBGWRN("Crypto Test", " desparityonkey result compare failed!");
        return FALSE;
    }

    XcKeyTable(XC_SERVICE_DES_CIPHER, XCDESTable, key);

    deskey(&desTable, saveKey);
    if (memcmp( (BYTE*)&desTable, XCDESTable, XC_SERVICE_DES_TABLESIZE ) != 0)
    {
        XDBGWRN("Crypto Test", " deskey result compare failed!");
        return FALSE;
    }

	memcpy(saveText, text, DES_TEST_LENGTH);

    dwStart = GetTickCount();
    for(i=0; i<DES_REPEAT_LOOP; ++i)
    {
        memcpy(fb,iv,8);
    	memcpy(text, saveText, DES_TEST_LENGTH);
    	XcBlockCryptCBC(XC_SERVICE_DES_CIPHER, DES_TEST_LENGTH, text, text, XCDESTable, XC_SERVICE_ENCRYPT, fb);
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("ROM DES Enc", "%d bytes took %d ms", DES_REPEAT_LOOP * DES_TEST_LENGTH, dwEnd );

	memcpy(saveCText, text, DES_TEST_LENGTH);

    dwStart = GetTickCount();
    for(i=0; i<DES_REPEAT_LOOP; ++i)
    {
        memcpy(fb,iv,8);
    	memcpy(text, saveCText, DES_TEST_LENGTH);
        for (j=0; j<DES_TEST_LENGTH; j+= 8)
        {
        	CBC(des, 8, text+j, text+j, &desTable, DECRYPT, fb);
        }
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("RSA DES Dec", "%d bytes took %d ms", DES_REPEAT_LOOP * DES_TEST_LENGTH, dwEnd );

    if (memcmp( saveText, text, DES_TEST_LENGTH ) != 0)
    {
        XDBGWRN("Crypto Test", " DES result compare failed!");
        return FALSE;
    }

    dwStart = GetTickCount();
    for(i=0; i<DES_REPEAT_LOOP; ++i)
    {
        memcpy(fb,iv,8);
    	memcpy(text, saveText, DES_TEST_LENGTH);
        for (j=0; j<DES_TEST_LENGTH; j+= 8)
        {
        	CBC(des, 8, text+j, text+j, &desTable, ENCRYPT, fb);
        }
    }
    dwEnd = GetTickCount() - dwStart;
    XDBGENT("RSA DES Enc", "%d bytes took %d ms", DES_REPEAT_LOOP * DES_TEST_LENGTH, dwEnd );

    if (memcmp( saveCText, text, DES_TEST_LENGTH ) != 0)
    {
        XDBGWRN("Crypto Test", " DES result compare failed!");
        return FALSE;
    }

    dwStart = GetTickCount();
    for(i=0; i<DES_REPEAT_LOOP; ++i)
    {
        memcpy(fb,iv,8);
    	memcpy(text, saveCText, DES_TEST_LENGTH);
    	XcBlockCryptCBC(XC_SERVICE_DES_CIPHER, DES_TEST_LENGTH, text, text, XCDESTable, XC_SERVICE_DECRYPT, fb);
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("ROM DES Dec", "%d bytes took %d ms", DES_REPEAT_LOOP * DES_TEST_LENGTH, dwEnd );

    if (memcmp( saveText, text, DES_TEST_LENGTH ) != 0)
    {
        XDBGWRN("Crypto Test", " DES result compare failed!");
        return FALSE;
    }

    for (i=0; i<DES_NUM_KA_VECTORS; i++) {
        memcpy (key, ka_keys[i], XC_SERVICE_DES_KEYSIZE);
        memcpy(fb,zeroes,8);
    	memcpy(text, ka_pts[i], 8);

        XcDESKeyParity(key, XC_SERVICE_DES_KEYSIZE);
        XcKeyTable(XC_SERVICE_DES_CIPHER, XCDESTable, key);

    	XcBlockCryptCBC(XC_SERVICE_DES_CIPHER, 8, text, text, XCDESTable, XC_SERVICE_ENCRYPT, fb);
        if (memcmp( ka_cts[i], text, 8 ) != 0)
        {
            XDBGWRN("Crypto Test", " Known Answer DES encryption compare failed!");
            return FALSE;
        };

        memcpy(fb,zeroes,8);
    	XcBlockCryptCBC(XC_SERVICE_DES_CIPHER, 8, text, text, XCDESTable, XC_SERVICE_DECRYPT, fb);
        if (memcmp( ka_pts[i], text, 8 ) != 0)
        {
            XDBGWRN("Crypto Test", " Known Answer DES decryption compare failed!");
            return FALSE;
        };
    };

    return TRUE;
}

#define DES3_NUM_KA_VECTORS 19
#define DES3_NUM_KA_IVS 3

BOOL des3test()
{
	BYTE text[DES_TEST_LENGTH];
	BYTE saveText[DES_TEST_LENGTH];
	BYTE saveCText[DES_TEST_LENGTH];
	BYTE key[XC_SERVICE_DES3_KEYSIZE];
	BYTE saveKey[XC_SERVICE_DES3_KEYSIZE];
	BYTE iv[XC_SERVICE_DES_BLOCKLEN];
	BYTE fb[XC_SERVICE_DES_BLOCKLEN];
	DES3TABLE desTable;
	BYTE XCDES3Table[XC_SERVICE_DES3_TABLESIZE];
	DWORD dwStart,dwEnd,i,j;

	BYTE ka_keys[DES3_NUM_KA_VECTORS][XC_SERVICE_DES3_KEYSIZE] = 
		{{0x7c, 0xa1, 0x10, 0x45, 0x4a, 0x1a, 0x6e, 0x57},
		 {0x01, 0x31, 0xd9, 0x61, 0x9d, 0xc1, 0x37, 0x6e},
		 {0x07, 0xa1, 0x13, 0x3e, 0x4a, 0x0b, 0x26, 0x86},
		 {0x38, 0x49, 0x67, 0x4c, 0x26, 0x02, 0x31, 0x9e},
		 {0x04, 0xb9, 0x15, 0xba, 0x43, 0xfe, 0xb5, 0xb6},
		 {0x01, 0x13, 0xb9, 0x70, 0xfd, 0x34, 0xf2, 0xce},
		 {0x01, 0x70, 0xf1, 0x75, 0x46, 0x8f, 0xb5, 0xe6},
		 {0x43, 0x29, 0x7f, 0xad, 0x38, 0xe3, 0x73, 0xfe},
		 {0x07, 0xa7, 0x13, 0x70, 0x45, 0xda, 0x2a, 0x16},
		 {0x04, 0x68, 0x91, 0x04, 0xc2, 0xfd, 0x3b, 0x2f},
		 {0x37, 0xd0, 0x6b, 0xb5, 0x16, 0xcb, 0x75, 0x46},
		 {0x1f, 0x08, 0x26, 0x0d, 0x1a, 0xc2, 0x46, 0x5e},
		 {0x58, 0x40, 0x23, 0x64, 0x1a, 0xba, 0x61, 0x76},
		 {0x02, 0x58, 0x16, 0x16, 0x46, 0x29, 0xb0, 0x07},
		 {0x49, 0x79, 0x3e, 0xbc, 0x79, 0xb3, 0x25, 0x8f},
		 {0x4f, 0xb0, 0x5e, 0x15, 0x15, 0xab, 0x73, 0xa7},
		 {0x49, 0xe9, 0x5d, 0x6d, 0x4c, 0xa2, 0x29, 0xbf},
		 {0x01, 0x83, 0x10, 0xdc, 0x40, 0x9b, 0x26, 0xd6},
		 {0x1c, 0x58, 0x7f, 0x1c, 0x13, 0x92, 0x4f, 0xef}};

	BYTE ka_pts[DES3_NUM_KA_VECTORS][8] = 
		{{0x01, 0xa1, 0xd6, 0xd0, 0x39, 0x77, 0x67, 0x42}, 
		 {0x5c, 0xd5, 0x4c, 0xa8, 0x3d, 0xef, 0x57, 0xda}, 
		 {0x02, 0x48, 0xd4, 0x38, 0x06, 0xf6, 0x71, 0x72}, 
		 {0x51, 0x45, 0x4b, 0x58, 0x2d, 0xdf, 0x44, 0x0a}, 
		 {0x42, 0xfd, 0x44, 0x30, 0x59, 0x57, 0x7f, 0xa2}, 
		 {0x05, 0x9b, 0x5e, 0x08, 0x51, 0xcf, 0x14, 0x3a}, 
		 {0x07, 0x56, 0xd8, 0xe0, 0x77, 0x47, 0x61, 0xd2}, 
		 {0x76, 0x25, 0x14, 0xb8, 0x29, 0xbf, 0x48, 0x6a}, 
		 {0x3b, 0xdd, 0x11, 0x90, 0x49, 0x37, 0x28, 0x02}, 
		 {0x26, 0x95, 0x5f, 0x68, 0x35, 0xaf, 0x60, 0x9a}, 
		 {0x16, 0x4d, 0x5e, 0x40, 0x4f, 0x27, 0x52, 0x32}, 
		 {0x6b, 0x05, 0x6e, 0x18, 0x75, 0x9f, 0x5c, 0xca}, 
		 {0x00, 0x4b, 0xd6, 0xef, 0x09, 0x17, 0x60, 0x62}, 
		 {0x48, 0x0d, 0x39, 0x00, 0x6e, 0xe7, 0x62, 0xf2}, 
		 {0x43, 0x75, 0x40, 0xc8, 0x69, 0x8f, 0x3c, 0xfa}, 
		 {0x07, 0x2d, 0x43, 0xa0, 0x77, 0x07, 0x52, 0x92}, 
		 {0x02, 0xfe, 0x55, 0x77, 0x81, 0x17, 0xf1, 0x2a}, 
		 {0x1d, 0x9d, 0x5c, 0x50, 0x18, 0xf7, 0x28, 0xc2}, 
		 {0x30, 0x55, 0x32, 0x28, 0x6d, 0x6f, 0x29, 0x5a}};

	BYTE ka_cts[DES3_NUM_KA_IVS][DES3_NUM_KA_VECTORS][8] = 
		{
		{{0x69, 0x0f, 0x5b, 0x0d, 0x9a, 0x26, 0x93, 0x9b}, 
		 {0x7a, 0x38, 0x9d, 0x10, 0x35, 0x4b, 0xd2, 0x71}, 
		 {0x86, 0x8e, 0xbb, 0x51, 0xca, 0xb4, 0x59, 0x9a}, 
		 {0x71, 0x78, 0x87, 0x6e, 0x01, 0xf1, 0x9b, 0x2a}, 
		 {0xaf, 0x37, 0xfb, 0x42, 0x1f, 0x8c, 0x40, 0x95}, 
		 {0x86, 0xa5, 0x60, 0xf1, 0x0e, 0xc6, 0xd8, 0x5b}, 
		 {0x0c, 0xd3, 0xda, 0x02, 0x00, 0x21, 0xdc, 0x09}, 
		 {0xea, 0x67, 0x6b, 0x2c, 0xb7, 0xdb, 0x2b, 0x7a}, 
		 {0xdf, 0xd6, 0x4a, 0x81, 0x5c, 0xaf, 0x1a, 0x0f}, 
		 {0x5c, 0x51, 0x3c, 0x9c, 0x48, 0x86, 0xc0, 0x88}, 
		 {0x0a, 0x2a, 0xee, 0xae, 0x3f, 0xf4, 0xab, 0x77}, 
		 {0xef, 0x1b, 0xf0, 0x3e, 0x5d, 0xfa, 0x57, 0x5a}, 
		 {0x88, 0xbf, 0x0d, 0xb6, 0xd7, 0x0d, 0xee, 0x56}, 
		 {0xa1, 0xf9, 0x91, 0x55, 0x41, 0x02, 0x0b, 0x56}, 
		 {0x6f, 0xbf, 0x1c, 0xaf, 0xcf, 0xfd, 0x05, 0x56}, 
		 {0x2f, 0x22, 0xe4, 0x9b, 0xab, 0x7c, 0xa1, 0xac}, 
		 {0x5a, 0x6b, 0x61, 0x2c, 0xc2, 0x6c, 0xce, 0x4a}, 
		 {0x5f, 0x4c, 0x03, 0x8e, 0xd1, 0x2b, 0x2e, 0x41}, 
		 {0x63, 0xfa, 0xc0, 0xd0, 0x34, 0xd9, 0xf7, 0x93}},

		{{0x89, 0x20, 0x2f, 0x22, 0x4f, 0x1f, 0x22, 0x61}, 
		 {0x6d, 0xda, 0x0d, 0xe9, 0x9d, 0x3c, 0x86, 0xb9}, 
		 {0x82, 0x00, 0x61, 0x6c, 0x58, 0x9b, 0xc7, 0xaa}, 
		 {0x64, 0x75, 0x72, 0x92, 0xfe, 0xbc, 0xca, 0xd1}, 
		 {0x20, 0x4f, 0xc6, 0x12, 0x39, 0x92, 0xd4, 0xe9}, 
		 {0x1f, 0xa8, 0x6f, 0x6f, 0x73, 0x56, 0x03, 0xa3}, 
		 {0x65, 0xe0, 0x5d, 0x62, 0xb3, 0x5a, 0xa3, 0x65}, 
		 {0x95, 0xc0, 0xf9, 0xe5, 0x95, 0xae, 0xc2, 0xff}, 
		 {0x12, 0x73, 0x59, 0xc2, 0x0e, 0x10, 0xe2, 0x5a}, 
		 {0xb0, 0x89, 0xd9, 0x0f, 0x84, 0xef, 0x0c, 0x4c}, 
		 {0x32, 0xbb, 0xdd, 0x67, 0xd4, 0xe6, 0x6d, 0xd6}, 
		 {0xb4, 0x87, 0x30, 0x81, 0xfd, 0xeb, 0xc8, 0x1d}, 
		 {0x98, 0x8f, 0xe2, 0xe8, 0xe1, 0x75, 0x5e, 0x78}, 
		 {0xee, 0x6c, 0x0f, 0xeb, 0xb2, 0x12, 0xb2, 0x18}, 
		 {0xc0, 0x3a, 0xdc, 0x2b, 0x6a, 0xa8, 0x5b, 0x5b}, 
		 {0x09, 0x6a, 0x41, 0x36, 0xe0, 0xf6, 0x5f, 0x76}, 
		 {0xbf, 0x4d, 0xa6, 0xaa, 0x59, 0xed, 0x57, 0x51}, 
		 {0xaa, 0xb9, 0x33, 0x90, 0xe1, 0x3d, 0x3b, 0xb3}, 
		 {0xdb, 0x3c, 0x41, 0x06, 0xc5, 0xdb, 0x56, 0x48}},

		{{0x58, 0x5a, 0x1e, 0x8d, 0x89, 0x70, 0x5d, 0x10},
		 {0x99, 0x98, 0x5b, 0x67, 0xb5, 0x98, 0xbd, 0x25},
		 {0xd2, 0xff, 0x67, 0x46, 0x13, 0x77, 0xfb, 0xb5},
		 {0x93, 0xbd, 0x8b, 0xee, 0xea, 0x23, 0x10, 0xfc},
		 {0x6b, 0xfb, 0x4d, 0xf0, 0x56, 0x9c, 0xeb, 0xce},
		 {0x0b, 0xe3, 0x55, 0x87, 0x38, 0xc6, 0xd7, 0xc3},
		 {0x3b, 0xfc, 0x9a, 0x3f, 0x03, 0x4d, 0xa2, 0x92},
		 {0xea, 0x9a, 0xb3, 0x58, 0x5f, 0x16, 0x65, 0x86},
		 {0x95, 0x3a, 0x36, 0xff, 0x13, 0xa0, 0x89, 0x06},
		 {0x08, 0xbd, 0x60, 0xf6, 0xf8, 0x0d, 0x6f, 0xad},
		 {0x83, 0xa3, 0x06, 0x06, 0xfc, 0x78, 0xd7, 0x40},
		 {0x64, 0x45, 0x79, 0x9c, 0x9b, 0x70, 0x16, 0x94},
		 {0x1e, 0x1f, 0xdd, 0x86, 0x60, 0xa7, 0x5b, 0xb5},
		 {0x60, 0xba, 0xe5, 0x9c, 0x51, 0x76, 0x73, 0x94},
		 {0x82, 0x6e, 0xc7, 0xe0, 0x2f, 0x48, 0x68, 0x85},
		 {0x9e, 0x30, 0x37, 0x7b, 0x7a, 0x39, 0xd5, 0xd3},
		 {0x64, 0xb7, 0x73, 0x06, 0x32, 0x1a, 0x93, 0x2c},
		 {0x3b, 0x17, 0xda, 0xff, 0x73, 0x3f, 0xcf, 0xb0},
		 {0x7f, 0x38, 0x21, 0x5d, 0x73, 0xb0, 0xee, 0x62}}};

	BYTE ka_ivs[DES3_NUM_KA_IVS][8] = 
		{{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		 {0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55},
		 {0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa}};

    
    ASSERT( sizeof(desTable) == XC_SERVICE_DES3_TABLESIZE );
    
	XNetRandom( text, DES_TEST_LENGTH );
	XNetRandom( key, XC_SERVICE_DES3_KEYSIZE );
	XNetRandom( iv, XC_SERVICE_DES_BLOCKLEN );

	memcpy(saveKey, key, XC_SERVICE_DES3_KEYSIZE);
    XcDESKeyParity(key, XC_SERVICE_DES3_KEYSIZE);

    desparityonkey(saveKey, XC_SERVICE_DES3_KEYSIZE);
    if (memcmp( key, saveKey, XC_SERVICE_DES3_KEYSIZE ) != 0)
    {
        XDBGWRN("Crypto Test", " desparityonkey result compare failed!");
        return FALSE;
    }

    XcKeyTable(XC_SERVICE_DES3_CIPHER, XCDES3Table, key);

    tripledes3key(&desTable, saveKey);
    if (memcmp( (BYTE*)&desTable, XCDES3Table, XC_SERVICE_DES3_TABLESIZE ) != 0)
    {
        XDBGWRN("Crypto Test", " tripledes3key result compare failed!");
        return FALSE;
    }

	memcpy(saveText, text, DES_TEST_LENGTH);

    dwStart = GetTickCount();
    for(i=0; i<DES_REPEAT_LOOP; ++i)
    {
        memcpy(fb,iv,8);
    	memcpy(text, saveText, DES_TEST_LENGTH);
    	XcBlockCryptCBC(XC_SERVICE_DES3_CIPHER, DES_TEST_LENGTH, text, text, XCDES3Table, XC_SERVICE_ENCRYPT, fb);
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("ROM 3DES Enc", "%d bytes took %d ms", DES_REPEAT_LOOP * DES_TEST_LENGTH, dwEnd );

	memcpy(saveCText, text, DES_TEST_LENGTH);

    dwStart = GetTickCount();
    for(i=0; i<DES_REPEAT_LOOP; ++i)
    {
        memcpy(fb,iv,8);
    	memcpy(text, saveCText, DES_TEST_LENGTH);
        for (j=0; j<DES_TEST_LENGTH; j+= 8)
        {
        	CBC(tripledes, 8, text+j, text+j, &desTable, DECRYPT, fb);
        }
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("RSA 3DES Dec", "%d bytes took %d ms", DES_REPEAT_LOOP * DES_TEST_LENGTH, dwEnd );

    if (memcmp( saveText, text, DES_TEST_LENGTH ) != 0)
    {
        XDBGWRN("Crypto Test", " DES result compare failed!");
        return FALSE;
    }

    dwStart = GetTickCount();
    for(i=0; i<DES_REPEAT_LOOP; ++i)
    {
        memcpy(fb,iv,8);
    	memcpy(text, saveText, DES_TEST_LENGTH);
        for (j=0; j<DES_TEST_LENGTH; j+= 8)
        {
        	CBC(tripledes, 8, text+j, text+j, &desTable, ENCRYPT, fb);
        }
    }
    dwEnd = GetTickCount() - dwStart;
    XDBGENT("RSA 3DES Enc", "%d bytes took %d ms", DES_REPEAT_LOOP * DES_TEST_LENGTH, dwEnd );

    if (memcmp( saveCText, text, DES_TEST_LENGTH ) != 0)
    {
        XDBGWRN("Crypto Test", " DES result compare failed!");
        return FALSE;
    }

    dwStart = GetTickCount();
    for(i=0; i<DES_REPEAT_LOOP; ++i)
    {
        memcpy(fb,iv,8);
    	memcpy(text, saveCText, DES_TEST_LENGTH);
    	XcBlockCryptCBC(XC_SERVICE_DES3_CIPHER, DES_TEST_LENGTH, text, text, XCDES3Table, XC_SERVICE_DECRYPT, fb);
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("ROM 3DES Dec", "%d bytes took %d ms", DES_REPEAT_LOOP * DES_TEST_LENGTH, dwEnd );

    if (memcmp( saveText, text, DES_TEST_LENGTH ) != 0)
    {
        XDBGWRN("Crypto Test", " DES result compare failed!");
        return FALSE;
    }

    for (i=0; i<DES3_NUM_KA_VECTORS; i++) {
        for (j=0; j<DES3_NUM_KA_IVS; j++) {
            memcpy (key, ka_keys[i], XC_SERVICE_DES_KEYSIZE);
            memcpy (key + XC_SERVICE_DES_KEYSIZE, ka_keys[i], XC_SERVICE_DES_KEYSIZE);
            memcpy (key + 2 * XC_SERVICE_DES_KEYSIZE, ka_keys[i], XC_SERVICE_DES_KEYSIZE);
            memcpy(fb,ka_ivs[j],8);
            memcpy(text, ka_pts[i], 8);

            XcDESKeyParity(key, XC_SERVICE_DES3_KEYSIZE);
            XcKeyTable(XC_SERVICE_DES3_CIPHER, XCDES3Table, key);

            XcBlockCryptCBC(XC_SERVICE_DES3_CIPHER, 8, text, text, XCDES3Table, XC_SERVICE_ENCRYPT, fb);
            if (memcmp( ka_cts[j][i], text, 8 ) != 0)
            {
                XDBGWRN("Crypto Test", " Known Answer tripleDES encryption compare failed!");
                return FALSE;
            };

            memcpy(fb,ka_ivs[j],8);
            XcBlockCryptCBC(XC_SERVICE_DES3_CIPHER, 8, text, text, XCDES3Table, XC_SERVICE_DECRYPT, fb);
            if (memcmp( ka_pts[i], text, 8 ) != 0)
            {
                XDBGWRN("Crypto Test", " Known Answer tripleDES decryption compare failed!");
                return FALSE;
            };
        };
    };


    return TRUE;
}

#define USE_GROUP1 1

#ifdef USE_GROUP0

#define DH_KEY_LENGTH 64

static unsigned char g_def_p[DH_KEY_LENGTH] =
    { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xc9, 0x0f, 0xda, 0xa2, 0x21, 0x68, 0xc2, 0x34,
      0xc4, 0xc6, 0x62, 0x8b, 0x80, 0xdc, 0x1c, 0xd1,
      0x29, 0x02, 0x4e, 0x08, 0x8a, 0x67, 0xcc, 0x74,
      0x4f, 0xe1, 0x35, 0x6d, 0x6d, 0x51, 0xc2, 0x45,
      0xe4, 0x85, 0xb5, 0x76, 0x62, 0x5e, 0x7e, 0xc6,
      0xf4, 0x4c, 0x42, 0xe9, 0xa6, 0x3a, 0x36, 0x20,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    };

static unsigned char g_def_g[DH_KEY_LENGTH] =
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02
    };

#else

#ifdef USE_GROUP1

#define DH_KEY_LENGTH 96

static unsigned char g_def_p[DH_KEY_LENGTH] =
    { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xc9, 0x0f, 0xda, 0xa2, 0x21, 0x68, 0xc2, 0x34,
      0xc4, 0xc6, 0x62, 0x8b, 0x80, 0xdc, 0x1c, 0xd1,
      0x29, 0x02, 0x4e, 0x08, 0x8a, 0x67, 0xcc, 0x74,
      0x02, 0x0b, 0xbe, 0xa6, 0x3b, 0x13, 0x9b, 0x22,
      0x51, 0x4a, 0x08, 0x79, 0x8e, 0x34, 0x04, 0xdd,
      0xef, 0x95, 0x19, 0xb3, 0xcd, 0x3a, 0x43, 0x1b,
      0x30, 0x2b, 0x0a, 0x6d, 0xf2, 0x5f, 0x14, 0x37,
      0x4f, 0xe1, 0x35, 0x6d, 0x6d, 0x51, 0xc2, 0x45,
      0xe4, 0x85, 0xb5, 0x76, 0x62, 0x5e, 0x7e, 0xc6,
      0xf4, 0x4c, 0x42, 0xe9, 0xa6, 0x3a, 0x36, 0x20,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    };

static unsigned char g_def_g[DH_KEY_LENGTH] =
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02
    };

#else

#define DH_KEY_LENGTH 128

static unsigned char g_def_p[DH_KEY_LENGTH] =
     { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
       0xc9, 0x0f, 0xda, 0xa2, 0x21, 0x68, 0xc2, 0x34,
       0xc4, 0xc6, 0x62, 0x8b, 0x80, 0xdc, 0x1c, 0xd1,
       0x29, 0x02, 0x4e, 0x08, 0x8a, 0x67, 0xcc, 0x74,
       0x02, 0x0b, 0xbe, 0xa6, 0x3b, 0x13, 0x9b, 0x22,
       0x51, 0x4a, 0x08, 0x79, 0x8e, 0x34, 0x04, 0xdd,
       0xef, 0x95, 0x19, 0xb3, 0xcd, 0x3a, 0x43, 0x1b,
       0x30, 0x2b, 0x0a, 0x6d, 0xf2, 0x5f, 0x14, 0x37,
       0x4f, 0xe1, 0x35, 0x6d, 0x6d, 0x51, 0xc2, 0x45,
       0xe4, 0x85, 0xb5, 0x76, 0x62, 0x5e, 0x7e, 0xc6,
       0xf4, 0x4c, 0x42, 0xe9, 0xa6, 0x37, 0xed, 0x6b,
       0x0b, 0xff, 0x5c, 0xb6, 0xf4, 0x06, 0xb7, 0xed,
       0xee, 0x38, 0x6b, 0xfb, 0x5a, 0x89, 0x9f, 0xa5,
       0xae, 0x9f, 0x24, 0x11, 0x7c, 0x4b, 0x1f, 0xe6,
       0x49, 0x28, 0x66, 0x51, 0xec, 0xe6, 0x53, 0x81,
       0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
     };

static unsigned char g_def_g[DH_KEY_LENGTH] =
     { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02
     };

#endif

#endif

#define DH_REPEAT_LOOP 10

BOOL dhtest()
{
	DWORD dwStart,dwEnd,i,j;
	BYTE x[DH_KEY_LENGTH];
	BYTE gx[DH_KEY_LENGTH];
	BYTE y[DH_KEY_LENGTH];
	BYTE gy[DH_KEY_LENGTH];
	BYTE gxy[DH_KEY_LENGTH];
	BYTE gyx[DH_KEY_LENGTH];
	BYTE *p;
	BOOL fOK;
	
    XNetRandom( x, DH_KEY_LENGTH );
    XNetRandom( y, DH_KEY_LENGTH );    
    
    dwStart = GetTickCount();
    for(i=0; i<DH_REPEAT_LOOP; ++i)
    {
        RtlZeroMemory( gx, DH_KEY_LENGTH );
        RtlZeroMemory( gy, DH_KEY_LENGTH );
        RtlZeroMemory( gxy, DH_KEY_LENGTH );
        RtlZeroMemory( gyx, DH_KEY_LENGTH );
        
        fOK = XcModExp( (DWORD*)gx, (DWORD*)g_def_g, (DWORD*)x, (DWORD*)g_def_p, DH_KEY_LENGTH / sizeof(DWORD) );
        if (!fOK)
        {
            XDBGWRN("Crypto Test", "XcModExp failed!");
            return FALSE;
        }
        
        fOK = XcModExp( (DWORD*)gy, (DWORD*)g_def_g, (DWORD*)y, (DWORD*)g_def_p, DH_KEY_LENGTH / sizeof(DWORD) );
        if (!fOK)
        {
            XDBGWRN("Crypto Test", "XcModExp failed!");
            return FALSE;
        }
        
        fOK = XcModExp( (DWORD*)gxy, (DWORD*)gx, (DWORD*)y, (DWORD*)g_def_p, DH_KEY_LENGTH / sizeof(DWORD) );
        if (!fOK)
        {
            XDBGWRN("Crypto Test", "XcModExp failed!");
            return FALSE;
        }
        
        fOK = XcModExp( (DWORD*)gyx, (DWORD*)gy, (DWORD*)x, (DWORD*)g_def_p, DH_KEY_LENGTH / sizeof(DWORD) );
        if (!fOK)
        {
            XDBGWRN("Crypto Test", "XcModExp failed!");
            return FALSE;
        }
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("XcModExp", "%d times took %d ms", DH_REPEAT_LOOP*4, dwEnd );

    for (i=0,p = x; i<DH_KEY_LENGTH; i+=16,p+=16)
    {
        XDBGEXT("x  ", "%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X",
            p[0],       p[1],        p[2],         p[3],         p[4],         p[5],         p[6],         p[7],
            p[8],       p[9],        p[10],        p[11],        p[12],        p[13],        p[14],        p[15] );
    }
    for (i=0,p = y; i<DH_KEY_LENGTH; i+=16,p+=16)
    {
        XDBGEXT("y  ", "%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X",
            p[0],       p[1],        p[2],         p[3],         p[4],         p[5],         p[6],         p[7],
            p[8],       p[9],        p[10],        p[11],        p[12],        p[13],        p[14],        p[15] );
    }
    for (i=0,p = gx; i<DH_KEY_LENGTH; i+=16,p+=16)
    {
        XDBGEXT("gx ", "%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X",
            p[0],       p[1],        p[2],         p[3],         p[4],         p[5],         p[6],         p[7],
            p[8],       p[9],        p[10],        p[11],        p[12],        p[13],        p[14],        p[15] );
    }
    for (i=0,p = gy; i<DH_KEY_LENGTH; i+=16,p+=16)
    {
        XDBGEXT("gy ", "%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X",
            p[0],       p[1],        p[2],         p[3],         p[4],         p[5],         p[6],         p[7],
            p[8],       p[9],        p[10],        p[11],        p[12],        p[13],        p[14],        p[15] );
    }
    for (i=0,p = gxy; i<DH_KEY_LENGTH; i+=16,p+=16)
    {
        XDBGEXT("gxy", "%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X",
            p[0],       p[1],        p[2],         p[3],         p[4],         p[5],         p[6],         p[7],
            p[8],       p[9],        p[10],        p[11],        p[12],        p[13],        p[14],        p[15] );
    }

    return (RtlEqualMemory(gxy, gyx, DH_KEY_LENGTH));
}

#ifdef AESTEST

#define AES_TEST_LENGTH 512

#define AES_KEY_LENGTH 16

#define AES_REPEAT_LOOP 1000

BOOL aestest()
{
	BYTE text[AES_TEST_LENGTH];
	BYTE saveText[AES_TEST_LENGTH];
	BYTE saveCText[AES_TEST_LENGTH];
	BYTE key[AES_KEY_LENGTH];
	BYTE iv[AES_KEY_LENGTH];
	BYTE fb[AES_KEY_LENGTH];
	AESTable aesTable;
	DWORD dwStart,dwEnd,i,j;
    
	XNetRandom( text, AES_TEST_LENGTH );
	XNetRandom( key, AES_KEY_LENGTH );
	XNetRandom( iv, AES_KEY_LENGTH );

    dwStart = GetTickCount();
    for(i=0; i<AES_REPEAT_LOOP; ++i)
    {
        aeskey(&aesTable, key, CRYPT_AES128_ROUNDS);
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("aes key", "%d times took %d ms", AES_REPEAT_LOOP, dwEnd );

	memcpy(saveText, text, AES_TEST_LENGTH);

    dwStart = GetTickCount();
    for(i=0; i<AES_REPEAT_LOOP; ++i)
    {
        memcpy(fb,iv,AES_KEY_LENGTH);
    	memcpy(text, saveText, AES_TEST_LENGTH);
        for (j=0; j<AES_TEST_LENGTH; j+= AES_KEY_LENGTH)
        {
        	CBC(aes, AES_KEY_LENGTH, text+j, text+j, &aesTable, ENCRYPT, fb);
        }
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("aes Enc", "%d bytes took %d ms", AES_REPEAT_LOOP * AES_TEST_LENGTH, dwEnd );

	memcpy(saveCText, text, AES_TEST_LENGTH);

    dwStart = GetTickCount();
    for(i=0; i<AES_REPEAT_LOOP; ++i)
    {
        memcpy(fb,iv,AES_KEY_LENGTH);
    	memcpy(text, saveCText, AES_TEST_LENGTH);
        for (j=0; j<AES_TEST_LENGTH; j+= AES_KEY_LENGTH)
        {
        	CBC(aes, AES_KEY_LENGTH, text+j, text+j, &aesTable, DECRYPT, fb);
        }
    }
    dwEnd = GetTickCount() - dwStart;
	XDBGENT("aes Dec", "%d bytes took %d ms", AES_REPEAT_LOOP * AES_TEST_LENGTH, dwEnd );

    if (memcmp( saveText, text, AES_TEST_LENGTH ) != 0)
    {
        XDBGWRN("Crypto Test", " AES result compare failed!");
        return FALSE;
    }

    return TRUE;
}

#endif //AESTEST


//
// Crypto updata test
//

DWORD g_updateTestResult;

void
TestXcSHAInit(
    IN PUCHAR pbSHAContext
    )
{
    g_updateTestResult = *pbSHAContext;
}
   
void
TestXcSHAUpdate(
    IN PUCHAR pbSHAContext,
    IN PUCHAR pbInput,
    IN ULONG dwInputLength
    )
{
    g_updateTestResult = *pbSHAContext * (*pbInput << 1) * (dwInputLength << 2);
}
   
void
TestXcSHAFinal(
    IN PUCHAR pbSHAContext,
    IN PUCHAR pbDigest
    )
{
    g_updateTestResult = *pbSHAContext * (*pbDigest << 1);
}
   
void
TestXcRC4Key(
    IN PUCHAR pbKeyStruct,
    IN ULONG dwKeyLength,
    IN PUCHAR pbKey
    )
{
    g_updateTestResult = *pbKeyStruct * (dwKeyLength << 1) * (*pbKey << 2);
}
   
void
TestXcRC4Crypt(
    IN PUCHAR pbKeyStruct,
    IN ULONG dwInputLength,
    IN PUCHAR pbInput
    )
{
    g_updateTestResult = *pbKeyStruct * (dwInputLength << 1) * (*pbInput << 2);
}
   
void
TestXcHMAC(
    IN PBYTE pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PBYTE pbData,
    IN ULONG cbData,
    IN PBYTE pbData2,
    IN ULONG cbData2,
    OUT PBYTE pbDigest
    )
{
    g_updateTestResult = *pbKeyMaterial * (cbKeyMaterial << 1) * (*pbData << 2) * (cbData << 3) * (*pbData2 << 4) * (cbData2 << 5) * (*pbDigest << 6);
}

ULONG
TestXcPKEncPublic(
    IN PUCHAR pbPubKey,
    IN PUCHAR pbInput,
    IN PUCHAR pbOutput
    )
{
    return *pbPubKey * (*pbInput << 1) * (*pbOutput << 2);
}
   
ULONG
TestXcPKDecPrivate(
    IN PUCHAR pbPrvKey,
    IN PUCHAR pbInput,
    IN PUCHAR pbOutput
    )
{
    return *pbPrvKey * (*pbInput << 1) * (*pbOutput << 2);
}

ULONG
TestXcPKGetKeyLen(
    IN PUCHAR pbPubKey
    )
{
    return *pbPubKey;
}

BOOLEAN
TestXcVerifyPKCS1Signature(
    IN PUCHAR pbSig,
    IN PUCHAR pbPubKey,
    IN PUCHAR pbDigest
    )
{
    return (BOOLEAN) ((g_updateTestResult = *pbSig * (*pbPubKey << 1) * (*pbDigest << 2)) & 1) != 0;
}
   
ULONG
TestXcModExp(
    IN LPDWORD pA,
    IN LPDWORD pB,
    IN LPDWORD pC,
    IN LPDWORD pD,
    IN ULONG dwN
    )
{
    return *(BYTE*)pA * (*(BYTE*)pB << 1) * (*(BYTE*)pC << 2) * (*(BYTE*)pD << 3) * (dwN << 4);
}
   
void
TestXcDESKeyParity(
    IN PUCHAR pbKey,
    IN ULONG dwKeyLength
    )
{
    g_updateTestResult = *pbKey * (dwKeyLength << 1);
}
   
void
TestXcKeyTable(
    IN ULONG dwCipher,
    OUT PUCHAR pbKeyTable,
    IN PUCHAR pbKey
    )
{
    g_updateTestResult = dwCipher * (*pbKeyTable << 1) * (*pbKey << 2);
}
   
void
TestXcBlockCrypt(
    IN ULONG dwCipher,
    IN PUCHAR pbOutput,
    IN PUCHAR pbInput,
    IN PUCHAR pbKeyTable,
    IN ULONG dwOp
    )
{
    g_updateTestResult = dwCipher * (*pbOutput << 1) * (*pbInput << 2) * (*pbKeyTable << 3) * (dwOp << 4);
}
   
void
TestXcBlockCryptCBC(
    IN ULONG dwCipher,
    IN ULONG dwInputLength,
    IN PUCHAR pbOutput,
    IN PUCHAR pbInput,
    IN PUCHAR pbKeyTable,
    IN ULONG dwOp,
    IN PUCHAR pbFeedback
    )
{
    g_updateTestResult = dwCipher * (dwInputLength << 1) * (*pbOutput << 2) * (*pbInput << 3) * (*pbKeyTable << 4) * (dwOp << 5) * (*pbFeedback << 6);
}

ULONG
TestXcCryptService(
    IN ULONG dwOp,
    IN void* pArgs
    )
{
    return dwOp * (*((BYTE*)pArgs) << 1);
}

CRYPTO_VECTOR newCryptoVector =
{
    TestXcSHAInit,
    TestXcSHAUpdate,
    TestXcSHAFinal,
    TestXcRC4Key,
    TestXcRC4Crypt,
    TestXcHMAC,
    TestXcPKEncPublic,
    TestXcPKDecPrivate,
    TestXcPKGetKeyLen,
    TestXcVerifyPKCS1Signature,
    TestXcModExp,
    TestXcDESKeyParity,
    TestXcKeyTable,
    TestXcBlockCrypt,
    TestXcBlockCryptCBC,
    TestXcCryptService
};

CRYPTO_VECTOR oldCryptoVector;

#define UPDATE_REPEAT_LOOP 1

BOOL updatetest()
{
    BYTE buf[1024], *p1, *p2;
    int i;
    DWORD result;

    KIRQL _irql;

    XNetRandom( buf, sizeof(buf) );
    p1 = p2 = buf;
        
    _irql = KeRaiseIrqlToDpcLevel();

    XcUpdateCrypto( &newCryptoVector, &oldCryptoVector );

    for (i = 0; i < UPDATE_REPEAT_LOOP; ++i)
    {
        XcSHAInit( p1++ );
        if ( g_updateTestResult != *p2++ ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );

        XcSHAUpdate( p1++, p1++, *p1++ );
        if ( g_updateTestResult != *p2++ * (*p2++ << 1) * (*p2++ << 2) ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );

        XcSHAFinal( p1++, p1++ );
        if ( g_updateTestResult != *p2++ * (*p2++ << 1) ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );

        XcRC4Key( p1++, *p1++, p1++ );
        if ( g_updateTestResult != *p2++ * (*p2++ << 1) * (*p2++ << 2) ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );

        XcRC4Crypt( p1++, *p1++, p1++ );
        if ( g_updateTestResult != *p2++ * (*p2++ << 1) * (*p2++ << 2) ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );

        XcHMAC( p1++, *p1++, p1++, *p1++, p1++, *p1++, p1++ );
        if ( g_updateTestResult != *p2++ * (*p2++ << 1) * (*p2++ << 2) * (*p2++ << 3) * (*p2++ << 4) * (*p2++ << 5) * (*p2++ << 6) ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );

        result = XcPKEncPublic( p1++, p1++, p1++ );
        if ( result != *p2++ * (*p2++ << 1) * (*p2++ << 2) ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );

        result = XcPKDecPrivate( p1++, p1++, p1++ );
        if ( result != *p2++ * (*p2++ << 1) * (*p2++ << 2) ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );

        result = XcPKGetKeyLen( p1++ );
        if ( result != *p2++ ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );

        result = XcVerifyPKCS1Signature( p1++, p1++, p1++ );
        if ( g_updateTestResult != *p2++ * (*p2++ << 1) * (*p2++ << 2) ) break;
        if ( result != ((g_updateTestResult & 1) != 0) ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );

        result = XcModExp( (DWORD*)p1++, (DWORD*)p1++, (DWORD*)p1++ , (DWORD*)p1++, *p1++ );
        if ( result != *p2++ * (*p2++ << 1) * (*p2++ << 2) * (*p2++ << 3) * (*p2++ << 4) ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );

        XcDESKeyParity( p1++, *p1++ );
        if ( g_updateTestResult != *p2++ * (*p2++ << 1) ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );

        XcKeyTable( *p1++, p1++, p1++ );
        if ( g_updateTestResult != *p2++ * (*p2++ << 1) * (*p2++ << 2) ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );
        
        XcBlockCrypt( *p1++, p1++, p1++, p1++, *p1++ );
        if ( g_updateTestResult != *p2++ * (*p2++ << 1) * (*p2++ << 2) * (*p2++ << 3) * (*p2++ << 4) ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );

        XcBlockCryptCBC( *p1++, *p1++, p1++, p1++, p1++, *p1++, p1++ );
        if ( g_updateTestResult != *p2++ * (*p2++ << 1) * (*p2++ << 2) * (*p2++ << 3) * (*p2++ << 4) * (*p2++ << 5) * (*p2++ << 6) ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );
        
        result = XcCryptService( *p1++, p1++ );
        if ( result != *p2++ * (*p2++ << 1) ) break;
        ASSERT( p1 == p2 && p1 < buf + sizeof(buf) );
    }
    
    XcUpdateCrypto( &oldCryptoVector, &newCryptoVector );

    KeLowerIrql(_irql);

    if (i < UPDATE_REPEAT_LOOP)
    {
        return FALSE;
    }
    
    if (shatest())
    {
        XDBGTRC("Crypto Test", "SHA1 succeeded!");
    }
    else
    {
        XDBGTRC("Crypto Test", "SHA1 failed!");
    }

    if (rc4test())
    {
        XDBGTRC("Crypto Test", "RC4 succeeded!");
    }
    else
    {
        XDBGTRC("Crypto Test", "RC4 failed!");
    }

    if (destest())
    {
        XDBGTRC("Crypto Test", "DES succeeded!");
    }
    else
    {
        XDBGTRC("Crypto Test", "DES failed!");
    }

    if (des3test())
    {
        XDBGTRC("Crypto Test", "Triple DES succeeded!");
    }
    else
    {
        XDBGTRC("Crypto Test", "Triple DES failed!");
    }

    if (dhtest())
    {
        XDBGTRC("Crypto Test", "Diffie Hellman succeeded!");
    }
    else
    {
        XDBGTRC("Crypto Test", "Diffie Hellman failed!");
    }

    if (pktest())
    {
        XDBGTRC("Crypto Test", "PK succeeded!");
    }
    else
    {
        XDBGTRC("Crypto Test", "PK failed!");
    }

    return TRUE;
}



//======================== The main function
void __cdecl main()
{

#if DBG
    XDebugOutLevel = XDBG_ENTRY;
    //XDebugOutLevel = XDBG_TRACE;
#endif

    //_asm int 3;

    XNetStartup(NULL);
    
    if (shatest())
    {
        XDBGTRC("Crypto Test", "SHA1 succeeded!");
    }
    else
    {
        XDBGTRC("Crypto Test", "SHA1 failed!");
    }

    if (rc4test())
    {
        XDBGTRC("Crypto Test", "RC4 succeeded!");
    }
    else
    {
        XDBGTRC("Crypto Test", "RC4 failed!");
    }

    if (destest())
    {
        XDBGTRC("Crypto Test", "DES succeeded!");
    }
    else
    {
        XDBGTRC("Crypto Test", "DES failed!");
    }

    if (des3test())
    {
        XDBGTRC("Crypto Test", "Triple DES succeeded!");
    }
    else
    {
        XDBGTRC("Crypto Test", "Triple DES failed!");
    }

    if (dhtest())
    {
        XDBGTRC("Crypto Test", "Diffie Hellman succeeded!");
    }
    else
    {
        XDBGTRC("Crypto Test", "Diffie Hellman failed!");
    }

    if (pktest())
    {
        XDBGTRC("Crypto Test", "PK succeeded!");
    }
    else
    {
        XDBGTRC("Crypto Test", "PK failed!");
    }

#ifdef AESTEST
    aestest();
#endif

    if (updatetest())
    {
        XDBGTRC("Crypto Test", "Crypto Update succeeded!");
    }
    else
    {
        XDBGTRC("Crypto Test", "Crypto Update failed!");
    }
    
    XNetCleanup();
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\dvdcont\dvdcont.cpp ===
/*++

Copyright (c) Microsoft Corporation

Author:
    Keith Lau (keithlau)

Description:
	Unit test shell for asynchronous XOnlineContentInstallFromDVD

Module Name:

    dvdcont.cpp

--*/

#include "xonp.h"
#include "testutil.h"
#include "testui.h"

#include "symmkey.c"

//
// Enable this macro if we want to wait for event before pumping
//
//#define WAIT_FOR_EVENT

#define MAX_DOWNLOAD_FILES		1

DWORD	g_dwTitleId = 100;

#define CDTEST_ALL_FILES		"\\*.*"

HRESULT HrFindFiles(
			XONLINEOFFERING_ID	OfferingId,
			DWORD				*pdwFiles
			)
{
	HRESULT	hr = S_OK;
	DWORD	dwTitleId;
	DWORD	cbPath;
	DWORD	dwFiles = 0;
	BOOL	fResult;
	BYTE	szPath[XONLINECONTENT_MAX_PATH];
	HANDLE	hFind = INVALID_HANDLE_VALUE;
	WIN32_FIND_DATA	wfd;

    dwTitleId = XeImageHeader()->Certificate->TitleID;

	cbPath = XONLINECONTENT_MAX_PATH;
	hr = XOnlineContentGetRootDirectory(
				OfferingId, FALSE,	// fUserData
				&cbPath, (CHAR *)szPath);
	if (FAILED(hr))
		return(hr);

	if ((cbPath + strlen(CDTEST_ALL_FILES)) >= XONLINECONTENT_MAX_PATH)
		return(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));

	strcpy((char *)szPath + cbPath, CDTEST_ALL_FILES);
	cbPath += strlen(CDTEST_ALL_FILES);

	hFind = FindFirstFile((LPCSTR)szPath, &wfd);
	if (hFind == INVALID_HANDLE_VALUE)
	{
		if ((GetLastError() == ERROR_FILE_NOT_FOUND) ||
			(GetLastError() == ERROR_PATH_NOT_FOUND))
		{
			*pdwFiles = 0;
			return(S_OK);
		}
		
		return(HRESULT_FROM_WIN32(GetLastError()));
	}
	fResult = TRUE;

	while (fResult)
	{
		if (wfd.cFileName[0] != '.')
			dwFiles++;

		fResult = FindNextFile(hFind, &wfd);
	}

	FindClose(hFind);

	if (GetLastError() != ERROR_NO_MORE_FILES)
	{
		FindClose(hFind);
		return(HRESULT_FROM_WIN32(GetLastError()));
	}

	FindClose(hFind);
	*pdwFiles = dwFiles;
	return(S_OK);
}

HRESULT HexStringToUlonglong(
			PSTR		szHexValue,
			DWORD		cbHexValue,
			ULONGLONG	*pullValue
			)
{
	ULONGLONG	ull = 0;
	DWORD 		i, c, len;

	len = cbHexValue?cbHexValue:strlen(szHexValue);
	if (len <= 16)
	{
		for (i = 0; i < len; i++)
		{
			c = szHexValue[(len - 1) - i];
			if ((c >= '0') && (c <= '9'))
				c = c - '0';
			else if ((c >= 'a') && ( c <= 'f'))
				c = (c - 'a') + 10;
			else if ((c >= 'A') && ( c <= 'F'))
				c = (c - 'A') + 10;
			else
				goto Error;
				
			ull |= (c << (i * 4));
		}

		*pullValue = ull;
		return(S_OK);
	}

Error:	
	return(HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
}

HRESULT ConvertToTitleId(
			PSTR	szTitleId,
			DWORD	*pdwTitleId
			)
{
	HRESULT		hr;
	ULONGLONG	ull;
	hr = HexStringToUlonglong(szTitleId, 8, &ull);
	*pdwTitleId = (DWORD)ull;
	return(hr);
}

HRESULT ConvertToOfferingId(
			PSTR				szOfferingId,
			XONLINEOFFERING_ID	*pOfferingId
			)
{
	HRESULT		hr;
	ULONGLONG	ull;
	hr = HexStringToUlonglong(szOfferingId, 8, &ull);
	*pOfferingId = (DWORD)ull;
	return(hr);
}


HRESULT ParseContentDirName(
			PSTR				szContentDir,
			XONLINEOFFERING_ID	*pOfferingId,
			DWORD				*pdwBitFilter
			)
{
	HRESULT	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	PSTR	pTemp = strchr(szContentDir, '.');

	if (pTemp)
	{
		*pTemp++ = '\0';
		hr = ConvertToOfferingId(szContentDir, pOfferingId);
		if (FAILED(hr))
			goto Error;

		hr = ConvertToTitleId(pTemp, pdwBitFilter);
		if (FAILED(hr))
			goto Error;
	}

Error:	
	return(hr);
}

typedef enum
{
	INSTALL_DOWNLOAD = 0,
	INSTALL_VERIFY,
	INSTALL_REMOVE,
	INSTALL_MAX
	
} INSTALL_STATES;

const WCHAR *rgwszStates[INSTALL_MAX] =
{
	L"INSTALLING", L"VERIFYING", L"REMOVING"
};

DWORD					dwPumpCalls = 0;
DWORD					dwIterations = 0;
DWORD					rgdwBitFlags[MAX_DOWNLOAD_FILES];
XONLINEOFFERING_ID		rgOid[MAX_DOWNLOAD_FILES];
XONLINETASK_HANDLE		rghTask[MAX_DOWNLOAD_FILES];
INSTALL_STATES			rgInstallState[MAX_DOWNLOAD_FILES];

WCHAR StatusBuffer[2400];

VOID DisplayStatus(
			XONLINEOFFERING_ID	OfferingId,
			INSTALL_STATES		is,
			XONLINETASK_HANDLE	hTask
			)
{
	HRESULT			hr;
	ULARGE_INTEGER	ulin, ulid;
	DWORD			dwPercentDone;

	hr = XOnlineContentInstallGetProgress(hTask, 
				&dwPercentDone, &(ulin.QuadPart), &(ulid.QuadPart));

	BeginNewScene();

	wsprintf(StatusBuffer,
		L"%u pump calls made\r\n"\
		L"%u packages downloaded, verified and removed\r\n"\
		L"Content ID: %u\r\n"\
		L"Processing Status: %s\r\n",
		dwPumpCalls, dwIterations, OfferingId, rgwszStates[is]);
	Xputs(StatusBuffer);

	if (is ==INSTALL_DOWNLOAD)
	{
		wsprintf(StatusBuffer, 
				L"  Install progress %u percent (%I64u / %I64u)\r\n",
				dwPercentDone, ulin, ulid);
		Xputs(StatusBuffer);				
	}

	PresentScene();
}

void Initialize()
{
	DWORD i;

	for (i = 0; i < MAX_DOWNLOAD_FILES; i++)
	{
		rghTask[i] = NULL;
		rgInstallState[i] = INSTALL_DOWNLOAD;
	}
}

#define NUM_SERVICES	1
DWORD			g_rgServices[NUM_SERVICES] =
{
	XONLINE_BILLING_OFFERING_SERVICE
};


//======================== The main function
void __cdecl main()
{
    HRESULT				hr;

	ULARGE_INTEGER		uliContentLength;
	CHAR				szReference[MAX_PATH];
	CHAR				szDownloadLocation[MAX_PATH];
	CHAR				szTime1[MAX_TIME_SIZE];
	CHAR				szTime2[MAX_TIME_SIZE];
	DWORD				dwInitialized;
    DWORD				dwCurTask = 0;
    DWORD				dwReason = 0;
    DWORD				dwError;
    DWORD				dwFiles;
    DWORD				dwSize;
    DWORD				i;

	DWORD				dwStatus;
	FILETIME			ftTime;
	FILETIME			ftLastModified;

	PBYTE				pbBuffer1 = NULL;
	PBYTE				pbBuffer2 = NULL;
    XONLINETASK_HANDLE	hLogon;

	CHAR				szRootPath[MAX_PATH];
    CHAR				szPath[MAX_PATH];
    DWORD				cbPath;

	HANDLE				hFind;
	WIN32_FIND_DATA		wfd;

	XONLINE_STARTUP_PARAMS	xosp = { 0 };

	XNetStartupParams 	xnsp = { sizeof(XNetStartupParams), 
								XNET_STARTUP_BYPASS_SECURITY };

	// Set up the 'current' Title ID
	ChangeCurrentTitleId(g_dwTitleId);
	
    DebugPrint("Loading XBox network stack...\n");
    dwError = XNetStartup(&xnsp);
    if (dwError != NO_ERROR)
    {
	    DebugPrint("Failed XNetStartup with %d\n", dwError);
        return;
    }

    DebugPrint("Calling XOnlineStartup...\n");
    hr = XOnlineStartup(&xosp);
    if (FAILED(hr))
    {
        DebugPrint("Error %08x returned by XOnlineStartup\n", hr);
        dwReason = 1;
        goto Error;
    }

	// Dump the size of the content download context for info
	DebugPrint("Size of context: %u bytes", 
				sizeof(XONLINETASK_CONTENT_DOWNLOAD));

#if 0
	// Initialize services
	hr = XOnlineLogonWrapper(g_rgServices, NUM_SERVICES, &hLogon);
	if (FAILED(hr))
	{
        DebugPrint("Cannot Logon (%08x), check c:\\xonline.ini\n", hr);
        RIP("Failed to initialize services");
        dwReason = 2;
        goto Error;
	}
#endif	

	// Initialize test specific stuff
	Initialize();

	// Initialize graphics stuff
	hr = InitializeGraphics();
	if (FAILED(hr))
	{
        DebugPrint("Cannot initialize graphics (%08x)\n", hr);
        RIP("Failed to initialize graphics");
        dwReason = 3;
        goto Error;
	}

	// Initialize text font
	hr = InitializeFont(0xffffffff, 0xff000000, XFONT_OPAQUE);
	if (FAILED(hr))
	{
        DebugPrint("Cannot initialize text (%08x)\n", hr);
        RIP("Failed to initialize text");
        dwReason = 4;
        goto Error;
	}

Redo:

	// Build the search path for content
	sprintf(szRootPath, "d:\\$c\\%08x\\", g_dwTitleId);
	strcpy(szPath, szRootPath);
	strcat(szPath, "*.*");
	hFind = FindFirstFile(szPath, &wfd);
	if (hFind == INVALID_HANDLE_VALUE)
	{
        DebugPrint("Cannot enumerate DVD content (%08x)\n", GetLastError());
        RIP("Failed to enumerate DVD content");
        dwReason = 5;
        goto Error;
	}

	// Loop downloading packages
	while (1)
	{
		// Start the task if completed
		if (!rghTask[dwCurTask])
		{
			switch (rgInstallState[dwCurTask])
			{
			case INSTALL_DOWNLOAD:

				// Figure out the target path, assume all content
				// packages are called content.xcp
				strcpy(szPath, szRootPath);
				strcat(szPath, wfd.cFileName);
				strcat(szPath, "\\content.xcp");

				hr = ParseContentDirName(wfd.cFileName, 
							&(rgOid[dwCurTask]), &(rgdwBitFlags[dwCurTask]));
				if (FAILED(hr))
				{
			        RIP("Failed parse content dir");
			        dwReason = 80;
			        goto Error;
				}

				// Install the content package
			    hr = XOnlineContentInstallFromDVD(
			    			szPath,
			    			g_dwTitleId,
			    			rgOid[dwCurTask],
			    			rgdwBitFlags[dwCurTask],
			    			rgbSymmetricKey,
			    			sizeof(rgbSymmetricKey),
			    			g_rgbPublicKey,
			    			g_cbPublicKey,
							NULL, 
	 		    			&(rghTask[dwCurTask]));

//			    DebugPrint("Installing %u  (hTask = %p)\n", 
//			    			rgOid[dwCurTask], rghTask[dwCurTask]);
			    
		    	AssertSz(SUCCEEDED(hr), "Cannot start install");
			    Assert(rghTask[dwCurTask] != NULL);

			    if (FAILED(hr))
			    {
			    	dwReason = 100;
			    	goto Error;
			    }

				dwIterations++;
//				DebugPrint("Iteration #%u\n", dwIterations);
			    break;

			case INSTALL_VERIFY:
				// Verify the content
				dwSize = XBOX_HD_SECTOR_SIZE * 2;
				hr = XOnlineContentVerify(
			    			rgOid[dwCurTask],
							NULL, &dwSize,
							NULL, 
	 		    			&(rghTask[dwCurTask]));
							
//			    DebugPrint("Verifying %u  (hTask = %p)\n", 
//			    			rgOid[dwCurTask], rghTask[dwCurTask]);
			    
		    	AssertSz(SUCCEEDED(hr), "Cannot start verification");
			    Assert(rghTask[dwCurTask] != NULL);

			    if (FAILED(hr))
			    {
			    	dwReason = 110;
			    	goto Error;
			    }
			    break;
				
			case INSTALL_REMOVE:
				// Remove the content
				hr = XOnlineContentRemove(
			    			rgOid[dwCurTask],
							NULL, 
	 		    			&(rghTask[dwCurTask]));
							
//			    DebugPrint("Removing %u  (hTask = %p)\n", 
//			    			rgOid[dwCurTask], rghTask[dwCurTask]);
			    
		    	AssertSz(SUCCEEDED(hr), "Cannot start removal");
                Assert(rghTask[dwCurTask] != NULL);

			    if (FAILED(hr))
			    {
			    	dwReason = 120;
			    	goto Error;
			    }
			    break;

			default:
				RIP("INVALID State");
			}
		}

		// Display status every x pumps
		if ((dwPumpCalls & 0xff) == 0)
		{
			DisplayStatus(
						rgOid[dwCurTask],
						rgInstallState[dwCurTask], 
						rghTask[dwCurTask]);
		}
		
		// Continue if required
		if (rghTask[dwCurTask])
		{
			hr = XOnlineTaskContinue(rghTask[dwCurTask]);
			if (XONLINETASK_STATUS_AVAILABLE(hr))
			{
				switch (rgInstallState[dwCurTask])
				{
				case INSTALL_DOWNLOAD:
				
					// Download complete ...
				    AssertSz(SUCCEEDED(hr), "Download");

				    if (FAILED(hr))
				    {
				    	dwReason = 200;
				    	goto Error;
				    }

				    hr = HrFindFiles(rgOid[dwCurTask], &dwFiles);
				    Assert(SUCCEEDED(hr) && dwFiles);

//				    DebugPrint("Download got %u files\n", dwFiles);

				    rgInstallState[dwCurTask] = INSTALL_VERIFY;

				    if (FAILED(hr))
				    {
				    	dwReason = 201;
				    	goto Error;
				    }
				    break;

				case INSTALL_VERIFY:

				    if (FAILED(hr))
				    {
				    	dwReason = 210;
				    	goto Error;
				    }

					// Verification complete ...
				    Assert(SUCCEEDED(hr));
				    rgInstallState[dwCurTask] = INSTALL_REMOVE;
					break;

				case INSTALL_REMOVE:
				
				    if (FAILED(hr))
				    {
				    	dwReason = 220;
				    	goto Error;
				    }
				    	
					// Remove complete ...
				    Assert(SUCCEEDED(hr));

				    hr = HrFindFiles(rgOid[dwCurTask], &dwFiles);
				    Assert(FAILED(hr) || !dwFiles);
				    hr = S_OK;

//				    DebugPrint("Remove left %u files\n", dwFiles);
					rgInstallState[dwCurTask] = INSTALL_DOWNLOAD;
				    break;

				default:
					RIP("INVALID State");
				}

				// Close the handle
				XOnlineTaskClose(rghTask[dwCurTask]);
				rghTask[dwCurTask] = NULL;

				if (rgInstallState[dwCurTask] == INSTALL_DOWNLOAD)
				{
					// Next Task
					dwCurTask++;
					if (dwCurTask >= MAX_DOWNLOAD_FILES)
						dwCurTask = 0;

					// Find the next piece of content
					if (!FindNextFile(hFind, &wfd))
					{
						FindClose(hFind);
						goto Redo;
					}
				}
			}
		}

		dwPumpCalls++;
	}

Exit:

    DebugPrint("Shutting down XOnline...\n");
    XOnlineCleanup();

	return;

Error:
	DebugPrint("Error occurred: %08x at %u\n\n", hr, dwReason);
	goto Exit;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\dvdcont\symmkey.c ===
BYTE rgbSymmetricKey[] =
{
	0x24, 0xDF, 0x69, 0x93, 0x96, 0xB8, 0xEA, 0x2A, 0x88, 0xD1, 0x33, 0x03, 0xCE, 0xEC, 0x0A, 0xE2
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\DVDTitleUpdate\DVDTitleUpdate.cpp ===
/*++

Copyright (c) Microsoft Corporation

Author:
    Keith Lau (keithlau)

Description:
	Unit test shell for DVD Title Update

Module Name:

    DVDTitleUpdate.cpp

--*/

#include "xonp.h"
#include "testutil.h"
#include "testui.h"

#ifdef DASH_UPDATE

#include "dash\package\symmkey.c"

const WCHAR	wszRebootMsg[] = 
			L"The Dashboard has been successfully updated from DVD.\n"
			L"Reboot your Xbox into the dashboard, and if\n"
			L"this worked, you will see a message telling you\n"
			L"that Autoreboot worked for DASH.\n";

#else

#include "title\package\symmkey.c"

const WCHAR	wszRebootMsg[] = 
			L"The current title has been successfully updated from DVD.\n"
			L"Reboot your Xbox and run this app again, and if\n"
			L"this worked, you will see a message telling you\n"
			L"that Autoreboot worked for TITLE.\n";

#endif

DWORD dwPumpCalls = 0;

WCHAR StatusBuffer[2400];

VOID DisplayStatus(
			DWORD				dwTitleId,
			XONLINETASK_HANDLE	hTask
			)
{
	HRESULT			hr;
	ULONGLONG		qwn, qwd;
	DWORD			dwPercentDone;

	hr = XOnlineTitleUpdateGetProgress(hTask, 
		&dwPercentDone, &qwn, &qwd);

	BeginNewScene();

	wsprintf(StatusBuffer,
		L"%u pump calls made\r\n"\
		L"Title ID: %u (%08x)\r\n",
		dwPumpCalls, dwTitleId, dwTitleId);
	Xputs(StatusBuffer);

	wsprintf(StatusBuffer, 
			L"  Autoupdate progress %u percent (%I64u / %I64u)\r\n",
			dwPercentDone, qwn, qwd);
	Xputs(StatusBuffer);				

	PresentScene();
}

#if 0 
//
// Implement verification routines to make sure the update happened
// correctly
//
HRESULT AutoupdCheckDirsDoWork(
			XONLINETASK_OP		op,
			XONLINETASK_HANDLE	hTask, 
			DWORD				dwMaxExecutionTimeSlice,
			DWORD				*pdwWorkFlags
			)
{
	HRESULT					hr = S_OK;
	PXONLINETASK_DIRCOPY	pdircopy;

	Assert(op == XONLINETASK_DOWORK);
	Assert(hTask != NULL);

	// Locate the containing object
	pdircopy = CONTAINING_RECORD(hTask, XONLINETASK_DIRCOPY, xontaskOnDir);

	// All we do is create the directory
	if (!CreateDirectory(pdircopy->dircrawl.szTarget, NULL))
		hr = HRESULT_FROM_WIN32(GetLastError());

	XONLINETASK_WORKFLAGS_SET_DONT_CONTINUE(pdwWorkFlags);
	return(hr);
}

//
// Simple per-file task handler to do a directory copy
//
HRESULT AutoupdCheckFilesDoWork(
			XONLINETASK_OP		op,
			XONLINETASK_HANDLE	hTask, 
			DWORD				dwMaxExecutionTimeSlice,
			DWORD				*pdwWorkFlags
			)
{
	HRESULT					hr = S_OK;
	PXONLINETASK_DIRCOPY	pdircopy;
	PXONLINETASK_DIRCRAWL	pdircrawl;
	ULARGE_INTEGER			uliSize;
	DWORD					cbSize;
	DWORD					cbTarget;

	Assert(op == XONLINETASK_DOWORK);
	Assert(hTask != NULL);

	// Locate the containing object
	pdircopy = CONTAINING_RECORD(hTask, XONLINETASK_DIRCOPY, xontaskOnFile);
	pdircrawl = &pdircopy->dircrawl;

	// Build the source and target paths for copy, making sure not to overrun
	// the buffers
	pdircrawl = &pdircopy->dircrawl;
	cbSize = strlen(pdircrawl->wfd.cFileName);
	Assert(pdircrawl->szTarget != NULL);
    Assert((pdircrawl->szPath + cbSize) < pdircrawl->cbMax);
    Assert((pdircrawl->szTarget + cbSize) < pdircrawl->cbMax);

	// Build the fill copy paths
	cbSize = pdircrawl->cbPath;
	cbTarget = pdircrawl->cbTarget;
	strcpy(pdircrawl->szPath + cbSize, pdircrawl->wfd.cFileName);
	strcpy(pdircrawl->szTarget + cbTarget, pdircrawl->wfd.cFileName);

	// All we do is create the directory
	if (!CopyFile(pdircrawl->szPath, pdircrawl->szTarget, FALSE))
		hr = HRESULT_FROM_WIN32(GetLastError());
	else
	{
		// Update the statistics
		(pdircopy->dwFilesCopied)++;
		uliSize.u.LowPart = pdircrawl->wfd.nFileSizeLow;
		uliSize.u.HighPart = pdircrawl->wfd.nFileSizeHigh;
		pdircopy->uliBytesCopied.QuadPart += uliSize.QuadPart;
	}

	// Restore the path strings
	pdircrawl->cbPath = cbSize;
	pdircrawl->szPath[cbSize] = '\0';
	pdircrawl->cbTarget = cbTarget;
	pdircrawl->szTarget[cbTarget] = '\0';

	XONLINETASK_WORKFLAGS_SET_DONT_CONTINUE(pdwWorkFlags);
	return(hr);
}

#endif

#define NUM_SERVICES	1
DWORD			g_rgServices[NUM_SERVICES] =
{
	XONLINE_AUTO_UPDATE_SERVICE
};

//======================== The main function
void __cdecl main()
{
    HRESULT				hr = S_OK;
    DWORD				dwTitleId;
    DWORD				dwError;
    DWORD				dwLastStatusUpdate = 0;
    HANDLE				hEvent = NULL;
	XONLINETASK_HANDLE	hTask = NULL;
    XONLINETASK_HANDLE	hLogon = NULL;
    WCHAR				wszReboot[MAX_PATH];
    CHAR				szPath[MAX_PATH];

	XONLINE_STARTUP_PARAMS	xosp = { 0 };

	XNetStartupParams 	xnsp = { sizeof(XNetStartupParams), 
								XNET_STARTUP_BYPASS_SECURITY };

    DebugPrint("Loading XBox network stack...\n");
    dwError = XNetStartup(&xnsp);
    if (dwError != NO_ERROR)
    {
	    DebugPrint("Failed XNetStartup with %d\n", dwError);
        return;
    }

    DebugPrint("Calling XOnlineStartup...\n");
    hr = XOnlineStartup(&xosp);
    if (FAILED(hr))
    {
        DebugPrint("Error %08x returned by XOnlineStartup\n", hr);
        return;
    }

	// Dump the size of the content download context for info
	// DebugPrint("Size of context: %u bytes", sizeof(XONLINETASK_AUTOUPD_ONLINE));

	hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

	// Initialize graphics stuff
	hr = InitializeGraphics();
	if (FAILED(hr))
	{
        DebugPrint("Cannot initialize graphics (%08x)\n", hr);
        RIP("Failed to initialize graphics");
        return;
	}

	// Initialize text font
	hr = InitializeFont(0xffffffff, 0xff000000, XFONT_OPAQUE);
	if (FAILED(hr))
	{
        DebugPrint("Cannot initialize text (%08x)\n", hr);
        RIP("Failed to initialize text");
        return;
	}

#if 0
	// Initialize services
	hr = XOnlineLogonWrapper(g_rgServices, NUM_SERVICES, &hLogon);
	if (FAILED(hr))
	{
        DebugPrint("Cannot Logon (%08x), check c:\\xonline.ini\n", hr);
        RIP("Failed to initialize services");
        return;
	}
#endif	

	DWORD	dwVersion;
	DWORD	cbTitleKey;
	BYTE	rgbTitleKey[XONLINE_KEY_LENGTH];
	
	dwTitleId = XeImageHeader()->Certificate->TitleID;
	dwVersion = XeImageHeader()->Certificate->Version;

	cbTitleKey = XONLINE_KEY_LENGTH;
	hr = XoUpdateGetRawTitleKey(dwTitleId, rgbTitleKey, &cbTitleKey);
	if (FAILED(hr))
	if (FAILED(hr))
	{
		_asm int 3;
	}

	sprintf(szPath, "d:\\$u\\%08x\\update.xcp", dwTitleId);

	// Just kick off the title update
	hr = XOnlineTitleUpdateFromDVDInternal(
				szPath,
				dwTitleId,
				dwVersion, 
				rgbTitleKey,
				(PBYTE)rgbSymmetricKey,
				sizeof(rgbSymmetricKey),
				g_rgbPublicKey,
				g_cbPublicKey,
				hEvent, &hTask);
	if (FAILED(hr))
	{
		_asm int 3;
	}

	dwLastStatusUpdate = GetTickCount();
	while (1)
	{
		hr = XOnlineTaskContinue(hTask);
		if (XONLINETASK_STATUS_AVAILABLE(hr))
		{
			if (FAILED(hr))
			{
				_asm int 3;
			}

			// Branch out here to tell the user to reboot
			goto PromptReboot;
		}
		
		dwPumpCalls++;

		// Display status every x pumps
		if ((GetTickCount() - dwLastStatusUpdate) > 100)
		{
			DisplayStatus(dwTitleId, hTask);
			dwLastStatusUpdate = GetTickCount();
		}
	}

PromptReboot:

	BeginNewScene();

	wcscpy((WCHAR *)wszReboot, (WCHAR *)wszRebootMsg);
	Xputs(wszReboot);

	PresentScene();

	while (1)
		Sleep(1000);

	// Break here
	_asm int 3;

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\dvdenum\dvdenum.cpp ===
/*++

Copyright (c) Microsoft Corporation

Author:
    Keith Lau (keithlau)

Description:
	Unit test shell for asynchronous content enumeration

Module Name:

    dvdenum.c

--*/

#include "xonp.h"
#include "testutil.h"
#include "testui.h"

VOID DisplayResults(
			ULARGE_INTEGER			*puliIterations,
			DWORD					dwEnumerations,
			PXONLINEOFFERING_INFO	*rgpEnumInfo,
			DWORD					dwResults,
			DWORD					dwBitFilter
			)
{
	WCHAR	wsz[2048];
	DWORD	i;
	SYSTEMTIME	st;

	BeginNewScene();

	wsprintf(wsz, L"%I64u Pump calls made\r\n"\
				L"Enumeration #%u returned %u results.\r\n \r\n"\
				L"Bitfilter = 0x%08x\r\n \r\n"\
				L"=============================================\r\n",
				*puliIterations, dwEnumerations, dwResults, dwBitFilter);
	Xputs(wsz);

	if (dwResults)
	{
		for (i = 0; i < dwResults; i++)
		{
			FileTimeToSystemTime(&(rgpEnumInfo[i]->ftActivationDate), &st);
			
			wsprintf(wsz, L"%u (0x%08x)   %08x\r\n",
						rgpEnumInfo[i]->OfferingId, rgpEnumInfo[i]->OfferingId,
						rgpEnumInfo[i]->dwBitFlags
						);
			Xputs(wsz);
		}
	}
	else
	{
		Xputs(L"No results.");
	}

	PresentScene();
}

//======================== The main function
void __cdecl main()
{
    HRESULT				hr;
    DWORD				dwError;

	XONLINETASK_HANDLE	hTask = NULL;
    BOOL				fPartial = FALSE;

	PBYTE				pbBuffer = NULL;
	DWORD				cbBuffer;
	DWORD				dwMaxResults;
	DWORD				dwResults;
    ULARGE_INTEGER		uliIterations = {0, 0};
	DWORD				dwEnumerations = 0;

	XONLINEOFFERING_ENUM_PARAMS	enumparams;
	PXONLINEOFFERING_INFO		*rgpEnumInfo;

	dwError = XOnlineStartup(NULL);
	if(dwError != S_OK)
    {
	    DebugPrint("Failed XOnlineStartup with %x\n", dwError);
        return;
    } 

	// Initialize graphics stuff
	hr = InitializeGraphics();
	if (FAILED(hr))
	{
        DebugPrint("Cannot initialize graphics (%08x)\n", hr);
        AssertSz(SUCCEEDED(hr), "Failed to initialize graphics");
        return;
	}

	// Initialize text font
	hr = InitializeFont(0xffffffff, 0xff000000, XFONT_OPAQUE);
	if (FAILED(hr))
	{
        DebugPrint("Cannot initialize text (%08x)\n", hr);
        AssertSz(SUCCEEDED(hr), "Failed to initialize text");
        return;
	}

	// Set up the enumeration params
	enumparams.dwOfferingType = 0;
	enumparams.dwBitFilter = 0;
	enumparams.dwMaxResults = 10;
	enumparams.dwDescriptionIndex = 0;

	// Allocate buffer to do work
	dwMaxResults = 10;
	cbBuffer = XOnlineOfferingEnumerateMaxSize(&enumparams, 0);
	pbBuffer = (PBYTE)LocalAlloc(LMEM_FIXED, cbBuffer);
	if (!pbBuffer)
	{
        DebugPrint("Cannot allocate memory (%u)\n", GetLastError());
        return;
	}

	// Loop downloading files
	while (1)
	{
		(uliIterations.QuadPart)++;

		// Start the task if completed
		if (!hTask)
		{
			enumparams.dwBitFilter = dwEnumerations;
			
			// Begin a new enumeration
			hr = XOnlineOfferingEnumerate(
						XONLINEOFFERING_ENUM_DEVICE_DVD,
						0, &enumparams,
						pbBuffer,
						cbBuffer,
						NULL,
						&hTask);

	    	AssertSz(SUCCEEDED(hr), "Cannot start enumeration");
		    Assert(hTask != NULL);
		}

		// Continue if required
		if (hTask)
		{
			hr = XOnlineTaskContinue(hTask);
			if (XONLINETASK_STATUS_AVAILABLE(hr))
			{
				// Enumerate complete ...
				hr = XOnlineOfferingEnumerateGetResults(
							hTask, 
							&rgpEnumInfo,
							&dwResults,
							&fPartial);
			    Assert(SUCCEEDED(hr));

				// Display the results
				DisplayResults(
							&uliIterations, dwEnumerations, 
							rgpEnumInfo, dwResults, 
							enumparams.dwBitFilter);

				if (!fPartial)
				{
					dwEnumerations++;
			
					// Close the handle
					XOnlineTaskClose(hTask);
					hTask = NULL;
				}
			}
		}
	}

	// Break here
	_asm int 3;

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\DVDTitleUpdate\sources.inc ===
USE_LIBCMT=1
 
SYNCRHONIZE_DRAIN=1

LINKER_FLAGS=$(LINKER_FLAGS) /IGNORE:4049,4217 /MAP

C_DEFINES=$(C_DEFINES) -DXONLINE_BUILD_LIBX

INCLUDES=\
    $(BASEDIR)\public\sdk\inc; \
    $(BASEDIR)\private\inc;\
    $(BASEDIR)\private\inc\crypto;\
    $(BASEDIR)\private\ntos\inc;\
    $(BASEDIR)\private\ntos\xapi\inc;\
    $(BASEDIR)\private\online\kerb;\
    $(BASEDIR)\private\online\util;\
    $(BASEDIR)\private\online;\
    $(BASEDIR)\private\ntos\net;\
    $(BASEDIR)\private\online\test\common;

SOURCES=\
    DVDTitleUpdate.cpp

TARGETLIBS=\
    $(SDK_LIB_PATH)\xonline$(D).lib \
    $(BASEDIR)\private\online\test\common\obj\i386\testutil$(D).lib \
    $(SDK_LIB_PATH)\xgraphics$(D).lib \
    $(LIBRARY_PATH)\d3d8$(D).lib \
    $(LIBRARY_PATH)\d3dx8$(D).lib
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\DVDTitleUpdate\Title\package\symmkey.c ===
// 0x4153513B48E643AF1C0FD7200E4EAE52

const unsigned char rgbSymmetricKey[] = {
	0x41, 0x53, 0x51, 0x3B, 0x48, 0xE6, 0x43, 0xAF,
	0x1C, 0x0F, 0xD7, 0x20, 0x0E, 0x4E, 0xAE, 0x52
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\DVDTitleUpdate\Dash\package\symmkey.c ===
// 0x223A17D78D7474EBEF2A9ED647E0133C

const unsigned char rgbSymmetricKey[] = {
	0x22, 0x3A, 0x17, 0xD7, 0x8D, 0x74, 0x74, 0xEB,
	0xEF, 0x2A, 0x9E, 0xD6, 0x47, 0xE0, 0x13, 0x3C
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\enumtest\xmain.cpp ===
/*++

Copyright (c) Microsoft Corporation

Author:
    Keith Lau (keithlau)

Description:
	Unit test shell for asynchronous content enumeration

Module Name:

    xmain.c

--*/

#include "xonp.h"
#include "testutil.h"
#include "testui.h"

#define MAX_TITLE_ID			4
#define MAX_LANG_ID				4

DWORD dwCurTitle = 0;
DWORD dwCurLang = 0;

DWORD rgdwTitleId[MAX_TITLE_ID] =
{
	0, 100, 101, 102
};

DWORD rgdwLangId[MAX_LANG_ID] =
{
	1, 2, 3, 4
};

VOID DisplayTitles()
{
	HRESULT				hr;
	XONLINETASK_HANDLE	hTask;
    XONLINETASK_HANDLE	hLogon;
	WCHAR				wsz[2048];
	DWORD				*rgTitleId;
	DWORD				dwTitleId;
	DWORD				i;

	BeginNewScene();

	Xputs(L"Titles found on this machine:");

	hr = XOnlineEnumerateTitlesBegin(2, NULL, &hTask);
	Assert(SUCCEEDED(hr));
	Assert(hTask != NULL);

	do
	{
		hr = XOnlineTaskContinue(hTask);
		if (XONLINETASK_STATUS_AVAILABLE(hr))
		{
			// Bail if the subtask indicated failure
			Assert(SUCCEEDED(hr));

			hr = XOnlineEnumerateTitlesGetResults(hTask, &rgTitleId, &dwTitleId);
			Assert(SUCCEEDED(hr));

			Xputs(L"============================");

			if (dwTitleId)
			{
				for (i = 0; i < dwTitleId; i++)
				{
					wsprintf(wsz, L"%08x (%u)", rgTitleId[i], rgTitleId[i]);
					Xputs(wsz);
				}
			}
			else
			{
				Xputs(L"No more results.");
				break;
			}
		}
		
	} while (1);

	PresentScene();
}

VOID DisplayResults(
			ULARGE_INTEGER			*puliIterations,
			DWORD					dwEnumerations,
			PXONLINEOFFERING_INFO	*rgpEnumInfo,
			DWORD					dwResults
			)
{
	WCHAR	wsz[2048];
	DWORD	i;
	SYSTEMTIME	st;

	BeginNewScene();

	wsprintf(wsz, L"%I64u Pump calls made\r\n"\
				L"Title ID: %u\r\n"\
				L"Enumeration #%u returned %u results.\r\n \r\n"\
				L"==========================================================\r\n",
				*puliIterations, rgdwTitleId[dwCurTitle], 
				dwEnumerations, dwResults);
	Xputs(wsz);

	if (dwResults)
	{
		for (i = 0; i < dwResults; i++)
		{
			FileTimeToSystemTime(&(rgpEnumInfo[i]->ftActivationDate), &st);
			
			wsprintf(wsz, L"%u  %02d/%02d/%04d  %08x  %08x  %u  %u  %u\r\n",
						rgpEnumInfo[i]->OfferingId,
						st.wMonth, st.wDay, st.wYear,
						rgpEnumInfo[i]->dwOfferingType,
						rgpEnumInfo[i]->dwBitFlags,
						rgpEnumInfo[i]->dwRating,
						rgpEnumInfo[i]->cbPackageSize,
						rgpEnumInfo[i]->cbInstallSize,
						rgpEnumInfo[i]->cbTitleSpecificData
						);
			Xputs(wsz);
		}
	}
	else
	{
		Xputs(L"No results.");
	}

	PresentScene();
}

#define NUM_SERVICES	1
DWORD			g_rgServices[NUM_SERVICES] =
{
	XONLINE_BILLING_OFFERING_SERVICE
};

//======================== The main function
void __cdecl main()
{
    HRESULT				hr;

	XONLINETASK_HANDLE	hTask = NULL;
    BOOL				fPartial = FALSE;

    WSADATA				WsaData;
	DWORD				dwError;

	PBYTE				pbBuffer = NULL;
	DWORD				cbBuffer;
	DWORD				dwMaxResults;
	DWORD				dwResults;
	SYSTEMTIME			st;
	FILETIME			ftCreatedAfter;

    ULARGE_INTEGER		uliIterations = {0, 0};
	DWORD				dwEnumerations = 0;

	DWORD				dwInitialized;

	XONLINEOFFERING_ENUM_PARAMS	enumparams;
	PXONLINEOFFERING_INFO		*rgpEnumInfo;
    XONLINETASK_HANDLE	hLogon;

	XONLINE_STARTUP_PARAMS	xosp = { 0 };
	
	XNetStartupParams 	xnsp = { sizeof(XNetStartupParams), 
								XNET_STARTUP_BYPASS_SECURITY };


	//  this lets us bypass auth for testing purposes.
    DebugPrint("Loading XBox network stack...\n");
    dwError = XNetStartup(&xnsp);
    if (dwError != NO_ERROR)
    {
	    DebugPrint("Failed XNetStartup with %d\n", dwError);
        return;
    }


    DebugPrint("Calling XOnlineStartup...\n");
    hr = XOnlineStartup(&xosp);
    if (FAILED(hr))
    {
        DebugPrint("Error %08x returned by XOnlineStartup\n", hr);
    	_asm int 3;
        return;
    }

	// Initialize services
	hr = XOnlineLogonWrapper(g_rgServices, NUM_SERVICES, &hLogon);
	if (FAILED(hr))
	{
        DebugPrint("Cannot Logon (%08x), check c:\\xonline.ini\n", hr);
        AssertSz(SUCCEEDED(hr), "Failed to initialize services");
        return;
	}

	// Initialize graphics stuff
	hr = InitializeGraphics();
	if (FAILED(hr))
	{
        DebugPrint("Cannot initialize graphics (%08x)\n", hr);
        AssertSz(SUCCEEDED(hr), "Failed to initialize graphics");
        return;
	}

	// Initialize text font
	hr = InitializeFont(0xffffffff, 0xff000000, XFONT_OPAQUE);
	if (FAILED(hr))
	{
        DebugPrint("Cannot initialize text (%08x)\n", hr);
        AssertSz(SUCCEEDED(hr), "Failed to initialize text");
        return;
	}

	// Set some time for filtering
	st.wYear = 2000;
	st.wMonth = 1;
	st.wDay = 1;
	st.wDayOfWeek = 6;
	st.wHour = 0;
	st.wMinute = 0;
	st.wSecond = 0;
	st.wMilliseconds = 0;
	SystemTimeToFileTime(&st, &ftCreatedAfter);

	// Set up the enumeration params
	enumparams.dwOfferingType = 0xffffffff;	// All types
	enumparams.dwBitFilter = 0xffffffff;	// All offerings
	enumparams.dwMaxResults = 10;			// Up to 10 records at a time
	enumparams.ftActiveAfter = ftCreatedAfter;
	enumparams.dwDescriptionIndex = 0;		// only look at the "english language" description!

	// Allocate buffer to do work
	dwMaxResults = 10;
	cbBuffer = XOnlineOfferingEnumerateMaxSize(&enumparams, 0);
	pbBuffer = (PBYTE)LocalAlloc(LMEM_FIXED, cbBuffer);
	if (!pbBuffer)
	{
        DebugPrint("Cannot allocate memory (%u)\n", GetLastError());
        return;
	}

	ChangeCurrentTitleId(rgdwTitleId[dwCurTitle]);

	// Test title enumeration
	// DisplayTitles();

	// Loop downloading files
	while (1)
	{
		(uliIterations.QuadPart)++;

		// Start the task if completed
		if (!hTask)
		{

			// force this process to go through, avoiding the checks.
			PXONLINE_USER pUsers;
			pUsers = XOnlineGetLogonUsers();
			pUsers[0].xuid.qwUserID = 0xCAFEBABE;
			pUsers[0].xuid.dwUserFlags =0;

			if (dwCurTitle >= MAX_TITLE_ID)
			   	dwCurTitle = 0;
			ChangeCurrentTitleId(rgdwTitleId[dwCurTitle]);

						ChangeCurrentTitleId(100);
			// Begin a new enumeration
			hr = XOnlineOfferingEnumerate(
						XONLINEOFFERING_ENUM_DEVICE_ONLINE,
						0, &enumparams,
						pbBuffer,
						cbBuffer,
						NULL,
						&hTask);

			DebugPrint("Enumerating content for title %u, %u records (hTask = %p)\n", 
						rgdwTitleId[dwCurTitle], dwMaxResults, hTask);
		    
	    	AssertSz(SUCCEEDED(hr), "Cannot start enumeration");
		    Assert(hTask != NULL);
		}

		// Continue if required
		if (hTask)
		{
			hr = XOnlineTaskContinue(hTask);
			if (XONLINETASK_STATUS_AVAILABLE(hr))
			{
				dwEnumerations++;
			
				// Enumerate complete ...
				hr = XOnlineOfferingEnumerateGetResults(
							hTask, 
							&rgpEnumInfo,
							&dwResults,
							&fPartial);
			    Assert(SUCCEEDED(hr));

				// Display the results
				DisplayResults(
							&uliIterations, dwEnumerations, 
							rgpEnumInfo, dwResults);

				if (!fPartial)
				{
					// Close the handle
					XOnlineTaskClose(hTask);
					hTask = NULL;

				    // Move on to next title
					dwCurTitle++;		

				}
			}
		}
	}

    DebugPrint("Unloading XOnline ...\n");
    XOnlineCleanup();

	// Break here
	_asm int 3;

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\gssserver\gssapi.h ===
/*
 * Copyright 1993 by OpenVision Technologies, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appears in all copies and
 * that both that copyright notice and this permission notice appear in
 * supporting documentation, and that the name of OpenVision not be used
 * in advertising or publicity pertaining to distribution of the software
 * without specific, written prior permission. OpenVision makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 * OPENVISION DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL OPENVISION BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
 * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef _GSSAPI_H_
   #define _GSSAPI_H_

/*
 * Determine platform-dependent configuration.
 */
   #if defined(_MSDOS) || defined(_WIN32)

/* Windows 32 specific definitions */
      #define GSS_SIZEOF_INT      4
      #define GSS_SIZEOF_SHORT    2
      #define GSS_SIZEOF_LONG     4

      #ifndef KRB5_CALLCONV
         #ifdef KRB5_DLL_FILE
            #define KRB5_DECLSPEC dllexport
         #else
            #define KRB5_DECLSPEC dllimport
         #endif
         #define KRB5_DLLIMP __declspec(KRB5_DECLSPEC)
         #define KRB5_CALLCONV __stdcall
         #define KRB5_CALLCONV_C __cdecl
         #define INTERFACE   KRB5_DLLIMP KRB5_CALLCONV
         #define INTERFACE_C KRB5_DLLIMP KRB5_CALLCONV_C
      #endif /* !KRB5_CALLCONV */

      #include <windows.h>

      #ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
         #define _SIZE_T_DEFINED
      #endif /* _SIZE_T_DEFINED */

      #ifndef _UID_T_DEFINED
typedef unsigned int uid_t;
         #define _UID_T_DEFINED
      #endif
   #else /* _MSDOS_ */

      #ifndef KRB5_CALLCONV
         #define KRB5_CALLCONV
         #define KRB5_CALLCONV_C
         #define KRB5_DLLIMP
         #define INTERFACE
         #define INTERFACE_C
         #define FAR
         #define NEAR
      #endif /* !KRB5_CALLCONV */

      #define GSS_SIZEOF_INT          SIZEOF_INT
      #define GSS_SIZEOF_LONG         SIZEOF_LONG
      #define GSS_SIZEOF_SHORT        SIZEOF_SHORT
   #endif /* _MSDOS */

   #ifndef FAR
      #define FAR
   #endif
   #ifndef NEAR
      #define NEAR
   #endif

/*
 * Make sure we have a definition for PROTOTYPE.
 */
   #if !defined(PROTOTYPE)
      #define PROTOTYPE(x) x
   #endif

   #include <stddef.h>

   #include <sys/types.h>

typedef void FAR * gss_name_t;
typedef void FAR * gss_cred_id_t;
typedef void FAR * gss_ctx_id_t;

typedef unsigned long gss_uint32;
typedef long gss_int32;

typedef gss_uint32      OM_uint32;

typedef struct gss_OID_desc_struct
{
   OM_uint32 length;
   void      FAR *elements;
} gss_OID_desc, FAR *gss_OID;

typedef struct gss_OID_set_desc_struct
{
   size_t  count;
   gss_OID elements;
} gss_OID_set_desc, FAR *gss_OID_set;

typedef struct gss_buffer_desc_struct
{
   size_t length;
   void FAR *value;
} gss_buffer_desc, FAR *gss_buffer_t;

typedef struct gss_channel_bindings_struct
{
   OM_uint32 initiator_addrtype;
   gss_buffer_desc initiator_address;
   OM_uint32 acceptor_addrtype;
   gss_buffer_desc acceptor_address;
   gss_buffer_desc application_data;
} FAR *gss_channel_bindings_t;

/*
 * For now, define a QOP-type as an OM_uint32 (pending resolution of ongoing
 * discussions).
 */
typedef OM_uint32       gss_qop_t;
typedef int             gss_cred_usage_t;

/*
 * Flag bits for context-level services.
 */
   #define GSS_C_DELEG_FLAG 1
   #define GSS_C_MUTUAL_FLAG 2
   #define GSS_C_REPLAY_FLAG 4
   #define GSS_C_SEQUENCE_FLAG 8
   #define GSS_C_CONF_FLAG 16
   #define GSS_C_INTEG_FLAG 32
   #define GSS_C_ANON_FLAG 64

/*
 * Credential usage options
 */
   #define GSS_C_BOTH 0
   #define GSS_C_INITIATE 1
   #define GSS_C_ACCEPT 2

/*
 * Status code types for gss_display_status
 */
   #define GSS_C_GSS_CODE 1
   #define GSS_C_MECH_CODE 2

/*
 * The constant definitions for channel-bindings address families
 */
   #define GSS_C_AF_UNSPEC     0
   #define GSS_C_AF_LOCAL      1
   #define GSS_C_AF_INET       2
   #define GSS_C_AF_IMPLINK    3
   #define GSS_C_AF_PUP        4
   #define GSS_C_AF_CHAOS      5
   #define GSS_C_AF_NS         6
   #define GSS_C_AF_NBS        7
   #define GSS_C_AF_ECMA       8
   #define GSS_C_AF_DATAKIT    9
   #define GSS_C_AF_CCITT      10
   #define GSS_C_AF_SNA        11
   #define GSS_C_AF_DECnet     12
   #define GSS_C_AF_DLI        13
   #define GSS_C_AF_LAT        14
   #define GSS_C_AF_HYLINK     15
   #define GSS_C_AF_APPLETALK  16
   #define GSS_C_AF_BSC        17
   #define GSS_C_AF_DSS        18
   #define GSS_C_AF_OSI        19
   #define GSS_C_AF_X25        21

   #define GSS_C_AF_NULLADDR   255

/*
 * Various Null values.
 */
   #define GSS_C_NO_BUFFER ((gss_buffer_t) 0)
   #define GSS_C_NO_OID ((gss_OID) 0)
   #define GSS_C_NO_OID_SET ((gss_OID_set) 0)
   #define GSS_C_NO_CONTEXT ((gss_ctx_id_t) 0)
   #define GSS_C_NO_CREDENTIAL ((gss_cred_id_t) 0)
   #define GSS_C_NO_CHANNEL_BINDINGS ((gss_channel_bindings_t) 0)
   #define GSS_C_EMPTY_BUFFER {0, NULL}

/*
 * Some alternate names for a couple of the above values.  These are defined
 * for V1 compatibility.
 */
   #define GSS_C_NULL_OID          GSS_C_NO_OID
   #define GSS_C_NULL_OID_SET      GSS_C_NO_OID_SET

/*
 * Define the default Quality of Protection for per-message services.  Note
 * that an implementation that offers multiple levels of QOP may either reserve
 * a value (for example zero, as assumed here) to mean "default protection", or
 * alternatively may simply equate GSS_C_QOP_DEFAULT to a specific explicit
 * QOP value.  However a value of 0 should always be interpreted by a GSSAPI
 * implementation as a request for the default protection level.
 */
   #define GSS_C_QOP_DEFAULT 0

/*
 * Expiration time of 2^32-1 seconds means infinite lifetime for a
 * credential or security context
 */
   #define GSS_C_INDEFINITE ((OM_uint32) 0xfffffffful)


/* Major status codes */

   #define GSS_S_COMPLETE 0

/*
 * Some "helper" definitions to make the status code macros obvious.
 */
   #define GSS_C_CALLING_ERROR_OFFSET 24
   #define GSS_C_ROUTINE_ERROR_OFFSET 16
   #define GSS_C_SUPPLEMENTARY_OFFSET 0
   #define GSS_C_CALLING_ERROR_MASK ((OM_uint32) 0377ul)
   #define GSS_C_ROUTINE_ERROR_MASK ((OM_uint32) 0377ul)
   #define GSS_C_SUPPLEMENTARY_MASK ((OM_uint32) 0177777ul)

/*
 * The macros that test status codes for error conditions.  Note that the
 * GSS_ERROR() macro has changed slightly from the V1 GSSAPI so that it now
 * evaluates its argument only once.
 */
   #define GSS_CALLING_ERROR(x) \
  ((x) & (GSS_C_CALLING_ERROR_MASK << GSS_C_CALLING_ERROR_OFFSET))
   #define GSS_ROUTINE_ERROR(x) \
  ((x) & (GSS_C_ROUTINE_ERROR_MASK << GSS_C_ROUTINE_ERROR_OFFSET))
   #define GSS_SUPPLEMENTARY_INFO(x) \
  ((x) & (GSS_C_SUPPLEMENTARY_MASK << GSS_C_SUPPLEMENTARY_OFFSET))
   #define GSS_ERROR(x) \
  ((x) & ((GSS_C_CALLING_ERROR_MASK << GSS_C_CALLING_ERROR_OFFSET) | \
          (GSS_C_ROUTINE_ERROR_MASK << GSS_C_ROUTINE_ERROR_OFFSET)))

/*
 * Now the actual status code definitions
 */

/*
 * Calling errors:
 */
   #define GSS_S_CALL_INACCESSIBLE_READ \
                             (((OM_uint32) 1ul) << GSS_C_CALLING_ERROR_OFFSET)
   #define GSS_S_CALL_INACCESSIBLE_WRITE \
                             (((OM_uint32) 2ul) << GSS_C_CALLING_ERROR_OFFSET)
   #define GSS_S_CALL_BAD_STRUCTURE \
                             (((OM_uint32) 3ul) << GSS_C_CALLING_ERROR_OFFSET)

/*
 * Routine errors:
 */
   #define GSS_S_BAD_MECH (((OM_uint32) 1ul) << GSS_C_ROUTINE_ERROR_OFFSET)
   #define GSS_S_BAD_NAME (((OM_uint32) 2ul) << GSS_C_ROUTINE_ERROR_OFFSET)
   #define GSS_S_BAD_NAMETYPE (((OM_uint32) 3ul) << GSS_C_ROUTINE_ERROR_OFFSET)
   #define GSS_S_BAD_BINDINGS (((OM_uint32) 4ul) << GSS_C_ROUTINE_ERROR_OFFSET)
   #define GSS_S_BAD_STATUS (((OM_uint32) 5ul) << GSS_C_ROUTINE_ERROR_OFFSET)
   #define GSS_S_BAD_SIG (((OM_uint32) 6ul) << GSS_C_ROUTINE_ERROR_OFFSET)
   #define GSS_S_NO_CRED (((OM_uint32) 7ul) << GSS_C_ROUTINE_ERROR_OFFSET)
   #define GSS_S_NO_CONTEXT (((OM_uint32) 8ul) << GSS_C_ROUTINE_ERROR_OFFSET)
   #define GSS_S_DEFECTIVE_TOKEN (((OM_uint32) 9ul) << GSS_C_ROUTINE_ERROR_OFFSET)
   #define GSS_S_DEFECTIVE_CREDENTIAL \
     (((OM_uint32) 10ul) << GSS_C_ROUTINE_ERROR_OFFSET)
   #define GSS_S_CREDENTIALS_EXPIRED \
     (((OM_uint32) 11ul) << GSS_C_ROUTINE_ERROR_OFFSET)
   #define GSS_S_CONTEXT_EXPIRED \
     (((OM_uint32) 12ul) << GSS_C_ROUTINE_ERROR_OFFSET)
   #define GSS_S_FAILURE (((OM_uint32) 13ul) << GSS_C_ROUTINE_ERROR_OFFSET)
   #define GSS_S_BAD_QOP (((OM_uint32) 14ul) << GSS_C_ROUTINE_ERROR_OFFSET)
   #define GSS_S_UNAUTHORIZED (((OM_uint32) 15ul) << GSS_C_ROUTINE_ERROR_OFFSET)
   #define GSS_S_UNAVAILABLE (((OM_uint32) 16ul) << GSS_C_ROUTINE_ERROR_OFFSET)
/*
 * XXX new functions.  Check to get official error number assigments?
 */
   #define GSS_S_DUPLICATE_ELEMENT \
     (((OM_uint32) 17ul) << GSS_C_ROUTINE_ERROR_OFFSET)

/*
 * Supplementary info bits:
 */
   #define GSS_S_CONTINUE_NEEDED (1 << (GSS_C_SUPPLEMENTARY_OFFSET + 0))
   #define GSS_S_DUPLICATE_TOKEN (1 << (GSS_C_SUPPLEMENTARY_OFFSET + 1))
   #define GSS_S_OLD_TOKEN (1 << (GSS_C_SUPPLEMENTARY_OFFSET + 2))
   #define GSS_S_UNSEQ_TOKEN (1 << (GSS_C_SUPPLEMENTARY_OFFSET + 3))
/*
 * XXX not in the cbindings yet.  remove this comment when it is
 */
   #define GSS_S_GAP_TOKEN (1 << (GSS_C_SUPPLEMENTARY_OFFSET + 4))


/*
 * Finally, function prototypes for the GSSAPI routines.
 */

KRB5_DLLIMP OM_uint32 KRB5_CALLCONV gss_acquire_cred
PROTOTYPE( (OM_uint32 FAR *,            /* minor_status */
            gss_name_t,                 /* desired_name */
            OM_uint32,                  /* time_req */
            gss_OID_set,                /* desired_mechs */
            gss_cred_usage_t,           /* cred_usage */
            gss_cred_id_t FAR *,        /* output_cred_handle */
            gss_OID_set FAR *,          /* actual_mechs */
            OM_uint32 FAR *             /* time_rec */
           ));

KRB5_DLLIMP OM_uint32 KRB5_CALLCONV gss_release_cred
PROTOTYPE( (OM_uint32 FAR *,            /* minor_status */
            gss_cred_id_t FAR *         /* cred_handle */
           ));

KRB5_DLLIMP OM_uint32 KRB5_CALLCONV gss_init_sec_context
PROTOTYPE( (OM_uint32 FAR *,            /* minor_status */
            gss_cred_id_t,              /* claimant_cred_handle */
            gss_ctx_id_t FAR *,         /* context_handle */
            gss_name_t,                 /* target_name */
            gss_OID,                    /* mech_type (used to be const) */
            OM_uint32,                  /* req_flags */
            OM_uint32,                  /* time_req */
            gss_channel_bindings_t,     /* input_chan_bindings */
            gss_buffer_t,               /* input_token */
            gss_OID FAR *,              /* actual_mech_type */
            gss_buffer_t,               /* output_token */
            OM_uint32 FAR *,            /* ret_flags */
            OM_uint32 FAR *             /* time_rec */
           ));

KRB5_DLLIMP OM_uint32 KRB5_CALLCONV gss_accept_sec_context
PROTOTYPE( (OM_uint32 FAR *,            /* minor_status */
            gss_ctx_id_t FAR *,         /* context_handle */
            gss_cred_id_t,              /* acceptor_cred_handle */
            gss_buffer_t,               /* input_token_buffer */
            gss_channel_bindings_t,     /* input_chan_bindings */
            gss_name_t FAR *,           /* src_name */
            gss_OID FAR *,              /* mech_type */
            gss_buffer_t,               /* output_token */
            OM_uint32 FAR *,            /* ret_flags */
            OM_uint32 FAR *,            /* time_rec */
            gss_cred_id_t FAR *         /* delegated_cred_handle */
           ));

KRB5_DLLIMP OM_uint32 KRB5_CALLCONV gss_process_context_token
PROTOTYPE( (OM_uint32 FAR *,            /* minor_status */
            gss_ctx_id_t,               /* context_handle */
            gss_buffer_t                /* token_buffer */
           ));

KRB5_DLLIMP OM_uint32 KRB5_CALLCONV gss_delete_sec_context
PROTOTYPE( (OM_uint32 FAR *,            /* minor_status */
            gss_ctx_id_t FAR *,         /* context_handle */
            gss_buffer_t                /* output_token */
           ));

KRB5_DLLIMP OM_uint32 KRB5_CALLCONV gss_context_time
PROTOTYPE( (OM_uint32 FAR *,            /* minor_status */
            gss_ctx_id_t,               /* context_handle */
            OM_uint32 FAR *             /* time_rec */
           ));

/* New for V2 */
KRB5_DLLIMP OM_uint32 KRB5_CALLCONV gss_get_mic
PROTOTYPE( (OM_uint32 FAR *,            /* minor_status */
            gss_ctx_id_t,               /* context_handle */
            gss_qop_t,                  /* qop_req */
            gss_buffer_t,               /* message_buffer */
            gss_buffer_t                /* message_token */
           ));

/* New for V2 */
KRB5_DLLIMP OM_uint32 KRB5_CALLCONV gss_verify_mic
PROTOTYPE( (OM_uint32 FAR *,            /* minor_status */
            gss_ctx_id_t,               /* context_handle */
            gss_buffer_t,               /* message_buffer */
            gss_buffer_t,               /* message_token */
            gss_qop_t *                 /* qop_state */
           ));

/* New for V2 */
KRB5_DLLIMP OM_uint32 KRB5_CALLCONV gss_wrap
PROTOTYPE( (OM_uint32 FAR *,            /* minor_status */
            gss_ctx_id_t,               /* context_handle */
            int,                        /* conf_req_flag */
            gss_qop_t,                  /* qop_req */
            gss_buffer_t,               /* input_message_buffer */
            int FAR *,                  /* conf_state */
            gss_buffer_t                /* output_message_buffer */
           ));

/* New for V2 */
KRB5_DLLIMP OM_uint32 KRB5_CALLCONV gss_unwrap
PROTOTYPE( (OM_uint32 FAR *,            /* minor_status */
            gss_ctx_id_t,               /* context_handle */
            gss_buffer_t,               /* input_message_buffer */
            gss_buffer_t,               /* output_message_buffer */
            int FAR *,                  /* conf_state */
            gss_qop_t FAR *             /* qop_state */
           ));

KRB5_DLLIMP OM_uint32 KRB5_CALLCONV gss_display_status
PROTOTYPE( (OM_uint32 FAR *,            /* minor_status */
            OM_uint32,                  /* status_value */
            int,                        /* status_type */
            gss_OID,                    /* mech_type (used to be const) */
            OM_uint32 FAR *,            /* message_context */
            gss_buffer_t                /* status_string */
           ));

KRB5_DLLIMP OM_uint32 KRB5_CALLCONV gss_indicate_mechs
PROTOTYPE( (OM_uint32 FAR *,            /* minor_status */
            gss_OID_set FAR *           /* mech_set */
           ));

KRB5_DLLIMP OM_uint32 KRB5_CALLCONV gss_compare_name
PROTOTYPE( (OM_uint32 FAR *,            /* minor_status */
            gss_name_t,                 /* name1 */
            gss_name_t,                 /* name2 */
            int FAR *                   /* name_equal */
           ));

KRB5_DLLIMP OM_uint32 KRB5_CALLCONV gss_display_name
PROTOTYPE( (OM_uint32 FAR *,            /* minor_status */
            gss_name_t,                 /* input_name */
            gss_buffer_t,               /* output_name_buffer */
            gss_OID FAR *               /* output_name_type */
           ));

KRB5_DLLIMP OM_uint32 KRB5_CALLCONV gss_import_name
PROTOTYPE( (OM_uint32 FAR *,            /* minor_status */
            gss_buffer_t,               /* input_name_buffer */
            gss_OID,                    /* input_name_type(used to be const) */
            gss_name_t FAR *            /* output_name */
           ));

KRB5_DLLIMP OM_uint32 KRB5_CALLCONV gss_release_name
PROTOTYPE( (OM_uint32 FAR *,            /* minor_status */
            gss_name_t FAR *            /* input_name */
           ));

KRB5_DLLIMP OM_uint32 KRB5_CALLCONV gss_release_buffer
PROTOTYPE( (OM_uint32 FAR *,            /* minor_status */
            gss_buffer_t                /* buffer */
           ));

KRB5_DLLIMP OM_uint32 KRB5_CALLCONV gss_release_oid_set
PROTOTYPE( (OM_uint32 FAR *,            /* minor_status */
            gss_OID_set FAR *           /* set */
           ));

KRB5_DLLIMP OM_uint32 KRB5_CALLCONV gss_inquire_cred
PROTOTYPE( (OM_uint32 FAR *,            /* minor_status */
            gss_cred_id_t,              /* cred_handle */
            gss_name_t FAR *,           /* name */
            OM_uint32 FAR *,            /* lifetime */
            gss_cred_usage_t FAR *,     /* cred_usage */
            gss_OID_set FAR *           /* mechanisms */
           ));

/* Last argument new for V2 */
KRB5_DLLIMP OM_uint32 KRB5_CALLCONV gss_inquire_context
PROTOTYPE( (OM_uint32 FAR *,            /* minor_status */
            gss_ctx_id_t,               /* context_handle */
            gss_name_t FAR *,           /* src_name */
            gss_name_t FAR *,           /* targ_name */
            OM_uint32 FAR *,            /* lifetime_rec */
            gss_OID FAR *,              /* mech_type */
            OM_uint32 FAR *,            /* ctx_flags */
            int FAR *,                  /* locally_initiated */
            int FAR *                   /* open */
           ));

/* New for V2 */
KRB5_DLLIMP OM_uint32 KRB5_CALLCONV gss_wrap_size_limit
PROTOTYPE( (OM_uint32 FAR *,            /* minor_status */
            gss_ctx_id_t,               /* context_handle */
            int,                        /* conf_req_flag */
            gss_qop_t,                  /* qop_req */
            OM_uint32,                  /* req_output_size */
            OM_uint32 *                 /* max_input_size */
           ));

/* New for V2 */
KRB5_DLLIMP OM_uint32 KRB5_CALLCONV gss_import_name_object
PROTOTYPE( (OM_uint32 FAR *,            /* minor_status */
            void FAR *,                 /* input_name */
            gss_OID,                    /* input_name_type */
            gss_name_t FAR *            /* output_name */
           ));

/* New for V2 */
KRB5_DLLIMP OM_uint32 KRB5_CALLCONV gss_export_name_object
PROTOTYPE( (OM_uint32 FAR *,            /* minor_status */
            gss_name_t,                 /* input_name */
            gss_OID,                    /* desired_name_type */
            void FAR * FAR *            /* output_name */
           ));

/* New for V2 */
KRB5_DLLIMP OM_uint32 KRB5_CALLCONV gss_add_cred
PROTOTYPE( (OM_uint32 FAR *,            /* minor_status */
            gss_cred_id_t,              /* input_cred_handle */
            gss_name_t,                 /* desired_name */
            gss_OID,                    /* desired_mech */
            gss_cred_usage_t,           /* cred_usage */
            OM_uint32,                  /* initiator_time_req */
            OM_uint32,                  /* acceptor_time_req */
            gss_cred_id_t FAR *,        /* output_cred_handle */
            gss_OID_set FAR *,          /* actual_mechs */
            OM_uint32 FAR *,            /* initiator_time_rec */
            OM_uint32 FAR *             /* acceptor_time_rec */
           ));

/* New for V2 */
KRB5_DLLIMP OM_uint32 KRB5_CALLCONV gss_inquire_cred_by_mech
PROTOTYPE( (OM_uint32  FAR *,           /* minor_status */
            gss_cred_id_t,              /* cred_handle */
            gss_OID,                    /* mech_type */
            gss_name_t FAR *,           /* name */
            OM_uint32 FAR *,            /* initiator_lifetime */
            OM_uint32 FAR *,            /* acceptor_lifetime */
            gss_cred_usage_t FAR *      /* cred_usage */
           ));

/* New for V2 */
KRB5_DLLIMP OM_uint32 KRB5_CALLCONV gss_export_sec_context
PROTOTYPE( (OM_uint32 FAR *,            /* minor_status */
            gss_ctx_id_t FAR *,         /* context_handle */
            gss_buffer_t                /* interprocess_token */
           ));

/* New for V2 */
KRB5_DLLIMP OM_uint32 KRB5_CALLCONV gss_import_sec_context
PROTOTYPE( (OM_uint32 FAR *,            /* minor_status */
            gss_buffer_t,               /* interprocess_token */
            gss_ctx_id_t FAR *          /* context_handle */
           ));

/* New for V2 */
KRB5_DLLIMP OM_uint32 KRB5_CALLCONV gss_release_oid
PROTOTYPE( (OM_uint32 FAR *,            /* minor_status */
            gss_OID FAR *               /* oid */
           ));

/* New for V2 */
KRB5_DLLIMP OM_uint32 KRB5_CALLCONV gss_create_empty_oid_set
PROTOTYPE( (OM_uint32 FAR *,            /* minor_status */
            gss_OID_set FAR *           /* oid_set */
           ));

/* New for V2 */
KRB5_DLLIMP OM_uint32 KRB5_CALLCONV gss_add_oid_set_member
PROTOTYPE( (OM_uint32 FAR *,            /* minor_status */
            gss_OID,                    /* member_oid */
            gss_OID_set FAR *           /* oid_set */
           ));

/* New for V2 */
KRB5_DLLIMP OM_uint32 KRB5_CALLCONV gss_test_oid_set_member
PROTOTYPE( (OM_uint32 FAR *,            /* minor_status */
            gss_OID,                    /* member */
            gss_OID_set,                /* set */
            int FAR *                   /* present */
           ));

/* New for V2 */
KRB5_DLLIMP OM_uint32 KRB5_CALLCONV gss_str_to_oid
PROTOTYPE( (OM_uint32 FAR *,            /* minor_status */
            gss_buffer_t,               /* oid_str */
            gss_OID FAR *               /* oid */
           ));

/* New for V2 */
KRB5_DLLIMP OM_uint32 KRB5_CALLCONV gss_oid_to_str
PROTOTYPE( (OM_uint32 FAR *,            /* minor_status */
            gss_OID,                    /* oid */
            gss_buffer_t                /* oid_str */
           ));

/* New for V2 */
KRB5_DLLIMP OM_uint32 KRB5_CALLCONV gss_inquire_names_for_mech
PROTOTYPE( (OM_uint32 FAR *,            /* minor_status */
            gss_OID,                    /* mechanism */
            gss_OID_set FAR *           /* name_types */
           ));

/*
 * The following routines are obsolete variants of gss_get_mic, gss_wrap,
 * gss_verify_mic and gss_unwrap.  They should be provided by GSSAPI V2
 * implementations for backwards compatibility with V1 applications.  Distinct
 * entrypoints (as opposed to #defines) should be provided, to allow GSSAPI
 * V1 applications to link against GSSAPI V2 implementations.
 */
KRB5_DLLIMP OM_uint32 KRB5_CALLCONV gss_sign
PROTOTYPE( (OM_uint32 FAR *,    /* minor_status */
            gss_ctx_id_t,       /* context_handle */
            int,                /* qop_req */
            gss_buffer_t,       /* message_buffer */
            gss_buffer_t        /* message_token */
           ));

KRB5_DLLIMP OM_uint32 KRB5_CALLCONV gss_verify
PROTOTYPE( (OM_uint32 FAR *,    /* minor_status */
            gss_ctx_id_t,       /* context_handle */
            gss_buffer_t,       /* message_buffer */
            gss_buffer_t,       /* token_buffer */
            int FAR *           /* qop_state */
           ));

KRB5_DLLIMP OM_uint32 KRB5_CALLCONV gss_seal
PROTOTYPE( (OM_uint32 FAR *,    /* minor_status */
            gss_ctx_id_t,       /* context_handle */
            int,                /* conf_req_flag */
            int,                /* qop_req */
            gss_buffer_t,       /* input_message_buffer */
            int FAR *,          /* conf_state */
            gss_buffer_t        /* output_message_buffer */
           ));

KRB5_DLLIMP OM_uint32 KRB5_CALLCONV gss_unseal
PROTOTYPE( (OM_uint32 FAR *,    /* minor_status */
            gss_ctx_id_t,       /* context_handle */
            gss_buffer_t,       /* input_message_buffer */
            gss_buffer_t,       /* output_message_buffer */
            int FAR *,          /* conf_state */
            int FAR *           /* qop_state */
           ));

/* XXXX these are not part of the GSSAPI C bindings!  (but should be) */

   #define GSS_CALLING_ERROR_FIELD(x) \
   (((x) >> GSS_C_CALLING_ERROR_OFFSET) & GSS_C_CALLING_ERROR_MASK)
   #define GSS_ROUTINE_ERROR_FIELD(x) \
   (((x) >> GSS_C_ROUTINE_ERROR_OFFSET) & GSS_C_ROUTINE_ERROR_MASK)
   #define GSS_SUPPLEMENTARY_INFO_FIELD(x) \
   (((x) >> GSS_C_SUPPLEMENTARY_OFFSET) & GSS_C_SUPPLEMENTARY_MASK)

/* XXXX This is a necessary evil until the spec is fixed */
   #define GSS_S_CRED_UNAVAIL GSS_S_FAILURE

#endif /* _GSSAPI_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\gssserver\gss-misc.h ===
/*
 * Copyright 1994 by OpenVision Technologies, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appears in all copies and
 * that both that copyright notice and this permission notice appear in
 * supporting documentation, and that the name of OpenVision not be used
 * in advertising or publicity pertaining to distribution of the software
 * without specific, written prior permission. OpenVision makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 * OPENVISION DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL OPENVISION BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
 * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

/* Our build process sucks.  Compensate by disabling warnings that 
   are more or less extraneous. */

#pragma warning( disable:4242 )
#pragma warning( disable:4311 )
#pragma warning( disable:4244 )

#ifndef _GSSMISC_H_
   #define _GSSMISC_H_

   #ifdef UNICODE
      #undef UNICODE
   #endif
   #include <windows.h>
   #include <rpc.h>
   #include <stdio.h>
   #include <stdlib.h>
   #include <io.h>
   #include <fcntl.h>
   #include <winsock2.h>
   #define SECURITY_WIN32
   #include <security.h>
   #include <ntsecapi.h>
   #include "gssapi.h"

   #define PROTOTYPE(_x_) _x_
extern FILE *display_file;

int send_token
PROTOTYPE( (int s, PSecBuffer tok) );
int recv_token
PROTOTYPE( (int s, PSecBuffer tok) );
void display_status
PROTOTYPE( (char *msg, ULONG maj_stat, ULONG min_stat) );
void display_ctx_flags
PROTOTYPE( (ULONG flags) );
void print_token
PROTOTYPE( (PSecBuffer tok) );

#endif

int 
connect_to_server( IN char *host, u_short port);

int call_server( char *host, 
		 u_short port, 
		 char *service_name, 
		 OM_uint32 deleg_flag, 
		 char *msg, 
		 int use_file,
		 BOOL SignOnly );


typedef struct
{

   PCHAR     name;
   OM_uint32 value;
   PCHAR     realname;

} FLAGMAPPING, *PFLAGMAPPING;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\gssserver\gssmisc.c ===
/*
 * Copyright 1994 by OpenVision Technologies, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appears in all copies and
 * that both that copyright notice and this permission notice appear in
 * supporting documentation, and that the name of OpenVision not be used
 * in advertising or publicity pertaining to distribution of the software
 * without specific, written prior permission. OpenVision makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 * OPENVISION DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL OPENVISION BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
 * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#include "gss-misc.h"

FILE *display_file;

void display_status_1
PROTOTYPE( (char *m, ULONG code, int type) );

int write_all(int fildes, char *buf, unsigned int nbyte)
{
   int ret;
   char *ptr;

   for (ptr = buf; nbyte; ptr += ret, nbyte -= ret)
   {
      ret = send(fildes, ptr, nbyte,0);
      if (ret < 0)
      {
         return (ret);
      }
      else if (ret == 0)
      {
         return (ptr-buf);
      }
   }

   return (ptr-buf);
}

int read_all(int fildes, char *buf, unsigned int nbyte)
{
   int ret;
   char *ptr;

   for (ptr = buf; nbyte; ptr += ret, nbyte -= ret)
   {
      ret = recv(fildes, ptr, nbyte,0);
      if (ret < 0)
      {
         return (ret);
      }
      else if (ret == 0)
      {
         return (ptr-buf);
      }
   }

   return (ptr-buf);
}

/*
 * Function: send_token
 *
 * Purpose: Writes a token to a file descriptor.
 *
 * Arguments:
 *
 *      s               (r) an open file descriptor
 *      tok             (r) the token to write
 *
 * Returns: 0 on success, -1 on failure
 *
 * Effects:
 *
 * send_token writes the token length (as a network long) and then the
 * token data to the file descriptor s.  It returns 0 on success, and
 * -1 if an error occurs or if it could not write all the data.
 */
int send_token(int s, PSecBuffer tok)
{
   ULONG len;
   LONG ret;

   len = htonl(tok->cbBuffer);

   ret = write_all(s, (char *) &len, 4);
   if (ret < 0)
   {
      perror("sending token length");
      return -1;
   }
   else if (ret != 4)
   {
      if (display_file)
         fprintf(display_file,
                 "sending token length: %d of %d bytes written\n",
                 ret, 4);
      return -1;
   }

   ret = write_all(s, tok->pvBuffer, tok->cbBuffer);
   if (ret < 0)
   {
      perror("sending token data");
      return -1;
   }
   else if (ret != (LONG) tok->cbBuffer)
   {
      if (display_file)
         fprintf(display_file,
                 "sending token data: %d of %d bytes written\n",
                 ret, tok->cbBuffer);
      return -1;
   }

   return 0;
}

/*
 * Function: recv_token
 *
 * Purpose: Reads a token from a file descriptor.
 *
 * Arguments:
 *
 *      s               (r) an open file descriptor
 *      tok             (w) the read token
 *
 * Returns: 0 on success, -1 on failure
 *
 * Effects:
 *
 * recv_token reads the token length (as a network long), allocates
 * memory to hold the data, and then reads the token data from the
 * file descriptor s.  It blocks to read the length and data, if
 * necessary.  On a successful return, the token should be freed with
 * gss_release_buffer.  It returns 0 on success, and -1 if an error
 * occurs or if it could not read all the data.
 */
int recv_token(int s, PSecBuffer tok)
{
    LONG ret;

   ret = read_all(s, (char *) &tok->cbBuffer, 4);
   if (ret < 0)
   {
      perror("reading token length");
      return -1;
   }
   else if (ret != 4)
   {
      if (display_file)
         fprintf(display_file,
                 "reading token length: %d of %d bytes read\n",
                 ret, 4);
      return -1;
   }

   tok->cbBuffer = ntohl(tok->cbBuffer);
   tok->pvBuffer = (char *) malloc(tok->cbBuffer);
   if (tok->pvBuffer == NULL)
   {
      if (display_file)
         fprintf(display_file,
                 "Out of memory allocating token data\n");
      return -1;
   }

   ret = read_all(s, (char *) tok->pvBuffer, tok->cbBuffer);
   if (ret < 0)
   {
      perror("reading token data");
      free(tok->pvBuffer);
      return -1;
   }
   else if (ret != (LONG) tok->cbBuffer)
   {
      fprintf(stderr, "sending token data: %d of %d bytes written\n",
              ret, tok->cbBuffer);
      free(tok->pvBuffer);
      return -1;
   }

   return 0;
}

void display_status_1(
    char *m,
    ULONG code,
    int type
    )
{
   type;
   
   if (display_file)
      fprintf(display_file, "GSS-API error %s: %x\n", m,
              code);
}

/*
 * Function: display_status
 *
 * Purpose: displays GSS-API messages
 *
 * Arguments:
 *
 *      msg             a string to be displayed with the message
 *      maj_stat        the GSS-API major status code
 *      min_stat        the GSS-API minor status code
 *
 * Effects:
 *
 * The GSS-API messages associated with maj_stat and min_stat are
 * displayed on stderr, each preceeded by "GSS-API error <msg>: " and
 * followed by a newline.
 */
void display_status(
    char *msg,
    ULONG maj_stat,
    ULONG min_stat
    )
{
   display_status_1(msg, maj_stat, GSS_C_GSS_CODE);
   if ( min_stat != 0 ) display_status_1(msg, min_stat, GSS_C_MECH_CODE);
}

/*
 * Function: display_ctx_flags
 *
 * Purpose: displays the flags returned by context initation in
 *          a human-readable form
 *
 * Arguments:
 *
 *      int             ret_flags
 *
 * Effects:
 *
 * Strings corresponding to the context flags are printed on
 * stdout, preceded by "context flag: " and followed by a newline
 */

void display_ctx_flags(
    ULONG flags
    )
{
   if (flags & GSS_C_DELEG_FLAG)
      fprintf(display_file, "context flag: GSS_C_DELEG_FLAG\n");
   if (flags & GSS_C_MUTUAL_FLAG)
      fprintf(display_file, "context flag: GSS_C_MUTUAL_FLAG\n");
   if (flags & GSS_C_REPLAY_FLAG)
      fprintf(display_file, "context flag: GSS_C_REPLAY_FLAG\n");
   if (flags & GSS_C_SEQUENCE_FLAG)
      fprintf(display_file, "context flag: GSS_C_SEQUENCE_FLAG\n");
   if (flags & GSS_C_CONF_FLAG )
      fprintf(display_file, "context flag: GSS_C_CONF_FLAG \n");
   if (flags & GSS_C_INTEG_FLAG )
      fprintf(display_file, "context flag: GSS_C_INTEG_FLAG \n");
}

void print_token(
    PSecBuffer tok
    )
{
   ULONG i;
   unsigned char *p = (PUCHAR) tok->pvBuffer;

   if (!display_file)
      return;
   for (i=0; i < tok->cbBuffer; i++, p++)
   {
      fprintf(display_file, "%02x ", *p);
      if ((i % 16) == 15)
      {
         fprintf(display_file, "\n");
      }
   }
   fprintf(display_file, "\n");
   fflush(display_file);
}

/*
 * Function: connect_to_server
 *
 * Purpose: Opens a TCP connection to the name host and port.
 *
 * Arguments:
 *
 *      host            (r) the target host name
 *      port            (r) the target port, in host byte order
 *
 * Returns: the established socket file desciptor, or -1 on failure
 *
 * Effects:
 *
 * The host name is resolved with gethostbyname(), and the socket is
 * opened and connected.  If an error occurs, an error message is
 * displayed and -1 is returned.
 */

int connect_to_server(
    char *host,
    u_short port
    )
{
   struct sockaddr_in saddr;
   struct hostent *hp;
   int s;
   int err;
   WSADATA socket_data;
   USHORT version_required = 0x0101;


   err = WSAStartup(version_required, &socket_data);
   if (err)
   {
      fprintf(stderr,"Failed to initailize WSA: %d\n",err);
      return (-1);
   }


   if ((hp = gethostbyname(host)) == NULL)
   {
      fprintf(stderr, "Unknown host: %s\n", host);
      return -1;
   }

   saddr.sin_family = hp->h_addrtype;
   memcpy((char *)&saddr.sin_addr, hp->h_addr, sizeof(saddr.sin_addr));
   saddr.sin_port = htons(port);

   if ((s = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)
   {
      fprintf(stderr, "creating socket - %x", GetLastError());
      return -1;
   }

   if (connect(s, (struct sockaddr *)&saddr, sizeof(saddr)) == SOCKET_ERROR)
   {
      fprintf(stderr, "connecting to server - %x", GetLastError());
      (void) closesocket(s);
      return -1;
   }
   return s;
}

/*
 * Function: client_establish_context
 *
 * Purpose: establishes a GSS-API context with a specified service and
 * returns the context handle
 *
 * Arguments:
 *
 *      s               (r) an established TCP connection to the service
 *      service_name    (r) the ASCII service name of the service
 *      context         (w) the established GSS-API context
 *      ret_flags       (w) the returned flags from init_sec_context
 *
 * Returns: 0 on success, -1 on failure
 *
 * Effects:
 *
 * service_name is imported as a GSS-API name and a GSS-API context is
 * established with the corresponding service; the service should be
 * listening on the TCP connection s.  The default GSS-API mechanism
 * is used, and mutual authentication and replay detection are
 * requested.
 *
 * If successful, the context handle is returned in context.  If
 * unsuccessful, the GSS-API error messages are displayed on stderr
 * and -1 is returned.
 */
int client_establish_context(
    int s,
    char *service_name,
    OM_uint32 deleg_flag,
    CtxtHandle *gss_context,
    OM_uint32 *ret_flags
    )
{
   SecBuffer send_tok, recv_tok;
   SecBufferDesc input_desc, output_desc;
   OM_uint32 maj_stat;
   CredHandle cred_handle;
   TimeStamp expiry;
   PCtxtHandle context_handle = NULL;


   input_desc.cBuffers = 1;
   input_desc.pBuffers = &recv_tok;
   input_desc.ulVersion = SECBUFFER_VERSION;

   recv_tok.BufferType = SECBUFFER_TOKEN;
   recv_tok.cbBuffer = 0;
   recv_tok.pvBuffer = NULL;

   output_desc.cBuffers = 1;
   output_desc.pBuffers = &send_tok;
   output_desc.ulVersion = SECBUFFER_VERSION;

   send_tok.BufferType = SECBUFFER_TOKEN;
   send_tok.cbBuffer = 0;
   send_tok.pvBuffer = NULL;

   cred_handle.dwLower = 0;
   cred_handle.dwUpper = 0;

   maj_stat = AcquireCredentialsHandle(
                                      NULL,                       // no principal name
                                      "Kerberos",                 // package name
                                      SECPKG_CRED_OUTBOUND,
                                      NULL,                       // no logon id
                                      NULL,                       // no auth data
                                      NULL,                       // no get key fn
                                      NULL,                       // noget key arg
                                      &cred_handle,
                                      &expiry
                                      );
   if (maj_stat != SEC_E_OK)
   {
      display_status("acquiring credentials",maj_stat, GetLastError());
      return (-1);
   }

   /*
    * Perform the context-establishement loop.
    */

   gss_context->dwLower = 0;
   gss_context->dwUpper = 0;

   do
   {
      maj_stat =
      InitializeSecurityContext(
                               &cred_handle,
                               context_handle,
                               service_name,
                               deleg_flag |
			       ISC_REQ_ALLOCATE_MEMORY,
                               0,          // reserved
                               SECURITY_NATIVE_DREP,
                               &input_desc,
                               0,          // reserved
                               gss_context,
                               &output_desc,
                               ret_flags,
                               &expiry
                               );

      if (recv_tok.pvBuffer)
      {
         free(recv_tok.pvBuffer);
         recv_tok.pvBuffer = NULL;
         recv_tok.cbBuffer = 0;

      }

      context_handle = gss_context;

      if (maj_stat!=SEC_E_OK && maj_stat!=SEC_I_CONTINUE_NEEDED)
      {
         display_status("initializing context", maj_stat, GetLastError());
         FreeCredentialsHandle(&cred_handle);
         return -1;
      }

      if (send_tok.cbBuffer != 0)
      {
         printf("Sending init_sec_context token (size=%d)...",
                send_tok.cbBuffer);

	 if ( getenv( "GSSCLIENT_VERBOSE" ) ) {

	   print_token( &send_tok );

	 }


         if (send_token(s, &send_tok) < 0)
         {
            FreeContextBuffer(send_tok.pvBuffer);
            FreeCredentialsHandle(&cred_handle);
            return -1;
         }
      }

      FreeContextBuffer(send_tok.pvBuffer);
      send_tok.pvBuffer = NULL;
      send_tok.cbBuffer = 0;

      if (maj_stat == SEC_I_CONTINUE_NEEDED)
      {
         printf("continue needed...");
         if (recv_token(s, &recv_tok) < 0)
         {
            FreeCredentialsHandle(&cred_handle);
            return -1;
         }
      }
      printf("\n");

   } while (maj_stat == SEC_I_CONTINUE_NEEDED);

   FreeCredentialsHandle(&cred_handle);
   return 0;
}

void read_file(
    char *file_name,
    PSecBuffer in_buf
    )
{
   int fd;
   LONG bytes_in;
   LONG  count;
   UCHAR buf[100];

   //
   // readthrough once to get the size.
   //

   if ((fd = _open(file_name, O_RDONLY, 0)) < 0)
   {
      perror("open");
      fprintf(stderr, "Couldn't open file %s\n", file_name);
      exit(1);
   }

   for (bytes_in = 0; ; bytes_in += count)
   {
      count = _read(fd, buf, sizeof(buf));
      if (count < 0)
      {
         fprintf(stderr, "read - %x", GetLastError());
         exit(1);
      }
      if (count == 0)
         break;
   }
   _close(fd);

   if ((fd = _open(file_name, O_RDONLY, 0)) < 0)
   {
      perror("open");
      fprintf(stderr, "Couldn't open file %s\n", file_name);
      exit(1);
   }

   in_buf->cbBuffer = bytes_in;
   in_buf->pvBuffer = malloc(in_buf->cbBuffer);

   if (in_buf->pvBuffer == 0)
   {
      fprintf(stderr, "Couldn't allocate %d byte buffer for reading file\n",
              in_buf->cbBuffer);
      exit(1);
   }

   memset(in_buf->pvBuffer, 0, in_buf->cbBuffer);

   for (bytes_in = 0; 
	bytes_in < (LONG) in_buf->cbBuffer; 
	bytes_in += count)
   {
      count = _read(fd, (PUCHAR) in_buf->pvBuffer+bytes_in, in_buf->cbBuffer-bytes_in);
      if (count < 0)
      {
         fprintf(stderr, "read - %x", GetLastError());
         exit(1);
      }
      if (count == 0)
         break;
   }

   if (bytes_in != count)
      fprintf(stderr, "Warning, only read in %d bytes, expected %d\n",
              bytes_in, count);
}

/*
 * Function: call_server
 *
 * Purpose: Call the "sign" service.
 *
 * Arguments:
 *
 *      host            (r) the host providing the service
 *      port            (r) the port to connect to on host
 *      service_name    (r) the GSS-API service name to authenticate to
 *      msg             (r) the message to have "signed"
 *
 * Returns: 0 on success, -1 on failure
 *
 * Effects:
 *
 * call_server opens a TCP connection to <host:port> and establishes a
 * GSS-API context with service_name over the connection.  It then
 * seals msg in a GSS-API token with gss_seal, sends it to the server,
 * reads back a GSS-API signature block for msg from the server, and
 * verifies it with gss_verify.  -1 is returned if any step fails,
 * otherwise 0 is returned.
 */
int call_server(
    char *host,
    u_short port,
    char *service_name,
    OM_uint32 deleg_flag,
    char *msg,
    int use_file,
    BOOL SignOnly
    )
{
   CtxtHandle context;
   SecBuffer in_buf, out_buf;
   SecBuffer wrap_bufs[3];
   SecBufferDesc in_buf_desc;
   SecPkgContext_Sizes sizes;
   int s;
   OM_uint32 ret_flags;
   OM_uint32 maj_stat;
   gss_qop_t qop_state;

   /* Open connection */
   if ((s = connect_to_server(host, port)) < 0)
      return -1;

   /* Establish context */
   if (client_establish_context(s, service_name, deleg_flag,  &context,
                                &ret_flags) < 0)
   {
      (void) closesocket(s);
      return -1;
   }

   maj_stat = QueryContextAttributes(
                                    &context,
                                    SECPKG_ATTR_SIZES,
                                    &sizes
                                    );
   if (maj_stat != SEC_E_OK)
   {
      display_status("querying context attributes", maj_stat, GetLastError());
      return (-1);
   }

   if (use_file)
   {
      read_file(msg, &in_buf);
   }
   else
   {
      /* Seal the message */
      in_buf.pvBuffer = msg;
      in_buf.cbBuffer = strlen(msg) + 1;
   }

   //
   // Prepare to encrypt the message
   //

   printf("Block Size is %d, inbuffer = %d\n",
          sizes.cbBlockSize, in_buf.cbBuffer);

   in_buf_desc.cBuffers = 3;
   in_buf_desc.pBuffers = wrap_bufs;
   in_buf_desc.ulVersion = SECBUFFER_VERSION;

   wrap_bufs[0].cbBuffer = sizes.cbSecurityTrailer;
   wrap_bufs[0].BufferType = SECBUFFER_TOKEN;
   wrap_bufs[0].pvBuffer = malloc(sizes.cbSecurityTrailer);

   if (wrap_bufs[0].pvBuffer == NULL)
   {
      fprintf(stderr,"Failed to allocate space for security trailer\n");
      return (-1);
   }

   wrap_bufs[1].BufferType = SECBUFFER_DATA;
   wrap_bufs[1].cbBuffer = in_buf.cbBuffer;
   wrap_bufs[1].pvBuffer = malloc(wrap_bufs[1].cbBuffer);

   if (wrap_bufs[1].pvBuffer == NULL)
   {
      fprintf(stderr,"Couldn't allocate space for wrap message\n");
      return (-1);
   }

   memcpy(
         wrap_bufs[1].pvBuffer,
         in_buf.pvBuffer,
         in_buf.cbBuffer
         );

   wrap_bufs[2].BufferType = SECBUFFER_PADDING;
   wrap_bufs[2].cbBuffer = sizes.cbBlockSize;
   wrap_bufs[2].pvBuffer = malloc(wrap_bufs[2].cbBuffer);

   if (wrap_bufs[2].pvBuffer == NULL)
   {
      fprintf(stderr,"Couldn't allocate space for wrap message\n");
      return (-1);
   }



   maj_stat = EncryptMessage(
                            &context,
                            SignOnly ? KERB_WRAP_NO_ENCRYPT : 0,
                            &in_buf_desc,
                            0);


   if (maj_stat != SEC_E_OK)
   {
      display_status("sealing message", maj_stat, GetLastError() );
      (void) closesocket(s);
      (void) DeleteSecurityContext(&context);
      return -1;
   }

   //
   // Create the mesage to send to server
   //

   out_buf.cbBuffer = wrap_bufs[0].cbBuffer + wrap_bufs[1].cbBuffer + wrap_bufs[2].cbBuffer;
   out_buf.pvBuffer = malloc(out_buf.cbBuffer);

   if (out_buf.pvBuffer == NULL)
   {
      fprintf(stderr,"Failed to allocate space for wrapepd message\n");
      return (-1);
   }

   memcpy(
         out_buf.pvBuffer,
         wrap_bufs[0].pvBuffer,
         wrap_bufs[0].cbBuffer
         );
   memcpy(
         (PUCHAR) out_buf.pvBuffer + (int) wrap_bufs[0].cbBuffer,
         wrap_bufs[1].pvBuffer,
         wrap_bufs[1].cbBuffer
         );
   memcpy(
         (PUCHAR) out_buf.pvBuffer + wrap_bufs[0].cbBuffer + wrap_bufs[1].cbBuffer,
         wrap_bufs[2].pvBuffer,
         wrap_bufs[2].cbBuffer
         );

   /* Send to server */
   if (send_token(s, &out_buf) < 0)
   {
      (void) closesocket(s);
      (void) DeleteSecurityContext(&context);
      return -1;
   }

   free(out_buf.pvBuffer);
   out_buf.pvBuffer = NULL;
   out_buf.cbBuffer = 0;
   free(wrap_bufs[0].pvBuffer);
   wrap_bufs[0].pvBuffer = NULL;
   free(wrap_bufs[1].pvBuffer);
   wrap_bufs[1].pvBuffer = NULL;

   /* Read signature block into out_buf */
   if (recv_token(s, &out_buf) < 0)
   {
      (void) closesocket(s);
      (void) DeleteSecurityContext( &context);
      return -1;
   }

   /* Verify signature block */

   in_buf_desc.cBuffers = 2;
   wrap_bufs[0] = in_buf;
   wrap_bufs[0].BufferType = SECBUFFER_DATA;
   wrap_bufs[1] = out_buf;
   wrap_bufs[1].BufferType = SECBUFFER_TOKEN;

   maj_stat = VerifySignature(&context, &in_buf_desc, 0, &qop_state);
   if (maj_stat != SEC_E_OK)
   {
      display_status("verifying signature", maj_stat, GetLastError());
      (void) closesocket(s);
      (void) DeleteSecurityContext( &context);
      return -1;
   }
   free(out_buf.pvBuffer);

   if (use_file)
      free(in_buf.pvBuffer);

   printf("Signature verified.\n");

   /* Delete context */
   maj_stat = DeleteSecurityContext(&context);
   if (maj_stat != SEC_E_OK)
   {
      display_status("deleting context", maj_stat, GetLastError() );
      (void) closesocket(s);
      return -1;
   }

   (void) closesocket(s);
   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\LocalCache\sources.inc ===
TARGETPATH=obj
TARGETTYPE=PROGRAM
TARGETNAME=localcache
USE_LIBCMT=1

MSC_WARNING_LEVEL=/W3 /WX /Ob1

!if defined(GENASM)
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /Fa
!endif

!if $(FREEBUILD) == 0
MSC_OPTIMIZATION=/Odi /Ob1
!endif

LINKER_FLAGS=$(LINKER_FLAGS) /map /IGNORE:4099

SOURCES=\
    main.cpp \
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\gssserver\sectoken.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    sectoken.h

Abstract:

    Security Testing Utilites -- token include file.

    These routines are primarily designed to check and/or set token
    info used by the security system in determining object access.

    See token.c for documentation on routines.

Author:

    Jim Gilroy (jamesg) 3-19-91

Revision History:

--*/


#ifndef  _SECTOKEN_
#define  _SECTOKEN_


/*   VOID */
/*   SecPrintTokenUser ( */
/*       IN  PTOKEN_USER  ptr */
/*       IN  PSZ   Name */
/*       ) */

/*   Prints TokenUser SID */

#define SecPrintTokenUser(ptr, Name) \
            SecPrintSid (((TOKEN_USER *)ptr)->User.Sid, Name)

/*   VOID */
/*   SecPrintTokenOwner ( */
/*       IN  PTOKEN_OWNER  ptr, */
/*       IN  PSZ   Name */
/*       ) */

/*   Prints TokenOwner SID */

#define SecPrintTokenOwner(ptr, Name) \
            SecPrintSid (((TOKEN_OWNER *)ptr)->Owner, Name)

/*   VOID */
/*   SecPrintTokenPrimaryGroup ( */
/*       IN  PTOKEN_PRIMARY_GROUP  ptr, */
/*       IN  PSZ   Name */
/*       ) */

/*   Prints TokenPrimaryGroup SID */

#define SecPrintTokenPrimaryGroup(ptr, Name) \
            SecPrintSid (((TOKEN_PRIMARY_GROUP *)ptr)->PrimaryGroup, Name)





/*  Token Group Routines */


VOID
SecPrintTokenGroups (
    IN  PTOKEN_GROUPS  PTokenGroups,
    IN  PSZ Name
    );


/*  Token Privileges */


VOID
SecPrintTokenPrivileges (
    IN  PTOKEN_PRIVILEGES  PTokenPrivileges,
    IN  PSZ  Name
    );

VOID
SecPrintTokenStatistics (
    IN  PTOKEN_STATISTICS  ptr,
    IN  PSZ  Name
    );

VOID
SecPrintTokenControl (
    IN  PTOKEN_CONTROL  ptr,
    IN  PSZ  Name
    );

NTSTATUS    SecPrintTokenInfo(
    IN  HANDLE  token_to_query
    );

#endif  /*  _SECTOKEN_ */


/*  End of sectoken.h */





=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\LocalCache\main.cpp ===
#include "xonp.h"
#include <stdlib.h>

#ifdef XONLINE_FEATURE_XBOX
extern class CXo * g_pXo;
#define GetXo() g_pXo
#endif

class CXoTest : public CXOnline
{
public:
    CXoTest(char * pszXbox = NULL) : CXOnline(pszXbox) {}
    void Test();
	void Test1();

};

const DWORD RECORD_SIZE = 10000;
typedef struct
{
    BYTE info[RECORD_SIZE];
}
TEST_RECORD;

typedef struct
{
    ULONGLONG qwUserID;
    BYTE     pInfo[33];
}TEST_INDEX_ENTRY1;

typedef struct
{
    ULONGLONG qwUserID;
    BYTE      pInfo[44];
}TEST_INDEX_ENTRY2;

typedef struct
{
    ULONGLONG qwUserID;
}LICENSING_INDEX_ENTRY;

typedef struct
{
    ULONGLONG qwUserID;
    DWORD     pInfo[2];
}BUDDYLIST_INDEX_ENTRY;

//////////////////////////////////////////////////////////////////////////////

int __cdecl main(int argc, char * argv[])
{
    char buffer[128];

//    sprintf(buffer, "%s@Nic/0", getenv("COMPUTERNAME") );
//    CXoTest * pXoTest = new CXoTest(buffer);
    
	CXoTest * pXoTest = new CXoTest;
    pXoTest->Test();
    
    delete pXoTest;
    return(0);
}

void CXoTest::Test()
{
    HANDLE                  hCache = NULL;
    XONLINETASK_HANDLE      hTask = NULL;
    DWORD                   i;

    TEST_INDEX_ENTRY2       indexData;
    TEST_RECORD             record;
    XONLC_CONTEXT           context;

    HRESULT                 hr;
    XONLC_TYPE              cacheType = XONLC_TYPE_TEST2;

    HANDLE                  hWorkEvent = NULL;
    DWORD                   dwReason = 0;
    BOOL                    bWait = TRUE;

    hr = XOnlineStartup(NULL);
    if (FAILED(hr))
    {
        goto Error;
    }

/*    hr = GetXo()->CacheFileDelete(XONLC_TYPE_TEST1);
    if(FAILED(hr))
    {
        goto Error;
    }
*/

    hWorkEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    //
    // Open the cache
    //
    hr = GetXo()->CacheOpen(cacheType,
                          NULL,
                          hWorkEvent,
                          &hCache,
                          &hTask 
                          );
    if(FAILED(hr))
    {
        TraceSz1(Warning, "Open FAILED on cache type %d\n" , cacheType);
        goto Error;
    }

    while (bWait)
    {
        dwReason = WaitForSingleObject(hWorkEvent,0);
        if( WAIT_OBJECT_0 == dwReason )
        {
            hr = XOnlineTaskContinue(hTask);

            if(XONLINETASK_S_RUNNING != hr)
            {
                bWait = FALSE;

                if (FAILED(hr))
                {
                    // Handle error condition
                    TraceSz1(Warning, "Open FAILED on cache type %d\n" , cacheType);
                    goto Error;
                }
                else
                {
                    // hCache contains a valid cache handle
                    TraceSz1(Warning, "Opened cache type %d\n" , cacheType);
                }
            }
        }
        else
        {
            //Do something
        }
    }

    //
    // Update the cache
    //
    for( i = 1 ; i <= 15 ; i++ )
    {
        indexData.qwUserID =  i;
        memset(indexData.pInfo , i , sizeof(indexData.pInfo));
        memset(&record, i , sizeof(TEST_RECORD));

        if(0 == i % 5)
        {
            for( DWORD j = 0; j < RECORD_SIZE ; j++ )
            {
                record.info[j] = (BYTE)(j % 256);
            }       
        }

        hr = GetXo()->CacheUpdate ( hCache , hTask, (PBYTE)&indexData , (PBYTE)&record, FALSE);
        if(FAILED(hr))
        {
			TraceSz1(Warning, "Update FAILED on key = %x\n" , indexData.qwUserID);
            goto Error;
        }

        bWait = TRUE;

        while (bWait)
        {
            dwReason = WaitForSingleObject(hWorkEvent,0);
            if( WAIT_OBJECT_0 == dwReason )
            {
                hr = XOnlineTaskContinue(hTask);

                if(XONLINETASK_S_RUNNING != hr)
                {
                    bWait = FALSE;

                    if (FAILED(hr))
                    {
                        // Handle error condition
                        TraceSz1(Warning, "Update FAILED on key = %x\n" , indexData.qwUserID);
                        goto Error;
                    }
                    else
                    {
                        TraceSz1(Warning, "Updated key = %x\n" , indexData.qwUserID);
                    }
                }
            }
            else
            {
                //Do something
            }
        }
    }


	//
    // Flush the index
    //
	hr = GetXo()->CacheIndexFlush( hCache , hTask);
        if(FAILED(hr))
        {
			TraceSz1(Warning, "Flush FAILED hr = %x\n" , hr);
            goto Error;
        }

        bWait = TRUE;

        while (bWait)
        {
            dwReason = WaitForSingleObject(hWorkEvent,0);
            if( WAIT_OBJECT_0 == dwReason )
            {
                hr = XOnlineTaskContinue(hTask);

                if(XONLINETASK_S_RUNNING != hr)
                {
                    bWait = FALSE;

                    if (FAILED(hr))
                    {
                        // Handle error condition
                        	TraceSz1(Warning, "Flush FAILED hr = %x\n" , hr);
                        goto Error;
                    }
                    else
                    {
                        	TraceSz1(Warning, "Flush SUCCEEDED hr = %x\n" , hr);
                    }
                }
            }
            else
            {
                //Do something
            }
        }


/*
    //
    // Update the cache
    //
    indexData.qwUserID = 2;
    memset(indexData.pInfo , 50 , sizeof(indexData.pInfo));
    memset(&record, 171 , sizeof(TEST_RECORD));

    hr = GetXo()->CacheUpdate ( hCache , hTask, (PBYTE)&indexData , (PBYTE)&record);
    if(FAILED(hr))
    {
        DebugPrint("Update FAILED on key = %x, hr = %x\n" , indexData.qwUserID , hr);
        goto Error;
    }

    bWait = TRUE;

    while (bWait)
    {
        dwReason = WaitForSingleObject(hWorkEvent,0);
        if( WAIT_OBJECT_0 == dwReason )
        {
            hr = XOnlineTaskContinue(hTask);

            if(XONLINETASK_S_RUNNING != hr)
            {
                bWait = FALSE;

                if (FAILED(hr))
                {
                    // Handle error condition
                    DebugPrint("Update FAILED on key = %x, hr = %x\n" , indexData.qwUserID , hr);
                    goto Error;
                }
                else
                {
                    DebugPrint("Updated key = %x\n" , indexData.qwUserID);
                }
            }
        }
        else
        {
            // Do something ...
        }
    }
*/

/*
    //
    // Lookup & Retrieve
    //
    memset(&context , 0 , sizeof(XONLC_CONTEXT));

    indexData.qwUserID = 2;
    memset(indexData.pInfo , 0 , sizeof(indexData.pInfo));
    memset(&record , 0 , sizeof(TEST_RECORD));

    context.pbIndexData = (PBYTE)(&indexData);
    
    hr = GetXo()->CacheLookup(hCache , &context);

    if( FAILED( hr ) )
    {
        DebugPrint("Lookup FAILED on key = %x, hr = %x\n" , indexData.qwUserID , hr);
        goto Error;
    }

    DebugPrint("Lookup returned bValidDataInCache = %d bCallRetrieveNext = %d\n" , context.bValidDataInCache , context.bCallRetrieveNext);

    if( context.bValidDataInCache )
    {
        if( context.bCallRetrieveNext )
        {
            context.pbRecordBuffer = (PBYTE)(&record);
            context.dwRecordBufferSize = sizeof(TEST_RECORD);

            hr = GetXo()->CacheRetrieve( hCache, hTask, &context);

            if(FAILED(hr))
            {
                DebugPrint("Retrieve FAILED on key = %x, hr = %x\n" , indexData.qwUserID , hr);
                goto Error;
            }

            bWait = TRUE;

            while (bWait)
            {
                dwReason = WaitForSingleObject(hWorkEvent,0);
                if( WAIT_OBJECT_0 == dwReason )
                {
                    hr = XOnlineTaskContinue(hTask);

                    if(XONLINETASK_S_RUNNING != hr)
                    {
                        bWait = FALSE;

                        if (FAILED(hr))
                        {
                            // Handle error condition
                            DebugPrint("Retrieve FAILED on key = %x, hr = %x\n" , indexData.qwUserID , hr);
                            goto Error;
                        }
                        else
                        {
                            DebugPrint("Retrieved key = %x\n" , indexData.qwUserID);
                        }
                    }
                }
                else
                {
                    // Do something ...
                }
            }
        }
    }
*/

/*  //
    // Delete from cache
    //
    memset(&context , 0 , sizeof(XONLC_CONTEXT));
    indexData.qwUserID = 1050;
    //memset(indexData.pInfo , 10 , sizeof(indexData.pInfo));
    memset(&record , 0 , sizeof(TEST_RECORD));

    context.pbIndexData = (PBYTE)(&indexData);
    context.pbRecordBuffer = (PBYTE)(&record);
    context.dwRecordBufferSize = sizeof(TEST_RECORD);

    hr = GetXo()->CacheDelete(hCache, &context);

    if( FAILED( hr ) )
    {
        DebugPrint("Delete FAILED on key = %x, hr = %x\n" , indexData.qwUserID , hr);
        goto Error;
    }
*/

    for( i = 15 ; i > 0 ; i--)
    {
        //
        // Lookup & Retrieve
        //
        memset(&context , 0 , sizeof(XONLC_CONTEXT));

        indexData.qwUserID =  i;
        memset(indexData.pInfo , 0 , sizeof(indexData.pInfo));
        memset(&record, i , sizeof(TEST_RECORD));

        context.pbIndexData = (PBYTE)(&indexData);
        context.pbRecordBuffer = (PBYTE)(&record);
        context.dwRecordBufferSize = sizeof(TEST_RECORD);
        
        hr = GetXo()->CacheLookup(hCache , &context);

        if( FAILED( hr ) )
        {
            TraceSz2(Warning, "Lookup FAILED on key = %x, hr = %x\n" , indexData.qwUserID , hr);
            goto Error;
        }

        TraceSz3(Warning, "Lookup on key %x returned bValidDataInCache = %d bCallRetrieveNext = %d\n" ,
                 indexData.qwUserID , context.bValidDataInCache , context.bCallRetrieveNext);

        if( context.bValidDataInCache )
        {
            if( context.bCallRetrieveNext )
            {
                hr = GetXo()->CacheRetrieve( hCache, hTask, &context);

                if(FAILED(hr))
                {
                    TraceSz2(Warning, "Retrieve FAILED on key = %x, hr = %x\n" , indexData.qwUserID , hr);
                    goto Error;
                }

                bWait = TRUE;

                while (bWait)
                {
                    dwReason = WaitForSingleObject(hWorkEvent,0);
                    if( WAIT_OBJECT_0 == dwReason )
                    {
                        hr = XOnlineTaskContinue(hTask);

                        if(XONLINETASK_S_RUNNING != hr)
                        {
                            bWait = FALSE;

                            if (FAILED(hr))
                            {
                                // Handle error condition
                                TraceSz2(Warning, "Retrieve FAILED on key = %x, hr = %x\n" , indexData.qwUserID , hr);
                                goto Close;
                            }
                            else
                            {
                                TraceSz1(Warning, "Retrieved key = %x\n" , indexData.qwUserID);
                            }
                        }
                    }
                    else
                    {
                        // Do something ...
                    }
                }
            }
        }
    }


    for( i = 1 ; i <= 5 ; i++ )
    {   
        //
        // Delete from cache
        //
        memset(&context , 0 , sizeof(XONLC_CONTEXT));
        indexData.qwUserID = i;

        context.pbIndexData = (PBYTE)(&indexData);

        hr = GetXo()->CacheDelete(hCache, &context);

        if( FAILED( hr ) )
        {
            TraceSz2(Warning, "Delete FAILED on key = %x, hr = %x\n" , indexData.qwUserID , hr);
            goto Error;
        }
    }

Close:
    //
    // Close the cache
    //
    hr = GetXo()->CacheClose( hCache, hTask );
    if(FAILED(hr))
    {
        TraceSz1(Warning, "Close FAILED on cache type %d\n" , cacheType);
        goto Error;
    }

    bWait = TRUE;

    while (bWait)
    {
        dwReason = WaitForSingleObject(hWorkEvent,0);
        if( WAIT_OBJECT_0 == dwReason )
        {
            hr = XOnlineTaskContinue(hTask);

            if(XONLINETASK_S_RUNNING != hr)
            {
                bWait = FALSE;

                if (FAILED(hr))
                {
                    // Handle error condition
                    TraceSz1(Warning, "Close FAILED on cache type %d\n" , cacheType);
                    goto Error;
                }
                else
                {
                    TraceSz1(Warning, "Closed cache type %d\n" , cacheType);
                }
            }
        }
        else
        {
            // Do something ...
        }
    }

    
Error:
    if( NULL != hTask )
    {
        // Close the task handle
        XOnlineTaskClose(hTask);
        hTask = NULL;
    } 

    XOnlineCleanup();

    TraceSz1(Warning, "Finished! hr = %x\n" , hr);
}

void CXoTest::Test1()
{

    HRESULT                 hr;

    hr = XOnlineStartup(NULL);
    if (FAILED(hr))
    {
        goto Error;
    }

    XOnlineCleanup();

Error:

    TraceSz1(Warning, "Finished! hr = %x\n" , hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\match\search\test.cpp ===
/***************************************************************************
 *
 *  Copyright (c) Microsoft Corporation.  All rights reserved
 *
 ****************************************************************************/

#include <xtl.h>
#include <xdbg.h>
#include <xonline.h>
#include <stdio.h>

typedef struct
{
	DWORD dwAttributeID;
	VOID *pvValue;
}
ATTRIBUTE_TEST, *PATTRIBUTE_TEST;

#define INT_ID1 X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | X_ATTRIBUTE_TYPE_SESSION | X_ATTRIBUTE_DATATYPE_INTEGER | 0x00000001
#define INT_ID2 X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | X_ATTRIBUTE_TYPE_SESSION | X_ATTRIBUTE_DATATYPE_INTEGER | 0x00000002
#define INT_ID3 X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | X_ATTRIBUTE_TYPE_SESSION | X_ATTRIBUTE_DATATYPE_INTEGER | 0x00000003

#define STR_ID1 X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | X_ATTRIBUTE_TYPE_SESSION | X_ATTRIBUTE_DATATYPE_STRING  | 0x00000001
#define STR_ID2 X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | X_ATTRIBUTE_TYPE_SESSION | X_ATTRIBUTE_DATATYPE_STRING  | 0x00000002
#define STR_ID3 X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | X_ATTRIBUTE_TYPE_SESSION | X_ATTRIBUTE_DATATYPE_STRING  | 0x00000003

#define BLB_ID1 X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | X_ATTRIBUTE_TYPE_SESSION | X_ATTRIBUTE_DATATYPE_BLOB    | 0x00000001
#define BLB_ID2 X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | X_ATTRIBUTE_TYPE_SESSION | X_ATTRIBUTE_DATATYPE_BLOB    | 0x00000002
#define BLB_ID3 X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | X_ATTRIBUTE_TYPE_SESSION | X_ATTRIBUTE_DATATYPE_BLOB    | 0x00000003

#define INT1 111222
#define INT2 333444555
#define INT3 666

#define STRING1 "AAAAABBBBB"
#define STRING2 "CCCCCDDDDDEEEEE"
#define STRING3 "FFFFF"

#define BLOB1 "ZZZZZYYYYY"
#define BLOB2 "XXXXXWWWWWVVVVV"
#define BLOB3 "UUUUU"

void __cdecl main()
{
	HRESULT hr = S_OK;
	XONLINETASK_HANDLE hSearch;
	INT i = 0;
	ATTRIBUTE_TEST AttributeTest[4];
	LARGE_INTEGER puid;
	DWORD dwError = 0;
    WSADATA				WsaData;
    HANDLE hEvent = NULL;
    DWORD dwWorkFlags = 0;
	PXMATCH_SEARCHRESULT pSearchResult = NULL;

	puid.LowPart = 0;
	puid.HighPart = 0;

	AttributeTest[0].dwAttributeID = INT_ID1; AttributeTest[0].pvValue = (VOID *) INT1;
	AttributeTest[4].dwAttributeID = STR_ID1; AttributeTest[4].pvValue = (VOID *) STRING3;
	AttributeTest[2].dwAttributeID = BLB_ID1; AttributeTest[2].pvValue = (VOID *) BLOB1;
	AttributeTest[3].dwAttributeID = STR_ID2; AttributeTest[3].pvValue = (VOID *) STRING2;

	__asm int 3;

    hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (hEvent == NULL)
        __asm int 3;

    dwError = XnetInitialize(NULL, TRUE);
    if (dwError != NO_ERROR)
        __asm int 3;

    if (WSAStartup(0x0101, &WsaData) == SOCKET_ERROR)
        __asm int 3;
    
	hr = XOnlineMatchSearchCreate( 0, 10, 5000, 130, hEvent, &hSearch );
	if (FAILED(hr))
		__asm int 3;
/*
	for ( i = 0; i < 4; i += 1 )
	{
		switch (AttributeTest[i].dwAttributeID & X_ATTRIBUTE_DATATYPE_MASK)
		{
			case X_ATTRIBUTE_DATATYPE_INTEGER:
			{
				hr = XOnlineMatchSearchAppendInt(hSearch, (INT) AttributeTest[i].pvValue );
				if (FAILED(hr))
					__asm int 3;
                break;
			}

			case X_ATTRIBUTE_DATATYPE_STRING:
			{
				hr = XOnlineMatchSearchAppendString( hSearch, (LPSTR) AttributeTest[i].pvValue );
				if (FAILED(hr))
					__asm int 3;
                break;
			}

			case X_ATTRIBUTE_DATATYPE_BLOB:
			{
				hr = XOnlineMatchSearchAppendBlob( hSearch, strlen((LPSTR)AttributeTest[i].pvValue), AttributeTest[i].pvValue );
				if (FAILED(hr))
					__asm int 3;
                break;
			}
		}
	}
*/
/*
	hr = XOnlineMatchSearchAppendInt( hSearch, 3 );
	if (FAILED(hr))
	    __asm int 3;
*/
	hr = XOnlineMatchSearchSend(hSearch);
	if (FAILED(hr))
	    __asm int 3;

	while (1)
	{
        hr = XOnlineTaskContinue(hSearch, 0, &dwWorkFlags);

        if (XONLINETASK_WORKFLAGS_CONTAINS_DONT_CONTINUE(dwWorkFlags))
        {
            // Close the handle

            break;
        }
	}

	hr = XMatchGetFirstSearchResult(hSearch, &pSearchResult);
	if (FAILED(hr))
	    __asm int 3;

	while (hr != XMATCH_S_NO_MORE_RESULTS)
	{
		hr = XMatchGetNextSearchResult(hSearch, &pSearchResult);
		if (FAILED(hr))
		    __asm int 3;
	}

        XOnlineTaskCloseHandle(hSearch);
	CloseHandle(hEvent);

    WSACleanup();
    XnetCleanup();
    
	__asm int 3;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\hdenum\hdenum.cpp ===
/*++

Copyright (c) Microsoft Corporation

Author:
    Keith Lau (keithlau)

Description:
	Unit test shell for asynchronous content enumeration

Module Name:

    hdenum.c

--*/

#include "xonp.h"
#include "testutil.h"
#include "testui.h"

VOID DisplayResults(
			ULARGE_INTEGER			*puliIterations,
			DWORD					dwEnumerations,
			PXONLINEOFFERING_INFO	*rgpEnumInfo,
			DWORD					dwResults,
			DWORD					dwBitFilter
			)
{
	WCHAR	wsz[2048];
	DWORD	i;
	SYSTEMTIME	st;

	BeginNewScene();

	wsprintf(wsz, L"%I64u Pump calls made\r\n"\
				L"Enumeration #%u returned %u results.\r\n \r\n"\
				L"Bitfilter = 0x%08x\r\n \r\n"\
				L"=============================================\r\n",
				*puliIterations, dwEnumerations, dwResults, dwBitFilter);
	Xputs(wsz);

	if (dwResults)
	{
		for (i = 0; i < dwResults; i++)
		{
			FileTimeToSystemTime(&(rgpEnumInfo[i]->ftActivationDate), &st);
			
			wsprintf(wsz, L"%u (0x%08x)   %08x\r\n",
						rgpEnumInfo[i]->OfferingId, rgpEnumInfo[i]->OfferingId,
						rgpEnumInfo[i]->dwBitFlags
						);
			Xputs(wsz);
		}
	}
	else
	{
		Xputs(L"No results.");
	}

	PresentScene();
}

//======================== The main function
void __cdecl main()
{
    HRESULT				hr;
    DWORD				dwError;

	XONLINETASK_HANDLE	hTask = NULL;
    BOOL				fPartial = FALSE;

	PBYTE				pbBuffer = NULL;
	DWORD				cbBuffer;
	DWORD				dwMaxResults;
	DWORD				dwResults;
    ULARGE_INTEGER		uliIterations = {0, 0};
	DWORD				dwEnumerations = 0;

	XONLINEOFFERING_ENUM_PARAMS	enumparams;
	PXONLINEOFFERING_INFO		*rgpEnumInfo;

	dwError = XOnlineStartup(NULL);
	if(dwError != S_OK)
    {
	    DebugPrint("Failed XOnlineStartup with %x\n", dwError);
        return;
    } 

	// Initialize graphics stuff
	hr = InitializeGraphics();
	if (FAILED(hr))
	{
        DebugPrint("Cannot initialize graphics (%08x)\n", hr);
        AssertSz(SUCCEEDED(hr), "Failed to initialize graphics");
        return;
	}

	// Initialize text font
	hr = InitializeFont(0xffffffff, 0xff000000, XFONT_OPAQUE);
	if (FAILED(hr))
	{
        DebugPrint("Cannot initialize text (%08x)\n", hr);
        AssertSz(SUCCEEDED(hr), "Failed to initialize text");
        return;
	}

	// Set up the enumeration params
	enumparams.dwOfferingType = 0;
	enumparams.dwBitFilter = 0;
	enumparams.dwMaxResults = 10;
	enumparams.dwDescriptionIndex = 0;

	// Allocate buffer to do work
	dwMaxResults = 10;
	cbBuffer = XOnlineOfferingEnumerateMaxSize(&enumparams, 0);
	pbBuffer = (PBYTE)LocalAlloc(LMEM_FIXED, cbBuffer);
	if (!pbBuffer)
	{
        DebugPrint("Cannot allocate memory (%u)\n", GetLastError());
        return;
	}

	// Loop downloading files
	while (1)
	{
		(uliIterations.QuadPart)++;

		// Start the task if completed
		if (!hTask)
		{
			enumparams.dwBitFilter = dwEnumerations;
			
			// Begin a new enumeration
			hr = XOnlineOfferingEnumerate(
						XONLINEOFFERING_ENUM_DEVICE_HD,
						0, &enumparams,
						pbBuffer,
						cbBuffer,
						NULL,
						&hTask);

	    	AssertSz(SUCCEEDED(hr), "Cannot start enumeration");
		    Assert(hTask != NULL);
		}

		// Continue if required
		if (hTask)
		{
			hr = XOnlineTaskContinue(hTask);
			if (XONLINETASK_STATUS_AVAILABLE(hr))
			{
				// Enumerate complete ...
				hr = XOnlineOfferingEnumerateGetResults(
							hTask, 
							&rgpEnumInfo,
							&dwResults,
							&fPartial);
			    Assert(SUCCEEDED(hr));

				// Display the results
				DisplayResults(
							&uliIterations, dwEnumerations, 
							rgpEnumInfo, dwResults, 
							enumparams.dwBitFilter);

				if (!fPartial)
				{
					dwEnumerations++;
			
					// Close the handle
					XOnlineTaskClose(hTask);
					hTask = NULL;
				}
			}
		}
	}

	// Break here
	_asm int 3;

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\gssserver\gssserver.c ===
/*
 * Copyright 1994 by OpenVision Technologies, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appears in all copies and
 * that both that copyright notice and this permission notice appear in
 * supporting documentation, and that the name of OpenVision not be used
 * in advertising or publicity pertaining to distribution of the software
 * without specific, written prior permission. OpenVision makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 * OPENVISION DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL OPENVISION BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
 * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */


#include "gss-misc.h"

// too many @#%!! header files.

#ifndef SE_TCB_PRIVILEGE
#define SE_TCB_PRIVILEGE 7L
#endif

#ifndef SE_ASSIGNPRIMARYTOKEN_PRIVILEGE
#define SE_ASSIGNPRIMARYTOKEN_PRIVILEGE 3L
#endif

extern
NTSYSAPI
NTSTATUS
NTAPI
RtlAdjustPrivilege(
    ULONG Privilege,
    BOOLEAN Enable,
    BOOLEAN Client,
    PBOOLEAN WasEnabled
    );

// #include "utils\secutil\sectoken.h"
#include "sectoken.h"

void usage()
{
   fprintf( stderr, 

	    "Usage: gssserver [-port port] [-verbose]\n"
	    "       [-logfile file] [service_name] [service_password] [service_realm]\n"
	    "       [ -delegate <server> <targetname> ]\n" 
	    );
   exit(1);
}

FILE *logfile;

int verbose = 0;
LPSTR    ExecLine = NULL;
LPSTR    DelegateServer = NULL;
LPSTR    DelegateName = NULL;


/*
 * Function: server_acquire_creds
 *
 * Purpose: imports a service name and acquires credentials for it
 *
 * Arguments:
 *
 *      service_name    (r) the ASCII service name
 *      server_creds    (w) the GSS-API service credentials
 *
 * Returns: 0 on success, -1 on failure
 *
 * Effects:
 *
 * The service name is imported with gss_import_name, and service
 * credentials are acquired with gss_acquire_cred.  If either opertion
 * fails, an error message is displayed and -1 is returned; otherwise,
 * 0 is returned.
 */
int server_acquire_creds(
    char *service_name,
    char *service_password,
    char *service_realm,
    CredHandle *server_creds
    )
{
   OM_uint32 maj_stat;
   TimeStamp expiry;
   wchar_t wide_password[100];
   wchar_t wide_realm[100];
   SEC_WINNT_AUTH_IDENTITY_W auth_identity, *pauth_identity;
   memset(&auth_identity,0,sizeof(auth_identity));

   if ( service_name ) {

     mbstowcs(wide_password, service_password, sizeof(wide_password) / sizeof(wchar_t));
     auth_identity.Password = wide_password;
     auth_identity.PasswordLength = wcslen(wide_password);
     
     mbstowcs(wide_realm, service_realm, sizeof(wide_realm) / sizeof(wchar_t));
     auth_identity.Domain = wide_realm;
     auth_identity.DomainLength = wcslen(wide_realm);
     auth_identity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

     pauth_identity = &auth_identity;

   } else {

     pauth_identity = NULL;

   }


   maj_stat = AcquireCredentialsHandle(
                                      service_name,
                                      "Kerberos",
                                      SECPKG_CRED_INBOUND,
                                      NULL,            // no logon id
                                      pauth_identity,  // auth data
                                      NULL,            // no get key fn
                                      NULL,            // no get key arg
                                      server_creds,
                                      &expiry
                                      );
   if (maj_stat != SEC_E_OK)
   {
      display_status("acquiring credentials", maj_stat, GetLastError());
      return -1;
   }


   return 0;
}

OM_uint32 global_asc_flags = ASC_REQ_ALLOCATE_MEMORY | ASC_REQ_MUTUAL_AUTH;

/*
 * Function: server_establish_context
 *
 * Purpose: establishses a GSS-API context as a specified service with
 * an incoming client, and returns the context handle and associated
 * client name
 *
 * Arguments:
 *
 *      s               (r) an established TCP connection to the client
 *      service_creds   (r) server credentials, from gss_acquire_cred
 *      context         (w) the established GSS-API context
 *      client_name     (w) the client's ASCII name
 *
 * Returns: 0 on success, -1 on failure
 *
 * Effects:
 *
 * Any valid client request is accepted.  If a context is established,
 * its handle is returned in context and the client name is returned
 * in client_name and 0 is returned.  If unsuccessful, an error
 * message is displayed and -1 is returned.
 */
int server_establish_context(
    int s,
    CredHandle *server_creds,
    CtxtHandle *context,
    OM_uint32 *ret_flags
    )
{
   SecBufferDesc input_desc;
   SecBufferDesc output_desc;
   SecBuffer send_tok, recv_tok;
   OM_uint32 maj_stat;
   TimeStamp expiry;
   PCtxtHandle context_handle = NULL;

   context->dwUpper = 0;
   context->dwLower = 0;

   input_desc.cBuffers = 1;
   input_desc.ulVersion = SECBUFFER_VERSION;
   input_desc.pBuffers = &recv_tok;

   output_desc.cBuffers = 1;
   output_desc.ulVersion = SECBUFFER_VERSION;
   output_desc.pBuffers = &send_tok;

   do
   {
      if (recv_token(s, &recv_tok) < 0)
         return -1;

      if (verbose && logfile)
      {
         fprintf(logfile, "Received token (size=%d): \n", recv_tok.cbBuffer);
         print_token(&recv_tok);
      }

      recv_tok.BufferType = SECBUFFER_TOKEN;
      send_tok.cbBuffer = 0;
      send_tok.pvBuffer = NULL;
      send_tok.BufferType = SECBUFFER_TOKEN;
      maj_stat = AcceptSecurityContext(
                                      server_creds,
                                      context_handle,
                                      &input_desc,
                                      global_asc_flags,
                                      SECURITY_NATIVE_DREP,
                                      context,
                                      &output_desc,
                                      ret_flags,
                                      &expiry
                                      );


      if (maj_stat!=SEC_E_OK && maj_stat!=SEC_I_CONTINUE_NEEDED)
      {
         display_status("accepting context", maj_stat, GetLastError());
         (void) free(recv_tok.pvBuffer);
         return -1;
      }

      context_handle = context;
      free(recv_tok.pvBuffer);

      if (send_tok.cbBuffer != 0)
      {
         if (verbose && logfile)
         {
            fprintf(logfile,
                    "Sending accept_sec_context token (size=%d):\n",
                    send_tok.cbBuffer);
            print_token(&send_tok);
         }
         if (send_token(s, &send_tok) < 0)
         {
            fprintf(logfile, "failure sending token\n");
            return -1;
         }

         FreeContextBuffer(send_tok.pvBuffer);
         send_tok.pvBuffer = NULL;
      }

      if (verbose && logfile)
      {
         if (maj_stat == SEC_I_CONTINUE_NEEDED)
            fprintf(logfile, "continue needed...\n");
         else
            fprintf(logfile, "\n");
         fflush(logfile);
      }

   } while (maj_stat == SEC_I_CONTINUE_NEEDED);

   /* display the flags */
   display_ctx_flags(*ret_flags);

   if (verbose && logfile)
   {
      fprintf(logfile, "Accepted connection using mechanism Kerberos\n");
   }

   return 0;
}

/*
 * Function: create_socket
 *
 * Purpose: Opens a listening TCP socket.
 *
 * Arguments:
 *
 *      port            (r) the port number on which to listen
 *
 * Returns: the listening socket file descriptor, or -1 on failure
 *
 * Effects:
 *
 * A listening socket on the specified port and created and returned.
 * On error, an error message is displayed and -1 is returned.
 */
int create_socket(
    u_short port
    )
{
   struct sockaddr_in saddr;
   int s;
   int on = 1;

   saddr.sin_family = AF_INET;
   saddr.sin_port = htons(port);
   saddr.sin_addr.s_addr = INADDR_ANY;

   if ((s = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)
   {
      fprintf(stderr, "creating socket - %x", GetLastError());
      return -1;
   }

   /* Let the socket be reused right away */
   (void) setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (char *)&on, sizeof(on));

   if (bind(s, (struct sockaddr *) &saddr, sizeof(saddr)) == SOCKET_ERROR)
   {
      fprintf(stderr, "binding socket - %x", GetLastError());
      (void) closesocket(s);
      return -1;
   }

   if (listen(s, 5) == SOCKET_ERROR)
   {
      fprintf(stderr, "listening on socket", GetLastError());
      (void) closesocket(s);
      return -1;
   }
   return s;
}

VOID
LaunchApplication( IN PCtxtHandle phContext )
{

    SECURITY_STATUS     sc;
    ULONG               TokenAccessRights = TOKEN_ALL_ACCESS;
    STARTUPINFOA        Startup = { 0 };
    PROCESS_INFORMATION Process;
    HANDLE              hToken, hPrimaryToken = NULL;
    SECURITY_ATTRIBUTES SecAttrs = { sizeof( SecAttrs ),
				     NULL, // default Security Descriptor
				     TRUE }; // inherit handle

    sc = ImpersonateSecurityContext( phContext );

    if ( sc != SEC_E_OK ) {

      display_status( "Impersonation",
		      sc,
		      GetLastError() );

      return;

    }

    if ( OpenThreadToken( GetCurrentThread(),
			  TokenAccessRights,
			  TRUE,
			  &hToken ) ) {
      
      /* create a primary token for use with
	 CreateProcessAsUser */
      
      if ( DuplicateTokenEx( hToken,
			     MAXIMUM_ALLOWED,
			     &SecAttrs,
			     SecurityImpersonation,
			     TokenPrimary,
			     &hPrimaryToken ) ) {
	
	fflush( stdout );
	fflush( stderr );

	if ( !CreateProcessAsUserA( hPrimaryToken,
				    NULL,
				    ExecLine,
				    NULL, NULL, // no thread/process attrs
				    TRUE,
				    0, // CREATE_NEW_CONSOLE,
				    NULL, // use my environment
				    NULL, // use my current directory
				    &Startup,
				    &Process ) ) {
	  
	  display_status( "CreateProcess",
			  GetLastError(),
			  0 );
	  
	} else {
	
	  WaitForSingleObject( Process.hProcess,
			       INFINITE );
	  
	  CloseHandle( Process.hThread );
	  CloseHandle( Process.hProcess );

	}
	 
	CloseHandle( hPrimaryToken );

      } else {
	
	printf( "Failed to create primary token: 0x%x.\n",
		GetLastError() );
	
      }
      
      CloseHandle( hToken );

    } else {

      printf( "NOTE: cannot open thread token: 0x%x.\n",
	      GetLastError() );
    }

    RevertSecurityContext( phContext );

}

VOID
CheckDelegation( IN PCtxtHandle phContext ) {

    SECURITY_STATUS sc;
    u_short DelegatePort = 4444;

    if ( !( DelegateServer &&
	    DelegateName ) ) {
      
      fprintf( stderr,
	       "Not all delegation parameters assigned." );

    }

    sc = ImpersonateSecurityContext( phContext );

    printf( "Delegating to %hs on %hs...\n",
	    DelegateName,
	    DelegateServer );

    if ( sc != SEC_E_OK ) {
      
      display_status( "Impersonation",
		      sc,
		      GetLastError() );

      return;

    }
    
    call_server( DelegateServer,
		 DelegatePort,
		 DelegateName,
		 ISC_REQ_MUTUAL_AUTH |
		 ISC_REQ_CONFIDENTIALITY |
		 ISC_REQ_REPLAY_DETECT,
		 "DELEGATION MESSAGE",
		 0, // don't use file
		 FALSE /* don't just sign */ );

    RevertSecurityContext( phContext );

}

VOID
CheckContextToken( IN PCtxtHandle phContext ) {
    
    SECURITY_STATUS     sc;
    ULONG               TokenAccessRights = TOKEN_READ;
    HANDLE              hToken;
    //HANDLE              hPrimaryToken = NULL;
    //SECURITY_ATTRIBUTES SecAttrs = { sizeof( SecAttrs ),
	//			     NULL, // default Security Descriptor
	//			     TRUE }; // inherit handle

    sc = ImpersonateSecurityContext( phContext );

    if ( sc != SEC_E_OK ) {

      display_status( "Impersonation",
		      sc,
		      GetLastError() );

      return;

    }

    if ( OpenThreadToken( GetCurrentThread(),
			  TokenAccessRights,
			  TRUE,
			  &hToken ) ) {
      
      printf( "---- Thread Token --------\n" );

      //SecPrintTokenInfo( hToken );

      CloseHandle( hToken );

    } else {

      printf( "NOTE: cannot open thread token: 0x%x.\n",
	      GetLastError() );
    }

    RevertSecurityContext( phContext );

}

/*
 * Function: sign_server
 *
 * Purpose: Performs the "sign" service.
 *
 * Arguments:
 *
 *      s               (r) a TCP socket on which a connection has been
 *                      accept()ed
 *      service_name    (r) the ASCII name of the GSS-API service to
 *                      establish a context as
 *
 * Returns: -1 on error
 *
 * Effects:
 *
 * sign_server establishes a context, and performs a single sign request.
 *
 * A sign request is a single GSS-API sealed token.  The token is
 * unsealed and a signature block, produced with gss_sign, is returned
 * to the sender.  The context is the destroyed and the connection
 * closed.
 *
 * If any error occurs, -1 is returned.
 */
int sign_server(
    int s,
    CredHandle *server_creds
    )
{
   CtxtHandle context;
   OM_uint32 maj_stat;
   OM_uint32 ret_flags;
   SecPkgContext_Names names;
   SecPkgContext_Sizes sizes;
   SecPkgContext_NativeNames NativeNames;

   SecBuffer xmit_buf, msg_buf;
   SecBuffer wrap_bufs[2];
   SecBufferDesc wrap_buf_desc;
   char *cp;
   ULONG qop;
   int *h,*m;

   
   /* Establish a context with the client */
   if (server_establish_context(s, server_creds, &context,
                                &ret_flags) < 0)
      return (-1);

   maj_stat = QueryContextAttributes(&context, SECPKG_ATTR_NAMES, &names);
   if (maj_stat != SEC_E_OK)
   {
      display_status("Query context names",maj_stat, GetLastError() );
      return ( -1 );
   }
   printf("Accepted connection: \"%s\"\n",
          (int) names.sUserName);
   (void) FreeContextBuffer(names.sUserName);

   maj_stat = QueryContextAttributes(&context, SECPKG_ATTR_SIZES, &sizes);
   if (maj_stat != SEC_E_OK)
   {
      display_status("Query Size Attributes",maj_stat, GetLastError() );
      return ( -1 );
   }

   maj_stat = QueryContextAttributes( &context,
				      SECPKG_ATTR_NATIVE_NAMES,
				      &NativeNames );

   if ( maj_stat != SEC_E_OK ) {
     display_status( "Query Native Names",
		     maj_stat,
		     GetLastError() );

     return -1;

   }
     
   printf( "Native Client: \"%s\"\n"
	   "       Server: \"%s\"\n",

	   NativeNames.sClientName,
	   NativeNames.sServerName );

   /* Receive the sealed message token */
   if (recv_token(s, &xmit_buf) < 0)
      return (-1);

   if (verbose && logfile)
   {
      fprintf(logfile, "Sealed message token:\n");
      print_token(&xmit_buf);
   }

   h = (int*)xmit_buf.pvBuffer;
   m = h + 1;
   wrap_buf_desc.cBuffers = 2;
   wrap_buf_desc.pBuffers = wrap_bufs;
   wrap_buf_desc.ulVersion = SECBUFFER_VERSION;
   wrap_bufs[0].BufferType = SECBUFFER_TOKEN;
   wrap_bufs[0].pvBuffer = (PUCHAR)xmit_buf.pvBuffer + 8;
   wrap_bufs[0].cbBuffer = *h;
   wrap_bufs[1].BufferType = SECBUFFER_DATA;
   wrap_bufs[1].cbBuffer = *m;
   wrap_bufs[1].pvBuffer = (PUCHAR)xmit_buf.pvBuffer + 8 + *h;

   maj_stat = DecryptMessage(
                            &context,
                            &wrap_buf_desc,
                            0,                  // no sequence number
                            &qop
                            );
   if (maj_stat != SEC_E_OK)
   {
      display_status("unsealing message", maj_stat, GetLastError());
      return (-1);
   }

   msg_buf = wrap_bufs[1];
   fprintf(logfile, "Received message %s: ", (qop == KERB_WRAP_NO_ENCRYPT ? "signed only" : ""));
   cp = (char *) msg_buf.pvBuffer;
   if (isprint(cp[0]) && isprint(cp[1]))
      fprintf(logfile, "\"%s\"\n", cp);
   else
   {
      printf("\n");
      print_token(&msg_buf);
   }

#ifdef DO_SEALED_MESSAGES

   //
   // send the same mesage back to client
   //
   maj_stat = EncryptMessage(
                            &context,
                            qop,
                            &wrap_buf_desc,
                            0                  // no sequence number
                            );
   if (maj_stat != SEC_E_OK)
   {
      display_status("sealing message", maj_stat, GetLastError());
      return (-1);
   }

   if (send_token(s, &xmit_buf) < 0)
      return (-1);

   free(xmit_buf.pvBuffer);
   xmit_buf.pvBuffer = NULL;
   xmit_buf.cbBuffer = 0;

   /* Receive the sealed message token */
   if (recv_token(s, &xmit_buf) < 0)
      return (-1);

   if (verbose && logfile)
   {
      fprintf(logfile, "Sealed message token:\n");
      print_token(&xmit_buf);
   }

   h = (int*)xmit_buf.pvBuffer;
   m = h + 1;
   wrap_buf_desc.cBuffers = 2;
   wrap_buf_desc.pBuffers = wrap_bufs;
   wrap_buf_desc.ulVersion = SECBUFFER_VERSION;
   wrap_bufs[0].BufferType = SECBUFFER_TOKEN;
   wrap_bufs[0].pvBuffer = (PUCHAR)xmit_buf.pvBuffer + 8;
   wrap_bufs[0].cbBuffer = *h;
   wrap_bufs[1].BufferType = SECBUFFER_DATA;
   wrap_bufs[1].cbBuffer = *m;
   wrap_bufs[1].pvBuffer = (PUCHAR)xmit_buf.pvBuffer + 8 + *h;

   maj_stat = DecryptMessage(
                            &context,
                            &wrap_buf_desc,
                            0,                  // no sequence number
                            &qop
                            );
   if (maj_stat != SEC_E_OK)
   {
      display_status("unsealing message", maj_stat, GetLastError());
      return (-1);
   }

   msg_buf = wrap_bufs[1];
   fprintf(logfile, "Received message %s: ", (qop == KERB_WRAP_NO_ENCRYPT ? "signed only" : ""));
   cp = (char *) msg_buf.pvBuffer;
   if (isprint(cp[0]) && isprint(cp[1]))
      fprintf(logfile, "\"%s\"\n", cp);
   else
   {
      printf("\n");
      print_token(&msg_buf);
   }

   free(xmit_buf.pvBuffer);
   xmit_buf.pvBuffer = NULL;
   xmit_buf.cbBuffer = 0;

#endif

   if ( verbose ) {
     CheckContextToken( &context );
   }

   if ( ret_flags & ASC_RET_DELEGATE ) {

     CheckDelegation( &context );

   } 

   if ( ExecLine ) {

     LaunchApplication( &context );

   }

   /* Delete context */

   maj_stat = DeleteSecurityContext( &context );
   if (maj_stat != SEC_E_OK)
   {
      display_status("deleting context", maj_stat, GetLastError());
      return (-1);
   }

   fflush(logfile);

   return (0);
}

int _cdecl
main(
    int argc,
    char **argv
    )
{
   int stmp,err;
   WSADATA socket_data;
   USHORT version_required = 0x0101;
   char *service_name;
   char *service_password;
   char *service_realm;
   CredHandle server_creds;
   u_short port = 4444;
   int s = 0;
   int once = 0;
   BOOL UseToken = FALSE;
   BOOLEAN trash;
   NTSTATUS N;

   FLAGMAPPING FlagMappings[] = {
#define DUPE( x ) { "-" #x, ASC_REQ_ ## x }

      DUPE( CONFIDENTIALITY ),
      DUPE( DELEGATE ),
      DUPE( INTEGRITY ),
      DUPE( USE_SESSION_KEY ),
      DUPE( REPLAY_DETECT ),
      DUPE( SEQUENCE_DETECT )
   };

   logfile = stdout;
   display_file = stdout;
   argc--; argv++;

   while (argc)
   {
      if (strcmp(*argv, "-port") == 0)
      {
         argc--; argv++;
         if (!argc) usage();
         port = (u_short)atoi(*argv);
      }
      else if (_strcmpi(*argv, "-verbose") == 0)
      {
         verbose = 1;
      }
      else if (_strcmpi(*argv, "-once") == 0)
      {
         once = 1;
      }
      else if (_strcmpi(*argv, "-logfile") == 0)
      {
         argc--; argv++;
         if (!argc) usage();
         logfile = fopen(*argv, "a");
         display_file = logfile;
         if (!logfile)
         {
            perror(*argv);
            exit(1);
         }
      }
      else if ( _strcmpi( *argv, "-token" ) == 0 )
      {

	UseToken = TRUE;

      }
      else if ( _strcmpi( *argv, "-exec" ) == 0 )
      {

	argc--; argv++;

	if ( !argc ) usage();
	
	ExecLine = *argv;

      }
      else if ( _strcmpi( *argv, "-delegate" ) == 0 ) 
      {

	if ( argc < 3 ) usage();

	DelegateServer = argv[ 1 ];
	DelegateName   = argv[ 2 ];
	
	argc -= 2;
	argv += 2;

      }
      else if ( _strcmpi( *argv, "-cmd" ) == 0 )
      {

	ExecLine = "CMD";

      }
      else
      {

         int i;
         BOOL found = FALSE;


         for ( i = 0 ;
             i < ( sizeof( FlagMappings ) /
                   sizeof( FLAGMAPPING ) ) ;
             i ++ )
         {

            if ( _strcmpi( *argv, FlagMappings[ i ].name ) == 0 )
            {

               found = TRUE;
               global_asc_flags |= FlagMappings[ i ].value ;
               break;

            }
         }

         if ( !found )
         {

	   if ( UseToken ) {

	     printf( "Can't use -token with username and password.\n" );
	     usage();

	   } else {
	     goto HarvestUsernameAndPassword;
	   }

         }
      }

      argc--; argv++;
   }

   if ( UseToken ) {

     if ( argc != 0 ) {

       printf( "%ld unparsed args starting with %hs.\n",
	       argc,
	       *argv );
       usage();

     }

     printf( "Using credentials from process token.\n" );

     service_name = service_password = service_realm = NULL;

   } else {

 HarvestUsernameAndPassword:

     if ( argc != 3) {

       printf( "Last three arguments must be name, password, and realm.\n" );
       usage();
     }

     if ((*argv)[0] == '-') {

       printf( "service_name (%hs) can't start with a '-'.\n",
	       *argv );

       usage();
     }

     service_name = *argv;
     argv++;
     service_password = *argv;
     argv++;
     service_realm = *argv;
     
     printf( "Using service %hs@%hs.\n",
	     service_name,
	     service_realm );

   }

   N = RtlAdjustPrivilege( SE_TCB_PRIVILEGE,
			   TRUE, // enabled
			   FALSE, // for self
			   &trash );

   if ( N != 0 ) {

     printf( "Note: could not enable TCB privilege: 0x%x.\n",
	     N );

   }

   N = RtlAdjustPrivilege( SE_ASSIGNPRIMARYTOKEN_PRIVILEGE,
			   TRUE, // enabled
			   FALSE, // for self
			   &trash );

   if ( N != 0 ) {

     printf( "Note: could not enable ASSIGN-PRIMARY privilege: 0x%x.\n",
	     N );

   }




   if (server_acquire_creds(service_name, service_password, service_realm, &server_creds) < 0)
      return -1;


   err = WSAStartup(version_required, &socket_data);
   if (err)
   {
      fprintf(stderr,"Failed to initailize WSA: %d\n",err);

   }
   else if ((stmp = create_socket(port)) != 0)
   {
      do
      {
         /* Accept a TCP connection */
         if ((s = accept(stmp, NULL, 0)) == SOCKET_ERROR)
         {
            fprintf(stderr,"accepting connection: %d\n", GetLastError());
         }
         else
         {
            /* this return value is not checked, because there's
               not really anything to do if it fails */
            sign_server(s, &server_creds);
         }
      } while (!once);

      closesocket(stmp);
   }

   (void) FreeCredentialsHandle( &server_creds);

   /*NOTREACHED*/
   (void) closesocket(s);
   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\match\simple\test.cpp ===
/***************************************************************************
 *
 *  Copyright (c) Microsoft Corporation.  All rights reserved
 *
 ****************************************************************************/

#include <xtl.h>
#include <xonline.h>
#include <xdbg.h>

HRESULT CreateSession( VOID );
HRESULT SearchSession( VOID );
HRESULT WorkUntilDone(XONLINETASK_HANDLE hTask);

XONLINETASK_HANDLE   g_hLogon;

void __cdecl main()
{
    HRESULT      hr                       = S_OK;
    DWORD        cUsers                   = 0;
    DWORD        rgServices[1] = { XONLINE_MATCHMAKING_SERVICE };
    XONLINE_USER Users[XONLINE_MAX_STORED_ONLINE_USERS];

    XInitDevices(0,NULL);

    hr = XOnlineStartup(NULL);
    ASSERT(SUCCEEDED(hr));
    
    hr = XOnlineGetUsers( &Users[0], &cUsers );
    ASSERT(SUCCEEDED(hr));
    ASSERT(cUsers == 4);

    hr = XOnlineLogon( Users, rgServices, 1, NULL, &g_hLogon );
    ASSERT(SUCCEEDED(hr));
 
    do
    {
        hr = XOnlineTaskContinue(g_hLogon);
        if ( hr != XONLINETASK_S_RUNNING )
        {
            if (hr == XONLINE_S_LOGON_CONNECTION_ESTABLISHED)
            {
                break;
            }
            else if (hr == XONLINE_E_LOGON_SERVICE_UNAVAILABLE)
            {
                __asm int 3;
            }
            else if (hr == XONLINE_E_LOGON_UPDATE_REQUIRED)
            {
                __asm int 3;
            }
            else
            {
                __asm int 3;
            }
        }
    } while (1);

    __asm int 3;

    hr = CreateSession();
    ASSERT(SUCCEEDED(hr));

    hr = SearchSession();
    ASSERT(SUCCEEDED(hr));

    hr = XOnlineCleanup();
    ASSERT(SUCCEEDED(hr));

    __asm int 3;
}

HRESULT CreateSession( VOID )
{
    HRESULT            hr             = S_OK;
    XONLINETASK_HANDLE hTask          = NULL;
    XNKID              SessionID      = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
    XNKEY              KeyExchangeKey;
    XONLINE_ATTRIBUTE  Attribs[20];

    Attribs[0].dwAttributeID = X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | X_ATTRIBUTE_DATATYPE_INTEGER | 0x00000000;
    Attribs[0].info.integer.qwValue = 1234;

    Attribs[1].dwAttributeID = X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | X_ATTRIBUTE_DATATYPE_STRING | 0x00000001;
    Attribs[1].info.string.pwszValue = L"MYSTRING111";

    Attribs[2].dwAttributeID = X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | X_ATTRIBUTE_DATATYPE_BLOB | 0x00000002;
    Attribs[2].info.blob.pvValue = (VOID *) "MYBLOB111";
    Attribs[2].info.blob.dwLength = 9;

    Attribs[3].dwAttributeID = X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | X_ATTRIBUTE_DATATYPE_STRING | 0x00000003;
    Attribs[3].info.string.pwszValue = L"MYSTRING222";

    Attribs[4].dwAttributeID = X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | X_ATTRIBUTE_DATATYPE_STRING | 0x00000004;
    Attribs[4].info.string.pwszValue = L"MYSTRING333";

    Attribs[5].dwAttributeID = X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | X_ATTRIBUTE_DATATYPE_BLOB | 0x00000005;
    Attribs[5].info.blob.pvValue = (VOID *) "MYBLOB222";
    Attribs[5].info.blob.dwLength = 9;

    Attribs[6].dwAttributeID = X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | X_ATTRIBUTE_DATATYPE_INTEGER | 0x00000006;
    Attribs[6].info.integer.qwValue = 5678;

    hr = XOnlineMatchSessionCreate( 1, 2, 3, 4, 7, Attribs, NULL, &hTask );
    ASSERT(SUCCEEDED(hr));

    hr = WorkUntilDone(hTask);
    ASSERT(SUCCEEDED(hr));

    hr = XOnlineMatchSessionGetInfo(hTask, &SessionID, &KeyExchangeKey);
    ASSERT(SUCCEEDED(hr));

    XOnlineTaskClose(hTask);

    hr = XOnlineMatchSessionUpdate( SessionID, 1, 2, 3, 4, 7, Attribs, NULL, &hTask );
    ASSERT(SUCCEEDED(hr));

    hr = WorkUntilDone(hTask);
    ASSERT(SUCCEEDED(hr));

    XOnlineTaskClose(hTask);

/*
    XOnlineMatchSessionFindFromID( SessionID, NULL, &hTask );
    
    hr = WorkUntilDone(hTask);
    if (FAILED(hr))
        __asm int 3;

    XOnlineTaskClose(hTask);

    hr = XOnlineMatchSessionDelete( SessionID, NULL, &hTask );
    if (FAILED(hr))
        __asm int 3;

    hr = WorkUntilDone(hCreate);
    if (FAILED(hr))
        __asm int 3;

    XOnlineTaskClose(hTask);
*/

    return hr;
}


HRESULT SearchSession( VOID )
{
    HRESULT              hr              = S_OK;
    PXMATCH_SEARCHRESULT *ppSearchResult = NULL;
    DWORD                dwNumResults    = 0;
    XONLINETASK_HANDLE   hTask           = NULL;
    DWORD                i               = 0;
    XONLINE_ATTRIBUTE    Attribs[20];

    Attribs[0].dwAttributeID = X_ATTRIBUTE_DATATYPE_INTEGER;
    Attribs[0].info.integer.qwValue = 1234;

    Attribs[1].dwAttributeID = X_ATTRIBUTE_DATATYPE_STRING;
    Attribs[1].info.string.pwszValue = L"MYSTRING111";

    Attribs[2].dwAttributeID = X_ATTRIBUTE_DATATYPE_BLOB;
    Attribs[2].info.blob.pvValue = (VOID *) "MYBLOB111";
    Attribs[2].info.blob.dwLength = 9;

    Attribs[3].dwAttributeID = X_ATTRIBUTE_DATATYPE_STRING;
    Attribs[3].info.string.pwszValue = L"MYSTRING222";

    hr = XOnlineMatchSearch( 1, 50, 4, Attribs, 5000, NULL, &hTask );
    ASSERT(SUCCEEDED(hr));

    hr = WorkUntilDone(hTask);
    ASSERT(SUCCEEDED(hr));

    hr = XOnlineMatchSearchGetResults(hTask, &ppSearchResult, &dwNumResults);
    ASSERT(SUCCEEDED(hr));

    for (i = 0; i < dwNumResults; i += 1)
    {
        /*
        hr = XOnlineMatchSearchParse( IN PXMATCH_SEARCHRESULT pSearchResult,
        IN DWORD dwNumSessionAttributes,
        IN PXONLINE_ATTRIBUTE_SPEC pSessionAttributeSpec,
        OUT PVOID pQuerySession
        );
        if (FAILED(hr))
            __asm int 3;
        */
    }

    XOnlineTaskClose(hTask);
    
    return hr;
}


HRESULT WorkUntilDone(XONLINETASK_HANDLE hTask)
{
    HRESULT hr          = S_OK;

    while (1)
    {
        hr = XOnlineTaskContinue(hTask);

        if (hr != XONLINETASK_S_RUNNING)
        {
            ASSERT(SUCCEEDED(hr));

            break;
        }

        if (FAILED(XOnlineTaskContinue(g_hLogon)))
        {
            __asm int 3;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\OnlineTitleUpdate\sources.inc ===
USE_LIBCMT=1
 
SYNCRHONIZE_DRAIN=1

LINKER_FLAGS=$(LINKER_FLAGS) /IGNORE:4049,4217 /MAP

C_DEFINES=$(C_DEFINES) -DXONLINE_BUILD_LIBX

INCLUDES=\
    $(BASEDIR)\public\sdk\inc; \
    $(BASEDIR)\private\inc;\
    $(BASEDIR)\private\inc\crypto;\
    $(BASEDIR)\private\ntos\inc;\
    $(BASEDIR)\private\ntos\xapi\inc;\
    $(BASEDIR)\private\online\kerb;\
    $(BASEDIR)\private\online\util;\
    $(BASEDIR)\private\online;\
    $(BASEDIR)\private\ntos\net;\
    $(BASEDIR)\private\online\test\common;

SOURCES=\
    OnlineTitleUpdate.cpp

TARGETLIBS=\
    $(SDK_LIB_PATH)\xonline$(D).lib \
    $(BASEDIR)\private\online\test\common\obj\i386\testutil$(D).lib \
    $(SDK_LIB_PATH)\xgraphics$(D).lib \
    $(LIBRARY_PATH)\d3d8$(D).lib \
    $(LIBRARY_PATH)\d3dx8$(D).lib
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\offers\xmain.cpp ===
/*++

Copyright (c) Microsoft Corporation

Author:
    Ben Zotto (benzotto), d'apres Keith Lau (keithlau)

Description:
	Dumb Test shell for billing functionality

Module Name:

    xmain.c

--*/

#include <xtl.h>
#include <xonlinep.h>

#include <xdbg.h>
#include <stdio.h>

#include "testutil.h"
#include "testui.h"


//
// Enable this macro if we want to wait for event before pumping
//
//#define WAIT_FOR_EVENT


DWORD					dwPumpCalls = 0;


WCHAR StatusBuffer[2400];


void Initialize()
{
	// do nothing 
}


#define NUM_SERVICES	1
XONLINE_SERVICE			g_rgServices[NUM_SERVICES] =
{
	{ XONLINE_BILLING_OFFERING_SERVICE, S_OK, NULL }
};


//======================== The main function
void __cdecl main()
{
    HRESULT				hr=S_OK;
    DWORD				dwWorkFlags;   

    WSADATA				WsaData;
	DWORD				dwError;

	// test stuff -- garbage values for now.
	
/*


	XNetStartupParams 	xnsp = { sizeof(XNetStartupParams), 
								XNET_STARTUP_BYPASS_SECURITY };
	
    //_asm int 3;

    DebugPrint("Loading XBox network stack...\n");
    dwError = XNetStartup(&xnsp);
    if (dwError != NO_ERROR)
    {
	    DebugPrint("Failed XNetStartup with %d\n", dwError);
        return;
    }

    DebugPrint("Calling WSAStartup...\n");
    if(WSAStartup(0x0101, &WsaData) == SOCKET_ERROR)
    {
        DebugPrint("Error %d returned by WSAStartup\n", GetLastError());
        return;
    }

	// Dump the size of the billing context for info
	DebugPrint("Size of context: %u bytes", 
				sizeof(XONLINE_BILLING_OFFERING_SERVICE));

	// Initialize services
	hr = XOnlineLogonWrapper(g_rgServices, NUM_SERVICES);
	if (FAILED(hr))
	{
        DebugPrint("Cannot Logon (%08x), check c:\\xonline.ini\n", hr);
//        RIP("Failed to initialize services");
        return;
	}
*/
	// Initialize test specific stuff
	Initialize();

	// Initialize graphics stuff
	hr = InitializeGraphics();
	if (FAILED(hr))
	{
        DebugPrint("Cannot initialize graphics (%08x)\n", hr);
 //       RIP("Failed to initialize graphics");
        return;
	}

	// Initialize text font  (be sure the tahoma.tff file is on the XDK box)
	hr = InitializeFont(0xffffffff, 0xff000000, XFONT_OPAQUE);
	if (FAILED(hr))
	{
        DebugPrint("Cannot initialize text (%08x)\n", hr);
//        RIP("Failed to initialize text");
        return;
	}

//	Do a little conversion-tastic price display! HOOWAH!
	XONLINE_PRICE pr;
	WCHAR pricestr[50];
	DWORD cbpricestr = 50;

	BeginNewScene();

	// US$15, in the united states
	pr.dwWholePart = 15;
	pr.dwFractionalPart = 0;
	pr.bCurrencyFormat = 0xDA;
	pr.rgchISOCurrencyCode[0] = L'U';
    pr.rgchISOCurrencyCode[1] = L'S';
    pr.rgchISOCurrencyCode[2] = L'D';

	XOnlineOfferingPriceFormat(&pr, pricestr, &cbpricestr, 0x0);
	wsprintf(StatusBuffer, L"Should be: $15.00. Formatted as: %s", pricestr);
	Xputs(StatusBuffer);		
	
	
	// US$15.26, displayed in Canada
	pr.dwWholePart = 15;
	pr.dwFractionalPart = 26;
	pr.bCurrencyFormat = 0xBE;
	pr.rgchISOCurrencyCode[0] = L'U';
    pr.rgchISOCurrencyCode[1] = L'S';
    pr.rgchISOCurrencyCode[2] = L'D';

	cbpricestr = 50;
	XOnlineOfferingPriceFormat(&pr, pricestr, &cbpricestr, 0x0);
	wsprintf(StatusBuffer, L"Should be: US$ 15.26. Formatted as: %s", pricestr);
	Xputs(StatusBuffer);		
	
	// Sfr, displayed in CH.  SHould be SFr 12,00
	pr.dwWholePart = 12;
	pr.dwFractionalPart = 0;
	pr.bCurrencyFormat = 0x2F;
	pr.rgchISOCurrencyCode[0] = L'C';
    pr.rgchISOCurrencyCode[1] = L'H';
    pr.rgchISOCurrencyCode[2] = L'F';

	cbpricestr = 50;
	XOnlineOfferingPriceFormat(&pr, pricestr, &cbpricestr, 0x0);
	wsprintf(StatusBuffer, L"Should be: SFr 12,00. Formatted as: %s", pricestr);
	Xputs(StatusBuffer);		


	// euros, displayed in france. SHould be 19,00E [euro]
	pr.dwWholePart = 19;
	pr.dwFractionalPart = 0;
	pr.bCurrencyFormat = 0x43;
	pr.rgchISOCurrencyCode[0] = L'E';
    pr.rgchISOCurrencyCode[1] = L'U';
    pr.rgchISOCurrencyCode[2] = L'R';

	cbpricestr = 50;
	XOnlineOfferingPriceFormat(&pr, pricestr, &cbpricestr, XO_CURRENCY_EUR);
	wsprintf(StatusBuffer, L"Should be: 19,00[euro]. Formatted as: %s", pricestr);
	Xputs(StatusBuffer);	


	// yen, displayed in japan(?). SHould be [yen]10000
	pr.dwWholePart = 10000;
	pr.dwFractionalPart = 0;
	pr.bCurrencyFormat = 0x68;
	pr.rgchISOCurrencyCode[0] = L'J';
    pr.rgchISOCurrencyCode[1] = L'P';
    pr.rgchISOCurrencyCode[2] = L'Y';

	cbpricestr = 50;
	XOnlineOfferingPriceFormat(&pr, pricestr, &cbpricestr, XO_CURRENCY_JPY);
	wsprintf(StatusBuffer, L"Should be: [yen]10000. Formatted as: %s", pricestr);
	Xputs(StatusBuffer);	

	// pounds, displayed in gb. SHould be [pounds]32.00
	pr.dwWholePart = 32;
	pr.dwFractionalPart = 0;
	pr.bCurrencyFormat = 0x5A;
	pr.rgchISOCurrencyCode[0] = L'G';
    pr.rgchISOCurrencyCode[1] = L'B';
    pr.rgchISOCurrencyCode[2] = L'P';

	cbpricestr = 50;
	XOnlineOfferingPriceFormat(&pr, pricestr, &cbpricestr, XO_CURRENCY_GBP);
	wsprintf(StatusBuffer, L"Should be: [pounds]32.00. Formatted as: %s", pricestr);
	Xputs(StatusBuffer);	

	// won, displayed in soko. SHould be [won]1500
	pr.dwWholePart = 1500;
	pr.dwFractionalPart =230;
	pr.bCurrencyFormat = 0x78;
	pr.rgchISOCurrencyCode[0] = L'K';
    pr.rgchISOCurrencyCode[1] = L'R';
    pr.rgchISOCurrencyCode[2] = L'W';

	cbpricestr = 50;
	XOnlineOfferingPriceFormat(&pr, pricestr, &cbpricestr, XO_CURRENCY_KRW);
	wsprintf(StatusBuffer, L"Should be: [won]1500. Formatted as: %s", pricestr);
	Xputs(StatusBuffer);
	
	// won, displayed somewhere outside soko with no char. SHould be [won]1500
	pr.dwWholePart = 1500;
	pr.dwFractionalPart =230;
	pr.bCurrencyFormat = 0x78;
	pr.rgchISOCurrencyCode[0] = L'K';
    pr.rgchISOCurrencyCode[1] = L'R';
    pr.rgchISOCurrencyCode[2] = L'W';

	cbpricestr = 50;
	XOnlineOfferingPriceFormat(&pr, pricestr, &cbpricestr, 0);
	wsprintf(StatusBuffer, L"Should be: KRW 1500. Formatted as: %s", pricestr);
	Xputs(StatusBuffer);	


	// totally foreign currency XON, displayed in the US. SHould be XON 14.22
	pr.dwWholePart = 14;
	pr.dwFractionalPart = 22;
	pr.bCurrencyFormat = 0xFE;
	pr.rgchISOCurrencyCode[0] = L'X';
    pr.rgchISOCurrencyCode[1] = L'O';
    pr.rgchISOCurrencyCode[2] = L'N';

	cbpricestr = 50;
	XOnlineOfferingPriceFormat(&pr, pricestr, &cbpricestr, 0x0);
	wsprintf(StatusBuffer, L"Should be: XON 14.22. Formatted as: %s", pricestr);
	Xputs(StatusBuffer);	

	// totally foreign currency XON, displayed in france. SHould be 14,22 XON
	pr.dwWholePart = 14;
	pr.dwFractionalPart = 22;
	pr.bCurrencyFormat = 0xF7;
	pr.rgchISOCurrencyCode[0] = L'X';
    pr.rgchISOCurrencyCode[1] = L'O';
    pr.rgchISOCurrencyCode[2] = L'N';

	cbpricestr = 50;
	XOnlineOfferingPriceFormat(&pr, pricestr, &cbpricestr, 0x0);
	wsprintf(StatusBuffer, L"Should be: 14,22 XON. Formatted as: %s", pricestr);
	Xputs(StatusBuffer);	


	PresentScene();										   








#if 0

	// start by sending the request 

	hr = XOnlineOfferingPurchase( 0, dwOfferingId, NULL, &hTask );
	if (FAILED(hr)) 
	{
		DebugPrint("  Purchase failed (%08x)", hr );
//		RIP("Purchase failed");
		return;
	}

	while (1) 
	{
		if (hTask)
		{
			dwPumpCalls++;
			hr = XOnlineTaskContinue( hTask, GetTickCount()+1 );
			if( hr != XONLINETASK_S_RUNNING )
			{
				// task completed, success?
				if( FAILED(hr) ) 
				{
					//bugger.  this shouldn't fail!
					BeginNewScene();
					wsprintf(StatusBuffer, L"   Purchase failed (%08x) after %u pump calls\r\n",
										   hr, dwPumpCalls );
				
					Xputs(StatusBuffer);		
					PresentScene();

					break;
				}
				
				// otherwise, success!
				
				// close task handle
				BeginNewScene();
				wsprintf(StatusBuffer, L"   Purchase succeeded (%08x) after %u pump call(s)\r\n",
										   hr, dwPumpCalls );
				
				Xputs(StatusBuffer);		
				PresentScene();
				break;
			}
		}
	}

	// we're done
	XOnlineTaskClose( hTask );
	hTask = NULL;

#endif
/*
    // Shutdown WinSock subsystem.
    WSACleanup();

    DebugPrint("Unloading XBox network stack...\n");
    XNetCleanup();
*/
	// Break here
	_asm int 3;

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\OnlineTitleUpdate\Dash\package\symmkey.c ===
// 0x868BC775CB6559265B659611C20FCBBF

const unsigned char rgbSymmetricKey[] = {
	0x86, 0x8B, 0xC7, 0x75, 0xCB, 0x65, 0x59, 0x26,
	0x5B, 0x65, 0x96, 0x11, 0xC2, 0x0F, 0xCB, 0xBF
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\OnlineTitleUpdate\OnlineTitleUpdate.cpp ===
/*++

Copyright (c) Microsoft Corporation

Author:
    Keith Lau (keithlau)

Description:
	Unit test shell for Online Autoupdate

Module Name:

    DVDTitleUpdate.cpp

--*/

#include "xonp.h"
#include "testutil.h"
#include "testui.h"

#ifdef DASH_UPDATE

#include "Dash\package\symmkey.c"

const WCHAR	wszRebootMsg[] = 
			L"The current Dashboard has been successfully updated ONLINE.\n"
			L"Reboot your Xbox into the Dashboard, and if\n"
			L"this worked, you will see a message telling you\n"
			L"that Autoreboot worked for DASH.\n";

#else

#include "Title\package\symmkey.c"

const WCHAR	wszRebootMsg[] = 
			L"The current title has been successfully updated ONLINE.\n"
			L"Reboot your Xbox and run this app again, and if\n"
			L"this worked, you will see a message telling you\n"
			L"that Autoreboot worked for TITLE.\n";

#endif

DWORD					dwPumpCalls = 0;

WCHAR StatusBuffer[2400];

VOID DisplayStatus(
			DWORD				dwTitleId,
			XONLINETASK_HANDLE	hTask
			)
{
	HRESULT			hr;
	ULONGLONG		qwn, qwd;
	DWORD			dwPercentDone;

	hr = XOnlineTitleUpdateGetProgress(hTask, 
		&dwPercentDone, &qwn, &qwd);

	BeginNewScene();

	wsprintf(StatusBuffer,
		L"%u pump calls made\r\n"\
		L"Title ID: %u (%08x)\r\n",
		dwPumpCalls, dwTitleId, dwTitleId);
	Xputs(StatusBuffer);

	wsprintf(StatusBuffer, 
			L"  Autoupdate progress %u percent (%I64u / %I64u)\r\n",
			dwPercentDone, qwn, qwd);
	Xputs(StatusBuffer);				

	PresentScene();
}

#define NUM_SERVICES	1
DWORD			g_rgServices[NUM_SERVICES] =
{
	XONLINE_AUTO_UPDATE_SERVICE
};

//======================== The main function
void __cdecl main()
{
    HRESULT				hr = S_OK;
    DWORD				dwError;
    DWORD				dwTitleId;
    DWORD				dwLastStatusUpdate = 0;
    HANDLE				hEvent = NULL;
	XONLINETASK_HANDLE	hTask = NULL;
    XONLINETASK_HANDLE	hLogon = NULL;
    WCHAR				wszReboot[MAX_PATH];

	XONLINE_STARTUP_PARAMS	xosp = { 0 };

	XNetStartupParams 	xnsp = { sizeof(XNetStartupParams), 
								XNET_STARTUP_BYPASS_SECURITY };

    DebugPrint("Loading XBox network stack...\n");
    dwError = XNetStartup(&xnsp);
    if (dwError != NO_ERROR)
    {
	    DebugPrint("Failed XNetStartup with %d\n", dwError);
        return;
    }

    DebugPrint("Calling XOnlineStartup...\n");
    hr = XOnlineStartup(&xosp);
    if (FAILED(hr))
    {
        DebugPrint("Error %08x returned by XOnlineStartup\n", hr);
        return;
    }

	// Dump the size of the content download context for info
	// DebugPrint("Size of context: %u bytes", sizeof(XONLINETASK_AUTOUPD_ONLINE));

	hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

	// Initialize graphics stuff
	hr = InitializeGraphics();
	if (FAILED(hr))
	{
        DebugPrint("Cannot initialize graphics (%08x)\n", hr);
        RIP("Failed to initialize graphics");
        return;
	}

	// Initialize text font
	hr = InitializeFont(0xffffffff, 0xff000000, XFONT_OPAQUE);
	if (FAILED(hr))
	{
        DebugPrint("Cannot initialize text (%08x)\n", hr);
        RIP("Failed to initialize text");
        return;
	}

#if 0
	// Initialize services
	hr = XOnlineLogonWrapper(g_rgServices, NUM_SERVICES, &hLogon);
	if (FAILED(hr))
	{
        DebugPrint("Cannot Logon (%08x), check c:\\xonline.ini\n", hr);
        RIP("Failed to initialize services");
        return;
	}
#endif	

	DWORD	dwVersion;
	DWORD	cbTitleKey;
	BYTE	rgbTitleKey[XONLINE_KEY_LENGTH];
	
	dwTitleId = XeImageHeader()->Certificate->TitleID;
	dwVersion = XeImageHeader()->Certificate->Version;
	
	cbTitleKey = XONLINE_KEY_LENGTH;
	hr = XoUpdateGetRawTitleKey(dwTitleId, rgbTitleKey, &cbTitleKey);
	if (FAILED(hr))
	if (FAILED(hr))
	{
		_asm int 3;
	}

	// Just kick off the title update
	hr = XOnlineTitleUpdateInternal(
				dwTitleId, dwVersion, rgbTitleKey, hEvent, &hTask);
	if (FAILED(hr))
	{
		_asm int 3;
	}

	dwLastStatusUpdate = GetTickCount();
	while (1)
	{
		hr = XOnlineTaskContinue(hTask);
		if (XONLINETASK_STATUS_AVAILABLE(hr))
		{
			if (FAILED(hr))
			{
				_asm int 3;
			}

			// Branch out here to tell the user to reboot
			goto PromptReboot;
		}
		
		dwPumpCalls++;

		// Display status every x pumps
		if ((GetTickCount() - dwLastStatusUpdate) > 100)
		{
			DisplayStatus(dwTitleId, hTask);
			dwLastStatusUpdate = GetTickCount();
		}
	}

PromptReboot:

	BeginNewScene();

	wcscpy((WCHAR *)wszReboot, (WCHAR *)wszRebootMsg);
	Xputs(wszReboot);

	PresentScene();

	while (1)
		Sleep(1000);

	// Break here
	_asm int 3;

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\presence\simple\test.cpp ===
/***************************************************************************
 *
 *  Copyright (c) Microsoft Corporation.  All rights reserved
 *
 ****************************************************************************/

#include <xtl.h>
#include <xonline.h>
#include <xdbg.h>

HRESULT GamerStuff(PXONLINE_USER pUsers);
HRESULT WorkUntilDone(XONLINETASK_HANDLE hTask);
HRESULT WorkForABit(XONLINETASK_HANDLE hTask, DWORD dwTime);

XONLINETASK_HANDLE g_hLogon;

void __cdecl main()
{
    HRESULT      hr     = S_OK;
    DWORD        cUsers = 0;
    XONLINE_USER Users[XONLINE_MAX_STORED_ONLINE_USERS];

    XInitDevices(0,NULL);

    hr = XOnlineStartup(NULL);
    ASSERT(SUCCEEDED(hr));
    
    hr = XOnlineGetUsers( Users, &cUsers );
    ASSERT(SUCCEEDED(hr));
    ASSERT(cUsers == 4);

    hr = XOnlineNotificationSetUserData( 0, 4, (PBYTE) "ABC", NULL, NULL);
    ASSERT(SUCCEEDED(hr));

    hr = XOnlineNotificationSetUserData( 1, 4, (PBYTE) "XYZ", NULL, NULL);
    ASSERT(SUCCEEDED(hr));

    hr = XOnlineLogon( Users, NULL, 0, NULL, &g_hLogon );
    ASSERT(SUCCEEDED(hr));
 
    do
    {
        hr = XOnlineTaskContinue(g_hLogon);
        if ( hr != XONLINETASK_S_RUNNING )
        {
            if (hr == XONLINE_S_LOGON_CONNECTION_ESTABLISHED)
            {
                break;
            }
            else if (hr == XONLINE_E_LOGON_SERVICE_UNAVAILABLE)
            {
                __asm int 3;
            }
            else if (hr == XONLINE_E_LOGON_UPDATE_REQUIRED)
            {
                __asm int 3;
            }
            else
            {
                __asm int 3;
            }
        }
    } while (1);

    __asm int 3;

    hr = GamerStuff( Users );
    ASSERT(SUCCEEDED(hr));

    hr = XOnlineCleanup();
    ASSERT(SUCCEEDED(hr));

    __asm int 3;
}

HRESULT GamerStuff(PXONLINE_USER pUsers)
{
    HRESULT                     hr              = S_OK;
    DWORD                       i, j            = 0;
    XONLINETASK_HANDLE          hTask           = NULL;
    XONLINETASK_HANDLE          hGamerTask      = NULL;
    XONLINETASK_HANDLE          hMuteTask       = NULL;
    PXONLINE_GAMER              pGamers         = NULL;
    DWORD                       dwNumGamers     = 0;
    PXONLINE_MUTEDUSER          pMutelist       = NULL;
    DWORD                       dwNumMutedUsers = 0;
    XNKID                       SessionID       = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
    XONLINE_ACCEPTED_GAMEINVITE GameInvite;

    pGamers   = (PXONLINE_GAMER)     LocalAlloc(0, MAX_GAMERS * sizeof(XONLINE_GAMER));
    pMutelist = (PXONLINE_MUTEDUSER) LocalAlloc(0, MAX_MUTEDUSERS * sizeof(XONLINE_MUTEDUSER));

    hr = XOnlineGamersStartup( NULL, &hGamerTask );
    ASSERT(SUCCEEDED(hr));

    for (i = 0; i < 4; i += 1)
    {
        hr = XOnlineGamersEnumerate( i, NULL, &hTask );
        ASSERT(SUCCEEDED(hr));

        hr = WorkForABit(hTask, 1000);
        ASSERT(SUCCEEDED(hr));

        XOnlineTaskClose(hTask);

        DWORD dwNumGamers = XOnlineGamersGetLatest( i, MAX_GAMERS, pGamers );

        for (j = 0; j < dwNumGamers; j += 1)
        {
            hr = XOnlineGamersRemove( i, &(pGamers[j]) );
            ASSERT(SUCCEEDED(hr));
        }

        hr = WorkForABit(hGamerTask, 2000);
        ASSERT(SUCCEEDED(hr));
    }

    hr = XOnlineGamersRequest( 0, pUsers[1].xuid );
    ASSERT(SUCCEEDED(hr));

    hr = XOnlineGamersRequest( 0, pUsers[2].xuid );
    ASSERT(SUCCEEDED(hr));

    hr = XOnlineGamersRequest( 0, pUsers[3].xuid );
    ASSERT(SUCCEEDED(hr));

    hr = WorkForABit(hGamerTask, 4000);
    ASSERT(SUCCEEDED(hr));

    hr = XOnlineGamersAnswerRequest( 1, pUsers[0].xuid, XONLINE_REQUEST_YES );
    ASSERT(SUCCEEDED(hr));

    hr = XOnlineGamersAnswerRequest( 2, pUsers[0].xuid, XONLINE_REQUEST_NO );
    ASSERT(SUCCEEDED(hr));

    hr = WorkForABit(hGamerTask, 4000);
    ASSERT(SUCCEEDED(hr));

    hr = XOnlineMutelistStartup( NULL, &hMuteTask );
    ASSERT(SUCCEEDED(hr));

    hr = XOnlineMutelistAdd( 0, pUsers[1].xuid, pUsers[1].name );
    ASSERT(SUCCEEDED(hr));

    hr = XOnlineMutelistAdd( 0, pUsers[2].xuid, pUsers[2].name );
    ASSERT(SUCCEEDED(hr));

    hr = WorkForABit(hMuteTask, 4000);
    ASSERT(SUCCEEDED(hr));

    hr = XOnlineMutelistRemove( 0, pUsers[1].xuid );
    ASSERT(SUCCEEDED(hr));

    hr = WorkForABit(hMuteTask, 4000);
    ASSERT(SUCCEEDED(hr));

    dwNumMutedUsers = XOnlineMutelistGet( 0, MAX_MUTEDUSERS, pMutelist );

    hr = XOnlineNotificationSetState(0, XONLINE_GAMERSTATE_FLAG_ONLINE | XONLINE_GAMERSTATE_FLAG_PLAYING, SessionID, 4, (PBYTE) "DEF");
    ASSERT(SUCCEEDED(hr));

    hr = XOnlineNotificationSetUserData( 0, 4, (PBYTE) "GHI", NULL, &hTask);
    ASSERT(SUCCEEDED(hr));

    hr = WorkUntilDone(hTask);
    ASSERT(SUCCEEDED(hr));

    XOnlineTaskClose(hTask);

    hr = XOnlineGamersEnumerate( 0, NULL, &hTask );
    ASSERT(SUCCEEDED(hr));

    hr = WorkForABit(hTask, 4000);
    ASSERT(SUCCEEDED(hr));

    dwNumGamers = XOnlineGamersGetLatest( 0, MAX_GAMERS, pGamers );

    hr = XOnlineGamersGameInvite( 0, SessionID, 1, &pGamers[0] );
    ASSERT(SUCCEEDED(hr));

    XOnlineTaskClose(hTask);

    hr = WorkForABit(hGamerTask, 4000);
    ASSERT(SUCCEEDED(hr));

    hr = XOnlineGamersEnumerate( 1, NULL, &hTask );
    ASSERT(SUCCEEDED(hr));

    hr = WorkForABit(hTask, 4000);
    ASSERT(SUCCEEDED(hr));

    dwNumGamers = XOnlineGamersGetLatest( 1, MAX_GAMERS, pGamers );

    hr = XOnlineGamersAnswerGameInvite( 1, &pGamers[0], XONLINE_GAMEINVITE_YES);
    ASSERT(SUCCEEDED(hr));

    XOnlineTaskClose(hTask);

    hr = WorkForABit(hGamerTask, 4000);
    ASSERT(SUCCEEDED(hr));

    hr = XOnlineGamersGetAcceptedGameInvite( NULL, &hTask );

    hr = WorkUntilDone(hTask);
    ASSERT(SUCCEEDED(hr));

    hr = XOnlineGamersGetAcceptedGameInviteResult( hTask, &GameInvite );

    XOnlineTaskClose(hTask);

    __asm int 3;

    XOnlineTaskClose(hGamerTask);

    XOnlineTaskClose(hMuteTask);

    LocalFree((HLOCAL) pGamers);

    LocalFree((HLOCAL) pMutelist);

    return hr;
}

HRESULT WorkUntilDone(XONLINETASK_HANDLE hTask)
{
    HRESULT hr = S_OK;

    while (1)
    {
        hr = XOnlineTaskContinue(hTask);

        if (hr != XONLINETASK_S_RUNNING)
        {
            if (FAILED(hr))
                __asm int 3;

            break;
        }

        if (FAILED(XOnlineTaskContinue(g_hLogon)))
        {
            __asm int 3;
        }
    }

    return hr;
}

HRESULT WorkForABit(XONLINETASK_HANDLE hTask, DWORD dwTime)
{
    HRESULT hr        = S_OK;
    DWORD   dwEndTime = GetTickCount() + dwTime;

    while (GetTickCount() < dwEndTime)
    {
        hr = XOnlineTaskContinue(hTask);

        if (hr != XONLINETASK_S_RUNNING && hr != XONLINE_S_NOTIFICATION_UPTODATE)
        {
            if (FAILED(hr))
                __asm int 3;

            break;
        }

        if (FAILED(XOnlineTaskContinue(g_hLogon)))
        {
            __asm int 3;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\rng\rngtestmain.cpp ===
#include <xtl.h>
#include <xdbg.h>
#include <winsockx.h>


#if DBG
extern "C" ULONG XDebugOutLevel;
#endif


//======================== The main function
void __cdecl main()
{
    BYTE randomData[30];
    int i;
    
#if DBG
    XDebugOutLevel = XDBG_EXIT;
#endif

    XNetStartup(NULL);
    
    for (i=0; i<16; ++i)
    {
        XNetRandom( randomData, sizeof(randomData) );

        XDBGTRC("Xonline", ",0x%.2X,0x%.2X,0x%.2X,0x%.2X,0x%.2X,0x%.2X,0x%.2X,0x%.2X,0x%.2X,0x%.2X,0x%.2X,0x%.2X,0x%.2X,0x%.2X,0x%.2X,0x%.2X",
            randomData[0],       randomData[1],        randomData[2],        randomData[3],        randomData[4],        randomData[5],        randomData[6],        randomData[7],
            randomData[8],        randomData[9],        randomData[10],        randomData[11],        randomData[12],        randomData[13],        randomData[14],        randomData[15]
            );
    }
    
    for (i=0; i<16; ++i)
    {
        XNetRandom( randomData, sizeof(randomData) );

        XDBGTRC("Xonline", "\\x%.2X\\x%.2X\\x%.2X\\x%.2X\\x%.2X\\x%.2X\\x%.2X\\x%.2X\\x%.2X\\x%.2X\\x%.2X\\x%.2X\\x%.2X\\x%.2X\\x%.2X\\x%.2X",
            randomData[0],       randomData[1],        randomData[2],        randomData[3],        randomData[4],        randomData[5],        randomData[6],        randomData[7],
            randomData[8],        randomData[9],        randomData[10],        randomData[11],        randomData[12],        randomData[13],        randomData[14],        randomData[15]
            );
    }
    
    XNetCleanup();

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\TitleCache\makefile.inc ===
$(XDK_LIB_PATH)\$(TARGETNAME).lib: $(SDK_LIB_PATH)\$(TARGETNAME).lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\v2app\switcher\switcher.cpp ===
/*++

Copyright (c) Microsoft Corporation

Author:
    Keith Lau (keithlau)

Description:
	Online Dash Bootstrap switcher app

Module Name:

    switcher.cpp

--*/

#include "xonp.h"
#include "testutil.h"
#include "testui.h"

//
// Make an external reference to the switcher logic
//
VOID XoUpdateDashSwitcherLogic();

//======================== The main function
void __cdecl main()
{
	XoUpdateDashSwitcherLogic();

	// Break here
	_asm int 3;

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\UTF8\test.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 ****************************************************************************/

#include <xtl.h>
#include <xdbg.h>
#include <stdio.h>

typedef struct
{
    BYTE  bUnicodeStr[128];
    DWORD cbUnicodeStr;
    BYTE  bUTF8Str[128];
    DWORD cbUTF8Str;
} STRINGS;

#define DW_NUM_STRINGS 4

STRINGS g_Strings[DW_NUM_STRINGS] = {
    {// Japanese
        { 0xb8,0x82,0x53,0x88,0x68,0x30,0xba,0x4e,0x87,0x65,0x20,0x00,0x99,0x51,0x1f,0x77,0x2c,0x00,0x20,0x00,0xfa,0x5e,0xc9,0x7b,0x2c,0x00,0x20,0x00,0x8e,0x7f,0x53,0x88,0x28,0x99,0x2c,0x00,0x20,0x00,0x74,0x6b,0xf2,0x53,0x2c,0x00,0x20,0x00,0x87,0x65,0x66,0x5b,0x00,0x00 },
        26,
        { 0xe8,0x8a,0xb8,0xe8,0xa1,0x93,0xe3,0x81,0xa8,0xe4,0xba,0xba,0xe6,0x96,0x87,0x20,0xe5,0x86,0x99,0xe7,0x9c,0x9f,0x2c,0x20,0xe5,0xbb,0xba,0xe7,0xaf,0x89,0x2c,0x20,0xe7,0xbe,0x8e,0xe8,0xa1,0x93,0xe9,0xa4,0xa8,0x2c,0x20,0xe6,0xad,0xb4,0xe5,0x8f,0xb2,0x2c,0x20,0xe6,0x96,0x87,0xe5,0xad,0xa6,0x00 },
        58
    },
    {// Hebrew
        { 0xd3,0x05,0xd3,0x05,0xd5,0x05,0xd1,0x05,0x20,0x00,0xd9,0x05,0xd0,0x05,0xdc,0x05,0x20,0x00,0xd2,0x05,0xd5,0x05,0xd6,0x05,0x20,0x00,0xd7,0x05,0xdc,0x05,0xd5,0x05,0xe9,0x05,0x20,0x00,0xe8,0x05,0xd7,0x05,0xd0,0x05,0x20,0x00,0xe2,0x05,0xe1,0x05,0xde,0x05,0x00,0x00 },
        26,
        { 0xd7,0x93,0xd7,0x93,0xd7,0x95,0xd7,0x91,0x20,0xd7,0x99,0xd7,0x90,0xd7,0x9c,0x20,0xd7,0x92,0xd7,0x95,0xd7,0x96,0x20,0xd7,0x97,0xd7,0x9c,0xd7,0x95,0xd7,0xa9,0x20,0xd7,0xa8,0xd7,0x97,0xd7,0x90,0x20,0xd7,0xa2,0xd7,0xa1,0xd7,0x9e,0x00 },
        46
    },
    {// Russian
        { 0x1f,0x04,0x30,0x04,0x48,0x04,0x30,0x04,0x20,0x00,0x32,0x04,0x41,0x04,0x35,0x04,0x33,0x04,0x34,0x04,0x30,0x04,0x20,0x00,0x31,0x04,0x4b,0x04,0x3b,0x04,0x20,0x00,0x3e,0x04,0x47,0x04,0x35,0x04,0x3d,0x04,0x4c,0x04,0x20,0x00,0x3d,0x04,0x30,0x04,0x31,0x04,0x3e,0x04,0x36,0x04,0x3d,0x04,0x4b,0x04,0x3c,0x04,0x00,0x00 },
        31,
        { 0xd0,0x9f,0xd0,0xb0,0xd1,0x88,0xd0,0xb0,0x20,0xd0,0xb2,0xd1,0x81,0xd0,0xb5,0xd0,0xb3,0xd0,0xb4,0xd0,0xb0,0x20,0xd0,0xb1,0xd1,0x8b,0xd0,0xbb,0x20,0xd0,0xbe,0xd1,0x87,0xd0,0xb5,0xd0,0xbd,0xd1,0x8c,0x20,0xd0,0xbd,0xd0,0xb0,0xd0,0xb1,0xd0,0xbe,0xd0,0xb6,0xd0,0xbd,0xd1,0x8b,0xd0,0xbc,0x00 },
        57
    },
    {// Chinese
        { 0x2d,0x4e,0xfd,0x56,0x8c,0x5b,0x10,0x62,0xba,0x4e,0x7b,0x7c,0xfa,0x57,0xe0,0x56,0xc4,0x7e,0xfe,0x56,0x00,0x00 },
        11,
        { 0xe4,0xb8,0xad,0xe5,0x9b,0xbd,0xe5,0xae,0x8c,0xe6,0x88,0x90,0xe4,0xba,0xba,0xe7,0xb1,0xbb,0xe5,0x9f,0xba,0xe5,0x9b,0xa0,0xe7,0xbb,0x84,0xe5,0x9b,0xbe,0x00 },
        31
    }
};

void __cdecl main()
{
    DWORD i;
    CHAR chUTF8[1024];
    TCHAR chUnicode[1024];
    CHAR chSmallUTF8[2];
    TCHAR chSmallUnicode[2];
    DWORD dwSize = 0;
    DWORD dwResult = 0;

    __asm int 3;

    for ( i = 0; i < DW_NUM_STRINGS; i += 1 )
    {
        // *********************************************************************
        // Unicode To UTF8
        //

        // Test to see if correct size is returned
        //
        dwSize = WideCharToMultiByte(CP_UTF8, 0, (LPWSTR)g_Strings[i].bUnicodeStr, g_Strings[i].cbUnicodeStr, NULL, 0, NULL, NULL);
        if (dwSize != g_Strings[i].cbUTF8Str)
            __asm int 3;

        // Test to see if conversion is correct
        //
        dwSize = WideCharToMultiByte(CP_UTF8, 0, (LPWSTR)g_Strings[i].bUnicodeStr, g_Strings[i].cbUnicodeStr, chUTF8, sizeof(chUTF8), NULL, NULL );
        if (dwSize != g_Strings[i].cbUTF8Str)
            __asm int 3;

        dwResult = memcmp(g_Strings[i].bUTF8Str, chUTF8, dwSize);
        if (dwResult != 0)
            __asm int 3;

        // Test to see if conversion when specifying -1 for length is correct
        //
        dwSize = WideCharToMultiByte(CP_UTF8, 0, (LPWSTR)g_Strings[i].bUnicodeStr, -1, chUTF8, sizeof(chUTF8), NULL, NULL );
        if (dwSize != g_Strings[i].cbUTF8Str)
            __asm int 3;

        dwResult = memcmp(g_Strings[i].bUTF8Str, chUTF8, dwSize);
        if (dwResult != 0)
            __asm int 3;

        // Test error condition: insufficient buffer
        //
        dwSize = WideCharToMultiByte(CP_UTF8, 0, (LPWSTR)g_Strings[i].bUnicodeStr, -1, chSmallUTF8, sizeof(chSmallUTF8), NULL, NULL );
        if (dwSize != 0 || GetLastError() != ERROR_INSUFFICIENT_BUFFER)
            __asm int 3;

        // *********************************************************************
        // UTF8 To Unicode
        //

        // Test to see if correct size is returned
        //
        dwSize = MultiByteToWideChar(CP_UTF8, 0, (CHAR *)g_Strings[i].bUTF8Str, g_Strings[i].cbUTF8Str, NULL, 0);
        if (dwSize != g_Strings[i].cbUnicodeStr)
            __asm int 3;

        // Test to see if conversion is correct
        //
        dwSize = MultiByteToWideChar(CP_UTF8, 0, (CHAR *)g_Strings[i].bUTF8Str, g_Strings[i].cbUTF8Str, chUnicode, sizeof(chUnicode));
        if (dwSize != g_Strings[i].cbUnicodeStr)
            __asm int 3;

        dwResult = memcmp(g_Strings[i].bUnicodeStr, chUnicode, dwSize * sizeof(TCHAR));
        if (dwResult != 0)
            __asm int 3;

        // Test to see if conversion when specifying -1 for length is correct
        //
        dwSize = MultiByteToWideChar(CP_UTF8, 0, (CHAR *)g_Strings[i].bUTF8Str, -1, chUnicode, sizeof(chUnicode));
        if (dwSize != g_Strings[i].cbUnicodeStr)
            __asm int 3;

        dwResult = memcmp(g_Strings[i].bUnicodeStr, chUnicode, dwSize * sizeof(TCHAR));
        if (dwResult != 0)
            __asm int 3;

        // Test error condition: insufficient buffer
        //
        dwSize = MultiByteToWideChar(CP_UTF8, 0, (CHAR *)g_Strings[i].bUTF8Str, -1, chSmallUnicode, sizeof(chSmallUnicode));
        if (dwSize != 0 || GetLastError() != ERROR_INSUFFICIENT_BUFFER)
            __asm int 3;
    }

    __asm int 3;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\uftest\xmain.cpp ===
/*++

Copyright (c) Microsoft Corporation

Author:
    Keith Lau (keithlau)

Description:
	Unit test shell for asynchronous XOnlineUploadFile

Module Name:

    xmain.c

--*/

#include "xonp.h"
#include "testui.h"
#include "testutil.h"

#define UPLOAD_LOCATION			"/xboxupload/xrl.xbp?loc=/xboxupload/%s"
#define DOWNLOAD_LOCATION		"/xboxupload/%s"
#define LOCAL_PATH				"t:\\test\\%s"
#define REFERENCE_PATH			"t:\\ref\\%s"

#define MAX_UPLOAD_FILES		5

char *rgszFilenames[] =
{
	"makefile", "wincrypt.h", "xmain.c", "xnetacc.c", "asyncxrl.c"
};

DWORD rgdwFileSizes[] = 
{
	247, 576501, 7616, 75968, 56283
};

typedef enum 
{
	STATE_UPLOAD = 0,
	STATE_DOWNLOAD
	
} UF_STATES;

#define NUM_SERVICES	1
DWORD			g_rgServices[NUM_SERVICES] =
{
	XONLINE_USER_ACCOUNT_SERVICE
};

//======================== The main function
void __cdecl main()
{
    HRESULT				hr;

	XONLINETASK_HANDLE	rghTask[] = { NULL, NULL, NULL, NULL, NULL };
	DWORD				rgdwState[] = { STATE_UPLOAD, STATE_UPLOAD, 
								STATE_UPLOAD, STATE_UPLOAD, STATE_UPLOAD };
	CHAR				szPath[MAX_PATH];
	CHAR				szReference[MAX_PATH];
	CHAR				szLocation[MAX_PATH];
	CHAR				szTime1[MAX_TIME_SIZE];
	CHAR				szTime2[MAX_TIME_SIZE];
    DWORD				dwCurTask = 0;
    DWORD				dwIterations = 0;
    DWORD				cbBuffer = 65536;
    DWORD				i;

    WSADATA				WsaData;
	DWORD				dwError;

	DWORD				dwStatus;
	FILETIME			ftTime;
	FILETIME			ftLastModified;

	HANDLE				hEventWorkAvailable = NULL;

	PBYTE				pbBuffer1 = NULL;
	PBYTE				pbBuffer2 = NULL;

	PBYTE				pbUpload = NULL;
	DWORD				cbUpload;
	ULARGE_INTEGER		uliTotalReceived;
	ULARGE_INTEGER		uliContentLength;

	DWORD				dwInitialized;
    XONLINETASK_HANDLE	hLogon;
	
	XONLINE_STARTUP_PARAMS	xosp = { 0 };

	XNetStartupParams	xnsp;

    _asm int 3;

    DebugPrint("Loading XBox network stack...\n");

    ZeroMemory(&xnsp, sizeof(XNetStartupParams));
    xnsp.cfgSizeOfStruct = sizeof(XNetStartupParams);
    xnsp.cfgFlags = XNET_STARTUP_BYPASS_SECURITY;

    dwError = XNetStartup(&xnsp);
    if (dwError != NO_ERROR)
    {
            DebugPrint("Failed XNetStartup with %d\n", dwError);
        return;
    }
	
    DebugPrint("Calling XOnlineStartup...\n");
    hr = XOnlineStartup(&xosp);
    if (FAILED(hr))
    {
        DebugPrint("Error %08x returned by XOnlineStartup\n", hr);
    	_asm int 3;
        return;
    }

	pbBuffer1 = (PBYTE)LocalAlloc(LMEM_FIXED, 2048);
	if (!pbBuffer1)
	{
        DebugPrint("Cannot allocate memory (%u)\n", GetLastError());
        return;
	}
	pbBuffer2 = (PBYTE)LocalAlloc(LMEM_FIXED, 2048);
	if (!pbBuffer2)
	{
        DebugPrint("Cannot allocate memory (%u)\n", GetLastError());
        return;
	}

	// Create the work event
	hEventWorkAvailable = CreateEvent(NULL, FALSE, FALSE, NULL);
	if (hEventWorkAvailable == NULL)
	{
        DebugPrint("Cannot create work event (%u)\n", GetLastError());
        return;
	}

	// Initialize services
	hr = XOnlineLogonWrapper(g_rgServices, NUM_SERVICES, &hLogon);
	if (FAILED(hr))
	{
        DebugPrint("Cannot Logon (%08x), check c:\\xonline.ini\n", hr);
        AssertSz(SUCCEEDED(hr), "Failed to initialize services");
        return;
	}

	// Loop downloading files
	while (1)
	{
		dwIterations++;

		// Start the task if completed
		if (!rghTask[dwCurTask])
		{
			if (rgdwState[dwCurTask] == STATE_UPLOAD)
			{
				// Upload to server
				sprintf(szReference, REFERENCE_PATH, rgszFilenames[dwCurTask]);
				sprintf(szLocation, UPLOAD_LOCATION, rgszFilenames[dwCurTask]);
				
			    hr = XOnlineUploadFile(
			    			XONLINE_USER_ACCOUNT_SERVICE, 
			    			szLocation, NULL, 
			    			&cbBuffer, (PBYTE) NULL, 0,
			    			szReference, 0, hEventWorkAvailable, 
	 		    			&(rghTask[dwCurTask]));

			    DebugPrint("Uploading %s  (hTask = %p)\n", 
			    			szLocation, rghTask[dwCurTask]);
			    
		    	AssertSz(SUCCEEDED(hr), "Cannot start upload");
			    Assert(rghTask[dwCurTask] != NULL);
			}
			else
			{
				// Download the local file
				sprintf(szPath, LOCAL_PATH, rgszFilenames[dwCurTask]);
				sprintf(szLocation, DOWNLOAD_LOCATION, rgszFilenames[dwCurTask]);
				
			    hr = XOnlineDownloadFile(
			    			XONLINE_USER_ACCOUNT_SERVICE, 
			    			szLocation, NULL, 
			    			65536, (PBYTE) NULL, 0,
			    			0, szPath, 0, hEventWorkAvailable, 
	 		    			&(rghTask[dwCurTask]));

			    DebugPrint("Downloading %s  (hTask = %p)\n", 
			    			szLocation, rghTask[dwCurTask]);
			    
		    	AssertSz(SUCCEEDED(hr), "Cannot start download");
			    Assert(rghTask[dwCurTask] != NULL);
			}
		}

		// Continue if required
		if (rghTask[dwCurTask])
		{
			hr = XOnlineTaskContinue(rghTask[dwCurTask]);
			if (XONLINETASK_STATUS_AVAILABLE(hr))
			{
				if (rgdwState[dwCurTask] == STATE_UPLOAD)
				{
					// Upload complete ...
					hr = XOnlineUploadGetResults(rghTask[dwCurTask], 
								&pbUpload, &cbUpload,
								&uliTotalReceived, &uliContentLength,
								&dwStatus, &ftTime);
				    Assert(SUCCEEDED(hr));
				    Assert(cbUpload == uliContentLength.QuadPart);

					i = sizeof(szTime1); 
	    			ConvertFileTimeAsString(szTime1, &i, &ftTime);

				    DebugPrint("[%3u] %s Time: %s  Response: %I64u bytes", 
				    			dwStatus, rgszFilenames[dwCurTask], szTime1, 
				    			uliContentLength.QuadPart);
				    
			    	// Set the next state to download
			    	rgdwState[dwCurTask] = STATE_DOWNLOAD;
				}
				else
				{
					// Download complete ...
					hr = XOnlineDownloadGetResults(rghTask[dwCurTask], 
								NULL, NULL, NULL, NULL, 
								&dwStatus, &ftTime, &ftLastModified);
				    Assert(SUCCEEDED(hr));

					i = sizeof(szTime1); 
	    			ConvertFileTimeAsString(szTime1, &i, &ftTime);
					i = sizeof(szTime2); 
	    			ConvertFileTimeAsString(szTime2, &i, &ftLastModified);

					sprintf(szPath, LOCAL_PATH, rgszFilenames[dwCurTask]);
					sprintf(szReference, REFERENCE_PATH, rgszFilenames[dwCurTask]);

				    DebugPrint("[%3u] %s Time: %s   Last modified: %s", 
				    			dwStatus, szPath, szTime1, szTime2);

					// Make sure reference file and downloaded file match
					hr = HrFileCompare(szPath, szReference, pbBuffer1, pbBuffer2, 2048);

			    	AssertSz(hr == S_OK, "Files dont match");

					if (!DeleteFile(szPath))
						hr = HRESULT_FROM_WIN32(GetLastError());
					
			    	AssertSz(SUCCEEDED(hr), "Cannot truncate/delete file");

			    	// Set the next state back to upload
			    	rgdwState[dwCurTask] = STATE_UPLOAD;
			    }

				// Close the handle
				XOnlineTaskClose(rghTask[dwCurTask]);
				rghTask[dwCurTask] = NULL;
			}
		}

		// Next Task
		dwCurTask++;
		if (dwCurTask >= MAX_UPLOAD_FILES)
			dwCurTask = 0;
	}

    DebugPrint("Unloading XOnline ...\n");
    XOnlineCleanup();

	// Break here
	_asm int 3;

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\TitleCache\main.cpp ===
#include "xonp.h"

#ifdef XONLINE_FEATURE_XBOX
extern class CXo * g_pXo;
#define GetXo() g_pXo
#endif

class CXoTest : public CXOnline
{
public:

    void Test();

};


//////////////////////////////////////////////////////////////////////////////

void __cdecl main()
{
    CXoTest XoTest;
    XoTest.Test();
}


void CXoTest::Test()
{
    DWORD                   i;

    HRESULT                 hr = S_OK;
    HANDLE                  hWorkEvent = NULL;
    DWORD                   dwReason = 0;
    BOOL                    bWait = TRUE;

	XONLINETASK_HANDLE      hTask = NULL;

	XNetStartupParams 	xnsp = { sizeof(XNetStartupParams), 
								XNET_STARTUP_BYPASS_SECURITY };

    hr = XOnlineStartup(NULL);
    if (FAILED(hr))
    {
        goto Error;
    }

    hWorkEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

		
    //_asm int 3;

    DWORD dwError = XNetStartup(&xnsp);
    if (dwError != NO_ERROR)
    {
	    //DebugPrint("Failed XNetStartup with %d\n", dwError);
        return;
    }

	WSADATA				WsaData;
    if(WSAStartup(0x0101, &WsaData) == SOCKET_ERROR)
    {
        //DebugPrint("Error %d returned by WSAStartup\n", GetLastError());
        return;
    }

	if(FAILED(hr))
    {
        TraceSz1(Warning, "Could not allocate task handle...hr = %x \n" , hr);
        goto Error;
    }


	hr = GetXo()->TitleCacheInit(hWorkEvent , &hTask);
                          
    if(FAILED(hr))
    {
        TraceSz1(Warning, "TitleCacheInit FAILED hr = %x \n" , hr);
        goto Error;
    }

	for( int i = 1 ; i < 10 ; i ++)
    {
		DWORD dwTitleID = i;
		XONLINE_TITLEDATA titleData;
		BOOL bFound;

		bWait = TRUE;

		bFound = GetXo()->TitleCacheRetrieve(hTask, dwTitleID, &titleData);

		if( bFound )
		{
			TraceSz1(Warning, "TitleCacheRetrieve Title ID = %d\n" , dwTitleID);
			TraceSz1(Warning, "TitleCacheRetrieve Title Name = %s\n" , titleData.name);
		}
		else
		{
			while (bWait)
			{
				dwReason = WaitForSingleObject(hWorkEvent,0);
				if( WAIT_OBJECT_0 == dwReason )
				{
					hr = XOnlineTaskContinue(hTask);

					if(XONLINETASK_S_RUNNING != hr)
					{
						bWait = FALSE;

						if (FAILED(hr))
						{
							// Handle error condition
							TraceSz1(Warning, "TitleCacheRetrieve FAILED hr = %x\n" , hr);
							goto Error;
						}
						else
						{
							TraceSz1(Warning, "TitleCacheRetrieve Title ID = %d\n" , dwTitleID);
							TraceSz1(Warning, "TitleCacheRetrieve Title Name = %s\n" , titleData.name);
						}
					}
				}
        
			}
		}

    }



    
Error:
    if( NULL != hTask )
    {
        // Close the task handle
        XOnlineTaskClose((XONLINETASK_HANDLE)hTask);
        hTask = NULL;
    }

    TraceSz1(Warning, "Finished! hr = %x\n" , hr);


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\v2app\v2dash\v2dash.cpp ===
/*++

Copyright (c) Microsoft Corporation

Author:
    Keith Lau (keithlau)

Description:
	Dummy version 2.0 Dash XBE to test autoupdate and autoreboot

Module Name:

    v2dash.cpp

--*/

#include "xonp.h"
#include "testutil.h"
#include "testui.h"

#include "xboxp.h"

//======================== The main function
void __cdecl main()
{
    HRESULT		hr = S_OK;
    DWORD		dwError;
    DWORD		dwTitleId;
    WCHAR		szMessage[1024];

	DWORD				dwType;
	LD_LAUNCH_DASHBOARD ld;
	LD_LAUNCH_DASHBOARD ld2;
	PLD_FROM_TITLE_UPDATE pldftu = (PLD_FROM_TITLE_UPDATE)&ld;
	PLD_FROM_DASHBOARD pldfd = (PLD_FROM_DASHBOARD)&ld2;
	
	dwError = XGetLaunchInfo(&dwType, (PLAUNCH_DATA)&ld);
	if (dwError != ERROR_SUCCESS)
	{
		hr = HRESULT_FROM_WIN32(dwError);
		goto Error;
	}

	// Make a reference to xonline.lib so we link in the 
	// reboot logic to make sure we don't screw up in the reboot
	// logic
    dwTitleId = XeImageHeader()->Certificate->TitleID;

	// Initialize graphics stuff
	hr = InitializeGraphics();
	if (FAILED(hr))
	{
        DebugPrint("Cannot initialize graphics (%08x)\n", hr);
        RIP("Failed to initialize graphics");
        return;
	}

	// Initialize text font
	hr = InitializeFont(0xffffffff, 0xff000000, XFONT_OPAQUE);
	if (FAILED(hr))
	{
        DebugPrint("Cannot initialize text (%08x)\n", hr);
        RIP("Failed to initialize text");
        return;
	}

	BeginNewScene();

	wsprintf(szMessage,
			L"\nCongratulations!!!!! AutoReboot works for D A S H!!!\n"
			L"Title ID: %08x (%u)\n"
			L"Current Version: %08x (%u)\n\n\n",
			XeImageHeader()->Certificate->TitleID,
			XeImageHeader()->Certificate->TitleID,
			XeImageHeader()->Certificate->Version,
			XeImageHeader()->Certificate->Version);
	Xputs(szMessage);

	if (dwType == LDT_FROM_TITLE_UPDATE)
	{
		// We were just updated, boot back to the app in d:
		if (FAILED(pldftu->hr))
		{
			wsprintf(szMessage,
					L"\nHowever, autoupdate for D A S H failed (%08x)\n\n"
					L"Rebooting to d:\\default.xbe in f3 seconds ...", pldftu->hr);
			Xputs(szMessage);
		}
		else
		{
			wsprintf(szMessage,
					L"\nAutoupdate for D A S H also succeeded with context (%08x)\n\n"
					L"Rebooting to d:\\default.xbe in 3 seconds ...", 
					pldftu->dwContext);
			Xputs(szMessage);
		}
		
		PresentScene();

		Sleep(3000);

		pldfd->dwContext = pldftu->dwContext;
		XLaunchNewImage("d:\\default.xbe", (PLAUNCH_DATA)&ld2);
	}

	PresentScene();

Wait:
	while (1)
	{
		Sleep(1000);
	}

	// Break here
	_asm int 3;

	return;

Error:	

	BeginNewScene();

	wsprintf(szMessage,
			L"\nAutoReboot for D A S H failed (%08x)\n", hr);
			
	Xputs(szMessage);

	PresentScene();

	goto Wait;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\ufmtest\xmain.cpp ===
/*++

Copyright (c) Microsoft Corporation

Author:
    Keith Lau (keithlau)

Description:
	Unit test shell for asynchronous XOnlineUploadFromMemory

Module Name:

    xmain.c

--*/

#include "xonp.h"
#include "testui.h"
#include "testutil.h"

//
// Enable this macro if we want to wait for event before pumping
//
#define WAIT_FOR_EVENT

#define UPLOAD_LOCATION			"/xboxupload/xrl.xbp?loc=/xboxupload/%s"
#define DOWNLOAD_LOCATION		"/xboxupload/%s"
#define LOCAL_PATH				"t:\\test\\%s"
#define REFERENCE_PATH			"t:\\ref\\%s"

#define MAX_UPLOAD_FILES		1

char *rgszFilenames[] =
{
	"makefile", "xmain.c", "wincrypt.h", "xnetacc.c", "asyncxrl.c"
};

DWORD rgdwFileSizes[] = 
{
	247, 7616, 576501, 75968, 56283
};

typedef enum 
{
	STATE_UPLOAD = 0,
	STATE_DOWNLOAD
	
} UF_STATES;

#define NUM_SERVICES	1
DWORD			g_rgServices[NUM_SERVICES] =
{
	XONLINE_USER_ACCOUNT_SERVICE
};

//======================== The main function
void __cdecl main()
{
    HRESULT				hr;

	XONLINETASK_HANDLE	rghTask[] = { NULL, NULL, NULL, NULL, NULL };
	DWORD				rgdwState[] = { STATE_UPLOAD, STATE_UPLOAD, 
								STATE_UPLOAD, STATE_UPLOAD, STATE_UPLOAD };
	PBYTE				rgpbBuffers[] = { NULL, NULL, NULL, NULL, NULL };
	DWORD				rgcbBuffers[] = { 0, 0, 0, 0, 0 };
	CHAR				szPath[MAX_PATH];
	CHAR				szReference[MAX_PATH];
	CHAR				szLocation[MAX_PATH];
	CHAR				szTime1[MAX_TIME_SIZE];
	CHAR				szTime2[MAX_TIME_SIZE];
    DWORD				dwCurTask = 0;
    DWORD				dwIterations = 0;
    DWORD				cbBuffer = 1024;
    DWORD				i;

    WSADATA				WsaData;
	DWORD				dwError;

	DWORD				dwStatus;
	FILETIME			ftTime;
	FILETIME			ftLastModified;

	HANDLE				hEventWorkAvailable = NULL;

	PBYTE				pbBuffer1 = NULL;
	PBYTE				pbBuffer2 = NULL;

	PBYTE				pbUpload = NULL;
	DWORD				cbUpload;
	ULARGE_INTEGER		uliTotalReceived;
	ULARGE_INTEGER		uliContentLength;

	DWORD				dwInitialized;
    XONLINETASK_HANDLE	hLogon;

	XNetStartupParams	xnsp;

    DebugPrint("Loading XBox network stack...\n");

    ZeroMemory(&xnsp, sizeof(XNetStartupParams));
    xnsp.cfgSizeOfStruct = sizeof(XNetStartupParams);
    xnsp.cfgFlags = XNET_STARTUP_BYPASS_SECURITY;

    dwError = XNetStartup(&xnsp);
    if (dwError != NO_ERROR)
    {
            DebugPrint("Failed XNetStartup with %d\n", dwError);
        return;
    }
	
	XONLINE_STARTUP_PARAMS	xosp = { 0 };
	
    DebugPrint("Calling XOnlineStartup...\n");
    hr = XOnlineStartup(&xosp);
    if (FAILED(hr))
    {
        DebugPrint("Error %08x returned by XOnlineStartup\n", hr);
    	_asm int 3;
        return;
    }

	pbBuffer1 = (PBYTE)LocalAlloc(LMEM_FIXED, 2048);
	if (!pbBuffer1)
	{
        DebugPrint("Cannot allocate memory (%u)\n", GetLastError());
        return;
	}
	pbBuffer2 = (PBYTE)LocalAlloc(LMEM_FIXED, 2048);
	if (!pbBuffer2)
	{
        DebugPrint("Cannot allocate memory (%u)\n", GetLastError());
        return;
	}

	// Create the work event
	hEventWorkAvailable = CreateEvent(NULL, FALSE, FALSE, NULL);
	if (hEventWorkAvailable == NULL)
	{
        DebugPrint("Cannot create work event (%u)\n", GetLastError());
        return;
	}

	// Initialize services
	hr = XOnlineLogonWrapper(g_rgServices, NUM_SERVICES, &hLogon);
	if (FAILED(hr))
	{
        DebugPrint("Cannot Logon (%08x), check c:\\xonline.ini\n", hr);
        AssertSz(SUCCEEDED(hr), "Failed to initialize services");
        return;
	}

	for (i = 0; i < MAX_UPLOAD_FILES; i++)
	{
		sprintf(szReference, REFERENCE_PATH, rgszFilenames[i]);
		if (!SUCCEEDED(HrAllocateAndReadFile(szReference, &(rgpbBuffers[i]), &(rgcbBuffers[i]))))
		{
			AssertSz(FALSE, "Cannot read files");
			return;
		}
	}

	// Loop downloading files
	while (1)
	{
		dwIterations++;

		// Start the task if completed
		if (!rghTask[dwCurTask])
		{
			if (rgdwState[dwCurTask] == STATE_UPLOAD)
			{
				// Upload to server
				sprintf(szReference, REFERENCE_PATH, rgszFilenames[dwCurTask]);
				sprintf(szLocation, UPLOAD_LOCATION, rgszFilenames[dwCurTask]);
				
			    hr = XOnlineUploadFromMemory(
			    			XONLINE_USER_ACCOUNT_SERVICE, 
			    			szLocation, NULL, 
			    			&cbBuffer, (PBYTE) NULL, 0,
			    			rgpbBuffers[dwCurTask], rgcbBuffers[dwCurTask],
			    			0, hEventWorkAvailable, 
	 		    			&(rghTask[dwCurTask]));

			    DebugPrint("Uploading %s  (hTask = %p)\n", 
			    			szLocation, rghTask[dwCurTask]);
			    
		    	AssertSz(SUCCEEDED(hr), "Cannot start upload");
			    Assert(rghTask[dwCurTask] != NULL);
			}
			else
			{
				// Download the local file
				sprintf(szPath, LOCAL_PATH, rgszFilenames[dwCurTask]);
				sprintf(szLocation, DOWNLOAD_LOCATION, rgszFilenames[dwCurTask]);
				
			    hr = XOnlineDownloadFile(
			    			XONLINE_USER_ACCOUNT_SERVICE, 
			    			szLocation, NULL, 
			    			65536, (PBYTE) NULL, 0,
			    			0, szPath, 0, hEventWorkAvailable, 
	 		    			&(rghTask[dwCurTask]));

			    DebugPrint("Downloading %s  (hTask = %p)\n", 
			    			szLocation, rghTask[dwCurTask]);
			    
		    	AssertSz(SUCCEEDED(hr), "Cannot start download");
			    Assert(rghTask[dwCurTask] != NULL);
			}
		}

		// Continue if required
		if (rghTask[dwCurTask])
		{
#ifdef WAIT_FOR_EVENT
			if (WaitForSingleObject(hEventWorkAvailable, INFINITE) != WAIT_OBJECT_0)
			{
				// Wha?
				AssertSz(FALSE, "Failed to wait for event?");
			}
#endif

			hr = XOnlineTaskContinue(rghTask[dwCurTask]);
			if (XONLINETASK_STATUS_AVAILABLE(hr))
			{
				if (rgdwState[dwCurTask] == STATE_UPLOAD)
				{
					// Upload complete ...
					hr = XOnlineUploadGetResults(rghTask[dwCurTask], 
								&pbUpload, &cbUpload,
								&uliTotalReceived, &uliContentLength,
								&dwStatus, &ftTime);
				    Assert(SUCCEEDED(hr));
				    Assert(cbUpload == uliContentLength.QuadPart);

					i = sizeof(szTime1); 
	    			ConvertFileTimeAsString(szTime1, &i, &ftTime);

				    DebugPrint("[%3u] %s Time: %s  Response: %I64u bytes", 
				    			dwStatus, rgszFilenames[dwCurTask], szTime1, 
				    			uliContentLength.QuadPart);
				    
			    	// Set the next state to download
			    	rgdwState[dwCurTask] = STATE_DOWNLOAD;
				}
				else
				{
					// Download complete ...
					hr = XOnlineDownloadGetResults(rghTask[dwCurTask], 
								NULL, NULL, NULL, NULL,
								&dwStatus, &ftTime, &ftLastModified);
				    Assert(SUCCEEDED(hr));

					i = sizeof(szTime1); 
	    			ConvertFileTimeAsString(szTime1, &i, &ftTime);
					i = sizeof(szTime2); 
	    			ConvertFileTimeAsString(szTime2, &i, &ftLastModified);

					sprintf(szPath, LOCAL_PATH, rgszFilenames[dwCurTask]);
					sprintf(szReference, REFERENCE_PATH, rgszFilenames[dwCurTask]);

				    DebugPrint("[%3u] %s Time: %s   Last modified: %s", 
				    			dwStatus, szPath, szTime1, szTime2);

					// Make sure reference file and downloaded file match
					hr = HrFileCompare(szPath, szReference, pbBuffer1, pbBuffer2, 2048);

			    	AssertSz(hr == S_OK, "Files dont match");

					if (!DeleteFile(szPath))
						hr = HRESULT_FROM_WIN32(GetLastError());
					
			    	AssertSz(SUCCEEDED(hr), "Cannot truncate/delete file");

			    	// Set the next state back to upload
			    	rgdwState[dwCurTask] = STATE_UPLOAD;
			    }

				// Close the handle
				XOnlineTaskClose(rghTask[dwCurTask]);
				rghTask[dwCurTask] = NULL;
			}
		}

		// Next Task
		dwCurTask++;
		if (dwCurTask >= MAX_UPLOAD_FILES)
			dwCurTask = 0;
	}

    DebugPrint("Unloading XOnline ...\n");
    XOnlineCleanup();

	// Break here
	_asm int 3;

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\xkdctest\accounts.cpp ===
#include "xkdctest.h"
#include <stdio.h>
#include <stdlib.h>
#include "accounts.h"


ULONGLONG HexStrToQW(IN char *szHex)
{
    ULONGLONG qw = 0;

    while (*szHex)
    {
        BYTE b;
        if (FAILED(HexCharToByte(szHex[0], &b)))
        {
            return 0;
        }
        qw = (qw << 4) + b;

        szHex++;
    }

    return qw;
}


HRESULT KeyStrToKey(
    IN char *szKey, 
    IN INT nKeyLength, 
    OUT BYTE *key)
{
    INT cStrKeyLen = strlen(szKey);
    if (cStrKeyLen != nKeyLength * 2)
    {
        return E_FAIL;
    }

    for (INT i = 0; i < XONLINE_KEY_LENGTH; i++)
    {
        if (HexPairToByte(szKey, &key[i]) != S_OK)
        {
            return E_FAIL;
        }
        szKey += 2;
    }

    return S_OK;
}


HRESULT MakeAccountWithPassword(
    IN XONLINEP_USER *pUser, 
    IN ULONGLONG id, 
    IN char *szName, 
    IN char *szKingdom, 
    IN char *szDomain,
    IN char *szRealm,
    IN char *szPassword)
{
    BYTE bKey[XONLINE_KEY_LENGTH];

    if (KerbPasswordToKey(szPassword, bKey))
    {
        return MakeAccountWithKey(pUser, id, szName, szKingdom, szDomain, szRealm, bKey);
    }
    else
    {
        return E_FAIL;
    }
}


HRESULT MakeAccountWithKey(
    IN XONLINEP_USER *pUser, 
    IN ULONGLONG id, 
    IN char *szName, 
    IN char *szKingdom, 
    IN char *szDomain,
    IN char *szRealm,
    IN BYTE *bKey)
{
    memset(pUser, 0, sizeof(XONLINEP_USER));

    pUser->xuid.qwUserID = id;
    pUser->xuid.dwUserFlags = 0;
    strncpy(pUser->name, szName, XONLINE_NAME_SIZE);
    strncpy(pUser->kingdom, szKingdom, XONLINE_KINGDOM_SIZE);
    strncpy(pUser->domain, szDomain, XONLINE_USERDOMAIN_SIZE);
    strncpy(pUser->realm, szRealm, XONLINE_REALM_NAME_SIZE);
    memset(pUser->pin, 0, 4);
    memcpy(pUser->key, bKey, XONLINE_KEY_LENGTH);

    return S_OK;
}

HRESULT MakeAccountWithHexKey(
    IN XONLINEP_USER *pUser, 
    IN ULONGLONG id, 
    IN char *szName, 
    IN char *szKingdom, 
    IN char *szDomain,
    IN char *szRealm,
    IN char *szKey)
{
    HRESULT hr = S_OK;

    BYTE bKey[XONLINE_KEY_LENGTH];

    if (KeyStrToKey(szKey, XONLINE_KEY_LENGTH, bKey) == S_OK)
    {
        return hr = MakeAccountWithKey(pUser, id, szName, szKingdom, szDomain, szRealm, bKey);
    }
    else
    {
        return E_FAIL;
    }
}


// Returns the new position of szList
void GetCommaListItem(char **szList, char *szItem, INT nMax)
{
    while (*szList && **szList == ' ') (*szList)++;
    if (**szList == '"') (*szList)++;

    while (**szList && **szList != ',' && nMax > 0)
    {
        *szItem = **szList;
        szItem++;
        (*szList)++;
        nMax--;
    }

    while (**szList && **szList != ',')
    {
        (*szList)++;
    }

    (*szList)++;

    while (*(szItem - 1) == ' ') szItem--;
    if (*(szItem - 1) == '"') szItem--;

    *szItem = 0;
}


HRESULT MakeAccountFromString(
    char *szAccount, 
    XONLINEP_USER *Account)
{
    HRESULT hr = E_FAIL;
    
    ULONGLONG qwUserID;
    char szPUID[33];
    char szName[XONLINE_NAME_SIZE+1];
    char szKingdom[XONLINE_KINGDOM_SIZE+1];
    char szDomain[XONLINE_USERDOMAIN_SIZE+1];
    char szRealm[XONLINE_REALM_NAME_SIZE+1];
    char szKey[XONLINE_KEY_LENGTH*2+3];

    GetCommaListItem(&szAccount, szPUID, 32);
    qwUserID = HexStrToQW(szPUID);
    GetCommaListItem(&szAccount, szName, XONLINE_NAME_SIZE);
    GetCommaListItem(&szAccount, szKingdom, XONLINE_KINGDOM_SIZE);
    GetCommaListItem(&szAccount, szDomain, XONLINE_USERDOMAIN_SIZE);
    GetCommaListItem(&szAccount, szRealm, XONLINE_REALM_NAME_SIZE);
    GetCommaListItem(&szAccount, szKey, XONLINE_KEY_LENGTH*2+2);

    if (szKey[0] == '0' && (szKey[1] == 'x' || szKey[1] == 'X'))
    {
        return MakeAccountWithHexKey(Account, qwUserID, szName, szKingdom, szDomain, szRealm, szKey+2);
    }
    else
    {
        return MakeAccountWithPassword(Account, qwUserID, szName, szKingdom, szDomain, szRealm, szKey);
    }
}

HRESULT HashAndPrintKeyHex(
    IN char *szKey)
{
    BYTE bHashedKey[16];

    INT err = KerbPasswordToKey(szKey, bHashedKey);
    
    for (INT i = 0; i < 16; i++ )
    {
        printf("%2.2X", bHashedKey[i]);
    }

    return err == 0 ? S_OK : E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\xkdctest\accounts.h ===
#ifndef ACCOUNTS_H
#define ACCOUNTS_H

#include "xkdctest.h"


HRESULT MakeAccountWithPassword(
    IN XONLINEP_USER *pUser, 
    IN ULONGLONG id, 
    IN char *szName, 
    IN char *szKingdom, 
    IN char *szDomain,
    IN char *szRealm,
    IN char *szPassword);

HRESULT MakeAccountWithKey(
    IN XONLINEP_USER *pUser, 
    IN ULONGLONG id, 
    IN char *szName, 
    IN char *szKingdom, 
    IN char *szDomain,
    IN char *szRealm,
    IN BYTE *bKey);

HRESULT MakeAccountWithHexKey(
    IN XONLINEP_USER *pUser, 
    IN ULONGLONG id, 
    IN char *szName, 
    IN char *szKingdom, 
    IN char *szDomain,
    IN char *szRealm,
    IN char *szKey);

HRESULT MakeAccountFromString(
    char *szAccount, 
    XONLINEP_USER *Account);

HRESULT HashAndPrintKeyHex(
    IN char *szKey);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\xkdctest\config.cpp ===
#include "xkdctest.h"
#include <stdlib.h>
#include "config.h"


Config::Config()
{
    m_cfgChain = NULL;
    m_szFileName = NULL;
}


Config::~Config()
{
    delete m_szFileName;

    m_strings.DeleteAll();
}


HRESULT Config::initialize(char *szFileName)
{
    HRESULT hr = E_FAIL;
    
    char *szT = NULL;
    if (strchr(szFileName, '\\') == NULL)
    {
        szT = new char[strlen(szFileName) + 3];
        szT[0] = '.';
        szT[1] = '\\';
        strcpy(szT+2, szFileName);
    }
    else
    {
        szT = szFileName;
    }

    FILE *pfileT = NULL;
    if(pfileT = fopen(szT, "r"))
    {
        fclose(pfileT);

        m_szFileName = new char[strlen(szT) + 1];

        if (!m_szFileName)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            strcpy(m_szFileName, szT);
            hr = S_OK;
        }
    }

    if (szT != szFileName)
    {
        delete szT;
    }

    return hr;
}


char *Config::copyTrim(char *sz)
{
    INT i = 0;
    INT j = 0;
    char *szTrimmed = new char[strlen(sz)+1];
    if (!szTrimmed)
        return NULL;
    
    while (sz[i])
    {
        if (sz[i] != ' ')
        {
            szTrimmed[j] = sz[i];

            j++;
        }
        i++;
    }
    szTrimmed[j] = 0;
    return szTrimmed;
}


char *Config::StrDupNoComments(char *sz)
{
    char *szDuped = new char[strlen(sz)+1];

    char *szT = szDuped;

    while (*sz && *sz != '#')
    {
        *szT = *sz;
        szT++;
        sz++;
    }
    
    *szT = 0;

    return szDuped;
}


void Config::getSections(Vector<char*> *vctSections)
{
    const IN nBuf = 4096;
    char szBuf[nBuf];
    char *szBufT = szBuf;

    DWORD dwResult = GetPrivateProfileStringA(NULL, NULL, "", szBufT, nBuf, m_szFileName);

    INT i = 0;
    while(szBufT[i])
    {
        char *szT = StrDupNoComments(szBufT);

        if (strlen(szT))
        {
            m_strings.Add(szT);
            vctSections->Add(szT);
        }

        szBufT += strlen(szBufT) + 1;
    }
}


void Config::getEntries(char *szSection, Vector<char*> *vctKeys)
{
    const IN nBuf = 4096;
    char szBuf[nBuf];
    char *szBufT = szBuf;

    DWORD dwResult = GetPrivateProfileStringA(szSection, NULL, "", szBufT, nBuf, m_szFileName);

    INT i = 0;
    while(szBufT[i])
    {
        char *szT = StrDupNoComments(szBufT);

        if (strlen(szT))
        {
            m_strings.Add(szT);
            vctKeys->Add(szT);
        }

        szBufT += strlen(szBufT) + 1;
    }
}


char *Config::getStrDef(char *szSection, char *szKey, char *szDefault)
{
    if (szSection == NULL || szKey == NULL)
    {
        return NULL;
    }

    char *szForceDefault = szDefault ? szDefault : "DeFaUlT";

    const INT nBuf = 256;
    char szBuf[nBuf];

    DWORD dwResult = GetPrivateProfileStringA(szSection, szKey, szForceDefault, szBuf, nBuf, m_szFileName);

    char *szT = NULL;
    
    if (strcmp(szBuf, "DeFaUlT"))
    {
        szT = StrDupNoComments(szBuf);

        m_strings.Add(szT);
    }

    if (szT || !m_cfgChain)
    {
        return szT;
    }
    else
    {
        return m_cfgChain->getStrDef(szSection, szKey, szDefault);
    }
}


BOOL Config::getBool(char *szSection, char *szKey)
{
    BOOL fResult = FALSE;

    char *sz = getStr(szSection, szKey);
    if (sz)
    {
        _strlwr(sz);
        fResult = strcmp(sz, "y") == 0 || strcmp(sz, "yes") == 0 || strcmp(sz, "1") == 0 || strcmp(sz, "true") == 0 || strcmp(sz, "yep") == 0;
    }

    return fResult;
}


INT Config::getInt(char *szSection, char *szKey)
{
    INT iResult = 0;

    char *sz = getStr(szSection, szKey);
    if (sz)
    {
        iResult = atoi(sz);
    }

    return iResult;
}


float Config::getFloat(char *szSection, char *szKey)
{
    float dResult = 0;

    char *sz = getStr(szSection, szKey);
    if (sz)
    {
        dResult = (float)atof(sz);
    }

    return dResult;
}


DWORD Config::getIP(char *szSection, char *szKey)
{
    DWORD dwIP = 0;

    char *szValue = getStrListItem(szSection, szKey, 0);
    if (szValue)
    {
        dwIP = ToIP(szValue);
    }

    if (!dwIP)
    {
        TestMsg(XKTVerbose_Status, "The specified %s IP address is invalid.\n", szKey);
    }

    return dwIP;
}


USHORT Config::getPort(char *szSection, char *szKey)
{
    USHORT nPort = (USHORT)getIntListItem(szSection, szKey, 1);

    if (nPort == 0)
    {
        return 88;
    }

    return nPort;
}


INT Config::countItems(char *szList)
{
    INT cItems = 0;

    char *szT = szList;
    BOOL fFoundItem = FALSE;
    while(szT[0])
    {
        if (szT[0] == ',')
        {
            fFoundItem = FALSE;
        }
        else if (!fFoundItem && szT[0] != ' ')
        {
            cItems++;
            fFoundItem = TRUE;
        }
        szT++;
    }

    return cItems;
}


BOOL Config::getIntList(char *szSection, char *szKey, INT **rgiItems, INT &cItems)
{
    *rgiItems = NULL;

    char *sz = getStr(szSection, szKey);

    cItems = 0;
    if (sz)
    {
        cItems = countItems(sz);

        (*rgiItems) = new INT[cItems];
    
        for (INT i = 0; i < cItems; i++)
        {
            (*rgiItems)[i] = atoi(sz);
            sz = strchr(sz, ',');
            if (sz)
            {
                sz++;
                if (sz[0] == ' ')
                {
                    sz++;
                }
            }
        }
    }
    else
    {
        return FALSE;
    }

    return TRUE;
}


BOOL Config::getStrList(char *szSection, char *szKey, char ***rgszItems, INT &cItems)
{
    *rgszItems = NULL;

    char *sz = getStr(szSection, szKey);

    cItems = 0;
    if (sz)
    {
        cItems = countItems(sz);

        *rgszItems = new char*[cItems];
    
        char *szT = sz;
        while (*szT)
        {
            if (*szT == ',')
            {
                *szT = 0;
            }
            szT++;
        }

        for (INT i = 0; i < cItems; i++)
        {
            (*rgszItems)[i] = copyTrim(sz);
            m_strings.Add((*rgszItems)[i]);
            sz += strlen(sz) + 1;
        }
    }
    else
    {
        return FALSE;
    }

    return TRUE;
}


INT Config::getBoolListItem(char *szSection, char *szKey, INT nWhich)
{
    BOOL fResult = FALSE;

    char *sz = getStrListItem(szSection, szKey, nWhich);
    if (sz)
    {
        _strlwr(sz);
        fResult = strcmp(sz, "y") == 0 || strcmp(sz, "yes") == 0 || strcmp(sz, "1") == 0 || strcmp(sz, "true") == 0 || strcmp(sz, "yep") == 0;
    }

    return fResult;
}


INT Config::getIntListItem(char *szSection, char *szKey, INT nWhich)
{
    INT iResult = 0;

    char *sz = getStrListItem(szSection, szKey, nWhich);
    if (sz)
    {
        iResult = atoi(sz);
    }

    return iResult;
}


char *Config::getStrListItem(char *szSection, char *szKey, INT nWhich)
{
    char *szList = getStr(szSection, szKey);

    if (!szList)
    {
        return NULL;
    }

    while (szList && *szList && nWhich != 0)
    {
        if (*szList == ',')
        {
            if (nWhich-- == 0)
            {
                szList++;
                break;
            }
        }
        szList++;
    }

    char *szNew = NULL;

    if (*szList)
    {
        while (*szList && *szList == ' ') szList++;
        if (*szList == '"') szList++;

        // This often gives us more space than we need but it's simpler
        szNew = new char[strlen(szList) + 1];
        char *szT = szNew;

        while (*szList && *szList != ',')
        {
            *szT = *szList;
            szList++;
            szT++;
        }
        szT--;

        while (szT != szNew && *szT == ' ') szT--;
        if (*szT == '"') szT--;

        *szT++;
        *szT = 0;

        m_strings.Add(szNew);
    }

    return szNew;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\xkdctest\kerberrorcompare.h ===
#ifndef KERBERRORCOMPARE_H
#define KERBERRORCOMPARE_H

#include "xkdctest.h"


#define NUMERRORS 21
#define ERRORLENGTH 32

class KerbErrorCompare
{
private:
    static char *m_szErrorNames[NUMERRORS];
    static NTSTATUS m_Errors[NUMERRORS];

public:
    static INT GetErrorValue(IN char *szErrorName)
    {
        for (INT i = 0; i < NUMERRORS; i++)
        {
            if (!_stricmp(szErrorName, m_szErrorNames[i]))
            {
                break;
            }
        }

        if (i == NUMERRORS)
        {
            return -1;
        }

        return m_Errors[i];
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\v2app\v2title\v2title.cpp ===
/*++

Copyright (c) Microsoft Corporation

Author:
    Keith Lau (keithlau)

Description:
	Dummy version 2.0 XBE to test autoupdate and autoreboot

Module Name:

    v2title.cpp

--*/

#include "xonp.h"
#include "testutil.h"
#include "testui.h"

//======================== The main function
void __cdecl main()
{
    HRESULT		hr = S_OK;
    DWORD		dwTitleId;
    WCHAR		szMessage[1024];

	// Make a reference to xonline.lib so we link in the 
	// reboot logic to make sure we don't screw up in the reboot
	// logic
    dwTitleId = XeImageHeader()->Certificate->TitleID;

	// Initialize graphics stuff
	hr = InitializeGraphics();
	if (FAILED(hr))
	{
        DebugPrint("Cannot initialize graphics (%08x)\n", hr);
        RIP("Failed to initialize graphics");
        return;
	}

	// Initialize text font
	hr = InitializeFont(0xffffffff, 0xff000000, XFONT_OPAQUE);
	if (FAILED(hr))
	{
        DebugPrint("Cannot initialize text (%08x)\n", hr);
        RIP("Failed to initialize text");
        return;
	}

	BeginNewScene();

	wsprintf(szMessage,
			L"\nCongratulations!!!!! AutoReboot works for T I T L E S!!!\n"
			L"Title ID: %08x (%u)\n"
			L"Current Version: %08x (%u)\n",
			XeImageHeader()->Certificate->TitleID,
			XeImageHeader()->Certificate->TitleID,
			XeImageHeader()->Certificate->Version,
			XeImageHeader()->Certificate->Version);
			
	Xputs(szMessage);

	PresentScene();

	while (1)
	{
		Sleep(1000);
	}

	// Break here
	_asm int 3;

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\xkdctest\dlist.h ===
#ifndef DLIST_H
#define DLIST_H


// Hungarian: dlst
template<class a> class DList {
private:
    struct Node {a data; Node *pPrev; Node *pNext;};
    Node *m_pnodHead;
    Node *m_pnodTail;
    Node *m_pnodCur;

public:
    DList()
    {
        m_pnodHead = NULL;
        m_pnodTail = NULL;
        m_pnodCur = NULL;
    }
    
    ~DList()
    {
        while (m_pnodHead)
        {
            Node *pnodNext = m_pnodHead->pNext;
            delete m_pnodHead;
            m_pnodHead = pnodNext;
        }
    }

    BOOL PushFront(const a &item)
    {
        Node *pnodNew = new Node;
        if (!pnodNew) return FALSE;
        pnodNew.data = a;
        pnodNew->pPrev = NULL;
        pnodNew->pNext = m_pnodHead;
        if (m_pnodHead) m_pnodHead->pPrev = pnodNew;
        m_pnodHead = pnodNew;
        if (!m_pnodTail) m_pnodTail = pnodNew;
        return TRUE;
    }

    BOOL PushBack(const a &data)
    {
        Node *pnodNew = new Node;
        if (!pnodNew) return FALSE;
        pnodNew->data = data;
        pnodNew->pPrev = m_pnodTail;
        pnodNew->pNext = NULL;
        if (m_pnodTail) m_pnodTail->pNext = pnodNew;
        m_pnodTail = pnodNew;
        if (!m_pnodHead) m_pnodHead = pnodNew;
        return TRUE;
    }

    BOOL PopFront(a &data)
    {
        if (m_pnodHead)
        {
            Node *pnodT = m_pnodHead;
            data = m_pnodHead->data;
            m_pnodHead = m_pnodHead->pNext;
            if (m_pnodHead) m_pnodHead->pPrev = NULL;
            if (m_pnodTail == pnodT) m_pnodTail = NULL;
            delete pnodT;
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }

    BOOL PopBack(a &data)
    {
        if (m_pnodTail)
        {
            Node *pnodT = m_pnodTail;
            a data = m_pnodTail.data;
            m_pnodTail = m_pnodHead->pPrev;
            if (m_pnodTail) m_pnodTail->pNext = NULL;
            if (m_pnodHead == pnodT) m_pnodHead = NULL;
            delete pnodT;
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }

    void CurReset()
    {
        m_pnodCur = m_pnodHead;
    }

    BOOL CurIsAtEnd()
    {
        if (m_pnodCur == NULL)
        {
            return TRUE;
        }
        return FALSE;
    }

    BOOL CurNext()
    {
        if (m_pnodCur)
        {
            m_pnodCur = m_pnodCur->pNext;
            return TRUE;
        }
        return FALSE;
    }

    BOOL CurPrev()
    {
        if (m_pnodCur)
        {
            m_pnodCur = m_pnodCur->pPrev;
            return TRUE;
        }
        return FALSE;
    }

    BOOL CurGetData(a &data)
    {
        if (m_pnodCur)
        {
            data = m_pnodCur->data;
            return TRUE;
        }
        return FALSE;
    }

    BOOL CurRemove()
    {
        if (!m_pnodCur)
        {
            return FALSE;
        }
        else if (m_pnodCur == m_pnodHead && m_pnodCur == m_pnodTail)
        {
            delete m_pnodCur;
            m_pnodCur = NULL;
            m_pnodHead = NULL;
            m_pnodTail = NULL;
        }
        else
        {
            Node *pnodT = m_pnodCur->pNext;

            if (m_pnodCur == m_pnodHead)
            {
                m_pnodHead = m_pnodCur->pNext;
                m_pnodHead->pPrev = NULL;
            }
            else if (m_pnodCur == m_pnodTail)
            {
                m_pnodTail = m_pnodCur->pPrev;
                m_pnodTail->pNext = NULL;
            }
            else
            {
                m_pnodCur->pNext->pPrev = m_pnodCur->pPrev;
                m_pnodCur->pPrev->pNext = m_pnodCur->pNext;
            }

            delete m_pnodCur;
            m_pnodCur = pnodT;
        }

        return TRUE;
    }

    BOOL DeleteAll()
    {
        BOOL f = TRUE;

        CurReset();
        while (!CurIsAtEnd())
        {
            f = CurRemove();
            if (!f)
            {
                break;
            }
        }

        Assert(m_pnodHead == NULL);
        Assert(m_pnodTail == NULL);
        Assert(m_pnodCur == NULL);

        return f;
    }

    DList(DList &);
    DList &operator=(const DList &v);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\xkdctest\kerberrorcompare.cpp ===
#include "xkdctest.h"
#include "kerberrorcompare.h" 


char *KerbErrorCompare::m_szErrorNames[] = {
    "STATUS_SUCCESS", //KDC_ERR_NONE
    "STATUS_ACCOUNT_DISABLED", //KDC_ERR_CLIENT_REVOKED
    "STATUS_PASSWORD_EXPIRED", //KDC_ERR_KEY_EXPIRED
    "STATUS_INSUFFICIENT_RESOURCES", //KRB_ERR_GENERIC
    "STATUS_TIME_DIFFERENCE_AT_DC", //KRB_AP_ERR_SKEW
    "STATUS_ACCOUNT_RESTRICTION", //KDC_ERR_POLICY
    "STATUS_NO_SUCH_USER", //KDC_ERR_C_PRINCIPAL_UNKNOWN
    "STATUS_NO_TRUST_SAM_ACCOUNT", //KDC_ERR_S_PRINCIPAL_UNKNOWN
    "STATUS_WRONG_PASSWORD", //KDC_ERR_PREAUTH_FAILED, KRB_AP_ERR_MODIFIED
    "STATUS_INVALID_BUFFER_SIZE", //KRB_ERR_RESPONSE_TOO_BIG
    "STATUS_NOT_SUPPORTED", //KDC_ERR_PADATA_TYPE_NOSUPP
    "SEC_E_WRONG_PRINCIPAL", //KRB_AP_ERR_NOT_US
    "STATUS_NO_LOGON_SERVERS", //KDC_ERR_SVC_UNAVAILABLE
    "STATUS_INVALID_PARAMETER", //KDC_ERR_WRONG_REALM
    "CRYPT_E_REVOKED", //KDC_ERR_REVOKED_CERTIFICATE
    "CRYPT_E_NO_REVOCATION_CHECK", //KDC_ERR_REVOCATION_STATUS_UNKNOWN
    "CRYPT_E_REVOCATION_OFFLINE", //KDC_ERR_REVOCATION_STATUS_UNAVAILABLE
    "STATUS_OBJECT_TYPE_MISMATCH", //KDC_ERR_CLIENT_NAME_MISMATCH
    "STATUS_LOGON_FAILURE", //Generic
    "STATUS_ACCOUNT_RESTRICTION", // KDC_ERR_POLICY
    "XONLINE_E_LOGON_XBOX_ACCOUNT_INVALID",
};

NTSTATUS KerbErrorCompare::m_Errors[] = {
    0x00000000L, 
    0xC0000072L, 
    0xC0000071L, 
    0xC000009AL, 
    0xC0000133L, 
    0xC000006EL, 
    0xC0000064L, 
    0xC000018BL, 
    0xC000006AL, 
    0xC0000206L, 
    0xC00000BBL, 
    0x80090322L, 
    0xC000005EL, 
    0xC000000DL, 
    0x80092010L, 
    0x80092012L, 
    0x80092013L, 
    0xC0000024L, 
    0xC000006DL,
    0xC000006EL,
    0x80151004L,
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\xkdctest\config.h ===
#ifndef CONFIG_H
#define CONFIG_H

#include "xkdctest.h"
#include "vector.h"

class Config {
private:
    Vector<char*> m_strings;
    char *m_szFileName;
    Config *m_cfgChain;

    char *copyTrim(char *sz);
    char *StrDupNoComments(char *sz);
    INT countItems(char *szList);

public:
    Config();
    ~Config();

    HRESULT initialize(char *szFileName);

    void chainConfig(Config *cfgChain) {m_cfgChain = cfgChain;}

    void getSections(Vector<char*> *vctSections);
    void getEntries(char *szSection, Vector<char*> *vctKeys);
    char *getStrDef(char *szSection, char *szKey, char *szDefault);
    char *getStr(char *szSection, char *szKey)  {return getStrDef(szSection, szKey, NULL);}
    BOOL getBool(char *szSection, char *szKey);
    INT getInt(char *szSection, char *szKey);
    float getFloat(char *szSection, char *szKey);
    DWORD getIP(char *szSection, char *szKey);
    USHORT getPort(char *szSection, char *szKey);
    BOOL getIntList(char *szSection, char *szKey, INT **rgiItems, INT &cItems);
    BOOL getStrList(char *szSection, char *szKey, char ***rgszItems, INT &cItems);
    INT getBoolListItem(char *szSection, char *szKey, INT nWhich);
    INT getIntListItem(char *szSection, char *szKey, INT nWhich);
    char *getStrListItem(char *szSection, char *szKey, INT nWhich);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\xkdctest\miscstuff.cpp ===
#include "xkdctest.h"
#include <stdlib.h>


HRESULT HexCharToByte(
    IN char hex, 
    OUT BYTE *byte)
{
    BYTE t = 0;

    if (hex >= '0' && hex <= '9')
        t = hex - '0';
    else if (hex >= 'a' && hex <= 'f')
        t = hex - 'a' + 10;
    else if (hex >= 'A' && hex <= 'F')
        t = hex - 'A' + 10;
    else
        return E_FAIL;

    *byte = t;
    return S_OK;
}


HRESULT HexPairToByte(
    IN char *hex,
    OUT BYTE *byte)
{
    HRESULT hr = S_OK;
    if (SUCCEEDED(hr = HexCharToByte(hex[0], byte)))
    {
        BYTE b;;
        if (SUCCEEDED(hr = HexCharToByte(hex[1], &b)))
        {
            *byte = (*byte << 4) | b;
        }
    }

    return hr;
}


DWORD ToIP(char *szIP)
{
    if (!szIP || szIP[0] == 0) return 0;

    DWORD IP = 0;

    ASSERT(szIP[1]);
    if (szIP[0] == '0' && (szIP[1] == 'x' || szIP[1] == 'X') && (strlen(szIP) == 10))
    {
        // The IP is in Hex form
        szIP += 2;

        for (INT i = 0; i < 4; i++)
        {
            if (HexPairToByte(szIP, ((BYTE*)&IP) + (3-i)) != S_OK)
            {
                return E_FAIL;
            }
            szIP += 2;
        }
    }
    else
    {
        BOOL fIsIP = TRUE;
        for (UINT i = 0; i < strlen(szIP); i++)
        {
            if ((szIP[i] < '0' || szIP[i] > '9') && szIP[i] != '.')
            {
                fIsIP = FALSE;
                break;
            }
        }

        if (fIsIP)
        {
            // The IP is in decimal dot form
            IP = atoi(szIP);
            szIP = strchr(szIP, '.') + 1;
            IP |= atoi(szIP) << 8;
            szIP = strchr(szIP, '.') + 1;
            IP |= atoi(szIP) << 16;
            szIP = strchr(szIP, '.') + 1;
            IP |= atoi(szIP) << 24;
        }
        else
        {
            // We don't do DNS lookup
            IP = 0;
        }
    }

    return IP;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\xkdctest\kerbsockets.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       sockets.cxx
//
//  Contents:   Code for kerberos client sockets
//
//  Classes:
//
//  Functions:
//
//  History:    26-Jul-1996     MikeSw          Created
//
//----------------------------------------------------------------------------

#include "xkdctest.h"
#include "kerberos.h"

#define DS_INET_ADDRESS    1

#define KERB_KDC_PORT       88

//
// These are arbitrary sizes for max request and responses sizes for datagram
// requests.
//

#define KERB_MAX_KDC_RESPONSE_SIZE      4000
#define KERB_MAX_KDC_REQUEST_SIZE       4000
#define KERB_MAX_DATAGRAM_SIZE          1460
#define KERB_MAX_RETRIES                3

//
// timeout values in seconds
//

#define KERB_KDC_CALL_TIMEOUT                   5
#define KERB_KDC_CALL_TIMEOUT_BACKOFF           5
#define KERB_KDC_WAIT_TIME      120


//+-------------------------------------------------------------------------
//
//  Function:   KerbCloseSocket
//
//  Synopsis:   Closes a socket binding handle
//
//  Effects:    calls closesocket on the handle
//
//  Arguments:  SocketHandle - handle to close
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
CXoTest::KerbCloseSocket(
    IN SOCKET SocketHandle
    )
{
    int SockError;
    if (SocketHandle != 0)
    {
        SockError = GetXo()->closesocket(SocketHandle);
        if (SockError != 0)
        {
            TraceSz1( AuthWarn, "CloseSocket failed: last error %d", WSAGetLastError());
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBindSocketByAddress
//
//  Synopsis:   Binds to the KDC socket on the specified address
//
//  Effects:
//
//  Arguments:  Address - Address to bind to
//              AddressType - Address type, as specified by DC locator
//              ContextHandle - Receives bound socket
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
CXoTest::KerbBindSocketByAddress(
    IN ULONG Address,
    IN ULONG AddressType,
    IN BOOLEAN UseDatagram,
    IN USHORT PortNumber,
    OUT SOCKET * ContextHandle
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    SOCKET ClientSocket = INVALID_SOCKET;
    struct sockaddr_in ServerAddress;
    struct sockaddr_in ClientAddress;
    int serr;
    LINGER  l_linger;

    ClientSocket = GetXo()->socket(
                    PF_INET,
                    (UseDatagram ? SOCK_DGRAM : SOCK_STREAM),
                    0
                    );
    if (ClientSocket == INVALID_SOCKET)
    {
        TraceSz1( AuthWarn, "Failed to create socket: %d", WSAGetLastError());
        Status = STATUS_NO_LOGON_SERVERS;
        goto Cleanup;
    }

    /*// We enable linger, but set a linger timeout of zero. This forces a hard
    // close on closesocket. This is what we have to do to make sure 1) the
    // closesocket call returns synchronously, and 2) sockets don't linger
    // around trying to gracefully close and cause xbox to run out of sockets
    l_linger.l_onoff = 1;
    l_linger.l_linger = 0;
    serr = setsockopt(ClientSocket, SOL_SOCKET, 
                SO_LINGER, (char *)&l_linger, sizeof(l_linger));
    if (serr == SOCKET_ERROR)
    {
        TraceSz1( AuthWarn, "Failed to setsockopt: %d", WSAGetLastError());
        Status = STATUS_NO_LOGON_SERVERS;
        goto Cleanup;
    }*/

    GetXo()->XnSetInsecure(ClientSocket);
    
    if (UseDatagram)
    {
        //
        // Bind client socket to any local interface and port
        //

        ClientAddress.sin_family = AF_INET;
        ClientAddress.sin_addr.s_addr = INADDR_ANY;
        ClientAddress.sin_port = 0;                 // no specific port

        if (GetXo()->bind(
                ClientSocket,
                (LPSOCKADDR) &ClientAddress,
                sizeof(ClientAddress)
                ) == SOCKET_ERROR )
        {
            TraceSz1( AuthWarn, "Failed to bind client socket: %d", WSAGetLastError());
            Status = STATUS_NO_LOGON_SERVERS;
            goto Cleanup;
        }
    }

    if (AddressType == DS_INET_ADDRESS)
    {
        ServerAddress.sin_family = AF_INET;

        RtlCopyMemory(
            &ServerAddress.sin_addr,
            &Address,
            sizeof(ULONG)
            );

    }
    else
    {
        //
        // Get the address of the server
        //
        Assert(!"Must use DS_INET_ADDRESS");
    }

    ServerAddress.sin_port = htons(PortNumber);

    if (GetXo()->connect(
            ClientSocket,
            (LPSOCKADDR) &ServerAddress,
            sizeof(ServerAddress)
            ) == SOCKET_ERROR)
    {
        TraceSz1( AuthWarn, "Failed to connect to server: %d", WSAGetLastError());
        Status = STATUS_NO_LOGON_SERVERS;
        goto Cleanup;
    }
    *ContextHandle = ClientSocket;

Cleanup:
    if (!NT_SUCCESS(Status))
    {
        if (ClientSocket != INVALID_SOCKET)
        {
            GetXo()->closesocket(ClientSocket);
        }
    }
    return(Status);


}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCallKdc
//
//  Synopsis:   Socket client stub for calling the KDC.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
CXoTest::KerbCallKdc(
    IN ULONG KdcAddress,
    IN ULONG AddressType,
    IN ULONG Timeout,
    IN BOOLEAN UseDatagram,
    IN USHORT PortNumber,
    IN PKERB_MESSAGE_BUFFER Input,
    OUT PKERB_MESSAGE_BUFFER Output
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Bytes;
    int NumberReady;
    SOCKET Socket = 0;
    PUCHAR RemainingBuffer;
    ULONG RemainingSize;
    ULONG SendSize ;
    fd_set ReadHandles;
    struct timeval TimeoutTime;
    ULONG NetworkSize;
    BOOLEAN RetriedOnce = FALSE;

    WSABUF Buffers[2] = {0};
    LPWSABUF SendBuffers = NULL;
    ULONG BufferCount = 0;
    int SendStatus;

    Output->Buffer = NULL;
    
    //
    // Start out by binding to the KDC
    //
  
    Status = KerbBindSocketByAddress(
                KdcAddress,
                AddressType,
                UseDatagram,
                PortNumber,
                &Socket
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    RemainingBuffer = Input->Buffer;
    RemainingSize = Input->BufferSize;

    //
    // Use winsock2
    //

    Buffers[0].len = sizeof(ULONG);
    NetworkSize = htonl(RemainingSize);
    Buffers[0].buf = (PCHAR) &NetworkSize;
    Buffers[1].len = Input->BufferSize;
    Buffers[1].buf = (PCHAR) Input->Buffer;

    if (UseDatagram)
    {
        BufferCount = 1;
        SendBuffers = &Buffers[1];
        RemainingSize = Buffers[1].len;
    }
    else
    {
        BufferCount = 2;
        SendBuffers = &Buffers[0];
        RemainingSize = Buffers[0].len + Buffers[1].len;
    }

RetrySend:

    SendStatus = GetXo()->WSASend(
                    Socket,
                    SendBuffers,
                    BufferCount,
                    &Bytes,
                    0,          // no flags
                    NULL,               // no overlapped
                    NULL                // no completion routine
                    );

    TraceSz5( AuthVerbose, "KerbCallKdc sent %d bytes to %d.%d.%d.%d",Bytes,
        (*((BYTE*)&KdcAddress)),(*(((BYTE*)&KdcAddress)+1)),(*(((BYTE*)&KdcAddress)+2)),(*(((BYTE*)&KdcAddress)+3))
        );

    if ((SendStatus != 0) || (Bytes == 0))
    {
        Assert(SendStatus == SOCKET_ERROR);
        TraceSz1( AuthWarn, "Failed to send data: %d", WSAGetLastError());
        Status = SEC_E_NO_AUTHENTICATING_AUTHORITY;
        goto Cleanup;
    }
    if (Bytes < RemainingSize)
    {
        RemainingSize -= Bytes;
        if (Bytes > SendBuffers->len)
        {
            //
            // We sent the whole of a buffer, so move on to the next
            //

            Bytes -= SendBuffers->len;

            Assert(BufferCount > 1);
            BufferCount--;
            SendBuffers++;
            SendBuffers->len -= Bytes;
            SendBuffers->buf += Bytes;
        }
        else
        {
            SendBuffers->len -= Bytes;
            SendBuffers->buf += Bytes;
        }
        goto RetrySend;
    }


    //
    // Now select on the socket and wait for a response
    // ReadHandles and TimeoutTime must be reset each time, cause winsock
    // zeroes them out in case of error

    ReadHandles.fd_count = 1;
    ReadHandles.fd_array[0] = Socket;
    TimeoutTime.tv_sec = Timeout;
    TimeoutTime.tv_usec = 0;

    NumberReady = GetXo()->select(
                    1,
                    &ReadHandles,
                    NULL,
                    NULL,
                    &TimeoutTime
                    );
    if ((NumberReady == SOCKET_ERROR) ||
        (NumberReady == 0))
    {

        TraceSz2( AuthWarn, "Failed to select from kdc %x%X, NumberReady: %d", WSAGetLastError(), NumberReady );

        //
        // Retry again and wait.
        //

        if ((NumberReady == 0) && (!RetriedOnce))
        {
            RetriedOnce = TRUE;
            goto RetrySend;
        }
        Status = STATUS_NO_LOGON_SERVERS;
        goto Cleanup;
    }

    //
    // Now receive the data
    //

    if (UseDatagram)
    {
        Output->BufferSize = KERB_MAX_KDC_RESPONSE_SIZE;
        Output->Buffer = (PUCHAR) LocalAlloc(LMEM_ZEROINIT,KERB_MAX_KDC_RESPONSE_SIZE);
        if (Output->Buffer == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        Bytes = GetXo()->recv(
                    Socket,
                    (char *) Output->Buffer,
                    Output->BufferSize,
                    0
                    );
        if ((Bytes == SOCKET_ERROR) || (Bytes == 0))
        {
            DWORD err=WSAGetLastError();
            TraceSz1( AuthWarn, "Failed to receive socket data: %d", WSAGetLastError());
            Status = SEC_E_NO_AUTHENTICATING_AUTHORITY;
            goto Cleanup;
        }
        Output->BufferSize = Bytes;
    }
    else
    {
        Bytes = GetXo()->recv(
                    Socket,
                    (char *) &NetworkSize,
                    sizeof(ULONG),
                    0
                    );
        if (Bytes != sizeof(ULONG) )
        {
            TraceSz1( AuthWarn, "Failed to receive socket data: %d", WSAGetLastError());
            Status = SEC_E_NO_AUTHENTICATING_AUTHORITY;
            goto Cleanup;
        }
        RemainingSize = ntohl(NetworkSize);
        Output->BufferSize = RemainingSize;
        Output->Buffer = (PUCHAR) LocalAlloc(LMEM_ZEROINIT,RemainingSize);
        if (Output->Buffer == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        while (RemainingSize != 0)
        {
            //
            // Make sure there is data ready
            //

            NumberReady = GetXo()->select(
                            1,
                            &ReadHandles,
                            NULL,
                            NULL,
                            &TimeoutTime
                            );
            if ((NumberReady == SOCKET_ERROR) ||
                (NumberReady == 0))
            {
                TraceSz2( AuthWarn, "Failed to select from kdc %x%X, NumberReady: %d", WSAGetLastError(), NumberReady );

                Status = STATUS_NO_LOGON_SERVERS;
                goto Cleanup;
            }

            //
            // Receive the data
            //

            Bytes = GetXo()->recv(
                        Socket,
                        (char *) Output->Buffer + Output->BufferSize - RemainingSize,
                        RemainingSize,
                        0
                        );
            if ((Bytes == SOCKET_ERROR) || (Bytes == 0))
            {
                TraceSz1( AuthWarn, "Failed to receive socket data: %d", WSAGetLastError());
                Status = SEC_E_NO_AUTHENTICATING_AUTHORITY;
                goto Cleanup;
            }
            RemainingSize -= Bytes;
        }
    }

    TraceSz5( AuthVerbose, "KerbCallKdc received %d bytes from %d.%d.%d.%d",Output->BufferSize,
        (*((BYTE*)&KdcAddress)),(*(((BYTE*)&KdcAddress)+1)),(*(((BYTE*)&KdcAddress)+2)),(*(((BYTE*)&KdcAddress)+3))
        );

Cleanup:
    if (Socket != 0)
    {
        KerbCloseSocket(Socket);
    }
    if (!NT_SUCCESS(Status))
    {
        if (Output->Buffer != NULL)
        {
            LocalFree(Output->Buffer);
            Output->Buffer = NULL;
        }
    }
    return(Status);

}

#ifdef TONYCHEN_PRIVATE
ULONG KerbGlobalKdcCallTimeout = 1000000;
ULONG KerbGlobalKdcCallBackoff = 1000000;
ULONG KerbGlobalKdcSendRetries = 0;
#else
ULONG KerbGlobalKdcCallTimeout = KERB_KDC_CALL_TIMEOUT;
ULONG KerbGlobalKdcCallBackoff = KERB_KDC_CALL_TIMEOUT_BACKOFF;
ULONG KerbGlobalKdcSendRetries = KERB_MAX_RETRIES;
#endif

ULONG KerbGlobalMaxDatagramSize = KERB_MAX_DATAGRAM_SIZE;

//--------------------------------------------------------------------------

NTSTATUS
CXoTest::KerbMakeKdcCall(
    IN DWORD dwIP, 
    IN USHORT PortNumber,
    IN BOOLEAN UseTcp,
    IN PKERB_MESSAGE_BUFFER RequestMessage,
    IN PKERB_MESSAGE_BUFFER ReplyMessage
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Retries;
    ULONG Timeout = KerbGlobalKdcCallTimeout;

    Retries = 0;
    do
    {
        //
        // don't force retry the first time
        //

        if (Retries > 0)
        {
            Timeout += KerbGlobalKdcCallBackoff;
        }

        if  (RequestMessage->BufferSize > KerbGlobalMaxDatagramSize)
        {
            UseTcp = TRUE;
        }

        Status =  KerbCallKdc(
                    dwIP,
                    DS_INET_ADDRESS,
                    Timeout,
                    !UseTcp,
                    PortNumber, 
                    RequestMessage,
                    ReplyMessage
                    );

        if (!NT_SUCCESS(Status) )
        {
            //
            // If the request used UDP and we got an invalid buffer size error,
            // try again with TCP.
            //

            if ((Status == STATUS_INVALID_BUFFER_SIZE) && (!UseTcp))
            {

                UseTcp = TRUE;
                Status =  KerbCallKdc(
                            dwIP,
                            DS_INET_ADDRESS,
                            Timeout,
                            !UseTcp,
                            KERB_KDC_PORT,
                            RequestMessage,
                            ReplyMessage
                            );
            }

        }

        Retries++;
    } while ( !NT_SUCCESS(Status) && (Retries < KerbGlobalKdcSendRetries) );

    if (Status != STATUS_SUCCESS)
    {
        TraceSz1( AuthWarn, "KerbMakeKdcCall failure status %X", Status );
    }
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\xkdctest\kerbsockets.h ===
#ifndef KERBSOCKETS_H
#define KERBSOCKETS_H

class KerbSockets
{
public:
    KerbSockets()
    {
        WSADATA wsaData;
        WORD wVersionRequested = MAKEWORD(2, 2);
        int err = WSAStartup(wVersionRequested, &wsaData);

        if (LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) != 2) {
            WSACleanup();
        }
    }

    ~KerbSockets()
    {
        WSACleanup();
    }

    NTSTATUS KerbMakeKdcCall(
        IN IN_ADDR IpAddress,
        IN BOOLEAN UseTcp,
        IN PKERB_MESSAGE_BUFFER RequestMessage,
        IN PKERB_MESSAGE_BUFFER ReplyMessage
        );

private:
    VOID KerbCloseSocket(
        IN SOCKET SocketHandle
        );

    NTSTATUS KerbBindSocketByAddress(
        IN ULONG Address,
        IN ULONG AddressType,
        IN BOOLEAN UseDatagram,
        IN USHORT PortNumber,
        OUT SOCKET * ContextHandle
        );

    NTSTATUS KerbCallKdc(
        IN ULONG KdcAddress,
        IN ULONG AddressType,
        IN ULONG Timeout,
        IN BOOLEAN UseDatagram,
        IN USHORT PortNumber,
        IN PKERB_MESSAGE_BUFFER Input,
        OUT PKERB_MESSAGE_BUFFER Output
        );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\xkdctest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by kdctest.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\xkdctest\ticketcache.h ===
#ifndef TICKETCACHE_H
#define TICKETCACHE_H

#include <stdio.h>
#include "config.h"

#include "xkdctest.h"


class TicketCache {
private:
    struct TicketInfo {XUID rgXuids[1 + XONLINE_MAX_LOGON_USERS]; XKERB_TGT_CONTEXT tkt;};
    static Vector<TicketInfo> m_vctTickets;
    struct AccountInfo {char szAccount[64]; XONLINEP_USER User;};
    static Vector<AccountInfo> m_vctAccounts;

    TicketCache();
    ~TicketCache();

    static HRESULT GenerateSignature(
        IN XONLINEP_USER *rgUsers,
        OUT TicketInfo &ticketinfo);

public:
    static HRESULT FindTicket(
        IN XONLINEP_USER *rgUsers,
        OUT XKERB_TGT_CONTEXT *ptkt);

    static HRESULT AddTicket(
        IN XONLINEP_USER *rgUsers,
        IN XKERB_TGT_CONTEXT *ptkt);

    static HRESULT FindAccount(
        IN char* szAccountIndicator,
        OUT XONLINEP_USER *pUser);
    
    static HRESULT AddAccount(
        IN char* szAccountIndicator,
        IN XONLINEP_USER *pUser);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\xkdctest\ticketcache.cpp ===
#include "xkdctest.h"
#include "ticketcache.h"


Vector<TicketCache::TicketInfo> TicketCache::m_vctTickets;
Vector<TicketCache::AccountInfo> TicketCache::m_vctAccounts;

HRESULT TicketCache::GenerateSignature(
    IN XONLINEP_USER *rgUsers,
    OUT TicketInfo &ticketinfo)
{
    HRESULT hr = E_FAIL;

    for (INT i = 0; i < 1 + XONLINE_MAX_LOGON_USERS; i++)
    {
        ticketinfo.rgXuids[i] = rgUsers[i].xuid;
        hr = S_OK;
    }

    return hr;
}


HRESULT TicketCache::FindTicket(
    IN XONLINEP_USER *rgUsers,
    OUT XKERB_TGT_CONTEXT *ptkt)
{
    HRESULT hr = E_FAIL;

    TicketInfo ticketinfo;
    if (SUCCEEDED(GenerateSignature(rgUsers, ticketinfo)))
    {
        hr = S_FALSE;
        for (INT i = 0; i < m_vctTickets.GetCount(); i++)
        {
            if (!memcmp(ticketinfo.rgXuids, m_vctTickets[i].rgXuids, sizeof(XUID) * (1 + XONLINE_MAX_LOGON_USERS)))
            {
                *ptkt = m_vctTickets[i].tkt;
                hr = S_OK;
            }
        }
    }

    return hr;
}


HRESULT TicketCache::AddTicket(
    IN XONLINEP_USER *rgUsers,
    IN XKERB_TGT_CONTEXT *ptkt)
{
    HRESULT hr = E_FAIL;

    TicketInfo ticketinfo;
    memset(&ticketinfo, 0, sizeof(TicketInfo));

    hr = GenerateSignature(rgUsers, ticketinfo);

    ticketinfo.tkt = *ptkt;
    m_vctTickets.Add(ticketinfo);

    return hr;
}


HRESULT TicketCache::FindAccount(
    IN char* szAccountIndicator,
    OUT XONLINEP_USER *pUser)
{
    HRESULT hr = E_FAIL;

    hr = S_FALSE;
    for (INT i = 0; i < m_vctAccounts.GetCount(); i++)
    {
        if (!strcmp(szAccountIndicator, m_vctAccounts[i].szAccount))
        {
            *pUser = m_vctAccounts[i].User;
            hr = S_OK;
        }
    }

    return hr;
}


HRESULT TicketCache::AddAccount(
    IN char* szAccountIndicator,
    IN XONLINEP_USER *pUser)
{
    HRESULT hr = E_FAIL;

    AccountInfo accountinfo;
    memset(&accountinfo, 0, sizeof(AccountInfo));

    strcpy(accountinfo.szAccount, szAccountIndicator);
    accountinfo.User = *pUser;

    if (m_vctAccounts.Add(accountinfo))
    {
        hr = S_OK;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\xkdctest\vector.h ===
#ifndef VECTOR_H
#define VECTOR_H

//#include "xkdctest.h"


// Hungarian: vct
template<class a> class Vector {
private:
    a *items;
    int numitems;
    int maxitems;

public:
    Vector()
    {
        items = NULL;
        numitems = 0;
        maxitems = 0;
    }
    
    ~Vector()
    {
        delete [] items;
    }

    void
    DeleteAll()
    {
        for (int i = 0; i < GetCount(); i++)
        {
            delete items[i];
        }
        delete [] items;
        items = NULL;
        numitems = 0;
        maxitems = 0;
    }

    int
    GetCount() const {return numitems;}

    a *GetItems() const {return items;}
    
    BOOL
    Add(const a &item)
    {
        if (numitems+1 > maxitems)
        {
            if (!DoubleArraySize())
            {
                return FALSE;
            }
        }
        items[numitems] = item;
        numitems++;
        return TRUE;
    }

    void
    Remove(int itemnumber)
    {
        items[itemnumber] = items[numitems-1];
        numitems--;
    }
    
    BOOL
    DoubleArraySize()
    {
        BOOL fStatus = FALSE;
        if (items == NULL) {
            maxitems = 4;
            items = new a[maxitems];
            if (items)
            {
                fStatus = TRUE;
            }
        }
        else
        {
            a *newitems = new a[maxitems*2];
            if (newitems)
            {
                for (int i=0; i<numitems; i++)
                    newitems[i] = items[i];
                delete [] items;
                items = newitems;
                maxitems *= 2;
                fStatus = TRUE;
            }
        }
        return fStatus;
    }

    a &operator[](int i) const {return items[i];}

    Vector &
    operator=(const Vector &v)
    {
        maxitems = v.maxitems;
        numitems = v.numitems;
        items = new a[maxitems];
        for (int i=0; i<numitems; i++)
            items[i] = v.items[i];
        return *this;
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\xkdctest\xkdctest.h ===
#ifndef XKDCTEST_H
#define XKDCTEST_H

#include "xonp.h"
#include "xonver.h"
#include <xonlinep.h>
#include "xkdctestdebug.h"
#include "xkdctestkerb.h"


DWORD ToIP(
    char *szIP);

HRESULT HexCharToByte(
    IN char hex, 
    OUT BYTE *byte);

HRESULT HexPairToByte(
    IN char *hex, 
    OUT BYTE *byte);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\xkdctest\xkdctestdebug.h ===
#ifndef XKDCTESTDEBUG_H
#define XKDCTESTDEBUG_H

#include "xkdctest.h"


enum XKTVerbose {XKTVerbose_None, XKTVerbose_Status, XKTVerbose_Process, XKTVerbose_All};

#define TestErrMsg TestMsg
void TestMsg(char *message, ...);
void TestMsg(XKTVerbose xktvLevel, char *message, ...);

#define TAHR(a) TestAssertHR(a, &hr);
void TestAssertHR(HRESULT hr, HRESULT *hrFunc = NULL);

#define TA(a) TestAssert(a, &hr)
void TestAssert(BOOL condition, HRESULT *hrFunc = NULL);

BOOL IsHex(char *sz, INT length);

HRESULT FillMemDbg(char *pb, INT cb);

HRESULT CheckMemDbg(char *pb, INT cb);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\xkdctest\xktest.h ===
#ifndef XKTEST_H
#define XKTEST_H

#include "config.h"

class XKTest
{
public:
    XKTest() {}
    ~XKTest() {}
    
    virtual void getName(OUT char *sz) = 0;

    virtual HRESULT runTest(IN CXoTest *xo, IN char *szSectionName, IN Config &cfg) = 0;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\xkdctest\xkdctestkerb.cpp ===
#include "xkdctest.h"


#define XONLINE_AS_EXCHANGE_BUFFER_SIZE 1400
#define XONLINE_TGS_COMBINE_REQUEST_BUFFER_SIZE 5120
#define XONLINE_TGS_EXCHANGE_BUFFER_SIZE 1400

#define XBOX_REALM      "xbox.com"
#define MACS_REALM      "macs.xbox.com"


/*
HRESULT CXoTest::UacsCreate(
    IN IN_ADDR dwIP, 
    IN OUT XONLINEP_USER *pUser)
{
    HRESULT hr = E_FAIL;

    Assert(sizeof(XONLINE_USER) == 128);

    char pb[1024];
    _snprintf(pb, 1024, "POST /xuacs/createacct.ashx HTTP/1.0\r\nUser-agent: 5/1.0\r\nContent-Length: %d\r\nContent-Type: xon/5\r\n\r\n", sizeof(XONLINE_USER));
    INT cb = strlen(pb);

    Assert(cb + sizeof(XONLINE_USER) < 1024);
    memcpy(pb + cb, pUser, sizeof(XONLINE_USER));
    cb += sizeof(XONLINE_USER);

    SOCKET Socket = INVALID_SOCKET;
    if ((Socket = GetXo()->socket(PF_INET, SOCK_STREAM, 0)) != INVALID_SOCKET)
    {
        GetXo()->XnSetInsecure(Socket);

        sockaddr_in ServerAddress;
        memset(&ServerAddress, 0, sizeof(sockaddr_in));
        ServerAddress.sin_family = AF_INET;
        ServerAddress.sin_addr = dwIP;
        ServerAddress.sin_port = 80 << 8;

        if (GetXo()->connect(Socket, (LPSOCKADDR)&ServerAddress, sizeof(ServerAddress)) != SOCKET_ERROR)
        {
            if (GetXo()->send(Socket, pb, cb, 0) != SOCKET_ERROR)
            {
                if ((cb = GetXo()->recv(Socket, pb, cb, 0)) != SOCKET_ERROR)
                {
                    if (!memcmp(pb + 9, "200", 3))
                    {
                        memcpy(pUser, pb + 149, 128);
                        INT err = KerbPasswordToKey(pUser->realm, pUser->key);
                        strcpy(pUser->realm, "passport.net");
                        hr = S_OK;
                    }
                    else
                    {
                        Assert(!memcmp(pb + 9, "500", 3));
                        char *szhrXError = strstr(pb, "X-Err: ");
                        if (szhrXError)
                        {
                            szhrXError += 7;
                            if (!memcmp(szhrXError, "80154000", 8))
                            {
                                hr = XUAC_E_NAME_TAKEN;
                            }
                            else if (!memcmp(szhrXError, "80154001", 8))
                            {
                                hr = XUAC_E_INVALID_KINGDOM;
                            }
                            else if (!memcmp(szhrXError, "80154002", 8))
                            {
                                hr = XUAC_E_INVALID_USER;
                            }
                            else if (!memcmp(szhrXError, "80154003", 8))
                            {
                                hr = XUAC_E_USER_NOT_LOCKED_OUT;
                            }
                            else if (!memcmp(szhrXError, "80154004", 8))
                            {
                                hr = XUAC_E_ACCOUNT_INACTIVE;
                            }
                        }
                    }
                }
            }
        }
    }

    if (Socket != INVALID_SOCKET)
    {
        GetXo()->closesocket(Socket);
    }

    return hr;
}
*/


HRESULT CXoTest::SignInAccount_AS(
    IN DWORD dwIP, 
    IN USHORT PortNumber,
    IN XONLINEP_USER *pUser, 
    IN BOOL fMachineAccount,
    IN OUT XKERB_TGT_CONTEXT *ptkt, 
    OUT NTSTATUS &Status)
{
    HRESULT hr = E_FAIL;

    BYTE RequestMessageBuffer[XONLINE_AS_EXCHANGE_BUFFER_SIZE];
    ULONG dwRequestMessageLength = XONLINE_AS_EXCHANGE_BUFFER_SIZE;

    Status = GetXo()->XkerbBuildAsRequest(
        fMachineAccount,
        pUser,
        RequestMessageBuffer,
        &dwRequestMessageLength,
        ptkt);
    if (NT_SUCCESS(Status))
    {
        KERB_MESSAGE_BUFFER RequestMessage;

        RequestMessage.Buffer = RequestMessageBuffer;
        RequestMessage.BufferSize = dwRequestMessageLength;

        KERB_MESSAGE_BUFFER ReplyMessage;

        Status = KerbMakeKdcCall(
            dwIP,
            PortNumber,
            FALSE, // Always use UDP
            &RequestMessage,
            &ReplyMessage);
        if (NT_SUCCESS(Status))
        {
            Status = GetXo()->XkerbVerifyAsReply(
                ReplyMessage.Buffer, 
                ReplyMessage.BufferSize, 
                ptkt);
            if (NT_SUCCESS(Status))
            {
                hr = S_OK;
            }
        }
    }

    return hr;
}


HRESULT CXoTest::SendAndVerifyTGSRequest(
    IN DWORD dwIP, 
    IN USHORT PortNumber,
    IN XONLINEP_USER *pUsers, 
    IN XKERB_TGT_CONTEXT *ptgtCombined, 
    IN OUT XKERB_SERVICE_CONTEXT *pKerbServiceContext, 
    OUT NTSTATUS &Status)
{
    HRESULT hr = E_FAIL;

    BYTE RequestMessageBuffer[XONLINE_TGS_EXCHANGE_BUFFER_SIZE];
    ULONG dwRequestMessageLength = XONLINE_TGS_EXCHANGE_BUFFER_SIZE;

    Status = GetXo()->XkerbBuildTgsRequest(
        ptgtCombined,
        RequestMessageBuffer,
        &dwRequestMessageLength,
        pKerbServiceContext);
    if (NT_SUCCESS(Status))
    {
        KERB_MESSAGE_BUFFER RequestMessage;

        RequestMessage.Buffer = RequestMessageBuffer;
        RequestMessage.BufferSize = dwRequestMessageLength;        

        KERB_MESSAGE_BUFFER ReplyMessage;

        Status = KerbMakeKdcCall(
            dwIP,
            PortNumber,
            FALSE, // Always use UDP
            &RequestMessage,
            &ReplyMessage);
        if (NT_SUCCESS(Status))
        {
            Status = GetXo()->XkerbVerifyTgsReply(
                pUsers,
                ptgtCombined,
                ReplyMessage.Buffer,
                ReplyMessage.BufferSize,
                pKerbServiceContext);
            if (NT_SUCCESS(Status))
            {
                hr = S_OK;
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\xkdctest\xkdctest.cpp ===
#include "xkdctest.h"

#include <time.h>

#include "accounts.h"

#include "vector.h"
#include "dlist.h"
#include "config.h"
#include "kerberrorcompare.h"

#include "xktest.h"
#include "xktxonlinelogon.h"
#include "xktxmacscreate.h"


extern XKTVerbose g_XKTVerbose;

/*
void MakeTacticsTestCase(CTestData &testdata, Config &cfg, char *szTestName, BOOL fSuccess)
{
    testdata.m_nTestCase = cfg.getInt(szTestName, "number");
    testdata.m_nConfig = cfg.getInt("logging", "machinetype");
    testdata.m_nMethod = cfg.getInt("logging", "testmethod");
    testdata.m_nMilestone = cfg.getInt("logging", "milestone");
    testdata.m_nType = cfg.getInt("logging", "testtype");

    char *sz = cfg.getStr("logging", "build");
    if (sz)
    {
        memcpy(testdata.m_szBuild, sz, strlen(sz));
    }

    sz = cfg.getStr("logging", "tacticscomment");
    if (sz)
    {
        memcpy(testdata.m_szComments, sz, strlen(sz));
    }

    testdata.m_nStatus = fSuccess ? 1 : 2;
}
*/


HRESULT RunTestFile(IN CXoTest *xo, IN Vector<XKTest*> &vctTests, IN Config &cfg, IN char *szTestSectionName, IN Vector<char*> &vctszTestsToRun, OUT Vector<char*> &vctszFailedTests, OUT INT &nTestsRun)
{
    HRESULT hr = S_OK;
    
    Vector<char*> vctSections;
    cfg.getSections(&vctSections);

    BOOL fFilterTests = vctszTestsToRun.GetCount() > 0;
    
    // Loop through all of the sections and run the test that corresponds
    for (INT j = 0; j < vctSections.GetCount(); j++)
    {
        BOOL fInTestsToRunList = !fFilterTests;

        for (INT l = 0; l < vctszTestsToRun.GetCount(); l++)
        {
            if (!_stricmp(vctSections[j], vctszTestsToRun[l]))
            {
                char *szT = vctszTestsToRun[l];
                vctszTestsToRun.Remove(l);
                delete szT;
                fInTestsToRunList = TRUE;
            }
        }

        if (fInTestsToRunList)
        {
            // Run all tests that start with "test_"
            if (!_strnicmp(vctSections[j], "test_", 5))
            {
                char *szTestType = cfg.getStr(vctSections[j], "test");
                if (!szTestType)
                {
                    TestMsg(XKTVerbose_Status, "Can not run %s because it does not have a test type.\n", vctSections[j]);
                }
                else
                {
                    // Loop through all of the tests to find the one to execute now
                    // This is inefficient, but it's not worth improving now
                    for (INT k = 0; k < vctTests.GetCount(); k++)
                    {
                        HRESULT hrT = S_OK;

                        char szTestName[256];
                        vctTests[k]->getName(szTestName);
                        // Check to see if this is the test we are to run
                        if (!_stricmp(szTestType, szTestName))
                        {
/*
                            CTestData testdata;
*/
                            TestMsg(XKTVerbose_Status, "Running %s...\n", vctSections[j]);

                            // Run the test
                            if (SUCCEEDED(hrT = vctTests[k]->runTest(xo, vctSections[j], cfg)))
                            {
                                TestMsg(XKTVerbose_Status, "<succeeded>\n\n");
/*
                                MakeTacticsTestCase(testdata, cfg, vctSections[j], TRUE);
*/
                            }
                            else
                            {
                                char *szFailureMsg = cfg.getStr(vctSections[j], "failuremsg");
                                if (szFailureMsg)
                                {
                                    TestMsg(XKTVerbose_Status, "<failed> - %s\n\n", szFailureMsg);
                                }
                                else
                                {
                                    TestMsg(XKTVerbose_Status, "<failed>\n\n");
                                }
/*
                                MakeTacticsTestCase(testdata, cfg, vctSections[j], FALSE);
*/
                                char *szFailedTest = new char[strlen(szTestSectionName) + strlen(vctSections[j]) + 3];
                                strcpy(szFailedTest, szTestSectionName);
                                if (strlen(szTestSectionName) > 0)
                                {
                                    strcat(szFailedTest, "::");
                                }
                                strcat(szFailedTest, vctSections[j]);
                                vctszFailedTests.Add(szFailedTest);

                                hr = hrT;
                            }

                            nTestsRun++;
/*
                            if (testdata.m_nTestCase != 0 && cfg.getBool("logging", "logtotactics"))
                            {
                                char *sz = cfg.getStr("logging", "tester");
                                WCHAR wcs[100];
                                if (!sz || !MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, sz, strlen(sz), wcs, 100))
                                {
                                    printf("MultiByteToWideChar failed.\n");
                                    ASSERT(FALSE);
                                    hrFinal = E_FAIL;
                                }
                                else
                                {
                                    if(pTLDBRoutines && FAILED(hrFinal = pTLDBRoutines->AddTestResult(&testdata, wcs)))
                                    {
                                        printf("TacticsLog failed to add test case result for case: %d.  Error code %x.\n", testdata.m_nTestCase, hr);
                                    }

                                }
                            }
*/
                        }
                    }
                }
            }
        }
    }

    return hr;
}

HRESULT RunTests(IN CXoTest *xo, IN Vector<XKTest*> &vctTests, IN Config &cfg, IN Vector<char*> &vctszTestsToRun, OUT Vector<char*> &vctszFailedTests, OUT INT &nTestsRun)
{
    HRESULT hr = S_OK;
    HRESULT hrFinal = S_OK;
    nTestsRun = 0;

    char *szVerbose = cfg.getStr("general", "verbose");

    if (!szVerbose)
    {
        g_XKTVerbose = XKTVerbose_All;
    }
    else
    {
        if (!_stricmp(szVerbose, "none"))
        {
            g_XKTVerbose = XKTVerbose_None;
        }
        else if (!_stricmp(szVerbose, "status"))
        {
            g_XKTVerbose = XKTVerbose_Status;
        }
        else if (!_stricmp(szVerbose, "process"))
        {
            g_XKTVerbose = XKTVerbose_Process;
        }
        else
        {
            g_XKTVerbose = XKTVerbose_All;
        }
    }

/*
    // TacticsLog
    CTLDBRoutines *pTLDBRoutines = NULL;

    if (cfg.getBool("logging", "logtotactics"))
    {
        pTLDBRoutines = new CTLDBRoutines();
        if (pTLDBRoutines)
        {
            hrFinal = pTLDBRoutines->Init();
        }
        else
        {
            hrFinal = E_FAIL;
        }
    }
*/

    if (FAILED(hrFinal))
    {
        printf("TacticsLog failed to initialize.  Error code %x.\n", hrFinal);
    }
    else
    {
        Vector<char*> vctszTestFiles;
        cfg.getEntries("tests", &vctszTestFiles);

        if (vctszTestFiles.GetCount() == 0)
        {
            hrFinal = RunTestFile(xo, vctTests, cfg, "", vctszTestsToRun, vctszFailedTests, nTestsRun);
        }

        // Loop through all of the keys in the tests section and run all tests in the indicated files
        for (INT i = 0; i < vctszTestFiles.GetCount(); i++)
        {
            Config cfgTestFile;
            cfgTestFile.initialize(cfg.getStr("tests", vctszTestFiles[i]));
            cfgTestFile.chainConfig(&cfg);

            HRESULT hr = RunTestFile(xo, vctTests, cfgTestFile, vctszTestFiles[i], vctszTestsToRun, vctszFailedTests, nTestsRun);
            if (FAILED(hr))
            {
                hrFinal = hr;
            }
        }
    }

    return hrFinal;
}


HRESULT ParseTestsToRun(DList<char*> &dlstszArgs, Vector<char*> &vctszTestsToRun)
{
    HRESULT hr = S_FALSE;

    dlstszArgs.CurReset();
    while(!dlstszArgs.CurIsAtEnd())
    {
        char *szT;
        BOOL f = dlstszArgs.CurGetData(szT);
        if (!f)
        {
            hr = E_FAIL;
            break;
        }
        else
        {
            if (!_stricmp(szT, "-r") || !_stricmp(szT, "/r"))
            {
                f = dlstszArgs.CurNext() && dlstszArgs.CurGetData(szT);
                if (!f)
                {
                    // -r comes at the end of the argument list, which is illegal
                    hr = E_FAIL;
                    break;
                }
                else
                {
                    vctszTestsToRun.Add(_strdup(szT));
                    if (dlstszArgs.CurPrev() && dlstszArgs.CurRemove() && dlstszArgs.CurRemove())
                    {
                        hr = S_OK;
                    }
                    else
                    {
                        hr = E_FAIL;
                        break;
                    }
                }
            }
            else
            {
                if (!dlstszArgs.CurNext())
                {
                    hr = E_FAIL;
                    break;
                }
            }
        }
    }

    return hr;
}


HRESULT VerifyConfig(Config &cfg)
{
    HRESULT hr = S_OK;

    Vector<char*> vctszSections;
    cfg.getSections(&vctszSections);
    for (INT i = 0; i < vctszSections.GetCount(); i++)
    {
        if (!strcmp(vctszSections[i], "general"))
        {
            break;
        }
    }
    if (i == vctszSections.GetCount())
    {
        TestMsg(XKTVerbose_Status, "There is no \"general\" section in the config file.\n");
        hr = E_INVALIDARG;
    }

    return hr;
}


HRESULT LoadArgsIntoDList(INT argc, char **argv, DList<char*> &dlstszArgs)
{
    HRESULT hr = S_OK;

    Assert(argc && argv);

    for (INT i = 1; i < argc; i++)
    {
        if (!dlstszArgs.PushBack(argv[i]))
        {
            hr = E_FAIL;
            break;
        }
    }

    return hr;
}


INT __cdecl main(INT argc, char **argv)
{
    HRESULT hr = E_FAIL;

//    LARGE_INTEGER qwTime;
//    NtQuerySystemTime(&qwTime);
//    qwTime.QuadPart += 60;
//    NtSetSystemTime(&qwTime, NULL);
//    return 0;

    DList<char*> dlstszArgs;
    hr = LoadArgsIntoDList(argc, argv, dlstszArgs);

    dlstszArgs.CurReset();
    char *szT;
    BOOL f = dlstszArgs.CurGetData(szT);
    if (f && (!_stricmp(szT, "-hash") || !_stricmp(szT, "/hash")))
    {
        f = dlstszArgs.CurNext() && dlstszArgs.CurGetData(szT);
        if (f)
        {
            HashAndPrintKeyHex(szT);
            hr = S_OK;
        }
    }

    if (f)
    {
        f = dlstszArgs.CurGetData(szT);
        if (f && (!_stricmp(szT, "-?") || !_stricmp(szT, "/?")))
        {
            printf("usage: %s <testfile>\n", argv[0]);
            hr = E_INVALIDARG;
        }
    }

    if (f)
    {
        Vector<char*> vctszTestsToRun;
        hr = ParseTestsToRun(dlstszArgs, vctszTestsToRun);

        if (SUCCEEDED(hr))
        {
            srand(time(NULL));
    
            Config cfg;
            f = dlstszArgs.PopFront(szT);

            if (!f || FAILED(hr = cfg.initialize(szT)))
            {
                printf("Not able to open file \"%s\".\n\n", szT);
                printf("usage: %s <testfile>\n", argv[0]);
            }
            else
            {
                // Do some simple verification on config file
                if (FAILED(VerifyConfig(cfg)))
                {
                    printf("\n");
                    printf("usage: %s <testfile>\n", argv[0]);
                }
                else
                {
                    CXoTest xon(cfg.getStr("general", "xboxname"));

                    if (SUCCEEDED(xon.XOnlineStartup(NULL)))
                    {
                        XNADDR xnaddr;

                        DWORD dwT = 0;
                        //Wait for DHCP to succeed

                        do
                        {
                            dwT = xon.XNetGetTitleXnAddr(&xnaddr);
                            Sleep(100);
                        } 
                        while (dwT == XNET_GET_XNADDR_PENDING);

                        Vector<XKTest*> vctTests;

                        vctTests.Add(new XKTXOnlineLogon());
                        vctTests.Add(new XKTXmacsCreate());

                        INT nTestsRun;
                        Vector<char*> vctszFailedTests;

                        if ((hr = RunTests(&xon, vctTests, cfg, vctszTestsToRun, vctszFailedTests, nTestsRun)) == S_OK)
                        {
                            TestMsg(XKTVerbose_Status, "\n");
                            if (nTestsRun == 1)
                            {
                                TestMsg(XKTVerbose_Status, " ===== Test succeeded =====\n");
                            }
                            else
                            {
                                TestMsg(XKTVerbose_Status, " ===== All %d tests succeeded =====\n", nTestsRun);
                            }
                        }
                        else
                        {
                            if (nTestsRun > 0)
                            {
                                TestMsg(XKTVerbose_Status, "\n");
                                TestMsg(XKTVerbose_Status, " ************************\n");
                                if (nTestsRun == 1)
                                {
                                    TestMsg(XKTVerbose_Status, " *    Test failed:\n");
                                }
                                else
                                {
                                    TestMsg(XKTVerbose_Status, " *    %d/%d tests failed:\n", vctszFailedTests.GetCount(), nTestsRun);
                                }
                                TestMsg(XKTVerbose_Status, " *\n");
                                for (INT i = 0; i < vctszFailedTests.GetCount(); i++)
                                {
                                    TestMsg(XKTVerbose_Status, " * %s\n", vctszFailedTests[i]);
                                }
                                TestMsg(XKTVerbose_Status, " *\n");
                                TestMsg(XKTVerbose_Status, " ************************\n");
                            }
                        }

                        vctTests.DeleteAll();
                        vctszFailedTests.DeleteAll();

                        hr = S_OK;

                        xon.XOnlineCleanup();
                    }
                }
            }
        }

        if (vctszTestsToRun.GetCount() > 0)
        {
            TestMsg(XKTVerbose_Status, "Test(s) specified on command line not found.\n");
            vctszTestsToRun.DeleteAll();
        }
    }

    dlstszArgs.DeleteAll();

    return SUCCEEDED(hr) ? 0 : 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\xkdctest\xkdctestdebug.cpp ===
#include <stdio.h>
#include "xkdctest.h"


XKTVerbose g_XKTVerbose = XKTVerbose_Status;


void TestMsg(char *message, ...)
{
    if (g_XKTVerbose >= XKTVerbose_All)
    {
        // Print a ":" preceding any message that is called without a verbose level to notify the developer of this
        printf(":");

        va_list arglist;

        va_start(arglist, message);
        char string[256];
        _vsnprintf(string, sizeof(string), message, arglist);
        va_end(arglist);

        printf(string);
    }
}


void TestMsg(XKTVerbose xktvLevel, char *message, ...)
{
    if (g_XKTVerbose >= xktvLevel)
    {
        for (INT i = 0; i < xktvLevel - 1; i++)
        {
            printf("  ");
        }

        va_list arglist;

        va_start(arglist, message);
        char string[256];
        _vsnprintf(string, sizeof(string), message, arglist);
        va_end(arglist);

        printf(string);
    }
}


void TestAssertHR(HRESULT hr, HRESULT *hrFunc)
{
    if (hr != S_OK)
    {
        if (hrFunc)
        {
            *hrFunc = E_FAIL;
        }
    }
}


void TestAssert(BOOL condition, HRESULT *hrFunc)
{
    if (!condition)
    {
        if (hrFunc)
            *hrFunc = E_FAIL;
    }
}


BOOL IsHex(char *sz, INT length)
{
    BOOL yes = TRUE;
    for (INT i = 0; i < length; i++)
    {
        if (!((sz[i] >= '0' && sz[i] <= '9') || (sz[i] >= 'A' && sz[i] <= 'F') || (sz[i] >= 'a' && sz[i] <= 'f')))
        {
            yes = FALSE;
        }
    }
    return yes;
}


HRESULT FillMemDbg(char *pb, INT cb)
{
    LONGLONG qwPattern = 0xc0fedeadbeefc0fe;
    char *bPattern = ((char*)&qwPattern);
    INT nPatternLength = 8;
    INT nPatternIndex = 0;
    for (INT i = 0; i < cb; i++)
    {
        pb[i] = bPattern[nPatternIndex];
        nPatternIndex++;
        if (nPatternIndex == nPatternLength)
        {
            nPatternIndex = 0;
        }
    }
    
    return S_OK;
}


HRESULT CheckMemDbg(char *pb, INT cb)
{
    HRESULT hr = S_OK;
    
    LONGLONG qwPattern = 0xc0fedeadbeefc0fe;
    char *bPattern = ((char*)&qwPattern);
    INT nPatternLength = 8;
    INT nPatternIndex = 0;
    for (INT i = 0; i < cb; i++)
    {
        if (pb[i] != bPattern[nPatternIndex])
        {
            return E_FAIL;
        }
        nPatternIndex++;
        if (nPatternIndex == nPatternLength)
        {
            nPatternIndex = 0;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\xkdctest\xktxmacscreate.cpp ===
#include "xkdctest.h"
#include "xktxmacscreate.h"
#include "accounts.h"


HRESULT XKTXmacsCreate::VerifyCreate(IN CXoTest *xo, Config &cfg, XONLINEP_USER &MachineAccount, XKERB_TGT_CONTEXT &tgt)
{
    HRESULT hr = S_OK;

    // Verify that the account was created correctly
    if (tgt.pAccountCreationPreAuth)
    {
        TA(tgt.pAccountCreationPreAuth->qwUserID > 0);
        //!!Verify tgt.pAccountCreationPreAuth->name (base 64)
        if (!strcmp(MachineAccount.name, "999999999999"))
        {
            TA(!strcmp(tgt.pAccountCreationPreAuth->kingdom, "_devkit_"));
        }
        else
        {
            TA(strcmp(tgt.pAccountCreationPreAuth->kingdom, "machines"));
        }
        TA(!strcmp(tgt.pAccountCreationPreAuth->domain, cfg.getStr("general", "XmacsDomain")));
        TA(!strcmp(tgt.pAccountCreationPreAuth->realm, "passport.net"));
        char szClientName[] = "2\0" "_|_|_|_|_|_|\0" "macs.xbox.com";
        memcpy(szClientName + 2, &MachineAccount.name, 12);
        TA(!memcmp(tgt.ClientName, szClientName, 29));
        TA(!strcmp(tgt.ClientRealm, "macs.xbox.com"));
        TA(tgt.ExpirationTime.QuadPart > tgt.StartTime.QuadPart);

        TAHR(MakeAccountWithKey(
            &MachineAccount, 
            tgt.pAccountCreationPreAuth->qwUserID, 
            tgt.pAccountCreationPreAuth->name, 
            tgt.pAccountCreationPreAuth->kingdom, 
            tgt.pAccountCreationPreAuth->domain, 
            tgt.pAccountCreationPreAuth->realm, 
            tgt.pAccountCreationPreAuth->key));

        TestMsg(XKTVerbose_Process, "Verifying created account by signing into XKDC...\n");

        DWORD dwXkdcIp = cfg.getIP("servers", "xkdc");
        USHORT usXkdcPort = cfg.getPort("servers", "xkdc");

        XKERB_TGT_CONTEXT tgt2;
        memset(&tgt2, 0, sizeof(XKERB_TGT_CONTEXT));
        NTSTATUS Status = 0;
        TAHR(xo->SignInAccount_AS(dwXkdcIp, usXkdcPort, &MachineAccount, TRUE, &tgt2, Status));

        char *szT = tgt2.ClientName;
        TA(!strcmp(szT, "2"));
        szT += strlen(szT) + 1;
        TA(strstr(szT, tgt.pAccountCreationPreAuth->name) == szT);
        TA((INT)strlen(tgt.pAccountCreationPreAuth->name) == (strstr(szT, tgt.pAccountCreationPreAuth->kingdom) - szT - 1));
        szT += strlen(szT) + 1;
        TA(!strcmp(szT, "passport.net"));

        TA(!strcmp(tgt2.ClientRealm, "passport.net"));
        TA(tgt2.ctNumNonces == 1);

        xo->SysFree(tgt.pAccountCreationPreAuth);
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}


char *XKTXmacsCreate::getStrX(Config &cfg, char *szSectionName, char *szItem, INT nIteration, INT nCreations)
{
    char *sz;
    if (nCreations == 0)
    {
        sz = cfg.getStr(szSectionName, szItem);
    }
    else
    {
        char szT[20];
        strcpy(szT, szItem);
        _itoa(nIteration, szT + strlen(szT), 10);
        sz = cfg.getStr(szSectionName, szT);
    }

    return sz;
}


HRESULT XKTXmacsCreate::MakeCreationAccount(IN char *szSectionName, IN Config &cfg, IN INT nIteration, IN INT nCreations, OUT XONLINEP_USER *pAccount)
{
    HRESULT hr = E_FAIL;

    char *szMachineAccountIndicator = getStrX(cfg, szSectionName, "machine", nIteration, nCreations);

    char *szSerial;
    char *szPassword;
    char *szRealm;

    if (szMachineAccountIndicator)
    {
        szSerial = cfg.getStrListItem("machines", szMachineAccountIndicator, 1);
        szPassword = cfg.getStrListItem("machines", szMachineAccountIndicator, 2);
        szRealm = cfg.getStrListItem("machines", szMachineAccountIndicator, 2);
    }
    else
    {
        szSerial = cfg.getStr(szSectionName, "serial");
        szPassword = cfg.getStr(szSectionName, "password");
        szRealm = cfg.getStr(szSectionName, "realm");
    }

    char *szSerialT = "999999999999";
    char *szPasswordT = "PASSWORD";
    char *szRealmT = "macs.xbox.com";

    if(!szSerial)
    {
        szSerial = szSerialT;
    }    
    if(!szPassword)
    {
        szPassword = szPasswordT;
    }
    if(!szRealm)
    {
        szRealm = szRealmT;
    }

    if (szPassword[0] == '0' && (szPassword[1] == 'x' || szPassword[1] == 'X'))
    {
        hr = MakeAccountWithKey(pAccount, 1, szSerial, "", "", szRealm, (BYTE*)(szPassword + 2));
    }
    else
    {
        hr = MakeAccountWithPassword(pAccount, 1, szSerial, "", "", szRealm, szPassword);
    }

    return hr;
}


HRESULT XKTXmacsCreate::runTest(IN CXoTest *xo, IN char *szSectionName, IN Config &cfg)
{
    HRESULT hr = E_FAIL;

    DWORD dwXmacsIp = cfg.getIP("servers", "xmacs");
    USHORT usXmacsPort = cfg.getPort("servers", "xmacs");

    int nCreations = cfg.getInt(szSectionName, "numcreations");

    INT i = 0;
    while (i < nCreations || (nCreations == 0 && i == 0))
    {
        HRESULT hrT = E_FAIL;
        
        char *szExpected = getStrX(cfg, szSectionName, "expected", i, nCreations);

        NTSTATUS nErrorValue = STATUS_SUCCESS;
        if (szExpected)
        {
            nErrorValue = KerbErrorCompare::GetErrorValue(szExpected);
        }

        char *szTimeSkew = getStrX(cfg, szSectionName, "timeskew", i, nCreations);
        INT nTimeSkew = 0;
        if (szTimeSkew)
        {
            nTimeSkew = atoi(szTimeSkew);
        }
        // The maximum allowed TimeSkew is 5 minutes to either side of correct
        BOOL fTimeSkewRepeat = nTimeSkew > 300;

        XONLINEP_USER MachineAccount;
        if ((hr = MakeCreationAccount(szSectionName, cfg, i, nCreations, &MachineAccount)) == S_OK)
        {
            TestMsg(XKTVerbose_Process, "Sending machine account creation request with principal \"%s@%s\"...\n", MachineAccount.name, MachineAccount.realm);

            XKERB_TGT_CONTEXT tgt;
            RtlZeroMemory(&tgt, sizeof(tgt));

            NTSTATUS Status = 0;
            for (INT j = 0; j < 2; j++)
            {
                // Send an AS to the XMACS to create the account
                hr = xo->SignInAccount_AS(dwXmacsIp, usXmacsPort, &MachineAccount, FALSE, &tgt, Status);
                if (!fTimeSkewRepeat)
                {
                    break;
                }
                else
                {
                    if (SUCCEEDED(hr) || Status != STATUS_TIME_DIFFERENCE_AT_DC)
                    {
                        hr = E_FAIL;
                        break;
                    }
                    else
                    {
                        fTimeSkewRepeat = FALSE;
                    }
                }
            }

            if (nErrorValue != STATUS_SUCCESS)
            {
                if (hr != S_OK)
                {
                    if (Status == nErrorValue)
                    {
                        hr = S_OK;
                    }
                    else
                    {
                        TestMsg(XKTVerbose_All, "Incorrect return value from XMACS.\n");
                    }
                }
                else
                {
                    hr = E_FAIL;
                }
            }
            else
            {
                if (hr == S_OK)
                {
                    hr = VerifyCreate(xo, cfg, MachineAccount, tgt);
                }
            }
        }

        i++;
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\xkdctest\xkdctestkerb.h ===
#ifndef XKDCTESTKERB_H
#define XKDCTESTKERB_H

#include "xkdctest.h"
#include "accounts.h"
#include "kerberrorcompare.h"


class CXoTest : public CXOnline
{
public:
    CXoTest(char * pszXbox = NULL) : CXOnline(pszXbox) {}

    HRESULT UacsCreate(
        IN IN_ADDR IPAddress, 
        IN OUT XONLINEP_USER *pUser);

    HRESULT SignInAccount_AS(
        IN DWORD dwIP, 
        IN USHORT PortNumber,
        IN XONLINEP_USER *Account, 
        IN BOOL fTcp, 
        IN OUT XKERB_TGT_CONTEXT *pTGTContext, 
        OUT NTSTATUS &Status);

    HRESULT SendAndVerifyTGSRequest(
        IN DWORD dwIP, 
        IN USHORT PortNumber,
        IN XONLINEP_USER *pUsers, 
        IN XKERB_TGT_CONTEXT *pCombinedTGTContext, 
        IN OUT XKERB_SERVICE_CONTEXT *pKerbServiceContext, 
        OUT NTSTATUS &Status);

    NTSTATUS KerbMakeKdcCall(
        IN DWORD dwIP, 
        IN USHORT PortNumber,
        IN BOOLEAN UseTcp,
        IN PKERB_MESSAGE_BUFFER RequestMessage,
        IN PKERB_MESSAGE_BUFFER ReplyMessage);

    void SysFree(void *pv)
    {
        GetXo()->SysFree(pv);
    }

private:
    VOID KerbCloseSocket(
        IN SOCKET SocketHandle);

    NTSTATUS KerbBindSocketByAddress(
        IN ULONG Address,
        IN ULONG AddressType,
        IN BOOLEAN UseDatagram,
        IN USHORT PortNumber,
        OUT SOCKET * ContextHandle);

    NTSTATUS KerbCallKdc(
        IN DWORD dwIP, 
        IN ULONG AddressType,
        IN ULONG Timeout,
        IN BOOLEAN UseDatagram,
        IN USHORT PortNumber,
        IN PKERB_MESSAGE_BUFFER Input,
        OUT PKERB_MESSAGE_BUFFER Output);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\xkdctest\xktxonlinelogon.cpp ===
#include "xkdctest.h"
#include <stdlib.h>
#include "xktxonlinelogon.h"
#include "accounts.h"
#include "ticketcache.h"


HRESULT XKTXOnlineLogon::VerifyUserHRs(
    IN Config &cfg, 
    IN char *szSectionName, 
    IN XONLINEP_USER *rgUsers)
{
    HRESULT hr = S_OK;

    if (cfg.getStr(szSectionName, "userhr"))
    {
        for (INT i = 0; i < XONLINE_MAX_LOGON_USERS; i++)
        {
            HRESULT hrExpected = E_INVALIDARG;
            char *szhrUser = cfg.getStrListItem(szSectionName, "userhr", i);
            if (!strcmp(szhrUser, "XONLINE_E_LOGON_USER_ACCOUNT_INVALID"))
            {
                hrExpected = XONLINE_E_LOGON_USER_ACCOUNT_INVALID;
            }
            else if (!strcmp(szhrUser, "S_OK"))
            {
                hrExpected = S_OK;
            }

            if (hrExpected == S_OK && rgUsers[i].hr == XONLINE_E_LOGON_USER_ACCOUNT_INVALID)
            {
                hr = XONLINE_E_LOGON_USER_ACCOUNT_INVALID;
            }
            else if (hrExpected == XONLINE_E_LOGON_USER_ACCOUNT_INVALID && rgUsers[i].hr == S_OK)
            {
                hr = E_FAIL;
            }
        }
    }
    else
    {
        for (INT i = 0; i < XONLINE_MAX_LOGON_USERS; i++)
        {
            if (rgUsers[i].hr != S_OK)
            {
                hr = XONLINE_E_LOGON_USER_ACCOUNT_INVALID;
            }
        }
    }

    return hr;
}


HRESULT XKTXOnlineLogon::VerifyServices(
    IN Config &cfg, 
    IN char *szSectionName, 
    IN XKERB_SERVICE_CONTEXT *pKerbServiceContext)
{
    HRESULT hr = E_FAIL;

    DWORD rgdwServices[XONLINE_MAX_NUMBER_SERVICE];
    HRESULT rghrServices[XONLINE_MAX_NUMBER_SERVICE];
    WORD rgwServicesPort[XONLINE_MAX_NUMBER_SERVICE];
    memcpy(rgdwServices, pKerbServiceContext->dwServiceID, sizeof(DWORD) * XONLINE_MAX_NUMBER_SERVICE);
    memcpy(rghrServices, pKerbServiceContext->hrService, sizeof(HRESULT) * XONLINE_MAX_NUMBER_SERVICE);
    memcpy(rgwServicesPort, pKerbServiceContext->wServicePort, sizeof(WORD) * XONLINE_MAX_NUMBER_SERVICE);

    DWORD rgdwServicesGranted[XONLINE_MAX_NUMBER_SERVICE];
    HRESULT rghrServicesGranted[XONLINE_MAX_NUMBER_SERVICE];
    DWORD rgdwServicesGrantedIp[XONLINE_MAX_NUMBER_SERVICE];
    WORD rgwServicesGrantedPort[XONLINE_MAX_NUMBER_SERVICE];
    memset(rgdwServicesGranted, 0, sizeof(DWORD) * XONLINE_MAX_NUMBER_SERVICE);
    memset(rghrServicesGranted, 0, sizeof(HRESULT) * XONLINE_MAX_NUMBER_SERVICE);
    memset(rgdwServicesGrantedIp, 0, sizeof(DWORD) * XONLINE_MAX_NUMBER_SERVICE);
    memset(rgwServicesGrantedPort, 0, sizeof(WORD) * XONLINE_MAX_NUMBER_SERVICE);

    char **rgszServicesRequested = NULL;
    INT cServicesRequested;
    BOOL fServicesRequestedFound = cfg.getStrList(szSectionName, "services", &rgszServicesRequested, cServicesRequested);
    Assert(fServicesRequestedFound && cServicesRequested >= 0 && cServicesRequested <= (INT)XONLINE_MAX_NUMBER_SERVICE);
    Assert((DWORD)cServicesRequested == pKerbServiceContext->dwNumServices);
    char **rgszhrServicesGranted = NULL;
    INT cServicesGranted;
    BOOL fServicesGrantedFound = cfg.getStrList(szSectionName, "granted", &rgszhrServicesGranted, cServicesGranted);
    Assert(cServicesGranted >= 0 && cServicesGranted <= (INT)XONLINE_MAX_NUMBER_SERVICE);
    Assert(cServicesRequested == cServicesGranted || !fServicesGrantedFound);

    for (INT i = 0; i < cServicesRequested; i++)
    {
        rgdwServicesGranted[i] = cfg.getIntListItem("services", rgszServicesRequested[i], 0);
        char *szSiteIndex = cfg.getStrListItem("services", rgszServicesRequested[i], 1);
        rgdwServicesGrantedIp[i] = cfg.getIP("sites", szSiteIndex);
        rgwServicesGrantedPort[i] = (WORD)cfg.getIntListItem("services", rgszServicesRequested[i], 2);

        if (fServicesGrantedFound)
        {
            if (!strcmp(rgszhrServicesGranted[i], "yes"))
            {
                rghrServicesGranted[i] = S_OK;
            }
            else if (!strcmp(rgszhrServicesGranted[i], "no"))
            {
                rghrServicesGranted[i] = XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED;
            }
            else if (!strcmp(rgszhrServicesGranted[i], "nonexistant"))
            {
                rghrServicesGranted[i] = XONLINE_E_INTERNAL_ERROR;
            }
            else
            {
                Assert(FALSE);
            }
        }
        else
        {
            rghrServicesGranted[i] = S_OK;
        }
    }

    hr = S_OK;
    BOOL fRealTicket = FALSE;

    for (i = 0; i < cServicesRequested; i++)
    {
        Assert(rgdwServices[i] == rgdwServicesGranted[i]);
        TA(rghrServices[i] == rghrServicesGranted[i]);
        if (rghrServices[i] == S_OK)
        {
            TA(rgdwServicesGrantedIp[i] == pKerbServiceContext->siteIPAddress.S_un.S_addr);
            TA(rgwServicesPort[i] == rgwServicesGrantedPort[i]);
            fRealTicket = TRUE;
        }
        else
        {
            TA(rgwServicesPort[i] == 0);
        }
    }

    //!! can we check the ip and other info for a 'fake' ticket?
    if (!fRealTicket)
    {
        TA(pKerbServiceContext->siteIPAddress.S_un.S_addr == 0);
    }

    delete rgszServicesRequested;

    delete rgszhrServicesGranted;

    return hr;
}


HRESULT XKTXOnlineLogon::SignInServices(
    IN CXoTest *pXo, 
    IN Config &cfg, 
    IN char *szSectionName,
    IN XONLINEP_USER *rgUsers,
    IN INT cUsers,
    IN XKERB_TGT_CONTEXT *ptkt)
{
    HRESULT hr = S_OK;

    DWORD dwXkdcIp = cfg.getIP("servers", "xkdc");
    USHORT usXkdcPort = cfg.getPort("servers", "xkdc");

    DWORD rgdwServices[XONLINE_MAX_NUMBER_SERVICE];
    memset(rgdwServices, 0, sizeof(DWORD) * XONLINE_MAX_NUMBER_SERVICE);

    char **rgszServiceIndicators = NULL;
    INT cServices;
    BOOL fServicesFound = cfg.getStrList(szSectionName, "services", &rgszServiceIndicators, cServices);

    TA(cServices >= 0 && cServices <= (INT)XONLINE_MAX_NUMBER_SERVICE);

    // If no services are requested then we can return success without doing any work.
    if (fServicesFound)
    {
        TestMsg(XKTVerbose_Process, "Signing in services...\n");

        char *szExpected = cfg.getStr(szSectionName, "expected");

        NTSTATUS nErrorValue = STATUS_SUCCESS;
        if (szExpected)
        {
            nErrorValue = KerbErrorCompare::GetErrorValue(szExpected);
        }

        char *szTimeSkew = cfg.getStr(szSectionName, "timeskew");
        INT nTimeSkew = 0;
        if (szTimeSkew)
        {
            nTimeSkew = atoi(szTimeSkew);
        }

        // The maximum allowed TimeSkew is 5 minutes to either side of correct
        BOOL fTimeSkewRepeat = nTimeSkew > 300;

        XKERB_SERVICE_CONTEXT KerbServiceContext;
        memset(&KerbServiceContext, 0, sizeof(XKERB_SERVICE_CONTEXT));

        KerbServiceContext.dwTitleID = 0xFFFE0000;

        for (INT i = 0; i < cUsers; i++)
        {
            KerbServiceContext.UserID[i] = rgUsers[i].xuid.qwUserID;
        }

        Assert(cServices <= XONLINE_MAX_NUMBER_SERVICE);
        KerbServiceContext.dwNumServices = cServices;

        for (i = 0; i < XONLINE_MAX_NUMBER_SERVICE; i++)
        {
            KerbServiceContext.dwServiceID[i] = XONLINE_INVALID_SERVICE;
            KerbServiceContext.hrService[i] = S_FALSE;
        }

        for (i = 0; i < cServices; i++)
        {
            KerbServiceContext.dwServiceID[i] = cfg.getIntListItem("services", rgszServiceIndicators[i], 0);
            if (!KerbServiceContext.dwServiceID[i])
            {
                TestMsg(XKTVerbose_All, "Service '%s' not found.\n", rgszServiceIndicators[i]);
                hr = E_INVALIDARG;
                break;
            }
        }

        if (SUCCEEDED(hr))
        {
            NTSTATUS Status = STATUS_SUCCESS;
            for (INT j = 0; j < 2; j++)
            {
                // Send an TGS-REQ to the XKDC to sign in
                hr = pXo->SendAndVerifyTGSRequest(dwXkdcIp, usXkdcPort, rgUsers, ptkt, &KerbServiceContext, Status);
                if (!fTimeSkewRepeat)
                {
                    break;
                }
                else
                {
                    if (SUCCEEDED(hr) || Status != STATUS_TIME_DIFFERENCE_AT_DC)
                    {
                        hr = E_FAIL;
                        break;
                    }
                    else
                    {
                        fTimeSkewRepeat = FALSE;
                    }
                }
            }

            if (nErrorValue != STATUS_SUCCESS)
            {
                if (hr != S_OK)
                {
                    if (Status == nErrorValue)
                    {
                        hr = S_OK;
                    }
                    else
                    {
                        TestMsg(XKTVerbose_All, "Incorrect return value from XKDC.\n");
                    }
                }
                else
                {
                    hr = E_FAIL;
                }
            }
            else
            {
                if (hr == S_OK)
                {
                    hr = VerifyUserHRs(cfg, szSectionName, rgUsers);
                    if (hr == S_OK)
                    {
                        hr = VerifyServices(cfg, szSectionName, &KerbServiceContext);
                    }
                    else if (hr == XONLINE_E_LOGON_USER_ACCOUNT_INVALID)
                    {
                        TestMsg(XKTVerbose_All, "Bad user account.\n");
                    }
                }
                else if (hr == S_FALSE)
                {
                    if (Status == XONLINE_E_LOGON_XBOX_ACCOUNT_INVALID)
                    {
                        TestMsg(XKTVerbose_All, "Bad machine account.\n");
                        hr = XONLINE_E_LOGON_XBOX_ACCOUNT_INVALID;
                    }
                    else
                    {
                        hr = E_FAIL;
                    }
                }
            }
        }
    }

    return hr;
}


HRESULT XKTXOnlineLogon::NewMachine(
    IN CXoTest *pXOn, 
    IN Config &cfg, 
    IN char *szSerial, 
    IN char *szPassword, 
    OUT XONLINEP_USER *pUser)
{
    HRESULT hr = E_FAIL;

    XONLINEP_USER MachineAccount;
    if (!szSerial || !szPassword)
    {
        TestMsg(XKTVerbose_All, "Machine account information is incorrectly formatted.\n");
    }
    else
    {
        if ((hr = MakeAccountWithPassword(&MachineAccount, 1, szSerial, "", "", "macs.xbox.com", szPassword)) != S_OK)
        {
            TestMsg(XKTVerbose_All, "Machine account information is incorrectly formatted.\n");
        }
        else
        {
            XKERB_TGT_CONTEXT tkt;
            RtlZeroMemory(&tkt, sizeof(XKERB_TGT_CONTEXT));

            NTSTATUS Status = 0;
            DWORD dwXmacsIp = cfg.getIP("servers", "xmacs");
            USHORT usXmacsPort = cfg.getPort("servers", "xmacs");

            if ((hr = pXOn->SignInAccount_AS(dwXmacsIp, usXmacsPort, &MachineAccount, FALSE, &tkt, Status)) == S_OK)
            {
                // Fill in the account structure with the newly created account
                if (tkt.pAccountCreationPreAuth)
                {
                    hr = MakeAccountWithKey(
                        pUser, 
                        tkt.pAccountCreationPreAuth->qwUserID, 
                        tkt.pAccountCreationPreAuth->name, 
                        tkt.pAccountCreationPreAuth->kingdom, 
                        tkt.pAccountCreationPreAuth->domain, 
                        tkt.pAccountCreationPreAuth->realm, 
                        tkt.pAccountCreationPreAuth->key);

                    pXOn->SysFree(tkt.pAccountCreationPreAuth);
                }
            }
        }
    }

    return hr;
}

/*
HRESULT XKTXOnlineLogon::NewUser(
    IN CXoTest *pXOn, 
    IN Config &cfg, 
    IN char *szName, 
    OUT XONLINEP_USER *pUser)
{
    HRESULT hr = E_FAIL;

    Assert(szName);

    BYTE bKey[XONLINE_KEY_LENGTH];
    memset(bKey, 0, XONLINE_KEY_LENGTH);
    if ((hr = MakeAccountWithKey(pUser, 0, szName, "Feb2002", "", "", bKey)) != S_OK)
    {
        TestMsg(XKTVerbose_All, "User account information is incorrectly formatted.\n");
    }
    else
    {
        pUser->name[strlen(pUser->name)] = '-';
        for (INT i = strlen(pUser->name); i < XONLINE_NAME_SIZE - 1; i++)
        {
            char chRand = (char)(((float)(rand() * ('z' - 'a'))) / RAND_MAX) + 'a';
            pUser->name[i] = chRand;
        }
        pUser->name[i] = 0;
        hr = pXOn->UacsCreate(cfg.getIP("servers", "uacs"), pUser);
    }

    return hr;
}
*/

//Simulate XOnlineLogon
HRESULT XKTXOnlineLogon::runTest(IN CXoTest *pXOn, IN char *szSectionName, IN Config &cfg)
{
    HRESULT hr = S_OK;

    BOOL fUseCache = !cfg.getBool(szSectionName, "nocache");
    DWORD dwXkdcIp = cfg.getIP("servers", "xkdc");
    USHORT usXkdcPort = cfg.getPort("servers", "xkdc");

    INT cRepeats = max(cfg.getInt(szSectionName, "repeat"), 1);
    for (INT nCurRepeat = 0; nCurRepeat < cRepeats && SUCCEEDED(hr); nCurRepeat++)
    {
        hr = E_FAIL;

        XONLINEP_USER rgUsers[1 + XONLINE_MAX_LOGON_USERS];
        memset(rgUsers, 0, sizeof(XONLINEP_USER) * (1 + XONLINE_MAX_LOGON_USERS));

        char *szUserSection = cfg.getStr("general", "users");

        // Load user accounts from file and put them into rgUsers

        char **rgszUserAccountIndicators = NULL;
        INT cUsers;
        BOOL fUsersFound = cfg.getStrList(szSectionName, "users", &rgszUserAccountIndicators, cUsers);

        hr = S_OK;

        if (cUsers < 0 || cUsers > XONLINE_MAX_LOGON_USERS)
        {
            hr = E_INVALIDARG;
        }
        else
        {
            for (INT i = 0; i < cUsers; i++)
            {
                char *szUserInfo = cfg.getStr(szUserSection, rgszUserAccountIndicators[i]);

                if (!szUserInfo)
                {
                    TestMsg(XKTVerbose_All, "Failed to find user info for '%s'.\n", rgszUserAccountIndicators[i]);
                    hr = E_FAIL;
                }
                else
                {
                    hr = MakeAccountFromString(szUserInfo, &rgUsers[i]);

                    if (hr != S_OK)
                    {
                        TestMsg(XKTVerbose_All, "Failed to interpret user account '%s' from config file.\n", rgszUserAccountIndicators[i]);
                        break;
                    }
                }
            }
        }

        // Load machine account from file and put it into rgUsers

        if (hr == S_OK)
        {
            char *szMachineAccountIndicator = cfg.getStr(szSectionName, "machine");
            if (!szMachineAccountIndicator)
            {
                TestErrMsg(XKTVerbose_Process, "Failed to find valid machine account indicator.\n");
                hr = E_INVALIDARG;
            }
            else
            {
                char *szUserInfo = cfg.getStr(szUserSection, szMachineAccountIndicator);
                if (!szUserInfo)
                {
                    TestErrMsg(XKTVerbose_Process, "Failed to find machine info for %s.\n", szMachineAccountIndicator);
                    hr = E_INVALIDARG;
                }
                else
                {
                    if (strstr(szUserInfo, "newmachine") == szUserInfo)
                    {
                        hr = TicketCache::FindAccount(szMachineAccountIndicator, &rgUsers[cUsers]);
                        if (hr == S_FALSE)
                        {
                            char *szSerial = cfg.getStrListItem(szUserSection, szMachineAccountIndicator, 1);
                            char *szPassword = cfg.getStrListItem(szUserSection, szMachineAccountIndicator, 2);
                            hr = NewMachine(pXOn, cfg, szSerial, szPassword, &rgUsers[cUsers]);

                            if (hr != S_OK || TicketCache::AddAccount(szMachineAccountIndicator, &rgUsers[cUsers]) != S_OK)
                            {
                                TestMsg(XKTVerbose_All, "Failed to create new machine account '%s'.\n", szMachineAccountIndicator);
                                break;
                            }
                        }
                    }
                    else
                    {
                        Assert(cUsers >= 0 && cUsers <= XONLINE_MAX_LOGON_USERS);

                        hr = MakeAccountFromString(szUserInfo, &rgUsers[cUsers]);

                        if (hr != S_OK)
                        {
                            TestMsg(XKTVerbose_All, "Failed to interpret user account '%s' from config file.\n", szMachineAccountIndicator);
                            break;
                        }
                    }
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            XKERB_TGT_CONTEXT tkt;

            hr = TicketCache::FindTicket(rgUsers, &tkt);
            if (FAILED(hr))
            {
                TestErrMsg(XKTVerbose_Process, "Failed during ticket cache lookup.\n");
            }
            else
            {
                if (hr == S_FALSE || !fUseCache)
                {
                    // Get ticket from XKDC
                    memset(&tkt, 0, sizeof(XKERB_TGT_CONTEXT));

                    hr = S_OK;
                    for (INT i = 0; i < cUsers + 1; i++)
                    {
                        XKERB_TGT_CONTEXT tktPrev;
                        TestMsg(XKTVerbose_Process, "Requesting ticket for '%s.%s'.\n", rgUsers[i].name, rgUsers[i].kingdom);

                        NTSTATUS Status = 0;
                        // If i == cUsers then this account is the last account in the list and thus the machine account
                        if ((hr = pXOn->SignInAccount_AS(dwXkdcIp, usXkdcPort, &rgUsers[i], i == cUsers, &tkt, Status)) != S_OK)
                        {
                            TestMsg(XKTVerbose_Process, "Failed to sign in with account '%s.%s'.\n", rgUsers[i].name, rgUsers[i].kingdom);
                            hr = E_FAIL;
                            break;
                        }

                        if (i < cUsers)
                        {
                            memcpy(&tktPrev, &tkt, sizeof(XKERB_TGT_CONTEXT));
                            tktPrev.pInputTGTContext = NULL;
                            tkt.pInputTGTContext = &tktPrev;
                        }
                    }

                    if (hr == S_OK)
                    {
                        hr = TicketCache::AddTicket(rgUsers, &tkt);
                        if (FAILED(hr))
                        {
                            TestErrMsg(XKTVerbose_Process, "Failed to add ticket to cache.\n");
                        }
                    }
                }
            }

            if (SUCCEEDED(hr))
            {
                hr = SignInServices(pXOn, cfg, szSectionName, rgUsers, cUsers, &tkt);
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\xkdctest\xktxonlinelogon.h ===
#ifndef XKTXONLINELOGON_H
#define XKTXONLINELOGON_H

#include "xktest.h"

class XKTXOnlineLogon : public XKTest
{
public:
    virtual void getName(OUT char *sz) {strcpy(sz, "XOnlineLogon");}

    virtual HRESULT runTest(IN CXoTest *pXOn, IN char *szSectionName, IN Config &cfg);
private:
    HRESULT NewUser(
        IN CXoTest *pXOn, 
        IN Config &cfg, 
        IN char *szName, 
        OUT XONLINEP_USER *pUser);

    HRESULT NewMachine(
        IN CXoTest *pXOn, 
        IN Config &cfg, 
        IN char *szSerial, 
        IN char *szPassword, 
        OUT XONLINEP_USER *pUser);

    HRESULT VerifyServices(
        IN Config &cfg, 
        IN char *szSectionName, 
        IN XKERB_SERVICE_CONTEXT *pKerbServiceContext);
    
    HRESULT VerifyUserHRs(
        IN Config &cfg, 
        IN char *szSectionName, 
        IN XONLINEP_USER *rgAccounts);

    HRESULT SignInServices(
        IN CXoTest *pXOn, 
        IN Config &cfg, 
        IN char *szSectionName,
        IN XONLINEP_USER *rgUsers,
        IN INT cUsers,
        IN XKERB_TGT_CONTEXT *ptkt);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\xkdctest\xktxmacscreate.h ===
#ifndef XKTXMACSCREATE_H
#define XKTXMACSCREATE_H

#include "xktest.h"


class XKTXmacsCreate : public XKTest
{
public:
    virtual void getName(OUT char *sz) {strcpy(sz, "XmacsCreate");}
    virtual HRESULT runTest(IN CXoTest *xo, IN char *szSectionName, IN Config &cfg);

private:
    char *getStrX(Config &cfg, char *szSectionName, char *szItem, INT nIteration, INT nCreations);
    HRESULT MakeCreationAccount(IN char *szSectionName, IN Config &cfg, IN INT nIteration, IN INT nCreations, OUT XONLINEP_USER *pAccount);
    HRESULT VerifyCreate(IN CXoTest *xo, Config &cfg, XONLINEP_USER &MachineAccount, XKERB_TGT_CONTEXT &tgt);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\xodash\AudioTest\main.cpp ===
#include "std.h"

#include "XODash.h"


XOApplication  theApp;
void __cdecl main()
{
	theApp.Create();
	while (1)
	{
		theApp.Run();
	}

	theApp.Destroy();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\xodash\AudioTest\std.h ===
#ifdef _XBOX
#ifdef __cplusplus
extern "C" {
#endif // __cplusplus
#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>
#include <ntddcdrm.h>
#include <ntddscsi.h>
#include <ntddcdvd.h>
#include <smcdef.h>
#include <scsi.h>
#include <init.h>
#ifdef __cplusplus
}
#endif // __cplusplus
#include <dsoundp.h>
#include <xtl.h>
#include <xgraphics.h>
#include <xboxp.h>
#include <xapip.h>
#include <av.h>


#ifndef D3DLOCK_DISCARD
#define D3DLOCK_DISCARD 0
#endif

#endif

#ifdef _WINDOWS
#include <winsock2.h>
#include <windows.h>
#endif

#include <tchar.h>
typedef TCHAR* PTCHAR;

// "Filesystem" Character Type...What do *most* of the file system API's use...
#if defined(_XBOX)
typedef char FSCHAR;
#define _FS(s) s
#else
typedef TCHAR FSCHAR;
#define _FS(s) _T(s)
#endif

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include <math.h>

#include <crtdbg.h>

#if !defined(_NOD3D)
#define D3D_OVERLOADS
#include <d3d8.h>
#include <d3dx8.h>

#endif


////////////////////////////////////////////////////////////////////////////

#ifdef  __cplusplus

#define EXTERN_C extern "C"


#define RELEASENULL(object) { if ((object) != NULL) { (object)->Release(); (object) = NULL; } }

#else // !__cplusplus

#define EXTERN_C extern
#define bool BOOL
#define true TRUE
#define false FALSE
#define inline _inline

#endif

#define CopyChars(dest, src, count) CopyMemory(dest, src, (count) * sizeof (TCHAR))
#define countof(n) (sizeof (n) / sizeof (n[0]))


#ifdef _UNICODE
extern void Unicode(TCHAR* wsz, const char* sz, int nMaxChars);
extern void Ansi(char* sz, const TCHAR* wsz, int nMaxChars);
#endif

#undef ASSERT
#undef VERIFY
#undef ASSERTHR
#undef VERIFYHR
#undef TRACE
#undef ALERT

#ifdef _DEBUG

#define ASSERT(f)		if (!(f)) RtlAssert(#f, __FILE__, __LINE__, NULL)
#define VERIFY(f)		ASSERT(f)
#define ASSERTHR(f)		do { HRESULT hrverify = (f); if (FAILED(hrverify) && AssertFailed(_T(__FILE__), __LINE__, hrverify)) _CrtDbgBreak(); } while (0)
#define VERIFYHR(f)		ASSERTHR(f)
#define TRACE			Trace
#define ALERT			Alert

EXTERN_C bool AssertFailed(const TCHAR* szFile, int nLine, HRESULT hr);
EXTERN_C void Trace(const TCHAR* szMsg, ...);

#else // !_DEBUG

#define ASSERT(f)		((void)0)
#define VERIFY(f)		((void)(f))
#define ASSERTHR(f)		((void)0)
#define VERIFYHR(f)		((void)(f))
#define TRACE			1 ? (void)0 : Trace
#define ALERT			1 ? (void)0 : Alert

inline void Trace(const TCHAR* szMsg, ...) { }

#endif

EXTERN_C void Alert(const TCHAR* szMsg, ...);


////////////////////////////////////////////////////////////////////////////

#ifdef _XBOX
#include "xprofp.h"

#ifdef _PROFILE
#define START_PROFILE() XProfpControl(XPROF_START, 0)
#define END_PROFILE() XProfpControl(XPROF_STOP, 0)
#else
#define START_PROFILE()
#define END_PROFILE()
#endif
#else
#define START_PROFILE()
#define END_PROFILE()
#endif

////////////////////////////////////////////////////////////////////////////
// Stuff from Windows that Xbox should have...
//
/*
#ifdef _XBOX
typedef  PVOID           HDEVNOTIFY;

typedef struct tagRGBQUAD {
        BYTE    rgbBlue;
        BYTE    rgbGreen;
        BYTE    rgbRed;
        BYTE    rgbReserved;
} RGBQUAD;
typedef RGBQUAD FAR* LPRGBQUAD;

#define MAX_COMPUTERNAME_LENGTH 15 // REVIEW: What is this really?
#endif
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\xodash\AudioTest\XBResource.h ===
//-----------------------------------------------------------------------------
// File: XBResource.h
//
// Desc: Loads resources from an XPR (Xbox Packed Resource) file.  
//
// Hist: 03.12.01 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBRESOURCE_H
#define XBRESOURCE_H



//-----------------------------------------------------------------------------
// Name: XBResource_SizeOf()
// Desc: Determines the byte size of a D3DResource
//-----------------------------------------------------------------------------
DWORD XBResource_SizeOf( LPDIRECT3DRESOURCE8 pResource );





//-----------------------------------------------------------------------------
// Name: struct XBRESOURCE
// Desc: Name tag for resources. An app may initialize this structure, and pass
//       it to the resource's Create() function. From then on, the app may call
//       GetResource() to retrieve a resource using an ascii name.
//-----------------------------------------------------------------------------
struct XBRESOURCE
{
    CHAR* strName;
    DWORD dwOffset;
};





//-----------------------------------------------------------------------------
// Name: class CXBPackedResource
// Desc: 
//-----------------------------------------------------------------------------
class CXBPackedResource
{
protected:
    BYTE*       m_pSysMemData;    // Alloc'ed mem for resource headers etc.
    BYTE*       m_pVidMemData;    // Alloc'ed mem for resource data, etc.

    DWORD       m_dwNumResources; // Number of loaded resources
 
    XBRESOURCE* m_pResourceTags;  // Tags to associate names with the resources

public:
    // Loads the resources out of the specified bundle
    HRESULT Create( LPDIRECT3DDEVICE8 pd3dDevice, const CHAR* strFilename, 
                    DWORD dwNumResources, XBRESOURCE* pResourceTags = NULL );

    VOID Destroy();

    // Functions to retrieve resources by their offset
    VOID* GetData( DWORD dwOffset ) const
    { return &m_pSysMemData[dwOffset]; }

    LPDIRECT3DRESOURCE8 GetResource( DWORD dwOffset ) const
    { return (LPDIRECT3DRESOURCE8)GetData(dwOffset); }

    LPDIRECT3DTEXTURE8 GetTexture( DWORD dwOffset ) const
    { return (LPDIRECT3DTEXTURE8)GetData( dwOffset ); }

    LPDIRECT3DCUBETEXTURE8 GetCubemap( DWORD dwOffset ) const
    { return (LPDIRECT3DCUBETEXTURE8)GetData( dwOffset ); }

    LPDIRECT3DVOLUMETEXTURE8 GetVolumeTexture( DWORD dwOffset ) const
    { return (LPDIRECT3DVOLUMETEXTURE8)GetData( dwOffset ); }

    LPDIRECT3DVERTEXBUFFER8 GetVertexBuffer( DWORD dwOffset ) const
    { return (LPDIRECT3DVERTEXBUFFER8)GetData( dwOffset ); }

    // Functions to retrieve resources by their name
    VOID* GetData( const CHAR* strName ) const;

    LPDIRECT3DRESOURCE8 GetResource( const CHAR* strName ) const
    { return (LPDIRECT3DRESOURCE8)GetData( strName ); }

    LPDIRECT3DTEXTURE8 GetTexture( const CHAR* strName ) const
    { return (LPDIRECT3DTEXTURE8)GetResource( strName ); }

    LPDIRECT3DCUBETEXTURE8 GetCubemap( const CHAR* strName ) const
    { return (LPDIRECT3DCUBETEXTURE8)GetResource( strName ); }

    LPDIRECT3DVOLUMETEXTURE8 GetVolumeTexture( const CHAR* strName ) const
    { return (LPDIRECT3DVOLUMETEXTURE8)GetResource( strName ); }

    LPDIRECT3DVERTEXBUFFER8 GetVertexBuffer( const CHAR* strName ) const
    { return (LPDIRECT3DVERTEXBUFFER8)GetResource( strName ); }

    // Constructor/destructor
    CXBPackedResource();
    ~CXBPackedResource();
};




#endif XBRESOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\xodash\AudioTest\xbfont.h ===
//-----------------------------------------------------------------------------
// File: XBFont.h
//
// Desc: Texture-based font class. This class reads .abc font files that are
//       generated by the FontMaker tool. These .abc files are used to create
//       a texture with all the font's glyph, and also extract information on
//       the dimensions of each glyph.
//
//       Once created, this class is used to render text in a 3D scene with the
//       following function:
//          DrawText( fScreenY, fScreenSpaceY, dwTextColor, strText,
//                    dwJustificationFlags );
//
//       For performance, you can batch mulitple DrawText calls together
//       between Begin() and End() calls, as in the following example:
//          pFont->Begin();
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->End();
//
//       The size (extent) of the text can be computed without rendering with
//       the following function:
//          GetTextExtent( strText, pfReturnedWidth, pfReturnedHeight,
//                         bComputeExtentUsingFirstLineOnly );
//
//       Finally, the font class can create a texture to hold rendered text,
//       which is useful for static text that must be rendered for many
//       frames, or can even be used within a 3D scene. (For instance, for a
//       player's name on a jersey.) Use the following function for this:
//          CreateTexture( strText, d3dTextureFormat );
//
//       See the XDK docs for more information.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       02.18.01 - Changes for March XDK release
//       04.15.01 - Using packed resources for May XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBFONT_H
#define XBFONT_H
#include "XBResource.h"
#include "XBUtil.h"




//-----------------------------------------------------------------------------
// Number of vertex buffers for rendering text. Having this number be greater
// than 1 can reduce potential stalling of the GPU.
//-----------------------------------------------------------------------------
#define NUM_FONT_BUFFERS 2



//-----------------------------------------------------------------------------
// Flags for the CXBFont::DrawText() function
//-----------------------------------------------------------------------------
#define XBFONT_LEFT     0x00000000
#define XBFONT_RIGHT    0x00000001
#define XBFONT_CENTER_X 0x00000002
#define XBFONT_CENTER_Y 0x00000004




//-----------------------------------------------------------------------------
// Custom vertex type for rendering text
//-----------------------------------------------------------------------------
struct XBFONTVERTEX 
{ 
    D3DXVECTOR4 p;
    DWORD       color;
    FLOAT       tu, tv; 
};

#define D3DFVF_XBFONTVERTEX (D3DFVF_XYZRHW|D3DFVF_DIFFUSE|D3DFVF_TEX1)




//-----------------------------------------------------------------------------
// Name: struct GLYPH_ATTR
// Desc: Structure to hold information about one glyph (font character image)
//-----------------------------------------------------------------------------
struct GLYPH_ATTR
{
    FLOAT left, top, right, bottom; // Texture coordinates for the image
    SHORT wOffset;                  // Pixel offset for glyph start
    SHORT wWidth;                   // Pixel width of the glyph
    SHORT wAdvance;                 // Pixels to advance after the glyph
};




//-----------------------------------------------------------------------------
// Name: class CXBFont
// Desc: Class to implement texture-based font rendering. A .tga image file of 
//       the pre-rendered font is used to create the texture. A .abc file
//       contains information for spacing the font characters (aka glyphs).
//-----------------------------------------------------------------------------
class CXBFont
{
public:
    // Font and texture dimensions
    DWORD         m_dwFontHeight;
    DWORD         m_dwTexWidth;
    DWORD         m_dwTexHeight;

    // Unicode ranges
    WCHAR         m_cLowChar;
    WCHAR         m_cHighChar;

    // Glyph data for the font
    DWORD         m_dwNumGlyphs;
    GLYPH_ATTR*   m_Glyphs;

    // D3D rendering objects
    CXBPackedResource       m_xprResource;
    LPDIRECT3DDEVICE8       m_pd3dDevice;
    LPDIRECT3DTEXTURE8      m_pTexture;
    LPDIRECT3DVERTEXBUFFER8 m_pVBs[NUM_FONT_BUFFERS];
    LPDIRECT3DVERTEXBUFFER8 m_pVB;
    DWORD                   m_dwCurrentBuffer;
    XBFONTVERTEX*           m_pVertices;
    DWORD                   m_dwNumQuads;
    DWORD                   m_dwNestedBeginCount;
    BOOL                    m_bTextureFromFile;

    // Internal call to trigger rendering of the vertex buffer
    HRESULT Render();

    // Access functions for debugging purposes
    LPDIRECT3DTEXTURE8 GetTexture() const    { return m_pTexture; }
    DWORD              GetFontHeight() const { return m_dwFontHeight; }

public:
    // Constructor/destructor
    CXBFont();
    ~CXBFont();

    // Functions to create and destroy the internal objects
    HRESULT Create( LPDIRECT3DDEVICE8 pd3dDevice, 
                    const CHAR* strFontResourceFileName );
    HRESULT Destroy();

    // Replaces invalid (outside the valid glyph range) characters in a string
    VOID    ReplaceInvalidChars( WCHAR* strUpdate, WCHAR cReplacement ) const;

    // Returns the dimensions of a text string
    HRESULT GetTextExtent( const WCHAR* strText, FLOAT* pWidth, 
                           FLOAT* pHeight, BOOL bFirstLineOnly=FALSE ) const;

    // Function to create a texture containing rendered text
    LPDIRECT3DTEXTURE8 CreateTexture( const WCHAR* strText, 
                                      D3DCOLOR dwBackgroundColor = 0x00000000,
                                      D3DCOLOR dwTextColor = 0xffffffff,
                                      D3DFORMAT d3dFormat = D3DFMT_LIN_A8R8G8B8 );

    // Public calls to render text. Callers can simply call DrawText(), but for
    // performance, they should batch multople calls together, bracketed by 
    // calls to Begin() and End().
    HRESULT Begin();
    HRESULT DrawText( FLOAT sx, FLOAT sy, DWORD dwColor, 
                      const WCHAR* strText, DWORD dwFlags=0L );
    HRESULT End();
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\xodash\AudioTest\XBResource.cpp ===
//-----------------------------------------------------------------------------
// File: XBResource.cpp
//
// Desc: Loads resources from an XPR (Xbox Packed Resource) file.  
//
// Hist: 03.12.01 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "std.h"
#include <xtl.h>
#include <xgraphics.h>
#include <stdio.h>
#include "XBUtil.h"
#include "XBResource.h"




//-----------------------------------------------------------------------------
// Name: XBResource_SizeOf()
// Desc: Determines the byte size of a D3DResource
//-----------------------------------------------------------------------------
DWORD XBResource_SizeOf( LPDIRECT3DRESOURCE8 pResource )
{
    switch( pResource->GetType() )
    {
        case D3DRTYPE_TEXTURE:       return sizeof(D3DTexture);
        case D3DRTYPE_VOLUMETEXTURE: return sizeof(D3DVolumeTexture);
        case D3DRTYPE_CUBETEXTURE:   return sizeof(D3DCubeTexture);
        case D3DRTYPE_VERTEXBUFFER:  return sizeof(D3DVertexBuffer);
        case D3DRTYPE_INDEXBUFFER:   return sizeof(D3DIndexBuffer);
        case D3DRTYPE_PALETTE:       return sizeof(D3DPalette);
    }
    return 0;
}




//-----------------------------------------------------------------------------
// Name: CXBPackedResource()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBPackedResource::CXBPackedResource()
{
    m_pSysMemData    = NULL;
    m_pVidMemData    = NULL;
    m_dwNumResources = 0L;
    m_pResourceTags  = NULL;
}




//-----------------------------------------------------------------------------
// Name: ~CXBPackedResource()
// Desc: Destructor
//-----------------------------------------------------------------------------
CXBPackedResource::~CXBPackedResource()
{
    Destroy();
}




//-----------------------------------------------------------------------------
// Name: GetData()
// Desc: Loads all the texture resources from the given XPR.
//-----------------------------------------------------------------------------
VOID* CXBPackedResource::GetData( const CHAR* strName ) const
{
    if( NULL==m_pResourceTags || NULL==strName )
        return NULL;

    for( DWORD i=0; i<m_dwNumResources; i++ )
    {
        if( !_stricmp( strName, m_pResourceTags[i].strName ) )
            return &m_pSysMemData[m_pResourceTags[i].dwOffset];
    }

    return NULL;
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Loads all the texture resources from the given XPR.
//-----------------------------------------------------------------------------
HRESULT CXBPackedResource::Create( LPDIRECT3DDEVICE8 pd3dDevice, 
                                   const CHAR* strFilename, DWORD dwNumResources,
                                   XBRESOURCE* pResourceTags )
{
    // Find the media file
    CHAR strResourcePath[512];
    if( FAILED( XBUtil_FindMediaFile( strResourcePath, strFilename ) ) )
        return E_FAIL;

    // Open the fileto read the XPR headers
    FILE* file = fopen( strResourcePath, "rb" );
    if( NULL == file )
        return E_FAIL;

    // Read in and verify the XPR magic header
    XPR_HEADER xprh;
    fread( &xprh, sizeof(XPR_HEADER), 1, file );
    if( xprh.dwMagic != XPR_MAGIC_VALUE )
    {
        OutputDebugString( _T("Invalid Xbox Packed Resource (.xpr) file") );
        fclose( file );
        return E_INVALIDARG;
    }

    // Compute memory requirements
    DWORD dwSysMemDataSize = xprh.dwHeaderSize - sizeof(XPR_HEADER);
    DWORD dwVidMemDataSize = xprh.dwTotalSize - xprh.dwHeaderSize;

    // Allocate memory
    m_pSysMemData = new BYTE[dwSysMemDataSize];
    m_pVidMemData = (BYTE*)D3D_AllocContiguousMemory( dwVidMemDataSize, D3DTEXTURE_ALIGNMENT );

    // Read in the data from the file
    fread( m_pSysMemData, dwSysMemDataSize, 1, file );
    fread( m_pVidMemData, dwVidMemDataSize, 1, file );

    // Done with the file
    fclose( file );
    
    // Loop over resources, calling Register()
    BYTE* pData = m_pSysMemData;

    for( DWORD i = 0; i < dwNumResources; i++ )
    {
		// Check for userdata
		if( *((DWORD*)pData) & 0x80000000 )
		{
			DWORD dwType = ((DWORD*)pData)[0];
			DWORD dwSize = ((DWORD*)pData)[1];
			pData += 8;

			pData += dwSize;
		}
		else
		{
			// Get the resource
			LPDIRECT3DRESOURCE8 pResource = (LPDIRECT3DRESOURCE8)pData;
    
	        // Register the resource
		    pResource->Register( m_pVidMemData );
        
			// Advance the pointer
			pData += XBResource_SizeOf( pResource );
		}
    }

    // Finally, store number of resources and the resource tags
    m_dwNumResources = dwNumResources;
    m_pResourceTags  = pResourceTags;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Tears down the packed resource data
//-----------------------------------------------------------------------------
VOID CXBPackedResource::Destroy() 
{
    if( m_pSysMemData != NULL )
    {
        delete[] m_pSysMemData;
        m_pSysMemData = NULL;
    }
    if( m_pVidMemData != NULL )
    {
        D3D_FreeContiguousMemory( m_pVidMemData );
        m_pVidMemData = NULL;
    }
    m_dwNumResources = 0L;
    m_pResourceTags  = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\xodash\AudioTest\xbfont.cpp ===
//-----------------------------------------------------------------------------
// File: XBFont.cpp
//
// Desc: Texture-based font class. This class reads .abc font files that are
//       generated by the FontMaker tool. These .abc files are used to create
//       a texture with all the font's glyph, and also extract information on
//       the dimensions of each glyph.
//
//       Once created, this class is used to render text in a 3D scene with the
//       following function:
//          DrawText( fScreenY, fScreenSpaceY, dwTextColor, strText,
//                    dwJustificationFlags );
//
//       For performance, you can batch mulitple DrawText calls together
//       between Begin() and End() calls, as in the following example:
//          pFont->Begin();
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->End();
//
//       The size (extent) of the text can be computed without rendering with
//       the following function:
//          GetTextExtent( strText, pfReturnedWidth, pfReturnedHeight,
//                         bComputeExtentUsingFirstLineOnly );
//
//       Finally, the font class can create a texture to hold rendered text,
//       which is useful for static text that must be rendered for many
//       frames, or can even be used within a 3D scene. (For instance, for a
//       player's name on a jersey.) Use the following function for this:
//          CreateTexture( strText, d3dTextureFormat );
//
//       See the XDK docs for more information.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       02.18.01 - Changes for March XDK release
//       04.15.01 - Using packed resources for May XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "std.h"
#include <xtl.h>
#include <stdio.h>
#include "XBFont.h"




// Max size for the font class' vertex buffer
const DWORD XBFONT_MAX_VERTICES = 1024 * 4;

// Helper function to init a vertex
inline XBFONTVERTEX InitFontVertex( const D3DXVECTOR4& p, D3DCOLOR color,
                                    FLOAT tu, FLOAT tv )
{
    XBFONTVERTEX v;   
    v.p     = p;   
    v.color = color;   
    v.tu    = tu;   
    v.tv    = tv;
    return v;
}




//-----------------------------------------------------------------------------
// Name: CXBFont()
// Desc: Font class constructor.
//-----------------------------------------------------------------------------
CXBFont::CXBFont()
{
    m_pd3dDevice         = NULL;
    m_pTexture           = NULL;

    for( DWORD i=0; i<NUM_FONT_BUFFERS; i++ )
        m_pVBs[i] = NULL;
    m_pVB                = NULL;
    m_dwCurrentBuffer    = 0L;
    m_bTextureFromFile   = FALSE;

    m_pVertices          = NULL;
    m_dwNumQuads         = 0L;
    m_dwNestedBeginCount = 0L;

    m_dwFontHeight       = 36;
    m_dwTexWidth         = 64;
    m_dwTexHeight        = 64;

    m_cLowChar           = 0;
    m_cHighChar          = 0;

    m_dwNumGlyphs        = 0L;
    m_Glyphs             = NULL;
}




//-----------------------------------------------------------------------------
// Name: ~CXBFont()
// Desc: Font class destructor.
//-----------------------------------------------------------------------------
CXBFont::~CXBFont()
{
    Destroy();
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Create the font's internal objects (texture and array of glyph info)
//       using the image and information from two files.
//-----------------------------------------------------------------------------
HRESULT CXBFont::Create( LPDIRECT3DDEVICE8 pd3dDevice, 
                         const CHAR* strFontResourceFileName )
{
    HRESULT hr;

    // Store the device for use in member functions
    m_pd3dDevice = pd3dDevice;

    if( FAILED( m_xprResource.Create( m_pd3dDevice, strFontResourceFileName, 
                                      2 ) ) )
        return E_FAIL;

    m_pTexture = m_xprResource.GetTexture( 0UL );

    BYTE* pData = (BYTE*)m_xprResource.GetData( XBResource_SizeOf(m_pTexture) );
    DWORD dwResourceType = ((DWORD*)pData)[0];
    DWORD dwResourceSize = ((DWORD*)pData)[1];
    pData += 2*sizeof(DWORD);

    DWORD dwVersion = ((DWORD*)pData)[0];
    m_dwFontHeight  = ((DWORD*)pData)[1];
    m_dwTexWidth    = ((DWORD*)pData)[2];
    m_dwTexHeight   = ((DWORD*)pData)[3];
    DWORD dwBPP     = ((DWORD*)pData)[4];
    pData += 5*sizeof(DWORD);

    // Check version of file (to make sure it matches up with the FontMaker tool)
    if( dwVersion != 0x00000004 )
    {
        OutputDebugStringA( "XBFont: Incorrect version number on font file!\n" );
        return E_FAIL;
    }

    // Read the low and high char
    m_cLowChar  = ((WCHAR*)pData)[0];
    m_cHighChar = ((WCHAR*)pData)[1];
    pData += 2*sizeof(WCHAR);

    // Read the glyph attributes from the file
    m_Glyphs = (GLYPH_ATTR*)(pData+4);

    // Create vertex buffer for rendering text strings
    for( DWORD i=0; i<NUM_FONT_BUFFERS; i++ )
    {
        hr = pd3dDevice->CreateVertexBuffer( XBFONT_MAX_VERTICES*sizeof(XBFONTVERTEX),
                                             D3DUSAGE_WRITEONLY, 0L,
                                             D3DPOOL_DEFAULT, &m_pVBs[i] );
        if( FAILED(hr) )
            return hr;
    }

    // Assign a current vertex buffer
    m_dwCurrentBuffer = 0L;
    m_pVB = m_pVBs[m_dwCurrentBuffer];

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Destroys the font object
//-----------------------------------------------------------------------------
HRESULT CXBFont::Destroy()
{
    m_xprResource.Destroy();

    // Delete vertex buffers
    for( DWORD i=0; i<NUM_FONT_BUFFERS; i++ )
        SAFE_RELEASE( m_pVBs[i] );

    if( m_bTextureFromFile )
    {
        SAFE_RELEASE( m_pTexture );
        delete [] m_Glyphs;
    }

    m_pd3dDevice         = NULL;
    m_pTexture           = NULL;
    m_pVB                = NULL;
    m_dwCurrentBuffer    = 0L;
    m_bTextureFromFile   = FALSE;

    m_pVertices          = NULL;
    m_dwNumQuads         = 0L;
    m_dwNestedBeginCount = 0L;

    m_dwFontHeight       = 36;
    m_dwTexWidth         = 64;
    m_dwTexHeight        = 64;

    m_cLowChar           = 0;
    m_cHighChar          = 0;

    m_dwNumGlyphs        = 0L;
    m_Glyphs             = NULL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: GetTextExtent()
// Desc: Get the dimensions of a text string
//-----------------------------------------------------------------------------
HRESULT CXBFont::GetTextExtent( const WCHAR* strText, FLOAT* pWidth, 
                                FLOAT* pHeight, BOOL bFirstLineOnly ) const
{
    // Check parameters
    if( NULL==strText || NULL==pWidth || NULL==pHeight )
        return E_INVALIDARG;

    // Set default text extent in output parameters
    (*pWidth)   = 0.0f;
    (*pHeight)  = 0.0f;

    // Initialize counters that keep track of text extent
    FLOAT sx = 0.0f;
    FLOAT sy = (FLOAT)(m_dwFontHeight + 1);

    // Loop through each character and update text extent
    while( *strText )
    {
        WCHAR letter = *strText++;
        
        // Handle newline character
        if( letter == L'\n' )
        {
            if( bFirstLineOnly )
                return S_OK;
            sx  = 0.0f;
            sy += (FLOAT)(m_dwFontHeight + 1);
        }

        // Ignore unprintable characters
        if( letter<m_cLowChar || letter>m_cHighChar )
            continue;

        // Get text extent for this character's glyph
        GLYPH_ATTR* pGlyph = &m_Glyphs[letter - m_cLowChar];
        sx += pGlyph->wOffset;
        sx += pGlyph->wAdvance;

        // Store text extent of string in output parameters
        if( sx > (*pWidth) )   (*pWidth)  = sx;
        if( sy > (*pHeight) )  (*pHeight) = sy;
     }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Begin()
// Desc: Prepares the font vertex buffers for rendering.
//-----------------------------------------------------------------------------
HRESULT CXBFont::Begin()
{
    // Lock vertex buffer on the first call (allow nesting of begin/end calls)
    if( 0 == m_dwNestedBeginCount )
    {
        // Assign a current vertex buffer
        if( m_pVB->IsBusy() )
        {
            if( ++m_dwCurrentBuffer >= NUM_FONT_BUFFERS )
                m_dwCurrentBuffer = 0L;
            m_pVB = m_pVBs[m_dwCurrentBuffer];
        }

        // Lock the vertex buffer
        m_pVB->Lock( 0, 0, (BYTE**)&m_pVertices, 0L );
        m_dwNumQuads = 0;
    }

    // Keep track of the nested begin/end calls.
    m_dwNestedBeginCount++;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DrawText()
// Desc: Draws text as textured polygons
//-----------------------------------------------------------------------------
HRESULT CXBFont::DrawText( FLOAT fOriginX, FLOAT fOriginY, DWORD dwColor,
                           const WCHAR* strText, DWORD dwFlags )
{
    // Set up stuff (i.e. lock the vertex buffer) to prepare for drawing text
    Begin();

    // Set the starting screen position
    FLOAT sx = fOriginX;
    FLOAT sy = fOriginY;

    // If vertically centered, offset the starting sy value
    if( dwFlags & XBFONT_CENTER_Y )
    {
        FLOAT w, h;
        GetTextExtent( strText, &w, &h );
        sy = floorf( sy - h/2 );
    }

    // Set a flag so we can determine initial justification effects
    BOOL bStartingNewLine = TRUE;

    while( *strText )
    {
        // If starting text on a new line, determine justification effects
        if( bStartingNewLine )
        {
            if( dwFlags & (XBFONT_RIGHT|XBFONT_CENTER_X) )
            {
                // Get the extent of this line
                FLOAT w, h;
                GetTextExtent( strText, &w, &h, TRUE );

                // Offset this line's starting sx value
                if( dwFlags & XBFONT_RIGHT )
                    sx = floorf( fOriginX - w );
                if( dwFlags & XBFONT_CENTER_X )
                    sx = floorf( fOriginX - w/2 );
            }
            bStartingNewLine = FALSE;
        }

        // Get the current letter in the string
        WCHAR letter = *strText++;

        // Handle the newline character
        if( letter == L'\n' )
        {
            sx  = fOriginX;
            sy += m_dwFontHeight;
            bStartingNewLine = TRUE;
        }

        // Skip invalid characters
        if( letter<m_cLowChar || letter>m_cHighChar )
            continue;

        // Get the glyph for this character
        GLYPH_ATTR* pGlyph = &m_Glyphs[letter-m_cLowChar];

        // Setup the screen coordinates (note the 0.5f shift value which is to
        // align texel centers with pixel centers)
        sx += pGlyph->wOffset;
        FLOAT sx1 = sx - 0.5f;
        FLOAT sx2 = sx - 0.5f + ((FLOAT)pGlyph->wWidth + 1);
        FLOAT sy1 = sy - 0.5f;
        FLOAT sy2 = sy - 0.5f + ((FLOAT)m_dwFontHeight + 1);
        sx += pGlyph->wAdvance;

        // Setup the texture coordinates (note the fudge factor for converting
        // from integer texel values to floating point texture coords).
        FLOAT tx1 = ( pGlyph->left   * ( m_dwTexWidth-1) ) / m_dwTexWidth;
        FLOAT ty1 = ( pGlyph->top    * (m_dwTexHeight-1) ) / m_dwTexHeight;
        FLOAT tx2 = ( pGlyph->right  * ( m_dwTexWidth-1) ) / m_dwTexWidth;
        FLOAT ty2 = ( pGlyph->bottom * (m_dwTexHeight-1) ) / m_dwTexHeight;

        // Set up the vertices (1 quad = 2 triangles = 6 vertices)
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx1,sy2,0.0f,0.0f), dwColor, tx1, ty2 );
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx1,sy1,0.0f,0.0f), dwColor, tx1, ty1 );
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx2,sy1,0.0f,0.0f), dwColor, tx2, ty1 );
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx2,sy2,0.0f,0.0f), dwColor, tx2, ty2 );
        m_dwNumQuads++;

        // If the vertex buffer is full, render it. This will stall the GPU, so
        // we should sure that XBFONT_MAX_VERTICES is big enough.
        if( (m_dwNumQuads+1)*4 > XBFONT_MAX_VERTICES )
        {
            // Unlock, render, and relock the vertex buffer
            m_pVB->Unlock();
            Render();
            m_pVB->Lock( 0, 0, (BYTE**)&m_pVertices, 0L );
            m_dwNumQuads = 0L;
        }
    }

    // Call End() to complete the begin/end pair for drawing text
    End();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: End()
// Desc: Called after Begin(), this function triggers the rendering of the
//       vertex buffer contents filled during calls to DrawText().
//-----------------------------------------------------------------------------
HRESULT CXBFont::End()
{
    // Keep track of nested calls to begin/end.
    if( 0L == m_dwNestedBeginCount )
        return E_FAIL;
    if( --m_dwNestedBeginCount > 0 )
        return S_OK;
    
    // Unlock the vertex buffer
    m_pVB->Unlock();

    // Render the contents of the vertex buffer
    if( m_dwNumQuads > 0 )
        Render();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: The internal call to actually render the vertices.
//-----------------------------------------------------------------------------
HRESULT CXBFont::Render()
{
    // Set the necessary renderstates
    m_pd3dDevice->SetTexture( 0, m_pTexture );
    m_pd3dDevice->SetStreamSource( 0, m_pVB, sizeof(XBFONTVERTEX) );
    m_pd3dDevice->SetVertexShader( D3DFVF_XBFONTVERTEX );
    m_pd3dDevice->SetPixelShader( NULL );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,         D3DBLEND_SRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND,        D3DBLEND_INVSRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHAREF,         0x08 );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHAFUNC,        D3DCMP_GREATEREQUAL );
    m_pd3dDevice->SetRenderState( D3DRS_FILLMODE,         D3DFILL_SOLID );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,         D3DCULL_CCW );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGENABLE,        FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGTABLEMODE,     D3DFOG_NONE );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILENABLE,    FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_EDGEANTIALIAS,    FALSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXCOORDINDEX, 0 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_NONE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );

    // Render the vertex buffer
    m_pd3dDevice->DrawPrimitive( D3DPT_QUADLIST, 0, m_dwNumQuads );

    // We can restore state here, if we like. Unfortunately, for generic use,
    // it's hard to guess what state the app will want everything restored to.

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderToTexture()
// Desc: Creates a texture and renders a text string into it. The texture
//       format defaults to a 32-bit linear texture
//-----------------------------------------------------------------------------
LPDIRECT3DTEXTURE8 CXBFont::CreateTexture( const WCHAR* strText, 
                                           D3DCOLOR dwBackgroundColor, 
                                           D3DCOLOR dwTextColor, 
                                           D3DFORMAT d3dFormat )
{
    // Calculate texture dimensions
    FLOAT fTexWidth;
    FLOAT fTexHeight;
    GetTextExtent( strText, &fTexWidth, &fTexHeight );
    DWORD dwWidth  = (DWORD)fTexWidth;
    DWORD dwHeight = (DWORD)fTexHeight;

    switch( d3dFormat )
    {
        case D3DFMT_A8R8G8B8:
        case D3DFMT_X8R8G8B8:
        case D3DFMT_R5G6B5:
        case D3DFMT_X1R5G5B5:
            // For swizzled textures, make sure the dimensions are a power of two
            for( DWORD wmask=1; dwWidth&(dwWidth-1); wmask = (wmask<<1)+1 )
                dwWidth  = ( dwWidth + wmask ) & ~wmask;
            for( DWORD hmask=1; dwHeight&(dwHeight-1); hmask = (hmask<<1)+1 )
                dwHeight = ( dwHeight + hmask ) & ~hmask;
            break;

        case D3DFMT_LIN_A8R8G8B8:
        case D3DFMT_LIN_X8R8G8B8:
        case D3DFMT_LIN_R5G6B5:
        case D3DFMT_LIN_X1R5G5B5:
            // For linear textures, make sure the stride is a multiple of 64 bytes
            dwWidth  = ( dwWidth + 0x1f ) & ~0x1f;
            break;

        default:
            // All other formats are unsupported as render targets
            return NULL;
    }

    // Create the texture
    LPDIRECT3DTEXTURE8 pTexture;
    if( FAILED( m_pd3dDevice->CreateTexture( dwWidth, dwHeight, 1, 0L, d3dFormat, 
                                             D3DPOOL_DEFAULT, &pTexture ) ) )
        return NULL;
    
    // Get the current backbuffer and zbuffer
    LPDIRECT3DSURFACE8 pBackBuffer, pZBuffer;
    m_pd3dDevice->GetRenderTarget( &pBackBuffer );
    m_pd3dDevice->GetDepthStencilSurface( &pZBuffer );

    // Set the new texture as the render target
    LPDIRECT3DSURFACE8 pTextureSurface;
    pTexture->GetSurfaceLevel( 0, &pTextureSurface );
    D3DVIEWPORT8 vp = { 0, 0, dwWidth, dwHeight, 0.0f, 1.0f };
    m_pd3dDevice->SetRenderTarget( pTextureSurface, NULL );
    m_pd3dDevice->SetViewport( &vp );
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET, dwBackgroundColor, 1.0f, 0L );

    // Render the text
    DrawText( 0, 0, dwTextColor, strText, 0L );

    // Restore the rendertarget
    D3DVIEWPORT8 vpBackBuffer = { 0, 0, 640, 480, 0.0f, 1.0f };
    m_pd3dDevice->SetRenderTarget( pBackBuffer, pZBuffer );
    m_pd3dDevice->SetViewport( &vpBackBuffer );
    SAFE_RELEASE( pBackBuffer );
    SAFE_RELEASE( pZBuffer );
    SAFE_RELEASE( pTextureSurface );

    // Return the new texture
    return pTexture;
}




//-----------------------------------------------------------------------------
// Name: ReplaceInvalidChars()
// Desc: Replaces any character that does not have a glyph in the font with
//       the specified character value. Function is useful for replacing
//       invalid characters with the null "box" character.
//-----------------------------------------------------------------------------
VOID CXBFont::ReplaceInvalidChars( WCHAR* strUpdate, WCHAR cReplacement ) const
{
    // TCR 3-26 Unsupported Characters
    for( ; *strUpdate; ++strUpdate )
    {
        WCHAR cLetter = *strUpdate;
        if( cLetter == L'\n' )
            continue;
        if( cLetter < m_cLowChar || cLetter > m_cHighChar )
            *strUpdate = cReplacement;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\xodash\DashEntry\font.h ===
// Automatically generated by the bundler tool from Font.rdf

#define Font_NUM_RESOURCES 2UL

#define Font_Font_OFFSET 0UL
#define Font_FontData_OFFSET 20UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\xodash\DashEntry\Gamepad.h ===
// Automatically generated by the bundler tool from Gamepad.rdf

#define Gamepad_NUM_RESOURCES 1UL

#define Gamepad_GamepadTexture_OFFSET 0UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\xodash\TextTest\main.cpp ===
#include "std.h"
#include "XODash.h"


XOApplication  theApp;
void __cdecl main()
{
	theApp.Create();
	while (1)
	{
		theApp.Run();
	}

	theApp.Destroy();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\xodash\DashEntry\DashEntry.cpp ===
//-----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "std.h"
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <xgraphics.h>

#define ARRAYSIZE(a) (sizeof(a) / sizeof(a[0]))

// #include "xonp.h"
// #include "xonver.h"
#include "dm.h"
#include "xboxp.h"
#include "xlaunch.h"

static const OBJECT_STRING g_DDosDevicePrefix =  CONSTANT_OBJECT_STRING(OTEXT("\\??\\D:"));
static const CHAR g_szDVDDevicePrefix[] =        "\\Device\\Cdrom0";
static const int  g_cchDVDDevicePrefix =         ARRAYSIZE(g_szDVDDevicePrefix) - 1;


static wchar_t* EntryPoints[] = {
	L"Network Configuration",
	L"New Account Sign-up",
	L"Message Server delivery section",
	L"Online Menu",
	L"Forced Name Change (New pick name screen)",
	L"Forced Edit Billing (the Edit Billing menu of Account Management)",
	L"Subscription Agreement (Policy document)",
	L"Terms of Use (Policy document)",
	L"Code of Conduct (Policy document)",
	L"Privacy Statement (Policy document)",

};


static DWORD dwReasons[] = 
{
	XLD_LAUNCH_DASHBOARD_NETWORK_CONFIGURATION,	
	XLD_LAUNCH_DASHBOARD_NEW_ACCOUNT_SIGNUP,         
	XLD_LAUNCH_DASHBOARD_MESSAGE_SERVER_INFO,
	XLD_LAUNCH_DASHBOARD_ONLINE_MENU,	
	XLD_LAUNCH_DASHBOARD_FORCED_NAME_CHANGE,
	XLD_LAUNCH_DASHBOARD_FORCED_BILLING_EDIT,
	XLD_LAUNCH_DASHBOARD_POLICY_DOCUMENT,    
};

static DWORD dwParameter1s[] = 
{
	XLD_POLICY_SUBSCRIPTION_AGREEMENT,
	XLD_POLICY_TERMS_OF_USE,
	XLD_POLICY_CODE_OF_CONDUCT,
	XLD_POLICY_PRIVACY_STATEMENT
};

#define countof(n) (sizeof (n) / sizeof (n[0]))

// This function courtesy Jim Helm will reboot you to a private xbe on the hard drive without further ado
NTSTATUS WriteTitleInfoAndReboot(LPCSTR pszLaunchPath, LPCSTR pszDDrivePath,
    DWORD dwLaunchDataType, DWORD dwTitleId, PLAUNCH_DATA pLaunchData)
{
    extern PLAUNCH_DATA_PAGE *LaunchDataPage;
    NTSTATUS Status;
    LARGE_INTEGER ByteOffset;
    PSTR pszOutput;
    int cch;

    if (NULL == *LaunchDataPage)
    {
        *LaunchDataPage = (PLAUNCH_DATA_PAGE)MmAllocateContiguousMemory(PAGE_SIZE);
    }

    if (NULL == *LaunchDataPage)
    {
        return STATUS_NO_MEMORY;
    }

    MmPersistContiguousMemory(*LaunchDataPage, PAGE_SIZE, TRUE);

    if (!pszDDrivePath)

    {
        pszDDrivePath = "\\Device\\Cdrom0";
    }

    pszOutput = ((PLAUNCH_DATA_PAGE) *LaunchDataPage)->Header.szLaunchPath;

    ASSERT(PAGE_SIZE == sizeof(LAUNCH_DATA_PAGE));

    RtlZeroMemory(*LaunchDataPage, PAGE_SIZE);

    ((PLAUNCH_DATA_PAGE) *LaunchDataPage)->Header.dwLaunchDataType = dwLaunchDataType;
    ((PLAUNCH_DATA_PAGE) *LaunchDataPage)->Header.dwTitleId = dwTitleId;

    if (dwLaunchDataType != LDT_NONE)
    {
        memcpy(((PLAUNCH_DATA_PAGE) *LaunchDataPage)->LaunchData,
               pLaunchData,
               sizeof(((PLAUNCH_DATA_PAGE) *LaunchDataPage)->LaunchData));
    }

    if (NULL != pszLaunchPath)
    {
        if (lstrcmpiA(pszDDrivePath, "\\Device\\Harddisk0\\Partition2") == 0)
        {
            lstrcpynA(pszOutput, "\\Device\\Harddisk0\\Partition2\\",
                      ARRAYSIZE(((PLAUNCH_DATA_PAGE) *LaunchDataPage)->Header.szLaunchPath) - 1);

            cch = strlen(pszOutput);
            lstrcpynA(&(pszOutput[cch]),
                      pszLaunchPath,
                      ARRAYSIZE(((PLAUNCH_DATA_PAGE) *LaunchDataPage)->Header.szLaunchPath) - (cch));
        }
        else
        {
            lstrcpynA(pszOutput,
                      pszDDrivePath,
                      ARRAYSIZE(((PLAUNCH_DATA_PAGE) *LaunchDataPage)->Header.szLaunchPath) - 1);

            cch = strlen(pszOutput);
            pszOutput[cch++] = TITLE_PATH_DELIMITER;

            lstrcpynA(&(pszOutput[cch]),
                      pszLaunchPath,
                      ARRAYSIZE(((PLAUNCH_DATA_PAGE) *LaunchDataPage)->Header.szLaunchPath) - (cch));
        }
    }

    // Notify the debugger that we're about to reboot and then reboot
    DmTell(DMTELL_REBOOT, NULL);

    HalReturnToFirmware(HalQuickRebootRoutine);
    return Status;
}

 
//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
public:
    CXBoxSample();

    virtual HRESULT Initialize();
    virtual HRESULT Render();
    virtual HRESULT FrameMove();

    // Font and help
    CXBFont         m_Font;
private:
	int m_nActiveEntry;
  
};



//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}



//-----------------------------------------------------------------------------
// Name: CXBoxSample (constructor)
// Desc: Constructor for CXBoxSample class
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample() 
            :m_nActiveEntry(0), CXBApplication()
{

}



//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: Peforms initialization
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::Initialize()
{
    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    return S_OK;
}



const char cszXbeName[] = "xonlinedash.xbe";
const char cszXbePath[] = "\\Device\\Harddisk0\\Partition2";

//-----------------------------------------------------------------------------
// Name: FrameMove
// Desc: Performs per-frame updates
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::FrameMove()
{
	if(m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_DOWN ||
			m_DefaultGamepad.fY1 == -1)
	{
		m_nActiveEntry++; 
		m_nActiveEntry = m_nActiveEntry < countof(EntryPoints) ? m_nActiveEntry : 0;

	}

	if(m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_DPAD_UP ||
			m_DefaultGamepad.fY1 == 1)
	{
		m_nActiveEntry--; 
		m_nActiveEntry = m_nActiveEntry >= 0 ? m_nActiveEntry : 0;

	}

    if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_A ] )
    {
		LD_LAUNCH_DASHBOARD launchData;
		ZeroMemory( &launchData, sizeof( launchData ) );
		// are we in the boundaries of the array
		ASSERT(m_nActiveEntry < countof(dwReasons));

		launchData.dwReason = (m_nActiveEntry > 5)? dwReasons[5] :dwReasons[m_nActiveEntry];
		if(m_nActiveEntry > 5)
		{
			// are we in the boundaries of the array
			ASSERT((m_nActiveEntry - 6) < countof(dwParameter1s));
		}
		launchData.dwParameter1 = (m_nActiveEntry > 5)? dwParameter1s[m_nActiveEntry - 6] : 0; 
		launchData.dwContext = launchData.dwReason;		

		NTSTATUS status = WriteTitleInfoAndReboot( cszXbeName, cszXbePath, LDT_LAUNCH_DASHBOARD, 0xFFFE0000, (PLAUNCH_DATA)&launchData);
    }

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: Render
// Desc: Renders the scene
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::Render()
{
    // Clear the zbuffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x00000000, 1.0f, 0L );

    // Draw a gradient filled background
    RenderGradientBackground( 0xff404040, 0xff404080 );

    m_Font.Begin();

	float fYPos = 50.0f;

	for (int i = 0; i<countof(EntryPoints); i++)
	{
		
		m_Font.DrawText( 64,fYPos , i == m_nActiveEntry? 0xffff8080: 0xffffffff, EntryPoints[i]);
		fYPos += 30.0f;
	}

    m_Font.End();

    // Present the scene
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\xodash\AudioTest\xODash.h ===
//-----------------------------------------------------------------------------
// File: XODash.h
//
// Container for XOnline's dash.  Stolen from ATG
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBAPP_H
#define XBAPP_H

#include <xtl.h>
#include <xgraphics.h>
#include <stdio.h>
#include "XBInput.h"
#include "XBUtil.h"
#include "XBFont.h"

#include "audio.h"



//-----------------------------------------------------------------------------
// Global access to common members
//-----------------------------------------------------------------------------
extern LPDIRECT3DDEVICE8 g_pd3dDevice;




//-----------------------------------------------------------------------------
// Error codes
//-----------------------------------------------------------------------------
#define XBAPPERR_MEDIANOTFOUND       0x82000003




//-----------------------------------------------------------------------------
// Name: class XOApplication
// Desc: holds all really high level objects, sets up D3D
//          Initialize()          - To initialize the device-dependant objects
//          FrameMove()           - To animate the scene
//          Render()              - To render the scene
//-----------------------------------------------------------------------------
class XOApplication
{
protected:
    // Main objects used for creating and rendering the 3D scene
    D3DPRESENT_PARAMETERS m_d3dpp;
    LPDIRECT3D8           m_pD3D;              // The D3D enumerator object
    LPDIRECT3DDEVICE8     m_pd3dDevice;        // The D3D rendering device
    LPDIRECT3DSURFACE8    m_pBackBuffer;       // The backbuffer
    LPDIRECT3DSURFACE8    m_pDepthBuffer;      // The depthbuffer

    // Variables for timing
    FLOAT      m_fTime;             // Current absolute time in seconds
    FLOAT      m_fElapsedTime;      // Elapsed absolute time since last frame
    FLOAT      m_fAppTime;          // Current app time in seconds
    FLOAT      m_fElapsedAppTime;   // Elapsed app time since last frame
    BOOL       m_bPaused;           // Whether app time is paused by user
    FLOAT      m_fFPS;              // Instanteous frame rate
    WCHAR      m_strFrameRate[20];  // Frame rate written to a string
    HANDLE     m_hFrameCounter;     // Handle to framerate perf counter

	

    // Members to init the XINPUT devices.
    XDEVICE_PREALLOC_TYPE* m_InputDeviceTypes;
    DWORD                  m_dwNumInputDeviceTypes;
    XBGAMEPAD*             m_Gamepad;
    XBGAMEPAD              m_DefaultGamepad;


    // Helper functions
    HRESULT RenderGradientBackground( DWORD dwTopColor, DWORD dwBottomColor );

    // Overridable functions for the 3D scene created by the app
    virtual HRESULT Initialize();
    virtual HRESULT FrameMove();
    virtual HRESULT Render();
    virtual HRESULT Cleanup();
	HRESULT Update();

public:

	TCHAR					m_szAppDir[MAX_PATH];

    // Functions to create, run, and clean up the application
    HRESULT Create();
    INT     Run();
    VOID    Destroy();

    // Internal constructor
    XOApplication();

	float	GetTime(){ return m_fAppTime; }
private:
	CXBFont     m_Font;
	CAudioClip m_AudioClip;
	int m_nCurrentFile;
	void DiscDrive_Init();
};


extern XOApplication	theApp; // the single instance


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\xodash\AudioTest\XODash.cpp ===
//-----------------------------------------------------------------------------
// File: XBApp.cpp
//
// Desc: Application class for the XBox samples.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       12.19.01 - Changes for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "std.h"
#include "XODash.h"

#include "XOConst.h"
#include "utilities.h"
#include "DSoundManager.h"
#include "ntiosvc.h"


//-----------------------------------------------------------------------------
// Global access to common members
//-----------------------------------------------------------------------------
XOApplication*    g_pXBApp     = NULL;
LPDIRECT3DDEVICE8  g_pd3dDevice = NULL;
DSoundManager* g_pDSoundManager = NULL;
CNtIoctlCdromService g_cdrom;
int g_nDiscType = eDiscNone;


float* g_fAppTime = 0;
TCHAR* g_szAppDir = NULL;

static TCHAR* szInputFiles[] = 
{			_T("cd:1"),
			_T("d:\\media\\8k16bs.wav"),
			_T("d:\\media\\becky.wma"),
			
			
	
		};
int nNumOfFiles = countof( szInputFiles);


//-----------------------------------------------------------------------------
// Name: XOApplication()
// Desc: Constructor
//-----------------------------------------------------------------------------
XOApplication::XOApplication()
{
    // Initialize member variables
    g_pXBApp          = this;

    // Direct3D variables
    m_pD3D            = NULL;
    m_pd3dDevice      = NULL;
    m_pDepthBuffer    = NULL;
    m_pBackBuffer     = NULL;

    // Variables to perform app timing
    m_bPaused         = FALSE;
    m_fTime           = 0.0f;
    m_fElapsedTime    = 0.0f;
    m_fAppTime        = 0.0f;
    m_fElapsedAppTime = 0.0f;
    m_fFPS            = 0.0f;
    m_strFrameRate[0] = L'\0';

    // Set up the presentation parameters for a double-bufferd, 640x480,
    // 32-bit display using depth-stencil. Override these parameters in
    // your derived class as your app requires.
    ZeroMemory( &m_d3dpp, sizeof(m_d3dpp) );
    m_d3dpp.BackBufferWidth        = 640;
    m_d3dpp.BackBufferHeight       = 480;
    m_d3dpp.BackBufferFormat       = D3DFMT_A8R8G8B8;
    m_d3dpp.BackBufferCount        = 1;
    m_d3dpp.EnableAutoDepthStencil = TRUE;
    m_d3dpp.AutoDepthStencilFormat = D3DFMT_D24S8;
    m_d3dpp.SwapEffect             = D3DSWAPEFFECT_DISCARD;

    // Specify number and type of input devices this app will be using. By
    // default, you can use 0 and NULL, which triggers XInputDevices() to
    // prealloc the default number and types of devices. To use chat or
    // other devices, override these variables in your derived class.
    m_dwNumInputDeviceTypes = 0;
    m_InputDeviceTypes      = NULL;
	g_fAppTime = &m_fAppTime;
	g_szAppDir = m_szAppDir;

	m_nCurrentFile = 0;
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Create the app
//-----------------------------------------------------------------------------
HRESULT XOApplication::Create()
{
    HRESULT hr;

    // Create the Direct3D object
    DbgPrint("XBApp: Creating Direct3D...\n");
    if( NULL == ( m_pD3D = Direct3DCreate8(D3D_SDK_VERSION) ) )
    {
        DbgPrint("XBApp: Unable to create Direct3D!\n");
        return E_FAIL;
    }

    // Create the device
    DbgPrint( "XBApp: Creating the D3D device...\n" );
    if( FAILED( hr = m_pD3D->CreateDevice( 0, D3DDEVTYPE_HAL, NULL, 
                                           D3DCREATE_HARDWARE_VERTEXPROCESSING, 
                                           &m_d3dpp, &m_pd3dDevice ) ) )
    {
        DbgPrint( "XBApp: Could not create D3D device!\n" );
        return hr;
    }

    // Allow global access to the device
    g_pd3dDevice = m_pd3dDevice;

    // Store pointers to the depth and back buffers
    m_pd3dDevice->GetDepthStencilSurface( &m_pDepthBuffer );
    m_pd3dDevice->GetBackBuffer( 0, 0, &m_pBackBuffer );

    // Initialize core peripheral port support. Note: If these parameters
    // are 0 and NULL, respectively, then the default number and types of 
    // controllers will be initialized.
    XInitDevices( m_dwNumInputDeviceTypes, m_InputDeviceTypes );

    // Create the gamepad devices
    DbgPrint( "XBApp: Creating gamepad devices...\n");
    if( FAILED( hr = XBInput_CreateGamepads( &m_Gamepad ) ) )
    {
        DbgPrint( "XBApp: Call to CreateGamepads() failed!\n" );
        return hr;
    }

    // Initialize the app's device-dependent objects
    DbgPrint("XBApp: Initializing the app...\n");
    if( FAILED( hr = Initialize() ) )
    {
        DbgPrint( "XBApp: Call to Initialize() failed!\n");
        return hr;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Cleanup objects
//-----------------------------------------------------------------------------
VOID XOApplication::Destroy()
{
    // Perform app-specific cleanup
    Cleanup();

	DSoundManager::Instance()->Cleanup();
    // Release display objects
    SAFE_RELEASE( m_pd3dDevice );
    SAFE_RELEASE( m_pD3D );
}




//-----------------------------------------------------------------------------
// Name: Run()
// Desc: 
//-----------------------------------------------------------------------------
INT XOApplication::Run()
{
    DbgPrint("XBApp: Running the application...\n");
	
	HRESULT hr;
    // Run the game loop, animating and rendering frames
    while( TRUE )
    {
    
        //-----------------------------------------
        // Animate and render a frame
        //-----------------------------------------
		
		hr = Update();
        // Frame move the scene
        FrameMove();

        // Render the scene
        Render();

        // Finally, show the frame (swaps the backbuffer to the front)
        m_pd3dDevice->Present( NULL, NULL, NULL, NULL );
    }

    return 0;
}



HRESULT XOApplication::Update()
{
	HRESULT hr = S_OK;
	// Get the frequency of the timer
    LARGE_INTEGER qwTicksPerSec;
    QueryPerformanceFrequency( &qwTicksPerSec );
    FLOAT fSecsPerTick = 1.0f / (FLOAT)qwTicksPerSec.QuadPart;

    // Save the start time
    LARGE_INTEGER qwTime, qwLastTime, qwElapsedTime;
    QueryPerformanceCounter( &qwTime );
    qwLastTime.QuadPart = qwTime.QuadPart;

    LARGE_INTEGER qwAppTime, qwElapsedAppTime;
    qwAppTime.QuadPart        = 0;
    qwElapsedTime.QuadPart    = 0;
    qwElapsedAppTime.QuadPart = 0;
    //-----------------------------------------
        // Handle input
        //-----------------------------------------

        // Read the input for all connected gampads
        XBInput_GetInput( m_Gamepad );

        // Lump inputs of all connected gamepads into one common structure.
        // This is done so apps that need only one gamepad can function with
        // any gamepad.
        ZeroMemory( &m_DefaultGamepad, sizeof(m_DefaultGamepad) );
        for( DWORD i=0; i<4; i++ )
        {
            if( m_Gamepad[i].hDevice )
            {
                m_DefaultGamepad.sThumbLX += m_Gamepad[i].sThumbLX;
                m_DefaultGamepad.sThumbLY += m_Gamepad[i].sThumbLY;
                m_DefaultGamepad.sThumbRX += m_Gamepad[i].sThumbRX;
                m_DefaultGamepad.sThumbRY += m_Gamepad[i].sThumbRY;
                m_DefaultGamepad.fX1      += m_Gamepad[i].fX1;
                m_DefaultGamepad.fY1      += m_Gamepad[i].fY1;
                m_DefaultGamepad.fX2      += m_Gamepad[i].fX2;
                m_DefaultGamepad.fY2      += m_Gamepad[i].fY2;
                m_DefaultGamepad.wButtons        |= m_Gamepad[i].wButtons;
                m_DefaultGamepad.wPressedButtons |= m_Gamepad[i].wPressedButtons;
                m_DefaultGamepad.wLastButtons    |= m_Gamepad[i].wLastButtons;

                for( DWORD b=0; b<8; b++ )
                {
                    m_DefaultGamepad.bAnalogButtons[b]        |= m_Gamepad[i].bAnalogButtons[b];
                    m_DefaultGamepad.bPressedAnalogButtons[b] |= m_Gamepad[i].bPressedAnalogButtons[b];
                    m_DefaultGamepad.bLastAnalogButtons[b]    |= m_Gamepad[i].bLastAnalogButtons[b];
                }
            }
        }

        // Handle special input combo to trigger a reboot to the Xbox Dashboard
        if( m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] > 0 )
        {
            if( m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] > 0 )
            {
                if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_BLACK] )
                    XLaunchNewImage( NULL, NULL );
            }
        }

        //-----------------------------------------
        // Perform app timing
        //-----------------------------------------

        // Check Start button
        if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_START )
            m_bPaused = !m_bPaused;

        // Get the current time (keep in LARGE_INTEGER format for precision)
        QueryPerformanceCounter( &qwTime );
        qwElapsedTime.QuadPart = qwTime.QuadPart - qwLastTime.QuadPart;
        qwLastTime.QuadPart    = qwTime.QuadPart;
        if( m_bPaused )
            qwElapsedAppTime.QuadPart = 0;
        else
            qwElapsedAppTime.QuadPart = qwElapsedTime.QuadPart;
        qwAppTime.QuadPart    += qwElapsedAppTime.QuadPart;

        // Store the current time values as floating point
        m_fTime           = fSecsPerTick * ((FLOAT)(qwTime.QuadPart));
        m_fElapsedTime    = fSecsPerTick * ((FLOAT)(qwElapsedTime.QuadPart));
        m_fAppTime        = fSecsPerTick * ((FLOAT)(qwAppTime.QuadPart));
        m_fElapsedAppTime = fSecsPerTick * ((FLOAT)(qwElapsedAppTime.QuadPart));

        // Compute the FPS (frames per second) once per second
        static FLOAT fLastTime = 0.0f;
        static DWORD dwFrames  = 0L;
        dwFrames++;

        if( m_fTime - fLastTime > 1.0f )
        {
            m_fFPS    = dwFrames / ( m_fTime - fLastTime );
            fLastTime = m_fTime;
            dwFrames  = 0L;
            swprintf( m_strFrameRate, L"%0.02f fps", m_fFPS );
        }
		return hr;
}

//-----------------------------------------------------------------------------
// Name: RenderGradientBackground()
// Desc: Draws a gradient filled background
//-----------------------------------------------------------------------------
HRESULT XOApplication::RenderGradientBackground( DWORD dwTopColor, 
                                                  DWORD dwBottomColor )
{
    // First time around, allocate a vertex buffer
    static LPDIRECT3DVERTEXBUFFER8 g_pVB  = NULL;
    if( g_pVB == NULL )
    {
        m_pd3dDevice->CreateVertexBuffer( 4*5*sizeof(FLOAT), D3DUSAGE_WRITEONLY, 
                                          0L, D3DPOOL_DEFAULT, &g_pVB );
        struct BACKGROUNDVERTEX { D3DXVECTOR4 p; D3DCOLOR color; };
        BACKGROUNDVERTEX* v;
        g_pVB->Lock( 0, 0, (BYTE**)&v, 0L );
        v[0].p = D3DXVECTOR4(   0,   0, 1.0f, 1.0f ); v[0].color = dwTopColor;
        v[1].p = D3DXVECTOR4( 640,   0, 1.0f, 1.0f ); v[1].color = dwTopColor;
        v[2].p = D3DXVECTOR4(   0, 480, 1.0f, 1.0f ); v[2].color = dwBottomColor;
        v[3].p = D3DXVECTOR4( 640, 480, 1.0f, 1.0f ); v[3].color = dwBottomColor;
        g_pVB->Unlock();
    }

    // Set states
    m_pd3dDevice->SetTexture( 0, NULL );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE ); 
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE ); 
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_DIFFUSE );
    m_pd3dDevice->SetStreamSource( 0, g_pVB, 5*sizeof(FLOAT) );

    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

    // Clear the zbuffer
    m_pd3dDevice->Clear( 0, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 0x00000000, 1.0f, 0L );

    return S_OK;
}

HRESULT XOApplication::Cleanup()
{
	m_AudioClip.Cleanup();

	return 0;
}

HRESULT XOApplication::Render()
{
	if ( m_pd3dDevice )
	{
	
		m_pd3dDevice->BeginScene();

		// Clear the backbuffer 
		m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, 
                         D3DCOLOR_XRGB( (int)0, (int)0, (int)0 ), 1.0f, 0L );
//////////////
    // Draw a gradient filled background
    RenderGradientBackground( 0xff404040, 0xff404080 );

        m_Font.Begin();
        m_Font.DrawText(  64, 50, 0xffffffff, L"BackgroundMusic" );
  /*      m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );

        WCHAR szSoundtrack[ MAX_SOUNDTRACK_NAME ];
        WCHAR szSong[ MAX_SONG_NAME ];
        DWORD dwLength;
        WCHAR sz[100];

        // Get information about what song/soundtrack is currently selected
        m_pMusicManager->GetCurrentInfo( szSoundtrack, szSong, &dwLength );
        swprintf( sz, L"Soundtrack: %s", szSoundtrack );
        m_Font.DrawText( 64, 80, 0xffffffff, sz );

        swprintf( sz, L"Song: %s", szSong );
        m_Font.DrawText( 64, 110, 0xffffffff, sz );

        FLOAT fPos = m_pMusicManager->GetPlaybackPosition();
        swprintf( sz, L"Position: %02d:%02d / %02d:%02d", DWORD(fPos / 60), 
                                                          (DWORD)fPos % 60, 
                                                          ( dwLength / 60000 ), 
                                                          ( dwLength / 1000 ) % 60 );
        m_Font.DrawText( 64, 140, m_pMusicManager->GetStatus() == MM_PLAYING ? 0xffffffff : 0xff808080, sz );

        swprintf( sz, L"Mode: %s %s", m_pMusicManager->GetRandom() ? L"Random" : L"Sequential", 
                                      m_pMusicManager->GetGlobal() ? L"Global" : L"Local" );
        m_Font.DrawText( 64, 170, 0xffffff00, sz );

        swprintf( sz, L"Volume %ddB", m_pMusicManager->GetVolume() / 100 );
        m_Font.DrawText( 64, 200, 0xffffff00, sz );
            
*/
        m_Font.End();
		static bool bStartedPlay = false;
		if(!bStartedPlay )
		{
			m_AudioClip.Play();
		}
		bStartedPlay = true;
/////////////
		m_pd3dDevice->EndScene();
	}

	return S_OK;
}


HRESULT XOApplication::FrameMove()
{
	if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_B ] )
    {
        m_AudioClip.PlayOrPause();
	}

	if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_X ] )
    {
        m_AudioClip.Stop();
	}
	if( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_A] )
    {
        m_AudioClip.Play();
	}
	if (m_DefaultGamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP)
	{
		m_AudioClip.Stop();
		m_nCurrentFile--;
		if(m_nCurrentFile < 0 )
		{
			m_nCurrentFile = 0;
		}
		m_AudioClip.m_url = szInputFiles[m_nCurrentFile];
		m_AudioClip.Play();
	}
	
	if (m_DefaultGamepad.wButtons & XINPUT_GAMEPAD_DPAD_DOWN)
	{
		m_AudioClip.Stop();
		m_nCurrentFile++;
		if(m_nCurrentFile >= nNumOfFiles)
		{
			m_nCurrentFile = 0;
		}

		m_AudioClip.m_url = szInputFiles[m_nCurrentFile];
		m_AudioClip.Play();
	}

    return S_OK;
}


HRESULT XOApplication::Initialize()
{
	HRESULT hr = S_OK;
	do 
	{
		if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
		{
			hr = XBAPPERR_MEDIANOTFOUND;
		}

		
		DiscDrive_Init();
		g_pDSoundManager = DSoundManager::Instance();
		if(!g_pDSoundManager)
		{
			DbgPrint("XOApplication::Initialize() fail to create DSoundManager");
			hr = E_OUTOFMEMORY;
			break;
		}
		hr = g_pDSoundManager->Initialize();
		if(FAILED(hr))
		{
			DbgPrint("XOApplication::Initialize() fail to init DSound");
			break;
		}

		m_AudioClip.m_url = szInputFiles[m_nCurrentFile];

		m_AudioClip.m_volume = 1.00f;
		m_AudioClip.Initialize();
	
	}while (0);

	return hr;
}

int GetDiscType();
void XOApplication::DiscDrive_Init()
{
    g_cdrom.Open(1);
    g_nDiscType = GetDiscType();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\xvchat\makefile.inc ===
!include "..\..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\xodash\TextTest\XODash.cpp ===
//-----------------------------------------------------------------------------
// File: XBApp.cpp
//
// Desc: Application class for the XBox samples.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       12.19.01 - Changes for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------


#include "std.h"

#include "XODash.h"


#include "utilities.h"
#include "XOConst.h"

#include "Translator.h"
#include "SmartObject.h"


//-----------------------------------------------------------------------------
// Global access to common members
//-----------------------------------------------------------------------------
XOApplication*    g_pXBApp     = NULL;
LPDIRECT3DDEVICE8  g_pd3dDevice = NULL;

float* g_fAppTime = 0;
TCHAR* g_szAppDir = NULL;

void Text_Exit();
//-----------------------------------------------------------------------------
// Name: XOApplication()
// Desc: Constructor
//-----------------------------------------------------------------------------
XOApplication::XOApplication()
{
    // Initialize member variables
    g_pXBApp          = this;

    // Direct3D variables
    m_pD3D            = NULL;
    m_pd3dDevice      = NULL;
    m_pDepthBuffer    = NULL;
    m_pBackBuffer     = NULL;

    // Variables to perform app timing
    m_fTime           = 0.0f;
    m_fElapsedTime    = 0.0f;

    m_fFPS            = 0.0f;
    m_strFrameRate[0] = L'\0';

    // Set up the presentation parameters for a double-bufferd, 640x480,
    // 32-bit display using depth-stencil. Override these parameters in
    // your derived class as your app requires.
    ZeroMemory( &m_d3dpp, sizeof(m_d3dpp) );
    m_d3dpp.BackBufferWidth        = 640;
    m_d3dpp.BackBufferHeight       = 480;
    m_d3dpp.BackBufferFormat       = D3DFMT_A8R8G8B8;
    m_d3dpp.BackBufferCount        = 1;
    m_d3dpp.EnableAutoDepthStencil = TRUE;
    m_d3dpp.AutoDepthStencilFormat = D3DFMT_D24S8;
    m_d3dpp.SwapEffect             = D3DSWAPEFFECT_DISCARD;

    // Specify number and type of input devices this app will be using. By
    // default, you can use 0 and NULL, which triggers XInputDevices() to
    // prealloc the default number and types of devices. To use chat or
    // other devices, override these variables in your derived class.
    m_dwNumInputDeviceTypes = 0;
    m_InputDeviceTypes      = NULL;
	g_fAppTime = &m_fTime;
	
    _tcscpy (m_szAppDir, _T("D:\\"));
	g_szAppDir = m_szAppDir;

	m_fLastChangeLanguge = 0.0f;
	m_nCurLanguage = 0;
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Create the app
//-----------------------------------------------------------------------------
HRESULT XOApplication::Create()
{
    HRESULT hr;

    // Create the Direct3D object
    DbgPrint( "XBApp: Creating Direct3D...\n" );
    if( NULL == ( m_pD3D = Direct3DCreate8(D3D_SDK_VERSION) ) )
    {
        DbgPrint( "XBApp: Unable to create Direct3D!\n");
        return E_FAIL;
    }

    // Create the device
    DbgPrint( "XBApp: Creating the D3D device...\n");
    if( FAILED( hr = m_pD3D->CreateDevice( 0, D3DDEVTYPE_HAL, NULL, 
                                           D3DCREATE_HARDWARE_VERTEXPROCESSING, 
                                           &m_d3dpp, &m_pd3dDevice ) ) )
    {
        DbgPrint( "XBApp: Could not create D3D device!\n");
        return hr;
    }

    // Allow global access to the device
    g_pd3dDevice = m_pd3dDevice;

    // Store pointers to the depth and back buffers
    m_pd3dDevice->GetDepthStencilSurface( &m_pDepthBuffer );
    m_pd3dDevice->GetBackBuffer( 0, 0, &m_pBackBuffer );

    // Initialize core peripheral port support. Note: If these parameters
    // are 0 and NULL, respectively, then the default number and types of 
    // controllers will be initialized.
    XInitDevices( m_dwNumInputDeviceTypes, m_InputDeviceTypes );

    // Create the gamepad devices
    DbgPrint( "XBApp: Creating gamepad devices...\n");
    if( FAILED( hr = XBInput_CreateGamepads( &m_Gamepad ) ) )
    {
        DbgPrint( "XBApp: Call to CreateGamepads() failed!\n" );
        return hr;
    }

    // Initialize the app's device-dependent objects
    DbgPrint("XBApp: Initializing the app...\n");
    if( FAILED( hr = Initialize() ) )
    {
        DbgPrint("XBApp: Call to Initialize() failed!\n" );
        return hr;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Cleanup objects
//-----------------------------------------------------------------------------
VOID XOApplication::Destroy()
{
    // Perform app-specific cleanup
    Cleanup();

    // Release display objects
    SAFE_RELEASE( m_pd3dDevice );
    SAFE_RELEASE( m_pD3D );
}




//-----------------------------------------------------------------------------
// Name: Run()
// Desc: 
//-----------------------------------------------------------------------------
INT XOApplication::Run()
{
    DbgPrint("XBApp: Running the application...\n");
	
	HRESULT hr;
    // Run the game loop, animating and rendering frames
    while( TRUE )
    {
    
        //-----------------------------------------
        // Animate and render a frame
        //-----------------------------------------
		
		hr = Update();
        // Frame move the scene
        FrameMove();

        // Render the scene
        Render();

        // Finally, show the frame (swaps the backbuffer to the front)
        m_pd3dDevice->Present( NULL, NULL, NULL, NULL );
    }

    return 0;
}



HRESULT XOApplication::Update()
{
	HRESULT hr = S_OK;
    
    //-----------------------------------------
        // Handle input
        //-----------------------------------------

        // Read the input for all connected gampads
        XBInput_GetInput( m_Gamepad );

        // Lump inputs of all connected gamepads into one common structure.
        // This is done so apps that need only one gamepad can function with
        // any gamepad.
        ZeroMemory( &m_DefaultGamepad, sizeof(m_DefaultGamepad) );
        for( DWORD i=0; i<4; i++ )
        {
            if( m_Gamepad[i].hDevice )
            {
                m_DefaultGamepad.sThumbLX += m_Gamepad[i].sThumbLX;
                m_DefaultGamepad.sThumbLY += m_Gamepad[i].sThumbLY;
                m_DefaultGamepad.sThumbRX += m_Gamepad[i].sThumbRX;
                m_DefaultGamepad.sThumbRY += m_Gamepad[i].sThumbRY;
                m_DefaultGamepad.fX1      += m_Gamepad[i].fX1;
                m_DefaultGamepad.fY1      += m_Gamepad[i].fY1;
                m_DefaultGamepad.fX2      += m_Gamepad[i].fX2;
                m_DefaultGamepad.fY2      += m_Gamepad[i].fY2;
                m_DefaultGamepad.wButtons        |= m_Gamepad[i].wButtons;
                m_DefaultGamepad.wPressedButtons |= m_Gamepad[i].wPressedButtons;
                m_DefaultGamepad.wLastButtons    |= m_Gamepad[i].wLastButtons;

                for( DWORD b=0; b<8; b++ )
                {
                    m_DefaultGamepad.bAnalogButtons[b]        |= m_Gamepad[i].bAnalogButtons[b];
                    m_DefaultGamepad.bPressedAnalogButtons[b] |= m_Gamepad[i].bPressedAnalogButtons[b];
                    m_DefaultGamepad.bLastAnalogButtons[b]    |= m_Gamepad[i].bLastAnalogButtons[b];
                }
            }
        }

        // Handle special input combo to trigger a reboot to the Xbox Dashboard
        if( m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] > 0 )
        {
            if( m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] > 0 )
            {
                if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_BLACK] )
                    XLaunchNewImage( NULL, NULL );
            }
        }

        //-----------------------------------------
        // Perform app timing
        //-----------------------------------------

		// Get the frequency of the timer
		LARGE_INTEGER qwTicksPerSec;
		QueryPerformanceFrequency( &qwTicksPerSec );
		FLOAT fSecsPerTick = 1.0f / (FLOAT)qwTicksPerSec.QuadPart;

		// Save the start time
		LARGE_INTEGER qwTime;
		QueryPerformanceCounter( &qwTime );

        // Store the current time values as floating point
        
        m_fElapsedTime    = fSecsPerTick * ((FLOAT)(qwTime.QuadPart)) - m_fTime;
		m_fTime           = fSecsPerTick * ((FLOAT)(qwTime.QuadPart));
        
        // Compute the FPS (frames per second) once per second
        static FLOAT fLastTime = 0.0f;
        static DWORD dwFrames  = 0L;
        dwFrames++;

        if( m_fTime - fLastTime > 1.0f )
        {
            m_fFPS    = dwFrames / ( m_fTime - fLastTime );
            fLastTime = m_fTime;
            dwFrames  = 0L;
            swprintf( m_strFrameRate, L"%0.02f fps", m_fFPS );
        }


		for (SmartObjIter iter = m_SmartObjects.begin(); iter != m_SmartObjects.end();iter++)
		{
			(*iter)->Advance(m_fElapsedTime);
		}

		return hr;
}

//-----------------------------------------------------------------------------
// Name: RenderGradientBackground()
// Desc: Draws a gradient filled background
//-----------------------------------------------------------------------------
HRESULT XOApplication::RenderGradientBackground( DWORD dwTopColor, 
                                                  DWORD dwBottomColor )
{
    // First time around, allocate a vertex buffer
    static LPDIRECT3DVERTEXBUFFER8 g_pVB  = NULL;
    if( g_pVB == NULL )
    {
        m_pd3dDevice->CreateVertexBuffer( 4*5*sizeof(FLOAT), D3DUSAGE_WRITEONLY, 
                                          0L, D3DPOOL_DEFAULT, &g_pVB );
        struct BACKGROUNDVERTEX { D3DXVECTOR4 p; D3DCOLOR color; };
        BACKGROUNDVERTEX* v;
        g_pVB->Lock( 0, 0, (BYTE**)&v, 0L );
        v[0].p = D3DXVECTOR4(   0,   0, 1.0f, 1.0f ); v[0].color = dwTopColor;
        v[1].p = D3DXVECTOR4( 640,   0, 1.0f, 1.0f ); v[1].color = dwTopColor;
        v[2].p = D3DXVECTOR4(   0, 480, 1.0f, 1.0f ); v[2].color = dwBottomColor;
        v[3].p = D3DXVECTOR4( 640, 480, 1.0f, 1.0f ); v[3].color = dwBottomColor;
        g_pVB->Unlock();
    }

    // Set states
    m_pd3dDevice->SetTexture( 0, NULL );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE ); 
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE ); 
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_DIFFUSE );
    m_pd3dDevice->SetStreamSource( 0, g_pVB, 5*sizeof(FLOAT) );

    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

    // Clear the zbuffer
    m_pd3dDevice->Clear( 0, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 0x00000000, 1.0f, 0L );

    return S_OK;
}

HRESULT XOApplication::Cleanup()
{
	HRESULT hr = S_OK;
	CTranslator::Instance()->Cleanup();
	
	return hr;
}

HRESULT XOApplication::Render()
{
	if ( m_pd3dDevice )
	{
	
		m_pd3dDevice->BeginScene();

		// Clear the backbuffer 
		m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, 
                         D3DCOLOR_XRGB( (int)0, (int)0, (int)0 ), 1.0f, 0L );
		for (SmartObjIter iter = m_SmartObjects.begin(); iter != m_SmartObjects.end();iter++)
		{
			(*iter)->Render();
		}

		m_pd3dDevice->EndScene();
	}

	return S_OK;
}



HRESULT XOApplication::FrameMove()
{
	HRESULT hr = S_OK;

	
	if ((m_fTime - m_fLastChangeLanguge) > 200.0f)
	{
		m_fLastChangeLanguge = m_fTime;
		CTranslator::Instance()->Cleanup();
		m_nCurLanguage +=1;
		if (m_nCurLanguage > 6)
			m_nCurLanguage = 1;
		
		XSetValue(XC_LANGUAGE, REG_DWORD, (DWORD*)&m_nCurLanguage, 4);
		hr = CTranslator::Instance()-> Initialize();

		while(!m_SmartObjects.empty())
		{

				SmartObject* pNext = m_SmartObjects.back();
				m_SmartObjects.pop_back();
				delete pNext;
		}
		
		Text_Exit();
		AddText();
	}
	
	D3DXMATRIX viewMatrix;

	D3DXVECTOR3 vPosition(1.8f, 0.3f, 2.0f);
	
	D3DXVECTOR3 vLookAt(1.8f,0.3f,0.0f);
	D3DXVECTOR3 vUp (0 ,1 ,0);

	D3DXMatrixLookAtRH(
	  &viewMatrix,
	  &vPosition,
	  &vLookAt,
	  &vUp );
	
	g_pd3dDevice->SetTransform( D3DTS_VIEW, &viewMatrix );

	D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovRH( &matProj, D3DX_PI/2, 1.333f, 1.0, 100.f );
	
	g_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );

	D3DXMATRIX curWorld;
//	D3DXMatrixIdentity(&curWorld);
	D3DXMatrixScaling(&curWorld, 0.2f, 0.2f, 0.2f);
	
	g_pd3dDevice->SetTransform( D3DTS_WORLD, &curWorld );

	g_pd3dDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
	g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, 1);
	g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
	g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
	g_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_CW );
	g_pd3dDevice->SetRenderState( D3DRS_EDGEANTIALIAS, TRUE );

	return S_OK;
}


HRESULT XOApplication::Initialize()
{
	
	HRESULT hr;
	hr = CTranslator::Instance()-> Initialize();
	if(FAILED(hr))
	{
		DbgPrint("XOApplication::Initialize - Fail to init XLate table");
		return hr;
	}
	
	AddText();
	return hr;
}

void XOApplication::AddText()
{
//	for(int i = 0; i<200; i++)
	{
		SmartObject* pSmartObj = new CText();
		if(pSmartObj)
		{
			CText* pText = (CText*) (pSmartObj);
			static TCHAR szTest[] = _T("SystemINFO");
			const TCHAR szFontBody[] = _T("Body");
			
			pText->m_szTextId = new TCHAR [_tcslen(szTest) + 1];
			_tcscpy(pText->m_szTextId,szTest);
			pText->m_szFont = new TCHAR [_tcslen(szFontBody) + 1];
			_tcscpy(pText->m_szFont, szFontBody);

			pText->m_width = 10.0f;
			pText->m_height = 4.0f;

			pText->m_scrollRate = 0.1f; 
			pText->m_scrollDelay = 5.0f;

			pText->Initialize();
			m_SmartObjects.push_back(pText);
		}

	}
// Bad input
	{// invalid text id
		SmartObject* pSmartObj = new CText();
		if(pSmartObj)
		{
			CText* pText = (CText*) (pSmartObj);

			static TCHAR szFontBody[] = _T("Body");
			static TCHAR szTest[] = _T("InvalidTextId");
			pText->m_szTextId = new TCHAR [_tcslen(szTest) + 1];
			_tcscpy(pText->m_szTextId,szTest);
			pText->m_szFont = new TCHAR [_tcslen(szFontBody) + 1];
			_tcscpy(pText->m_szFont, szFontBody);
//			m_SmartObjects.push_back(pText);
		}
	}

	{ // invalid font
		SmartObject* pSmartObj = new CText();
		if(pSmartObj)
		{
			CText* pText = (CText*) (pSmartObj);
			static TCHAR szTest[] = _T("SystemINFO");
			static TCHAR szFontBody[] = _T("InvalidFont");
			
			pText->m_szTextId = new TCHAR [_tcslen(szTest) + 1];
			_tcscpy(pText->m_szTextId, szTest);
			pText->m_szFont = new TCHAR [_tcslen(szFontBody) + 1];
			_tcscpy(pText->m_szFont, szFontBody);
//			m_SmartObjects.push_back(pText);
		}
	}

	{// no font specified
		SmartObject* pSmartObj = new CText();
		if(pSmartObj)
		{
			CText* pText = (CText*) (pSmartObj);
			static TCHAR szTest[] = _T("InValidTextId");
			
			pText->m_szTextId = new TCHAR [_tcslen(szTest) + 1];
			_tcscpy(pText->m_szTextId, szTest);
			
//			m_SmartObjects.push_back(pText);
		}
	}


	{
		// no translation
		SmartObject* pSmartObj = new CText();
		if(pSmartObj)
		{
			CText* pText = (CText*) (pSmartObj);
			static TCHAR szTest[] = _T("SystemINFO");
			static TCHAR szFontBody[] = _T("Body");
			
			pText->m_szText = new TCHAR [_tcslen(szTest) + 1];
			_tcscpy(pText->m_szText,szTest);
			pText->m_szFont = new TCHAR [_tcslen(szFontBody) + 1];
			_tcscpy(pText->m_szFont, szFontBody);

			pText->m_width = -4.0f;
			pText->m_height = 2.0f;

			pText->m_scrollRate = 10.0f; 
			pText->m_scrollDelay = 1.0f;

			pText-> m_bTranslate = false;
			pText->Initialize();
//			m_SmartObjects.push_back(pText);
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\xodash\TextTest\std.h ===
#ifdef _XBOX
#ifdef __cplusplus
extern "C" {
#endif // __cplusplus
#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>
#include <ntddcdrm.h>
#include <ntddscsi.h>
#include <ntddcdvd.h>
#include <smcdef.h>
#include <scsi.h>
#include <init.h>
#ifdef __cplusplus
}
#endif // __cplusplus
#include <dsoundp.h>
#include <xtl.h>
#include <xgraphics.h>
#include <xboxp.h>
#include <xapip.h>
#include <av.h>


#ifndef D3DLOCK_DISCARD
#define D3DLOCK_DISCARD 0
#endif

#endif

#ifdef _WINDOWS
#include <winsock2.h>
#include <windows.h>
#endif

#include <tchar.h>
typedef TCHAR* PTCHAR;

// "Filesystem" Character Type...What do *most* of the file system API's use...
#if defined(_XBOX)
typedef char FSCHAR;
#define _FS(s) s
#else
typedef TCHAR FSCHAR;
#define _FS(s) _T(s)
#endif

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include <math.h>

#include <crtdbg.h>

#if !defined(_NOD3D)
#define D3D_OVERLOADS
#include <d3d8.h>
#include <d3dx8.h>

#endif

#define ASSERTHR(f)		do { HRESULT hrverify = (f); if (FAILED(hrverify) && AssertFailed(_T(__FILE__), __LINE__, hrverify)) _CrtDbgBreak(); } while (0)
#define VERIFYHR(f)		ASSERTHR(f)
EXTERN_C bool AssertFailed(const TCHAR* szFile, int nLine, HRESULT hr);
#define BREAKONFAIL(a,b)  {if(FAILED(a)) {DbgPrint(b);break;} }

/*
#undef TRACE
#ifdef _DEBUG
#define TRACE Trace
#define TRACEFILE TraceInFile
extern "C" void Trace(char* szMsg, ...);
extern "C" void TraceInFile(char* szMsg, ...);
#endif
*/
/*
#ifdef _UNICODE
extern void Unicode(TCHAR* wsz, const char* sz, int nMaxChars);
extern void Ansi(char* sz, const TCHAR* wsz, int nMaxChars);
#endif

#undef ASSERT
#undef VERIFY
#undef ASSERTHR
#undef VERIFYHR
#undef TRACE
#undef ALERT

#ifdef _DEBUG

#define ASSERT(f)		if (!(f)) RtlAssert(#f, __FILE__, __LINE__, NULL)
#define VERIFY(f)		ASSERT(f)
#define ASSERTHR(f)		do { HRESULT hrverify = (f); if (FAILED(hrverify) && AssertFailed(_T(__FILE__), __LINE__, hrverify)) _CrtDbgBreak(); } while (0)
#define VERIFYHR(f)		ASSERTHR(f)
#define TRACE			Trace
#define ALERT			Alert

EXTERN_C bool AssertFailed(const TCHAR* szFile, int nLine, HRESULT hr);
EXTERN_C void Trace(const TCHAR* szMsg, ...);

#else // !_DEBUG

#define ASSERT(f)		((void)0)
#define VERIFY(f)		((void)(f))
#define ASSERTHR(f)		((void)0)
#define VERIFYHR(f)		((void)(f))
#define TRACE			1 ? (void)0 : Trace
#define ALERT			1 ? (void)0 : Alert

inline void Trace(const TCHAR* szMsg, ...) { }

#endif

EXTERN_C void Alert(const TCHAR* szMsg, ...);


////////////////////////////////////////////////////////////////////////////

#ifdef _XBOX
#include "xprofp.h"

#ifdef _PROFILE
#define START_PROFILE() XProfpControl(XPROF_START, 0)
#define END_PROFILE() XProfpControl(XPROF_STOP, 0)
#else
#define START_PROFILE()
#define END_PROFILE()
#endif
#else
#define START_PROFILE()
#define END_PROFILE()
#endif

*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\xon\testxon.cpp ===
// ----------------------------------------------------------------------------
// testxon.cpp
//
// Copyright (c) Microsoft Corporation.  All rights reserved
// ----------------------------------------------------------------------------

#include <windows.h>
#include <xbox.h>
#include <winsockx.h>
#include <winsockp.h>
#include <xonlinep.h>
#include <stdlib.h>
#include <stdio.h>
#include <vlan.h>
#include <OnlineAccounts2.h>

// ---------------------------------------------------------------------------------------
// Utilities
// ---------------------------------------------------------------------------------------

__forceinline void DbgBreak() {
    _asm int 3;
}

#define Verify(x)       do { if (!(x)) DbgBreak(); } while (0)

//
// Standard 30 second timeout.  Used as a parameter to DoWork().
//
#define STANDARD_TIMEOUT 30000

//
// Maximum number of tasks in the array that DoWork() will pump
//
#define NUM_TASKS        10

//
// Helper structure to tie a task with an HRESULT
//
struct ONLINETASK
{
    XONLINETASK_HANDLE hTask;
    HRESULT            hr;
};

//
// Progress interval:  time between output of dots.
//
#define PROGRESS_INTERVAL 2000

// ---------------------------------------------------------------------------------------
// CTestXbox
// ---------------------------------------------------------------------------------------

//
// Inherit from COnlineAccounts for account creation support
//
// BUGBUG: COnlineAccounts does not handle more than one instance of itself.  Need to
// fix it so we can simulate multiple Xboxes.
//
class CTestXbox : public COnlineAccounts
{

public:
    CTestXbox(char *pszXbox) : COnlineAccounts(pszXbox) {};

    //
    // Initialization of CTestXbox class.  It takes a pointer to the second CTestXbox
    // class so it can access the member variables such as user list and hresults.
    //
    virtual void StartupTest(CTestXbox *pOtherXbox, HANDLE hEvent1, HANDLE hEvent2)
    {
        DWORD i = 0;

        m_pOtherXbox = pOtherXbox;
        m_hEvent1    = hEvent1;
        m_hEvent2    = hEvent2;

        //
        // Initialize all tasks and create events for each
        //
        for (i = 0; i < NUM_TASKS; i += 1)
        {
            m_Tasks[i].hTask = NULL;
            m_Tasks[i].hr = S_OK;
            Verify((m_hEvents[i] = CreateEvent(NULL, FALSE, FALSE, NULL)) != NULL);
        }

        //
        // Zero out the user list
        //
        RtlZeroMemory( m_pUsers, sizeof(m_pUsers) );

        Verify(XOnlineStartup(NULL) == S_OK);
    };

    //
    // Termination of CTestXbox class.  Closes the logon task handle and XOnline.
    //
    virtual void TermTest()
    {
        DWORD i = 0;

        //
        // Close logon task handle
        //
        if (m_Tasks[0].hTask != NULL)
        {
            Verify(XOnlineTaskClose(m_Tasks[0].hTask) == S_OK);
        }

        Verify(XOnlineCleanup() == S_OK);

        //
        // Cleanup all task events
        //
        for (i = 0; i < NUM_TASKS; i += 1)
        {
            Verify(CloseHandle(m_hEvents[i]));
        }
    };

    //
    // =============================================================================
    // =============================================================================
    // Test case list - Add test cases here
    //
    virtual void Test_Account_Create() = 0;
    virtual void Test_Friends() = 0;
    virtual void Test_Matchmaking() = 0;
    //
    // End of test case list
    // =============================================================================
    // =============================================================================
    //

    //
    // Pump an array of task handles for some amount of time.  If hTaskToComplete is
    // NULL, then all of the tasks are just pumped as needed for dwTime.  If
    // hTaskToComplete is a valid task handle in the m_Tasks array, DoWork() will
    // exit early as soon as that task is complete (ie. did not return
    // XONLINETASK_S_RUNNING).  HRESULTS for every task are stored in the m_Tasks
    // structures.  A task is pumped until it returns something other than
    // XONLINETASK_S_RUNNING.  On the next call to DoWork(), however, all HRESULTS
    // are reset and all tasks are pumped again.
    //
    void DoWork(XONLINETASK_HANDLE hTaskToComplete, DWORD dwTime)
    {
        DWORD        dwEndTime  = GetTickCount() + dwTime;
        DWORD        i          = 0;
        static DWORD dwLastTime = 0;
        static BOOL  fDidWork   = FALSE;

        //
        // Reset HR of every task so they are pumped at least once.  If you need
        // the HR, be sure to use it before calling DoWork() again.
        //
        for (i = 0; i < NUM_TASKS; i += 1)
        {
            m_Tasks[i].hr = XONLINETASK_S_RUNNING;
        }

        //
        // Loop until we pass the timeout time.
        //
        while (GetTickCount() < dwEndTime)
        {
            //
            // Wait for any of our tasks to signal that work is required.  If no tasks are signalled
            // after PROGRESS_INTERVAL time, display a dot, and wait again (or leave it we hit the
            // timeout dwEndTime)
            //
            if (WaitForMultipleObjects(NUM_TASKS, m_hEvents, FALSE, PROGRESS_INTERVAL) != WAIT_TIMEOUT)
            {
                for (i = 0; i < NUM_TASKS; i += 1)
                {
                    //
                    // If the last TaskContinue() call returned XONLINETASK_S_RUNNING, then
                    // pump it again this time.  Otherwise skip it, so the client of DoWork()
                    // can look at any interesting HRESULTS.
                    //
                    if (m_Tasks[i].hr == XONLINETASK_S_RUNNING && m_Tasks[i].hTask != NULL)
                    {
                        fDidWork = TRUE;

                        m_Tasks[i].hr = XOnlineTaskContinue(m_Tasks[i].hTask);

                        //
                        // If the task has signalled an important state (something other than
                        // XONLINETASK_S_RUNNING) and the client of DoWork() is waiting for this
                        // task to complete (by passing in the task handle as the hTaskToComplete
                        // parameter), exit this function.
                        //
                        if (m_Tasks[i].hr != XONLINETASK_S_RUNNING && m_Tasks[i].hTask == hTaskToComplete)
                        {
                            goto Done;
                        }
                    }
                }
            }

            //
            // Output a dot to signal that the program is still running.  Only display a dot
            // as often as PROGRESS_INTERVAL.
            //
            if ((GetTickCount() - dwLastTime) > PROGRESS_INTERVAL)
            {
                dwLastTime = GetTickCount();

                if (fDidWork == TRUE)
                {
                    printf("*");
                    fDidWork = FALSE;
                }
                else
                {
                    printf(".");
                }
            }

            //
            // BUGBUG: Pending bug 11521, we need to Sleep so that vlan.sys has a chance to do work
            // and keep up with net traffic.
            //
            Sleep(1);
        }
      Done:;
    };

    //
    // Helper function that returns true if all task HRESULTS are success.  Useful to call
    // this after calling DoWork().
    //
    BOOL NoTaskErrors()
    {
        for (DWORD i = 0; i < NUM_TASKS; i += 1)
        {
            if (FAILED(m_Tasks[i].hr))
            {
                return FALSE;
            }
        }
        return TRUE;
    };

    HANDLE             m_hEvent1;            // Synchronization event to keep unit test threads running together
    HANDLE             m_hEvent2;            // Synchronization event to keep unit test threads running together
    XONLINE_USER       m_pUsers[XONLINE_MAX_STORED_ONLINE_USERS]; // Array of logged in users
    DWORD              m_cUsers;             // Number of logged in users
    ONLINETASK         m_Tasks[NUM_TASKS];   // Array of task handles to pump
    HANDLE             m_hEvents[NUM_TASKS]; // Array of events to signal task handles
    CTestXbox          *m_pOtherXbox;        // Pointer to other Xbox so we can access its member variables
};


//
// Helper function for Friends test.  Checks if a particular user is in the friends list.
//
BOOL IsInFriendsList(XUID xuid, PXONLINE_FRIEND pFriends, DWORD dwNumFriends)
{
    DWORD i = 0;

    for (i = 0; i < dwNumFriends; i += 1)
    {
        if (*((ULONGLONG *)&xuid) == *((ULONGLONG *)&(pFriends[i].xuid)))
            return TRUE;
    }
    return FALSE;
}

//
// First simulated Xbox.  This will contain unit tests that only require one simulated Xbox in addition
// to tests that require both simulated Xboxes.
//
class CTestXbox1 : public CTestXbox
{
public:
    CTestXbox1(char *pszXbox) : CTestXbox(pszXbox) {};

    //
    // *****************************************************************************
    // *****************************************************************************
    // Test_Account_Create - test account creation and logon
    // *****************************************************************************
    // *****************************************************************************
    //
    virtual void Test_Account_Create()
    {
        HRESULT hr;

        //
        // =============================================================================
        // =============================================================================
        // Add required services here
        //
        DWORD aServices[] = {
            XONLINE_BILLING_OFFERING_SERVICE,
            XONLINE_USER_ACCOUNT_SERVICE,
            XONLINE_AUTO_UPDATE_SERVICE,
            XONLINE_MATCHMAKING_SERVICE,
            };
        //
        // =============================================================================
        // =============================================================================
        //

        printf("Testing Account_Create ");

        //
        // Populate four users onto the hard drive.  This tests logon with machine account,
        // creation of four users, and storing those users to the hard disk.
        //
        Verify(PopulateUserAccountsHD( NULL, 4 ) == S_OK);

        //
        // Retrieve users from hard drive
        //
        Verify(XOnlineGetUsers( &m_pUsers[0], &m_cUsers ) == S_OK);

        //
        // Set user data for a couple of users.  This tests friend list functionality
        // but is included here since it behaves differently when called before logon,
        // and we want to test that.
        //
        Verify(SUCCEEDED(XOnlineNotificationSetUserData( 0, 4, (PBYTE) "ABC", NULL, NULL)));
        Verify(SUCCEEDED(XOnlineNotificationSetUserData( 1, 4, (PBYTE) "XYZ", NULL, NULL)));

        //
        // Logon with four users
        //
        Verify(XOnlineLogon(m_pUsers, aServices, sizeof(aServices)/sizeof(DWORD), m_hEvents[0], &m_Tasks[0].hTask) == S_OK);
        DoWork(m_Tasks[0].hTask, STANDARD_TIMEOUT);                                                              
        Verify(m_Tasks[0].hr == XONLINE_S_LOGON_CONNECTION_ESTABLISHED);

        //
        // Wait for the second simulated Xbox to finish this unit test
        //
        WaitForSingleObject(m_hEvent2, INFINITE);
        ResetEvent(m_hEvent2);
        SetEvent(m_hEvent1);

        printf(" [OK]\n");
    };

    //
    // *****************************************************************************
    // *****************************************************************************
    // Test_Friends - test buddy list stuff
    // *****************************************************************************
    // *****************************************************************************
    //
    virtual void Test_Friends()
    {
        DWORD                       i                 = 0;
        PXONLINE_FRIEND             pFriends          = NULL;
        DWORD                       dwNumFriends      = 0;
        PXONLINE_LOCKOUTUSER        pLockoutlist      = NULL;
        DWORD                       dwNumLockoutUsers = 0;
        XNKID                       SessionID         = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
        XONLINE_ACCEPTED_GAMEINVITE GameInvite;
        DWORD                       dwEndTime;

        printf("Testing Friends ");

        //
        // Allocate memory for friend and block list
        //
        Verify((pFriends = (PXONLINE_FRIEND) LocalAlloc(0, MAX_FRIENDS * sizeof(XONLINE_FRIEND))) != NULL);
        Verify((pLockoutlist = (PXONLINE_LOCKOUTUSER) LocalAlloc(0, MAX_LOCKOUTUSERS * sizeof(XONLINE_LOCKOUTUSER))) != NULL);

        //
        // Start the friends and lockoutlist tasks.
        //
        Verify(SUCCEEDED(XOnlineFriendsStartup( m_hEvents[1], &m_Tasks[1].hTask )));
        Verify(SUCCEEDED(XOnlineLockoutlistStartup( m_hEvents[2], &m_Tasks[2].hTask )));

        //
        // Set state of user
        //
        Verify(SUCCEEDED(XOnlineNotificationSetState(0, XONLINE_FRIENDSTATE_FLAG_ONLINE, SessionID, 0, NULL)));
        Verify(SUCCEEDED(XOnlineNotificationSetState(1, XONLINE_FRIENDSTATE_FLAG_ONLINE, SessionID, 0, NULL)));
        Verify(SUCCEEDED(XOnlineNotificationSetState(2, XONLINE_FRIENDSTATE_FLAG_ONLINE, SessionID, 0, NULL)));
        Verify(SUCCEEDED(XOnlineNotificationSetState(3, XONLINE_FRIENDSTATE_FLAG_ONLINE, SessionID, 0, NULL)));

        //
        // Have the first user invite other three users to be friends.
        //
        Verify(SUCCEEDED(XOnlineFriendsRequest( 0, m_pUsers[1].xuid )));
        Verify(SUCCEEDED(XOnlineFriendsRequest( 0, m_pUsers[2].xuid )));
        Verify(SUCCEEDED(XOnlineFriendsRequest( 0, m_pUsers[3].xuid )));

        //
        // Start enumerating all friend lists
        //
        Verify(SUCCEEDED(XOnlineFriendsEnumerate( 0, m_hEvents[3], &m_Tasks[3].hTask )));
        Verify(SUCCEEDED(XOnlineFriendsEnumerate( 1, m_hEvents[4], &m_Tasks[4].hTask )));
        Verify(SUCCEEDED(XOnlineFriendsEnumerate( 2, m_hEvents[5], &m_Tasks[5].hTask )));
        Verify(SUCCEEDED(XOnlineFriendsEnumerate( 3, m_hEvents[6], &m_Tasks[6].hTask )));

        //
        // Work until all users have correct friends in their lists, or hit the
        // timeout.
        //
        dwEndTime = GetTickCount() + STANDARD_TIMEOUT;
        while (GetTickCount() < dwEndTime)
        {
            DoWork(NULL, 500);
            Verify(NoTaskErrors());
            Verify(m_Tasks[1].hr != XONLINE_S_NOTIFICATION_FRIEND_RESULT);

            //
            // Verify that all users have correct friends in their lists.  If not
            // iterate the loop and work some more.
            //
            dwNumFriends = XOnlineFriendsGetLatest( 0, MAX_FRIENDS, pFriends );
            if (dwNumFriends != 3) continue;
            if (!IsInFriendsList(m_pUsers[1].xuid, pFriends, dwNumFriends)) continue;
            if (!IsInFriendsList(m_pUsers[2].xuid, pFriends, dwNumFriends)) continue;
            if (!IsInFriendsList(m_pUsers[3].xuid, pFriends, dwNumFriends)) continue;

            dwNumFriends = XOnlineFriendsGetLatest( 1, MAX_FRIENDS, pFriends );
            if (dwNumFriends != 1) continue;
            if (!IsInFriendsList(m_pUsers[0].xuid, pFriends, dwNumFriends)) continue;

            dwNumFriends = XOnlineFriendsGetLatest( 2, MAX_FRIENDS, pFriends );
            if (dwNumFriends != 1) continue;
            if (!IsInFriendsList(m_pUsers[0].xuid, pFriends, dwNumFriends)) continue;

            dwNumFriends = XOnlineFriendsGetLatest( 3, MAX_FRIENDS, pFriends );
            if (dwNumFriends != 1) continue;
            if (!IsInFriendsList(m_pUsers[0].xuid, pFriends, dwNumFriends)) continue;

            break;
        }
        Verify(GetTickCount() < dwEndTime);

        //
        // Have one user reply with yes, one reply with no and last user doesn't reply at all.
        //
        Verify(SUCCEEDED(XOnlineFriendsAnswerRequest( 1, &pFriends[0], XONLINE_REQUEST_YES )));
        Verify(SUCCEEDED(XOnlineFriendsAnswerRequest( 2, &pFriends[0], XONLINE_REQUEST_NO )));

        //
        // Work until all users have correct friends in their lists, or hit the
        // timeout.
        //
        dwEndTime = GetTickCount() + STANDARD_TIMEOUT;
        while (GetTickCount() < dwEndTime)
        {
            DoWork(NULL, 500);
            Verify(NoTaskErrors());
            Verify(m_Tasks[1].hr != XONLINE_S_NOTIFICATION_FRIEND_RESULT);

            //
            // Verify that all users have correct friends in their lists.  If not
            // iterate the loop and work some more.
            //
            dwNumFriends = XOnlineFriendsGetLatest( 0, MAX_FRIENDS, pFriends );
            if (dwNumFriends != 2) continue;
            if (!IsInFriendsList(m_pUsers[1].xuid, pFriends, dwNumFriends)) continue;
            if (!IsInFriendsList(m_pUsers[3].xuid, pFriends, dwNumFriends)) continue;
            if (pFriends[0].friendState & XONLINE_FRIENDSTATE_FLAG_CLOAKED) continue;

            dwNumFriends = XOnlineFriendsGetLatest( 1, MAX_FRIENDS, pFriends );
            if (dwNumFriends != 1) continue;
            if (!IsInFriendsList(m_pUsers[0].xuid, pFriends, dwNumFriends)) continue;
            if (!(pFriends[0].friendState & XONLINE_FRIENDSTATE_FLAG_ONLINE)) continue;
            if (pFriends[0].friendState & XONLINE_FRIENDSTATE_FLAG_CLOAKED) continue;

            dwNumFriends = XOnlineFriendsGetLatest( 2, MAX_FRIENDS, pFriends );
            if (dwNumFriends != 0) continue;

            dwNumFriends = XOnlineFriendsGetLatest( 3, MAX_FRIENDS, pFriends );
            if (dwNumFriends != 1) continue;
            if (!IsInFriendsList(m_pUsers[0].xuid, pFriends, dwNumFriends)) continue;

            break;
        }
        Verify(GetTickCount() < dwEndTime);

        //
        // Check if we receive friend errors correctly.  Attempt to add a friend
        // that is already in our friend list.
        //
        Verify(SUCCEEDED(XOnlineFriendsRequest( 0, m_pUsers[1].xuid )));

        //
        // Work until we receive the error code from TaskContinue that indicates
        // there is a friend error.
        //
        dwEndTime = GetTickCount() + STANDARD_TIMEOUT;
        while (GetTickCount() < dwEndTime)
        {
            DoWork(NULL, 500);
            if (m_Tasks[1].hr != XONLINE_S_NOTIFICATION_FRIEND_RESULT) continue;
            Verify(NoTaskErrors());

            DWORD dwUserIndex = 0;
            XUID  xuidTargetUser;

            //
            // Verify that the friend error is correct
            //
            Verify(XOnlineFriendsGetResults(&dwUserIndex, &xuidTargetUser) == 0x80070524);
            Verify(dwUserIndex == 0);
            Verify(*((ULONGLONG *)&xuidTargetUser) == *((ULONGLONG *)&m_pUsers[1].xuid));

            break;
        }
        Verify(GetTickCount() < dwEndTime);

        //
        // Add two users to the lockout list.  Work for a bit to make sure those lockoutlist
        // adds are sent to the server.
        //
        Verify(SUCCEEDED(XOnlineLockoutlistAdd( 0, m_pUsers[1].xuid, m_pUsers[1].name )));
        Verify(SUCCEEDED(XOnlineLockoutlistAdd( 0, m_pUsers[2].xuid, m_pUsers[2].name )));
        DoWork(NULL, 3000);
        Verify(NoTaskErrors());

        //
        // Remove one user from the lockout list and work for a bit to send it
        // to the server.
        //
        Verify(SUCCEEDED(XOnlineLockoutlistRemove( 0, m_pUsers[1].xuid )));
        DoWork(NULL, 3000);
        Verify(NoTaskErrors());

        //
        // Get the lockout list for the first user and verify that it contains one user.
        //
        Verify((dwNumLockoutUsers = XOnlineLockoutlistGet( 0, MAX_LOCKOUTUSERS, pLockoutlist )) == 1);
        
        //
        // Set the state and user data for the first user and work so it gets sent
        // to the server.
        //
        Verify(SUCCEEDED(XOnlineNotificationSetState(0, XONLINE_FRIENDSTATE_FLAG_ONLINE | XONLINE_FRIENDSTATE_FLAG_PLAYING, SessionID, 4, (PBYTE) "DEF")));
        Verify(SUCCEEDED(XOnlineNotificationSetUserData( 0, 4, (PBYTE) "GHI", m_hEvents[7], &m_Tasks[7].hTask)));
        DoWork(m_Tasks[7].hTask, STANDARD_TIMEOUT);
        Verify(m_Tasks[7].hr == XONLINETASK_S_SUCCESS);
        Verify(NoTaskErrors());
        XOnlineTaskClose(m_Tasks[7].hTask);
        m_Tasks[7].hTask = NULL;

        //
        // Work until the state is updated correctly in the friend list, or hit the
        // timeout.
        //
        dwEndTime = GetTickCount() + STANDARD_TIMEOUT;
        while (GetTickCount() < dwEndTime)
        {
            DoWork(NULL, 500);
            Verify(NoTaskErrors());

            //
            // Verify that the state is correct
            //
            dwNumFriends = XOnlineFriendsGetLatest( 1, MAX_FRIENDS, pFriends );
            if (dwNumFriends != 1) continue;
            if (!IsInFriendsList(m_pUsers[0].xuid, pFriends, dwNumFriends)) continue;
            if (!(pFriends[0].friendState & XONLINE_FRIENDSTATE_FLAG_PLAYING)) continue;
            if (pFriends[0].StateData[0] != 'D' || pFriends[0].StateData[1] != 'E' || pFriends[0].StateData[2] != 'F') continue;
            if (pFriends[0].UserData[0] != 'G' || pFriends[0].UserData[1] != 'H' || pFriends[0].UserData[2] != 'I') continue;

            break;
        }
        Verify(GetTickCount() < dwEndTime);

        //
        // Retrieve the user's latest friend list so we can invite a friend
        // to join our game session.
        //
        dwNumFriends = XOnlineFriendsGetLatest( 0, MAX_FRIENDS, pFriends );

        //
        // Find User #1 in our friend list.
        //
        for (i = 0; i < dwNumFriends; i += 1)
        {
            if (*((ULONGLONG *)&pFriends[i].xuid) == *((ULONGLONG *)&m_pUsers[1].xuid))
            {
                break;
            }
        }

        //
        // Invite User #2 to a game session.
        //
        Verify(SUCCEEDED(XOnlineFriendsGameInvite( 0, SessionID, 1, &pFriends[i] )));

        //
        // Work until the state is updated correctly in the friend list, or hit the
        // timeout.
        //
        dwEndTime = GetTickCount() + STANDARD_TIMEOUT;
        while (GetTickCount() < dwEndTime)
        {
            DoWork(NULL, 500);
            Verify(NoTaskErrors());

            //
            // Verify that all users have correct buddies in their lists
            //
            dwNumFriends = XOnlineFriendsGetLatest( 0, MAX_FRIENDS, pFriends );
            if (dwNumFriends != 2) continue;
            if (!IsInFriendsList(m_pUsers[1].xuid, pFriends, dwNumFriends)) continue;
            if (!(pFriends[i].friendState & XONLINE_FRIENDSTATE_FLAG_SENTINVITE)) continue;
            if (pFriends[i].friendState & XONLINE_FRIENDSTATE_FLAG_RECEIVEDINVITE) continue;
            if (pFriends[i].friendState & XONLINE_FRIENDSTATE_FLAG_INVITEACCEPTED) continue;
            if (pFriends[i].friendState & XONLINE_FRIENDSTATE_FLAG_INVITEREJECTED) continue;

            dwNumFriends = XOnlineFriendsGetLatest( 1, MAX_FRIENDS, pFriends );
            if (dwNumFriends != 1) continue;
            if (!IsInFriendsList(m_pUsers[0].xuid, pFriends, dwNumFriends)) continue;
            if (!(pFriends[0].friendState & XONLINE_FRIENDSTATE_FLAG_RECEIVEDINVITE)) continue;
            if (pFriends[0].friendState & XONLINE_FRIENDSTATE_FLAG_SENTINVITE) continue;
            if (pFriends[0].friendState & XONLINE_FRIENDSTATE_FLAG_INVITEACCEPTED) continue;
            if (pFriends[0].friendState & XONLINE_FRIENDSTATE_FLAG_INVITEREJECTED) continue;

            break;
        }
        Verify(GetTickCount() < dwEndTime);

        //
        // Retrieve the second user's latest buddy list and answer the game invite
        // that was sent.  Then close the enumeration task handle and pump the friends
        // task handle to send the game invite response to the other user.
        //
        Verify(SUCCEEDED(XOnlineFriendsAnswerGameInvite( 1, &pFriends[0], XONLINE_GAMEINVITE_NO)));

        //
        // Invite User #1 to a game session.
        //
        Verify(SUCCEEDED(XOnlineFriendsGameInvite(1, SessionID, 1, &pFriends[0] )));

        dwEndTime = GetTickCount() + STANDARD_TIMEOUT;
        while (GetTickCount() < dwEndTime)
        {
            DoWork(NULL, 500);
            Verify(NoTaskErrors());

            //
            // Verify that the state is correct
            //
            dwNumFriends = XOnlineFriendsGetLatest( 0, MAX_FRIENDS, pFriends );
            if (dwNumFriends != 2) continue;
            if (!IsInFriendsList(m_pUsers[1].xuid, pFriends, dwNumFriends)) continue;
            if (!(pFriends[i].friendState & XONLINE_FRIENDSTATE_FLAG_INVITEREJECTED)) continue;
            if (!(pFriends[i].friendState & XONLINE_FRIENDSTATE_FLAG_SENTINVITE)) continue;
            if (!(pFriends[i].friendState & XONLINE_FRIENDSTATE_FLAG_RECEIVEDINVITE)) continue;
            if (pFriends[i].friendState & XONLINE_FRIENDSTATE_FLAG_INVITEACCEPTED) continue;

            dwNumFriends = XOnlineFriendsGetLatest( 1, MAX_FRIENDS, pFriends );
            if (dwNumFriends != 1) continue;
            if (!IsInFriendsList(m_pUsers[0].xuid, pFriends, dwNumFriends)) continue;
            if (!(pFriends[0].friendState & XONLINE_FRIENDSTATE_FLAG_SENTINVITE)) continue;
            if (pFriends[0].friendState & XONLINE_FRIENDSTATE_FLAG_RECEIVEDINVITE) continue;
            if (pFriends[0].friendState & XONLINE_FRIENDSTATE_FLAG_INVITEACCEPTED) continue;
            if (pFriends[0].friendState & XONLINE_FRIENDSTATE_FLAG_INVITEREJECTED) continue;

            break;
        }
        Verify(GetTickCount() < dwEndTime);

        //
        // Retrieve the accepted game invite from the hard disk.
        // BUGBUG: This currently isn't a really valid test since the game invite won't be written
        // to the hard disk if it came from in-game.  The API that changes the title ID should
        // be called with a different title ID in order to simulate this functionality.
        //
        Verify(SUCCEEDED(XOnlineFriendsGetAcceptedGameInvite( m_hEvents[7], &m_Tasks[7].hTask )));
        
        dwEndTime = GetTickCount() + STANDARD_TIMEOUT;
        while (GetTickCount() < dwEndTime)
        {
            DoWork(m_Tasks[7].hTask, 500);
            Verify(NoTaskErrors());

            if (m_Tasks[7].hr != XONLINETASK_S_SUCCESS) continue;

            break;
        }
        Verify(GetTickCount() < dwEndTime);

        Verify(SUCCEEDED(XOnlineFriendsGetAcceptedGameInviteResult( m_Tasks[7].hTask, &GameInvite )));
        XOnlineTaskClose(m_Tasks[7].hTask);
        m_Tasks[7].hTask = NULL;

        //
        // Close all opened task handles, except logon task handle at index 0
        //
        for (i = 1; i < NUM_TASKS; i += 1)
        {
            if (m_Tasks[i].hTask != NULL)
            {
                XOnlineTaskClose(m_Tasks[i].hTask);
                m_Tasks[i].hTask = NULL;
            }
        }

        //
        // Free the buddy list and block list memory
        //
        LocalFree((HLOCAL) pFriends);
        LocalFree((HLOCAL) pLockoutlist);

        //
        // Wait for the second simulated Xbox to finish this unit test
        //
        WaitForSingleObject(m_hEvent2, INFINITE);
        ResetEvent(m_hEvent2);
        SetEvent(m_hEvent1);

        printf(" [OK]\n");
    };

    //
    // *****************************************************************************
    // *****************************************************************************
    // Test_Matchmaking - test matchmaking session create and search
    // *****************************************************************************
    // *****************************************************************************
    //
    virtual void Test_Matchmaking()
    {
        XNKEY                KeyExchangeKey;
        XONLINE_ATTRIBUTE    Attribs[20];
        XNKID                SessionID       = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
        PXMATCH_SEARCHRESULT *ppSearchResult = NULL;
        DWORD                dwNumResults    = 0;
        DWORD                i               = 0;

        printf("Testing Matchmaking ");

        //
        // Create a set of attributes to advertise with the new session
        //
        Attribs[0].dwAttributeID = X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | X_ATTRIBUTE_DATATYPE_INTEGER | 0x00000000;
        Attribs[0].info.integer.qwValue = 1234;
        Attribs[1].dwAttributeID = X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | X_ATTRIBUTE_DATATYPE_STRING | 0x00000001;
        Attribs[1].info.string.pwszValue = L"MYSTRING111";
        Attribs[2].dwAttributeID = X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | X_ATTRIBUTE_DATATYPE_BLOB | 0x00000002;
        Attribs[2].info.blob.pvValue = (VOID *) "MYBLOB111";
        Attribs[2].info.blob.dwLength = 9;
        Attribs[3].dwAttributeID = X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | X_ATTRIBUTE_DATATYPE_STRING | 0x00000003;
        Attribs[3].info.string.pwszValue = L"MYSTRING222";
        Attribs[4].dwAttributeID = X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | X_ATTRIBUTE_DATATYPE_STRING | 0x00000004;
        Attribs[4].info.string.pwszValue = L"MYSTRING333";
        Attribs[5].dwAttributeID = X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | X_ATTRIBUTE_DATATYPE_BLOB | 0x00000005;
        Attribs[5].info.blob.pvValue = (VOID *) "MYBLOB222";
        Attribs[5].info.blob.dwLength = 9;
        Attribs[6].dwAttributeID = X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | X_ATTRIBUTE_DATATYPE_INTEGER | 0x00000006;
        Attribs[6].info.integer.qwValue = 5678;

        //
        // Create a new session and send it to the server.  Then get the SessionID and KeyExchangeKey for that
        // new session.
        //
        Verify(SUCCEEDED(XOnlineMatchSessionCreate( 1, 2, 3, 4, 7, Attribs, m_hEvents[1], &m_Tasks[1].hTask )));
        DoWork(m_Tasks[1].hTask, STANDARD_TIMEOUT);
        Verify(NoTaskErrors());

        Verify(SUCCEEDED(XOnlineMatchSessionGetInfo(m_Tasks[1].hTask, &SessionID, &KeyExchangeKey)));
        XOnlineTaskClose(m_Tasks[1].hTask);
        m_Tasks[1].hTask = NULL;

        //
        // Update the session that was just created
        //
        Verify(SUCCEEDED(XOnlineMatchSessionUpdate( SessionID, 1, 2, 3, 4, 7, Attribs, m_hEvents[1], &m_Tasks[1].hTask )));
        DoWork(m_Tasks[1].hTask, STANDARD_TIMEOUT);
        Verify(NoTaskErrors());

        XOnlineTaskClose(m_Tasks[1].hTask);
        m_Tasks[1].hTask = NULL;

        //
        // Create a set of parameters to pass up to the session search request.
        //
        Attribs[0].dwAttributeID = X_ATTRIBUTE_DATATYPE_INTEGER;
        Attribs[0].info.integer.qwValue = 1234;
        Attribs[1].dwAttributeID = X_ATTRIBUTE_DATATYPE_STRING;
        Attribs[1].info.string.pwszValue = L"MYSTRING111";
        Attribs[2].dwAttributeID = X_ATTRIBUTE_DATATYPE_BLOB;
        Attribs[2].info.blob.pvValue = (VOID *) "MYBLOB111";
        Attribs[2].info.blob.dwLength = 9;
        Attribs[3].dwAttributeID = X_ATTRIBUTE_DATATYPE_STRING;
        Attribs[3].info.string.pwszValue = L"MYSTRING222";

        //
        // Create a new session search request and send it to the server.
        //
        Verify(SUCCEEDED(XOnlineMatchSearch( 1, 50, 4, Attribs, 5000, m_hEvents[1], &m_Tasks[1].hTask )));
        DoWork(m_Tasks[1].hTask, STANDARD_TIMEOUT);
        Verify(NoTaskErrors());

        //
        // Get the results of the search request.
        //
        Verify(SUCCEEDED(XOnlineMatchSearchGetResults(m_Tasks[1].hTask, &ppSearchResult, &dwNumResults)));
        XOnlineTaskClose(m_Tasks[1].hTask);
        m_Tasks[1].hTask = NULL;

        //
        // Wait for the second simulated Xbox to finish this unit test
        //
        WaitForSingleObject(m_hEvent2, INFINITE);
        ResetEvent(m_hEvent2);
        SetEvent(m_hEvent1);

        printf(" [OK]\n");
    };
};

//
// Second simulated Xbox.  This will only contain unit tests that require two simulated Xboxes.
// Tests that don't require two simulated Xboxes should use the same function template as
// Test_Matchmaking.
//
class CTestXbox2 : public CTestXbox
{
public:
    CTestXbox2(char *pszXbox) : CTestXbox(pszXbox) {};

    //
    // *****************************************************************************
    // *****************************************************************************
    // Test_Account_Create - test account creation and logon
    // *****************************************************************************
    // *****************************************************************************
    //
    virtual void Test_Account_Create()
    {
        //
        // Second simulated Xbox is not currently supported.  COnlineAccounts contains
        // bugs that prevent it from being instantiated more than once.
        //

        //
        // Tell first simulated Xbox that we're done and wait for it to respond
        // by setting its event.
        //
        SetEvent(m_hEvent2);
        WaitForSingleObject(m_hEvent1, INFINITE);
        ResetEvent(m_hEvent1);
    };

    //
    // *****************************************************************************
    // *****************************************************************************
    // Test_Friends - test buddy list stuff
    // *****************************************************************************
    // *****************************************************************************
    //
    virtual void Test_Friends()
    {
        //
        // Second simulated Xbox is not currently supported.  COnlineAccounts contains
        // bugs that prevent it from being instantiated more than once.
        //

        //
        // Tell first simulated Xbox that we're done and wait for it to respond
        // by setting its event.
        //
        SetEvent(m_hEvent2);
        WaitForSingleObject(m_hEvent1, INFINITE);
        ResetEvent(m_hEvent1);
    };

    //
    // *****************************************************************************
    // *****************************************************************************
    // Test_Matchmaking - test matchmaking session create and search
    // *****************************************************************************
    // *****************************************************************************
    //
    virtual void Test_Matchmaking()
    {
        //
        // Second simulated Xbox is not currently supported.  COnlineAccounts contains
        // bugs that prevent it from being instantiated more than once.
        //

        //
        // Tell first simulated Xbox that we're done and wait for it to respond
        // by setting its event.
        //
        SetEvent(m_hEvent2);
        WaitForSingleObject(m_hEvent1, INFINITE);
        ResetEvent(m_hEvent1);
    };
};

int     g_argc;
char ** g_argv;
BOOL    g_fNicSpecified;

//
// Helper function to see if unit test should be run or not.  If unit tests
// are specified on the command line, only those tests will run.
//
BOOL RunTest(char * pszName)
{
    if (g_argc == 1 || (g_argc == 2 && g_fNicSpecified == TRUE))
    {
        return(TRUE);
    }

    for (int i = 1; i < g_argc; i += 1)
    {
        if (g_argv[i] && lstrcmpiA(g_argv[i], pszName) == 0)
            return(TRUE);
    }

    return(FALSE);
}

//
// Helper function to get the Nic number to use.  If a number is
// specified on the command line, use that Nic.  If not, read it
// from the registry, if it exists.  Write it to the registry
// afterwards.
//
VOID GetNicNumber(DWORD *pdwNic)
{
    DWORD cbNicNum = sizeof(*pdwNic);
    HKEY  hKey1    = NULL;
    HKEY  hKey2    = NULL;

    *pdwNic = 0;
    g_fNicSpecified = FALSE;

    //
    // Look for a single digit specified on the command line.  If
    // one exists, use it as the Nic number.
    //
    for (int i = 1; i < g_argc; i += 1)
    {
        if (g_argv[i] && g_argv[i][0] >= '0' && g_argv[i][0] <= '9')
        {
            *pdwNic = g_argv[i][0] - '0';
            g_fNicSpecified = TRUE;
        }
    }

    //
    // Open the registry key and create the XboxSDK key if it doesn't
    // exist.
    //
    RegOpenKeyEx( HKEY_CURRENT_USER, L"Software\\Microsoft", 0, KEY_ALL_ACCESS, &hKey1);
    RegCreateKeyEx( hKey1, L"XboxSDK", 0, NULL, 0, KEY_ALL_ACCESS, NULL, &hKey2, NULL);
    RegCloseKey(hKey1);

    //
    // If a Nic was not specified on the command line, try getting it from the
    // registry
    //
    if (g_fNicSpecified == FALSE)
    {
        RegQueryValueEx( hKey2, L"SmokeTestNicNum", NULL, NULL, (LPBYTE) pdwNic, &cbNicNum);
    }
    
    //
    // Write Nic number to the registry
    //
    RegSetValueEx( hKey2, L"SmokeTestNicNum", 0, REG_DWORD, (BYTE *)pdwNic, sizeof(DWORD));
    RegCloseKey(hKey2);
}

//
// Thread proc that will run the unit tests on each of the two simulated Xboxes.
//
DWORD WINAPI TestThreadProc(void *pv)
{
    CTestXbox *pXbox = (CTestXbox *) pv;

    //
    // =============================================================================
    // =============================================================================
    // Test case list - Add test cases here
    //
    // Account_Create test must always run.  Other tests should be conditional
    // on command line parameters.  If no command line parameters are specified
    // then it defaults to all tests.
    //
                                          pXbox->Test_Account_Create();
    if (RunTest("Friends"))               pXbox->Test_Friends();
    if (RunTest("Matchmaking"))           pXbox->Test_Matchmaking();
    //
    // End of test case list
    // =============================================================================
    // =============================================================================
    //

    return(0);
}

//
// Main.  Sets up two simulated Xboxes and starts the threads that run through
// the unit tests.
//
int __cdecl main(int argc, char * argv[])
{
    HANDLE hThread1 = NULL;
    HANDLE hThread2 = NULL;
    HANDLE hEvent1 = NULL;
    HANDLE hEvent2 = NULL;
    char szXboxName1[128];
    char szXboxName2[128];
    CTestXbox1 *pXbox1;
    CTestXbox2 *pXbox2;
    DWORD dwNic = 0;

    g_argc = argc;
    g_argv = argv;

    //
    // Initialize VLan
    //
    Verify(VLanInit());

    Verify((hEvent1 = CreateEvent(NULL, FALSE, FALSE, NULL)) != NULL); ResetEvent(hEvent1);
    Verify((hEvent2 = CreateEvent(NULL, FALSE, FALSE, NULL)) != NULL); ResetEvent(hEvent2);

    //
    // Get Nic number from command line or registry, if one is specified
    //
    GetNicNumber(&dwNic);

    //
    // Create name of two simulated Xboxes.  It's based on the computer name of the system
    // you are running the test on.
    //
    sprintf(szXboxName1, "%s_1@Nic/%d", getenv("COMPUTERNAME"), dwNic);
    sprintf(szXboxName2, "%s_2@Nic/%d", getenv("COMPUTERNAME"), dwNic);

    printf("Xbox 1: '%s'\nXbox 2: '%s'\n\n", szXboxName1, szXboxName2);

    //
    // Instantiate two simulated Xbox classes
    //
    pXbox1 = new CTestXbox1(szXboxName1);
    pXbox2 = new CTestXbox2(szXboxName2);

    //
    // Initialize the Xboxes
    //
    pXbox1->StartupTest(pXbox2, hEvent1, hEvent2);
    pXbox2->StartupTest(pXbox1, hEvent1, hEvent2);

    //
    // Create the two threads that will run through the unit tests
    //
    Verify((hThread1 = CreateThread(NULL, 0, TestThreadProc, pXbox1, 0, NULL)) != NULL);
    Verify((hThread2 = CreateThread(NULL, 0, TestThreadProc, pXbox2, 0, NULL)) != NULL);

    //
    // Wait for them to complete.
    //
    WaitForSingleObject(hThread1, INFINITE);
    WaitForSingleObject(hThread2, INFINITE);

    //
    // Call cleanup functions on the two simulated Xboxes.
    //
    pXbox1->TermTest();
    pXbox2->TermTest();

    CloseHandle(hEvent1);
    CloseHandle(hEvent2);
    CloseHandle(hThread1);
    CloseHandle(hThread2);

    VLanTerm();

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\xvchat\xvchattest.cpp ===
#include "xtl.h"
#include "xvchat.h"

#include <assert.h>

int __cdecl main(int argc, char * argv[])
{
	HRESULT hr = S_OK;
	HANDLE  hVChatMgr = NULL; 

	XInitDevices(NULL, NULL);

	HANDLE hEvtMicInput = CreateEvent(NULL, FALSE, FALSE, NULL);

	VOICE_CHAT_CONFIG cfg;
	memset(&cfg, 0, sizeof(VOICE_CHAT_CONFIG));

	hr = XOnlineVChatStartup(&cfg, &hVChatMgr);
	
	if( FAILED( hr ) )
    {
		goto Error;
    }

	

Error:
	if( NULL != hVChatMgr )
    {
		XOnlineVChatCleanup(hVChatMgr);
		hVChatMgr = NULL;
    }

    return(0);

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\test\xodash\TextTest\xODash.h ===
//-----------------------------------------------------------------------------
// File: XODash.h
//
// Container for XOnline's dash.  Stolen from ATG
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBAPP_H
#define XBAPP_H

#include <xtl.h>
#include <xgraphics.h>
#include <stdio.h>
#include "XBInput.h"
#include "XBUtil.h"


#include "SmartObject.h"
#include <vector>
#include <list>

using namespace std;


struct XBGAMEPAD;
class SmartObject;

typedef list<SmartObject* > ListSmartObj;

typedef ListSmartObj::iterator SmartObjIter;


//-----------------------------------------------------------------------------
// Global access to common members
//-----------------------------------------------------------------------------
extern LPDIRECT3DDEVICE8 g_pd3dDevice;




//-----------------------------------------------------------------------------
// Error codes
//-----------------------------------------------------------------------------
#define XBAPPERR_MEDIANOTFOUND       0x82000003




//-----------------------------------------------------------------------------
// Name: class XOApplication
// Desc: holds all really high level objects, sets up D3D
//          Initialize()          - To initialize the device-dependant objects
//          FrameMove()           - To animate the scene
//          Render()              - To render the scene
//-----------------------------------------------------------------------------
class XOApplication
{
protected:
    // Main objects used for creating and rendering the 3D scene
    D3DPRESENT_PARAMETERS m_d3dpp;
    LPDIRECT3D8           m_pD3D;              // The D3D enumerator object
    LPDIRECT3DDEVICE8     m_pd3dDevice;        // The D3D rendering device
    LPDIRECT3DSURFACE8    m_pBackBuffer;       // The backbuffer
    LPDIRECT3DSURFACE8    m_pDepthBuffer;      // The depthbuffer

    // Variables for timing
    FLOAT      m_fTime;             // Current absolute time in seconds
    FLOAT      m_fElapsedTime;      // Elapsed absolute time since last frame
    FLOAT      m_fAppTime;          // Current app time in seconds
    FLOAT      m_fElapsedAppTime;   // Elapsed app time since last frame
    BOOL       m_bPaused;           // Whether app time is paused by user
    FLOAT      m_fFPS;              // Instanteous frame rate
    WCHAR      m_strFrameRate[20];  // Frame rate written to a string
    HANDLE     m_hFrameCounter;     // Handle to framerate perf counter
	


    // Members to init the XINPUT devices.
    XDEVICE_PREALLOC_TYPE* m_InputDeviceTypes;
    DWORD                  m_dwNumInputDeviceTypes;
    XBGAMEPAD*             m_Gamepad;
    XBGAMEPAD              m_DefaultGamepad;


    // Helper functions
    HRESULT RenderGradientBackground( DWORD dwTopColor, DWORD dwBottomColor );

    // Overridable functions for the 3D scene created by the app
    virtual HRESULT Initialize();
    virtual HRESULT FrameMove();
    virtual HRESULT Render();
    virtual HRESULT Cleanup();
	HRESULT Update();

public:

	TCHAR					m_szAppDir[MAX_PATH];

    // Functions to create, run, and clean up the application
    HRESULT Create();
    INT     Run();
    VOID    Destroy();

    // Internal constructor
    XOApplication();

	float	GetTime(){ return m_fAppTime; }

private:
	ListSmartObj m_SmartObjects; 
	void AddText();
	DWORD m_nCurLanguage;
	float m_fLastChangeLanguge;
};


extern XOApplication	theApp; // the single instance


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\Accounts\GenAccounts\GenAccounts.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: GenAccounts.cpp
//
// Author: Dan Rosenstein (danrose)
//
// Description: code to generate account names from user names and kingdoms
//
///////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

///////////////////////////////////////////////////////////////////////////////
//
// Name: Usage
//
// Input: None
//
// Output: None
//
// Description: describes how to use the app
//
///////////////////////////////////////////////////////////////////////////////

void Usage( void )
{
	fprintf( stderr, "Usage:   GenAccounts <NAME_FILE> <KINGDOM_FILE>\r\n" );
	fprintf( stderr, "Example: GenAccounts names.txt kingdoms.txt\r\n ");
}

///////////////////////////////////////////////////////////////////////////////
//
// Name: main
//
// Input: argc - the number of args
//        argv - the args
//
// Output: an error code. 0 for success, -XXXXX for failure
//
// Description: actualy does all the work
//
///////////////////////////////////////////////////////////////////////////////

int main( int argc, char* argv[] )
{
	//
	// the file pointers
	//

	FILE* pNameFile = NULL;
	FILE* pKingdomFile = NULL;

	//
	// the strings
	//

	char szName[64];
	char szKingdom[64];
	char szDomain[64];
	char* szNew = NULL;

	//
	// integer return values
	//

	int iVal = 0;
	int iRetKingdom = 0;
	int iRetName = 0;

	//
	// count of names and kingdoms
	//

	unsigned int iNameCount = 0;
	unsigned int iKingdomCount = 0;

	//
	// decide if there should be a passcode
	//

	bool bPassCode = true;

	//
	// must have 3 args
	//

	if ( 3 != argc )
	{
		Usage();
		iVal = -1;
	}

	//
	// open the name file
	//

	if ( 0 == iVal )
	{
		pNameFile = fopen( argv[1], "rb" );

		//
		// if hte file could not be opened, say that
		//

		if ( NULL == pNameFile )
		{
			fprintf( stderr, "Could not open Name file: %s\r\n", argv[1] );
			Usage();

			iVal = -2;
		}
	}

	//
	// open the kingdom file
	//

	if ( 0 == iVal )
	{
		pKingdomFile = fopen( argv[2], "rb" );

		//
		// if the file could not be opened, say that
		//

		if ( NULL == pKingdomFile )
		{
			fprintf( stderr, "Could not open Kingdom file: %s\r\n", argv[2] );
			Usage();

			iVal = -3;
		}
	}

	//
	// turn echo off...
	//

	if ( 0 == iVal )
	{
		printf( "@echo off\r\n" );
	}

	//
	// cycle through each kingdom
	//

	while ( EOF != iRetKingdom && 0 == iVal )
	{
		//
		// reset the kingdom string
		//

		memset( szKingdom, 0, sizeof( szKingdom ) );

		//
		// read tje kingdom string from the file
		//

		iRetKingdom = fscanf( pKingdomFile, "%s", szKingdom );

		if ( 0 == iRetKingdom )
		{
			iVal = -4;
		}
		else
		{
			//
			// incrmenet the kingdom count
			//

			iKingdomCount++;
		}

		//
		// cycle through the users
		//

		while ( EOF != iRetName && 0 == iVal )
		{
			//
			// reset the name
			//

			memset( szName, 0, sizeof( szName ) );

			//
			// read the next name
			//

			iRetName = fscanf( pNameFile, "%s", szName );

			if ( 0 == iRetName )
			{
				iVal = -5;
			}
			else
			{
				//
				// find where the domain name begins
				//

				szNew = strpbrk( szName, "@" );

				if ( NULL == szNew )
				{
					iVal = -6;
				}
				else
				{
					//
					// copy the domain
					//

					strcpy( szDomain, szNew );

					//
					// replace the domain with .kingdom@domain
					//

					sprintf( szNew, "_%s%s", szKingdom, szDomain );

					//
					// print the new user name
					//

					if ( bPassCode )
					{
						printf( "AccCmdTool %s 00000001,04020406\r\n", szName );
					}
					else
					{
						printf( "AccCmdTool %s 00000000,00000000\r\n", szName );
					}

					iNameCount++;
				}
			}

			//
			// we want to do this in groups of 4 users
			//

			if ( 4 == iNameCount )
			{
				bPassCode = ! bPassCode;
				iNameCount = 0;
				break;
			}
		}
	}

	//
	// close the name file
	//

	if ( pNameFile )
	{
		fclose( pNameFile );
	}

	//
	// close the kingdom file
	//

	if ( pKingdomFile )
	{
		fclose( pKingdomFile );
	}

	return iVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\AddOnlineUser\sources.inc ===
TARGETPATH=obj
TARGETTYPE=PROGRAM
TARGETNAME=AddOnlineUser
USE_LIBCMT=1
XE_FLAGS=$(XE_FLAGS) /TESTNAME:$(TARGETNAME) /TESTID:1235

MSC_WARNING_LEVEL=/W3 /WX /Ob1

!if defined(GENASM)
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /Fa
!endif

!if $(FREEBUILD) == 0
MSC_OPTIMIZATION=/Odi /Ob1
!endif

C_DEFINES=$(C_DEFINES) -DNT -DXONLINE_BUILD_LIB$(LIBTAG)

LINKER_FLAGS=$(LINKER_FLAGS) /map /IGNORE:4099

INCLUDES=$(INCLUDES); \
    $(BASEDIR)\public\sdk\inc;\
    $(BASEDIR)\private\inc\crypto;\
    $(BASEDIR)\private\ntos\inc;\
    $(BASEDIR)\private\ntos\fatx;\
    $(BASEDIR)\private\ntos\xapi\inc;\
    $(BASEDIR)\private\ntos\xapi\k32;\
    $(BASEDIR)\private\ntos\net;\
    $(BASEDIR)\private\online;

SOURCES=\
    AddOnlineUser.cpp \
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\BoxID\boxinfo.cpp ===
/*****************************************************************************

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    hvsUtils.cpp

Abstract:

    HVS Test Helper functions

Notes:

*****************************************************************************/

#pragma warning(disable: 4200) // nonstandard extension used : zero-sized array in struct/union

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>
#include <scsi.h>
#include <ntddscsi.h>
#include <ntdddisk.h>
#include <ntddcdrm.h>
#include <ntddcdvd.h>
#include <xbeimage.h>
extern "C"
    {
    #include <init.h>
    }
#define XeImageHeader() ((struct _XBEIMAGE_HEADER*)XBEIMAGE_STANDARD_BASE_ADDRESS)

#include <xtl.h>
#include <stdio.h>
#include <xonlinep.h>

extern "C"
    {
    DECLSPEC_IMPORT
    void
    WINAPI
    HalReadWritePCISpace(
        IN ULONG BusNumber,
        IN ULONG SlotNumber,
        IN ULONG RegisterNumber,
        IN PVOID Buffer,
        IN ULONG Length,
        IN BOOLEAN WritePCISpace
        );
    #define HalReadPCISpace(BusNumber, SlotNumber, RegisterNumber, Buffer, Length) \
        HalReadWritePCISpace(BusNumber, SlotNumber, RegisterNumber, Buffer, Length, FALSE)

    DECLSPEC_IMPORT
    LONG
    WINAPI
    HalReadSMBusValue(
        IN UCHAR SlaveAddress,
        IN UCHAR CommandCode,
        IN BOOLEAN ReadWordValue,
        OUT ULONG *DataValue
        );

    DECLSPEC_IMPORT
    LONG
    WINAPI
    HalWriteSMBusValue(
        IN UCHAR SlaveAddress,
        IN UCHAR CommandCode,
        IN BOOLEAN WriteWordValue,
        IN ULONG DataValue
        );

    void*
    WINAPI
    MmMapIoSpace(
        IN ULONG_PTR PhysicalAddress,
        IN SIZE_T NumberOfBytes,
        IN ULONG Protect
        );

    void
    WINAPI
    MmUnmapIoSpace(
        IN PVOID BaseAddress,
        IN SIZE_T NumberOfBytes
        );
    }

typedef struct _PCI_SLOT_NUMBER {
    union {
        struct {
            ULONG   DeviceNumber:5;
            ULONG   FunctionNumber:3;
            ULONG   Reserved:24;
        } bits;
        ULONG   AsULONG;
    } u;
} PCI_SLOT_NUMBER, *PPCI_SLOT_NUMBER;

FORCEINLINE ULONG REG_RD32(VOID* Ptr, ULONG Addr)
    {
    return *((volatile DWORD*)((BYTE*)(Ptr) + (Addr)));
    }

static DWORD WriteSMC(unsigned char addr, unsigned char value)
    {
    return HalWriteSMBusValue(0x20, addr, FALSE, value);
    }

static DWORD ReadSMC(unsigned char addr)
    {
    DWORD value = 0xCCCCCCCC;
    DWORD status = HalReadSMBusValue(0x21, addr, FALSE, &value);
    return value;
    }

static const char * const vmodes[] =
    {
    "SDTV SCART Analog/Digital",
    "HDTV",
    "VGA",
    "RFU",
    "SDTV Analog/Digital",
    "Power Off",
    "SDTV Analog",
    "No Pack",
    "SMC Error"
    };

static const char * const hwversions[] =
    {
    "Unknown",
    "DVT3", 
    "DVT3",
    "DVT4",
    "DVT6"
    };

static const char * const lang[] = 
    {
    "Unknown",
    "English",
    "Japanese",
    "German",
    "French",
    "Spanish",
    "Italian"
    };

static const char * const videostd[] =
    {
    "Unknown",
    "NTSC_M",
    "NTSC_J",
    "PAL_I"
    };

enum MEDIA_TYPES
	{
	MEDIA_UNKNOWN,
	MEDIA_CDDA,
	MEDIA_CDROM,
	MEDIA_DVD_5_RO,
	MEDIA_DVD_5_RW,
	MEDIA_DVD_9_RO,
	MEDIA_DVD_9_RW,
	MEDIA_HD
	};

static const char *mediaTypeNames[] = 
    {
    "Unknown",
    "CD DA",
    "CD ROM",
    "DVD 5 RO",
    "DVD 5 RW",
    "DVD 9 RO",
    "DVD 9 RW",
    "Hard Disk"
    };

static char* GetHWVersion(unsigned &hwver);
static void DumpClocks(char *buffer, unsigned hwver);
static void GetPeripheral(char *buffer);
static void GetDriveID(char* device, char* model, char* serial, char* firmware);
static DWORD GetDiskType(void);

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)        (sizeof(a) / sizeof(a[0]))
#endif


/*****************************************************************************

Routine Description:

    GetBoxInformation

    Retrieves detailed information on the current box (hw and sw versions 
    etc.)

Arguments:

    none

Return Value:

    char* - newly allocated string

Notes:

    Caller MUST delete[] the returned pointer !!!

*****************************************************************************/
char *GetBoxInformation(void)
    {
    DWORD buffLen;
    bool multiple;
    char *info;
    char *boxInfo = new char[8*1024];
    if(!boxInfo) return NULL;

	memset( boxInfo, 0, 8 * 1024 );

    info = boxInfo;

    char *tempBuff = new char[1024];
    if(!tempBuff)
        {
        delete[] boxInfo;
        return NULL;
        }

	ULONGLONG ullMachineID = 0;

	char szSerial[12];

    // hw version
    unsigned baseInitTable = 0;

    info += sprintf(info, "HW Ver = %s %s\n", GetHWVersion(baseInitTable), (XboxHardwareInfo->Flags&XBOX_HW_FLAG_DEVKIT_KERNEL)?"DEVKIT":"RETAIL");
   
	_XOnlineGetMachineID( &ullMachineID );
	info += sprintf( info, "Machine ID = %I64u\n", ullMachineID );

	_XOnlineGetSerialNumber( szSerial );
	info += sprintf( info, "Serial Number = %.12s\n", szSerial );

	info += sprintf(info, "GPU Ver = %02X, ", XboxHardwareInfo->GpuRevision);
    info += sprintf(info, "MCP Ver = %02X, ", XboxHardwareInfo->McpRevision);

    // get SMC version
    tempBuff[0] = (char)ReadSMC(0x01);
    tempBuff[1] = (char)ReadSMC(0x01);
    tempBuff[2] = (char)ReadSMC(0x01);
    tempBuff[3] = '\0';
    info += sprintf(info, "SMC Ver = %s\n", tempBuff);

    // get clock speeds
  //  DumpClocks(tempBuff, baseInitTable);
   // info += sprintf(info, "%s\n", tempBuff);

    // get memory information
    DWORD memTest = ReadSMC(0x14);
    #define NV_PEXTDEV_BOOT_0                                0x00101000 // private\windows\directx\dxg\d3d8\se\nv_ref_2a.h
    #define XPCICFG_GPU_MEMORY_REGISTER_BASE_0               0xFD000000 // private\ntos\inc\xpcicfg.h
    if((REG_RD32((void*)XPCICFG_GPU_MEMORY_REGISTER_BASE_0, NV_PEXTDEV_BOOT_0) & 0x0000C0000) == 0)
        info += sprintf(info, "Memory Type = Micron, ");
    else
        info += sprintf(info, "Memory Type = Samsung, ");
    info += sprintf(info, "Memory Size = %s\n", ReadSMC(0x15)==1 ? "4 Meg chips" : "2 Meg chips");
  //  info += sprintf(info, "Memory Test = 0x%08X (%s)\n", memTest, memTest?"FAIL":"PASS");

    // get hard disk manufacturer
    memset(tempBuff, 0, 1024);
    GetDriveID("\\Device\\Harddisk0\\Partition0", tempBuff, tempBuff+384, tempBuff+768);
    info += sprintf(info, "HD = %s, %s, %s\n", tempBuff, tempBuff+384, tempBuff+768);

    // get dvd drive information
    memset(tempBuff, 0, 1024);
    GetDriveID("\\Device\\CdRom0", tempBuff, tempBuff+384, tempBuff+768);
    info += sprintf(info, "DVD = %s, %s, %s\n", tempBuff, tempBuff+384, tempBuff+768);
    info += sprintf(info, "Media Type = %s\n", mediaTypeNames[GetDiskType()]);

    // hw flags "private/ntos/inc/init.h"
    tempBuff[0] = '\0';
    multiple=false;
    if(XboxHardwareInfo->Flags & XBOX_HW_FLAG_INTERNAL_USB_HUB)
        {
        if(multiple) multiple = !strcat(tempBuff, ", ");
        multiple = !!strcat(tempBuff, "USB HUB");
        }
    if(XboxHardwareInfo->Flags & XBOX_480P_MACROVISION_ENABLED)
        {
        if(multiple) multiple = !strcat(tempBuff, ", ");
        multiple = !!strcat(tempBuff, "480p");
        }
    info += sprintf(info, "HW Flags = %s\n", tempBuff);

    // language
    DWORD language = XGetLanguage();
    if(language >= ARRAYSIZE(lang)) language = 0;
    info += sprintf(info, "Language = %s\n", lang[language]);

    // game region
    DWORD region = XGetLanguage();
    if(region == XC_GAME_REGION_NA)
        info += sprintf(info, "Game Region = North America\n");
    else if(region == XC_GAME_REGION_JAPAN)
        info += sprintf(info, "Game Region = Japan\n");
    else if(region == XC_GAME_REGION_RESTOFWORLD)
        info += sprintf(info, "Game Region = Europe, etc.\n");
    else
        info += sprintf(info, "Game Region = Unknown\n");

    // av pack
    DWORD avpack = ReadSMC(0x04);
    if(avpack > 8) avpack = 8; // ReadSMC() can return 0xCCCCCCCC on error
    info += sprintf(info, "AV Pack = %s\n", vmodes[avpack]);

    // video standard
    DWORD vidStd = XGetVideoStandard();
    if(vidStd >= ARRAYSIZE(videostd)) vidStd = 0;
    info += sprintf(info, "Video Standard = %s\n", videostd[vidStd]);

    // get video flags
    DWORD vidFlags = XGetVideoFlags();
    multiple=false;
    tempBuff[0] = '\0';
    strcat(tempBuff, "(");
    if(vidFlags & XC_VIDEO_FLAGS_WIDESCREEN)
        {
        if(multiple) multiple = !strcat(tempBuff, ", ");
        multiple = !!strcat(tempBuff, "WIDE");
        }
    if(vidFlags & XC_VIDEO_FLAGS_HDTV_720p)
        {
        if(multiple) multiple = !strcat(tempBuff, ", ");
        multiple = !!strcat(tempBuff, "720p");
        }
    if(vidFlags & XC_VIDEO_FLAGS_HDTV_1080i)
        {
        if(multiple) multiple = !strcat(tempBuff, ", ");
        multiple = !!strcat(tempBuff, "1080i");
        }
    if(vidFlags & XC_VIDEO_FLAGS_LETTERBOX)
        {
        if(multiple) multiple = !strcat(tempBuff, ", ");
        multiple = !!strcat(tempBuff, "LETTERBOX");
        }
    if(vidFlags & XC_VIDEO_FLAGS_PAL_60Hz)
        {
        if(multiple) multiple = !strcat(tempBuff, ", ");
        multiple = !!strcat(tempBuff, "PAL60Hz");
        }
    strcat(tempBuff, ")");
    info += sprintf(info, "Video Flags = %s\n", tempBuff);

    // get audio flags
    DWORD audioFlags = XGetAudioFlags();
    multiple=false;
    tempBuff[0] = '\0';
    if(audioFlags & XC_AUDIO_FLAGS_SURROUND)
        {
        if(multiple) multiple = !strcat(tempBuff, ", ");
        multiple = !!strcat(tempBuff, "SURROUND");
        }
    if(audioFlags & XC_AUDIO_FLAGS_STEREO)
        {
        if(multiple) multiple = !strcat(tempBuff, ", ");
        multiple = !!strcat(tempBuff, "STEREO");
        }
    if(audioFlags & XC_AUDIO_FLAGS_MONO)
        {
        if(multiple) multiple = !strcat(tempBuff, ", ");
        multiple = !!strcat(tempBuff, "MONO");
        }
    if(audioFlags & XC_AUDIO_FLAGS_ENABLE_AC3)
        {
        if(multiple) multiple = !strcat(tempBuff, ", ");
        multiple = !!strcat(tempBuff, "AC3");
        }
    if(audioFlags & XC_AUDIO_FLAGS_ENABLE_DTS)
        {
        if(multiple) multiple = !strcat(tempBuff, ", ");
        multiple = !!strcat(tempBuff, "DTS");
        }
    info += sprintf(info, "Audio Flags = %s\n", tempBuff);

    // USB Devices
    tempBuff[0] = '\0';
    GetPeripheral(tempBuff);
    info += sprintf(info, "Peripherals = %s\n", tempBuff);

    // Kernel and library version
    info += sprintf(info, "ROM Version = %u %s\n", XboxKrnlVersion->Build, (!!(0x8000 & XboxKrnlVersion->Qfe))?"checked":"free");
    info += sprintf(info, "XTL Version = %u %s\n", XeImageHeader()->XapiLibraryVersion->BuildVersion, XeImageHeader()->XapiLibraryVersion->DebugBuild?"checked":"free");

    // SMC info
    info += sprintf(info, "CPU Temp = %d, ", ReadSMC(0x09));
    info += sprintf(info, "AIR Temp = %d, ", ReadSMC(0x0A));
    info += sprintf(info, "Fan = %d, ", ReadSMC(0x10));
    info += sprintf(info, "SMC Error = %d\n", ReadSMC(0x0F));


    delete[] tempBuff;
    return boxInfo;
    }






static DWORD GetDiskType(void)
    {
    DWORD type = MEDIA_UNKNOWN;
    #define ALIGN_DOWN(length, type)    ((ULONG)(length) & ~(sizeof(type) - 1))
    #define ALIGN_UP(length, type)      (ALIGN_DOWN(((ULONG)(length) + sizeof(type) - 1), type))

    DWORD returned;
    NTSTATUS status;
    HANDLE handle;
    OBJECT_ATTRIBUTES ObjA;
    OBJECT_STRING VolumeString;
    IO_STATUS_BLOCK IoStatusBlock;

    RtlInitObjectString(&VolumeString, "\\Device\\CdRom0");
    InitializeObjectAttributes(&ObjA, &VolumeString, OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = NtCreateFile(&handle,
                            SYNCHRONIZE|GENERIC_READ,
                            &ObjA,
                            &IoStatusBlock,
                            0,
                            FILE_ATTRIBUTE_NORMAL,
                            FILE_SHARE_READ, FILE_OPEN,
                            FILE_SYNCHRONOUS_IO_NONALERT);


    DVD_READ_STRUCTURE readStruct;
    UCHAR readStructureOutput[ALIGN_UP(sizeof(DVD_DESCRIPTOR_HEADER) + sizeof(DVD_LAYER_DESCRIPTOR), ULONG)];

    memset(&readStruct, 0, sizeof(DVD_READ_STRUCTURE));
    memset(readStructureOutput, 0, sizeof(readStructureOutput));

    // try DVD Read Structure
    readStruct.Format = DvdPhysicalDescriptor;

    returned = 0;
    BOOL result = DeviceIoControl(handle, IOCTL_DVD_READ_STRUCTURE, &readStruct, sizeof(DVD_READ_STRUCTURE), readStructureOutput, sizeof(readStructureOutput), &returned, NULL);

    NtClose(handle);

    if(result)
        {
        DVD_LAYER_DESCRIPTOR *layerDescr = (DVD_LAYER_DESCRIPTOR *)(&readStructureOutput[sizeof(DVD_DESCRIPTOR_HEADER)]);
        BYTE layerType = (layerDescr->BookType) | (layerDescr->BookVersion << 4);
        if(layerDescr->LayerType == 1)
            {
            if(layerDescr->NumberOfLayers == 0)
                type = MEDIA_DVD_5_RO;
            else type = MEDIA_DVD_9_RO;
            }
        else
            {
            if(layerDescr->NumberOfLayers == 0)
                type = MEDIA_DVD_5_RW;
            else type = MEDIA_DVD_9_RW;
            }
        }

    // not a DVD disk...
    else
        {
	    CDROM_TOC toc;
        memset(&toc, 0, sizeof(CDROM_TOC));
		result = DeviceIoControl( handle, IOCTL_CDROM_READ_TOC, &toc, sizeof(CDROM_TOC), &toc, sizeof(CDROM_TOC), &returned, NULL);
        if(result)
            {
            if(toc.FirstTrack == toc.LastTrack) type = MEDIA_CDROM;
            type = MEDIA_CDDA;
            }
        else
            {
            type = MEDIA_UNKNOWN;
            }
        }

    NtClose(handle);
    return type;
    }



static void DumpClocks(char *buffer, unsigned hwver)
    {
    #define NV_PRAMDAC_NVPLL_COEFF 0x00680500 /* RW-4R */
    const float F_XTAL_135 = 13.5f;
    const float F_XTAL_166 = 16.6667f;

    PCI_SLOT_NUMBER SlotNumber;
    DWORD MPLLCoeff;
    DWORD m;
    DWORD n;
    DWORD p;
    DWORD fsbspeed;
    DWORD vcofreq;
    DWORD nvclk;
    DWORD nvpll;
    DWORD fsb_pdiv;
    DWORD mem_pdiv;
    DWORD mclk;
    DWORD cpuspeed;
    float XTAL;

    if(hwver >= 0x46) 
        {
        XTAL = F_XTAL_166;
        }
    else
        {
        XTAL = F_XTAL_135;
        }

    //
    // Read CR_CPU_MPLL_COEFF 
    //
    SlotNumber.u.AsULONG = 0;
    SlotNumber.u.bits.DeviceNumber = 0;
    SlotNumber.u.bits.FunctionNumber = 3;
    HalReadPCISpace(0, SlotNumber.u.AsULONG, 0x6C, &MPLLCoeff, sizeof(MPLLCoeff));

    m = MPLLCoeff & 0xFF;
    n = (MPLLCoeff >> 8) & 0xFF;

    if(m != 0)
        {
        //
        // Calculate cpu frequency
        //
        fsbspeed = (DWORD)((XTAL / m) * n);

        cpuspeed = (DWORD)((XTAL / m) * n * 11 / 2);
    
        //
        // Calculate nvclk
        //
        nvpll = REG_RD32((void*)XPCICFG_GPU_MEMORY_REGISTER_BASE_0, NV_PRAMDAC_NVPLL_COEFF);
        m = nvpll & 0xFF;
        n = (nvpll >> 8)  & 0xFF;
        p = (nvpll >> 16) & 0xFF;
    
        nvclk = (m != 0) ? (DWORD)((n * XTAL / (1 << p) / m)) : 0;
    
        //
        // Calculate vco
        //
        m = MPLLCoeff & 0xFF;
        n = (MPLLCoeff >> 8) & 0xFF;
        fsb_pdiv = (MPLLCoeff >> 16) & 0xF;
        
        vcofreq = (DWORD)((XTAL / m) * (fsb_pdiv * 2 * n));
    
        //
        // Calculate mclk
        //
        mem_pdiv = (MPLLCoeff >> 20) & 0xF;
        mclk = (DWORD)(vcofreq / (2 * mem_pdiv));

        sprintf(buffer, "Crystal=%s, FSB=%d, CPU=%d, NVCLK=%d, VCO=%d, MCLK=%d",
            (hwver >= 0x46) ? "16.6" : "13.5", fsbspeed, cpuspeed, nvclk, vcofreq, mclk);
        }
    else
        {
        sprintf(buffer, "unknown");
        }
    }

static char* GetHWVersion(unsigned &hwver)
    {
    #define PAGE_SIZE                   4096
    #define ROM_SIZE                    (1024 * 1024)
    #define ROM_VERSION_OFFSET          30 // In DWORDs (0x78 is the absolute offset)
    #define ROM_VERSION_BYTE_OFFSET     0x78
    #define FLASH_BASE_ADDRESS          0xFFF00000
    #define FLASH_REGION_SIZE           (0xFFFFFFFF-FLASH_BASE_ADDRESS-1)

    LPBYTE RomBase = (LPBYTE)MmMapIoSpace(FLASH_BASE_ADDRESS, PAGE_SIZE, PAGE_READWRITE | PAGE_NOCACHE);

    if(RomBase == NULL) return (char*)hwversions[0];

    hwver = RomBase[ROM_VERSION_BYTE_OFFSET];

    MmUnmapIoSpace(RomBase, PAGE_SIZE);

    //
    // Init table version < 0x40: Old DVT 3 Boxes with NV2A A02 old metal 7 (NVCLK 155, CPU 665)
    // Init table version = 0x40: New DVT 3 Boxes with NV2A A02 new metal 7 (Faster)
    // Init table version = 0x46: DVT4/5
    // Init table version > 0x46: DVT6
    //
    //DebugPrint("hwver: 0x%X\n", hwver);

    if(hwver <  0x40) return (char*)hwversions[1];
    if(hwver == 0x40) return (char*)hwversions[2];
    if(hwver == 0x46) return (char*)hwversions[3];
    if(hwver >  0x46) return (char*)hwversions[4];
    return (char*)hwversions[0];
    }

static void GetPeripheral(char *buffer)
    {
    DWORD XIDMasks[] = {
        XDEVICE_PORT0_MASK,
        XDEVICE_PORT1_MASK,
        XDEVICE_PORT2_MASK,
        XDEVICE_PORT3_MASK
        };
    DWORD XMUMasks[] = {
        XDEVICE_PORT0_TOP_MASK,
        XDEVICE_PORT1_TOP_MASK,
        XDEVICE_PORT2_TOP_MASK,
        XDEVICE_PORT3_TOP_MASK,
        XDEVICE_PORT0_BOTTOM_MASK,
        XDEVICE_PORT1_BOTTOM_MASK,
        XDEVICE_PORT2_BOTTOM_MASK,
        XDEVICE_PORT3_BOTTOM_MASK
        };
    DWORD insertions, insertions2;
    unsigned i;
    unsigned port, slot;

    buffer[0] = '\0';

    bool dukeMask[4] = { false, false, false, false }; // Duke zeros bug

    // look for dukes
    insertions = XGetDevices(XDEVICE_TYPE_GAMEPAD);
    for(i=0; i<XGetPortCount(); i++)
        {
        port = i%XGetPortCount();
        if(insertions & XIDMasks[i])
            {
            buffer+=sprintf(buffer, "Duke(%d); ", port);
            dukeMask[port] = true;
            }
        }

    // check for mus
    insertions = XGetDevices(XDEVICE_TYPE_MEMORY_UNIT);
    for(i=0; i<ARRAYSIZE(XMUMasks); i++)
        {
        slot = i<XGetPortCount()?1:2;
        port = i%XGetPortCount();
        if(insertions & XMUMasks[i])
            {
            buffer+=sprintf(buffer, "MU(%d, %d); ", port, slot);

            // Duke zeros bug
            // TODO can remove this code when bug is fixed
            if(dukeMask[port] == false)
                {
                //DukeZerosBug();
                }
            }
        }

    /*
    // check for hawks
    insertions = XGetDevices(XDEVICE_TYPE_VOICE_MICROPHONE);
    //insertions2 = XGetDevices(XDEVICE_TYPE_VOICE_HEADPHONE);
    for(i=0; i<ARRAYSIZE(XMUMasks); i++)
        {
        slot = i<XGetPortCount()?1:2;
        port = i%XGetPortCount();
        if(insertions & XMUMasks[i])
            {
            buffer+=sprintf(buffer, "Hawk(%d, %d); ", port, slot);
            }
        }
        */

    // look for dvd dongle
    /* 
    insertions = XGetDevices(XDEVICE_TYPE_IR_REMOTE);
    for(i=0; i<XGetPortCount(); i++)
        {
        port = i % XGetPortCount();
        if(insertions & XIDMasks[i])
            {
            buffer+=sprintf(buffer, "DVD(%d); ", port);
            }
        }
    */

    // look for keyboard
    #ifdef DEBUG_KEYBOARD
    insertions = XGetDevices(XDEVICE_TYPE_DEBUG_KEYBOARD);
    for(i=0; i<XGetPortCount(); i++)
        {
        port = i % XGetPortCount();
        if(insertions & XIDMasks[i])
            {
            buffer+=sprintf(buffer, "Keyboard(%d); ", port);
            }
        }
    #endif // DEBUG_KEYBOARD

    }


static void GetDriveID(char* device, char* model, char* serial, char* firmware)
    {
    char *temp;
    unsigned i;
    DWORD returned;
    NTSTATUS status;
    HANDLE fileHandle;
    OBJECT_ATTRIBUTES ObjA;
    OBJECT_STRING VolumeString;
    IO_STATUS_BLOCK IoStatusBlock;
    char buffer[sizeof(ATA_PASS_THROUGH) + 512];
    PATA_PASS_THROUGH atapt = (PATA_PASS_THROUGH)buffer;


    RtlInitObjectString(&VolumeString, device);
    InitializeObjectAttributes(&ObjA,&VolumeString,OBJ_CASE_INSENSITIVE,NULL,NULL);

    status = NtCreateFile(&fileHandle,
                            SYNCHRONIZE|GENERIC_READ,
                            &ObjA,
                            &IoStatusBlock,
                            0,
                            FILE_ATTRIBUTE_NORMAL,
                            FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN,
                            FILE_SYNCHRONOUS_IO_NONALERT);

    atapt->DataBufferSize = 512;
    atapt->DataBuffer = atapt + 1;

    atapt->IdeReg.bFeaturesReg     = 0;
    atapt->IdeReg.bSectorCountReg  = 0;
    atapt->IdeReg.bSectorNumberReg = 0;
    atapt->IdeReg.bCylLowReg       = 0;
    atapt->IdeReg.bCylHighReg      = 0;
    atapt->IdeReg.bDriveHeadReg    = 0;
    atapt->IdeReg.bHostSendsData   = 0;

    if(strstr(device, "CdRom") != NULL) atapt->IdeReg.bCommandReg = 0xa1;
    else atapt->IdeReg.bCommandReg = 0xec;

    status = DeviceIoControl(fileHandle,
                             IOCTL_IDE_PASS_THROUGH,
                             atapt,
                             sizeof(ATA_PASS_THROUGH),
                             atapt,
                             sizeof(ATA_PASS_THROUGH),
                             &returned,
                             FALSE);
    NtClose(fileHandle);

    PIDE_IDENTIFY_DATA IdData = (PIDE_IDENTIFY_DATA)atapt->DataBuffer;

    for ( i=0; i<sizeof(IdData->ModelNumber); i+=2 ) {
        model[i + 0] = IdData->ModelNumber[i + 1];
        model[i + 1] = IdData->ModelNumber[i + 0];
    }
    model[i] = '\0';
    temp = strstr(model, "  ");
    if(temp) *temp = '\0';

    for ( i=0; i<sizeof(IdData->SerialNumber); i+=2 ) {
        serial[i + 0] = IdData->SerialNumber[i + 1];
        serial[i + 1] = IdData->SerialNumber[i + 0];
    }
    serial[i] = '\0';
    temp = strstr(serial, "  ");
    if(temp) *temp = '\0';

    for ( i=0; i<sizeof(IdData->FirmwareRevision); i+=2 ) {
        firmware[i + 0] = IdData->FirmwareRevision[i + 1];
        firmware[i + 1] = IdData->FirmwareRevision[i + 0];
    }
    firmware[i] = '\0';
    temp = strstr(firmware, "  ");
    if(temp) *temp = '\0';
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\AddOnlineUser\AddOnlineUser.cpp ===
// ---------------------------------------------------------------------------------------
// conline.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "xonp.h"
#include "xonver.h"
#include <string.h>

#if 0
#include <windows.h>
#include <xbox.h>
#include <winsockx.h>
#include <winsockp.h>
#include <xonlinep.h>
#include <stdlib.h>
#include <stdio.h>
#include <xonp.h>
#endif

#ifdef XONLINE_FEATURE_XBOX
extern CXo *         g_pXo;
#define GetXo()      g_pXo
#endif

static const LPSTR INI_FILE_LOCATION = "d:\\AddOnlineUser.ini";

#define MAX_USERS 9
char g_acArgvFromIniFile[MAX_USERS][256];
int g_ctUsers = 0;

#define Verify(x) do { if (!(x)) DbgBreak(); } while (0)

HRESULT ReadUserData( char* pcUser, PXONLINEP_USER pNewUser );
HRESULT ParseIniFile( void );
HRESULT XOnlineSetMachineAccount(IN PXONLINE_USER pUser);

#ifdef _XBOX
int __cdecl main(int argc, char * argv[])
#else
class CTestXOnline : public CXOnline
{
public:
    CTestXOnline(char * pszXbox = NULL) : CXOnline(pszXbox) {}
    int Main(int argc, char * argv[]);
};

int __cdecl main(int argc, char * argv[])
{
    int result;
    char buffer[128];

    sprintf(buffer, "%s@Nic/0", getenv("COMPUTERNAME") );
    CTestXOnline * pTestXOnline = new CTestXOnline(buffer);
    result = pTestXOnline->Main(argc, argv);
    delete pTestXOnline;
    return(result);
}

int CTestXOnline::Main(int argc, char * argv[])
#endif
{
    HRESULT hr;
    NTSTATUS Status;
    XONLINE_USER users[XONLINE_MAX_STORED_ONLINE_USERS];
    DWORD cUsers;
    XONLINEP_USER newUser;
    char* pcNewUserInfo = NULL;
    BYTE abConfigData[CONFIG_DATA_LENGTH];
    XC_ONLINE_MACHINE_ACCOUNT_STRUCT* pMachineAccount;
    HANDLE hConfigVolume;
    DWORD dwPort, dwSlot;
    CHAR chDrive;
    int i;
    
#ifdef XNET_FEATURE_TRACE
    Tag(Verbose) = TAG_ENABLE;
    Tag(Warning) = TAG_ENABLE;
#endif

    hr = XOnlineStartup(NULL);
    Verify(hr == S_OK);

#ifdef _XBOX
    XInitDevices(0,NULL);

    //
    // Sleep a while to make sure the USB is ready
    //
    Sleep (1000);
#endif

    hr = XOnlineGetUsers( &users[0], &cUsers );
    Verify ( SUCCEEDED( hr ) );

    for (i=0; i<(int)cUsers; ++i)
    {
        TraceSz2( Verbose, "XOnlineGetUsers returned user %s with options 0x%08X", users[i].name, users[i].dwUserOptions);

        if ((users[i].dwUserOptions & XONLINE_USER_OPTION_CAME_FROM_MU) == 0)
        {
            hr = _XOnlineRemoveUserFromHD( &users[i] );
            Verify ( SUCCEEDED( hr ) );
        }
    }

#ifdef _XBOX
    hr = ParseIniFile();
    Verify(hr == S_OK);

    for (i=0; i<g_ctUsers; ++i)
    {
        pcNewUserInfo = g_acArgvFromIniFile[i];

        hr = ReadUserData( pcNewUserInfo, &newUser );
        Verify(hr == S_OK);

        //
        // Check if machine account.
        //
        if (_stricmp(newUser.kingdom, "_devkit_") == 0)
        {
            if (!GetXo()->SetMachineAccount( &newUser ))
            {
                DbgBreak();
            }
        }
        else if (newUser.index == 0xFFFFFFFF)
        {
            hr = _XOnlineAddUserToHD((PXONLINE_USER)&newUser);
            Verify(hr == S_OK);
            TraceSz1(Verbose, "AddOnlineUser succeeded for %s", pcNewUserInfo);
        }
        else
        {
            dwPort = newUser.index;
            dwSlot = newUser.hr;
            Assert( dwPort < XGetPortCount() && dwSlot < 2 );
            Status = XMountMU( dwPort, dwSlot, &chDrive );
            if (Status == STATUS_SUCCESS)
            {
                hr = _XOnlineSetUserInMU(chDrive, (PXONLINE_USER)&newUser);            
                Verify(hr == S_OK);
                TraceSz3(Verbose, "AddOnlineUser succeeded for %s into port:%d slot:%d", pcNewUserInfo, dwPort, dwSlot);
                XUnmountMU( dwPort, dwSlot );
            }
        }
        
    }
#else
    if (argc != 2)
    {
        printf("Usage:\n    AddOnlineUser PuidInHex,name,kingdom,domain,KeyInHex,OptionsInHex,PinInHex\n");
        return (1);
    }

    hr = ReadUserData( argv[1], &newUser );
    Verify(hr == S_OK);

    //
    // Check if machine account.
    //
    if (_stricmp(newUser.kingdom, "_devkit_") == 0)
    {
        if (!GetXo()->SetMachineAccount( &newUser ))
        {
            DbgBreak();
        }
    }
    else if (newUser.index == 0xFFFFFFFF)
    {
        hr = _XOnlineAddUserToHD((PXONLINE_USER)&newUser);
        Verify(hr == S_OK);    
        printf("AddOnlineUser succeeded for %s\n",argv[1]);
    }
#endif

    hr = XOnlineCleanup();
    Verify(hr == S_OK);

    return (0);
}


HRESULT ParseIniFile( void )
{
    HRESULT hr = S_OK;
    FILE* pIniFile = NULL;
    int iVal = 0;

    //
    // open the ini file
    //

    if ( SUCCEEDED( hr ) )
    {
        pIniFile = fopen( INI_FILE_LOCATION, "rb" );
        if (pIniFile == NULL)
        {
            hr = E_FAIL;
            goto Cleanup;
        }
    }

    while (fgets( g_acArgvFromIniFile[g_ctUsers], sizeof(g_acArgvFromIniFile[g_ctUsers]), pIniFile ) != NULL)
    {
        iVal = strlen(g_acArgvFromIniFile[g_ctUsers]);
        if (g_acArgvFromIniFile[g_ctUsers][iVal-1] == '\n')
        {
            g_acArgvFromIniFile[g_ctUsers][iVal-1] = '\0';
        }

        g_ctUsers++;
        if (g_ctUsers == MAX_USERS)
        {
            break;
        }    
    }
    
    if (g_ctUsers == 0)
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
Cleanup:
    //
    // close the ini file
    //
    if ( pIniFile )
    {
        fclose( pIniFile );
    }

    return hr;
}

HRESULT
ReadUserData( char* pcUser, PXONLINEP_USER pNewUser )
{
    HRESULT hr = S_OK;
    INT iVal = 0;
    DWORD i;
    
    CHAR szString[256];
    BYTE byPin[XONLINE_PIN_LENGTH];

    union un {
        ULONGLONG ullVals[2];
        BYTE byVals[16];
    } unn;

    //
    // make sure the ini file is not NULL
    //

    if ( NULL == pcUser )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    //
    // make sure the user is not NULL
    //

    if ( NULL == pNewUser )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    RtlZeroMemory( pNewUser, sizeof(*pNewUser) );

    pNewUser->index = 0xFFFFFFFF;
    
    if ( SUCCEEDED( hr ) )
    {

        ZeroMemory( szString, sizeof( szString ) );

        //
        // the format string is:
        //
        // 16 hex charecters put into an 8 byte value
        // , delimieter
        // 63 maximum valid email string charecters
        // , delimeter
        // 32 hex charecters (16 + 16) put into 2-8 byte values
        // , delimiter
        // 255 maximum valid string charecters (optional)

        iVal = sscanf( pcUser, 
                       "%16I64x,%16[a-zA-Z0-9!#$%&'*+./=?^_`{|}~@-],%12[a-zA-Z0-9!#$%&'*+./=?^_`{|}~@-],%20[a-zA-Z0-9!#$%&'*+./=?^_`{|}~@-],%16I64x%16I64x,%255[a-zA-Z0-9,:]", 
                       &pNewUser->xuid.qwUserID,
                       pNewUser->name,
                       pNewUser->kingdom,
                       pNewUser->domain,
                       unn.ullVals + 1,
                       unn.ullVals,
                       szString );

        hr = 0 != iVal ? S_OK : E_FAIL;

        if (FAILED(hr))
        {
            goto Cleanup;
        }

        strcpy( pNewUser->realm, "passport.net" );

        if ( EOF == iVal )
        {
            hr = E_OUTOFMEMORY;
        }
    }
            
    //
    // copy the values from the union into the key
    //

    for ( i = 0; i < sizeof( ULONGLONG ) * 2 && SUCCEEDED( hr ); i++ )
    {
        pNewUser->key[i] = unn.byVals[sizeof( ULONGLONG ) * 2 - i - 1];
    }

    //
    // Parse the optional params. These are (all optional)
    // 8 bytes flags
    // , delimieter
    // 8 bytes pin
    // , delimiter
    // port,slot
    // : delimiter
    // 237 chars
    //

    if ( SUCCEEDED( hr ) )
    {
        iVal = sscanf( szString, "%8x,%8x:%d,%d", &pNewUser->dwUserOptions, byPin, &pNewUser->index, &pNewUser->hr );

        hr = 0 != iVal ? S_OK : E_FAIL;
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }

    //
    // rearange the pin value
    //

    for ( i = 0; i < XONLINE_PIN_LENGTH && SUCCEEDED( hr ); i++ )
    {
        pNewUser->pin[i] = byPin[XONLINE_PIN_LENGTH - i - 1];
    }

    TimeStampOnlineUserStruct( (XC_ONLINE_USER_ACCOUNT_STRUCT*) pNewUser );

    //
    // spit back the hr
    //
Cleanup:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\BoxID\main.cpp ===
#include <xtl.h>
#include <xdbg.h>
#include <xonline.h>
#include <UserInterface.h>

char* GetBoxInformation( void );

void __cdecl main( void )
{
	HRESULT hr = S_OK;

	char* szBoxInfo = NULL;
	char* szTemp = NULL;
	char* szStr = NULL;

	DWORD dwY = 30;

	//
	// create the screens
	//

	CUserInterfaceScreen mainScreen( NULL, 
		                             0xFFFFFFFF, 
									 0x00000000, 
									 320, 
									 250 );

	//
	// setup online
	//

	if ( SUCCEEDED( hr ) )
	{
		hr = XOnlineStartup( NULL );
		ASSERT( SUCCEEDED( hr ) || !"Could not startup online" );
	}

	//
	// create user interface
	//

	if ( SUCCEEDED( hr ) )
	{
		hr = CUserInterface::Instance()->Initialize( &mainScreen,
													 640, 
													 480, 
													 0,
													 NULL );

		ASSERT( SUCCEEDED( hr ) || !"Could not setup user interface" );
	}

	//
	// set empty text
	//

	mainScreen.SetText( "" );

	//
	// get the box info
	//

	szBoxInfo = GetBoxInformation();

	//
	// make sure box info is good
	//

	if ( NULL == szBoxInfo )
	{
		ASSERT( !"Could not get box information" );
		hr = E_OUTOFMEMORY;
	}

	//
	// get the first string
	//

	if ( SUCCEEDED( hr ) )
	{
		szStr = szBoxInfo;
		szTemp = strstr( szBoxInfo, "\n" );
	}

	//
	// keep cycling through strings, adding them to the ui
	//

	while ( NULL != szTemp && SUCCEEDED( hr ) )
	{
		//
		// convert next return to null char
		//

		*szTemp = '\0';

		//
		// add the string to the ui text, move down one line
		//

		mainScreen.AddUIText( new CUserInterfaceText( szStr, 320, dwY, 0xFFFFFFFF, 0x00000000 ) );
		dwY += 20;

		//
		// point to the beginning of the next string
		//

		szStr = szTemp + 1;

		//
		// find the next line feed
		//

		szTemp = strstr( szTemp + 1, "\n" );

	} 

	//
	// Begin the app loop
	//

	while ( SUCCEEDED( hr ) )
	{	
		//
		// Update the scene
		//

		hr = CUserInterface::Instance()->Update();
		ASSERT( SUCCEEDED( hr ) || !"Could not update the scene" );

	}

	//
	// kill the box info
	//

	delete [] szBoxInfo;

	//
	// kill online
	//

	XOnlineCleanup();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\certstor\async.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       async.cpp
//
//  Contents:   Async Parameter Management
//
//  History:    05-Aug-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
#include <async.h>
//+---------------------------------------------------------------------------
//
//  Function:   CryptCreateAsyncHandle
//
//  Synopsis:   create async param handle
//
//----------------------------------------------------------------------------
BOOL WINAPI
CryptCreateAsyncHandle (
     IN DWORD dwFlags,
     OUT PHCRYPTASYNC phAsync
     )
{
    CCryptAsyncHandle* pAsyncHandle;

    pAsyncHandle = new CCryptAsyncHandle( dwFlags );
    if ( pAsyncHandle == NULL )
    {
        SetLastError( E_OUTOFMEMORY );
        return( FALSE );
    }

    *phAsync = pAsyncHandle;
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   CryptSetAsyncParam
//
//  Synopsis:   set async parameter
//
//----------------------------------------------------------------------------
BOOL WINAPI
CryptSetAsyncParam (
     IN HCRYPTASYNC hAsync,
     IN LPSTR pszParamOid,
     IN LPVOID pvParam,
     IN OPTIONAL PFN_CRYPT_ASYNC_PARAM_FREE_FUNC pfnFree
     )
{
    return( ( ( CCryptAsyncHandle* )hAsync )->SetAsyncParam(
                                                 pszParamOid,
                                                 pvParam,
                                                 pfnFree
                                                 ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CryptGetAsyncParam
//
//  Synopsis:   get async parameter
//
//----------------------------------------------------------------------------
BOOL WINAPI
CryptGetAsyncParam (
     IN HCRYPTASYNC hAsync,
     IN LPSTR pszParamOid,
     OUT LPVOID* ppvParam,
     OUT OPTIONAL PFN_CRYPT_ASYNC_PARAM_FREE_FUNC* ppfnFree
     )
{
    return( ( ( CCryptAsyncHandle* )hAsync )->GetAsyncParam(
                                                 pszParamOid,
                                                 ppvParam,
                                                 ppfnFree
                                                 ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CryptCloseAsyncHandle
//
//  Synopsis:   close async handle
//
//----------------------------------------------------------------------------
BOOL WINAPI
CryptCloseAsyncHandle (
     IN HCRYPTASYNC hAsync
     )
{
    delete ( CCryptAsyncHandle * )hAsync;
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptAsyncHandle::CCryptAsyncHandle, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CCryptAsyncHandle::CCryptAsyncHandle (DWORD dwFlags)
{
    m_pConstOidList = NULL;
    m_pStrOidList = NULL;
    InitializeCriticalSection( &m_AsyncLock );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptAsyncHandle::~CCryptAsyncHandle, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CCryptAsyncHandle::~CCryptAsyncHandle ()
{
    FreeOidList( m_pConstOidList, TRUE );
    FreeOidList( m_pStrOidList, FALSE );
    DeleteCriticalSection( &m_AsyncLock );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptAsyncHandle::SetAsyncParam, public
//
//  Synopsis:   set an async parameter, if the pvParam is NULL then
//              the parameter is removed and freed if a free function
//              has been specified
//
//----------------------------------------------------------------------------
BOOL
CCryptAsyncHandle::SetAsyncParam (
                      LPSTR pszParamOid,
                      LPVOID pvParam,
                      PFN_CRYPT_ASYNC_PARAM_FREE_FUNC pfnFree
                      )
{
    BOOL               fReturn = FALSE;
    PCRYPT_ASYNC_PARAM pParam = NULL;
    BOOL               fConstOid = ( (DWORD_PTR)pszParamOid <= 0xFFFF );

    EnterCriticalSection( &m_AsyncLock );

    pParam = FindAsyncParam( pszParamOid, fConstOid );

    if ( pvParam == NULL )
    {
        if ( pParam != NULL )
        {
            RemoveAsyncParam( pParam );
            FreeAsyncParam( pParam, fConstOid );
            fReturn = TRUE;
        }
        else
        {
            SetLastError( E_INVALIDARG );
        }

        LeaveCriticalSection( &m_AsyncLock );
        return( fReturn );
    }

    if ( pParam != NULL )
    {
        if ( pParam->pfnFree != NULL )
        {
            (*pParam->pfnFree)( pszParamOid, pvParam );
        }

        pParam->pvParam = pvParam;

        LeaveCriticalSection( &m_AsyncLock );
        return( TRUE );
    }

    if ( AllocAsyncParam(
              pszParamOid,
              fConstOid,
              pvParam,
              pfnFree,
              &pParam
              ) == TRUE )
    {
        AddAsyncParam( pParam, fConstOid );
        fReturn = TRUE;
    }
    else
    {
        fReturn = FALSE;
    }

    LeaveCriticalSection( &m_AsyncLock );
    return( fReturn );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptAsyncHandle::GetAsyncParam, public
//
//  Synopsis:   get an async parameter
//
//----------------------------------------------------------------------------
BOOL
CCryptAsyncHandle::GetAsyncParam (
                      LPSTR pszParamOid,
                      LPVOID* ppvParam,
                      PFN_CRYPT_ASYNC_PARAM_FREE_FUNC* ppfnFree
                      )
{
    BOOL               fReturn = FALSE;
    PCRYPT_ASYNC_PARAM pFoundParam = NULL;
    BOOL               fConstOid = ( (DWORD_PTR)pszParamOid <= 0xFFFF );

    EnterCriticalSection( &m_AsyncLock );

    pFoundParam = FindAsyncParam( pszParamOid, fConstOid );
    if ( pFoundParam == NULL )
    {
        LeaveCriticalSection( &m_AsyncLock );
        SetLastError( E_INVALIDARG );
        return( FALSE );
    }

    *ppvParam = pFoundParam->pvParam;
    if ( ppfnFree != NULL )
    {
        *ppfnFree = pFoundParam->pfnFree;
    }

    LeaveCriticalSection( &m_AsyncLock );
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptAsyncHandle::AllocAsyncParam, private
//
//  Synopsis:   allocate an async parameter block
//
//----------------------------------------------------------------------------
BOOL
CCryptAsyncHandle::AllocAsyncParam (
                        LPSTR pszParamOid,
                        BOOL fConstOid,
                        LPVOID pvParam,
                        PFN_CRYPT_ASYNC_PARAM_FREE_FUNC pfnFree,
                        PCRYPT_ASYNC_PARAM* ppParam
                        )
{
    HRESULT            hr = S_OK;
    PCRYPT_ASYNC_PARAM pParam;

    pParam = new CRYPT_ASYNC_PARAM;
    if ( pParam != NULL )
    {
        memset( pParam, 0, sizeof( CRYPT_ASYNC_PARAM ) );
        if ( fConstOid == FALSE )
        {
            pParam->pszOid = new CHAR [strlen( pszParamOid ) + 1];
            if ( pParam->pszOid != NULL )
            {
                strcpy( pParam->pszOid, pszParamOid );
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            pParam->pszOid = pszParamOid;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if ( hr != S_OK )
    {
        SetLastError( hr );
        return( FALSE );
    }

    pParam->pvParam = pvParam,
    pParam->pfnFree = pfnFree;
    *ppParam = pParam;

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptAsyncHandle::FreeAsyncParam, private
//
//  Synopsis:   free an async param
//
//----------------------------------------------------------------------------
VOID
CCryptAsyncHandle::FreeAsyncParam (
                       PCRYPT_ASYNC_PARAM pParam,
                       BOOL fConstOid
                       )
{
    if ( pParam->pfnFree != NULL )
    {
        (*pParam->pfnFree)( pParam->pszOid, pParam->pvParam );
    }

    if ( fConstOid == FALSE )
    {
        delete pParam->pszOid;
    }

    delete pParam;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptAsyncHandle::AddAsyncParam, private
//
//  Synopsis:   add an async parameter
//
//----------------------------------------------------------------------------
VOID
CCryptAsyncHandle::AddAsyncParam (
                      PCRYPT_ASYNC_PARAM pParam,
                      BOOL fConstOid
                      )
{
    PCRYPT_ASYNC_PARAM* ppOidList;

    if ( fConstOid == TRUE )
    {
        ppOidList = &m_pConstOidList;
    }
    else
    {
        ppOidList = &m_pStrOidList;
    }

    pParam->pNext = *ppOidList;
    pParam->pPrev = NULL;
    *ppOidList = pParam;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptAsyncHandle::RemoveAsyncParam, private
//
//  Synopsis:   remove an async parameter
//
//----------------------------------------------------------------------------
VOID
CCryptAsyncHandle::RemoveAsyncParam (
                         PCRYPT_ASYNC_PARAM pParam
                         )
{
    if ( pParam->pPrev != NULL )
    {
        pParam->pPrev->pNext = pParam->pNext;
    }

    if ( pParam->pNext != NULL )
    {
        pParam->pNext->pPrev = pParam->pPrev;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptAsyncHandle::FindAsyncParam, private
//
//  Synopsis:   find an async parameter
//
//----------------------------------------------------------------------------
PCRYPT_ASYNC_PARAM
CCryptAsyncHandle::FindAsyncParam (
                       LPSTR pszParamOid,
                       BOOL fConstOid
                       )
{
    PCRYPT_ASYNC_PARAM pParam;

    if ( fConstOid == TRUE )
    {
        pParam = m_pConstOidList;
    }
    else
    {
        pParam = m_pStrOidList;
    }

    while ( pParam != NULL )
    {
        if ( fConstOid == TRUE )
        {
            if ( pParam->pszOid == pszParamOid )
            {
                break;
            }
        }
        else
        {
            if ( _stricmp( pParam->pszOid, pszParamOid ) == 0 )
            {
                break;
            }
        }

        pParam = pParam->pNext;
    }

    return( pParam );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptAsyncHandle::FreeOidList, private
//
//  Synopsis:   free an OID list
//
//----------------------------------------------------------------------------
VOID
CCryptAsyncHandle::FreeOidList (
                       PCRYPT_ASYNC_PARAM pOidList,
                       BOOL fConstOidList
                       )
{
    PCRYPT_ASYNC_PARAM pParam;
    PCRYPT_ASYNC_PARAM pParamNext;

    pParam = pOidList;

    while ( pParam != NULL )
    {
        pParamNext = pParam->pNext;
        FreeAsyncParam( pParam, fConstOidList );
        pParam = pParamNext;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\certstor\async.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       async.h
//
//  Contents:   Async Parameter Management definitions
//
//  History:    05-Aug-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__ASYNC_H__)
#define __ASYNC_H__

//
// CCryptAsyncHandle.  Async parameter handle class, a list of OID
// specified parameters.
//

typedef struct _CRYPT_ASYNC_PARAM {

    LPSTR pszOid;
    LPVOID pvParam;
    PFN_CRYPT_ASYNC_PARAM_FREE_FUNC pfnFree;
    struct _CRYPT_ASYNC_PARAM* pPrev;
    struct _CRYPT_ASYNC_PARAM* pNext;

} CRYPT_ASYNC_PARAM, *PCRYPT_ASYNC_PARAM;

class CCryptAsyncHandle
{
public:

    //
    // Construction
    //

    CCryptAsyncHandle (DWORD dwFlags);
    ~CCryptAsyncHandle ();

    //
    // Management methods
    //

    BOOL SetAsyncParam (
            LPSTR pszParamOid,
            LPVOID pvParam,
            PFN_CRYPT_ASYNC_PARAM_FREE_FUNC pfnFree
            );

    BOOL GetAsyncParam (
            LPSTR pszParamOid,
            LPVOID* ppvParam,
            PFN_CRYPT_ASYNC_PARAM_FREE_FUNC* ppfnFree
            );

private:

    //
    // Lock
    //

    CRITICAL_SECTION   m_AsyncLock;

    //
    // Parameter lists
    //

    PCRYPT_ASYNC_PARAM m_pConstOidList;
    PCRYPT_ASYNC_PARAM m_pStrOidList;

    //
    // Private methods
    //

    BOOL AllocAsyncParam (
              LPSTR pszParamOid,
              BOOL fConstOid,
              LPVOID pvParam,
              PFN_CRYPT_ASYNC_PARAM_FREE_FUNC pfnFree,
              PCRYPT_ASYNC_PARAM* ppParam
              );

    VOID FreeAsyncParam (
             PCRYPT_ASYNC_PARAM pParam,
             BOOL fConstOid
             );

    VOID AddAsyncParam (
            PCRYPT_ASYNC_PARAM pParam,
            BOOL fConstOid
            );

    VOID RemoveAsyncParam (
            PCRYPT_ASYNC_PARAM pParam
            );

    PCRYPT_ASYNC_PARAM FindAsyncParam (
                           LPSTR pszParamOid,
                           BOOL fConstOid
                           );

    VOID FreeOidList (
             PCRYPT_ASYNC_PARAM pOidList,
             BOOL fConstOidList
             );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\certstor\certstr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       certstr.cpp
//
//  Contents:   Certificate String and Unicode Helper APIs
//
//  Functions:
//              CertRDNValueToStrA
//              CertRDNValueToStrW
//              UnicodeNameValueEncodeEx
//              UnicodeNameValueDecodeEx
//              UnicodeNameInfoEncodeEx
//              UnicodeNameInfoDecodeEx
//              CertNameToStrW
//              CertNameToStrA
//              CertStrToNameW
//              CertStrToNameA
//              CertGetNameStringW
//              CertGetNameStringA
//
//  Note:
//      Linked into xenroll.dll. xenroll.dll must be able to work with
//      crypt32.dll 3.02 which doesn't export CryptEncodeObjectEx.
//      xenroll.dll only calls CertNameToStrW.
//
//  History:    24-Mar-96   philh   created
//--------------------------------------------------------------------------


#include "global.hxx"
#include <dbgdef.h>

// All the *pvInfo extra stuff needs to be aligned
#define INFO_LEN_ALIGN(Len)  ((Len + 7) & ~7)

//+-------------------------------------------------------------------------
//  Maps an ASN.1 8 bit character string to a new wide-character (Unicode).
//
//  If fDisableIE4UTF8 isn't set, the 8 bit character string is initially
//  processed as UTF-8 encoded characters.
//
//  If fDisableIE4UTF8 is set or the UTF-8 conversion fails, converts to
//  wide characters by doing a WCHAR cast.
//--------------------------------------------------------------------------
static int WINAPI Asn1ToWideChar(
    IN LPCSTR lp8BitStr,
    IN int cch8Bit,
    IN BOOL fDisableIE4UTF8,
    OUT LPWSTR lpWideCharStr,
    IN int cchWideChar
    )
{
    int cchOutWideChar;

    if (!fDisableIE4UTF8) {
        int cchUTF8WideChar;

        cchUTF8WideChar = UTF8ToWideChar(
            lp8BitStr,
            cch8Bit,
            lpWideCharStr,
            cchWideChar
            );
        if (0 < cchUTF8WideChar)
            return cchUTF8WideChar;
    }

    if (cch8Bit < 0)
        cch8Bit = strlen(lp8BitStr) + 1;
    cchOutWideChar = cch8Bit;

    if (cchWideChar < 0)
        goto InvalidParameter;
    else if (0 == cchWideChar)
        goto CommonReturn;
    else if (cchOutWideChar > cchWideChar)
        goto InsufficientBuffer;

    while (cch8Bit--)
        *lpWideCharStr++ = (unsigned char) *lp8BitStr++;

CommonReturn:
    return cchOutWideChar;

ErrorReturn:
    cchOutWideChar = 0;
    goto CommonReturn;
SET_ERROR(InvalidParameter, ERROR_INVALID_PARAMETER)
SET_ERROR(InsufficientBuffer, ERROR_INSUFFICIENT_BUFFER)
}

//+-------------------------------------------------------------------------
//  Maps a wide-character (Unicode) string to a new ASN.1 8 bit character
//  string.
//--------------------------------------------------------------------------
static inline void WideCharToAsn1(
    IN LPCWSTR lpWideCharStr,
    IN DWORD cchWideChar,
    OUT LPSTR lp8BitStr
    )
{
    while (cchWideChar--)
        *lp8BitStr++ = (unsigned char) (*lpWideCharStr++ & 0xFF);
}

static void *AllocAndDecodeObject(
    IN DWORD dwCertEncodingType,
    IN LPCSTR lpszStructType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN DWORD dwFlags,
    OUT OPTIONAL DWORD *pcbStructInfo = NULL
    )
{
    DWORD cbStructInfo;
    void *pvStructInfo;

    if (!CryptDecodeObjectEx(
            dwCertEncodingType,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            dwFlags | CRYPT_DECODE_ALLOC_FLAG | CRYPT_DECODE_NOCOPY_FLAG,
            &PkiDecodePara,
            (void *) &pvStructInfo,
            &cbStructInfo
            ))
        goto ErrorReturn;

CommonReturn:
    if (pcbStructInfo)
        *pcbStructInfo = cbStructInfo;
    return pvStructInfo;
ErrorReturn:
    pvStructInfo = NULL;
    cbStructInfo = 0;
    goto CommonReturn;
}

typedef BOOL (WINAPI *PFN_NESTED_DECODE_INFO_EX_CALLBACK)(
    IN void *pvDecodeInfo,
    IN DWORD dwFlags,
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
    OUT OPTIONAL void *pvStructInfo,
    IN OUT LONG *plRemainExtra
    );

static BOOL WINAPI NestedDecodeAndAllocInfoEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_NESTED_DECODE_INFO_EX_CALLBACK pfnDecodeInfoExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    BOOL fResult;
    LONG lRemainExtra;
    DWORD cbStructInfo;
    void *pvDecodeInfo = NULL;
    DWORD cbDecodeInfo;

    if (NULL == pvStructInfo || (dwFlags & CRYPT_DECODE_ALLOC_FLAG)) {
        cbStructInfo = 0;
        lRemainExtra = 0;
    } else {
        cbStructInfo = *pcbStructInfo;
        lRemainExtra = (LONG) cbStructInfo;
    }

    if (!CryptDecodeObjectEx(
            dwCertEncodingType,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            CRYPT_DECODE_ALLOC_FLAG | CRYPT_DECODE_NOCOPY_FLAG,
            &PkiDecodePara,
            (void *) &pvDecodeInfo,
            &cbDecodeInfo
            )) goto DecodeObjectError;

    if (!pfnDecodeInfoExCallback(
            pvDecodeInfo,
            dwFlags & ~CRYPT_DECODE_ALLOC_FLAG,
            pDecodePara,
            pvStructInfo,
            &lRemainExtra
            )) goto DecodeCallbackError;

    if (dwFlags & CRYPT_DECODE_ALLOC_FLAG) {
        void *pv;
        PFN_CRYPT_ALLOC pfnAlloc = PkiGetDecodeAllocFunction(pDecodePara);

        assert(0 > lRemainExtra);
        lRemainExtra = -lRemainExtra;
        cbStructInfo = (DWORD) lRemainExtra;

        if (NULL == (pv = pfnAlloc(cbStructInfo)))
            goto OutOfMemory;
        if (!pfnDecodeInfoExCallback(
                pvDecodeInfo,
                dwFlags & ~CRYPT_DECODE_ALLOC_FLAG,
                pDecodePara,
                pv,
                &lRemainExtra
                )) {
            PFN_CRYPT_FREE pfnFree = PkiGetDecodeFreeFunction(pDecodePara);
            pfnFree(pv);
            goto DecodeCallbackError;
        }
        *((void **) pvStructInfo) = pv;
        assert(0 <= lRemainExtra);
    }

    if (0 <= lRemainExtra) {
        cbStructInfo -= (DWORD) lRemainExtra;
    } else {
        cbStructInfo += (DWORD) -lRemainExtra;
        if (pvStructInfo) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fResult = FALSE;
            goto CommonReturn;
        }
    }

    fResult = TRUE;
CommonReturn:
    *pcbStructInfo = cbStructInfo;
    PkiFree(pvDecodeInfo);
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_DECODE_ALLOC_FLAG)
        *((void **) pvStructInfo) = NULL;
    cbStructInfo = 0;
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(DecodeObjectError)
TRACE_ERROR(DecodeCallbackError)
TRACE_ERROR(OutOfMemory)
}

//+-------------------------------------------------------------------------
//  Convert a Name Value to a null terminated char string
//
//  Returns the number of bytes converted including the terminating null
//  character. If psz is NULL or csz is 0, returns the required size of the
//  destination string (including the terminating null char).
//
//  If psz != NULL && csz != 0, returned psz is always NULL terminated.
//
//  Note: csz includes the NULL char.
//--------------------------------------------------------------------------
DWORD
WINAPI
CertRDNValueToStrA(
    IN DWORD dwValueType,
    IN PCERT_RDN_VALUE_BLOB pValue,
    OUT OPTIONAL LPSTR psz,
    IN DWORD csz
    )
{
    DWORD cszOut = 0;
    LPWSTR pwsz = NULL;
    DWORD cwsz;

    if (psz == NULL)
        csz = 0;

    cwsz = CertRDNValueToStrW(
        dwValueType,
        pValue,
        NULL,                   // pwsz
        0                       // cwsz
        );
    if (pwsz = (LPWSTR) PkiNonzeroAlloc(cwsz * sizeof(WCHAR))) {
        CertRDNValueToStrW(
            dwValueType,
            pValue,
            pwsz,
            cwsz
            );

        int cchMultiByte;
        cchMultiByte = WideCharToMultiByte(
            CP_ACP,
            0,                      // dwFlags
            pwsz,
            -1,                     // Null terminated
            psz,
            (int) csz,
            NULL,                   // lpDefaultChar
            NULL                    // lpfUsedDefaultChar
            );
        if (cchMultiByte < 1)
            cszOut = 0;
        else
            // Subtract off the trailing null terminator
            cszOut = (DWORD) cchMultiByte - 1;

        PkiFree(pwsz);
    }

    if (csz != 0) {
        // Always NULL terminate
        *(psz + cszOut) = '\0';
    }
    return cszOut + 1;
}


//+-------------------------------------------------------------------------
//  Convert a Name Value to a null terminated WCHAR string
//
//  Returns the number of WCHARs converted including the terminating null
//  WCHAR. If pwsz is NULL or cwsz is 0, returns the required size of the
//  destination string (including the terminating null WCHAR).
//
//  If pwsz != NULL && cwsz != 0, returned pwsz is always NULL terminated.
//
//  Note: cwsz includes the NULL WCHAR.
//--------------------------------------------------------------------------
DWORD
WINAPI
CertRDNValueToStrW(
    IN DWORD dwValueType,
    IN PCERT_RDN_VALUE_BLOB pValue,
    OUT OPTIONAL LPWSTR pwsz,
    IN DWORD cwsz
    )
{
    BOOL fDisableIE4UTF8;
    DWORD cwszOut = 0;

    if (pwsz == NULL)
        cwsz = 0;

    fDisableIE4UTF8 = (0 != (dwValueType & CERT_RDN_DISABLE_IE4_UTF8_FLAG));
    dwValueType &= CERT_RDN_TYPE_MASK;

    if (dwValueType == CERT_RDN_UNICODE_STRING ||
            dwValueType == CERT_RDN_UTF8_STRING) {
        cwszOut = pValue->cbData / sizeof(WCHAR);
        if (cwsz > 0) {
            cwszOut = min(cwszOut, cwsz - 1);
            if (cwszOut)
                memcpy((BYTE *) pwsz, pValue->pbData, cwszOut * sizeof(WCHAR));
        }
    } else if (dwValueType == CERT_RDN_UNIVERSAL_STRING) {
        // Get the "low" 16 bits from each 32 bit integer
        cwszOut = pValue->cbData / sizeof(DWORD);
        if (cwsz > 0) {
            cwszOut = min(cwszOut, cwsz - 1);
            DWORD cdw = cwszOut;
            DWORD *pdwIn = (DWORD *) pValue->pbData;
            LPWSTR pwszOut = pwsz;
            for ( ; cdw > 0; cdw--)
                *pwszOut++ = (WCHAR) *pdwIn++;
        }
    } else {
        // Treat as a 8 bit character string
        if (cwsz != 1) {
            int cchWideChar;

            if (cwsz == 0)
                cchWideChar = 0;
            else
                cchWideChar = cwsz - 1;

            if (dwValueType != CERT_RDN_T61_STRING)
                fDisableIE4UTF8 = TRUE;
            cchWideChar = Asn1ToWideChar(
                (LPSTR) pValue->pbData,
                pValue->cbData,
                fDisableIE4UTF8,
                pwsz,
                cchWideChar
                );
            if (cchWideChar <= 0)
                cwszOut = 0;
            else
                cwszOut = (DWORD) cchWideChar;
        }
    }

    if (cwsz != 0) {
        // Always NULL terminate
        *(pwsz + cwszOut) = L'\0';
    }
    return cwszOut + 1;
}

//+-------------------------------------------------------------------------
//  Wide Character functions
//
//  Needed, since we don't link with 'C' runtime
//--------------------------------------------------------------------------
static inline BOOL IsSpaceW(WCHAR wc)
{
    return wc == L' ' || (wc >= 0x09 && wc <= 0x0d);
}
static BOOL IsInStrW(LPCWSTR pwszList, WCHAR wc)
{
    WCHAR wcList;
    while (wcList = *pwszList++)
        if (wc == wcList)
            return TRUE;
    return FALSE;
}

//+-------------------------------------------------------------------------
//  Checks if an ASN.1 numeric character
//--------------------------------------------------------------------------
static inline BOOL IsNumericW(WCHAR wc)
{
    return (wc >= L'0' && wc <= L'9') || wc == L' ';
}

//+-------------------------------------------------------------------------
//  Checks if an ASN.1 printable character
//--------------------------------------------------------------------------
static inline BOOL IsPrintableW(WCHAR wc)
{
    return (wc >= L'A' && wc <= L'Z') || (wc >= L'a' && wc <= L'z') ||
        IsNumericW(wc) || IsInStrW(L"\'()+,-./:=?", wc);
}

//+-------------------------------------------------------------------------
//  Returns 0 if the unicode character string doesn't contain any invalid
//  characters. Otherwise, returns CRYPT_E_INVALID_NUMERIC_STRING,
//  CRYPT_E_INVALID_PRINTABLE_STRING or CRYPT_E_INVALID_IA5_STRING with
//  *pdwErrLocation updated with the index of the first invalid character.
//--------------------------------------------------------------------------
static DWORD CheckUnicodeValueType(
        IN DWORD dwValueType,
        IN LPCWSTR pwszAttr,
        IN DWORD cchAttr,
        OUT DWORD *pdwErrLocation
        )
{
    DWORD i;
    DWORD dwErr;

    assert(dwValueType & CERT_RDN_TYPE_MASK);
    *pdwErrLocation = 0;

    dwErr = 0;
    for (i = 0; i < cchAttr; i++) {
        WCHAR wc = pwszAttr[i];

        switch (dwValueType & CERT_RDN_TYPE_MASK) {
        case CERT_RDN_NUMERIC_STRING:
            if (!IsNumericW(wc))
                dwErr = (DWORD) CRYPT_E_INVALID_NUMERIC_STRING;
            break;
        case CERT_RDN_PRINTABLE_STRING:
            if (!IsPrintableW(wc))
                dwErr = (DWORD) CRYPT_E_INVALID_PRINTABLE_STRING;
            break;
        case CERT_RDN_IA5_STRING:
            if (wc > 0x7F)
                dwErr = (DWORD) CRYPT_E_INVALID_IA5_STRING;
            break;
        default:
            return 0;
        }

        if (0 != dwErr) {
            assert(i <= CERT_UNICODE_VALUE_ERR_INDEX_MASK);
            *pdwErrLocation = i & CERT_UNICODE_VALUE_ERR_INDEX_MASK;
            return dwErr;
        }
    }

    return 0;
}

//+-------------------------------------------------------------------------
//  Set/Free/Get CERT_RDN attribute value. The values are unicode.
//+-------------------------------------------------------------------------
static BOOL SetUnicodeRDNAttributeValue(
        IN DWORD dwValueType,
        IN PCERT_RDN_VALUE_BLOB pSrcValue,
        IN BOOL fDisableCheckType,
        OUT PCERT_RDN_VALUE_BLOB pDstValue,
        OUT OPTIONAL DWORD *pdwErrLocation
        )
{
    BOOL fResult;
    LPCWSTR pwszAttr;
    DWORD cchAttr;
    DWORD dwErr;

    if (pdwErrLocation)
        *pdwErrLocation = 0;

    dwValueType &= CERT_RDN_TYPE_MASK;

    memset(pDstValue, 0, sizeof(CERT_RDN_VALUE_BLOB));
    if (CERT_RDN_ANY_TYPE == dwValueType)
        goto InvalidArg;
    assert(IS_CERT_RDN_CHAR_STRING(dwValueType));

    pwszAttr = pSrcValue->pbData ? (LPCWSTR) pSrcValue->pbData : L"";
    cchAttr = pSrcValue->cbData ?
        pSrcValue->cbData / sizeof(WCHAR) : wcslen(pwszAttr);

    // Update Destination Value
    if (cchAttr) {
        switch (dwValueType) {
        case CERT_RDN_UNICODE_STRING:
        case CERT_RDN_UTF8_STRING:
            // Use source. No allocation or copy required
            pDstValue->pbData = (BYTE *) pwszAttr;
            pDstValue->cbData = cchAttr * sizeof(WCHAR);
            break;
        case CERT_RDN_UNIVERSAL_STRING:
            // Update the "low" 16 bits of each 32 bit integer with
            // the UNICODE character
            {
                DWORD cdw = cchAttr;
                DWORD *pdwDst;
                LPCWSTR pwszSrc = pwszAttr;

                if (NULL == (pdwDst = (DWORD *) PkiNonzeroAlloc(
                        cdw * sizeof(DWORD))))
                    goto OutOfMemory;
                pDstValue->pbData = (BYTE *) pdwDst;
                pDstValue->cbData = cdw * sizeof(DWORD);
                for ( ; cdw > 0; cdw--)
                    *pdwDst++ = ((DWORD) *pwszSrc++) & 0xFFFF;
            }
            break;
        default:
            // Convert each unicode character to 8 Bit character
            {
                BYTE *pbDst;

                if (pdwErrLocation && !fDisableCheckType) {
                    // Check that the unicode string doesn't contain any
                    // invalid dwValueType characters.
                    if (0 != (dwErr = CheckUnicodeValueType(
                            dwValueType,
                            pwszAttr,
                            cchAttr,
                            pdwErrLocation
                            ))) goto InvalidUnicodeValueType;
                }

                if (NULL == (pbDst = (BYTE *) PkiNonzeroAlloc(cchAttr)))
                    goto OutOfMemory;
                pDstValue->pbData = pbDst;
                pDstValue->cbData = cchAttr;

                WideCharToAsn1(
                    pwszAttr,
                    cchAttr,
                    (LPSTR) pbDst
                    );
            }
        }
    }

    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidArg, E_INVALIDARG)
SET_ERROR_VAR(InvalidUnicodeValueType, dwErr)
TRACE_ERROR(OutOfMemory)
}

static void FreeUnicodeRDNAttributeValue(
        IN DWORD dwValueType,
        IN OUT PCERT_RDN_VALUE_BLOB pValue
        )
{
    switch (dwValueType & CERT_RDN_TYPE_MASK) {
    case CERT_RDN_UNICODE_STRING:
    case CERT_RDN_UTF8_STRING:
    case CERT_RDN_ENCODED_BLOB:
    case CERT_RDN_OCTET_STRING:
        break;
    default:
        PkiFree(pValue->pbData);
    }
}

static BOOL GetUnicodeRDNAttributeValue(
        IN DWORD dwValueType,
        IN PCERT_RDN_VALUE_BLOB pSrcValue,
        IN DWORD dwFlags,
        OUT PCERT_RDN_VALUE_BLOB pDstValue,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    DWORD cbData;
    BYTE *pbSrcData;
    BOOL fDisableIE4UTF8;

    // Get Unicode value length
    cbData = pSrcValue->cbData;
    pbSrcData = pSrcValue->pbData;

    fDisableIE4UTF8 =
        (0 != (dwFlags & CRYPT_UNICODE_NAME_DECODE_DISABLE_IE4_UTF8_FLAG));

    assert(0 == (dwValueType & ~CERT_RDN_TYPE_MASK));
    dwValueType &= CERT_RDN_TYPE_MASK;

    switch (dwValueType) {
    case CERT_RDN_UNICODE_STRING:
    case CERT_RDN_UTF8_STRING:
    case CERT_RDN_ENCODED_BLOB:
    case CERT_RDN_OCTET_STRING:
        // The above cbData
        break;
    case CERT_RDN_UNIVERSAL_STRING:
        // 4 byte string. Will only copy the lower 16 bits to unicode
        cbData = (cbData / 4) * sizeof(WCHAR);
        break;
    default:
        // Length of resultant WideChar
        if (cbData) {
            int cchWideChar;

            if (dwValueType != CERT_RDN_T61_STRING)
                fDisableIE4UTF8 = TRUE;
            cchWideChar = Asn1ToWideChar(
                (LPSTR) pbSrcData,
                cbData,
                fDisableIE4UTF8,
                NULL,                   // lpWideCharStr
                0                       // cchWideChar
                );
            if (cchWideChar <= 0)
                goto Asn1ToWideCharError;
            cbData = cchWideChar * sizeof(WCHAR);
        }
    }

    // Note, +sizeof(WCHAR) is unicode value's NULL terminator
    lAlignExtra = INFO_LEN_ALIGN(cbData + sizeof(WCHAR));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        pDstValue->pbData = pbExtra;
        pDstValue->cbData = cbData;

        switch (dwValueType) {
        case CERT_RDN_UNICODE_STRING:
        case CERT_RDN_UTF8_STRING:
        case CERT_RDN_ENCODED_BLOB:
        case CERT_RDN_OCTET_STRING:
            if (cbData)
                memcpy(pbExtra, pbSrcData, cbData);
            break;
        case CERT_RDN_UNIVERSAL_STRING:
            // Update the unicode characters with the "low" 16 bits
            // of each DWORD
            {
                DWORD cdw = cbData / sizeof(WCHAR);
                DWORD *pdwSrc = (DWORD *) pbSrcData;
                LPWSTR pwszDst = (LPWSTR) pbExtra;
                for ( ; cdw > 0; cdw--)
                    *pwszDst++ = (WCHAR) *pdwSrc++;
            }
            break;
        default:
            // Convert UTF8 to unicode
            if (cbData) {
                int cchWideChar;
                cchWideChar = Asn1ToWideChar(
                    (LPSTR) pbSrcData,
                    pSrcValue->cbData,
                    fDisableIE4UTF8,
                    (LPWSTR) pbExtra,
                    cbData / sizeof(WCHAR)
                    );
                if (cchWideChar > 0) {
                    if (((DWORD) cchWideChar * sizeof(WCHAR)) <= cbData) {
                        pDstValue->cbData = cchWideChar * sizeof(WCHAR);
                        *((LPWSTR) pbExtra + cchWideChar) = L'\0';
                    }
                 } else {
                    assert(0);
                    goto Asn1ToWideCharError;
                }
            }
        }
        // Ensure NULL termination
        memset(pbExtra + cbData, 0, sizeof(WCHAR));
        pbExtra += lAlignExtra;
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(Asn1ToWideCharError)
}

//+-------------------------------------------------------------------------
//  Encode the "UNICODE" Name Value
//--------------------------------------------------------------------------
BOOL WINAPI UnicodeNameValueEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_NAME_VALUE pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    DWORD dwValueType;
    CERT_NAME_VALUE DstInfo;
    DWORD dwErrLocation;
    BOOL fDisableCheckType;

    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;

    dwValueType = pInfo->dwValueType;
    if (!IS_CERT_RDN_CHAR_STRING(dwValueType)) {
        *pcbEncoded = 0;
        SetLastError((DWORD) CRYPT_E_NOT_CHAR_STRING);
        return FALSE;
    }

    DstInfo.dwValueType = dwValueType & CERT_RDN_TYPE_MASK;
    fDisableCheckType =
        (0 != (dwFlags & CRYPT_UNICODE_NAME_ENCODE_DISABLE_CHECK_TYPE_FLAG) ||
                0 != (dwValueType & CERT_RDN_DISABLE_CHECK_TYPE_FLAG));
    if (!SetUnicodeRDNAttributeValue(dwValueType, &pInfo->Value,
            fDisableCheckType, &DstInfo.Value, &dwErrLocation)) {
        fResult = FALSE;
        *pcbEncoded = dwErrLocation;
        goto CommonReturn;
    }

    fResult = CryptEncodeObjectEx(
        dwCertEncodingType,
        X509_NAME_VALUE,
        &DstInfo,
        dwFlags & ~CRYPT_UNICODE_NAME_ENCODE_DISABLE_CHECK_TYPE_FLAG,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

CommonReturn:
    FreeUnicodeRDNAttributeValue(dwValueType, &DstInfo.Value);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Decode the "UNICODE" Name Value
//--------------------------------------------------------------------------
BOOL WINAPI UnicodeNameValueDecodeExCallback(
        IN void *pvDecodeInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    PCERT_NAME_VALUE pNameValue = (PCERT_NAME_VALUE) pvDecodeInfo;
    PCERT_NAME_VALUE pInfo = (PCERT_NAME_VALUE) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    PCERT_RDN_VALUE_BLOB pValue;

    if (!IS_CERT_RDN_CHAR_STRING(pNameValue->dwValueType))
        goto NotCharString;

    lRemainExtra -= sizeof(CERT_NAME_VALUE);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
        pValue = NULL;
    } else {
        pbExtra = (BYTE *) pInfo + sizeof(CERT_NAME_VALUE);
        pInfo->dwValueType = pNameValue->dwValueType;
        pValue = &pInfo->Value;
    }

    if (!GetUnicodeRDNAttributeValue(
            pNameValue->dwValueType,
            &pNameValue->Value,
            dwFlags,
            pValue,
            &pbExtra,
            &lRemainExtra
            )) goto DecodeError;

    fResult = TRUE;
CommonReturn:
    *plRemainExtra = lRemainExtra;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(NotCharString, CRYPT_E_NOT_CHAR_STRING)
TRACE_ERROR(DecodeError)
}

BOOL WINAPI UnicodeNameValueDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return NestedDecodeAndAllocInfoEx(
        dwCertEncodingType,
        X509_NAME_VALUE,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        UnicodeNameValueDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Default ordered list of acceptable RDN attribute value types. Used when
//  OIDInfo's ExtraInfo.cbData == 0. Or when ExtraInfo contains an empty
//  list.
//--------------------------------------------------------------------------
static const DWORD rgdwDefaultValueType[] = {
    CERT_RDN_PRINTABLE_STRING,
    CERT_RDN_UNICODE_STRING,
    0
};

//+-------------------------------------------------------------------------
//  Default X500 OID Information entry
//--------------------------------------------------------------------------
static CCRYPT_OID_INFO DefaultX500Info = {
    sizeof(CCRYPT_OID_INFO),            // cbSize
    "",                                 // pszOID
    L"",                                // pwszName
    0,                                  // dwLength
    0, NULL                             // ExtraInfo
};

// Please update the following if you add a new entry to the RDNAttrTable in
// oidinfo.cpp with a longer pwszName
#define MAX_X500_KEY_LEN    64

//+-------------------------------------------------------------------------
//  Checks if character needs to be quoted
//
//  Defined in RFC1779
//--------------------------------------------------------------------------
static inline BOOL IsQuotedW(WCHAR wc)
{
    return IsInStrW(L",+=\"\n<>#;", wc);
}

//+-------------------------------------------------------------------------
//  Checks if "decoded" unicode RDN value needs to be quoted
//--------------------------------------------------------------------------
static BOOL IsQuotedUnicodeRDNValue(PCERT_RDN_VALUE_BLOB pValue)
{
    LPCWSTR pwszValue = (LPCWSTR) pValue->pbData;
    DWORD cchValue = pValue->cbData / sizeof(WCHAR);
    if (0 == cchValue)
        return TRUE;

    // First or Last character is whitespace
    if (IsSpaceW(pwszValue[0]) || IsSpaceW(pwszValue[cchValue - 1]))
        return TRUE;

    for ( ; cchValue > 0; cchValue--, pwszValue++)
        if (IsQuotedW(*pwszValue))
            return TRUE;
    return FALSE;
}


//+-------------------------------------------------------------------------
//  Get the first dwValueType from the attribute's ordered list that is
//  an acceptable type for the input attribute character string.
//
//  If no type is acceptable, update the *pdwErrLocation with the first
//  bad character position using the last type in the list.
//--------------------------------------------------------------------------
static DWORD GetUnicodeValueType(
        IN PCCRYPT_OID_INFO pX500Info,
        IN LPCWSTR pwszAttr,
        IN DWORD cchAttr,
        IN DWORD dwUnicodeFlags,
        OUT DWORD *pdwErrLocation
        )
{
    DWORD dwValueType;
    const DWORD *pdwValueType;
    DWORD cValueType;
    DWORD dwErr = (DWORD) E_UNEXPECTED;
    DWORD i;

    pdwValueType = (DWORD *) pX500Info->ExtraInfo.pbData;
    cValueType = pX500Info->ExtraInfo.cbData / sizeof(DWORD);
    // Need at least two entries: a dwValueType and a 0 terminator. Otherwise,
    // use default value types.
    if (2 > cValueType || 0 == pdwValueType[0]) {
        pdwValueType = rgdwDefaultValueType;
        cValueType = sizeof(rgdwDefaultValueType) / sizeof(DWORD);
    }

    *pdwErrLocation = 0;
    for (i = 0; i < cValueType && 0 != (dwValueType = pdwValueType[i]); i++) {
        if (CERT_RDN_UNICODE_STRING == dwValueType) {
            if (dwUnicodeFlags & CERT_RDN_ENABLE_UTF8_UNICODE_FLAG)
                return CERT_RDN_UTF8_STRING;
            else if (0 == (dwUnicodeFlags & CERT_RDN_ENABLE_T61_UNICODE_FLAG))
                return CERT_RDN_UNICODE_STRING;
            else {
                DWORD j;
                for (j = 0; j < cchAttr; j++) {
                    if (pwszAttr[j] > 0xFF)
                        return CERT_RDN_UNICODE_STRING;
                }
                return CERT_RDN_T61_STRING;
            }
        }
        dwErr = CheckUnicodeValueType(
            dwValueType,
            pwszAttr,
            cchAttr,
            pdwErrLocation
            );

        if (0 == dwErr)
            return dwValueType;
    }

    assert(dwErr);
    SetLastError(dwErr);

    return 0;
}


//+-------------------------------------------------------------------------
//  Get an acceptable dwValueType associated with the OID for the input
//  attribute character string.
//
//  If no type is acceptable, update the *pdwErrLocation with the indices
//  of the RDN, RDNAttribute, and character string.
//--------------------------------------------------------------------------
static DWORD GetUnicodeX500OIDValueType(
        IN LPCSTR pszObjId,
        IN LPCWSTR pwszAttr,
        IN DWORD cchAttr,
        IN DWORD dwRDNIndex,
        IN DWORD dwAttrIndex,
        IN DWORD dwUnicodeFlags,
        OUT DWORD *pdwErrLocation
        )
{
    PCCRYPT_OID_INFO pX500Info;
    DWORD dwValueType;

    assert(pszObjId);
    if (NULL == pszObjId)
        pszObjId = "";

    // Attempt to find the OID in the table. If OID isn't found,
    // use default
    if (NULL == (pX500Info = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            (void *) pszObjId,
            CRYPT_RDN_ATTR_OID_GROUP_ID
            )))
        pX500Info = &DefaultX500Info;

    if (0 == (dwValueType = GetUnicodeValueType(
            pX500Info,
            pwszAttr,
            cchAttr,
            dwUnicodeFlags,
            pdwErrLocation
            ))) {
        // Include the dwRDNIndex and dwAttrIndex in the error location.
        assert(dwRDNIndex <= CERT_UNICODE_RDN_ERR_INDEX_MASK);
        assert(dwAttrIndex <= CERT_UNICODE_ATTR_ERR_INDEX_MASK);
        *pdwErrLocation |=
            ((dwRDNIndex & CERT_UNICODE_RDN_ERR_INDEX_MASK) <<
                CERT_UNICODE_RDN_ERR_INDEX_SHIFT) |
            ((dwAttrIndex & CERT_UNICODE_ATTR_ERR_INDEX_MASK) <<
                CERT_UNICODE_ATTR_ERR_INDEX_SHIFT);
    }
    return dwValueType;
}

//+-------------------------------------------------------------------------
//  Set/Free/Get CERT_RDN_ATTR. The values are unicode.
//--------------------------------------------------------------------------
static BOOL SetUnicodeRDNAttribute(
        IN PCERT_RDN_ATTR pSrcRDNAttr,
        IN DWORD dwRDNIndex,
        IN DWORD dwAttrIndex,
        IN DWORD dwFlags,
        IN OUT PCERT_RDN_ATTR pDstRDNAttr,
        OUT DWORD *pdwErrLocation
        )
{
    BOOL fResult;
    DWORD dwValueType = pSrcRDNAttr->dwValueType;
    PCERT_RDN_VALUE_BLOB pSrcValue;
    LPCWSTR pwszAttr;
    DWORD cchAttr;
    DWORD dwErr;

    DWORD dwUnicodeFlags;
    BOOL fDisableCheckType;

    if ((dwFlags & CRYPT_UNICODE_NAME_ENCODE_ENABLE_T61_UNICODE_FLAG) ||
            (dwValueType & CERT_RDN_ENABLE_T61_UNICODE_FLAG))
        dwUnicodeFlags = CERT_RDN_ENABLE_T61_UNICODE_FLAG;
    else if ((dwFlags & CRYPT_UNICODE_NAME_ENCODE_ENABLE_UTF8_UNICODE_FLAG) ||
            (dwValueType & CERT_RDN_ENABLE_UTF8_UNICODE_FLAG))
        dwUnicodeFlags = CERT_RDN_ENABLE_UTF8_UNICODE_FLAG;
    else
        dwUnicodeFlags = 0;

    fDisableCheckType =
        (0 != (dwFlags & CRYPT_UNICODE_NAME_ENCODE_DISABLE_CHECK_TYPE_FLAG) ||
                0 != (dwValueType & CERT_RDN_DISABLE_CHECK_TYPE_FLAG));

    dwValueType &= CERT_RDN_TYPE_MASK;

    *pdwErrLocation = 0;
    if (CERT_RDN_ENCODED_BLOB == dwValueType ||
            CERT_RDN_OCTET_STRING == dwValueType) {
        // No unicode conversion on this type
        memcpy(pDstRDNAttr, pSrcRDNAttr, sizeof(CERT_RDN_ATTR));
        return TRUE;
    }

    pSrcValue = &pSrcRDNAttr->Value;
    pwszAttr = pSrcValue->pbData ? (LPCWSTR) pSrcValue->pbData : L"";
    cchAttr = pSrcValue->cbData ?
        pSrcValue->cbData / sizeof(WCHAR) : wcslen(pwszAttr);

    if (0 == dwValueType) {
        if (0 == (dwValueType = GetUnicodeX500OIDValueType(
                pSrcRDNAttr->pszObjId,
                pwszAttr,
                cchAttr,
                dwRDNIndex,
                dwAttrIndex,
                dwUnicodeFlags,
                pdwErrLocation
                ))) goto GetValueTypeError;
    } else if (!fDisableCheckType) {
        if (0 != (dwErr = CheckUnicodeValueType(
                dwValueType,
                pwszAttr,
                cchAttr,
                pdwErrLocation
                ))) {
            // Include the dwRDNIndex and dwAttrIndex in the error location.
            assert(dwRDNIndex <= CERT_UNICODE_RDN_ERR_INDEX_MASK);
            assert(dwAttrIndex <= CERT_UNICODE_ATTR_ERR_INDEX_MASK);
            *pdwErrLocation |=
                ((dwRDNIndex & CERT_UNICODE_RDN_ERR_INDEX_MASK) <<
                    CERT_UNICODE_RDN_ERR_INDEX_SHIFT) |
                ((dwAttrIndex & CERT_UNICODE_ATTR_ERR_INDEX_MASK) <<
                    CERT_UNICODE_ATTR_ERR_INDEX_SHIFT);
            goto InvalidUnicodeValueType;
        }
    }

    pDstRDNAttr->pszObjId = pSrcRDNAttr->pszObjId;
    pDstRDNAttr->dwValueType = dwValueType;

    if (!SetUnicodeRDNAttributeValue(
            dwValueType,
            pSrcValue,
            TRUE,                   // fDisableCheckType
            &pDstRDNAttr->Value,
            NULL                    // OPTIONAL pdwErrLocation
            )) goto SetUnicodeRDNAttributeValueError;

    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetValueTypeError)
SET_ERROR_VAR(InvalidUnicodeValueType, dwErr)
TRACE_ERROR(SetUnicodeRDNAttributeValueError)
}

static void FreeUnicodeRDNAttribute(
        IN OUT PCERT_RDN_ATTR pRDNAttr
        )
{
    FreeUnicodeRDNAttributeValue(pRDNAttr->dwValueType, &pRDNAttr->Value);
}

static BOOL GetUnicodeRDNAttribute(
        IN PCERT_RDN_ATTR pSrcRDNAttr,
        IN DWORD dwFlags,
        OUT PCERT_RDN_ATTR pDstRDNAttr,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lAlignExtra;
    DWORD cbObjId;
    DWORD dwValueType;
    PCERT_RDN_VALUE_BLOB pDstValue;

    // Get Object Identifier length
    if (pSrcRDNAttr->pszObjId)
        cbObjId = strlen(pSrcRDNAttr->pszObjId) + 1;
    else
        cbObjId = 0;

    dwValueType = pSrcRDNAttr->dwValueType;

    lAlignExtra = INFO_LEN_ALIGN(cbObjId);
    *plRemainExtra -= lAlignExtra;
    if (*plRemainExtra >= 0) {
        if(cbObjId) {
            pDstRDNAttr->pszObjId = (LPSTR) *ppbExtra;
            memcpy(*ppbExtra, pSrcRDNAttr->pszObjId, cbObjId);
        } else
            pDstRDNAttr->pszObjId = NULL;
        *ppbExtra += lAlignExtra;

        pDstRDNAttr->dwValueType = dwValueType;
        pDstValue = &pDstRDNAttr->Value;
    } else
        pDstValue = NULL;

    return GetUnicodeRDNAttributeValue(
        dwValueType,
        &pSrcRDNAttr->Value,
        dwFlags,
        pDstValue,
        ppbExtra,
        plRemainExtra
        );
}

//+-------------------------------------------------------------------------
//  Decode the "UNICODE" Name Info
//--------------------------------------------------------------------------
BOOL WINAPI UnicodeNameInfoDecodeExCallback(
        IN void *pvDecodeInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    PCERT_NAME_INFO pNameInfo = (PCERT_NAME_INFO) pvDecodeInfo;
    PCERT_NAME_INFO pInfo = (PCERT_NAME_INFO) pvStructInfo;
    BYTE *pbExtra;
    LONG lRemainExtra = *plRemainExtra;
    LONG lAlignExtra;

    DWORD cRDN, cAttr;
    PCERT_RDN pSrcRDN, pDstRDN;
    PCERT_RDN_ATTR pSrcAttr, pDstAttr;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lRemainExtra -= sizeof(CERT_NAME_INFO);
    if (lRemainExtra < 0)
        pbExtra = NULL;
    else
        pbExtra = (BYTE *) pInfo + sizeof(CERT_NAME_INFO);

    cRDN = pNameInfo->cRDN;
    pSrcRDN = pNameInfo->rgRDN;
    lAlignExtra = INFO_LEN_ALIGN(cRDN * sizeof(CERT_RDN));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        pInfo->cRDN = cRDN;
        pDstRDN = (PCERT_RDN) pbExtra;
        pInfo->rgRDN = pDstRDN;
        pbExtra += lAlignExtra;
    } else
        pDstRDN = NULL;

    // Array of RDNs
    for (; cRDN > 0; cRDN--, pSrcRDN++, pDstRDN++) {
        cAttr = pSrcRDN->cRDNAttr;
        pSrcAttr = pSrcRDN->rgRDNAttr;
        lAlignExtra = INFO_LEN_ALIGN(cAttr * sizeof(CERT_RDN_ATTR));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            pDstRDN->cRDNAttr = cAttr;
            pDstAttr = (PCERT_RDN_ATTR) pbExtra;
            pDstRDN->rgRDNAttr = pDstAttr;
            pbExtra += lAlignExtra;
        } else
            pDstAttr = NULL;

        // Array of attribute/values
        for (; cAttr > 0; cAttr--, pSrcAttr++, pDstAttr++)
            // We're now ready to get the attribute/value stuff
            if (!GetUnicodeRDNAttribute(pSrcAttr, dwFlags,
                    pDstAttr, &pbExtra, &lRemainExtra))
                goto DecodeError;
    }

    fResult = TRUE;
CommonReturn:
    *plRemainExtra = lRemainExtra;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(DecodeError)
}

BOOL WINAPI UnicodeNameInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return NestedDecodeAndAllocInfoEx(
        dwCertEncodingType,
        X509_NAME,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        UnicodeNameInfoDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}



//+-------------------------------------------------------------------------
//  Encode the "UNICODE" Name Info
//--------------------------------------------------------------------------
static void FreeUnicodeNameInfo(
        PCERT_NAME_INFO pInfo
        )
{
    PCERT_RDN pRDN = pInfo->rgRDN;
    if (pRDN) {
        DWORD cRDN = pInfo->cRDN;
        for ( ; cRDN > 0; cRDN--, pRDN++) {
            PCERT_RDN_ATTR pAttr = pRDN->rgRDNAttr;
            if (pAttr) {
                DWORD cAttr = pRDN->cRDNAttr;
                for ( ; cAttr > 0; cAttr--, pAttr++)
                    FreeUnicodeRDNAttribute(pAttr);
                PkiFree(pRDN->rgRDNAttr);
            }
        }
        PkiFree(pInfo->rgRDN);
    }
}

static BOOL SetUnicodeNameInfo(
        IN PCERT_NAME_INFO pSrcInfo,
        IN DWORD dwFlags,
        OUT PCERT_NAME_INFO pDstInfo,
        OUT DWORD *pdwErrLocation
        )
{
    BOOL fResult;
    DWORD cRDN, cAttr;
    DWORD i, j;
    PCERT_RDN pSrcRDN, pDstRDN;
    PCERT_RDN_ATTR pSrcAttr, pDstAttr;

    *pdwErrLocation = 0;

    cRDN = pSrcInfo->cRDN;
    pSrcRDN = pSrcInfo->rgRDN;
    pDstInfo->cRDN = cRDN;
    pDstInfo->rgRDN = NULL;
    if (cRDN > 0) {
        if (NULL == (pDstRDN = (PCERT_RDN) PkiZeroAlloc(
                cRDN * sizeof(CERT_RDN))))
            goto OutOfMemory;
        pDstInfo->rgRDN = pDstRDN;
    }

    // Array of RDNs
    for (i = 0; i < cRDN; i++, pSrcRDN++, pDstRDN++) {
        cAttr = pSrcRDN->cRDNAttr;
        pSrcAttr = pSrcRDN->rgRDNAttr;
        pDstRDN->cRDNAttr = cAttr;

        if (cAttr > 0) {
            if (NULL == (pDstAttr = (PCERT_RDN_ATTR) PkiZeroAlloc(cAttr *
                    sizeof(CERT_RDN_ATTR))))
                goto OutOfMemory;
            pDstRDN->rgRDNAttr = pDstAttr;
        }

        // Array of attribute/values
        for (j = 0; j < cAttr; j++, pSrcAttr++, pDstAttr++) {
            // We're now ready to convert the unicode string
            if (!SetUnicodeRDNAttribute(pSrcAttr, i, j, dwFlags, pDstAttr,
                    pdwErrLocation))
                goto SetUnicodeRDNAttributeError;
        }
    }

    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(SetUnicodeRDNAttributeError)
}

BOOL WINAPI UnicodeNameInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_NAME_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CERT_NAME_INFO DstInfo;
    DWORD dwErrLocation;
    if (!SetUnicodeNameInfo(pInfo, dwFlags, &DstInfo, &dwErrLocation)) {
        if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
            *((void **) pvEncoded) = NULL;
        *pcbEncoded = dwErrLocation;
        fResult = FALSE;
        goto CommonReturn;
    }

    fResult = CryptEncodeObjectEx(
        dwCertEncodingType,
        X509_NAME,
        &DstInfo,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

CommonReturn:
    FreeUnicodeNameInfo(&DstInfo);
    return fResult;
}

static BOOL WINAPI UnicodeNameInfoEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_NAME_INFO pInfo,
        OUT OPTIONAL BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CERT_NAME_INFO DstInfo;
    DWORD dwErrLocation;
    if (!SetUnicodeNameInfo(pInfo, 0, &DstInfo, &dwErrLocation)) {
        *pcbEncoded = dwErrLocation;
        fResult = FALSE;
        goto CommonReturn;
    }

    fResult = CryptEncodeObject(
        dwCertEncodingType,
        X509_NAME,
        &DstInfo,
        pbEncoded,
        pcbEncoded
        );

CommonReturn:
    FreeUnicodeNameInfo(&DstInfo);
    return fResult;
}


static void PutStrW(LPCWSTR pwszPut, LPWSTR *ppwsz, DWORD *pcwsz,
        DWORD *pcwszOut, BOOL fQuote = FALSE)
{
    WCHAR wc;
    while (wc = *pwszPut++) {
        if (L'\"' == wc && fQuote)
            PutStrW(L"\"", ppwsz, pcwsz, pcwszOut, FALSE);
        if (*pcwsz != 1) {
            if (*pcwsz) {
                **ppwsz = wc;
                *ppwsz += 1;
                *pcwsz -= 1;
            }
            *pcwszOut += 1;
        }
        // else
        //  Always reserve space for the NULL terminator.
    }
}

static void PutOIDStrW(
    IN DWORD dwStrType,
    IN LPCSTR pszObjId,
    IN OUT LPWSTR *ppwsz,
    IN OUT DWORD *pcwsz,
    IN OUT DWORD *pcwszOut
    )
{
    // Eliminate the upper flags before switching
    switch (dwStrType & 0xFFFF) {
        case CERT_X500_NAME_STR:
            {
                PCCRYPT_OID_INFO pX500Info;
                if (pX500Info = CryptFindOIDInfo(
                        CRYPT_OID_INFO_OID_KEY,
                        (void *) pszObjId,
                        CRYPT_RDN_ATTR_OID_GROUP_ID
                        )) {
                    if (*pX500Info->pwszName) {
                            PutStrW(pX500Info->pwszName, ppwsz, pcwsz,
                                pcwszOut);
                            PutStrW(L"=", ppwsz, pcwsz, pcwszOut);
                            return;
                    }
                }
                PutStrW(L"OID.", ppwsz, pcwsz, pcwszOut);
            }
            // Fall through
        case CERT_OID_NAME_STR:
            {
                int cchWideChar;
                cchWideChar = MultiByteToWideChar(
                    CP_ACP,
                    0,                      // dwFlags
                    pszObjId,
                    -1,                     // null terminated
                    *ppwsz,
                    *pcwsz) - 1;
                if (cchWideChar > 0) {
                    if (*pcwsz) {
                        assert(*pcwsz > (DWORD)cchWideChar);
                        *pcwsz -= cchWideChar;
                        *ppwsz += cchWideChar;
                    }
                    *pcwszOut += cchWideChar;
                }
                PutStrW(L"=", ppwsz, pcwsz, pcwszOut);
            }
            break;
        case CERT_SIMPLE_NAME_STR:
        default:
            break;
    }
}

static void PutHexW(
    IN PCERT_RDN_VALUE_BLOB pValue,
    IN OUT LPWSTR *ppwsz,
    IN OUT DWORD *pcwsz,
    IN OUT DWORD *pcwszOut
    )
{
    WCHAR wszHex[3];
    BYTE *pb = pValue->pbData;
    DWORD cb = pValue->cbData;

    PutStrW(L"#", ppwsz, pcwsz, pcwszOut);
    wszHex[2] = L'\0';

    for ( ; cb > 0; cb--, pb++) {
        int b;
        b = (*pb >> 4) & 0x0F;
        wszHex[0] = (b <= 9) ? b + L'0' : (b - 10) + L'A';
        b = *pb & 0x0F;
        wszHex[1] = (b <= 9) ? b + L'0' : (b - 10) + L'A';
        PutStrW(wszHex, ppwsz, pcwsz, pcwszOut);
    }
}

static void ReverseNameInfo(
    IN PCERT_NAME_INFO pInfo
    )
{
    DWORD cRDN;
    PCERT_RDN pLo;
    PCERT_RDN pHi;
    CERT_RDN Tmp;

    cRDN = pInfo->cRDN;
    if (0 == cRDN)
        return;

    pLo = pInfo->rgRDN;
    pHi = pInfo->rgRDN + cRDN - 1;
    for ( ; pLo < pHi; pHi--, pLo++) {
        Tmp = *pHi;
        *pHi = *pLo;
        *pLo = Tmp;
    }
}

//+-------------------------------------------------------------------------
//  Convert the decoded certificate name info to a null terminated WCHAR
//  string.
//
//  Note, if CERT_NAME_STR_REVERSE_FLAG is set, reverses the decoded
//  name info RDNs
//--------------------------------------------------------------------------
static DWORD WINAPI CertNameInfoToStrW(
    IN DWORD dwCertEncodingType,
    IN PCERT_NAME_INFO pInfo,
    IN DWORD dwStrType,
    OUT OPTIONAL LPWSTR pwsz,
    IN DWORD cwsz
    )
{
    DWORD cwszOut = 0;

    LPCWSTR pwszRDNSeparator;
    LPCWSTR pwszMultiValueSeparator;
    BOOL fEnableQuoting;

    if (dwStrType & CERT_NAME_STR_SEMICOLON_FLAG)
        pwszRDNSeparator = L"; ";
    else if (dwStrType & CERT_NAME_STR_CRLF_FLAG)
        pwszRDNSeparator = L"\r\n";
    else
        pwszRDNSeparator = L", ";

    if (dwStrType & CERT_NAME_STR_NO_PLUS_FLAG)
        pwszMultiValueSeparator = L" ";
    else
        pwszMultiValueSeparator = L" + ";

    if (dwStrType & CERT_NAME_STR_NO_QUOTING_FLAG)
        fEnableQuoting = FALSE;
    else
        fEnableQuoting = TRUE;

    if (pwsz == NULL)
        cwsz = 0;

    if (pInfo) {
        DWORD cRDN;
        PCERT_RDN pRDN;

        if (dwStrType & CERT_NAME_STR_REVERSE_FLAG)
            ReverseNameInfo(pInfo);

        cRDN = pInfo->cRDN;
        pRDN = pInfo->rgRDN;
        if (0 == cRDN)
            SetLastError((DWORD) CRYPT_E_NOT_FOUND);
        for ( ; cRDN > 0; cRDN--, pRDN++) {
            DWORD cAttr = pRDN->cRDNAttr;
            PCERT_RDN_ATTR pAttr = pRDN->rgRDNAttr;
            for ( ; cAttr > 0; cAttr--, pAttr++) {
                BOOL fQuote;
                PutOIDStrW(dwStrType, pAttr->pszObjId, &pwsz, &cwsz, &cwszOut);

                if (CERT_RDN_ENCODED_BLOB == pAttr->dwValueType ||
                        CERT_RDN_OCTET_STRING == pAttr->dwValueType)
                    PutHexW(&pAttr->Value, &pwsz, &cwsz, &cwszOut);
                else {
                    fQuote = fEnableQuoting && IsQuotedUnicodeRDNValue(
                        &pAttr->Value);
                    if (fQuote)
                        PutStrW(L"\"", &pwsz, &cwsz, &cwszOut);
                    PutStrW((LPCWSTR) pAttr->Value.pbData, &pwsz, &cwsz,
                        &cwszOut, fQuote);
                    if (fQuote)
                        PutStrW(L"\"", &pwsz, &cwsz, &cwszOut);
                }

                if (cAttr > 1)
                    PutStrW(pwszMultiValueSeparator, &pwsz, &cwsz, &cwszOut);
            }
            if (cRDN > 1)
                PutStrW(pwszRDNSeparator, &pwsz, &cwsz, &cwszOut);
        }
    }

    if (cwsz != 0) {
        // Always NULL terminate
        *pwsz = L'\0';
    }

    return cwszOut + 1;
}

//+-------------------------------------------------------------------------
//  Convert the certificate name blob to a null terminated WCHAR string.
//--------------------------------------------------------------------------
DWORD
WINAPI
CertNameToStrW(
    IN DWORD dwCertEncodingType,
    IN PCERT_NAME_BLOB pName,
    IN DWORD dwStrType,
    OUT OPTIONAL LPWSTR pwsz,
    IN DWORD cwsz
    )
{
    DWORD cwszOut;
    PCERT_NAME_INFO pInfo;
    pInfo = (PCERT_NAME_INFO) AllocAndDecodeObject(
        dwCertEncodingType,
        X509_UNICODE_NAME,
        pName->pbData,
        pName->cbData,
        (dwStrType & CERT_NAME_STR_DISABLE_IE4_UTF8_FLAG) ?
            CRYPT_UNICODE_NAME_DECODE_DISABLE_IE4_UTF8_FLAG : 0
        );

    // Note, decoded name info RDNs may be reversed
    cwszOut = CertNameInfoToStrW(
        dwCertEncodingType,
        pInfo,
        dwStrType,
        pwsz,
        cwsz
        );

    PkiFree(pInfo);
    return cwszOut;
}

//+-------------------------------------------------------------------------
//  Convert the Unicode string to Ascii
//--------------------------------------------------------------------------
static DWORD ConvertUnicodeStringToAscii(
    IN LPWSTR pwsz,
    IN DWORD cwsz,
    OUT OPTIONAL LPSTR psz,
    IN DWORD csz
    )
{
    DWORD cszOut = 0;

    if (psz == NULL)
        csz = 0;

    if (pwsz) {
        int cchMultiByte;
        cchMultiByte = WideCharToMultiByte(
            CP_ACP,
            0,                      // dwFlags
            pwsz,
            -1,                     // Null terminated
            psz,
            (int) csz,
            NULL,                   // lpDefaultChar
            NULL                    // lpfUsedDefaultChar
            );
        if (cchMultiByte < 1)
            cszOut = 0;
        else
            // Subtract off the trailing null terminator
            cszOut = (DWORD) cchMultiByte - 1;
    }

    if (csz != 0) {
        // Always NULL terminate
        *(psz + cszOut) = '\0';
    }
    return cszOut + 1;
}

//+-------------------------------------------------------------------------
//  Convert the certificate name blob to a null terminated char string.
//--------------------------------------------------------------------------
DWORD
WINAPI
CertNameToStrA(
    IN DWORD dwCertEncodingType,
    IN PCERT_NAME_BLOB pName,
    IN DWORD dwStrType,
    OUT OPTIONAL LPSTR psz,
    IN DWORD csz
    )
{
    DWORD cszOut;
    LPWSTR pwsz = NULL;
    DWORD cwsz;

    cwsz = CertNameToStrW(
        dwCertEncodingType,
        pName,
        dwStrType,
        NULL,                   // pwsz
        0                       // cwsz
        );
    if (pwsz = (LPWSTR) PkiNonzeroAlloc(cwsz * sizeof(WCHAR)))
        CertNameToStrW(
            dwCertEncodingType,
            pName,
            dwStrType,
            pwsz,
            cwsz
            );
    cszOut = ConvertUnicodeStringToAscii(pwsz, cwsz, psz, csz);

    PkiFree(pwsz);
    return cszOut;
}


//+-------------------------------------------------------------------------
//  Map the attribute key (for example "CN") to its Object Identifier
//  (for example, "2.5.4.3").
//
//  The input pwcKey isn't NULL terminated. cchKey > 0.
//
//  Returns NULL if unable to find a matching attribute key.
//--------------------------------------------------------------------------
static LPCSTR X500KeyToOID(IN LPCWSTR pwcKey, IN DWORD cchKey)
{
    PCCRYPT_OID_INFO pX500Info;
    WCHAR wszKey[MAX_X500_KEY_LEN + 1];

    if (cchKey > MAX_X500_KEY_LEN)
        return NULL;
    assert(cchKey > 0);

    // Null terminate the input Key
    memcpy(wszKey, pwcKey, cchKey * sizeof(WCHAR));
    wszKey[cchKey] = L'\0';

    if (pX500Info = CryptFindOIDInfo(
            CRYPT_OID_INFO_NAME_KEY,
            wszKey,
            CRYPT_RDN_ATTR_OID_GROUP_ID
            )) {
        if (*pX500Info->pszOID)
            return pX500Info->pszOID;
    }
    return NULL;
}


//+-------------------------------------------------------------------------
//  Checks if a digit
//--------------------------------------------------------------------------
static inline BOOL IsDigitA(char c)
{
    return c >= '0' && c <= '9';
}

#define X500_OID_PREFIX_A       "OID."
#define X500_OID_PREFIX_LEN     strlen(X500_OID_PREFIX_A)
//+-------------------------------------------------------------------------
//  Check for the case insensitive leading "OID." If present, skip past
//  it. Check that the remaining string contains only digits or a dot (".").
//  Also, don't allow consecutive dots.
//
//  Returns NULL for an invalid OID.
//--------------------------------------------------------------------------
static LPCSTR GetX500OID(IN LPCSTR pszObjId)
{
    LPCSTR psz;
    char c;
    BOOL fDot;

    if (strlen(pszObjId) > X500_OID_PREFIX_LEN &&
            0 == _strnicmp(X500_OID_PREFIX_A, pszObjId, X500_OID_PREFIX_LEN))
        pszObjId += X500_OID_PREFIX_LEN;

    // Verify the OID to have only digits and dots
    psz = pszObjId;
    fDot = FALSE;
    while (c = *psz++) {
        if (c == '.') {
            if (fDot)
                return NULL;
            fDot = TRUE;
        } else {
            if (!IsDigitA(c))
                return NULL;
            fDot = FALSE;
        }
    }
    return pszObjId;
}

//+-------------------------------------------------------------------------
//  Convert the the hex string, for example, #AB01, to binary.
//
//  The input string is assumed to have the leading #. Ignores embedded
//  whitespace.
//
//  The returned binary is allocated in pValue->pbData.
//--------------------------------------------------------------------------
static BOOL GetAndAllocHexW(
    IN LPCWSTR pwszToken,
    IN DWORD cchToken,
    OUT PCERT_RDN_VALUE_BLOB pValue
    )
{
    BOOL fResult;
    BYTE *pb;
    DWORD cb;
    BOOL fUpperNibble;

    pValue->pbData = NULL;
    pValue->cbData = 0;

    // Advance past #
    cchToken--;
    pwszToken++;
    if (0 == cchToken)
        goto NoHex;         // BUGBUG OSS returns a null pointer error when
                            // encoding an octet string of length 0.

    if (NULL == (pb = (BYTE *) PkiNonzeroAlloc(cchToken / 2 + 1)))
        goto OutOfMemory;
    pValue->pbData = pb;

    fUpperNibble = TRUE;
    cb = 0;
    while (cchToken--) {
        BYTE b;
        WCHAR wc = *pwszToken++;
        // only convert ascii hex characters 0..9, a..f, A..F
        // ignore whitespace
        if (wc >= L'0' && wc <= L'9')
            b = wc - L'0';
        else if (wc >= L'a' && wc <= L'f')
            b = 10 + wc - L'a';
        else if (wc >= L'A' && wc <= L'F')
            b = 10 + wc - L'A';
        else if (IsSpaceW(wc))
            continue;
        else
            goto InvalidHex;

        if (fUpperNibble) {
            *pb = b << 4;
            cb++;
            fUpperNibble = FALSE;
        } else {
            *pb = *pb | b;
            pb++;
            fUpperNibble = TRUE;
        }
    }
    if (cb == 0) {
        PkiFree(pValue->pbData);
        pValue->pbData = NULL;
    }
    pValue->cbData = cb;

    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    PkiFree(pValue->pbData);
    pValue->pbData = NULL;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
SET_ERROR(NoHex, CRYPT_E_INVALID_X500_STRING)
SET_ERROR(InvalidHex, CRYPT_E_INVALID_X500_STRING)
}

#define X500_QUOTED_FLAG            0x1
#define X500_EMBEDDED_QUOTE_FLAG    0x2

//+-------------------------------------------------------------------------
//  Get the next key or value token.
//
//  Handles quoted tokens.
//
//  Upon return *ppwsz points at the delimiter or error location
//--------------------------------------------------------------------------
static BOOL GetX500Token(
    IN OUT LPCWSTR *ppwsz,
    IN LPCWSTR pwszDelimiter,
    IN BOOL fEnableQuoting,
    OUT LPCWSTR *ppwszToken,
    OUT DWORD *pcchToken,
    OUT DWORD *pdwFlags
    )
{
    BOOL fResult;
    LPCWSTR pwsz = *ppwsz;
    LPCWSTR pwszStart = NULL;
    LPCWSTR pwszEnd = NULL;
    DWORD dwQuote = 0;          // 1 - after leading ", 2 - after trailing "

    *pdwFlags = 0;
    while (TRUE) {
        WCHAR wc = *pwsz;
        if (0 == dwQuote) {
            // No quotes so far. Or quoting not enabled.
            if (fEnableQuoting && L'\"' == wc) {
                if (NULL == pwszStart) {
                    pwszStart = pwsz + 1;
                    dwQuote = 1;
                    *pdwFlags |= X500_QUOTED_FLAG;
                } else
                    // Quote after non whitespace
                    goto ErrorReturn;
            } else {
                if (L'\0' == wc || IsInStrW(pwszDelimiter, wc)) {
                    // Hit a delimiter (including the null terminator)
                    if (pwszStart)
                        *pcchToken = (DWORD)(pwszEnd - pwszStart) + 1;
                    else
                        *pcchToken = 0;
                    break;
                }

                if (!IsSpaceW(wc)) {
                    pwszEnd = pwsz;
                    if (NULL == pwszStart)
                        pwszStart = pwsz;
                }
            }
        } else if (1 == dwQuote) {
            // After first quote
            if (L'\0' == wc) {
                // Point to first quote
                pwsz = pwszStart - 1;
                goto ErrorReturn;
            } else if (L'\"' == wc) {
                if (L'\"' == *(pwsz + 1)) {
                    *pdwFlags |= X500_EMBEDDED_QUOTE_FLAG;
                    // Skip double quote
                    pwsz++;
                } else {
                    *pcchToken = (DWORD)(pwsz - pwszStart);
                    dwQuote++;
                }
            }
        } else {
            // After second quote
            if (L'\0' == wc || IsInStrW(pwszDelimiter, wc))
                break;
            else if (!IsSpaceW(wc))
                goto ErrorReturn;
        }
        pwsz++;
    }

    fResult = TRUE;
CommonReturn:
    *ppwszToken = pwszStart;
    *ppwsz = pwsz;
    return fResult;

ErrorReturn:
    pwszStart = NULL;
    *pcchToken = 0;
    fResult = FALSE;
    goto CommonReturn;
}

#pragma optimize("", off)

//+-------------------------------------------------------------------------
//  Convert the null terminated X500 WCHAR string to an encoded
//  certificate name.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertStrToNameW(
    IN DWORD dwCertEncodingType,
    IN LPCWSTR pwszX500,
    IN DWORD dwStrType,
    IN OPTIONAL void *pvReserved,
    OUT BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded,
    OUT OPTIONAL LPCWSTR *ppwszError
    )
{

typedef struct _X500_ATTR_AUX {
    LPSTR pszAllocObjId;
    LPCWSTR pwszValue;
    BYTE *pbAllocValue;
    BOOL fNewRDN;
} X500_ATTR_AUX, *PX500_ATTR_AUX;
#define X500_ATTR_ALLOC_COUNT   20

    BOOL fResult;
    CERT_NAME_INFO NameInfo;
    PCERT_RDN pRDN = NULL;
    PCERT_RDN_ATTR pAttr = NULL;
    PX500_ATTR_AUX pAux = NULL;

    DWORD cRDN = 0;
    DWORD cAttr = 0;
    DWORD iRDN;
    DWORD iAttr;
    DWORD cAllocAttr;
    BOOL fNewRDN;
    DWORD dwValueType;

    WCHAR wszSeparators[8];
    BOOL fEnableQuoting;
    LPCWSTR pwszError = NULL;
    LPCWSTR pwszStartX500 = pwszX500;

    if (dwStrType & CERT_NAME_STR_ENABLE_T61_UNICODE_FLAG)
        dwValueType = CERT_RDN_ENABLE_T61_UNICODE_FLAG;
    else if (dwStrType & CERT_NAME_STR_ENABLE_UTF8_UNICODE_FLAG)
        dwValueType = CERT_RDN_ENABLE_UTF8_UNICODE_FLAG;
    else
        dwValueType = 0;

    // Check for an empty Name.
    if (NULL == pwszX500 || L'\0' == *pwszX500) {
    	BOOL fRet;
        NameInfo.cRDN = 0;
        NameInfo.rgRDN = NULL;

        if (ppwszError)
            *ppwszError = NULL;

        fRet = CryptEncodeObject( 
        			dwCertEncodingType,
        			X509_NAME,
        			&NameInfo,
        			pbEncoded,
        			pcbEncoded );
		return fRet;        			
    }

    if (dwStrType & CERT_NAME_STR_SEMICOLON_FLAG)
        wcscpy(wszSeparators, L";");
    else if (dwStrType & CERT_NAME_STR_COMMA_FLAG)
        wcscpy(wszSeparators, L",");
    else if (dwStrType & CERT_NAME_STR_CRLF_FLAG)
        wcscpy(wszSeparators, L"\r\n");
    else
        wcscpy(wszSeparators, L",;");
    if (!(dwStrType & CERT_NAME_STR_NO_PLUS_FLAG))
        wcscat(wszSeparators, L"+");

    if (dwStrType & CERT_NAME_STR_NO_QUOTING_FLAG)
        fEnableQuoting = FALSE;
    else
        fEnableQuoting = TRUE;

    // Eliminate the upper flags before switching
    switch (dwStrType & 0xFFFF) {
        case 0:
        case CERT_OID_NAME_STR:
        case CERT_X500_NAME_STR:
            break;
        case CERT_SIMPLE_NAME_STR:
        default:
            goto InvalidArg;
    }

    // Do initial allocations of Attrs, and Auxs
    if (NULL == (pAttr = (PCERT_RDN_ATTR) PkiNonzeroAlloc(
                sizeof(CERT_RDN_ATTR) * X500_ATTR_ALLOC_COUNT)) ||
            NULL == (pAux = (PX500_ATTR_AUX) PkiNonzeroAlloc(
                sizeof(X500_ATTR_AUX) * X500_ATTR_ALLOC_COUNT)))
        goto OutOfMemory;
    cAllocAttr = X500_ATTR_ALLOC_COUNT;
    fNewRDN = TRUE;
    while (TRUE) {
        LPCWSTR pwszToken;
        DWORD cchToken;
        DWORD dwTokenFlags;
        LPCSTR pszObjId;

        // Get the key token
        if (!GetX500Token(
                &pwszX500,
                L"=",           // pwszDelimiter
                FALSE,          // fEnableQuoting
                &pwszToken,
                &cchToken,
                &dwTokenFlags
                )) {
            pwszError = pwszX500;
            goto X500KeyTokenError;
        }

        if (0 == cchToken) {
            if (*pwszX500 == L'\0')
                break;
            else {
                pwszError = pwszX500;
                goto EmptyX500KeyError;
            }
        } else if (*pwszX500 == L'\0') {
            pwszError = pwszToken;
            goto NoX500KeyEqualError;
        }

        if (cAttr >= cAllocAttr) {
            PCERT_RDN_ATTR pNewAttr;
            PX500_ATTR_AUX pNewAux;

            assert(cAttr == cAllocAttr);
            if (NULL == (pNewAttr = (PCERT_RDN_ATTR) PkiRealloc(pAttr,
                    sizeof(CERT_RDN_ATTR) *
                        (cAllocAttr + X500_ATTR_ALLOC_COUNT))))
                goto OutOfMemory;
            pAttr = pNewAttr;

            if (NULL == (pNewAux = (PX500_ATTR_AUX) PkiRealloc(pAux,
                    sizeof(X500_ATTR_AUX) *
                        (cAllocAttr + X500_ATTR_ALLOC_COUNT))))
                goto OutOfMemory;
            pAux = pNewAux;

            cAllocAttr += X500_ATTR_ALLOC_COUNT;
        }
        iAttr = cAttr;
        cAttr++;
        memset(&pAttr[iAttr], 0, sizeof(CERT_RDN_ATTR));
        memset(&pAux[iAttr], 0, sizeof(X500_ATTR_AUX));
        pAux[iAttr].fNewRDN = fNewRDN;
        if (fNewRDN)
            cRDN++;

        // Convert the Key token to an OID
        pszObjId = X500KeyToOID(pwszToken, cchToken);
        if (NULL == pszObjId) {
            // Convert to ascii and null terminate
            LPSTR pszAllocObjId;
            DWORD i;

            // Convert from unicode to ascii and null terminate
            if (NULL == (pszAllocObjId = (LPSTR) PkiNonzeroAlloc(
                    cchToken + 1)))
                goto OutOfMemory;
            pAux[iAttr].pszAllocObjId = pszAllocObjId;
            for (i = 0; i < cchToken; i++)
                pszAllocObjId[i] = (char) (pwszToken[i] & 0xFF);
            pszAllocObjId[cchToken] = '\0';

            // Skips by leading OID. and validates
            pszObjId = GetX500OID(pszAllocObjId);
            if (NULL == pszObjId) {
                pwszError = pwszToken;
                goto InvalidX500Key;
            }
        }
        pAttr[iAttr].pszObjId = (LPSTR) pszObjId;
        pAttr[iAttr].dwValueType = dwValueType;

        // Advance past the Key's "=" delimiter
        pwszX500++;

        // Get the value token
        if (!GetX500Token(
                &pwszX500,
                wszSeparators,
                fEnableQuoting,
                &pwszToken,
                &cchToken,
                &dwTokenFlags
                )) {
            pwszError = pwszX500;
            goto X500ValueTokenError;
        }
        if (cchToken) {
            if (*pwszToken == L'#' && 0 == (dwTokenFlags & X500_QUOTED_FLAG)) {
                // Convert ascii hex to binary
                if (!GetAndAllocHexW(pwszToken, cchToken,
                        &pAttr[iAttr].Value)) {
                    pwszError = pwszToken;
                    goto ConvertHexError;
                }
                pAttr[iAttr].dwValueType = CERT_RDN_OCTET_STRING;
                pAux[iAttr].pbAllocValue = pAttr[iAttr].Value.pbData;
            } else if (dwTokenFlags & X500_EMBEDDED_QUOTE_FLAG) {
                // Realloc and remove the double "'s
                LPWSTR pwszAlloc;
                DWORD cchAlloc;
                DWORD i;
                if (NULL == (pwszAlloc = (LPWSTR) PkiNonzeroAlloc(
                        cchToken * sizeof(WCHAR))))
                    goto OutOfMemory;
                pAux[iAttr].pbAllocValue = (BYTE *) pwszAlloc;
                cchAlloc = 0;
                for (i = 0; i < cchToken; i++) {
                    pwszAlloc[cchAlloc++] = pwszToken[i];
                    if (pwszToken[i] == L'\"')
                        i++;
                }
                assert(cchAlloc < cchToken);
                pAttr[iAttr].Value.pbData = (BYTE *) pwszAlloc;
                pAttr[iAttr].Value.cbData = cchAlloc * sizeof(WCHAR);
            } else {
                pAttr[iAttr].Value.pbData = (BYTE *) pwszToken;
                pAttr[iAttr].Value.cbData = cchToken * sizeof(WCHAR);
            }

            pAux[iAttr].pwszValue = pwszToken;
        }

        fNewRDN = TRUE;
        if (*pwszX500 == L'\0')
            break;
        else if (*pwszX500 == L'+')
            fNewRDN = FALSE;

        // Advance past the value's delimiter
        pwszX500++;
    }

    if (0 == cRDN) {
        pwszError = pwszStartX500;
        goto NoRDNError;
    }

    // Allocate array of RDNs and update
    if (NULL == (pRDN = (PCERT_RDN) PkiNonzeroAlloc(sizeof(CERT_RDN) * cRDN)))
        goto OutOfMemory;
    iRDN = 0;
    for (iAttr = 0; iAttr < cAttr; iAttr++) {
        if (pAux[iAttr].fNewRDN) {
            assert(iRDN < cRDN);
            pRDN[iRDN].cRDNAttr = 1;
            pRDN[iRDN].rgRDNAttr = &pAttr[iAttr];
            iRDN++;
        } else {
            assert(iRDN > 0);
            pRDN[iRDN - 1].cRDNAttr++;

        }
    }
    assert(iRDN == cRDN);
    NameInfo.cRDN = cRDN;
    NameInfo.rgRDN = pRDN;

    if (dwStrType & CERT_NAME_STR_REVERSE_FLAG)
        ReverseNameInfo(&NameInfo);

    // Encode the above built name
    fResult = UnicodeNameInfoEncode(
        dwCertEncodingType,
        X509_UNICODE_NAME,
        &NameInfo,
        pbEncoded,
        pcbEncoded
        );

    if (!fResult) {
        DWORD dwErr = GetLastError();
        if ((DWORD) CRYPT_E_INVALID_NUMERIC_STRING == dwErr ||
                (DWORD) CRYPT_E_INVALID_PRINTABLE_STRING == dwErr ||
                (DWORD) CRYPT_E_INVALID_IA5_STRING == dwErr) {
            // *pcbEncoded contains the location of the error

            PCERT_RDN_ATTR pErrAttr;
            DWORD iValue;

            if (dwStrType & CERT_NAME_STR_REVERSE_FLAG) {
                // Reverse back to get the correct location of the error
                // relative to the input string
                ReverseNameInfo(&NameInfo);
                fResult = UnicodeNameInfoEncode(
                    dwCertEncodingType,
                    X509_UNICODE_NAME,
                    &NameInfo,
                    pbEncoded,
                    pcbEncoded
                    );
                if (fResult)
                    goto UnexpectedReverseEncodeSuccess;
                dwErr = GetLastError();
                if (!( (DWORD) CRYPT_E_INVALID_NUMERIC_STRING == dwErr ||
                        (DWORD) CRYPT_E_INVALID_PRINTABLE_STRING == dwErr ||
                        (DWORD) CRYPT_E_INVALID_IA5_STRING == dwErr))
                    goto UnexpectedReverseEncodeError;
            }

            iValue = GET_CERT_UNICODE_VALUE_ERR_INDEX(*pcbEncoded);
            iRDN = GET_CERT_UNICODE_RDN_ERR_INDEX(*pcbEncoded);
            iAttr = GET_CERT_UNICODE_ATTR_ERR_INDEX(*pcbEncoded);
            *pcbEncoded = 0;

            assert(iRDN < cRDN);
            assert(iAttr < pRDN[iRDN].cRDNAttr);
            pErrAttr = &pRDN[iRDN].rgRDNAttr[iAttr];

            assert(pErrAttr->dwValueType != CERT_RDN_OCTET_STRING);

            // Index from beginning of pAttr
            iAttr = (DWORD)(pErrAttr - pAttr);
            assert(iAttr < cAttr);
            assert(iValue < pAttr[iAttr].Value.cbData / sizeof(WCHAR));
            pwszError = pAux[iAttr].pwszValue;
            assert(pwszError);
            if (pAux[iAttr].pbAllocValue) {
                // Adjust for embedded quotes where the the second quote
                // was removed above before encoding
                DWORD i = iValue;
                assert(pAux[iAttr].pbAllocValue == pAttr[iAttr].Value.pbData);
                LPCWSTR pwszValue = (LPCWSTR) pAttr[iAttr].Value.pbData;
                for ( ; i > 0; i--, pwszValue++)
                    if (*pwszValue == L'\"')
                        iValue++;
            }
            pwszError += iValue;
        }
    }
CommonReturn:
    while (cAttr--) {
        PkiFree(pAux[cAttr].pszAllocObjId);
        PkiFree(pAux[cAttr].pbAllocValue);
    }

    PkiFree(pRDN);
    PkiFree(pAttr);
    PkiFree(pAux);
    if (ppwszError)
        *ppwszError = pwszError;
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(OutOfMemory)
SET_ERROR(X500KeyTokenError, CRYPT_E_INVALID_X500_STRING)
SET_ERROR(EmptyX500KeyError, CRYPT_E_INVALID_X500_STRING)
SET_ERROR(NoX500KeyEqualError, CRYPT_E_INVALID_X500_STRING)
SET_ERROR(InvalidX500Key, CRYPT_E_INVALID_X500_STRING)
SET_ERROR(X500ValueTokenError, CRYPT_E_INVALID_X500_STRING)
SET_ERROR(ConvertHexError, CRYPT_E_INVALID_X500_STRING)
SET_ERROR(NoRDNError, CRYPT_E_INVALID_X500_STRING)
SET_ERROR(UnexpectedReverseEncodeSuccess, E_UNEXPECTED)
TRACE_ERROR(UnexpectedReverseEncodeError)
}
#pragma optimize ("", on)
//+-------------------------------------------------------------------------
//  Convert the null terminated X500 char string to an encoded
//  certificate name.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertStrToNameA(
    IN DWORD dwCertEncodingType,
    IN LPCSTR pszX500,
    IN DWORD dwStrType,
    IN OPTIONAL void *pvReserved,
    OUT BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded,
    OUT OPTIONAL LPCSTR *ppszError
    )
{
    BOOL fResult;
    LPWSTR pwszX500 = NULL;
    LPCWSTR pwszError = NULL;

    assert(pszX500);
    if (NULL == (pwszX500 = MkWStr((LPSTR) pszX500)))
        goto ErrorReturn;
    fResult = CertStrToNameW(
        dwCertEncodingType,
        pwszX500,
        dwStrType,
        pvReserved,
        pbEncoded,
        pcbEncoded,
        &pwszError
        );
    if (ppszError) {
        // Update multi byte error location
        if (pwszError) {
            // Default to beginning of string
            *ppszError = pszX500;
            if (pwszError > pwszX500) {
                // After beginning of string. There should be at least 2
                // characters.
                //
                // Need to convert pwszX500 .. pwszError - 1 back to multi byte
                // to get the correct multi byte pointer.
                int cchError = strlen(pszX500) - 1; // exclude error char
                LPSTR pszError;
                assert(cchError);
                if (pszError = (LPSTR) PkiNonzeroAlloc(cchError)) {
                    // Convert up through the previous multibyte character
                    cchError = WideCharToMultiByte(
                        CP_ACP,
                        0,                      // dwFlags
                        pwszX500,
                        (int)(pwszError - pwszX500),
                        pszError,
                        cchError,
                        NULL,                   // lpDefaultChar
                        NULL                    // lpfUsedDefaultChar
                        );
                    if (cchError > 0)
                        *ppszError = pszX500 + cchError;
                    PkiFree(pszError);
                }
            }
        } else
            *ppszError = NULL;
    }

CommonReturn:
    FreeWStr(pwszX500);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    *pcbEncoded = 0;
    if (ppszError)
        *ppszError = NULL;
    goto CommonReturn;
}

//==========================================================================
//  CertGetNameStrW support functions
//==========================================================================

//+-------------------------------------------------------------------------
//  Returns pointer to allocated CERT_NAME_INFO by decoding the name blob.
//
//  Returns NULL if cRDN == 0
//--------------------------------------------------------------------------
static PCERT_NAME_INFO AllocAndGetNameInfo(
    IN DWORD dwCertEncodingType,
    IN PCERT_NAME_BLOB pName,
    IN DWORD dwFlags
    )
{
    PCERT_NAME_INFO pInfo;

    assert(pName);
    if (0 == pName->cbData)
        return NULL;

    if (NULL == (pInfo = (PCERT_NAME_INFO) AllocAndDecodeObject(
            dwCertEncodingType,
            X509_UNICODE_NAME,
            pName->pbData,
            pName->cbData,
            (dwFlags & CERT_NAME_DISABLE_IE4_UTF8_FLAG) ?
                CRYPT_UNICODE_NAME_DECODE_DISABLE_IE4_UTF8_FLAG : 0
            )))
        return NULL;
    if (0 == pInfo->cRDN) {
        PkiFree(pInfo);
        return NULL;
    } else
        return pInfo;
}

//+-------------------------------------------------------------------------
//  Returns pointer to allocated CERT_NAME_INFO by decoding either the
//  Subject or Issuer field in the certificate. CERT_NAME_ISSUER_FLAG is
//  set to select the Issuer.
//
//  Returns NULL if cRDN == 0
//--------------------------------------------------------------------------
static PCERT_NAME_INFO AllocAndGetCertNameInfo(
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwFlags
    )
{
    PCERT_NAME_BLOB pName;

    if (dwFlags & CERT_NAME_ISSUER_FLAG)
        pName = &pCertContext->pCertInfo->Issuer;
    else
        pName = &pCertContext->pCertInfo->Subject;

    return AllocAndGetNameInfo(pCertContext->dwCertEncodingType, pName,
        dwFlags);
}

//+-------------------------------------------------------------------------
//  Table of Subject and Issuer Alternative Name extension OIDs
//--------------------------------------------------------------------------
static const LPCSTR rgpszSubjectAltOID[] = {
    szOID_SUBJECT_ALT_NAME2,
    szOID_SUBJECT_ALT_NAME
};
#define NUM_SUBJECT_ALT_OID (sizeof(rgpszSubjectAltOID) / \
                                         sizeof(rgpszSubjectAltOID[0]))

static const LPCSTR rgpszIssuerAltOID[] = {
    szOID_ISSUER_ALT_NAME2,
    szOID_ISSUER_ALT_NAME
};
#define NUM_ISSUER_ALT_OID (sizeof(rgpszIssuerAltOID) / \
                                         sizeof(rgpszIssuerAltOID[0]))

//+-------------------------------------------------------------------------
//  Returns pointer to allocated CERT_ALT_NAME_INFO by decoding either the
//  Subject or Issuer Alternative Extension. CERT_NAME_ISSUER_FLAG is
//  set to select the Issuer.
//
//  Returns NULL if extension not found or cAltEntry == 0
//--------------------------------------------------------------------------
static PCERT_ALT_NAME_INFO AllocAndGetAltNameInfo(
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwFlags
    )
{
    DWORD cAltOID;
    const LPCSTR *ppszAltOID;

    PCERT_EXTENSION pExt;
    PCERT_ALT_NAME_INFO pInfo;

    if (dwFlags & CERT_NAME_ISSUER_FLAG) {
        cAltOID = NUM_ISSUER_ALT_OID;
        ppszAltOID = rgpszIssuerAltOID;
    } else {
        cAltOID = NUM_SUBJECT_ALT_OID;
        ppszAltOID = rgpszSubjectAltOID;
    }

    // Try to find an alternative name extension
    pExt = NULL;
    for ( ; cAltOID > 0; cAltOID--, ppszAltOID++) {
        if (pExt = CertFindExtension(
                *ppszAltOID,
                pCertContext->pCertInfo->cExtension,
                pCertContext->pCertInfo->rgExtension
                ))
            break;
    }

    if (NULL == pExt)
        return NULL;

    if (NULL == (pInfo = (PCERT_ALT_NAME_INFO) AllocAndDecodeObject(
            pCertContext->dwCertEncodingType,
            X509_ALTERNATE_NAME,
            pExt->Value.pbData,
            pExt->Value.cbData,
            0                       // dwFlags
            )))
        return NULL;
    if (0 == pInfo->cAltEntry) {
        PkiFree(pInfo);
        return NULL;
    } else
        return pInfo;
}

//+-------------------------------------------------------------------------
//  Returns pointer to allocated CERT_NAME_INFO by decoding the first
//  Directory Name choice (if it exists) in the decoded CERT_ALT_NAME_INFO.
//
//  Returns NULL if no Directory Name choice or cRDN == 0.
//--------------------------------------------------------------------------
static PCERT_NAME_INFO AllocAndGetAltDirNameInfo(
    IN DWORD dwCertEncodingType,
    IN PCERT_ALT_NAME_INFO pAltNameInfo,
    IN DWORD dwFlags
    )
{
    DWORD cEntry;
    PCERT_ALT_NAME_ENTRY pEntry;

    if (NULL == pAltNameInfo)
        return NULL;

    cEntry = pAltNameInfo->cAltEntry;
    pEntry = pAltNameInfo->rgAltEntry;

    for ( ; cEntry > 0; cEntry--, pEntry++) {
        if (CERT_ALT_NAME_DIRECTORY_NAME == pEntry->dwAltNameChoice) {
            return AllocAndGetNameInfo(dwCertEncodingType,
                &pEntry->DirectoryName, dwFlags);
        }
    }

    return NULL;
}

//+-------------------------------------------------------------------------
//  First, returns pointer to allocated CERT_ALT_NAME_INFO by decoding either
//  the Subject or Issuer Alternative Extension. CERT_NAME_ISSUER_FLAG is
//  set to select the Issuer. Returns NULL if extension not found or
//  cAltEntry == 0
//
//  Then, if able to find the extension, returns pointer to allocated
//  CERT_NAME_INFO by decoding the first Directory Name choice (if it exists)
//  in the decoded CERT_ALT_NAME_INFO. Returns NULL if no Directory Name
//  choice or cRDN == 0.
//--------------------------------------------------------------------------
static PCERT_NAME_INFO AllocAndGetAltDirNameInfo(
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwFlags,
    OUT PCERT_ALT_NAME_INFO *ppAltNameInfo
    )
{
    PCERT_ALT_NAME_INFO pAltNameInfo;
    *ppAltNameInfo = pAltNameInfo = AllocAndGetAltNameInfo(pCertContext,
        dwFlags);
    if (NULL == pAltNameInfo)
        return NULL;
    return AllocAndGetAltDirNameInfo(pCertContext->dwCertEncodingType,
        pAltNameInfo, dwFlags);
}

//+-------------------------------------------------------------------------
//  Copy name string. Ensure its NULL terminated.
//--------------------------------------------------------------------------
static void CopyNameStringW(
    IN LPCWSTR pwszSrc,
    OUT OPTIONAL LPWSTR pwszNameString,
    IN DWORD cchNameString,
    OUT DWORD *pcwszOut
    )
{
    PutStrW(pwszSrc, &pwszNameString, &cchNameString, pcwszOut);
    if (cchNameString != 0)
        // Always NULL terminate
        *pwszNameString = L'\0';
    *pcwszOut += 1;
}

//+-------------------------------------------------------------------------
//  Table of ordered RDN attributes to search for when formatting
//  SIMPLE_DISPLAY_TYPE
//--------------------------------------------------------------------------
static const LPCSTR rgpszSimpleDisplayAttrOID[] = {
    szOID_COMMON_NAME,
    szOID_ORGANIZATIONAL_UNIT_NAME,
    szOID_ORGANIZATION_NAME,
    szOID_RSA_emailAddr,
    NULL                                // any
};
#define NUM_SIMPLE_DISPLAY_ATTR_OID (sizeof(rgpszSimpleDisplayAttrOID) / \
                                        sizeof(rgpszSimpleDisplayAttrOID[0]))

//+-------------------------------------------------------------------------
//  Table of ordered RDN attributes to search for when formatting
//  EMAIL_TYPE
//--------------------------------------------------------------------------
static const LPCSTR rgpszEmailAttrOID[] = {
    szOID_RSA_emailAddr
};
#define NUM_EMAIL_ATTR_OID (sizeof(rgpszEmailAttrOID) / \
                                     sizeof(rgpszEmailAttrOID[0]))


// Largest number from above tables
#define MAX_ATTR_OID            NUM_SIMPLE_DISPLAY_ATTR_OID

// PCERT_NAME_INFO table count and indices
#define NAME_INFO_CNT           2
#define CERT_NAME_INFO_INDEX    0
#define ALT_DIR_NAME_INFO_INDEX 1


//+-------------------------------------------------------------------------
//  Iterate through the list of attributes specified in rgpszAttrOID
//  and iterate through the table of decoded names specified in rgpNameInfo
//  and find the first occurrence of the attribute.
//--------------------------------------------------------------------------
static BOOL GetAttrStringW(
    IN DWORD cAttrOID,
    IN const LPCSTR *rgpszAttrOID,
    IN PCERT_NAME_INFO rgpNameInfo[NAME_INFO_CNT],
    OUT OPTIONAL LPWSTR pwszNameString,
    IN DWORD cchNameString,
    OUT DWORD *pcwszOut
    )
{
    DWORD iOID;
    PCERT_RDN_ATTR rgpFoundAttr[MAX_ATTR_OID];
    DWORD iInfo;

    assert(cAttrOID > 0 && cAttrOID <= MAX_ATTR_OID);
    for (iOID = 0; iOID < cAttrOID; iOID++)
        rgpFoundAttr[iOID] = NULL;

    for (iInfo = 0; iInfo < NAME_INFO_CNT; iInfo++) {
        PCERT_NAME_INFO pInfo;
        DWORD cRDN;

        if (NULL == (pInfo = rgpNameInfo[iInfo]))
            continue;

        // Search RDNs in reverse order
        for (cRDN = pInfo->cRDN; cRDN > 0; cRDN--) {
            PCERT_RDN pRDN = &pInfo->rgRDN[cRDN - 1];
            DWORD cAttr = pRDN->cRDNAttr;
            PCERT_RDN_ATTR pAttr = pRDN->rgRDNAttr;
            for ( ; cAttr > 0; cAttr--, pAttr++) {
                if (CERT_RDN_ENCODED_BLOB == pAttr->dwValueType ||
                        CERT_RDN_OCTET_STRING == pAttr->dwValueType)
                    continue;

                for (iOID = 0; iOID < cAttrOID; iOID++) {
                    if (NULL == rgpFoundAttr[iOID] &&
                            (NULL == rgpszAttrOID[iOID] ||
                                0 == strcmp(rgpszAttrOID[iOID],
                                    pAttr->pszObjId))) {
                        rgpFoundAttr[iOID] = pAttr;
                        if (0 == iOID)
                            goto FoundAttr;
                        else
                            break;
                    }
                }
            }
        }
    }


    // iOID == 0 was already found above
    assert(NULL == rgpFoundAttr[0]);
    for (iOID = 1; iOID < cAttrOID; iOID++) {
        if (rgpFoundAttr[iOID])
            break;
    }
    if (iOID >= cAttrOID)
        return FALSE;

FoundAttr:
    assert(iOID < cAttrOID && rgpFoundAttr[iOID]);
    CopyNameStringW((LPCWSTR) rgpFoundAttr[iOID]->Value.pbData, pwszNameString,
        cchNameString, pcwszOut);
    return TRUE;
}

//+-------------------------------------------------------------------------
//  Attempt to find a RFC822_NAME choice in the decoded alternative name
//  extension.
//--------------------------------------------------------------------------
static BOOL GetAltNameEmailW(
    IN PCERT_ALT_NAME_INFO pAltNameInfo,
    OUT OPTIONAL LPWSTR pwszNameString,
    IN DWORD cchNameString,
    OUT DWORD *pcwszOut
    )
{
    DWORD cEntry;
    PCERT_ALT_NAME_ENTRY pEntry;

    if (NULL == pAltNameInfo)
        return FALSE;

    cEntry = pAltNameInfo->cAltEntry;
    pEntry = pAltNameInfo->rgAltEntry;
    for ( ; cEntry > 0; cEntry--, pEntry++) {
        if (CERT_ALT_NAME_RFC822_NAME == pEntry->dwAltNameChoice) {
            CopyNameStringW(pEntry->pwszRfc822Name, pwszNameString,
                cchNameString, pcwszOut);
            return TRUE;
        }
    }

    return FALSE;
}

//+-------------------------------------------------------------------------
//  Get the subject or issuer name from the certificate and
//  according to the specified format type, convert to a null terminated
//  WCHAR string.
//
//  CERT_NAME_ISSUER_FLAG can be set to get the issuer's name. Otherwise,
//  gets the subject's name.
//--------------------------------------------------------------------------
DWORD
WINAPI
CertGetNameStringW(
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwType,
    IN DWORD dwFlags,
    IN void *pvTypePara,
    OUT OPTIONAL LPWSTR pwszNameString,
    IN DWORD cchNameString
    )
{
    DWORD cwszOut = 0;
    PCERT_NAME_INFO rgpNameInfo[NAME_INFO_CNT] = { NULL, NULL };
    PCERT_ALT_NAME_INFO pAltNameInfo = NULL;

    DWORD i;
    DWORD dwStrType;
    DWORD dwCertEncodingType;

    if (NULL == pwszNameString)
        cchNameString = 0;

    switch (dwType) {
        case CERT_NAME_EMAIL_TYPE:
            pAltNameInfo = AllocAndGetAltNameInfo(pCertContext, dwFlags);
            if (GetAltNameEmailW(
                    pAltNameInfo,
                    pwszNameString,
                    cchNameString,
                    &cwszOut
                    )) goto CommonReturn;

            rgpNameInfo[CERT_NAME_INFO_INDEX] = AllocAndGetCertNameInfo(
                pCertContext, dwFlags);
            if (!GetAttrStringW(
                    NUM_EMAIL_ATTR_OID,
                    rgpszEmailAttrOID,
                    rgpNameInfo,
                    pwszNameString,
                    cchNameString,
                    &cwszOut
                    )) goto NoEmail;
            break;

        case CERT_NAME_RDN_TYPE:
            dwStrType = pvTypePara ? *((DWORD *) pvTypePara) : 0;

            if (dwStrType & CERT_NAME_STR_DISABLE_IE4_UTF8_FLAG)
                dwFlags |= CERT_NAME_DISABLE_IE4_UTF8_FLAG;

            dwCertEncodingType = pCertContext->dwCertEncodingType;
            if (rgpNameInfo[CERT_NAME_INFO_INDEX] = AllocAndGetCertNameInfo(
                    pCertContext, dwFlags))
                // Note, decoded name info RDNs may be reversed
                cwszOut = CertNameInfoToStrW(
                    dwCertEncodingType,
                    rgpNameInfo[CERT_NAME_INFO_INDEX],
                    dwStrType,
                    pwszNameString,
                    cchNameString
                    );
            else if (rgpNameInfo[ALT_DIR_NAME_INFO_INDEX] =
                    AllocAndGetAltDirNameInfo(pCertContext, dwFlags,
                        &pAltNameInfo))
                // Note, decoded name info RDNs may be reversed
                cwszOut = CertNameInfoToStrW(
                    dwCertEncodingType,
                    rgpNameInfo[ALT_DIR_NAME_INFO_INDEX],
                    dwStrType,
                    pwszNameString,
                    cchNameString
                    );
            else
                goto NoRDN;
            break;

        case CERT_NAME_ATTR_TYPE:
            rgpNameInfo[CERT_NAME_INFO_INDEX] = AllocAndGetCertNameInfo(
                pCertContext, dwFlags);
            rgpNameInfo[ALT_DIR_NAME_INFO_INDEX] = AllocAndGetAltDirNameInfo(
                pCertContext, dwFlags, &pAltNameInfo);

            if (!GetAttrStringW(
                    1,                  // cAttrOID
                    (const LPCSTR *) &pvTypePara,
                    rgpNameInfo,
                    pwszNameString,
                    cchNameString,
                    &cwszOut
                    )) goto NoAttr;
            break;

        case CERT_NAME_FRIENDLY_DISPLAY_TYPE:
            {
                DWORD cbData = 0;

                CertGetCertificateContextProperty(
                    pCertContext,
                    CERT_FRIENDLY_NAME_PROP_ID,
                    NULL,                           // pvData
                    &cbData
                    );
                // Need at least one character, plus the null terminator
                if (cbData >= sizeof(WCHAR) * 2) {
                    LPWSTR pwszFriendlyName;

                    // Ensure the Friendly name is null terminated.
                    if (pwszFriendlyName = (LPWSTR) PkiZeroAlloc(
                            cbData + sizeof(WCHAR) * 2)) {
                        BOOL fResult;

                        fResult = CertGetCertificateContextProperty(
                            pCertContext,
                            CERT_FRIENDLY_NAME_PROP_ID,
                            pwszFriendlyName,
                            &cbData
                            );
                        if (fResult)
                            CopyNameStringW(
                                pwszFriendlyName,
                                pwszNameString,
                                cchNameString,
                                &cwszOut
                                );
                        PkiFree(pwszFriendlyName);
                        if (fResult)
                            goto CommonReturn;
                    }
                }
            }
            // Fall through

        case CERT_NAME_SIMPLE_DISPLAY_TYPE:
            rgpNameInfo[CERT_NAME_INFO_INDEX] = AllocAndGetCertNameInfo(
                pCertContext, dwFlags);
            rgpNameInfo[ALT_DIR_NAME_INFO_INDEX] = AllocAndGetAltDirNameInfo(
                pCertContext, dwFlags, &pAltNameInfo);

            if (GetAttrStringW(
                    NUM_SIMPLE_DISPLAY_ATTR_OID,
                    rgpszSimpleDisplayAttrOID,
                    rgpNameInfo,
                    pwszNameString,
                    cchNameString,
                    &cwszOut
                    )) goto CommonReturn;
            if (!GetAltNameEmailW(
                    pAltNameInfo,
                    pwszNameString,
                    cchNameString,
                    &cwszOut
                    )) goto NoSimpleDisplay;
            break;

        default:
            goto InvalidType;
    }

CommonReturn:
    for (i = 0; i < NAME_INFO_CNT; i++)
        PkiFree(rgpNameInfo[i]);
    PkiFree(pAltNameInfo);
    return cwszOut;

ErrorReturn:
    if (0 != cchNameString)
        // Always NULL terminate
        *pwszNameString = L'\0';
    cwszOut = 1;
    goto CommonReturn;

SET_ERROR(NoEmail, CRYPT_E_NOT_FOUND)
SET_ERROR(NoRDN, CRYPT_E_NOT_FOUND)
SET_ERROR(NoAttr, CRYPT_E_NOT_FOUND)
SET_ERROR(NoSimpleDisplay, CRYPT_E_NOT_FOUND)
SET_ERROR(InvalidType, E_INVALIDARG)
}

//+-------------------------------------------------------------------------
//  Get the subject or issuer name from the certificate and
//  according to the specified format type, convert to a null terminated
//  char string.
//
//  CERT_NAME_ISSUER_FLAG can be set to get the issuer's name. Otherwise,
//  gets the subject's name.
//--------------------------------------------------------------------------
DWORD
WINAPI
CertGetNameStringA(
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwType,
    IN DWORD dwFlags,
    IN void *pvTypePara,
    OUT OPTIONAL LPSTR pszNameString,
    IN DWORD cchNameString
    )
{
    DWORD cszOut;
    LPWSTR pwsz = NULL;
    DWORD cwsz;

    cwsz = CertGetNameStringW(
        pCertContext,
        dwType,
        dwFlags,
        pvTypePara,
        NULL,                   // pwsz
        0                       // cwsz
        );
    if (pwsz = (LPWSTR) PkiNonzeroAlloc(cwsz * sizeof(WCHAR)))
        CertGetNameStringW(
            pCertContext,
            dwType,
            dwFlags,
            pvTypePara,
            pwsz,
            cwsz
            );
    cszOut = ConvertUnicodeStringToAscii(pwsz, cwsz, pszNameString,
        cchNameString);

    PkiFree(pwsz);
    return cszOut;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\certstor\certhlpr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       certhlpr.cpp
//
//  Contents:   Certificate and CRL Helper APIs
//
//  Functions:  CertHelperDllMain
//              I_CryptGetDefaultCryptProv
//              I_CryptGetDefaultCryptProvForEncrypt
//              CertCompareIntegerBlob
//              CertCompareCertificate
//              CertCompareCertificateName
//              CertIsRDNAttrsInCertificateName
//              CertComparePublicKeyInfo
//              CryptVerifyCertificateSignature
//              CryptHashCertificate
//              CryptHashToBeSigned
//              CryptSignCertificate
//              CryptSignAndEncodeCertificate
//              CertVerifyTimeValidity
//              CertVerifyCRLTimeValidity
//              CertVerifyValidityNesting
//              CertVerifyCRLRevocation
//              CertAlgIdToOID
//              CertOIDToAlgId
//              CertFindExtension
//              CertFindAttribute
//              CertFindRDNAttr
//              CertGetIntendedKeyUsage
//              CertGetPublicKeyLength
//              CryptHashPublicKeyInfo
//
//              I_CertCompareCertAndProviderPublicKey
//              CryptFindCertificateKeyProvInfo
//
//              CryptCreatePublicKeyInfo
//              CryptConvertPublicKeyInfo
//              CryptExportPublicKeyInfo
//              CryptExportPublicKeyInfoEx
//              CryptImportPublicKeyInfo
//              CryptImportPublicKeyInfoEx
//              CryptCreateKeyIdentifierFromCSP
//
//              CryptInstallDefaultContext
//              CryptUninstallDefaultContext
//
//  History:    23-Feb-96   philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

#define EMULATE_SHA1
#include "xcrypt.h"

// All the *pvInfo extra stuff needs to be aligned
#define INFO_LEN_ALIGN(Len)  ((Len + 7) & ~7)

#define NULL_ASN_TAG        0x05

//+=========================================================================
//  CryptCreatePublicKeyInfo, EncodePublicKeyAndParameters
//  and CryptConvertPublicKeyInfo functions
//-=========================================================================

// The following should be moved to wincrypt.x

// If CRYPT_ALLOC_FLAG is set, *pvPubKeyInfo is updated with a LocalAlloc'ed
// pointer to a CERT_PUBLIC_KEY_INFO data structure which must be freed by
// calling LocalFree. Otherwise, pvPubKeyInfo points to a user allocated
// CERT_PUBLIC_KEY_INFO data structure which is updated.
WINCRYPT32API
BOOL
WINAPI
CryptCreatePublicKeyInfo(
    IN DWORD dwCertEncodingType,
    IN OPTIONAL LPCSTR pszPubKeyOID,
    IN const PUBLICKEYSTRUC *pPubKeyStruc,
    IN DWORD cbPubKeyStruc,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT void *pvPubKeyInfo,
    IN OUT DWORD *pcbPubKeyInfo
    );

#define CRYPT_ALLOC_FLAG            0x8000


#define CRYPT_OID_ENCODE_PUBLIC_KEY_AND_PARAMETERS_FUNC  \
    "CryptDllEncodePublicKeyAndParameters"

// The returned encoded public keys and parameters are LocalAlloc'ed.
typedef BOOL (WINAPI *PFN_CRYPT_ENCODE_PUBLIC_KEY_AND_PARAMETERS)(
    IN DWORD dwCertEncodingType,
    IN OPTIONAL LPCSTR pszPubKeyOID,
    IN const PUBLICKEYSTRUC *pPubKeyStruc,
    IN DWORD cbPubKeyStruc,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT BYTE **ppbEncodedPubKey,
    OUT DWORD *pcbEncodedPubKey,
    OUT BYTE **ppbEncodedParameters,
    OUT DWORD *pcbEncodedParameters
    );

// If CRYPT_ALLOC_FLAG is set, *pvPubKeyStruc is updated with a LocalAlloc'ed
// pointer to a PUBLICKEYSTRUC data structure which must be freed by calling
// LocalFree. Otherwise, pvPubKeyStruc points to a user allocated
// PUBLICKEYSTRUC data structure which is updated.
WINCRYPT32API
BOOL
WINAPI
CryptConvertPublicKeyInfo(
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pPubKeyInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT void *pvPubKeyStruc,
    IN OUT DWORD *pcbPubKeyStruc
    );


#define CRYPT_OID_CONVERT_PUBLIC_KEY_INFO_FUNC  "CryptDllConvertPublicKeyInfo"

typedef BOOL (WINAPI *PFN_CRYPT_CONVERT_PUBLIC_KEY_INFO)(
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pPubKeyInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT void *pvPubKeyStruc,
    IN OUT DWORD *pcbPubKeyStruc
    );

// End of what should be moved to wincrypt.x

static HCRYPTOIDFUNCSET hEncodePubKeyFuncSet;
static HCRYPTOIDFUNCSET hConvertPubKeyFuncSet;

//+-------------------------------------------------------------------------
//  Encode the RSA public key and parameters
//--------------------------------------------------------------------------
static BOOL WINAPI EncodeRSAPublicKeyAndParameters(
    IN DWORD dwCertEncodingType,
    IN OPTIONAL LPCSTR pszPubKeyOID,
    IN const PUBLICKEYSTRUC *pPubKeyStruc,
    IN DWORD cbPubKeyStruc,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT BYTE **ppbEncodedPubKey,
    OUT DWORD *pcbEncodedPubKey,
    OUT BYTE **ppbEncodedParameters,
    OUT DWORD *pcbEncodedParameters
    );

//+-------------------------------------------------------------------------
//  Convert as an RSA public key
//--------------------------------------------------------------------------
static BOOL WINAPI ConvertRSAPublicKeyInfo(
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pPubKeyInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT void *pvPubKeyStruc,
    IN OUT DWORD *pcbPubKeyStruc
    );

//+-------------------------------------------------------------------------
//  Encode the DSS public key and parameters
//--------------------------------------------------------------------------
static BOOL WINAPI EncodeDSSPublicKeyAndParameters(
    IN DWORD dwCertEncodingType,
    IN OPTIONAL LPCSTR pszPubKeyOID,
    IN const PUBLICKEYSTRUC *pPubKeyStruc,
    IN DWORD cbPubKeyStruc,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT BYTE **ppbEncodedPubKey,
    OUT DWORD *pcbEncodedPubKey,
    OUT BYTE **ppbEncodedParameters,
    OUT DWORD *pcbEncodedParameters
    );

//+-------------------------------------------------------------------------
//  Convert as an DSS public key
//--------------------------------------------------------------------------
static BOOL WINAPI ConvertDSSPublicKeyInfo(
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pPubKeyInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT void *pvPubKeyStruc,
    IN OUT DWORD *pcbPubKeyStruc
    );

//+-------------------------------------------------------------------------
//  Encode the DH public key and parameters
//--------------------------------------------------------------------------
static BOOL WINAPI EncodeDHPublicKeyAndParameters(
    IN DWORD dwCertEncodingType,
    IN OPTIONAL LPCSTR pszPubKeyOID,
    IN const PUBLICKEYSTRUC *pPubKeyStruc,
    IN DWORD cbPubKeyStruc,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT BYTE **ppbEncodedPubKey,
    OUT DWORD *pcbEncodedPubKey,
    OUT BYTE **ppbEncodedParameters,
    OUT DWORD *pcbEncodedParameters
    );

static const CRYPT_OID_FUNC_ENTRY EncodePubKeyFuncTable[] = {
    szOID_RSA_RSA, EncodeRSAPublicKeyAndParameters,
    szOID_OIWSEC_rsaXchg, EncodeRSAPublicKeyAndParameters,
    szOID_OIWSEC_dsa, EncodeDSSPublicKeyAndParameters,
    szOID_X957_DSA, EncodeDSSPublicKeyAndParameters,
    szOID_ANSI_X942_DH, EncodeDHPublicKeyAndParameters,
    szOID_RSA_DH, EncodeDHPublicKeyAndParameters,
};
#define ENCODE_PUB_KEY_FUNC_COUNT (sizeof(EncodePubKeyFuncTable) / \
                                    sizeof(EncodePubKeyFuncTable[0]))

static const CRYPT_OID_FUNC_ENTRY ConvertPubKeyFuncTable[] = {
    szOID_RSA_RSA, ConvertRSAPublicKeyInfo,
    szOID_OIWSEC_rsaXchg, ConvertRSAPublicKeyInfo,
    szOID_OIWSEC_dsa, ConvertDSSPublicKeyInfo,
    szOID_X957_DSA, ConvertDSSPublicKeyInfo,
};
#define CONVERT_PUB_KEY_FUNC_COUNT (sizeof(ConvertPubKeyFuncTable) / \
                                    sizeof(ConvertPubKeyFuncTable[0]))


//+=========================================================================
//  CryptExportPublicKeyInfoEx and CryptImportPublicKeyInfoEx OID
//  installable functions.
//-=========================================================================

typedef BOOL (WINAPI *PFN_EXPORT_PUB_KEY_FUNC) (
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwKeySpec,
    IN DWORD dwCertEncodingType,
    IN LPSTR pszPublicKeyObjId,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvAuxInfo,
    OUT PCERT_PUBLIC_KEY_INFO pInfo,
    IN OUT DWORD *pcbInfo
    );

typedef BOOL (WINAPI *PFN_IMPORT_PUB_KEY_FUNC) (
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pInfo,
    IN ALG_ID aiKeyAlg,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvAuxInfo,
    OUT HCRYPTKEY *phKey
    );

static HCRYPTOIDFUNCSET hExportPubKeyFuncSet;
static HCRYPTOIDFUNCSET hImportPubKeyFuncSet;


//+-------------------------------------------------------------------------
//  Default CryptProvs. Once acquired, not released until ProcessDetach.
//--------------------------------------------------------------------------
#define DEFAULT_RSA_CRYPT_PROV                  0
#define DEFAULT_DSS_CRYPT_PROV                  1
#define DEFAULT_ENCRYPT_BASE_RSA_CRYPT_PROV     2
#define DEFAULT_ENCRYPT_ENH_RSA_CRYPT_PROV      3
#define DEFAULT_ENCRYPT_DH_CRYPT_PROV           4
#define DEFAULT_CRYPT_PROV_CNT                  5

static HCRYPTPROV rghDefaultCryptProv[DEFAULT_CRYPT_PROV_CNT];
static CRITICAL_SECTION DefaultCryptProvCriticalSection;

typedef struct _ENCRYPT_ALG_INFO ENCRYPT_ALG_INFO, *PENCRYPT_ALG_INFO;
struct _ENCRYPT_ALG_INFO {
    ALG_ID              aiAlgid;
    DWORD               dwMinLen;
    DWORD               dwMaxLen;
    PENCRYPT_ALG_INFO   pNext;
};

static BOOL fLoadedRSAEncryptAlgInfo = FALSE;
static PENCRYPT_ALG_INFO pRSAEncryptAlgInfoHead = NULL;

//+=========================================================================
//  DefaultContext Function Forward References and Data Structures
//-=========================================================================

//
// dwDefaultTypes:
//  CRYPT_DEFAULT_CONTEXT_CERT_SIGN_OID (pvDefaultPara :== pszOID)
BOOL
WINAPI
I_CryptGetDefaultContext(
    IN DWORD dwDefaultType,
    IN const void *pvDefaultPara,
    OUT HCRYPTPROV *phCryptProv,
    OUT HCRYPTDEFAULTCONTEXT *phDefaultContext
    );

// hDefaultContext is only NON-null for Process default context
void
WINAPI
I_CryptFreeDefaultContext(
    HCRYPTDEFAULTCONTEXT hDefaultContext
    );

typedef struct _DEFAULT_CONTEXT DEFAULT_CONTEXT, *PDEFAULT_CONTEXT;
struct _DEFAULT_CONTEXT {
    HCRYPTPROV                              hCryptProv;
    DWORD                                   dwDefaultType;
    union   {
        // CRYPT_DEFAULT_CONTEXT_CERT_SIGN_OID (note, converted to MULTI_)
        // CRYPT_DEFAULT_CONTEXT_MULTI_CERT_SIGN_OID
        PCRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA   pOIDDefaultPara;
    };

    DWORD                                   dwFlags;
    PDEFAULT_CONTEXT                        pNext;
    PDEFAULT_CONTEXT                        pPrev;

    // Following applicable to Process DefaultContext
    LONG                                    lRefCnt;
    HANDLE                                  hWait;
};

static BOOL fHasThreadDefaultContext;
static HCRYPTTLS hTlsDefaultContext;

static BOOL fHasProcessDefaultContext;
static CRITICAL_SECTION DefaultContextCriticalSection;
static PDEFAULT_CONTEXT pProcessDefaultContextHead;


//+-------------------------------------------------------------------------
//  Default CryptProv: initialization and free
//--------------------------------------------------------------------------
static void InitDefaultCryptProv()
{
    InitializeCriticalSection(&DefaultCryptProvCriticalSection);
}
static void FreeDefaultCryptProv()
{
    PENCRYPT_ALG_INFO pAlgInfo;

    DWORD cProv = DEFAULT_CRYPT_PROV_CNT;
    while (cProv--) {
        HCRYPTPROV hProv = rghDefaultCryptProv[cProv];
        if (hProv)
            CryptReleaseContext(hProv, 0);
    }

    pAlgInfo = pRSAEncryptAlgInfoHead;
    while (pAlgInfo) {
        PENCRYPT_ALG_INFO pDeleteAlgInfo = pAlgInfo;
        pAlgInfo = pAlgInfo->pNext;
        PkiFree(pDeleteAlgInfo);
    }

    DeleteCriticalSection(&DefaultCryptProvCriticalSection);
}

static
VOID
WINAPI
DetachDefaultContext(
    IN LPVOID pv
    )
{
    PDEFAULT_CONTEXT pDefaultContext = (PDEFAULT_CONTEXT) pv;

    while (pDefaultContext) {
        PDEFAULT_CONTEXT pFree = pDefaultContext;
        pDefaultContext = pDefaultContext->pNext;
        if (pFree->dwFlags & CRYPT_DEFAULT_CONTEXT_AUTO_RELEASE_FLAG)
            CryptReleaseContext(pFree->hCryptProv, 0);
        PkiFree(pFree);
    }
}

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL
WINAPI
CertHelperDllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved)
{
    BOOL    fRet;

    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        InitDefaultCryptProv();

		// Public key function setup
        if (NULL == (hExportPubKeyFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_EXPORT_PUBLIC_KEY_INFO_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;
        if (NULL == (hImportPubKeyFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_IMPORT_PUBLIC_KEY_INFO_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;

        if (NULL == (hEncodePubKeyFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_ENCODE_PUBLIC_KEY_AND_PARAMETERS_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;
        if (NULL == (hConvertPubKeyFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_CONVERT_PUBLIC_KEY_INFO_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;

        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CRYPT_OID_ENCODE_PUBLIC_KEY_AND_PARAMETERS_FUNC,
                ENCODE_PUB_KEY_FUNC_COUNT,
                EncodePubKeyFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError;
        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CRYPT_OID_CONVERT_PUBLIC_KEY_INFO_FUNC,
                CONVERT_PUB_KEY_FUNC_COUNT,
                ConvertPubKeyFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError;

        InitializeCriticalSection(&DefaultContextCriticalSection);
        if (NULL == (hTlsDefaultContext = I_CryptAllocTls()))
            goto CryptAllocTlsError;
        break;


    case DLL_PROCESS_DETACH:
        FreeDefaultCryptProv();

        while (pProcessDefaultContextHead) {
            PDEFAULT_CONTEXT pFree = pProcessDefaultContextHead;
            pProcessDefaultContextHead = pProcessDefaultContextHead->pNext;
            if (pFree->dwFlags & CRYPT_DEFAULT_CONTEXT_AUTO_RELEASE_FLAG)
                CryptReleaseContext(pFree->hCryptProv, 0);
            PkiFree(pFree);
        }
        DeleteCriticalSection(&DefaultContextCriticalSection);
        I_CryptFreeTls(hTlsDefaultContext, DetachDefaultContext);
        break;

    case DLL_THREAD_DETACH:
        DetachDefaultContext(I_CryptDetachTls(hTlsDefaultContext));
        break;

    default:
        break;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(CryptInitOIDFunctionSetError)
TRACE_ERROR(CryptInstallOIDFunctionAddressError)
TRACE_ERROR(CryptAllocTlsError)
}


//+-------------------------------------------------------------------------
//  Acquire default CryptProv according to the public key algorithm supported
//  by the provider type. The provider is acquired with only
//  CRYPT_VERIFYCONTEXT.
//
//  Setting aiPubKey to 0, gets the default provider for RSA_FULL.
//
//  Note, the returned CryptProv must not be released. Once acquired, the
//  CryptProv isn't released until ProcessDetach. This allows the returned 
//  CryptProvs to be shared.
//--------------------------------------------------------------------------
HCRYPTPROV
WINAPI
I_CryptGetDefaultCryptProv(
    IN ALG_ID aiPubKey
    )
{
    HCRYPTPROV hProv;
    DWORD dwProvType;
    DWORD dwDefaultProvIndex;

    switch (aiPubKey) {
        case 0:
        case CALG_RSA_SIGN:
        case CALG_RSA_KEYX:
            dwProvType = PROV_RSA_FULL;
            dwDefaultProvIndex = DEFAULT_RSA_CRYPT_PROV;
            break;
        case CALG_DSS_SIGN:
            dwProvType = PROV_DSS_DH;
            dwDefaultProvIndex = DEFAULT_DSS_CRYPT_PROV;
            break;
        default:
            SetLastError((DWORD) E_INVALIDARG);
            return 0;
    }

    hProv = rghDefaultCryptProv[dwDefaultProvIndex];

    if (0 == hProv) {
        EnterCriticalSection(&DefaultCryptProvCriticalSection);
        hProv = rghDefaultCryptProv[dwDefaultProvIndex];
        if (0 == hProv) {
            if (!CryptAcquireContext(
                    &hProv,
                    NULL,               // pszContainer
                    NULL,               // pszProvider,
                    dwProvType,
                    CRYPT_VERIFYCONTEXT // dwFlags
                    )) {
                hProv = 0;   // CAPI bug, sets hCryptProv to nonzero
                if (DEFAULT_DSS_CRYPT_PROV == dwDefaultProvIndex) {
                    if (!CryptAcquireContext(
                            &hProv,
                            NULL,               // pszContainer
                            NULL,               // pszProvider,
                            PROV_DSS,
                            CRYPT_VERIFYCONTEXT // dwFlags
                            ))
                        hProv = 0;   // CAPI bug, sets hCryptProv to nonzero
                }
            }
            rghDefaultCryptProv[dwDefaultProvIndex] = hProv;
        }
        LeaveCriticalSection(&DefaultCryptProvCriticalSection);
    }
    return hProv;
}


// Note, PP_ENUMALGS_EX returns the bit range. However, this parameter type
// may not be supported by all CSPs. If this fails, try PP_ENUMALGS which only
// returns a single, default bit length.
static void LoadRSAEncryptAlgInfo()
{
    EnterCriticalSection(&DefaultCryptProvCriticalSection);

    if (!fLoadedRSAEncryptAlgInfo) {
        HCRYPTPROV hProv;
        if (hProv = I_CryptGetDefaultCryptProv(CALG_RSA_KEYX)) {
            DWORD dwFlags = CRYPT_FIRST;
            BOOL fEx = TRUE;

            while (TRUE) {
                ENCRYPT_ALG_INFO AlgInfo;
                PENCRYPT_ALG_INFO pAllocAlgInfo;

                if (fEx) {
                    PROV_ENUMALGS_EX Data;
                    DWORD cbData = sizeof(Data);

                    if (!CryptGetProvParam(
                            hProv,
                            PP_ENUMALGS_EX,
                            (BYTE *) &Data,
                            &cbData,
                            dwFlags
                            )) {
                        if (0 != dwFlags) {
                            // Try PP_ENUMALGS
                            fEx = FALSE;
                            continue;
                        } else
                            break;
                    }
                    AlgInfo.aiAlgid = Data.aiAlgid;
                    AlgInfo.dwMinLen = Data.dwMinLen;
                    AlgInfo.dwMaxLen = Data.dwMaxLen;
                } else {
                    PROV_ENUMALGS Data;
                    DWORD cbData = sizeof(Data);

                    if (!CryptGetProvParam(
                            hProv,
                            PP_ENUMALGS,
                            (BYTE *) &Data,
                            &cbData,
                            dwFlags
                            ))
                        break;
                    // Only know about a single length
                    AlgInfo.aiAlgid = Data.aiAlgid;
                    AlgInfo.dwMinLen = Data.dwBitLen;
                    AlgInfo.dwMaxLen = Data.dwBitLen;
                }

                dwFlags = 0;    // CRYPT_NEXT

                // Only interested in encrypt algorithms
                if (ALG_CLASS_DATA_ENCRYPT != GET_ALG_CLASS(AlgInfo.aiAlgid))
                    continue;

                if (NULL == (pAllocAlgInfo = (PENCRYPT_ALG_INFO)
                        PkiNonzeroAlloc(sizeof(ENCRYPT_ALG_INFO))))
                    break;
                AlgInfo.pNext = pRSAEncryptAlgInfoHead;
                memcpy(pAllocAlgInfo, &AlgInfo, sizeof(*pAllocAlgInfo));
                pRSAEncryptAlgInfoHead = pAllocAlgInfo;
            }
        }

        fLoadedRSAEncryptAlgInfo = TRUE;
    }
    LeaveCriticalSection(&DefaultCryptProvCriticalSection);
}

static BOOL IsDefaultRSACryptProvForEncrypt(
    IN ALG_ID aiEncrypt,
    IN DWORD dwBitLen
    )
{
    PENCRYPT_ALG_INFO pInfo;
    if (!fLoadedRSAEncryptAlgInfo)
        LoadRSAEncryptAlgInfo();

    if (0 == dwBitLen && (CALG_RC2 == aiEncrypt || CALG_RC4 == aiEncrypt))
        dwBitLen = 40;

    for (pInfo = pRSAEncryptAlgInfoHead; pInfo; pInfo = pInfo->pNext) {
        if (aiEncrypt == pInfo->aiAlgid) {
            if (0 == dwBitLen || (pInfo->dwMinLen <= dwBitLen &&
                    dwBitLen <= pInfo->dwMaxLen))
                return TRUE;
        }
    }

    return FALSE;
}


//+-------------------------------------------------------------------------
//  Acquire default CryptProv according to the public key algorithm, encrypt
//  key algorithm and encrypt key length supported by the provider type.
//
//  dwBitLen = 0, assumes the aiEncrypt's default bit length. For example,
//  CALG_RC2 has a default bit length of 40.
//
//  Note, the returned CryptProv must not be released. Once acquired, the
//  CryptProv isn't released until ProcessDetach. This allows the returned 
//  CryptProvs to be shared.
//--------------------------------------------------------------------------
HCRYPTPROV
WINAPI
I_CryptGetDefaultCryptProvForEncrypt(
    IN ALG_ID aiPubKey,
    IN ALG_ID aiEncrypt,
    IN DWORD dwBitLen
    )
{
    HCRYPTPROV hProv;
    DWORD dwProvType;
    DWORD dwDefaultProvIndex;
    LPCTSTR pszProvider;

    if (CALG_DH_SF == aiPubKey || CALG_DH_EPHEM == aiPubKey) {
        dwProvType = PROV_DSS_DH;
        dwDefaultProvIndex = DEFAULT_ENCRYPT_DH_CRYPT_PROV;
        pszProvider = NULL;
    } else {
        dwProvType = PROV_RSA_FULL;

        if (IsDefaultRSACryptProvForEncrypt(
                aiEncrypt,
                dwBitLen
                ))
            // Set to fall through to the default case
            aiEncrypt = 0;

        switch (aiEncrypt) {
            case CALG_DES:
            case CALG_3DES:
            case CALG_3DES_112:
                dwDefaultProvIndex = DEFAULT_ENCRYPT_ENH_RSA_CRYPT_PROV;
                pszProvider = MS_ENHANCED_PROV;
                break;
            case CALG_RC2:
            case CALG_RC4:
                if (40 >= dwBitLen) {
                    dwDefaultProvIndex = DEFAULT_ENCRYPT_BASE_RSA_CRYPT_PROV;
                    pszProvider = MS_DEF_PROV;
                } else {
                    dwDefaultProvIndex = DEFAULT_ENCRYPT_ENH_RSA_CRYPT_PROV;
                    pszProvider = MS_ENHANCED_PROV;
                }
                break;
            case 0:
            default:
                dwDefaultProvIndex = DEFAULT_RSA_CRYPT_PROV;
                pszProvider = NULL;
                break;
        }
    }

    hProv = rghDefaultCryptProv[dwDefaultProvIndex];

    if (0 == hProv) {
        EnterCriticalSection(&DefaultCryptProvCriticalSection);
        hProv = rghDefaultCryptProv[dwDefaultProvIndex];
        if (0 == hProv) {
            if (!CryptAcquireContext(
                    &hProv,
                    NULL,               // pszContainer
                    pszProvider,
                    dwProvType,
                    CRYPT_VERIFYCONTEXT // dwFlags
                    ))
                hProv = 0;   // CAPI bug, sets hCryptProv to nonzero
            else
                rghDefaultCryptProv[dwDefaultProvIndex] = hProv;
        }
        LeaveCriticalSection(&DefaultCryptProvCriticalSection);
    }
    return hProv;
}


//+-------------------------------------------------------------------------
//  Cert helper allocation and free functions
//--------------------------------------------------------------------------
static void *AllocAndDecodeObject(
    IN DWORD dwCertEncodingType,
    IN LPCSTR lpszStructType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT OPTIONAL DWORD *pcbStructInfo = NULL
    )
{
    DWORD cbStructInfo;
    void *pvStructInfo;

    if (!CryptDecodeObjectEx(
            dwCertEncodingType,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            CRYPT_DECODE_NOCOPY_FLAG | CRYPT_DECODE_ALLOC_FLAG,
            &PkiDecodePara,
            (void *) &pvStructInfo,
            &cbStructInfo
            ))
        goto ErrorReturn;

CommonReturn:
    if (pcbStructInfo)
        *pcbStructInfo = cbStructInfo;
    return pvStructInfo;
ErrorReturn:
    pvStructInfo = NULL;
    goto CommonReturn;
}

static BOOL AllocAndEncodeObject(
    IN DWORD dwCertEncodingType,
    IN LPCSTR lpszStructType,
    IN const void *pvStructInfo,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded
    )
{
    return CryptEncodeObjectEx(
        dwCertEncodingType,
        lpszStructType,
        pvStructInfo,
        CRYPT_ENCODE_ALLOC_FLAG,
        &PkiEncodePara,
        (void *) ppbEncoded,
        pcbEncoded
        );
}

#if 0
//+-------------------------------------------------------------------------
//  For an authority key identifier extension, compare the extension's optional
//  fields with the specified issuer certificate.
//
//  Returns TRUE for no authority key identifier extension or an issuer
//  certificate match.
//--------------------------------------------------------------------------
static BOOL CompareAuthorityKeyIdentifier(
    IN DWORD dwCertEncodingType,
    IN DWORD cExtensions,
    IN CERT_EXTENSION rgExtensions[],
    IN PCERT_INFO pIssuerInfo
    )
{
    BOOL fResult;
    PCERT_EXTENSION pExt;
    PCERT_AUTHORITY_KEY_ID_INFO pKeyIdInfo = NULL;

    pExt = CertFindExtension(
            szOID_AUTHORITY_KEY_IDENTIFIER,
            cExtensions,
            rgExtensions
            );
    if (pExt == NULL)
        return TRUE;
    
    if (NULL == (pKeyIdInfo =
        (PCERT_AUTHORITY_KEY_ID_INFO) AllocAndDecodeObject(
            dwCertEncodingType,
            X509_AUTHORITY_KEY_ID,
            pExt->Value.pbData,
            pExt->Value.cbData
            ))) goto DecodeError;

    if (pKeyIdInfo->CertIssuer.cbData) {
        // Issuer certificate's issuer name must match
        if (!CertCompareCertificateName(
                dwCertEncodingType,
                &pKeyIdInfo->CertIssuer,
                &pIssuerInfo->Issuer
                )) goto ErrorReturn;
    }

    if (pKeyIdInfo->CertSerialNumber.cbData) {
        // Issuer certificate's serial number must match
        if (!CertCompareIntegerBlob(
                &pKeyIdInfo->CertSerialNumber,
                &pIssuerInfo->SerialNumber))
            goto ErrorReturn;
    }

    fResult = TRUE;
    goto CommonReturn;

DecodeError:
    fResult = TRUE;
    goto CommonReturn;
ErrorReturn:
    fResult = FALSE;
CommonReturn:
    PkiFree(pKeyIdInfo);
    return fResult;
}
#endif


//+-------------------------------------------------------------------------
//  Compare two multiple byte integer blobs to see if they are identical.
//
//  Before doing the comparison, leading zero bytes are removed from a
//  positive number and leading 0xFF bytes are removed from a negative
//  number.
//
//  The multiple byte integers are treated as Little Endian. pbData[0] is the
//  least significant byte and pbData[cbData - 1] is the most significant
//  byte.
//
//  Returns TRUE if the integer blobs are identical after removing leading
//  0 or 0xFF bytes.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertCompareIntegerBlob(
    IN PCRYPT_INTEGER_BLOB pInt1,
    IN PCRYPT_INTEGER_BLOB pInt2
    )
{
    BYTE *pb1 = pInt1->pbData;
    DWORD cb1 = pInt1->cbData;
    BYTE *pb2 = pInt2->pbData;
    DWORD cb2 = pInt2->cbData;

    // Assumption: normally don't have leading 0 or 0xFF bytes.

    while (cb1 > 1) {
        BYTE bEnd = pb1[cb1 - 1];
        BYTE bPrev = pb1[cb1 - 2];
        if ((0 == bEnd && 0 == (bPrev & 0x80)) ||
                (0xFF == bEnd && 0 != (bPrev & 0x80)))
            cb1--;
        else
            break;
    }

    while (cb2 > 1) {
        BYTE bEnd = pb2[cb2 - 1];
        BYTE bPrev = pb2[cb2 - 2];
        if ((0 == bEnd && 0 == (bPrev & 0x80)) ||
                (0xFF == bEnd && 0 != (bPrev & 0x80)))
            cb2--;
        else
            break;
    }

    if (cb1 == cb2 && (0 == cb1 || 0 == memcmp(pb1, pb2, cb1)))
        return TRUE;
    else
        return FALSE;
}

//+-------------------------------------------------------------------------
//  Compare two certificates to see if they are identical.
//
//  Since a certificate is uniquely identified by its Issuer and SerialNumber,
//  these are the only fields needing to be compared.
//
//  Returns TRUE if the certificates are identical.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertCompareCertificate(
    IN DWORD dwCertEncodingType,
    IN PCERT_INFO pCertId1,
    IN PCERT_INFO pCertId2
    )
{
    if (CertCompareIntegerBlob(&pCertId1->SerialNumber,
            &pCertId2->SerialNumber) &&
        pCertId1->Issuer.cbData == pCertId2->Issuer.cbData &&
        memcmp(pCertId1->Issuer.pbData, pCertId2->Issuer.pbData,
            pCertId1->Issuer.cbData) == 0)
        return TRUE;
    else
        return FALSE;
}

//+-------------------------------------------------------------------------
//  Compare two certificate names to see if they are identical.
//
//  Returns TRUE if the names are identical.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertCompareCertificateName(
    IN DWORD dwCertEncodingType,
    IN PCERT_NAME_BLOB pCertName1,
    IN PCERT_NAME_BLOB pCertName2
    )
{
    if (pCertName1->cbData == pCertName2->cbData &&
        memcmp(pCertName1->pbData, pCertName2->pbData,
            pCertName1->cbData) == 0)
        return TRUE;
    else
        return FALSE;
}

//+-------------------------------------------------------------------------
//  Compare the attributes in the certificate name with the specified 
//  Relative Distinguished Name's (CERT_RDN) array of attributes.
//  The comparison iterates through the CERT_RDN attributes and looks for an
//  attribute match in any of the certificate's RDNs. Returns TRUE if all the
//  attributes are found and match. 
//
//  The CERT_RDN_ATTR fields can have the following special values:
//    pszObjId == NULL              - ignore the attribute object identifier
//    dwValueType == CERT_RDN_ANY_TYPE   - ignore the value type
//    Value.pbData == NULL          - match any value
//   
//  Currently only an exact, case sensitive match is supported.
//
//  CERT_UNICODE_IS_RDN_ATTRS_FLAG should be set if the pRDN was initialized
//  with unicode strings as for CryptEncodeObject(X509_UNICODE_NAME).
//--------------------------------------------------------------------------
BOOL
WINAPI
CertIsRDNAttrsInCertificateName(
    IN DWORD dwCertEncodingType,
    IN DWORD dwFlags,
    IN PCERT_NAME_BLOB pCertName,
    IN PCERT_RDN pRDN
    )
{
    BOOL fResult;
    PCERT_NAME_INFO pNameInfo = NULL;

    DWORD cCmpAttr;
    PCERT_RDN_ATTR pCmpAttr;
    BOOL fMatch;

    if (NULL == (pNameInfo =
        (PCERT_NAME_INFO) AllocAndDecodeObject(
            dwCertEncodingType,
            CERT_UNICODE_IS_RDN_ATTRS_FLAG & dwFlags ? X509_UNICODE_NAME :
                X509_NAME,
            pCertName->pbData,
            pCertName->cbData
            ))) goto ErrorReturn;

    cCmpAttr = pRDN->cRDNAttr;
    pCmpAttr = pRDN->rgRDNAttr;
    fMatch = TRUE;
    // Iterate through list of attributes to be compared against
    for ( ; cCmpAttr > 0; cCmpAttr--, pCmpAttr++) {
        fMatch = FALSE;
        DWORD cNameRDN = pNameInfo->cRDN;
        PCERT_RDN pNameRDN = pNameInfo->rgRDN;
        // Iterate through name's list of RDNs
        for ( ; cNameRDN > 0; cNameRDN--, pNameRDN++) {
            DWORD cNameAttr = pNameRDN->cRDNAttr;
            PCERT_RDN_ATTR pNameAttr = pNameRDN->rgRDNAttr;
            // Iterate through name's CERT_RDN's list of attributes
            for ( ; cNameAttr > 0; cNameAttr--, pNameAttr++) {
                DWORD cbCmpData;
                if (pCmpAttr->pszObjId && 
                        (pNameAttr->pszObjId == NULL ||
                         strcmp(pCmpAttr->pszObjId, pNameAttr->pszObjId) != 0))
                    continue;
                if (pCmpAttr->dwValueType != CERT_RDN_ANY_TYPE &&
                        pCmpAttr->dwValueType != pNameAttr->dwValueType)
                    continue;

                if (pCmpAttr->Value.pbData == NULL) {
                    fMatch = TRUE;
                    break;
                }

                cbCmpData = pCmpAttr->Value.cbData;
                if ((CERT_UNICODE_IS_RDN_ATTRS_FLAG & dwFlags) &&
                        0 == cbCmpData)
                    cbCmpData = wcslen((LPWSTR) pCmpAttr->Value.pbData) * 2;

                if (cbCmpData == pNameAttr->Value.cbData &&
                        (cbCmpData == 0 ||
                         memcmp(pCmpAttr->Value.pbData,
                            pNameAttr->Value.pbData,
                            cbCmpData) == 0)) {
                    fMatch = TRUE;
                    break;
                }
            }
            if (fMatch) break;
        }
        if (!fMatch) break;
    }

    if (!fMatch) {
        SetLastError((DWORD) CRYPT_E_NO_MATCH);
        goto ErrorReturn;
    }

    fResult = TRUE;
    goto CommonReturn;


ErrorReturn:
    fResult = FALSE;
CommonReturn:
    PkiFree(pNameInfo);
    return fResult;
}

#if 0
#ifndef RSA1
#define RSA1 ((DWORD)'R'+((DWORD)'S'<<8)+((DWORD)'A'<<16)+((DWORD)'1'<<24))
#endif

//+-------------------------------------------------------------------------
//  Compare two public keys to see if they are identical.
//
//  Returns TRUE if the keys are identical.
//
//  Note: ignores CAPI's reserved and aiKeyAlg fields in the comparison.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertComparePublicKeyBitBlob(
    IN DWORD dwCertEncodingType,
    IN PCRYPT_BIT_BLOB pPublicKey1,
    IN PCRYPT_BIT_BLOB pPublicKey2
    )
{
    BYTE *pb1, *pb2;
    PUBLICKEYSTRUC *pPubKeyStruc1, *pPubKeyStruc2;
    RSAPUBKEY *pRsaPubKey1, *pRsaPubKey2;
    BYTE *pbModulus1, *pbModulus2;
    DWORD cbModulus1, cbModulus2;


    // The CAPI public key representation consists of the following sequence:
    //  - PUBLICKEYSTRUC
    //  - RSAPUBKEY
    //  - rgbModulus[]
    pb1 = pPublicKey1->pbData;
    pPubKeyStruc1 = (PUBLICKEYSTRUC *) pb1;
    pRsaPubKey1 = (RSAPUBKEY *) (pb1 + sizeof(PUBLICKEYSTRUC));
    pbModulus1 = pb1 + sizeof(PUBLICKEYSTRUC) + sizeof(RSAPUBKEY);
    cbModulus1 = pRsaPubKey1->bitlen / 8;

    assert(cbModulus1 > 0);
    assert(sizeof(PUBLICKEYSTRUC) + sizeof(RSAPUBKEY) + cbModulus1 <=
        pPublicKey1->cbData);
    assert(pPubKeyStruc1->bType == PUBLICKEYBLOB);
    assert(pPubKeyStruc1->bVersion == CUR_BLOB_VERSION);
    assert(pPubKeyStruc1->aiKeyAlg == CALG_RSA_SIGN ||
           pPubKeyStruc1->aiKeyAlg == CALG_RSA_KEYX);
    assert(pRsaPubKey1->magic == RSA1);
    assert(pRsaPubKey1->bitlen % 8 == 0);

    pb2 = pPublicKey2->pbData;
    pPubKeyStruc2 = (PUBLICKEYSTRUC *) pb2;
    pRsaPubKey2 = (RSAPUBKEY *) (pb2 + sizeof(PUBLICKEYSTRUC));
    pbModulus2 = pb2 + sizeof(PUBLICKEYSTRUC) + sizeof(RSAPUBKEY);
    cbModulus2 = pRsaPubKey2->bitlen / 8;

    assert(cbModulus2 > 0);
    assert(sizeof(PUBLICKEYSTRUC) + sizeof(RSAPUBKEY) + cbModulus2 <=
        pPublicKey2->cbData);
    assert(pPubKeyStruc2->bType == PUBLICKEYBLOB);
    assert(pPubKeyStruc2->bVersion == CUR_BLOB_VERSION);
    assert(pPubKeyStruc2->aiKeyAlg == CALG_RSA_SIGN ||
           pPubKeyStruc2->aiKeyAlg == CALG_RSA_KEYX);
    assert(pRsaPubKey2->magic == RSA1);
    assert(pRsaPubKey2->bitlen % 8 == 0);

    if (pRsaPubKey1->pubexp == pRsaPubKey2->pubexp &&
            cbModulus1 == cbModulus2 &&
            memcmp(pbModulus1, pbModulus2, cbModulus1) == 0)
        return TRUE;
    else
        return FALSE;

}
#endif

//+-------------------------------------------------------------------------
//  Compare two public keys to see if they are identical.
//
//  Returns TRUE if the keys are identical.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertComparePublicKeyInfo(
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pPublicKey1,
    IN PCERT_PUBLIC_KEY_INFO pPublicKey2
    )
{
    DWORD cbData;
    if ((cbData = pPublicKey1->PublicKey.cbData) ==
            pPublicKey2->PublicKey.cbData &&
            (cbData == 0 || memcmp(pPublicKey1->PublicKey.pbData,
                pPublicKey2->PublicKey.pbData, cbData) == 0)) {
        // Compare algorithm parameters
        DWORD cb1 = pPublicKey1->Algorithm.Parameters.cbData;
        BYTE *pb1 = pPublicKey1->Algorithm.Parameters.pbData;
        DWORD cb2 = pPublicKey2->Algorithm.Parameters.cbData;
        BYTE *pb2 = pPublicKey2->Algorithm.Parameters.pbData;

        if (X509_ASN_ENCODING == GET_CERT_ENCODING_TYPE(dwCertEncodingType)) {
            // Check if either has NO or NULL parameters
            if (0 == cb1 || *pb1 == NULL_ASN_TAG ||
                    0 == cb2 || *pb2 == NULL_ASN_TAG)
                return TRUE;
        }

        if (cb1 == cb2) {
            if (0 == cb1 || 0 == memcmp(pb1, pb2, cb1))
                return TRUE;
        }
    }

    return FALSE;
}

static BOOL GetSignOIDInfo(
    IN LPCSTR pszObjId,
    OUT ALG_ID *paiHash,
    OUT ALG_ID *paiPubKey,
    OUT DWORD *pdwFlags
    )
{
    BOOL fResult;
    PCCRYPT_OID_INFO pInfo;

    *paiPubKey = 0;
    *pdwFlags = 0;
    if (pInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            (void *) pszObjId,
            CRYPT_SIGN_ALG_OID_GROUP_ID
            )) {
        DWORD cExtra = pInfo->ExtraInfo.cbData / sizeof(DWORD);
        DWORD *pdwExtra = (DWORD *) pInfo->ExtraInfo.pbData;

        *paiHash = pInfo->Algid;
        if (1 <= cExtra) {
            *paiPubKey = pdwExtra[0];
            if (2 <= cExtra)
                *pdwFlags = pdwExtra[1];
        }
        fResult = TRUE;
    } else {
        *paiHash = 0;
        fResult = FALSE;
        SetLastError((DWORD) NTE_BAD_ALGID);
    }
    return fResult;
}


#ifndef CMS_PKCS7

//+-------------------------------------------------------------------------
//  Verify the signature of a subject certificate or a CRL using the
//  specified public key.
//
//  Returns TRUE for a valid signature.
//
//  hCryptProv specifies the crypto provider to use to verify the signature.
//  It doesn't need to use a private key.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptVerifyCertificateSignature(
    IN HCRYPTPROV   hCryptProv,
    IN DWORD        dwCertEncodingType,
    IN const BYTE * pbEncoded,
    IN DWORD        cbEncoded,
    IN PCERT_PUBLIC_KEY_INFO pPublicKey
    )
{
    BOOL fResult;
    PCERT_SIGNED_CONTENT_INFO pSignedInfo = NULL;
    HCRYPTDEFAULTCONTEXT hDefaultContext = NULL;
    HCRYPTKEY hSignKey = 0;
    HCRYPTHASH hHash = 0;
    BYTE *pbSignature;      // not allocated
    DWORD cbSignature;
    BYTE rgbDssSignature[CERT_DSS_SIGNATURE_LEN];
    ALG_ID aiHash;
    ALG_ID aiPubKey;
    DWORD dwSignFlags;
    DWORD dwErr;
    
    if (NULL == (pSignedInfo =
        (PCERT_SIGNED_CONTENT_INFO) AllocAndDecodeObject(
            dwCertEncodingType,
            X509_CERT,
            pbEncoded,
            cbEncoded
            ))) goto ErrorReturn;

    if (!GetSignOIDInfo(pSignedInfo->SignatureAlgorithm.pszObjId,
            &aiHash, &aiPubKey, &dwSignFlags))
        goto ErrorReturn;

    if (0 == hCryptProv) {
        if (!I_CryptGetDefaultContext(
                CRYPT_DEFAULT_CONTEXT_CERT_SIGN_OID,
                (const void *) pSignedInfo->SignatureAlgorithm.pszObjId,
                &hCryptProv,
                &hDefaultContext
                )) {
            if (0 == (hCryptProv = I_CryptGetDefaultCryptProv(aiPubKey)))
                goto ErrorReturn;
        }
    }

#if 0
    // Slow down the signature verify while holding the default context
    // reference count
    if (hDefaultContext)
        Sleep(5000);
#endif

    if (!CryptImportPublicKeyInfo(
                hCryptProv,
                dwCertEncodingType,
                pPublicKey,
                &hSignKey
                )) goto ErrorReturn;
    if (!CryptCreateHash(
                hCryptProv,
                aiHash,
                NULL,               // hKey - optional for MAC
                0,                  // dwFlags
                &hHash
                )) goto ErrorReturn;
    if (!CryptHashData(
                hHash,
                pSignedInfo->ToBeSigned.pbData,
                pSignedInfo->ToBeSigned.cbData,
                0                   // dwFlags
                )) goto ErrorReturn;


    pbSignature = pSignedInfo->Signature.pbData;
    cbSignature = pSignedInfo->Signature.cbData;
    if (CALG_DSS_SIGN == aiPubKey &&
            0 == (dwSignFlags & CRYPT_OID_INHIBIT_SIGNATURE_FORMAT_FLAG)) {
        DWORD cbData;

        // Undo the reversal done by CryptDecodeObject(X509_CERT)
        PkiAsn1ReverseBytes(pbSignature, cbSignature);
        // Convert from ASN.1 sequence of two integers to the CSP signature
        // format.
        cbData = sizeof(rgbDssSignature);
        if (!CryptDecodeObject(
                dwCertEncodingType,
                X509_DSS_SIGNATURE,
                pbSignature,
                cbSignature,
                0,                                  // dwFlags
                rgbDssSignature,
                &cbData
                ))
            goto ErrorReturn;
        pbSignature = rgbDssSignature;
        assert(cbData == sizeof(rgbDssSignature));
        cbSignature = sizeof(rgbDssSignature);
    }

    if (!CryptVerifySignature(
                hHash,
                pbSignature,
                cbSignature,
                hSignKey,
                NULL,               // sDescription
                0                   // dwFlags
                )) goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:
    dwErr = GetLastError();
    if (hSignKey)
        CryptDestroyKey(hSignKey);
    if (hHash)
        CryptDestroyHash(hHash);
    I_CryptFreeDefaultContext(hDefaultContext);
    PkiFree(pSignedInfo);

    SetLastError(dwErr);
    return fResult;
}

#endif  // CMS_PKCS7

BOOL
WINAPI
DefaultHashCertificate(
    IN ALG_ID Algid,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT BYTE *pbHash,
    IN OUT DWORD *pcbHash
    )
{
    DWORD cbInHash;
    DWORD cbOutHash;

    if (NULL == pbHash)
        cbInHash = 0;
    else
        cbInHash = *pcbHash;

    switch (Algid) {
        case CALG_MD5:
            cbOutHash = MD5DIGESTLEN;
            if (MD5DIGESTLEN <= cbInHash) {
                MD5_CTX md5ctx;

                MD5Init(&md5ctx);
                if (cbEncoded)
                    MD5Update(&md5ctx, pbEncoded, cbEncoded);
                MD5Final(&md5ctx);
                memcpy(pbHash, md5ctx.digest, MD5DIGESTLEN);
            }
            break;

        case CALG_SHA1:
        default:
            assert(CALG_SHA1 == Algid);
            assert(CALG_SHA == Algid);
            cbOutHash = A_SHA_DIGEST_LEN;
            if (A_SHA_DIGEST_LEN <= cbInHash) {
                A_SHA_CTX shactx;

                A_SHAInit(&shactx);
                if (cbEncoded)
                    A_SHAUpdate(&shactx, (BYTE *) pbEncoded, cbEncoded);
                A_SHAFinal(&shactx, pbHash);
            }
            break;
    }

    *pcbHash = cbOutHash;
    if (cbInHash < cbOutHash && pbHash) {
        SetLastError((DWORD) ERROR_MORE_DATA);
        return FALSE;
    } else
        return TRUE;
}

//+-------------------------------------------------------------------------
//  Hash the encoded content.
//
//  hCryptProv specifies the crypto provider to use to compute the hash.
//  It doesn't need to use a private key.
//
//  Algid specifies the CAPI hash algorithm to use. If Algid is 0, then, the
//  default hash algorithm (currently SHA1) is used.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptHashCertificate(
    IN HCRYPTPROV hCryptProv,
    IN ALG_ID Algid,
    IN DWORD dwFlags,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT BYTE *pbComputedHash,
    IN OUT DWORD *pcbComputedHash
    )
{
    BOOL fResult;
    HCRYPTHASH hHash = 0;
    DWORD dwErr;

    if (Algid == 0) {
        Algid = CALG_SHA;
        dwFlags = 0;
    }

    if (0 == hCryptProv) {
        if (CALG_SHA1 == Algid || CALG_MD5 == Algid)
            return DefaultHashCertificate(
                Algid,
                pbEncoded,
                cbEncoded,
                pbComputedHash,
                pcbComputedHash
                );
        if (0 == (hCryptProv = I_CryptGetDefaultCryptProv(0)))
            goto ErrorReturn;
    }

    if (!CryptCreateHash(
                hCryptProv,
                Algid,
                NULL,               // hKey - optional for MAC
                dwFlags,
                &hHash
                ))
        goto ErrorReturn;
    if (!CryptHashData(
                hHash,
                pbEncoded,
                cbEncoded,
                0                   // dwFlags
                ))
        goto ErrorReturn;

    fResult = CryptGetHashParam(
                hHash,
                HP_HASHVAL,
                pbComputedHash,
                pcbComputedHash,
                0                   // dwFlags
                );
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
    *pcbComputedHash = 0;
CommonReturn:
    dwErr = GetLastError();
    if (hHash)
        CryptDestroyHash(hHash);
    SetLastError(dwErr);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Compute the hash of the "to be signed" information in the encoded
//  signed content.
//
//  hCryptProv specifies the crypto provider to use to compute the hash.
//  It doesn't need to use a private key.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptHashToBeSigned(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwCertEncodingType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT BYTE *pbComputedHash,
    IN OUT DWORD *pcbComputedHash
    )
{
    BOOL fResult;
    PCERT_SIGNED_CONTENT_INFO pSignedInfo = NULL;
    HCRYPTHASH hHash = 0;
    DWORD dwErr;
    ALG_ID aiHash;
    ALG_ID aiPubKey;
    DWORD dwSignFlags;
    
    if (NULL == (pSignedInfo =
        (PCERT_SIGNED_CONTENT_INFO) AllocAndDecodeObject(
            dwCertEncodingType,
            X509_CERT,
            pbEncoded,
            cbEncoded
            ))) goto ErrorReturn;

    if (!GetSignOIDInfo(pSignedInfo->SignatureAlgorithm.pszObjId,
            &aiHash, &aiPubKey, &dwSignFlags))
        goto ErrorReturn;

    if (0 == hCryptProv) {
        if (CALG_SHA1 == aiHash || CALG_MD5 == aiHash) {
            fResult = DefaultHashCertificate(
                aiHash,
                pSignedInfo->ToBeSigned.pbData,
                pSignedInfo->ToBeSigned.cbData,
                pbComputedHash,
                pcbComputedHash
                );
            goto CommonReturn;
        }
        if (0 == (hCryptProv = I_CryptGetDefaultCryptProv(0)))
            goto ErrorReturn;
    }

    if (!CryptCreateHash(
                hCryptProv,
                aiHash,
                NULL,               // hKey - optional for MAC
                0,                  // dwFlags
                &hHash
                ))
        goto ErrorReturn;
    if (!CryptHashData(
                hHash,
                pSignedInfo->ToBeSigned.pbData,
                pSignedInfo->ToBeSigned.cbData,
                0                   // dwFlags
                ))
        goto ErrorReturn;

    fResult = CryptGetHashParam(
                hHash,
                HP_HASHVAL,
                pbComputedHash,
                pcbComputedHash,
                0                   // dwFlags
                );
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
    *pcbComputedHash = 0;
CommonReturn:
    dwErr = GetLastError();
    if (hHash)
        CryptDestroyHash(hHash);
    PkiFree(pSignedInfo);
    SetLastError(dwErr);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Sign the "to be signed" information in the encoded signed content.
//
//  hCryptProv specifies the crypto provider to use to do the signature.
//  It needs to use the provider's signature private key.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptSignCertificate(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwKeySpec,
    IN DWORD dwCertEncodingType,
    IN const BYTE *pbEncodedToBeSigned,
    IN DWORD cbEncodedToBeSigned,
    IN PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
    IN OPTIONAL const void *pvHashAuxInfo,
    OUT BYTE *pbSignature,
    IN OUT DWORD *pcbSignature
    )
{
    BOOL fResult;
    ALG_ID aiHash;
    ALG_ID aiPubKey;
    DWORD dwSignFlags;
    HCRYPTHASH hHash = 0;
    DWORD dwErr;

    if (!GetSignOIDInfo(pSignatureAlgorithm->pszObjId,
            &aiHash, &aiPubKey, &dwSignFlags))
        goto ErrorReturn;

    if (CALG_DSS_SIGN == aiPubKey &&
            0 == (dwSignFlags & CRYPT_OID_INHIBIT_SIGNATURE_FORMAT_FLAG)) {
        if (NULL == pbSignature) {
            *pcbSignature = CERT_MAX_ASN_ENCODED_DSS_SIGNATURE_LEN;
            return TRUE;
        }
    }

    if (!CryptCreateHash(
                hCryptProv,
                aiHash,
                NULL,               // hKey - optional for MAC
                0,                  // dwFlags,
                &hHash
                ))
        goto ErrorReturn;

    if (!CryptHashData(
                hHash,
                pbEncodedToBeSigned,
                cbEncodedToBeSigned,
                0                   // dwFlags
                ))
        goto ErrorReturn;

    if (CALG_DSS_SIGN == aiPubKey &&
            0 == (dwSignFlags & CRYPT_OID_INHIBIT_SIGNATURE_FORMAT_FLAG)) {
        DWORD cbData;
        BYTE rgbDssSignature[CERT_DSS_SIGNATURE_LEN];

        cbData = sizeof(rgbDssSignature);
        if (!CryptSignHash(
                hHash,
                dwKeySpec,
                NULL,               // sDescription
                0,                  // dwFlags
                rgbDssSignature,
                &cbData
                )) goto ErrorReturn;
        assert(cbData == sizeof(rgbDssSignature));
        // Convert from the CSP signature format to an ASN.1 sequence of
        // two integers
        fResult = CryptEncodeObject(
                    dwCertEncodingType,
                    X509_DSS_SIGNATURE,
                    rgbDssSignature,
                    pbSignature,
                    pcbSignature
                    );
        if (fResult)
            // A subsequent CryptEncodeObject(X509_CERT) will reverse
            // the signature bytes
            PkiAsn1ReverseBytes(pbSignature, *pcbSignature);
        else if (0 != *pcbSignature)
            // Since a random number is used in each CryptSignHash invocation,
            // the generated signature will be different. In particular
            // different signatures may have different leading 0x00's or
            // 0xFF's which get removed when converted to the ASN.1 sequence
            // of integers.
            *pcbSignature = CERT_MAX_ASN_ENCODED_DSS_SIGNATURE_LEN;
    } else
        fResult = CryptSignHash(
                    hHash,
                    dwKeySpec,
                    NULL,               // sDescription
                    0,                  // dwFlags
                    pbSignature,        // pbData
                    pcbSignature
                    );
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
    *pcbSignature = 0;
CommonReturn:
    dwErr = GetLastError();
    if (hHash)
        CryptDestroyHash(hHash);
    SetLastError(dwErr);
    return fResult;
}

static DWORD AdjustForMaximumEncodedSignatureLength(
    IN PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
    IN DWORD cbOrig
    )
{
    DWORD cbAdjust;
    ALG_ID aiHash;
    ALG_ID aiPubKey;
    DWORD dwSignFlags;

    cbAdjust = 0;
    if (GetSignOIDInfo(pSignatureAlgorithm->pszObjId,
            &aiHash, &aiPubKey, &dwSignFlags)) {
        if (CALG_DSS_SIGN == aiPubKey &&
                0 == (dwSignFlags & CRYPT_OID_INHIBIT_SIGNATURE_FORMAT_FLAG)) {
            assert(CERT_MAX_ASN_ENCODED_DSS_SIGNATURE_LEN >= cbOrig);
            if (CERT_MAX_ASN_ENCODED_DSS_SIGNATURE_LEN > cbOrig)
                // the +1 is for adjusting the number of length octets in
                // the outer SEQUENCE. Note, the number of length octets in
                // the signature's BITSTRING will always be 1, ie,
                // CERT_MAX_ASN_ENCODED_DSS_SIGNATURE_LEN <= 0x7F.
                cbAdjust =
                    (CERT_MAX_ASN_ENCODED_DSS_SIGNATURE_LEN - cbOrig) + 1;
        }
    }
    return cbAdjust;
}

//+-------------------------------------------------------------------------
//  Encode the "to be signed" information. Sign the encoded "to be signed".
//  Encode the "to be signed" and the signature.
//
//  hCryptProv specifies the crypto provider to use to do the signature.
//  It uses the specified private key.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptSignAndEncodeCertificate(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwKeySpec,
    IN DWORD dwCertEncodingType,
    IN LPCSTR lpszStructType,
    IN const void *pvStructInfo,
    IN PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
    IN OPTIONAL const void *pvHashAuxInfo,
    OUT BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    BOOL fResult;
    CERT_SIGNED_CONTENT_INFO SignedInfo;
    memset(&SignedInfo, 0, sizeof(SignedInfo));

    SignedInfo.SignatureAlgorithm = *pSignatureAlgorithm;

    if (!AllocAndEncodeObject(
            dwCertEncodingType,
            lpszStructType,
            pvStructInfo,
            &SignedInfo.ToBeSigned.pbData,
            &SignedInfo.ToBeSigned.cbData
            )) goto ErrorReturn;

    CryptSignCertificate(
            hCryptProv,
            dwKeySpec,
            dwCertEncodingType,
            SignedInfo.ToBeSigned.pbData,
            SignedInfo.ToBeSigned.cbData,
            &SignedInfo.SignatureAlgorithm,
            pvHashAuxInfo,
            NULL,                   // pbSignature
            &SignedInfo.Signature.cbData
            );
    if (SignedInfo.Signature.cbData == 0) goto ErrorReturn;
    SignedInfo.Signature.pbData =
        (BYTE *) PkiNonzeroAlloc(SignedInfo.Signature.cbData);
    if (SignedInfo.Signature.pbData == NULL) goto ErrorReturn;
    if (pbEncoded) {
        if (!CryptSignCertificate(
                hCryptProv,
                dwKeySpec,
                dwCertEncodingType,
                SignedInfo.ToBeSigned.pbData,
                SignedInfo.ToBeSigned.cbData,
                &SignedInfo.SignatureAlgorithm,
                pvHashAuxInfo,
                SignedInfo.Signature.pbData,
                &SignedInfo.Signature.cbData
                )) goto ErrorReturn;
    }

    fResult = CryptEncodeObject(
            dwCertEncodingType,
            X509_CERT,
            &SignedInfo,
            pbEncoded,
            pcbEncoded
            );
    if (!fResult && *pcbEncoded) {
        *pcbEncoded += AdjustForMaximumEncodedSignatureLength(
            &SignedInfo.SignatureAlgorithm,
            SignedInfo.Signature.cbData
            );
    }

CommonReturn:
    PkiFree(SignedInfo.ToBeSigned.pbData);
    PkiFree(SignedInfo.Signature.pbData);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    *pcbEncoded = 0;
    goto CommonReturn;
}


//+-------------------------------------------------------------------------
//  Verify the time validity of a certificate.
//
//  Returns -1 if before NotBefore, +1 if after NotAfter and otherwise 0 for
//  a valid certificate
//
//  If pTimeToVerify is NULL, uses the current time.
//--------------------------------------------------------------------------
LONG
WINAPI
CertVerifyTimeValidity(
    IN LPFILETIME pTimeToVerify,
    IN PCERT_INFO pCertInfo
    )
{
    SYSTEMTIME SystemTime;
    FILETIME FileTime;
    LPFILETIME pFileTime;

    if (pTimeToVerify)
        pFileTime = pTimeToVerify;
    else {
        GetSystemTime(&SystemTime);
        SystemTimeToFileTime(&SystemTime, &FileTime);
        pFileTime = &FileTime;
    }

    if (CompareFileTime(pFileTime, &pCertInfo->NotBefore) < 0)
        return -1;
    else if (CompareFileTime(pFileTime, &pCertInfo->NotAfter) > 0)
        return 1;
    else
        return 0;
}

#ifdef CAPI_INCLUDE_CRL
//+-------------------------------------------------------------------------
//  Verify the time validity of a CRL.
//
//  Returns -1 if before ThisUpdate, +1 if after NextUpdate and otherwise 0 for
//  a valid CRL
//
//  If pTimeToVerify is NULL, uses the current time.
//--------------------------------------------------------------------------
LONG
WINAPI
CertVerifyCRLTimeValidity(
    IN LPFILETIME pTimeToVerify,
    IN PCRL_INFO pCrlInfo
    )
{
    SYSTEMTIME SystemTime;
    FILETIME FileTime;
    LPFILETIME pFileTime;

    if (pTimeToVerify)
        pFileTime = pTimeToVerify;
    else {
        GetSystemTime(&SystemTime);
        SystemTimeToFileTime(&SystemTime, &FileTime);
        pFileTime = &FileTime;
    }

    // Note, NextUpdate is optional. When not present, set to 0
    if (CompareFileTime(pFileTime, &pCrlInfo->ThisUpdate) < 0)
        return -1;
    else if ((pCrlInfo->NextUpdate.dwLowDateTime ||
                pCrlInfo->NextUpdate.dwHighDateTime) &&
            CompareFileTime(pFileTime, &pCrlInfo->NextUpdate) > 0)
        return 1;
    else
        return 0;
}
#endif //CAPI_INCLUDE_CRL

//+-------------------------------------------------------------------------
//  Verify that the subject's time validity nests within the issuer's time
//  validity.
//
//  Returns TRUE if it nests. Otherwise, returns FALSE.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertVerifyValidityNesting(
    IN PCERT_INFO pSubjectInfo,
    IN PCERT_INFO pIssuerInfo
    )
{
    if ((CompareFileTime(&pSubjectInfo->NotBefore,
                &pIssuerInfo->NotBefore) >= 0) &&
            (CompareFileTime(&pSubjectInfo->NotAfter,
                &pIssuerInfo->NotAfter) <= 0))
        return TRUE;
    else
        return FALSE;
}

#ifdef CAPI_INCLUDE_CRL

//+-------------------------------------------------------------------------
//  Verify that the subject certificate isn't on its issuer CRL.
//
//  Returns true if the certificate isn't on the CRL.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertVerifyCRLRevocation(
    IN DWORD dwCertEncodingType,
    IN PCERT_INFO pCertId,          // Only the Issuer and SerialNumber
                                    // fields are used
    IN DWORD cCrlInfo,
    IN PCRL_INFO rgpCrlInfo[]
    )
{
    DWORD InfoIdx;

    for (InfoIdx = 0; InfoIdx < cCrlInfo; InfoIdx++) {
        DWORD cEntry = rgpCrlInfo[InfoIdx]->cCRLEntry;
        PCRL_ENTRY rgEntry = rgpCrlInfo[InfoIdx]->rgCRLEntry;
        DWORD EntryIdx;

        for (EntryIdx = 0; EntryIdx < cEntry; EntryIdx++) {
            if (CertCompareIntegerBlob(&rgEntry[EntryIdx].SerialNumber,
                    &pCertId->SerialNumber))
                // It has been revoked!!!
                return FALSE;
        }
    }

    return TRUE;
}
#endif //CAPI_INCLUDE_CRL
//+-------------------------------------------------------------------------
//  Convert the CAPI AlgId to the ASN.1 Object Identifier string
//
//  Returns NULL if there isn't an ObjId corresponding to the AlgId.
//--------------------------------------------------------------------------
LPCSTR
WINAPI
CertAlgIdToOID(
    IN DWORD dwAlgId
    )
{
    DWORD dwGroupId;

    for (dwGroupId = CRYPT_FIRST_ALG_OID_GROUP_ID;
            dwGroupId <= CRYPT_LAST_ALG_OID_GROUP_ID; dwGroupId++) {
        PCCRYPT_OID_INFO pInfo;
        if (pInfo = CryptFindOIDInfo(
                CRYPT_OID_INFO_ALGID_KEY,
                &dwAlgId,
                dwGroupId
                ))
            return pInfo->pszOID;
    }
    return NULL;
}

//+-------------------------------------------------------------------------
//  Convert the ASN.1 Object Identifier string to the CAPI AlgId.
//
//  Returns 0 if there isn't an AlgId corresponding to the ObjId.
//--------------------------------------------------------------------------
DWORD
WINAPI
CertOIDToAlgId(
    IN LPCSTR pszObjId
    )
{
    DWORD dwGroupId;

    for (dwGroupId = CRYPT_FIRST_ALG_OID_GROUP_ID;
            dwGroupId <= CRYPT_LAST_ALG_OID_GROUP_ID; dwGroupId++) {
        PCCRYPT_OID_INFO pInfo;
        if (pInfo = CryptFindOIDInfo(
                CRYPT_OID_INFO_OID_KEY,
                (void *) pszObjId,
                dwGroupId
                ))
            return pInfo->Algid;
    }
    return 0;
}

//+-------------------------------------------------------------------------
//  Find an extension identified by its Object Identifier.
//
//  If found, returns pointer to the extension. Otherwise, returns NULL.
//--------------------------------------------------------------------------
PCERT_EXTENSION
WINAPI
CertFindExtension(
    IN LPCSTR pszObjId,
    IN DWORD cExtensions,
    IN CERT_EXTENSION rgExtensions[]
    )
{
    for (; cExtensions > 0; cExtensions--, rgExtensions++) {
        if (strcmp(pszObjId, rgExtensions->pszObjId) == 0)
            return rgExtensions;
    }
    return NULL;
}

//+-------------------------------------------------------------------------
//  Find the first attribute identified by its Object Identifier.
//
//  If found, returns pointer to the attribute. Otherwise, returns NULL.
//--------------------------------------------------------------------------
PCRYPT_ATTRIBUTE
WINAPI
CertFindAttribute(
    IN LPCSTR pszObjId,
    IN DWORD cAttr,
    IN CRYPT_ATTRIBUTE rgAttr[]
    )
{
    for (; cAttr > 0; cAttr--, rgAttr++) {
        if (strcmp(pszObjId, rgAttr->pszObjId) == 0)
            return rgAttr;
    }
    return NULL;
}

//+-------------------------------------------------------------------------
//  Find the first CERT_RDN attribute identified by its Object Identifier in
//  the name's list of Relative Distinguished Names.
//
//  If found, returns pointer to the attribute. Otherwise, returns NULL.
//--------------------------------------------------------------------------
PCERT_RDN_ATTR
WINAPI
CertFindRDNAttr(
    IN LPCSTR pszObjId,
    IN PCERT_NAME_INFO pName
    )
{
    DWORD cRDN = pName->cRDN;
    PCERT_RDN pRDN = pName->rgRDN;
    for ( ; cRDN > 0; cRDN--, pRDN++) {
        DWORD cRDNAttr = pRDN->cRDNAttr;
        PCERT_RDN_ATTR pRDNAttr = pRDN->rgRDNAttr;
        for (; cRDNAttr > 0; cRDNAttr--, pRDNAttr++) {
            if (strcmp(pszObjId, pRDNAttr->pszObjId) == 0)
                return pRDNAttr;
        }
    }
    return NULL;
}

//+-------------------------------------------------------------------------
//  Get the intended key usage bytes from the certificate.
//
//  If the certificate doesn't have any intended key usage bytes, returns FALSE
//  and *pbKeyUsage is zeroed. Otherwise, returns TRUE and up through
//  cbKeyUsage bytes are copied into *pbKeyUsage. Any remaining uncopied
//  bytes are zeroed.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertGetIntendedKeyUsage(
    IN DWORD dwCertEncodingType,
    IN PCERT_INFO pCertInfo,
    OUT BYTE *pbKeyUsage,
    IN DWORD cbKeyUsage
    )
{
    BOOL fResult;
    DWORD cbData;
    PCERT_EXTENSION pExt;
    PCERT_KEY_ATTRIBUTES_INFO pKeyAttrInfo = NULL;
    PCRYPT_BIT_BLOB pAllocKeyUsage = NULL;
    PCRYPT_BIT_BLOB pKeyUsage = NULL;          // not allocated

    // First see if the certificate has the simple Key Usage Extension
    if (NULL != (pExt = CertFindExtension(
            szOID_KEY_USAGE,
            pCertInfo->cExtension,
            pCertInfo->rgExtension
            ))  &&
        NULL != (pAllocKeyUsage =
            (PCRYPT_BIT_BLOB) AllocAndDecodeObject(
                dwCertEncodingType,
                X509_KEY_USAGE,
                pExt->Value.pbData,
                pExt->Value.cbData
                )))
        pKeyUsage = pAllocKeyUsage;
    else {
        pExt = CertFindExtension(
                szOID_KEY_ATTRIBUTES,
                pCertInfo->cExtension,
                pCertInfo->rgExtension
                );
        if (pExt == NULL) goto GetError;
    
        if (NULL == (pKeyAttrInfo =
            (PCERT_KEY_ATTRIBUTES_INFO) AllocAndDecodeObject(
                dwCertEncodingType,
                X509_KEY_ATTRIBUTES,
                pExt->Value.pbData,
                pExt->Value.cbData
                ))) goto ErrorReturn;
        pKeyUsage = &pKeyAttrInfo->IntendedKeyUsage;
    }

    if (pKeyUsage->cbData == 0 || cbKeyUsage == 0)
        goto GetError;

    cbData = min(pKeyUsage->cbData, cbKeyUsage);
    memcpy(pbKeyUsage, pKeyUsage->pbData, cbData);
    fResult = TRUE;
    goto CommonReturn;

GetError:
    SetLastError(0);
ErrorReturn:
    fResult = FALSE;
    cbData = 0;
CommonReturn:
    PkiFree(pAllocKeyUsage);
    PkiFree(pKeyAttrInfo);
    if (cbData < cbKeyUsage)
        memset(pbKeyUsage + cbData, 0, cbKeyUsage - cbData);
    return fResult;
}

static DWORD GetYPublicKeyLength(
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pPublicKeyInfo
    )
{
    PCRYPT_UINT_BLOB pY = NULL;
    DWORD dwBitLen;

    if (NULL == (pY = (PCRYPT_UINT_BLOB) AllocAndDecodeObject(
            dwCertEncodingType,
            X509_MULTI_BYTE_UINT,
            pPublicKeyInfo->PublicKey.pbData,
            pPublicKeyInfo->PublicKey.cbData
            ))) goto DecodePubKeyError;

    dwBitLen = pY->cbData * 8;

CommonReturn:
    PkiFree(pY);
    return dwBitLen;
ErrorReturn:
    dwBitLen = 0;
    goto CommonReturn;

TRACE_ERROR(DecodePubKeyError)
}

// If there are parameters, use the length of the 'P' parameter. Otherwise,
// use the length of Y. Note, P's MSB must be set. Y's MSB may not be set.
static DWORD GetDHPublicKeyLength(
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pPublicKey
    )
{
    PCERT_DH_PARAMETERS pDhParameters = NULL;
    DWORD dwBitLen;

    if (0 == pPublicKey->Algorithm.Parameters.cbData)
        goto NoDhParametersError;
    if (NULL == (pDhParameters = (PCERT_DH_PARAMETERS) AllocAndDecodeObject(
            dwCertEncodingType,
            X509_DH_PARAMETERS,
            pPublicKey->Algorithm.Parameters.pbData,
            pPublicKey->Algorithm.Parameters.cbData
            ))) goto DecodeParametersError;

    dwBitLen = pDhParameters->p.cbData * 8;

CommonReturn:
    PkiFree(pDhParameters);
    return dwBitLen;
ErrorReturn:
    dwBitLen = GetYPublicKeyLength(dwCertEncodingType, pPublicKey);
    goto CommonReturn;

TRACE_ERROR(NoDhParametersError)
TRACE_ERROR(DecodeParametersError)
}

// If there are parameters, use the length of the 'P' parameter. Otherwise,
// use the length of Y. Note, P's MSB must be set. Y's MSB may not be set.
static DWORD GetDSSPublicKeyLength(
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pPublicKey
    )
{
    PCERT_DSS_PARAMETERS pDssParameters = NULL;
    DWORD dwBitLen;

    if (0 == pPublicKey->Algorithm.Parameters.cbData)
        goto NoDssParametersError;
    if (NULL == (pDssParameters = (PCERT_DSS_PARAMETERS) AllocAndDecodeObject(
            dwCertEncodingType,
            X509_DSS_PARAMETERS,
            pPublicKey->Algorithm.Parameters.pbData,
            pPublicKey->Algorithm.Parameters.cbData
            ))) goto DecodeParametersError;

    dwBitLen = pDssParameters->p.cbData * 8;

CommonReturn:
    PkiFree(pDssParameters);
    return dwBitLen;
ErrorReturn:
    dwBitLen = GetYPublicKeyLength(dwCertEncodingType, pPublicKey);
    goto CommonReturn;

TRACE_ERROR(NoDssParametersError)
TRACE_ERROR(DecodeParametersError)
}

//+-------------------------------------------------------------------------
//  Get the public/private key's bit length.
//
//  Returns 0 if unable to determine the key's length.
//--------------------------------------------------------------------------
DWORD
WINAPI
CertGetPublicKeyLength(
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pPublicKey
    )
{
    DWORD dwErr = 0;
    DWORD dwBitLen;
    ALG_ID aiPubKey;
    PCCRYPT_OID_INFO pOIDInfo;
    HCRYPTPROV hCryptProv;          // don't need to release
    HCRYPTKEY hPubKey = 0;
    DWORD cbData;

    if (pOIDInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            pPublicKey->Algorithm.pszObjId,
            CRYPT_PUBKEY_ALG_OID_GROUP_ID))
        aiPubKey = pOIDInfo->Algid;
    else
        aiPubKey = 0;

    if (aiPubKey == CALG_DH_SF || aiPubKey == CALG_DH_EPHEM)
        return GetDHPublicKeyLength(
            dwCertEncodingType,
            pPublicKey
            );

    if (aiPubKey == CALG_DSS_SIGN)
        return GetDSSPublicKeyLength(
            dwCertEncodingType,
            pPublicKey
            );

    if (0 == (hCryptProv = I_CryptGetDefaultCryptProv(aiPubKey)))
        goto GetDefaultCryptProvError;
    if (!CryptImportPublicKeyInfo(
            hCryptProv,
            dwCertEncodingType,
            pPublicKey,
            &hPubKey
            )) goto ImportPublicKeyError;

    cbData = sizeof(dwBitLen);
    if (CryptGetKeyParam(
            hPubKey,
            KP_KEYLEN,
            (BYTE *) &dwBitLen,
            &cbData,
            0))                 // dwFlags
        goto CommonReturn;

    cbData = sizeof(dwBitLen);
    if (CryptGetKeyParam(
            hPubKey,
            KP_BLOCKLEN,
            (BYTE *) &dwBitLen,
            &cbData,
            0))                 // dwFlags
        goto CommonReturn;


    {
        // BUGBUG:: the CSP should have supported one of the above

        // Export the public key and look at the bitlen field.
        // The CAPI public key representation consists of the following
        //  sequence:
        //  - PUBLICKEYSTRUC
        //  - DSSPUBKEY | RSAPUBKEY (DSSPUBKEY is subset of RSAPUBKEY)
        //  ...

        BYTE *pbPubKey = NULL;
        DWORD cbPubKey;

        dwBitLen = 0;
        dwErr = GetLastError();
        cbPubKey = 0;
        if (CryptExportKey(
                    hPubKey,
                    0,              // hPubKey
                    PUBLICKEYBLOB,
                    0,              // dwFlags
                    NULL,           // pbData
                    &cbPubKey
                    ) &&
                cbPubKey >= (sizeof(PUBLICKEYSTRUC) + sizeof(DSSPUBKEY)) &&
                NULL != (pbPubKey = (BYTE *) PkiNonzeroAlloc(cbPubKey))) {
            if (CryptExportKey(
                    hPubKey,
                    0,              // hPubKey
                    PUBLICKEYBLOB,
                    0,              // dwFlags
                    pbPubKey,
                    &cbPubKey
                    )) {
                DSSPUBKEY *pPubKey =
                    (DSSPUBKEY *) (pbPubKey + sizeof(PUBLICKEYSTRUC));
                dwBitLen = pPubKey->bitlen;
            }
            PkiFree(pbPubKey);
        }
        if (0 != dwBitLen)
            goto CommonReturn;
        SetLastError(dwErr);
        goto GetKeyParamError;
    }

CommonReturn:
    if (hPubKey)
        CryptDestroyKey(hPubKey);
    SetLastError(dwErr);
    return dwBitLen;
ErrorReturn:
    dwBitLen = 0;
    dwErr = GetLastError();
    goto CommonReturn;
TRACE_ERROR(GetDefaultCryptProvError)
TRACE_ERROR(ImportPublicKeyError)
TRACE_ERROR(GetKeyParamError)
}

//+-------------------------------------------------------------------------
//  Compute the hash of the encoded public key info.
//
//  The public key info is encoded and then hashed.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptHashPublicKeyInfo(
    IN HCRYPTPROV hCryptProv,
    IN ALG_ID Algid,
    IN DWORD dwFlags,
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pInfo,
    OUT BYTE *pbComputedHash,
    IN OUT DWORD *pcbComputedHash
    )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    if (!AllocAndEncodeObject(
            dwCertEncodingType,
            X509_PUBLIC_KEY_INFO,
            pInfo,
            &pbEncoded,
            &cbEncoded
            ))
        goto ErrorReturn;

    fResult = CryptHashCertificate(
            hCryptProv,
            Algid ? Algid : CALG_MD5,
            dwFlags,
            pbEncoded,
            cbEncoded,
            pbComputedHash,
            pcbComputedHash
            );
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
    *pcbComputedHash = 0;
    
CommonReturn:
    PkiFree(pbEncoded);
    return fResult;
}



//+-------------------------------------------------------------------------
//  Compares the certificate's public key with the provider's public key
//  to see if they are identical.
//
//  Returns TRUE if the keys are identical.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertCompareCertAndProviderPublicKey(
    IN PCCERT_CONTEXT pCert,
    IN HCRYPTPROV hProv,
    IN DWORD dwKeySpec
    )
{
    BOOL fResult;
    PCERT_PUBLIC_KEY_INFO pProvPubKeyInfo = NULL;
    DWORD cbProvPubKeyInfo;
    DWORD dwCertEncodingType = pCert->dwCertEncodingType;

    // Get provider's public key
    if (!CryptExportPublicKeyInfo(
            hProv,
            dwKeySpec,
            dwCertEncodingType,
            NULL,               // pProvPubKeyInfo
            &cbProvPubKeyInfo
            ))
        goto ExportPublicKeyInfoError;
    assert(cbProvPubKeyInfo);
    if (NULL == (pProvPubKeyInfo = (PCERT_PUBLIC_KEY_INFO) PkiNonzeroAlloc(
            cbProvPubKeyInfo)))
        goto OutOfMemory;
    if (!CryptExportPublicKeyInfo(
            hProv,
            dwKeySpec,
            dwCertEncodingType,
            pProvPubKeyInfo,
            &cbProvPubKeyInfo
            ))
        goto ExportPublicKeyInfoError;

    if (!CertComparePublicKeyInfo(
            dwCertEncodingType,
            &pCert->pCertInfo->SubjectPublicKeyInfo,
            pProvPubKeyInfo
            ))
        goto ComparePublicKeyError;

    fResult = TRUE;
CommonReturn:
    PkiFree(pProvPubKeyInfo);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(ExportPublicKeyInfoError)
TRACE_ERROR(OutOfMemory)
SET_ERROR(ComparePublicKeyError, NTE_BAD_PUBLIC_KEY)
}

//+=========================================================================
//  CryptFindCertificateKeyProvInfo Support Functions
//-=========================================================================
static BOOL HasValidKeyProvInfo(
    IN PCCERT_CONTEXT pCert,
    IN DWORD dwFindKeySetFlags
    )
{
    BOOL fResult;
    PCRYPT_KEY_PROV_INFO pKeyProvInfo = NULL;
    HCRYPTPROV hProv = 0;
    DWORD cbData;

    if (!CertGetCertificateContextProperty(
            pCert,
            CERT_KEY_PROV_INFO_PROP_ID,
            NULL,                       // pvData
            &cbData
            ))
        return FALSE;
    if (NULL == (pKeyProvInfo = (PCRYPT_KEY_PROV_INFO) PkiNonzeroAlloc(
            cbData)))
        goto OutOfMemory;
    if (!CertGetCertificateContextProperty(
            pCert,
            CERT_KEY_PROV_INFO_PROP_ID,
            pKeyProvInfo,
            &cbData
            ))
        goto GetKeyProvInfoPropertyError;

    if (pKeyProvInfo->dwFlags & CRYPT_MACHINE_KEYSET) {
        if (0 == (dwFindKeySetFlags & CRYPT_FIND_MACHINE_KEYSET_FLAG))
            goto NotUserContainer;
    } else {
        if (0 == (dwFindKeySetFlags & CRYPT_FIND_USER_KEYSET_FLAG))
            goto NotMachineContainer;
    }

    if (!CryptAcquireCertificatePrivateKey(
            pCert,
            CRYPT_ACQUIRE_COMPARE_KEY_FLAG,
            NULL,                   // pvReserved
            &hProv,
            NULL,                   // pdwKeySpec
            NULL                    // pfCallerFreeProv
            ))
        goto AcquireCertPrivateKeyError;

    fResult = TRUE;
CommonReturn:
    PkiFree(pKeyProvInfo);
    if (hProv) {
        DWORD dwErr = GetLastError();
        CryptReleaseContext(hProv, 0);
        SetLastError(dwErr);
    }
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
TRACE_ERROR(GetKeyProvInfoPropertyError)
SET_ERROR(NotUserContainer, NTE_NOT_FOUND)
SET_ERROR(NotMachineContainer, NTE_NOT_FOUND)
TRACE_ERROR(AcquireCertPrivateKeyError)
}


// Default to Algid being supported. Only return FALSE if successfully
// enumerated all the provider algorithms and didn't find a match.
static BOOL IsPublicKeyAlgidSupported(
    IN PCCERT_CONTEXT pCert,
    IN HCRYPTPROV hProv,
    IN ALG_ID aiPubKey
    )
{
    BOOL fResult;
    DWORD dwErr;
    BYTE *pbData = NULL;
    DWORD cbMaxData;
    DWORD cbData;
    DWORD dwFlags;

    if (0 == aiPubKey)
        return TRUE;

    // Get maximum length of provider algorithm parameter data
    cbMaxData = 0;
    if (!CryptGetProvParam(
            hProv,
            PP_ENUMALGS,
            NULL,           // pbData
            &cbMaxData,
            CRYPT_FIRST     // dwFlags
            )) {
        dwErr = GetLastError();
        if (ERROR_MORE_DATA != dwErr)
            goto GetProvAlgParamError;
    }
    if (0 == cbMaxData)
        goto NoProvAlgParamError;
    if (NULL == (pbData = (BYTE *) PkiNonzeroAlloc(cbMaxData)))
        goto OutOfMemory;

    dwFlags = CRYPT_FIRST;
    while (TRUE) {
        ALG_ID aiProv;

        cbData = cbMaxData;
        if (!CryptGetProvParam(
                hProv,
                PP_ENUMALGS,
                pbData,
                &cbData,
                dwFlags
                )) {
            dwErr = GetLastError();
            if (ERROR_NO_MORE_ITEMS == dwErr) {
                fResult = FALSE;
                goto PublicKeyAlgidNotSupported;
            } else
                goto GetProvAlgParamError;
        }
        assert(cbData >= sizeof(ALG_ID));
        aiProv = *(ALG_ID *) pbData;
        // Don't distinguish between exchange or signature
        if (GET_ALG_TYPE(aiPubKey) == GET_ALG_TYPE(aiProv))
            break;

        dwFlags = 0;    // CRYPT_NEXT
    }
    fResult = TRUE;

PublicKeyAlgidNotSupported:
CommonReturn:
    PkiFree(pbData);
    return fResult;
ErrorReturn:
    // For an error, assume the public key algorithm is supported.
    fResult = TRUE;
    goto CommonReturn;

SET_ERROR_VAR(GetProvAlgParamError, dwErr)
SET_ERROR(NoProvAlgParamError, NTE_NOT_FOUND)
TRACE_ERROR(OutOfMemory)
}

// For success, updates the certificate's KEY_PROV_INFO property
//
// If container isn't found, LastError is set to ERROR_NO_MORE_ITEMS.
static BOOL FindContainerAndSetKeyProvInfo(
    IN PCCERT_CONTEXT pCert,
    IN HCRYPTPROV hProv,
    IN LPWSTR pwszProvName,
    IN DWORD dwProvType,
    IN DWORD dwProvFlags
    )
{
    BOOL fResult;
    DWORD dwEnumFlags;
    DWORD dwEnumErr = 0;
    DWORD dwAcquireErr = 0;
    LPSTR pszContainerName = NULL;
    DWORD cchContainerName;
    DWORD cchMaxContainerName;
    LPWSTR pwszContainerName = NULL;

    // Get maximum container name length
    cchMaxContainerName = 0;
    if (!CryptGetProvParam(
            hProv,
            PP_ENUMCONTAINERS,
            NULL,           // pbData
            &cchMaxContainerName,
            CRYPT_FIRST
            )) {
        dwEnumErr = GetLastError();
        if (ERROR_FILE_NOT_FOUND == dwEnumErr ||
                ERROR_INVALID_PARAMETER == dwEnumErr)
            goto PublicKeyContainerNotFound;
        else if (ERROR_MORE_DATA != dwEnumErr)
            goto EnumContainersError;
    }
    if (0 == cchMaxContainerName)
        goto PublicKeyContainerNotFound;
	// On Windows CE, the container name is returned as LPWSTR
	// Also, the length is incorrectly returned in WCHARs instead of bytes
	cchMaxContainerName *= sizeof(TCHAR);
	
	if (NULL == (pszContainerName = (LPSTR) PkiNonzeroAlloc(
            cchMaxContainerName + 1)))	
        goto OutOfMemory;

    dwEnumFlags = CRYPT_FIRST;
    while (TRUE) {
        DWORD dwErr;
        HCRYPTPROV hContainerProv;
        LPWSTR pwszAcquireProvName = pwszProvName;

        cchContainerName = cchMaxContainerName;
        if (!CryptGetProvParam(
                hProv,
                PP_ENUMCONTAINERS,
                (BYTE *) pszContainerName,
                &cchContainerName,
                dwEnumFlags
                )) {
            dwEnumErr = GetLastError();
            if (ERROR_NO_MORE_ITEMS == dwEnumErr ||
                    ERROR_FILE_NOT_FOUND == dwEnumErr) {
                if (0 != dwAcquireErr)
                    goto CryptAcquireContextError;
                else
                    goto PublicKeyContainerNotFound;
            } else
                goto EnumContainersError;
        }
        dwEnumFlags = 0;        // CRYPT_NEXT

#ifndef CE_BUILD
        if (NULL == (pwszContainerName = MkWStr(pszContainerName)))
            goto OutOfMemory;
#else
		pwszContainerName = (LPWSTR)pszContainerName;
#endif		

        fResult = CryptAcquireContextU(
                &hContainerProv,
                pwszContainerName,
                pwszAcquireProvName,
                dwProvType,
                dwProvFlags
                );
        if (!fResult) {
            dwErr = GetLastError();
            if (PROV_RSA_FULL == dwProvType &&
                    0 == _wcsicmp(pwszProvName, MS_DEF_PROV_W)) {
                // Try again using the enhanced provider
                pwszAcquireProvName = MS_ENHANCED_PROV_W;
                fResult = CryptAcquireContextU(
                        &hContainerProv,
                        pwszContainerName,
                        pwszAcquireProvName,
                        dwProvType,
                        dwProvFlags
                        );
            }
        }

        if (!fResult)
            dwAcquireErr = dwErr;
        else {
            DWORD dwKeySpec;

            dwKeySpec = AT_KEYEXCHANGE;
            fResult = FALSE;
            while (TRUE) {
                if (I_CertCompareCertAndProviderPublicKey(
                        pCert,
                        hContainerProv,
                        dwKeySpec
                        )) {
                    fResult = TRUE;
                    break;
                } else if (AT_SIGNATURE == dwKeySpec)
                    break;
                else
                    dwKeySpec = AT_SIGNATURE;
            }
            CryptReleaseContext(hContainerProv, 0);

            if (fResult) {
                CRYPT_KEY_PROV_INFO KeyProvInfo;

                memset(&KeyProvInfo, 0, sizeof(KeyProvInfo));
                KeyProvInfo.pwszContainerName = pwszContainerName;
                KeyProvInfo.pwszProvName = pwszAcquireProvName;
                KeyProvInfo.dwProvType = dwProvType;
                KeyProvInfo.dwFlags = dwProvFlags;
                KeyProvInfo.dwKeySpec = dwKeySpec;

                if (!CertSetCertificateContextProperty(
                        pCert,
                        CERT_KEY_PROV_INFO_PROP_ID,
                        0,                              // dwFlags
                        &KeyProvInfo
                        ))
                    goto SetKeyProvInfoPropertyError;
                else
                    goto SuccessReturn;
            }
        }

#ifndef CE_BUILD
        FreeWStr(pwszContainerName);
#endif        
        pwszContainerName = NULL;
    }

    goto UnexpectedError;

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    PkiFree(pszContainerName);
#ifndef CE_BUILD    
    FreeWStr(pwszContainerName);
#endif    
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR_VAR(EnumContainersError, dwEnumErr)
TRACE_ERROR(OutOfMemory)
SET_ERROR_VAR(CryptAcquireContextError, dwAcquireErr)
SET_ERROR(PublicKeyContainerNotFound, ERROR_NO_MORE_ITEMS)
TRACE_ERROR(SetKeyProvInfoPropertyError)
SET_ERROR(UnexpectedError, E_UNEXPECTED)
}


static BOOL AcquireContextForEnumeration(
    HCRYPTPROV *phProv,
    LPCWSTR pwszProvName,
    DWORD dwProvType,
    BOOL fIsMachineKeySet) 
{
	BOOL fResult;
	DWORD dwFlags = fIsMachineKeySet ? CRYPT_MACHINE_KEYSET : 0;
#ifdef CE_BUILD
	// VERIFY_KEYSET cannot be used with CryptEnumKeyContainers on Windows CE
	// so use a persistent store, creating one if necessary
	fResult = CryptAcquireContextU(
                phProv,
                NULL,               // pwszContainerName,
                pwszProvName,
                dwProvType,
                dwFlags
                );
    if (!fResult && GetLastError() == NTE_BAD_KEYSET)
    {
		fResult = CryptAcquireContextU(
                phProv,
                NULL,               // pwszContainerName,
                pwszProvName,
                dwProvType,
                dwFlags | CRYPT_NEWKEYSET
                );
    }
#else
	fResult = CryptAcquireContextU(
                phProv,
                NULL,               // pwszContainerName,
                pwszProvName,
                dwProvType,
                dwFlags | CRYPT_VERIFYCONTEXT;
                );

#endif
	return fResult;
}
			
//+-------------------------------------------------------------------------
//  Enumerates the cryptographic providers and their containers to find the
//  private key corresponding to the certificate's public key. For a match,
//  the certificate's CERT_KEY_PROV_INFO_PROP_ID property is updated.
//
//  If the CERT_KEY_PROV_INFO_PROP_ID is already set, then, its checked to
//  see if it matches the provider's public key. For a match, the above
//  enumeration is skipped.
//
//  By default both the user and machine key containers are searched.
//  The CRYPT_FIND_USER_KEYSET_FLAG or CRYPT_FIND_MACHINE_KEYSET_FLAG
//  can be set in dwFlags to restrict the search to either of the containers.
//
//  If a container isn't found, returns FALSE with LastError set to
//  NTE_NO_KEY.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptFindCertificateKeyProvInfo(
    IN PCCERT_CONTEXT pCert,
    IN DWORD dwFlags,
    IN void *pvReserved
    )
{
    BOOL fResult;
    DWORD dwFindContainerErr = ERROR_NO_MORE_ITEMS;
    DWORD dwAcquireErr = 0;
    DWORD dwProvIndex;
    PCCRYPT_OID_INFO pOIDInfo;
    ALG_ID aiPubKey;

    if (0 == (dwFlags &
            (CRYPT_FIND_USER_KEYSET_FLAG | CRYPT_FIND_MACHINE_KEYSET_FLAG)))
        dwFlags |=
            CRYPT_FIND_USER_KEYSET_FLAG | CRYPT_FIND_MACHINE_KEYSET_FLAG;

    if (HasValidKeyProvInfo(pCert, dwFlags))
        return TRUE;

    if (pOIDInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId,
            CRYPT_PUBKEY_ALG_OID_GROUP_ID
            ))
        aiPubKey = pOIDInfo->Algid;
    else
        aiPubKey = 0;
    

    for (dwProvIndex = 0; TRUE; dwProvIndex++) {
        LPWSTR pwszProvName;
        DWORD cbProvName;
        HCRYPTPROV hProv;
        DWORD dwProvType;

        cbProvName = 0;
        dwProvType = 0;
        if (!CryptEnumProvidersU(
                dwProvIndex,
                NULL,               // pdwReserved
                0,                  // dwFlags
                &dwProvType,
                NULL,               // pwszProvName,
                &cbProvName
                ) || 0 == cbProvName) {
            if (0 == dwProvIndex)
                goto EnumProvidersError;
            else if (ERROR_NO_MORE_ITEMS != dwFindContainerErr)
                goto FindContainerError;
            else if (0 != dwAcquireErr)
                goto CryptAcquireContextError;
            else
                goto KeyContainerNotFound;
        }
        if (NULL == (pwszProvName = (LPWSTR) PkiNonzeroAlloc(
                (cbProvName + 1) * sizeof(WCHAR))))
            goto OutOfMemory;
        if (!CryptEnumProvidersU(
                dwProvIndex,
                NULL,               // pdwReserved
                0,                  // dwFlags
                &dwProvType,
                pwszProvName,
                &cbProvName
                )) {
            PkiFree(pwszProvName);
            goto EnumProvidersError;
        }

        fResult = FALSE;
        if (!AcquireContextForEnumeration(
                &hProv,
                pwszProvName,
                dwProvType,
                FALSE // fMachineKeySet
                )) {
            dwAcquireErr = GetLastError();
            hProv = 0;   // CAPI bug, sets hCryptProv to nonzero
        } else if (IsPublicKeyAlgidSupported(
                pCert,
                hProv,
                aiPubKey
                )) {
            if (dwFlags & CRYPT_FIND_USER_KEYSET_FLAG) {
                if (FindContainerAndSetKeyProvInfo(
                        pCert,
                        hProv,
                        pwszProvName,
                        dwProvType,
                        0                       // dwProvFlags
                        ))
                    fResult = TRUE;
                else if (ERROR_NO_MORE_ITEMS == dwFindContainerErr)
                    dwFindContainerErr = GetLastError();
            }

            if (!fResult && (dwFlags & CRYPT_FIND_MACHINE_KEYSET_FLAG)) {
                CryptReleaseContext(hProv, 0);

                if (!AcquireContextForEnumeration(
                        &hProv,
                        pwszProvName,
                        dwProvType,
                        TRUE  // fMachineKeySet
                        )) {
                    dwAcquireErr = GetLastError();
                    hProv = 0;   // CAPI bug, sets hCryptProv to nonzero
                } else {
                    if (FindContainerAndSetKeyProvInfo(
                            pCert,
                            hProv,
                            pwszProvName,
                            dwProvType,
                            CRYPT_MACHINE_KEYSET    // dwProvFlags
                            ))
                        fResult = TRUE;
                    else if (ERROR_NO_MORE_ITEMS == dwFindContainerErr)
                        dwFindContainerErr = GetLastError();
                }
            }
        }

        if (hProv)
            CryptReleaseContext(hProv, 0);
        PkiFree(pwszProvName);
        if (fResult)
            goto CommonReturn;
    }

    goto UnexpectedError;

CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(EnumProvidersError)
SET_ERROR(KeyContainerNotFound, NTE_NO_KEY)
SET_ERROR_VAR(FindContainerError, dwFindContainerErr)
SET_ERROR_VAR(CryptAcquireContextError, dwAcquireErr)
TRACE_ERROR(OutOfMemory)
SET_ERROR(UnexpectedError, E_UNEXPECTED)
}



//+=========================================================================
//  CryptCreatePublicKeyInfo, EncodePublicKeyAndParameters
//  and CryptConvertPublicKeyInfo functions
//-=========================================================================

static BOOL EncodePublicKeyInfo(
    IN LPCSTR pszPubKeyOID,
    IN BYTE *pbEncodedPubKey,
    IN DWORD cbEncodedPubKey,
    IN BYTE *pbEncodedParameters,
    IN DWORD cbEncodedParameters,
    OUT PCERT_PUBLIC_KEY_INFO pInfo,
    IN OUT DWORD *pcbInfo
    )
{
    BOOL fResult;
    BYTE *pbExtra;
    LONG lRemainExtra;
    DWORD cbOID;

    if (pInfo == NULL)
        *pcbInfo = 0;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lRemainExtra = (LONG) *pcbInfo - sizeof(CERT_PUBLIC_KEY_INFO);
    if (lRemainExtra < 0)
        pbExtra = NULL;
    else
        pbExtra = (BYTE *) pInfo + sizeof(CERT_PUBLIC_KEY_INFO);

    cbOID = strlen(pszPubKeyOID) + 1;
    lRemainExtra -= INFO_LEN_ALIGN(cbOID) +
        INFO_LEN_ALIGN(cbEncodedParameters) + cbEncodedPubKey;
    if (lRemainExtra >= 0) {
        memset(pInfo, 0, sizeof(CERT_PUBLIC_KEY_INFO));
        pInfo->Algorithm.pszObjId = (LPSTR) pbExtra;
        memcpy(pbExtra, pszPubKeyOID, cbOID);
        pbExtra += INFO_LEN_ALIGN(cbOID);
        if (cbEncodedParameters) {
            pInfo->Algorithm.Parameters.cbData = cbEncodedParameters;
            pInfo->Algorithm.Parameters.pbData = pbExtra;
            memcpy(pbExtra, pbEncodedParameters, cbEncodedParameters);
            pbExtra += INFO_LEN_ALIGN(cbEncodedParameters);
        }

        pInfo->PublicKey.pbData = pbExtra;
        pInfo->PublicKey.cbData = cbEncodedPubKey;
        memcpy(pbExtra, pbEncodedPubKey, cbEncodedPubKey);

        *pcbInfo = *pcbInfo - (DWORD) lRemainExtra;
    } else {
        *pcbInfo = *pcbInfo + (DWORD) -lRemainExtra;
        if (pInfo) goto LengthError;
    }
    fResult = TRUE;

CommonReturn:
    return fResult;

LengthError:
    SetLastError((DWORD) ERROR_MORE_DATA);
    fResult = FALSE;
    goto CommonReturn;
}

//  By default, the pPubKeyStruc->aiKeyAlg is used to find the appropriate
//  public key Object Identifier. pszPubKeyOID can be set to override
//  the default OID obtained from the aiKeyAlg.
BOOL
WINAPI
CryptCreatePublicKeyInfo(
    IN DWORD dwCertEncodingType,
    IN OPTIONAL LPCSTR pszPubKeyOID,
    IN const PUBLICKEYSTRUC *pPubKeyStruc,
    IN DWORD cbPubKeyStruc,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT void *pvPubKeyInfo,
    IN OUT DWORD *pcbPubKeyInfo
    )
{
    BOOL fResult;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr;
    LPCSTR pszEncodePubKeyOID;

    BYTE *pbEncodedPubKey = NULL;
    DWORD cbEncodedPubKey = 0;
    BYTE *pbEncodedParameters = NULL;
    DWORD cbEncodedParameters = 0;

    PCERT_PUBLIC_KEY_INFO pPubKeyInfo = NULL;
    DWORD cbPubKeyInfo;

    if (NULL == pszPubKeyOID) {
        PCCRYPT_OID_INFO pInfo;
        if (NULL == (pInfo = CryptFindOIDInfo(
                CRYPT_OID_INFO_ALGID_KEY,
                (void *) &pPubKeyStruc->aiKeyAlg,
                CRYPT_PUBKEY_ALG_OID_GROUP_ID
                )))
            goto NoPubKeyOIDInfo;
         pszEncodePubKeyOID = pInfo->pszOID;
    } else
        pszEncodePubKeyOID = pszPubKeyOID;

    if (!CryptGetOIDFunctionAddress(
            hEncodePubKeyFuncSet,
            dwCertEncodingType,
            pszEncodePubKeyOID,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr)) {
        PCCRYPT_OID_INFO pInfo;

        if (NULL == pszPubKeyOID)
            goto NoEncodePubKeyFunction;

        if (NULL == (pInfo = CryptFindOIDInfo(
                CRYPT_OID_INFO_ALGID_KEY,
                (void *) &pPubKeyStruc->aiKeyAlg,
                CRYPT_PUBKEY_ALG_OID_GROUP_ID
                )))
            goto NoPubKeyOIDInfo;
         pszEncodePubKeyOID = pInfo->pszOID;

        if (!CryptGetOIDFunctionAddress(
                hEncodePubKeyFuncSet,
                dwCertEncodingType,
                pszEncodePubKeyOID,
                0,                      // dwFlags
                &pvFuncAddr,
                &hFuncAddr))
            goto NoEncodePubKeyFunction;
    }

    if (NULL == pszPubKeyOID)
        pszPubKeyOID = pszEncodePubKeyOID;

    fResult = ((PFN_CRYPT_ENCODE_PUBLIC_KEY_AND_PARAMETERS) pvFuncAddr)(
        dwCertEncodingType,
        pszPubKeyOID,
        pPubKeyStruc,
        cbPubKeyStruc,
        dwFlags,
        pvReserved,
        &pbEncodedPubKey,
        &cbEncodedPubKey,
        &pbEncodedParameters,
        &cbEncodedParameters
        );
    CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    if (!fResult)
        goto EncodePubKeyAndParametersError;

    if (dwFlags & CRYPT_ALLOC_FLAG) {
        if (!EncodePublicKeyInfo(
                pszPubKeyOID,
                pbEncodedPubKey,
                cbEncodedPubKey,
                pbEncodedParameters,
                cbEncodedParameters,
                NULL,                   // pPubKeyInfo
                &cbPubKeyInfo
                ))
            goto EncodePublicKeyInfoError;
        if (NULL == (pPubKeyInfo =
                (PCERT_PUBLIC_KEY_INFO) PkiDefaultCryptAlloc(cbPubKeyInfo)))
            goto OutOfMemory;
        *((PCERT_PUBLIC_KEY_INFO *) pvPubKeyInfo) = pPubKeyInfo;
    } else {
        pPubKeyInfo = (PCERT_PUBLIC_KEY_INFO) pvPubKeyInfo;
        cbPubKeyInfo = *pcbPubKeyInfo;
    }

    fResult = EncodePublicKeyInfo(
        pszPubKeyOID,
        pbEncodedPubKey,
        cbEncodedPubKey,
        pbEncodedParameters,
        cbEncodedParameters,
        pPubKeyInfo,
        &cbPubKeyInfo
        );

    if (!fResult && (dwFlags & CRYPT_ALLOC_FLAG))
        goto ErrorReturn;

CommonReturn:
    PkiDefaultCryptFree(pbEncodedPubKey);
    PkiDefaultCryptFree(pbEncodedParameters);

    *pcbPubKeyInfo = cbPubKeyInfo;
    return fResult;
ErrorReturn:
    if (dwFlags & CRYPT_ALLOC_FLAG) {
        PkiDefaultCryptFree(pPubKeyInfo);
        *((void **) pvPubKeyInfo) = NULL;
    }
    cbPubKeyInfo = 0;
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(NoPubKeyOIDInfo, ERROR_FILE_NOT_FOUND)
TRACE_ERROR(NoEncodePubKeyFunction)
TRACE_ERROR(EncodePubKeyAndParametersError)
TRACE_ERROR(EncodePublicKeyInfoError)
TRACE_ERROR(OutOfMemory)
}

BOOL
WINAPI
CryptConvertPublicKeyInfo(
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pPubKeyInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT void *pvPubKeyStruc,
    IN OUT DWORD *pcbPubKeyStruc
    )
{
    BOOL fResult;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr;

    if (CryptGetOIDFunctionAddress(
            hConvertPubKeyFuncSet,
            dwCertEncodingType,
            pPubKeyInfo->Algorithm.pszObjId,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr)) {
        fResult = ((PFN_CRYPT_CONVERT_PUBLIC_KEY_INFO) pvFuncAddr)(
            dwCertEncodingType,
            pPubKeyInfo,
            dwFlags,
            pvReserved,
            pvPubKeyStruc,
            pcbPubKeyStruc
            );
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    } else {
        ALG_ID aiPubKey;
        PCCRYPT_OID_INFO pOIDInfo;

        if (pOIDInfo = CryptFindOIDInfo(
                CRYPT_OID_INFO_OID_KEY,
                pPubKeyInfo->Algorithm.pszObjId,
                CRYPT_PUBKEY_ALG_OID_GROUP_ID
                ))
            aiPubKey = pOIDInfo->Algid;
        else
            aiPubKey = 0;

        switch (aiPubKey) {
            case CALG_DSS_SIGN:
                fResult = ConvertDSSPublicKeyInfo(
                    dwCertEncodingType,
                    pPubKeyInfo,
                    dwFlags,
                    pvReserved,
                    pvPubKeyStruc,
                    pcbPubKeyStruc
                    );
                break;
            default:
                // Attempt to decode as a PKCS #1 RSA public key
                fResult = ConvertRSAPublicKeyInfo(
                    dwCertEncodingType,
                    pPubKeyInfo,
                    dwFlags,
                    pvReserved,
                    pvPubKeyStruc,
                    pcbPubKeyStruc
                    );
                break;
        }
    }
    return fResult;
}

//+-------------------------------------------------------------------------
//  Encode the RSA public key and parameters
//--------------------------------------------------------------------------
static BOOL WINAPI EncodeRSAPublicKeyAndParameters(
    IN DWORD dwCertEncodingType,
    IN OPTIONAL LPCSTR pszPubKeyOID,
    IN const PUBLICKEYSTRUC *pPubKeyStruc,
    IN DWORD cbPubKeyStruc,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT BYTE **ppbEncodedPubKey,
    OUT DWORD *pcbEncodedPubKey,
    OUT BYTE **ppbEncodedParameters,
    OUT DWORD *pcbEncodedParameters
    )
{
    *ppbEncodedParameters = NULL;
    *pcbEncodedParameters = 0;

    return CryptEncodeObjectEx(
        dwCertEncodingType,
        RSA_CSP_PUBLICKEYBLOB,
        pPubKeyStruc,
        CRYPT_ENCODE_ALLOC_FLAG,
        NULL,                       // pEncodePara
        (void *) ppbEncodedPubKey,
        pcbEncodedPubKey
        );
}

//+-------------------------------------------------------------------------
//  Convert as an RSA public key
//--------------------------------------------------------------------------
static BOOL WINAPI ConvertRSAPublicKeyInfo(
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pPubKeyInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT void *pvPubKeyStruc,
    IN OUT DWORD *pcbPubKeyStruc
    )
{
    return CryptDecodeObjectEx(
        dwCertEncodingType,
        RSA_CSP_PUBLICKEYBLOB,
        pPubKeyInfo->PublicKey.pbData,
        pPubKeyInfo->PublicKey.cbData,
        (dwFlags & CRYPT_ALLOC_FLAG) ? CRYPT_DECODE_ALLOC_FLAG : 0,
        NULL,                               // pDecodePara,
        pvPubKeyStruc,
        pcbPubKeyStruc
        );
}

#ifndef DSS1
#define DSS1 ((DWORD)'D'+((DWORD)'S'<<8)+((DWORD)'S'<<16)+((DWORD)'1'<<24))
#endif

#define DSS_Q_LEN   20

//+-------------------------------------------------------------------------
//  Encode the DSS public key and parameters
//--------------------------------------------------------------------------
static BOOL WINAPI EncodeDSSPublicKeyAndParameters(
    IN DWORD dwCertEncodingType,
    IN OPTIONAL LPCSTR pszPubKeyOID,
    IN const PUBLICKEYSTRUC *pPubKeyStruc,
    IN DWORD cbPubKeyStruc,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT BYTE **ppbEncodedPubKey,
    OUT DWORD *pcbEncodedPubKey,
    OUT BYTE **ppbEncodedParameters,
    OUT DWORD *pcbEncodedParameters
    )
{
    BOOL fResult;
    BYTE *pbKeyBlob;
    DSSPUBKEY *pCspPubKey;
    DWORD cbKey;
    BYTE *pbKey;

    CERT_DSS_PARAMETERS DssParameters;
    CRYPT_UINT_BLOB DssPubKey;

    *ppbEncodedPubKey = NULL;
    *ppbEncodedParameters = NULL;

    // The CAPI public key representation consists of the following sequence:
    //  - PUBLICKEYSTRUC
    //  - DSSPUBKEY
    //  - rgbP[cbKey]
    //  - rgbQ[20]
    //  - rgbG[cbKey]
    //  - rgbY[cbKey]
    //  - DSSSEED
    pbKeyBlob = (BYTE *) pPubKeyStruc;
    pCspPubKey = (DSSPUBKEY *) (pbKeyBlob + sizeof(PUBLICKEYSTRUC));
    pbKey = pbKeyBlob + sizeof(PUBLICKEYSTRUC) + sizeof(DSSPUBKEY);
    cbKey = pCspPubKey->bitlen / 8;

    assert(cbKey > 0);
    assert(cbPubKeyStruc >= sizeof(PUBLICKEYSTRUC) + sizeof(DSSPUBKEY) +
        cbKey + DSS_Q_LEN + cbKey + cbKey + sizeof(DSSSEED));
    assert(pPubKeyStruc->bType == PUBLICKEYBLOB);
    assert(pPubKeyStruc->bVersion == CUR_BLOB_VERSION);
    assert(pPubKeyStruc->aiKeyAlg == CALG_DSS_SIGN);
    assert(pCspPubKey->magic == DSS1);
    assert(pCspPubKey->bitlen % 8 == 0);

    if (pPubKeyStruc->bType != PUBLICKEYBLOB)
        goto InvalidArg;

    // Initialize DSS parameters from CSP data structure
    DssParameters.p.cbData = cbKey;
    DssParameters.p.pbData = pbKey;
    pbKey += cbKey;
    DssParameters.q.cbData = DSS_Q_LEN;
    DssParameters.q.pbData = pbKey;
    pbKey += DSS_Q_LEN;
    DssParameters.g.cbData = cbKey;
    DssParameters.g.pbData = pbKey;
    pbKey += cbKey;

    // Initialize DSS public key from CSP data structure
    DssPubKey.cbData = cbKey;
    DssPubKey.pbData = pbKey;

    // Encode the parameters and public key
    if (!CryptEncodeObjectEx(
            dwCertEncodingType,
            X509_DSS_PARAMETERS,
            &DssParameters,
            CRYPT_ENCODE_ALLOC_FLAG,
            NULL,                       // pEncodePara
            (void *) ppbEncodedParameters,
            pcbEncodedParameters
            )) goto ErrorReturn;

    if (!CryptEncodeObjectEx(
            dwCertEncodingType,
            X509_DSS_PUBLICKEY,
            &DssPubKey,
            CRYPT_ENCODE_ALLOC_FLAG,
            NULL,                       // pEncodePara
            (void *) ppbEncodedPubKey,
            pcbEncodedPubKey
            )) goto ErrorReturn;

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    PkiDefaultCryptFree(*ppbEncodedParameters);
    PkiDefaultCryptFree(*ppbEncodedPubKey);
    *ppbEncodedParameters = NULL;
    *ppbEncodedPubKey = NULL;
    *pcbEncodedParameters = 0;
    *pcbEncodedPubKey = 0;
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidArg, E_INVALIDARG)
}

//+-------------------------------------------------------------------------
//  Convert as an DSS public key
//--------------------------------------------------------------------------
static BOOL WINAPI ConvertDSSPublicKeyInfo(
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pPubKeyInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT void *pvPubKeyStruc,
    IN OUT DWORD *pcbPubKeyStruc
    )
{
    BOOL fResult;
    PCERT_DSS_PARAMETERS pDssParameters = NULL;
    PCRYPT_UINT_BLOB pDssPubKey = NULL;
    PUBLICKEYSTRUC *pPubKeyStruc = NULL;
    DWORD cbPubKeyStruc;
    BYTE *pbKeyBlob;
    DSSPUBKEY *pCspPubKey;
    DSSSEED *pCspSeed;
    DWORD cbKey;
    BYTE *pbKey;
    DWORD cb;

    if (0 == pPubKeyInfo->Algorithm.Parameters.cbData ||
            NULL_ASN_TAG == *pPubKeyInfo->Algorithm.Parameters.pbData)
        goto NoDssParametersError;
    if (NULL == (pDssParameters = (PCERT_DSS_PARAMETERS) AllocAndDecodeObject(
            dwCertEncodingType,
            X509_DSS_PARAMETERS,
            pPubKeyInfo->Algorithm.Parameters.pbData,
            pPubKeyInfo->Algorithm.Parameters.cbData
            ))) goto DecodeParametersError;

    if (NULL == (pDssPubKey = (PCRYPT_UINT_BLOB) AllocAndDecodeObject(
            dwCertEncodingType,
            X509_DSS_PUBLICKEY,
            pPubKeyInfo->PublicKey.pbData,
            pPubKeyInfo->PublicKey.cbData
            ))) goto DecodePubKeyError;

    // The CAPI public key representation consists of the following sequence:
    //  - PUBLICKEYSTRUC
    //  - DSSPUBKEY
    //  - rgbP[cbKey]
    //  - rgbQ[20]
    //  - rgbG[cbKey]
    //  - rgbY[cbKey]
    //  - DSSSEED

    cbKey = pDssParameters->p.cbData;
    if (0 == cbKey)
        goto InvalidDssParametersError;

    cbPubKeyStruc = sizeof(PUBLICKEYSTRUC) + sizeof(DSSPUBKEY) +
        cbKey + DSS_Q_LEN + cbKey + cbKey + sizeof(DSSSEED);

    if (dwFlags & CRYPT_ALLOC_FLAG) {
        if (NULL == (pPubKeyStruc =
                (PUBLICKEYSTRUC *) PkiDefaultCryptAlloc(cbPubKeyStruc)))
            goto OutOfMemory;
        *((PUBLICKEYSTRUC **) pvPubKeyStruc) = pPubKeyStruc;
    } else
        pPubKeyStruc = (PUBLICKEYSTRUC *) pvPubKeyStruc;

    fResult = TRUE;
    if (pPubKeyStruc) {
        if (0 == (dwFlags & CRYPT_ALLOC_FLAG) &&
                *pcbPubKeyStruc < cbPubKeyStruc) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fResult = FALSE;
        } else {
            pbKeyBlob = (BYTE *) pPubKeyStruc;
            pCspPubKey = (DSSPUBKEY *) (pbKeyBlob + sizeof(PUBLICKEYSTRUC));
            pbKey = pbKeyBlob + sizeof(PUBLICKEYSTRUC) + sizeof(DSSPUBKEY);

            // NOTE, the length of G and Y can be less than the length of P.
            // The CSP requires G and Y to be padded out with 0x00 bytes if it
            // is less and in little endian form
            
            // PUBLICKEYSTRUC
            pPubKeyStruc->bType = PUBLICKEYBLOB;
            pPubKeyStruc->bVersion = CUR_BLOB_VERSION;
            pPubKeyStruc->reserved = 0;
            pPubKeyStruc->aiKeyAlg = CALG_DSS_SIGN;
            // DSSPUBKEY
            pCspPubKey->magic = DSS1;
            pCspPubKey->bitlen = cbKey * 8;

            // rgbP[cbKey]
            memcpy(pbKey, pDssParameters->p.pbData, cbKey);
            pbKey += cbKey;

            // rgbQ[20]
            cb = pDssParameters->q.cbData;
            if (0 == cb || cb > DSS_Q_LEN)
                goto InvalidDssParametersError;
            memcpy(pbKey, pDssParameters->q.pbData, cb);
            if (DSS_Q_LEN > cb)
                memset(pbKey + cb, 0, DSS_Q_LEN - cb);
            pbKey += DSS_Q_LEN;

            // rgbG[cbKey]
            cb = pDssParameters->g.cbData;
            if (0 == cb || cb > cbKey)
                goto InvalidDssParametersError;
            memcpy(pbKey, pDssParameters->g.pbData, cb);
            if (cbKey > cb)
                memset(pbKey + cb, 0, cbKey - cb);
            pbKey += cbKey;

            // rgbY[cbKey]
            cb = pDssPubKey->cbData;
            if (0 == cb || cb > cbKey)
                goto InvalidDssPubKeyError;
            memcpy(pbKey, pDssPubKey->pbData, cb);
            if (cbKey > cb)
                memset(pbKey + cb, 0, cbKey - cb);
            pbKey += cbKey;

            // DSSSEED: set counter to 0xFFFFFFFF to indicate not available
            pCspSeed = (DSSSEED *) pbKey;
            memset(&pCspSeed->counter, 0xFF, sizeof(pCspSeed->counter));
        }
    }

CommonReturn:
    *pcbPubKeyStruc = cbPubKeyStruc;
    PkiFree(pDssParameters);
    PkiFree(pDssPubKey);
    return fResult;
            
ErrorReturn:
    if (dwFlags & CRYPT_ALLOC_FLAG) {
        PkiDefaultCryptFree(pPubKeyStruc);
        *((PUBLICKEYSTRUC **) pvPubKeyStruc) = NULL;
    }
    cbPubKeyStruc = 0;
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(DecodeParametersError)
TRACE_ERROR(DecodePubKeyError)
#ifdef CMS_PKCS7
SET_ERROR(NoDssParametersError, CRYPT_E_MISSING_PUBKEY_PARA)
#else
SET_ERROR(NoDssParametersError, E_INVALIDARG)
#endif  // CMS_PKCS7
SET_ERROR(InvalidDssParametersError, E_INVALIDARG)
SET_ERROR(InvalidDssPubKeyError, E_INVALIDARG)
}

#ifndef DH3
#define DH3 (((DWORD)'D'<<8)+((DWORD)'H'<<16)+((DWORD)'3'<<24))
#endif

//+-------------------------------------------------------------------------
//  Encode the DH public key and parameters
//--------------------------------------------------------------------------
static BOOL WINAPI EncodeDHPublicKeyAndParameters(
    IN DWORD dwCertEncodingType,
    IN OPTIONAL LPCSTR pszPubKeyOID,
    IN const PUBLICKEYSTRUC *pPubKeyStruc,
    IN DWORD cbPubKeyStruc,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT BYTE **ppbEncodedPubKey,
    OUT DWORD *pcbEncodedPubKey,
    OUT BYTE **ppbEncodedParameters,
    OUT DWORD *pcbEncodedParameters
    )
{
    BOOL fResult;
    BYTE *pbKeyBlob;
    DHPUBKEY *pCspPubKey;
    DWORD cbKey;
    BYTE *pbKey;

    CERT_DH_PARAMETERS DhParameters;
    CRYPT_UINT_BLOB DhPubKey;

    *ppbEncodedPubKey = NULL;
    *ppbEncodedParameters = NULL;

    // The CAPI public key representation consists of the following sequence:
    //  - PUBLICKEYSTRUC
    //  - DHPUBKEY
    //  - rgbY[cbKey]
    //  - rgbP[cbKey]
    //  - rgbG[cbKey]
    pbKeyBlob = (BYTE *) pPubKeyStruc;
    pCspPubKey = (DHPUBKEY *) (pbKeyBlob + sizeof(PUBLICKEYSTRUC));
    pbKey = pbKeyBlob + sizeof(PUBLICKEYSTRUC) + sizeof(DHPUBKEY);
    cbKey = pCspPubKey->bitlen / 8;

    if (cbPubKeyStruc < sizeof(PUBLICKEYSTRUC) + sizeof(DHPUBKEY) +
            cbKey * 3)
        goto InvalidArg;
    if (pPubKeyStruc->bType != PUBLICKEYBLOB)
        goto InvalidArg;
    if (pCspPubKey->magic != DH3)
        goto InvalidArg;

    assert(cbKey > 0);
    assert(cbPubKeyStruc >= sizeof(PUBLICKEYSTRUC) + sizeof(DHPUBKEY) +
        cbKey * 3);
    assert(pPubKeyStruc->bType == PUBLICKEYBLOB);
    assert(pPubKeyStruc->bVersion == CUR_BLOB_VERSION);
    assert(pPubKeyStruc->aiKeyAlg == CALG_DH_SF ||
        pPubKeyStruc->aiKeyAlg == CALG_DH_EPHEM);
    assert(pCspPubKey->magic == DH3);
    assert(pCspPubKey->bitlen % 8 == 0);

    // Initialize DH public key from CSP data structure
    DhPubKey.cbData = cbKey;
    DhPubKey.pbData = pbKey;

    // Initialize the P and G parameters from CSP data structure
    pbKey += cbKey;
    DhParameters.p.pbData = pbKey;
    DhParameters.p.cbData = cbKey;
    pbKey += cbKey;
    DhParameters.g.pbData = pbKey;
    DhParameters.g.cbData = cbKey;

    // Encode the parameters and public key
    if (!CryptEncodeObjectEx(
            dwCertEncodingType,
            X509_DH_PARAMETERS,
            &DhParameters,
            CRYPT_ENCODE_ALLOC_FLAG,
            NULL,                       // pEncodePara
            (void *) ppbEncodedParameters,
            pcbEncodedParameters
            )) goto ErrorReturn;

    if (!CryptEncodeObjectEx(
            dwCertEncodingType,
            X509_DH_PUBLICKEY,
            &DhPubKey,
            CRYPT_ENCODE_ALLOC_FLAG,
            NULL,                       // pEncodePara
            (void *) ppbEncodedPubKey,
            pcbEncodedPubKey
            )) goto ErrorReturn;

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    PkiDefaultCryptFree(*ppbEncodedParameters);
    PkiDefaultCryptFree(*ppbEncodedPubKey);
    *ppbEncodedParameters = NULL;
    *ppbEncodedPubKey = NULL;
    *pcbEncodedParameters = 0;
    *pcbEncodedPubKey = 0;
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidArg, E_INVALIDARG)
}

#ifndef DH1
#define DH1 (((DWORD)'D'<<8)+((DWORD)'H'<<16)+((DWORD)'1'<<24))
#endif

// The old DH1 PublicKey Blob didn't include the P and G parameters.
// 
// For a DH1 PublicKey Blob, convert to a DH3 PublicKeyBlob by getting
// the P and G parameters from the hPubKey (via CryptGetKeyParam) and
// append to the DH1 PublicKey Blob.
static BOOL AppendDHParametersToPublicKeyStruc(
    IN HCRYPTKEY hPubKey,
    IN OUT PUBLICKEYSTRUC **ppPubKeyStruc,
    IN OUT DWORD *pcbPubKeyStruc
    )
{
    BOOL fResult;
    PUBLICKEYSTRUC *pPubKeyStruc = *ppPubKeyStruc;
    BYTE *pbKeyBlob;
    DHPUBKEY *pCspPubKey;
    DWORD cbKey;
    BYTE *pbKey;

    PUBLICKEYSTRUC *pNewPubKeyStruc = NULL;
    DWORD cbNewPubKeyStruc;
    DWORD cbData;

    // The CAPI public key representation consists of the following sequence:
    //  - PUBLICKEYSTRUC
    //  - DHPUBKEY
    //  - rgbY[cbKey]
    pbKeyBlob = (BYTE *) pPubKeyStruc;
    pCspPubKey = (DHPUBKEY *) (pbKeyBlob + sizeof(PUBLICKEYSTRUC));
    if (pCspPubKey->magic != DH1)
        return TRUE;

    pCspPubKey->magic = DH3;
    cbKey = pCspPubKey->bitlen / 8;
    cbNewPubKeyStruc = *pcbPubKeyStruc + cbKey * 2;

    if (NULL == (pNewPubKeyStruc = (PUBLICKEYSTRUC *) PkiRealloc(pPubKeyStruc,
            cbNewPubKeyStruc)))
        goto OutOfMemory;

    pbKeyBlob = (BYTE *) pNewPubKeyStruc;
    pbKey = pbKeyBlob + *pcbPubKeyStruc;

    // Get the P and G parameters from the public key
    cbData = cbKey;
    if (!CryptGetKeyParam(
            hPubKey,
            KP_P,
            pbKey,
            &cbData,
            0                   // dwFlags
            ) || cbData != cbKey)
        goto GetPError;

    pbKey += cbKey;
    cbData = cbKey;
    if (!CryptGetKeyParam(
            hPubKey,
            KP_G,
            pbKey,
            &cbData,
            0                   // dwFlags
            ) || cbData != cbKey)
        goto GetGError;

    *ppPubKeyStruc = pNewPubKeyStruc;
    *pcbPubKeyStruc = cbNewPubKeyStruc;
    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    PkiFree(pNewPubKeyStruc);
    goto CommonReturn;
    fResult = FALSE;
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(GetPError)
TRACE_ERROR(GetGError)
}

//+=========================================================================
//  CryptExportPublicKeyInfo functions
//-=========================================================================

//+-------------------------------------------------------------------------
//  Use the aiKeyAlg in the public key structure exported by the CSP to
//  determine how to encode the public key.
//
//  The dwFlags and pvAuxInfo aren't used.
//--------------------------------------------------------------------------
static BOOL WINAPI ExportCspPublicKeyInfoEx(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwKeySpec,
    IN DWORD dwCertEncodingType,
    IN OPTIONAL LPSTR pszPublicKeyObjId,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvAuxInfo,
    OUT PCERT_PUBLIC_KEY_INFO pInfo,
    IN OUT DWORD *pcbInfo
    )
{
    BOOL fResult;
    DWORD dwErr;
    HCRYPTKEY hPubKey = 0;
    PUBLICKEYSTRUC *pPubKeyStruc = NULL;
    DWORD cbPubKeyStruc;

    if (!CryptGetUserKey(
            hCryptProv,
            dwKeySpec,
            &hPubKey
            )) {
        hPubKey = 0;
        goto GetUserKeyError;
    }

    cbPubKeyStruc = 0;
    if (!CryptExportKey(
            hPubKey,
            0,              // hPubKey
            PUBLICKEYBLOB,
            0,              // dwFlags
            NULL,           // pbData
            &cbPubKeyStruc
            ) || (cbPubKeyStruc == 0))
        goto ExportPublicKeyBlobError;
    if (NULL == (pPubKeyStruc = (PUBLICKEYSTRUC *) PkiNonzeroAlloc(
            cbPubKeyStruc)))
        goto OutOfMemory;
    if (!CryptExportKey(
            hPubKey,
            0,              // hPubKey
            PUBLICKEYBLOB,
            0,              // dwFlags
            (BYTE *) pPubKeyStruc,
            &cbPubKeyStruc
            ))
        goto ExportPublicKeyBlobError;

    if (CALG_DH_SF == pPubKeyStruc->aiKeyAlg ||
            CALG_DH_EPHEM == pPubKeyStruc->aiKeyAlg) {
        // For DH1 convert to DH3 by getting and appending the P and G
        // parameters
        if (!AppendDHParametersToPublicKeyStruc(
                hPubKey,
                &pPubKeyStruc,
                &cbPubKeyStruc
                ))
            goto AppendDHParametersError;
    }

    fResult = CryptCreatePublicKeyInfo(
        dwCertEncodingType,
        pszPublicKeyObjId,
        pPubKeyStruc,
        cbPubKeyStruc,
        0,                      // dwFlags
        NULL,                   // pvAuxInfo
        pInfo,
        pcbInfo
        );

CommonReturn:
    dwErr = GetLastError();
    if (hPubKey)
        CryptDestroyKey(hPubKey);
    PkiFree(pPubKeyStruc);
    SetLastError(dwErr);
    return fResult;

ErrorReturn:
    *pcbInfo = 0;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetUserKeyError)
TRACE_ERROR(ExportPublicKeyBlobError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(AppendDHParametersError)
}

//+-------------------------------------------------------------------------
//  Export the public key info associated with the provider's corresponding
//  private key.
//
//  Uses the dwCertEncodingType and pszPublicKeyObjId to call the
//  installable CRYPT_OID_EXPORT_PUBLIC_KEY_INFO_FUNC. The called function
//  has the same signature as CryptExportPublicKeyInfoEx.
//
//  If unable to find an installable OID function for the pszPublicKeyObjId,
//  attempts to export via the default export function.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptExportPublicKeyInfoEx(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwKeySpec,
    IN DWORD dwCertEncodingType,
    IN OPTIONAL LPSTR pszPublicKeyObjId,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvAuxInfo,
    OUT PCERT_PUBLIC_KEY_INFO pInfo,
    IN OUT DWORD *pcbInfo
    )
{
    BOOL fResult;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr;

    if (pszPublicKeyObjId && CryptGetOIDFunctionAddress(
            hExportPubKeyFuncSet,
            dwCertEncodingType,
            pszPublicKeyObjId,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr)) {
        fResult = ((PFN_EXPORT_PUB_KEY_FUNC) pvFuncAddr)(
            hCryptProv,
            dwKeySpec,
            dwCertEncodingType,
            pszPublicKeyObjId,
            dwFlags,
            pvAuxInfo,
            pInfo,
            pcbInfo
            );
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    } else
        // Attempt to export via the default function that looks at the
        // public key algorithm in the public key struc exported by the CSP.
        fResult = ExportCspPublicKeyInfoEx(
            hCryptProv,
            dwKeySpec,
            dwCertEncodingType,
            pszPublicKeyObjId,
            dwFlags,
            pvAuxInfo,
            pInfo,
            pcbInfo
            );
    return fResult;
}

//+-------------------------------------------------------------------------
//  Export the public key info associated with the provider's corresponding
//  private key.
//
//  Calls CryptExportPublicKeyInfo with pszPublicKeyObjId = NULL,
//  dwFlags = 0 and pvAuxInfo = NULL.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptExportPublicKeyInfo(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwKeySpec,
    IN DWORD dwCertEncodingType,
    OUT PCERT_PUBLIC_KEY_INFO pInfo,
    IN OUT DWORD *pcbInfo
    )
{
    return CryptExportPublicKeyInfoEx(
        hCryptProv,
        dwKeySpec,
        dwCertEncodingType,
        NULL,                           // pszPublicKeyObjId
        0,                              // dwFlags
        NULL,                           // pvAuxInfo
        pInfo,
        pcbInfo
        );
}

//+=========================================================================
//  CryptImportPublicKeyInfo functions
//-=========================================================================

//+-------------------------------------------------------------------------
//  Convert and import the public key info into the provider and return a
//  handle to the public key.
//
//  Uses the dwCertEncodingType and pInfo->Algorithm.pszObjId to call the
//  installable CRYPT_OID_IMPORT_PUBLIC_KEY_INFO_FUNC. The called function
//  has the same signature as CryptImportPublicKeyInfoEx.
//
//  If unable to find an installable OID function for the pszObjId,
//  decodes the PublicKeyInfo into a CSP PublicKey Blob and imports.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptImportPublicKeyInfoEx(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pInfo,
    IN ALG_ID aiKeyAlg,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvAuxInfo,
    OUT HCRYPTKEY *phKey
    )
{
    BOOL fResult;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr;
    PUBLICKEYSTRUC *pPubKeyStruc = NULL;
    DWORD cbPubKeyStruc;

    if (CryptGetOIDFunctionAddress(
            hImportPubKeyFuncSet,
            dwCertEncodingType,
            pInfo->Algorithm.pszObjId,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr)) {
        fResult = ((PFN_IMPORT_PUB_KEY_FUNC) pvFuncAddr)(
            hCryptProv,
            dwCertEncodingType,
            pInfo,
            aiKeyAlg,
            dwFlags,
            pvAuxInfo,
            phKey
            );
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    } else {
        if (!CryptConvertPublicKeyInfo(
                dwCertEncodingType,
                pInfo,
                CRYPT_ALLOC_FLAG,
                NULL,                   // pvReserved
                (void *) &pPubKeyStruc,
                &cbPubKeyStruc
                ))
            goto ConvertPublicKeyInfoError;

        if (aiKeyAlg)
            pPubKeyStruc->aiKeyAlg = aiKeyAlg;

        if (!CryptImportKey(
                hCryptProv,
                (BYTE *) pPubKeyStruc,
                cbPubKeyStruc,
                NULL,           // hImpKey
                0,              // dwFlags
                phKey
                ))
            goto ImportKeyError;
        fResult = TRUE;
    }

CommonReturn:
    PkiDefaultCryptFree(pPubKeyStruc);
    return fResult;
ErrorReturn:
    *phKey = NULL;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(ConvertPublicKeyInfoError)
TRACE_ERROR(ImportKeyError)
}

//+-------------------------------------------------------------------------
//  Convert and import the public key info into the provider and return a
//  handle to the public key.
//
//  Calls CryptImportPublicKeyInfoEx with aiKeyAlg = 0, dwFlags = 0 and
//  pvAuxInfo = NULL.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptImportPublicKeyInfo(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwCertEncodingType,
    IN PCERT_PUBLIC_KEY_INFO pInfo,
    OUT HCRYPTKEY *phKey
    )
{
    return CryptImportPublicKeyInfoEx(
        hCryptProv,
        dwCertEncodingType,
        pInfo,
        0,                      // aiKeyAlg
        0,                      // dwFlags
        NULL,                   // pvAuxInfo
        phKey
        );
}

//+-------------------------------------------------------------------------
//  Create a KeyIdentifier from the CSP Public Key Blob.
//
//  Converts the CSP PUBLICKEYSTRUC into a X.509 CERT_PUBLIC_KEY_INFO and
//  encodes. The encoded CERT_PUBLIC_KEY_INFO is SHA1 hashed to obtain
//  the Key Identifier.
//
//  By default, the pPubKeyStruc->aiKeyAlg is used to find the appropriate
//  public key Object Identifier. pszPubKeyOID can be set to override
//  the default OID obtained from the aiKeyAlg.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptCreateKeyIdentifierFromCSP(
    IN DWORD dwCertEncodingType,
    IN OPTIONAL LPCSTR pszPubKeyOID,
    IN const PUBLICKEYSTRUC *pPubKeyStruc,
    IN DWORD cbPubKeyStruc,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT BYTE *pbHash,
    IN OUT DWORD *pcbHash
    )
{
    BOOL fResult;
    PCERT_PUBLIC_KEY_INFO pInfo = NULL;
    DWORD cbInfo;

    if (!CryptCreatePublicKeyInfo(
            dwCertEncodingType,
            pszPubKeyOID,
            pPubKeyStruc,
            cbPubKeyStruc,
            CRYPT_ALLOC_FLAG,
            NULL,                   // pvReserved
            (void *) &pInfo,
            &cbInfo
            ))
        goto CreatePublicKeyInfoError;

    fResult = CryptHashPublicKeyInfo(
            NULL,                   // hCryptProv
            CALG_SHA1,
            0,                      // dwFlags
            dwCertEncodingType,
            pInfo,
            pbHash,
            pcbHash
            );

CommonReturn:
    PkiDefaultCryptFree(pInfo);
    return fResult;

ErrorReturn:
    *pcbHash = 0;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(CreatePublicKeyInfoError)
}


//+=========================================================================
//  DefaultContext APIs and Data Structures
//-=========================================================================

static BOOL InstallThreadDefaultContext(
    IN PDEFAULT_CONTEXT pDefaultContext
    )
{
    PDEFAULT_CONTEXT pNext;
    pNext = (PDEFAULT_CONTEXT) I_CryptGetTls(hTlsDefaultContext);
    if (pNext) {
        pDefaultContext->pNext = pNext;
        pNext->pPrev = pDefaultContext;
    }

    fHasThreadDefaultContext = TRUE;
    return I_CryptSetTls(hTlsDefaultContext, pDefaultContext);
}

static BOOL InstallProcessDefaultContext(
    IN PDEFAULT_CONTEXT pDefaultContext
    )
{
    EnterCriticalSection(&DefaultContextCriticalSection);

    if (pProcessDefaultContextHead) {
        pDefaultContext->pNext = pProcessDefaultContextHead;
        pProcessDefaultContextHead->pPrev = pDefaultContext;
    }
    pProcessDefaultContextHead = pDefaultContext;

    fHasProcessDefaultContext = TRUE;

    LeaveCriticalSection(&DefaultContextCriticalSection);

    return TRUE;
}

//+-------------------------------------------------------------------------
//  Install a previously CryptAcquiredContext'ed HCRYPTPROV to be used as
//  a default context.
//
//  dwDefaultType and pvDefaultPara specify where the default context is used.
//  For example, install the HCRYPTPROV to be used to verify certificate's
//  having szOID_OIWSEC_md5RSA signatures.
//
//  By default, the installed HCRYPTPROV is only applicable to the current
//  thread. Set CRYPT_DEFAULT_CONTEXT_PROCESS_FLAG to allow the HCRYPTPROV 
//  to be used by all threads in the current process.
//
//  For a successful install, TRUE is returned and *phDefaultContext is
//  updated with the HANDLE to be passed to CryptUninstallDefaultContext.
//
//  The installed HCRYPTPROVs are stack ordered (the last installed
//  HCRYPTPROV is checked first). All thread installed HCRYPTPROVs are
//  checked before any process HCRYPTPROVs.
//
//  The installed HCRYPTPROV remains available for default usage until
//  CryptUninstallDefaultContext is called or the thread or process exits.
//
//  If CRYPT_DEFAULT_CONTEXT_AUTO_RELEASE_FLAG is set, then, the HCRYPTPROV
//  is CryptReleaseContext'ed at thread or process exit. However,
//  not CryptReleaseContext'ed if CryptUninstallDefaultContext is
//  called.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptInstallDefaultContext(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwDefaultType,
    IN const void *pvDefaultPara,
    IN DWORD dwFlags,
    IN void *pvReserved,
    OUT HCRYPTDEFAULTCONTEXT *phDefaultContext
    )
{
    BOOL fResult;
    CRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA MultiOIDPara;
    LPSTR rgpszOID[1];
    PCRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA pMultiOIDPara;

    PDEFAULT_CONTEXT pDefaultContext = NULL;
    DWORD cbDefaultContext;
    BYTE *pbExtra;
    DWORD cbExtra;
    
    if (CRYPT_DEFAULT_CONTEXT_CERT_SIGN_OID == dwDefaultType) {
        dwDefaultType = CRYPT_DEFAULT_CONTEXT_MULTI_CERT_SIGN_OID;
        if (pvDefaultPara) {
            rgpszOID[0] = (LPSTR) pvDefaultPara;
            MultiOIDPara.cOID = 1;
            MultiOIDPara.rgpszOID = rgpszOID;
            pvDefaultPara = (const void *) &MultiOIDPara;
        }
    }

    if (CRYPT_DEFAULT_CONTEXT_MULTI_CERT_SIGN_OID != dwDefaultType)
        goto InvalidArg;

    pMultiOIDPara = (PCRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA) pvDefaultPara;
    if (pMultiOIDPara) {
        DWORD cOID = pMultiOIDPara->cOID;
        LPSTR *ppszOID = pMultiOIDPara->rgpszOID;

        if (0 == cOID)
            goto InvalidArg;
        cbExtra = INFO_LEN_ALIGN(sizeof(CRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA)) +
            cOID * sizeof(LPSTR);

        for ( ; cOID; cOID--, ppszOID++)
            cbExtra += strlen(*ppszOID) + 1;
    } else {
        if (dwFlags & CRYPT_DEFAULT_CONTEXT_PROCESS_FLAG)
            goto InvalidArg;
        cbExtra = 0;
    }

    cbDefaultContext = INFO_LEN_ALIGN(sizeof(DEFAULT_CONTEXT)) + cbExtra;

    if (NULL == (pDefaultContext = (PDEFAULT_CONTEXT) PkiZeroAlloc(
            cbDefaultContext)))
        goto OutOfMemory;

    pDefaultContext->hCryptProv = hCryptProv;
    pDefaultContext->dwDefaultType = dwDefaultType;
    pDefaultContext->dwFlags = dwFlags;

    pbExtra = ((BYTE *) pDefaultContext) +
        INFO_LEN_ALIGN(sizeof(DEFAULT_CONTEXT));

    if (cbExtra) {
        DWORD cOID = pMultiOIDPara->cOID;
        LPSTR *ppszOID = pMultiOIDPara->rgpszOID;

        PCRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA pOIDDefaultPara;
        LPSTR *ppszOIDDefault;

        assert(cOID);

        pOIDDefaultPara = (PCRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA) pbExtra;
        pDefaultContext->pOIDDefaultPara = pOIDDefaultPara;
        pbExtra += INFO_LEN_ALIGN(sizeof(CRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA));

        ppszOIDDefault = (LPSTR *) pbExtra;
        pbExtra += cOID * sizeof(LPSTR);
        pOIDDefaultPara->cOID = cOID;
        pOIDDefaultPara->rgpszOID = ppszOIDDefault;

        for ( ; cOID; cOID--, ppszOID++, ppszOIDDefault++) {
            DWORD cch = strlen(*ppszOID) + 1;

            memcpy(pbExtra, *ppszOID, cch);
            *ppszOIDDefault = (LPSTR) pbExtra;
            pbExtra += cch;
        }
    }
    assert(pbExtra == ((BYTE *) pDefaultContext) + cbDefaultContext);

    if (dwFlags & CRYPT_DEFAULT_CONTEXT_PROCESS_FLAG)
        fResult = InstallProcessDefaultContext(pDefaultContext);
    else
        fResult = InstallThreadDefaultContext(pDefaultContext);
    if (!fResult)
        goto ErrorReturn;

CommonReturn:
    *phDefaultContext = (HCRYPTDEFAULTCONTEXT) pDefaultContext;
    return fResult;

ErrorReturn:
    PkiFree(pDefaultContext);
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(OutOfMemory)
}

//+-------------------------------------------------------------------------
//  Uninstall a default context previously installed by
//  CryptInstallDefaultContext.
//
//  For a default context installed with CRYPT_DEFAULT_CONTEXT_PROCESS_FLAG
//  set, if any other threads are currently using this context,
//  this function will block until they finish.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptUninstallDefaultContext(
    HCRYPTDEFAULTCONTEXT hDefaultContext,
    IN DWORD dwFlags,
    IN void *pvReserved
    )
{
    BOOL fResult;
    PDEFAULT_CONTEXT pDefaultContext = (PDEFAULT_CONTEXT) hDefaultContext;
    PDEFAULT_CONTEXT pDefaultContextHead;
    BOOL fProcess;

    if (NULL == pDefaultContext)
        return TRUE;

    fProcess = (pDefaultContext->dwFlags & CRYPT_DEFAULT_CONTEXT_PROCESS_FLAG);
    if (fProcess) {
        EnterCriticalSection(&DefaultContextCriticalSection);
        pDefaultContextHead = pProcessDefaultContextHead;
    } else { 
        pDefaultContextHead = (PDEFAULT_CONTEXT) I_CryptGetTls(
            hTlsDefaultContext);
    }

    if (NULL == pDefaultContextHead)
        goto InvalidArg;

    // Remove context from the list
    if (pDefaultContext->pNext)
        pDefaultContext->pNext->pPrev = pDefaultContext->pPrev;
    if (pDefaultContext->pPrev)
        pDefaultContext->pPrev->pNext = pDefaultContext->pNext;
    else if (pDefaultContext == pDefaultContextHead) {
        pDefaultContextHead = pDefaultContext->pNext;
        if (fProcess)
            pProcessDefaultContextHead = pDefaultContextHead;
        else
            I_CryptSetTls(hTlsDefaultContext, pDefaultContextHead);
    } else
        goto InvalidArg;

    if (fProcess) {
        if (pDefaultContext->lRefCnt) {
            // Wait for all uses of the hCryptProv handle to finish
            if (NULL == (pDefaultContext->hWait = CreateEvent(
                    NULL,       // lpsa
                    FALSE,      // fManualReset
                    FALSE,      // fInitialState
                    NULL))) {   // lpszEventName
                assert(pDefaultContext->hWait);
                goto UnexpectedError;
            }
                
            while (pDefaultContext->lRefCnt) {
                LeaveCriticalSection(&DefaultContextCriticalSection);
                WaitForSingleObject(pDefaultContext->hWait, INFINITE);
                EnterCriticalSection(&DefaultContextCriticalSection);
            }
            CloseHandle(pDefaultContext->hWait);
            pDefaultContext->hWait = NULL;
        }
    }

    PkiFree(pDefaultContext);
    fResult = TRUE;

CommonReturn:
    if (fProcess)
        LeaveCriticalSection(&DefaultContextCriticalSection);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidArg, E_INVALIDARG)
SET_ERROR(UnexpectedError, E_UNEXPECTED)
}


static PDEFAULT_CONTEXT FindDefaultContext(
    IN DWORD dwDefaultType,
    IN const void *pvDefaultPara,
    IN PDEFAULT_CONTEXT pDefaultContext
    )
{
    for ( ; pDefaultContext; pDefaultContext = pDefaultContext->pNext) {
        switch (dwDefaultType) {
            case CRYPT_DEFAULT_CONTEXT_CERT_SIGN_OID:
                if (CRYPT_DEFAULT_CONTEXT_MULTI_CERT_SIGN_OID ==
                        pDefaultContext->dwDefaultType) {
                    PCRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA pOIDDefaultPara =
                        pDefaultContext->pOIDDefaultPara;
                    DWORD cOID;
                    LPSTR *ppszOID;

                    if (NULL == pOIDDefaultPara)
                        return pDefaultContext;

                    cOID = pOIDDefaultPara->cOID;
                    ppszOID = pOIDDefaultPara->rgpszOID;
                    for ( ; cOID; cOID--, ppszOID++) {
                        if (0 == strcmp(*ppszOID, (LPSTR) pvDefaultPara))
                            return pDefaultContext;
                    }
                }
                break;
            default:
                return NULL;
        }
    }

    return NULL;
}

//
// dwDefaultTypes:
//  CRYPT_DEFAULT_CONTEXT_CERT_SIGN_OID (pvDefaultPara :== pszOID)
BOOL
WINAPI
I_CryptGetDefaultContext(
    IN DWORD dwDefaultType,
    IN const void *pvDefaultPara,
    OUT HCRYPTPROV *phCryptProv,
    OUT HCRYPTDEFAULTCONTEXT *phDefaultContext
    )
{

    if (fHasThreadDefaultContext) {
        PDEFAULT_CONTEXT pDefaultContext;

        pDefaultContext = (PDEFAULT_CONTEXT) I_CryptGetTls(hTlsDefaultContext);
        if (pDefaultContext = FindDefaultContext(
                dwDefaultType,
                pvDefaultPara,
                pDefaultContext
                )) {
            *phCryptProv = pDefaultContext->hCryptProv;
            *phDefaultContext = NULL;
            return TRUE;
        }
    }

    if (fHasProcessDefaultContext) {
        PDEFAULT_CONTEXT pDefaultContext;

        EnterCriticalSection(&DefaultContextCriticalSection);
        if (pDefaultContext = FindDefaultContext(
                dwDefaultType,
                pvDefaultPara,
                pProcessDefaultContextHead
                ))
            pDefaultContext->lRefCnt++;
        LeaveCriticalSection(&DefaultContextCriticalSection);

        if (pDefaultContext) {
            *phCryptProv = pDefaultContext->hCryptProv;
            *phDefaultContext = (HCRYPTDEFAULTCONTEXT) pDefaultContext;
            return TRUE;
        }
    }

    *phCryptProv = NULL;
    *phDefaultContext = NULL;
    return FALSE;
}

// hDefaultContext is only NON-null for Process default context
void
WINAPI
I_CryptFreeDefaultContext(
    HCRYPTDEFAULTCONTEXT hDefaultContext
    )
{
    PDEFAULT_CONTEXT pDefaultContext = (PDEFAULT_CONTEXT) hDefaultContext;

    if (NULL == pDefaultContext)
        return;

    assert(pDefaultContext->dwFlags & CRYPT_DEFAULT_CONTEXT_PROCESS_FLAG);
    assert(0 < pDefaultContext->lRefCnt);

    EnterCriticalSection(&DefaultContextCriticalSection);
    if (0 == --pDefaultContext->lRefCnt && pDefaultContext->hWait)
        SetEvent(pDefaultContext->hWait);
    LeaveCriticalSection(&DefaultContextCriticalSection);
}


#ifdef CMS_PKCS7

WINCRYPT32API
BOOL
WINAPI
CryptVerifyCertificateSignatureEx(
    IN OPTIONAL HCRYPTPROV hCryptProv,
    IN DWORD dwCertEncodingType,
    IN DWORD dwSubjectType,
    IN void *pvSubject,
    IN DWORD dwIssuerType,
    IN void *pvIssuer,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved
    )
{
    BOOL fResult;
    PCERT_SIGNED_CONTENT_INFO pSignedInfo = NULL;
    DWORD cbSignedInfo;
    HCRYPTDEFAULTCONTEXT hDefaultContext = NULL;
    HCRYPTKEY hSignKey = 0;
    HCRYPTHASH hHash = 0;
    BYTE *pbSignature;      // not allocated
    DWORD cbSignature;
    BYTE rgbDssSignature[CERT_DSS_SIGNATURE_LEN];
    ALG_ID aiHash;
    ALG_ID aiPubKey;
    DWORD dwSignFlags;
    DWORD dwErr;

    const BYTE *pbEncoded;  // not allocated
    DWORD cbEncoded;
    PCERT_PUBLIC_KEY_INFO pIssuerPubKeyInfo;
    CERT_PUBLIC_KEY_INFO IssuerPubKeyInfo;
    PCRYPT_OBJID_BLOB pIssuerPara;
    BYTE *pbAllocIssuerPara = NULL;

    switch (dwSubjectType) {
        case CRYPT_VERIFY_CERT_SIGN_SUBJECT_BLOB:
            {
                PCRYPT_DATA_BLOB pBlob = (PCRYPT_DATA_BLOB) pvSubject;
                pbEncoded = pBlob->pbData;
                cbEncoded = pBlob->cbData;
            }
            break;
        case CRYPT_VERIFY_CERT_SIGN_SUBJECT_CERT:
            {
                PCCERT_CONTEXT pSubject = (PCCERT_CONTEXT) pvSubject;
                pbEncoded = pSubject->pbCertEncoded;
                cbEncoded = pSubject->cbCertEncoded;
            }
            break;
        case CRYPT_VERIFY_CERT_SIGN_SUBJECT_CRL:
            {
                PCCRL_CONTEXT pSubject = (PCCRL_CONTEXT) pvSubject;
                pbEncoded = pSubject->pbCrlEncoded;
                cbEncoded = pSubject->cbCrlEncoded;
            }
            break;
        default:
            goto InvalidSubjectType;
    }
    
    if (!CryptDecodeObjectEx(
            dwCertEncodingType,
            X509_CERT,
            pbEncoded,
            cbEncoded,
            CRYPT_DECODE_NOCOPY_FLAG | CRYPT_DECODE_ALLOC_FLAG |
                CRYPT_DECODE_NO_SIGNATURE_BYTE_REVERSAL_FLAG,
            &PkiDecodePara,
            (void *) &pSignedInfo,
            &cbSignedInfo
            )) goto DecodeCertError;

    if (!GetSignOIDInfo(pSignedInfo->SignatureAlgorithm.pszObjId,
            &aiHash, &aiPubKey, &dwSignFlags))
        goto GetSignOIDInfoError;

    if (0 == hCryptProv) {
        if (!I_CryptGetDefaultContext(
                CRYPT_DEFAULT_CONTEXT_CERT_SIGN_OID,
                (const void *) pSignedInfo->SignatureAlgorithm.pszObjId,
                &hCryptProv,
                &hDefaultContext
                )) {
            if (0 == (hCryptProv = I_CryptGetDefaultCryptProv(aiPubKey)))
                goto GetDefaultCryptProvError;
        }
    }

#if 0
    // Slow down the signature verify while holding the default context
    // reference count
    if (hDefaultContext)
        Sleep(5000);
#endif

    switch (dwIssuerType) {
        case CRYPT_VERIFY_CERT_SIGN_ISSUER_PUBKEY:
            pIssuerPubKeyInfo = (PCERT_PUBLIC_KEY_INFO) pvIssuer;
            break;
        case CRYPT_VERIFY_CERT_SIGN_ISSUER_CHAIN:
            {
                PCCERT_CHAIN_CONTEXT pChain = (PCCERT_CHAIN_CONTEXT) pvIssuer;

                // All chains have at least the leaf certificate context
                assert(pChain->cChain && pChain->rgpChain[0]->cElement);
                pvIssuer =
                    (void *) pChain->rgpChain[0]->rgpElement[0]->pCertContext;
                dwIssuerType = CRYPT_VERIFY_CERT_SIGN_ISSUER_CERT;
            }
            // fall through
        case CRYPT_VERIFY_CERT_SIGN_ISSUER_CERT:
            {
                PCCERT_CONTEXT pIssuer = (PCCERT_CONTEXT) pvIssuer;

                pIssuerPubKeyInfo = &pIssuer->pCertInfo->SubjectPublicKeyInfo;

                // Check if the public key parameters were omitted
                // from the encoded certificate. If omitted, try
                // to use the certificate's CERT_PUBKEY_ALG_PARA_PROP_ID
                // property.
                pIssuerPara = &pIssuerPubKeyInfo->Algorithm.Parameters;
                if (0 == pIssuerPara->cbData ||
                        NULL_ASN_TAG == *pIssuerPara->pbData) {
                    DWORD cbData;

                    if (CertGetCertificateContextProperty(
                            pIssuer,
                            CERT_PUBKEY_ALG_PARA_PROP_ID,
                            NULL,                       // pvData
                            &cbData) && 0 < cbData
                                    &&
                        (pbAllocIssuerPara = (BYTE *) PkiNonzeroAlloc(
                            cbData))
                                    &&
                        CertGetCertificateContextProperty(
                            pIssuer,
                            CERT_PUBKEY_ALG_PARA_PROP_ID,
                            pbAllocIssuerPara,
                            &cbData)) {

                        IssuerPubKeyInfo = *pIssuerPubKeyInfo;
                        IssuerPubKeyInfo.Algorithm.Parameters.pbData =
                            pbAllocIssuerPara;
                        IssuerPubKeyInfo.Algorithm.Parameters.cbData = cbData;
                        pIssuerPubKeyInfo = &IssuerPubKeyInfo;
                    }
                }
            }
            break;
        default:
            goto InvalidIssuerType;
    }

    if (!CryptImportPublicKeyInfo(
                hCryptProv,
                dwCertEncodingType,
                pIssuerPubKeyInfo,
                &hSignKey
                )) goto ImportPublicKeyInfoError;
    if (!CryptCreateHash(
                hCryptProv,
                aiHash,
                NULL,               // hKey - optional for MAC
                0,                  // dwFlags
                &hHash
                )) goto CreateHashError;
    if (!CryptHashData(
                hHash,
                pSignedInfo->ToBeSigned.pbData,
                pSignedInfo->ToBeSigned.cbData,
                0                   // dwFlags
                )) goto HashDataError;


    pbSignature = pSignedInfo->Signature.pbData;
    cbSignature = pSignedInfo->Signature.cbData;
    if (CALG_DSS_SIGN == aiPubKey &&
            0 == (dwSignFlags & CRYPT_OID_INHIBIT_SIGNATURE_FORMAT_FLAG)) {
        DWORD cbData;

        // Convert from ASN.1 sequence of two integers to the CSP signature
        // format.
        cbData = sizeof(rgbDssSignature);
        if (!CryptDecodeObject(
                dwCertEncodingType,
                X509_DSS_SIGNATURE,
                pbSignature,
                cbSignature,
                0,                                  // dwFlags
                rgbDssSignature,
                &cbData
                ))
            goto DecodeDssSignatureError;
        pbSignature = rgbDssSignature;
        assert(cbData == sizeof(rgbDssSignature));
        cbSignature = sizeof(rgbDssSignature);
    } else 
        PkiAsn1ReverseBytes(pbSignature, cbSignature);

    if (!CryptVerifySignature(
                hHash,
                pbSignature,
                cbSignature,
                hSignKey,
                NULL,               // sDescription
                0                   // dwFlags
                )) goto VerifySignatureError;


    // For a certificate context certificate, check if the issuer has public
    // key parameters that can be inherited
    pIssuerPara = &pIssuerPubKeyInfo->Algorithm.Parameters;
    if (CRYPT_VERIFY_CERT_SIGN_SUBJECT_CERT == dwSubjectType &&
            pIssuerPara->cbData && NULL_ASN_TAG != *pIssuerPara->pbData) {
        // If a subject is missing its public key parameters and has
        // the same public key algorithm as its issuer, then, set
        // its CERT_PUBKEY_ALG_PARA_PROP_ID property.

        PCCERT_CONTEXT pSubject = (PCCERT_CONTEXT) pvSubject;
        PCERT_PUBLIC_KEY_INFO pSubjectPubKeyInfo =
            &pSubject->pCertInfo->SubjectPublicKeyInfo;
        PCCRYPT_OID_INFO pOIDInfo;
        PCRYPT_OBJID_BLOB pSubjectPara;
        DWORD cbData;

        pSubjectPara = &pSubjectPubKeyInfo->Algorithm.Parameters;
        if (pSubjectPara->cbData && NULL_ASN_TAG != *pSubjectPara->pbData)
            // Subject public key has parameters
            goto SuccessReturn;

        if (CertGetCertificateContextProperty(
                pSubject,
                CERT_PUBKEY_ALG_PARA_PROP_ID,
                NULL,                       // pvData
                &cbData) && 0 < cbData)
            // Subject already has public key parameters property
            goto SuccessReturn;

        pOIDInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            pSubjectPubKeyInfo->Algorithm.pszObjId,
            CRYPT_PUBKEY_ALG_OID_GROUP_ID);

        if (NULL == pOIDInfo || aiPubKey != pOIDInfo->Algid)
            // Subject and issuer don't have the same public key algorithms
            goto SuccessReturn;

        CertSetCertificateContextProperty(
            pSubject,
            CERT_PUBKEY_ALG_PARA_PROP_ID,
            CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG,
            pIssuerPara
            );
    }
    

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    dwErr = GetLastError();
    if (hSignKey)
        CryptDestroyKey(hSignKey);
    if (hHash)
        CryptDestroyHash(hHash);
    I_CryptFreeDefaultContext(hDefaultContext);
    PkiFree(pSignedInfo);
    PkiFree(pbAllocIssuerPara);

    SetLastError(dwErr);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidSubjectType, E_INVALIDARG)
TRACE_ERROR(DecodeCertError)
TRACE_ERROR(GetSignOIDInfoError)
TRACE_ERROR(GetDefaultCryptProvError)
SET_ERROR(InvalidIssuerType, E_INVALIDARG)
TRACE_ERROR(ImportPublicKeyInfoError)
TRACE_ERROR(CreateHashError)
TRACE_ERROR(HashDataError)
TRACE_ERROR(DecodeDssSignatureError)
TRACE_ERROR(VerifySignatureError)
}

//+-------------------------------------------------------------------------
//  Verify the signature of a subject certificate or a CRL using the
//  specified public key.
//
//  Returns TRUE for a valid signature.
//
//  hCryptProv specifies the crypto provider to use to verify the signature.
//  It doesn't need to use a private key.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptVerifyCertificateSignature(
    IN HCRYPTPROV   hCryptProv,
    IN DWORD        dwCertEncodingType,
    IN const BYTE * pbEncoded,
    IN DWORD        cbEncoded,
    IN PCERT_PUBLIC_KEY_INFO pPublicKey
    )
{
    CRYPT_DATA_BLOB Subject;

    Subject.cbData = cbEncoded;
    Subject.pbData = (BYTE *) pbEncoded;
    return CryptVerifyCertificateSignatureEx(
        hCryptProv,
        dwCertEncodingType,
        CRYPT_VERIFY_CERT_SIGN_SUBJECT_BLOB,
        (void *) &Subject,
        CRYPT_VERIFY_CERT_SIGN_ISSUER_PUBKEY,
        (void *) pPublicKey,
        0,                                      // dwFlags
        NULL                                    // pvReserved
        );
}

#endif  // CMS_PKCS7
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\certstor\crypttls.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       crypttls.cpp
//
//  Contents:   Crypt Thread Local Storage (TLS) and OssGlobal "world"
//              installation and allocation functions
//
//  Functions:  I_CryptTlsDllMain
//              I_CryptAllocTls
//              I_CryptFreeTls
//              I_CryptGetTls
//              I_CryptSetTls
//              I_CryptDetachTls
//              I_CryptInstallOssGlobal
//              I_CryptUninstallOssGlobal
//              I_CryptGetOssGlobal
//
//              I_CryptInstallAsn1Module
//              I_CryptUninstallAsn1Module
//              I_CryptGetAsn1Encoder
//              I_CryptGetAsn1Decoder
//
//  Assumption:
//      For PROCESS_ATTACH or THREAD_ATTACH, I_CryptTlsDllMain is called
//      first. For PROCESS_DETACH or THREAD_DETACH, I_CryptTlsDllMain
//      is called last.
//
//  History:    17-Nov-96    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

#ifdef OSS_CRYPT_ASN1
#include <asn1code.h>
#endif

#ifdef STATIC
#undef STATIC
#endif
#define STATIC

// CryptTls Entry types
#define FREE_CRYPTTLS       0
#define USER_CRYPTTLS       1
#define OSS_CRYPTTLS        2
#define ASN1_CRYPTTLS       3

typedef struct _ASN1_TLS_ENTRY {
    ASN1encoding_t pEnc;
    ASN1decoding_t pDec;
} ASN1_TLS_ENTRY, *PASN1_TLS_ENTRY;

// The following is reallocated and updated for each I_CryptAllocTls or
// I_CryptInstallOssGlobal. For I_CryptAllocTls, dwType is set to
// USER_CRYPTTLS and dwNext is zeroed.  For I_CryptInstallOssGlobal, dwType
// is set to OSS_CRYPTTLS and pvCtlTbl is updated with pvCtlTbl.
// For I_CryptFreeTls, dwType is set to FREE_CRYPTTLS and dwNext is
// updated with previous dwFreeProcessTlsHead.
//
// The array is indexed via hCryptTls -1 or hOssGlobal -1.
typedef struct _CRYPTTLS_PROCESS_ENTRY {
    DWORD                   dwType;
    union {
        void                    *pvCtlTbl;
        ASN1module_t            pMod;
        // Following is applicable to I_CryptFreeTls'ed entries.
        // Its the array index + 1 of the next free entry. A dwNext
        // of zero terminates.
        DWORD                   dwNext;
    };
} CRYPTTLS_PROCESS_ENTRY, *PCRYPTTLS_PROCESS_ENTRY;
static DWORD cProcessTls;
static PCRYPTTLS_PROCESS_ENTRY pProcessTls;


// The head of the entries freed by I_CryptFreeTls are indexed by the following.
// A 0 index indicates an empty free list.
//
// I_CryptAllocTls first checks this list before reallocating pProcessTls.
static DWORD dwFreeProcessTlsHead;

// The kernel32.dll Thread Local Storage (TLS) slot index
static DWORD iCryptTLS = 0xFFFFFFFF;

// The Thread Local Storage (TLS) referenced by iCryptTLS points to the
// following structure allocated for each thread. Once allocated, not
// reallocated. 
typedef struct _CRYPTTLS_THREAD_HDR CRYPTTLS_THREAD_HDR, *PCRYPTTLS_THREAD_HDR;
struct _CRYPTTLS_THREAD_HDR {
    DWORD                   cTls;
    void                    **ppvTls;   // reallocated
    PCRYPTTLS_THREAD_HDR    pNext;
    PCRYPTTLS_THREAD_HDR    pPrev;
};

// Linked list of all threads having CRYPTTLS
static PCRYPTTLS_THREAD_HDR pThreadTlsHead;


// Minimum number of entries allocated for pProcessTls and the ppvTls
//
// realloc optimization (MIN value is 1)
#define MIN_TLS_ALLOC_COUNT 16

// Used to protect the allocation of TLS and installation of OssGlobals
static CRITICAL_SECTION CryptTlsCriticalSection;

//+-------------------------------------------------------------------------
//  Free the thread's CRYPT TLS
//
//  Upon entry/exit, in CryptTlsCriticalSection
//--------------------------------------------------------------------------
static void FreeCryptTls(
    IN PCRYPTTLS_THREAD_HDR pTlsHdr
    )
{
    if (pTlsHdr->pNext)
        pTlsHdr->pNext->pPrev = pTlsHdr->pPrev;
    if (pTlsHdr->pPrev)
        pTlsHdr->pPrev->pNext = pTlsHdr->pNext;
    else if (pTlsHdr == pThreadTlsHead)
        pThreadTlsHead = pTlsHdr->pNext;
    else {
        assert(pTlsHdr == pThreadTlsHead);
    }

    if (pTlsHdr->ppvTls)
        free(pTlsHdr->ppvTls);
    free(pTlsHdr);
}

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptTlsDllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved)
{
    BOOL fRet;
    PCRYPTTLS_THREAD_HDR pTlsHdr;

    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        InitializeCriticalSection(&CryptTlsCriticalSection);
        if ((iCryptTLS = TlsAlloc()) == 0xFFFFFFFF)
            goto TlsAllocError;
        break;

    case DLL_PROCESS_DETACH:
    case DLL_THREAD_DETACH:
        if (pTlsHdr = (PCRYPTTLS_THREAD_HDR) TlsGetValue(iCryptTLS)) {
            DWORD cTls;
            DWORD cDetach = 0;
            DWORD i;

            cTls = pTlsHdr->cTls;

            EnterCriticalSection(&CryptTlsCriticalSection);
            assert(cTls <= cProcessTls);
            for (i = 0; i < cTls; i++) {
                void *pvTls;
                if (pvTls = pTlsHdr->ppvTls[i]) {
                    switch (pProcessTls[i].dwType) {
#ifdef OSS_CRYPT_ASN1
                    
                        case OSS_CRYPTTLS:
                            // Following API is in DELAYLOAD'ed msoss.dll. 
                            __try {
                                ossterm((POssGlobal) pvTls);
                            } __except(EXCEPTION_EXECUTE_HANDLER) {
                            }
                            free(pvTls);
                            pTlsHdr->ppvTls[i] = NULL;
                            break;
#endif                            
                        case ASN1_CRYPTTLS:
                            {
                                PASN1_TLS_ENTRY pAsn1TlsEntry =
                                    (PASN1_TLS_ENTRY) pvTls;

                                if (pAsn1TlsEntry->pEnc)
                                    ASN1_CloseEncoder(pAsn1TlsEntry->pEnc);
                                if (pAsn1TlsEntry->pDec)
                                    ASN1_CloseDecoder(pAsn1TlsEntry->pDec);
                                free(pvTls);
                                pTlsHdr->ppvTls[i] = NULL;
                            }
                            break;
                        case USER_CRYPTTLS:
                            cDetach++;
                            break;
                        default:
                            assert(FREE_CRYPTTLS == pProcessTls[i].dwType);
                    }

                }
            }

            FreeCryptTls(pTlsHdr);
            TlsSetValue(iCryptTLS, 0);
            
            LeaveCriticalSection(&CryptTlsCriticalSection);
            assert(cDetach == 0);
        }

        if (ulReason == DLL_PROCESS_DETACH) {
            while(pThreadTlsHead)
                FreeCryptTls(pThreadTlsHead);

            if (pProcessTls) {
                free(pProcessTls);
                pProcessTls = NULL;
            }
            cProcessTls = 0;
            dwFreeProcessTlsHead = 0;

            DeleteCriticalSection(&CryptTlsCriticalSection);
            TlsFree(iCryptTLS);
            iCryptTLS = 0xFFFFFFFF;
        }
        break;

    default:
        break;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(TlsAllocError)
}

//+-------------------------------------------------------------------------
//  Get a pointer to the Crypt TLS entries. Check that the hCryptTls is
//  included in the list of entries. If hCryptTls isn't included and
//  allocation isn't inhibited, alloc/realloc the array of TLS entries.
//
//  Also verifies the hCryptTls handle.
//--------------------------------------------------------------------------
STATIC void **GetCryptTls(
    IN HCRYPTTLS hCryptTls,
    IN BOOL fInhibitAlloc       // TRUE for I_CryptDetachTls
    )
{
    PCRYPTTLS_THREAD_HDR pTlsHdr;
    DWORD cTls;
    void **ppvTls;
    DWORD i;

    if (0 == hCryptTls--) {
        SetLastError((DWORD) E_INVALIDARG);
        return NULL;
    }

    pTlsHdr = (PCRYPTTLS_THREAD_HDR) TlsGetValue(iCryptTLS);
    cTls = pTlsHdr ? pTlsHdr->cTls : 0;
    if (hCryptTls < cTls)
        return pTlsHdr->ppvTls;

    if (fInhibitAlloc)
        return NULL;

    EnterCriticalSection(&CryptTlsCriticalSection);

    if (hCryptTls >= cProcessTls)
        goto InvalidArg;
    assert(cTls < cProcessTls);

    // Note for !DBG: realloc is mapped to LocalReAlloc. For LocalRealloc()
    // the previous memory pointer can't be NULL.
    if (pTlsHdr) {
        if (cProcessTls > MIN_TLS_ALLOC_COUNT) {
            if (NULL == (ppvTls = (void **) realloc(pTlsHdr->ppvTls,
                    cProcessTls * sizeof(void *))))
                goto OutOfMemory;
        } else {
            ppvTls = pTlsHdr->ppvTls;
            assert(ppvTls);
        }
    } else {
        DWORD cAllocTls = (cProcessTls > MIN_TLS_ALLOC_COUNT) ?
            cProcessTls : MIN_TLS_ALLOC_COUNT;
        if (NULL == (ppvTls = (void **) malloc(cAllocTls * sizeof(void *))))
            goto OutOfMemory;
        if (NULL == (pTlsHdr = (PCRYPTTLS_THREAD_HDR) malloc(
                sizeof(CRYPTTLS_THREAD_HDR)))) {
            free(ppvTls);
            goto OutOfMemory;
        }

        if (!TlsSetValue(iCryptTLS, pTlsHdr)) {
            free(pTlsHdr);
            free(ppvTls);
            goto TlsSetValueError;
        }

        pTlsHdr->pPrev = NULL;
        pTlsHdr->pNext = pThreadTlsHead;
        if (pThreadTlsHead)
            pThreadTlsHead->pPrev = pTlsHdr;
        pThreadTlsHead = pTlsHdr;
    }

    for (i = cTls; i < cProcessTls; i++)
        ppvTls[i] = NULL;
    pTlsHdr->ppvTls = ppvTls;
    pTlsHdr->cTls = cProcessTls;

CommonReturn:
    LeaveCriticalSection(&CryptTlsCriticalSection);
    return ppvTls;

ErrorReturn:
    ppvTls = NULL;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
TRACE_ERROR(TlsSetValueError)
}

//+-------------------------------------------------------------------------
//  Install a thread local storage entry and return a handle for future access.
//--------------------------------------------------------------------------
HCRYPTTLS
WINAPI
I_CryptAllocTls()
{
    HCRYPTTLS hCryptTls;

    EnterCriticalSection(&CryptTlsCriticalSection);

    if (dwFreeProcessTlsHead) {
        PCRYPTTLS_PROCESS_ENTRY pEntry;

        hCryptTls = (HCRYPTTLS) dwFreeProcessTlsHead;
        assert(hCryptTls <= cProcessTls);
        pEntry = &pProcessTls[dwFreeProcessTlsHead - 1];
        assert(FREE_CRYPTTLS == pEntry->dwType);
        assert(pEntry->dwNext <= cProcessTls);

        pEntry->dwType = USER_CRYPTTLS;
        dwFreeProcessTlsHead = pEntry->dwNext;
        pEntry->dwNext = 0;
    } else {
        PCRYPTTLS_PROCESS_ENTRY pNewProcessTls;

        // Note for !DBG: realloc is mapped to LocalReAlloc. For LocalRealloc()
        // the previous memory pointer can't be NULL.
        if (pProcessTls) {
            if (cProcessTls + 1 > MIN_TLS_ALLOC_COUNT)
                pNewProcessTls = (PCRYPTTLS_PROCESS_ENTRY) realloc(pProcessTls,
                    (cProcessTls + 1) * sizeof(CRYPTTLS_PROCESS_ENTRY));
            else
                pNewProcessTls = pProcessTls;
        } else
            pNewProcessTls = (PCRYPTTLS_PROCESS_ENTRY) malloc(
                (MIN_TLS_ALLOC_COUNT) * sizeof(CRYPTTLS_PROCESS_ENTRY));

        if (pNewProcessTls) {
            pNewProcessTls[cProcessTls].dwType = USER_CRYPTTLS;
            pNewProcessTls[cProcessTls].dwNext = 0;
            hCryptTls = (HCRYPTTLS) ++cProcessTls;
            pProcessTls = pNewProcessTls;
        } else {
            SetLastError((DWORD) E_OUTOFMEMORY);
            hCryptTls = 0;
        }
    }

    LeaveCriticalSection(&CryptTlsCriticalSection);
    return hCryptTls;
}

//+-------------------------------------------------------------------------
//  Called at DLL_PROCESS_DETACH to free a thread local storage entry.
//  Optionally, calls the callback for each thread having a non-NULL pvTls.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptFreeTls(
    IN HCRYPTTLS hCryptTls,
    IN OPTIONAL PFN_CRYPT_FREE pfnFree
    )
{
    BOOL fResult;
    DWORD dwType;
    PCRYPTTLS_THREAD_HDR pThreadTls;

    if (0 == hCryptTls--) {
        SetLastError((DWORD) E_INVALIDARG);
        return FALSE;
    }

    EnterCriticalSection(&CryptTlsCriticalSection);

    if (hCryptTls >= cProcessTls)
        goto InvalidArg;

    dwType = pProcessTls[hCryptTls].dwType;
    if (!(OSS_CRYPTTLS == dwType || USER_CRYPTTLS == dwType ||
            ASN1_CRYPTTLS == dwType))
        goto InvalidArg;

    // Iterate through the threads having CRYPTTLS
    pThreadTls = pThreadTlsHead;
    while (pThreadTls) {
        PCRYPTTLS_THREAD_HDR pThreadTlsNext;

        pThreadTlsNext = pThreadTls->pNext;
        if (pThreadTls->cTls > hCryptTls) {
            void *pvTls = pThreadTls->ppvTls[hCryptTls];
            if (pvTls) {
                pThreadTls->ppvTls[hCryptTls] = NULL;
#ifdef OSS_CRYPT_ASN1

                if (OSS_CRYPTTLS == dwType) {
                    // Following API is in DELAYLOAD'ed msoss.dll. 
                    __try {
                        ossterm((POssGlobal) pvTls);
                    } __except(EXCEPTION_EXECUTE_HANDLER) {
                    }
                    free(pvTls);
                } else 
#endif                
                if (ASN1_CRYPTTLS == dwType) {
                    PASN1_TLS_ENTRY pAsn1TlsEntry =
                        (PASN1_TLS_ENTRY) pvTls;

                    if (pAsn1TlsEntry->pEnc)
                        ASN1_CloseEncoder(pAsn1TlsEntry->pEnc);
                    if (pAsn1TlsEntry->pDec)
                        ASN1_CloseDecoder(pAsn1TlsEntry->pDec);

                    free(pvTls);
                } else if (pfnFree) {
                    // Don't call the callback holding the critical section
                    LeaveCriticalSection(&CryptTlsCriticalSection);
                    pfnFree(pvTls);
                    EnterCriticalSection(&CryptTlsCriticalSection);

                    // In case this thread gets deleted, start over at
                    // the beginning.
                    pThreadTlsNext = pThreadTlsHead;
                }
            }
        }

        pThreadTls = pThreadTlsNext;
    }

    // Insert in beginning of process free list
    pProcessTls[hCryptTls].dwType = FREE_CRYPTTLS;
    pProcessTls[hCryptTls].dwNext = dwFreeProcessTlsHead;
    dwFreeProcessTlsHead = hCryptTls + 1;
    fResult = TRUE;

CommonReturn:
    LeaveCriticalSection(&CryptTlsCriticalSection);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
}

//+-------------------------------------------------------------------------
//  Get the thread specific pointer specified by the
//  hCryptTls returned by I_CryptAllocTls().
//
//  Returns NULL for an error or uninitialized or NULL pointer.
//--------------------------------------------------------------------------
void *
WINAPI
I_CryptGetTls(
    IN HCRYPTTLS hCryptTls
    )
{
    void **ppvTls;
    void *pvTls;
    if (ppvTls = GetCryptTls(
            hCryptTls,
            FALSE)) {       // fInhibitAlloc
        if (NULL == (pvTls = ppvTls[hCryptTls - 1]))
            SetLastError(NO_ERROR);
    } else
        pvTls = NULL;
    return pvTls;
}

//+-------------------------------------------------------------------------
//  Set the thread specific pointer specified by the
//  hCryptTls returned by I_CryptAllocTls().
//
//  Returns FALSE for an invalid handle or unable to allocate memory.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptSetTls(
    IN HCRYPTTLS hCryptTls,
    IN void *pvTls
    )
{
    void **ppvTls;
    if (ppvTls = GetCryptTls(
            hCryptTls,
            FALSE)) {       // fInhibitAlloc
        ppvTls[hCryptTls - 1] = pvTls;
        return TRUE;
    } else
        return FALSE;
}

//+-------------------------------------------------------------------------
//  Called at DLL_THREAD_DETACH to free the thread's
//  TLS entry specified by the hCryptTls. Returns the thread specific pointer
//  to be freed by the caller.
//
//  Note, at DLL_PROCESS_DETACH, I_CryptFreeTls should be called instead.
//--------------------------------------------------------------------------
void *
WINAPI
I_CryptDetachTls(
    IN HCRYPTTLS hCryptTls
    )
{
    void **ppvTls;
    void *pvTls;
    if (ppvTls = GetCryptTls(
            hCryptTls,
            TRUE)) {        // fInhibitAlloc
        if (pvTls = ppvTls[hCryptTls - 1])
            ppvTls[hCryptTls - 1] = NULL;
        else
            SetLastError(NO_ERROR);
    } else
        pvTls = NULL;
    return pvTls;
}

#ifdef OSS_CRYPT_ASN1

//+-------------------------------------------------------------------------
//  Install an OssGlobal entry and return a handle for future access.
//
//  Each thread has its own copy of OssGlobal. Allocation and
//  initialization are deferred until first referenced by the thread.
//
//  The parameter, pvCtlTbl is passed to ossinit() to initialize the OssGlobal.
//
//  I_CryptGetOssGlobal must be called with the handled returned by
//  I_CryptInstallOssGlobal to get the thread specific OssGlobal.
//
//  Currently, dwFlags and pvReserved aren't used and must be set to 0.
//--------------------------------------------------------------------------
HCRYPTOSSGLOBAL
WINAPI
I_CryptInstallOssGlobal(
    IN void *pvCtlTbl,
    IN DWORD dwFlags,
    IN void *pvReserved
    )
{
    HCRYPTOSSGLOBAL hOssGlobal;

    if (hOssGlobal = (HCRYPTOSSGLOBAL) I_CryptAllocTls()) {
        // Since pProcessTls can be reallocated in another thread
        // need CriticalSection
        EnterCriticalSection(&CryptTlsCriticalSection);
        pProcessTls[hOssGlobal - 1].dwType = OSS_CRYPTTLS;
        pProcessTls[hOssGlobal - 1].pvCtlTbl = pvCtlTbl;
        LeaveCriticalSection(&CryptTlsCriticalSection);
    }
    return hOssGlobal;
}

//+-------------------------------------------------------------------------
//  Called at DLL_PROCESS_DETACH to uninstall an OssGlobal entry. Iterate
//  through the threads and frees their allocated copy of OssGlobal.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptUninstallOssGlobal(
    IN HCRYPTOSSGLOBAL hOssGlobal
    )
{
    return I_CryptFreeTls(
        (HCRYPTTLS) hOssGlobal,
        NULL                        // pfnFree
        );
}

//+-------------------------------------------------------------------------
//  Get the thread specific pointer to the OssGlobal specified by the
//  hOssGlobal returned by CryptInstallOssGlobal. If the
//  OssGlobal doesn't exist, then, its allocated and initialized using
//  the pvCtlTbl associated with hOssGlobal.
//--------------------------------------------------------------------------
POssGlobal
WINAPI
I_CryptGetOssGlobal(
    IN HCRYPTOSSGLOBAL hOssGlobal
    )
{
    POssGlobal pog;
    void **ppvTls;
    DWORD iOssGlobal;
    DWORD dwType;
    void *pvCtlTbl;
    DWORD dwExceptionCode;

    if (NULL == (ppvTls = GetCryptTls(
                                (HCRYPTTLS) hOssGlobal,
                                FALSE)))        // fInhibitAlloc
        return NULL;

    iOssGlobal = (DWORD) hOssGlobal - 1;
    if (pog = (POssGlobal) ppvTls[iOssGlobal])
        return pog;

    // Since pProcessTls can be reallocated in another thread
    // need CriticalSection
    EnterCriticalSection(&CryptTlsCriticalSection);
    dwType = pProcessTls[iOssGlobal].dwType;
    pvCtlTbl = pProcessTls[iOssGlobal].pvCtlTbl;
    LeaveCriticalSection(&CryptTlsCriticalSection);
    if (OSS_CRYPTTLS != dwType || NULL == pvCtlTbl)
        goto InvalidArg;

    // The following APIs are in DELAYLOAD'ed msoss.dll. If the DELAYLOAD
    // fails an exception is raised. 
    __try {
        if (NULL == (pog = (POssGlobal) malloc(ossGetOssGlobalSize())))
            goto OutOfMemory;
        if (0 != ossinit(pog, pvCtlTbl))
            goto ossinitError;
        if (0 != ossSetEncodingRules(pog, OSS_DER))
            goto SetEncodingRulesError;
#if DBG
        if (!DbgInitOSS(pog))
            goto DbgInitOSSError;
#else
        if (0 != ossSetEncodingFlags(pog, NOTRAPPING | FRONT_ALIGN))
            goto SetEncodingFlagsError;
        if (0 != ossSetDecodingFlags(pog, NOTRAPPING | RELAXBER))
            goto SetDecodingFlagsError;
#endif
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwExceptionCode = GetExceptionCode();
        goto msossLoadLibraryException;
    }

    ppvTls[iOssGlobal] = pog;
CommonReturn:
    return pog;

ErrorReturn:
    if (pog) {
        free(pog);
        pog = NULL;
    }
    goto CommonReturn;

SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(ossinitError)
TRACE_ERROR(SetEncodingRulesError)
#if DBG
TRACE_ERROR(DbgInitOSSError)
#else
TRACE_ERROR(SetEncodingFlagsError)
TRACE_ERROR(SetDecodingFlagsError)
#endif
SET_ERROR_VAR(msossLoadLibraryException, dwExceptionCode)
}

#endif

//+-------------------------------------------------------------------------
//  Install an Asn1 module entry and return a handle for future access.
//
//  Each thread has its own copy of the decoder and encoder associated
//  with the Asn1 module. Creation is deferred until first referenced by
//  the thread.
//
//  I_CryptGetAsn1Encoder or I_CryptGetAsn1Decoder must be called with the
//  handle returned by I_CryptInstallAsn1Module to get the thread specific
//  Asn1 encoder or decoder.
//
//  Currently, dwFlags and pvReserved aren't used and must be set to 0.
//--------------------------------------------------------------------------
HCRYPTASN1MODULE
WINAPI
I_CryptInstallAsn1Module(
    IN ASN1module_t pMod,
    IN DWORD dwFlags,
    IN void *pvReserved
    )
{
    HCRYPTASN1MODULE hAsn1Module;

    if (hAsn1Module = (HCRYPTOSSGLOBAL) I_CryptAllocTls()) {
        // Since pProcessTls can be reallocated in another thread
        // need CriticalSection
        EnterCriticalSection(&CryptTlsCriticalSection);
        pProcessTls[hAsn1Module - 1].dwType = ASN1_CRYPTTLS;
        pProcessTls[hAsn1Module - 1].pMod = pMod;
        LeaveCriticalSection(&CryptTlsCriticalSection);
    }
    return hAsn1Module;
}

//+-------------------------------------------------------------------------
//  Called at DLL_PROCESS_DETACH to uninstall an hAsn1Module entry. Iterates
//  through the threads and frees their created Asn1 encoders and decoders.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptUninstallAsn1Module(
    IN HCRYPTASN1MODULE hAsn1Module
    )
{
    return I_CryptFreeTls(
        (HCRYPTTLS) hAsn1Module,
        NULL                        // pfnFree
        );
}


STATIC
PASN1_TLS_ENTRY
WINAPI
I_CryptGetAsn1Tls(
    IN HCRYPTASN1MODULE hAsn1Module
    )
{
    PASN1_TLS_ENTRY pAsn1TlsEntry;
    void **ppvTls;
    DWORD iAsn1Module;

    if (NULL == (ppvTls = GetCryptTls(
                                (HCRYPTTLS) hAsn1Module,
                                FALSE)))        // fInhibitAlloc
        return NULL;

    iAsn1Module = (DWORD) hAsn1Module - 1;
    if (pAsn1TlsEntry = (PASN1_TLS_ENTRY) ppvTls[iAsn1Module])
        return pAsn1TlsEntry;

    if (NULL == (pAsn1TlsEntry = (PASN1_TLS_ENTRY) malloc(
            sizeof(ASN1_TLS_ENTRY))))
        goto OutOfMemory;
    memset(pAsn1TlsEntry, 0, sizeof(ASN1_TLS_ENTRY));

    ppvTls[iAsn1Module] = pAsn1TlsEntry;
CommonReturn:
    return pAsn1TlsEntry;

ErrorReturn:
    goto CommonReturn;

SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
}


//+-------------------------------------------------------------------------
//  Get the thread specific pointer to the Asn1 encoder specified by the
//  hAsn1Module returned by CryptInstallAsn1Module. If the
//  encoder doesn't exist, then, its created using the Asn1 module
//  associated with hAsn1Module.
//--------------------------------------------------------------------------
ASN1encoding_t
WINAPI
I_CryptGetAsn1Encoder(
    IN HCRYPTASN1MODULE hAsn1Module
    )
{
    PASN1_TLS_ENTRY pAsn1TlsEntry;
    ASN1encoding_t pEnc;
    DWORD iAsn1Module;
    DWORD dwType;
    ASN1module_t pMod;
    ASN1error_e Asn1Err;

    if (NULL == (pAsn1TlsEntry = I_CryptGetAsn1Tls(hAsn1Module)))
        return NULL;
    if (pEnc = pAsn1TlsEntry->pEnc)
        return pEnc;

    iAsn1Module = (DWORD) hAsn1Module - 1;

    // Since pProcessTls can be reallocated in another thread
    // need CriticalSection
    EnterCriticalSection(&CryptTlsCriticalSection);
    dwType = pProcessTls[iAsn1Module].dwType;
    pMod = pProcessTls[iAsn1Module].pMod;
    LeaveCriticalSection(&CryptTlsCriticalSection);
    if (ASN1_CRYPTTLS != dwType || NULL == pMod)
        goto InvalidArg;

    Asn1Err = ASN1_CreateEncoder(
        pMod,
        &pEnc,
        NULL,           // pbBuf
        0,              // cbBufSize
        NULL            // pParent
        );
    if (ASN1_SUCCESS != Asn1Err)
        goto CreateEncoderError;

    pAsn1TlsEntry->pEnc = pEnc;
CommonReturn:
    return pEnc;

ErrorReturn:
    pEnc = NULL;
    goto CommonReturn;

SET_ERROR_VAR(CreateEncoderError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(InvalidArg, E_INVALIDARG)
}

//+-------------------------------------------------------------------------
//  Get the thread specific pointer to the Asn1 decoder specified by the
//  hAsn1Module returned by CryptInstallAsn1Module. If the
//  decoder doesn't exist, then, its created using the Asn1 module
//  associated with hAsn1Module.
//--------------------------------------------------------------------------
ASN1decoding_t
WINAPI
I_CryptGetAsn1Decoder(
    IN HCRYPTASN1MODULE hAsn1Module
    )
{
    PASN1_TLS_ENTRY pAsn1TlsEntry;
    ASN1decoding_t pDec;
    DWORD iAsn1Module;
    DWORD dwType;
    ASN1module_t pMod;
    ASN1error_e Asn1Err;

    if (NULL == (pAsn1TlsEntry = I_CryptGetAsn1Tls(hAsn1Module)))
        return NULL;
    if (pDec = pAsn1TlsEntry->pDec)
        return pDec;

    iAsn1Module = (DWORD) hAsn1Module - 1;

    // Since pProcessTls can be reallocated in another thread
    // need CriticalSection
    EnterCriticalSection(&CryptTlsCriticalSection);
    dwType = pProcessTls[iAsn1Module].dwType;
    pMod = pProcessTls[iAsn1Module].pMod;
    LeaveCriticalSection(&CryptTlsCriticalSection);
    if (ASN1_CRYPTTLS != dwType || NULL == pMod)
        goto InvalidArg;

    Asn1Err = ASN1_CreateDecoder(
        pMod,
        &pDec,
        NULL,           // pbBuf
        0,              // cbBufSize
        NULL            // pParent
        );
    if (ASN1_SUCCESS != Asn1Err)
        goto CreateDecoderError;

    pAsn1TlsEntry->pDec = pDec;
CommonReturn:
    return pDec;

ErrorReturn:
    pDec = NULL;
    goto CommonReturn;

SET_ERROR_VAR(CreateDecoderError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(InvalidArg, E_INVALIDARG)
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\certstor\ekuhlpr.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       ekuhlpr.cpp
//
//  Contents:   Certificate Enhanced Key Usage Helper API implementation
//
//  History:    21-May-97    kirtd    Created
//              xx-xxx-xx    reidk    Added CertGetValidUsages
//
//----------------------------------------------------------------------------
#include <global.hxx>
#include <dbgdef.h>
//+---------------------------------------------------------------------------
//
//  Function:   CertGetEnhancedKeyUsage
//
//  Synopsis:   gets the enhanced key usage extension/property from the
//              certificate
//
//----------------------------------------------------------------------------
BOOL WINAPI CertGetEnhancedKeyUsage (
                IN     PCCERT_CONTEXT     pCertContext,
                IN     DWORD              dwFlags,
                OUT    PCERT_ENHKEY_USAGE pUsage,
                IN OUT DWORD*             pcbUsage
                )
{
    HRESULT           hr = S_OK;
    CRYPT_OBJID_BLOB  cob;
    PCRYPT_OBJID_BLOB pExtBlob = NULL;
    PCRYPT_OBJID_BLOB pPropBlob = NULL;

    //
    // If the flags are zero then assume they want everything
    //

    if ( dwFlags == 0 )
    {
        dwFlags = CERT_FIND_ALL_ENHKEY_USAGE_FLAG;
    }

    //
    // Validate the parameters
    //

    if ( ( ( dwFlags & CERT_FIND_ALL_ENHKEY_USAGE_FLAG ) == 0 ) ||
         ( pCertContext == NULL ) || ( pcbUsage == NULL ) )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return( FALSE );
    }

    //
    // If they want everything, call CertGetValidUsages
    //

    if ( dwFlags == CERT_FIND_ALL_ENHKEY_USAGE_FLAG )
    {
        return( EkuGetIntersectedUsageViaGetValidUsages(
                   pCertContext,
                   pcbUsage,
                   pUsage
                   ) );
    }

    //
    // If they want extensions get the extension blob, if they want
    // properties get the property blob
    //

    if ( dwFlags & CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG )
    {
        pExtBlob = EkuGetExtension(pCertContext);
    }

    if ( dwFlags & CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG )
    {
        hr = EkuGetProperty(pCertContext, &cob);
        if ( hr == S_OK )
        {
            pPropBlob = &cob;
        }
    }

    //
    // Make sure that at least something was found and that what has occurred
    // is correctly indicated
    //

    if ( ( pExtBlob == NULL ) && ( pPropBlob == NULL ) )
    {
        if ( hr == S_OK )
        {
            hr = CRYPT_E_NOT_FOUND;
        }
    }
    else
    {
        hr = S_OK;
    }

    //
    // If all they wanted was the size, give it to them, otherwise, we
    // need to decode and give the caller what they requested
    //

    if ( hr == S_OK )
    {
        if ( pUsage == NULL )
        {
            DWORD cbSize = 0;
            DWORD cbExtSize = 0;
            DWORD cbPropSize = 0;

            hr = EkuGetDecodedUsageSizes(
                       pExtBlob,
                       pPropBlob,
                       &cbSize,
                       &cbExtSize,
                       &cbPropSize
                       );

            if ( hr == S_OK )
            {
                if ( cbSize > 0 )
                {
                    *pcbUsage = cbSize;
                }
                else
                {
                    // Need better last error code
                    hr = E_INVALIDARG;
                }
            }
        }
        else
        {
            hr = EkuGetMergedDecodedUsage(
                             pExtBlob,
                             pPropBlob,
                             pcbUsage,
                             pUsage
                             );
        }
    }

    //
    // Cleanup and return
    //

    if ( pPropBlob != NULL )
    {
        delete pPropBlob->pbData;
    }

    if ( hr != S_OK )
    {
        SetLastError(hr);
        return( FALSE );
    }

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   CertSetEnhancedKeyUsage
//
//  Synopsis:   sets the enhanced key usage property on the certificate
//
//----------------------------------------------------------------------------
BOOL WINAPI CertSetEnhancedKeyUsage (
                IN PCCERT_CONTEXT     pCertContext,
                IN PCERT_ENHKEY_USAGE pUsage
                )
{
    HRESULT          hr;
    CRYPT_OBJID_BLOB EkuBlob;

    //
    // if pUsage is NULL, then just set the NULL property
    //
    if (pUsage == NULL)
    {
        hr = EkuSetProperty(pCertContext, NULL);
    }
    else
    {
        //
        // Encode the usage and set the property
        //
        hr = EkuEncodeUsage(pUsage, &EkuBlob);
        if ( hr == S_OK )
        {
            hr = EkuSetProperty(pCertContext, &EkuBlob);
            delete EkuBlob.pbData;
        }
    }

    if ( hr != S_OK )
    {
        SetLastError(hr);
        return( FALSE );
    }

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   CertAddEnhancedKeyUsageIdentifier
//
//  Synopsis:   adds a key usage identifier to the enhanced key usage property
//              on the certificate
//
//----------------------------------------------------------------------------
BOOL WINAPI CertAddEnhancedKeyUsageIdentifier (
                IN PCCERT_CONTEXT pCertContext,
                IN LPCSTR         pszUsageIdentifier
                )
{
    HRESULT            hr;
    DWORD              cbUsage1 = 0;
    DWORD              cbUsage2 = 0;
    DWORD              cbUsageM = 0;
    DWORD              cId;
    PCERT_ENHKEY_USAGE pUsage1 = NULL;
    PCERT_ENHKEY_USAGE pUsage2 = NULL;
    PCERT_ENHKEY_USAGE pUsageM = NULL;

    //
    // Create a one element, properly "encoded" (see EkuMergeUsage) enhanced
    // key usage structure
    //

    cId = strlen(pszUsageIdentifier)+1;
    cbUsage1 = sizeof(CERT_ENHKEY_USAGE)+sizeof(LPSTR)+cId;
    pUsage1 = (PCERT_ENHKEY_USAGE)new BYTE [cbUsage1];
    if ( pUsage1 == NULL )
    {
        SetLastError(E_OUTOFMEMORY);
        return( FALSE );
    }

    pUsage1->cUsageIdentifier = 1;
    pUsage1->rgpszUsageIdentifier = (LPSTR *)((LPBYTE)pUsage1+sizeof(CERT_ENHKEY_USAGE));
    pUsage1->rgpszUsageIdentifier[0] = (LPSTR)((LPBYTE)pUsage1->rgpszUsageIdentifier+sizeof(LPSTR));
    strcpy(pUsage1->rgpszUsageIdentifier[0], pszUsageIdentifier);

    //
    // Get the current enhanced key usage properties and get an appropriately
    // sized block for the merged data unless there are no current usage
    // properties in which case we just set the one we have now
    //

    hr = EkuGetUsage(
               pCertContext,
               CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG,
               &cbUsage2,
               &pUsage2
               );

    if ( hr == S_OK )
    {
        cbUsageM = cbUsage1 + cbUsage2;
        pUsageM = (PCERT_ENHKEY_USAGE)new BYTE [cbUsageM];
        if ( pUsageM == NULL )
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else if ( hr == CRYPT_E_NOT_FOUND )
    {
        BOOL fReturn;

        fReturn = CertSetEnhancedKeyUsage(pCertContext, pUsage1);
        delete pUsage1;
        return( fReturn );
    }
    else
    {
        SetLastError(hr);
        return( FALSE );
    }

    //
    // Merge the usage structures and set the properties
    //

    hr = EkuMergeUsage(cbUsage1, pUsage1, cbUsage2, pUsage2, cbUsageM, pUsageM);
    if ( hr == S_OK )
    {
        if ( CertSetEnhancedKeyUsage(pCertContext, pUsageM) == FALSE )
        {
            hr = GetLastError();
        }
    }

    //
    // Cleanup
    //

    delete pUsage1;
    delete pUsage2;
    delete pUsageM;

    if ( hr != S_OK )
    {
        SetLastError(hr);
        return( FALSE );
    }

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   CertRemoveEnhancedKeyUsageIdentifier
//
//  Synopsis:   removes a key usage identifier from the enhanced key usage
//              property on the certificate
//
//----------------------------------------------------------------------------
BOOL WINAPI CertRemoveEnhancedKeyUsageIdentifier (
                IN PCCERT_CONTEXT pCertContext,
                IN LPCSTR         pszUsageIdentifier
                )
{
    HRESULT            hr;
    DWORD              cFound = 0;
    DWORD              cCount;
    PCERT_ENHKEY_USAGE pUsage;
    LPSTR*             apsz;

    //
    // Get the current usage properties
    //

    hr = EkuGetUsage(
            pCertContext,
            CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG,
            NULL,
            &pUsage
            );

    if ( hr != S_OK )
    {
        SetLastError(hr);
        return( FALSE );
    }

    //
    // Loop through the usage identifiers and remove ones that match
    // the passed in id
    //

    apsz = pUsage->rgpszUsageIdentifier;

    for (cCount = 0; cCount < pUsage->cUsageIdentifier; cCount++)
    {
        if ( strcmp(apsz[cCount], pszUsageIdentifier) == 0 )
        {
            cFound++;
        }
        else if ( cFound > 0 )
        {
            apsz[cCount-cFound] = apsz[cCount];
        }
    }

    //
    // If we removed any, update the usage id count and set the new property
    //

    if ( cFound > 0 )
    {
        pUsage->cUsageIdentifier -= cFound;

        if ( pUsage->cUsageIdentifier == 0 )
        {
            // Delete the property if we are down to zero
            hr = EkuSetProperty(pCertContext, NULL);
        }
        else if ( CertSetEnhancedKeyUsage(pCertContext, pUsage) == FALSE )
        {
            hr = GetLastError();
        }
    }

    //
    // Cleanup
    //

    delete pUsage;

    if ( hr != S_OK )
    {
        SetLastError(hr);
        return( FALSE );
    }

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   EkuGetExtension
//
//  Synopsis:   gets the enhanced key usage extension blob from the
//              certificate
//
//----------------------------------------------------------------------------
PCRYPT_OBJID_BLOB EkuGetExtension (
                        PCCERT_CONTEXT pCertContext
                        )
{
    PCERT_EXTENSION pExtension;

    //
    // Get the enhanced key usage extension from the certificate and if
    // we couldn't find the extension return NULL otherwise, return
    // the appropriate field of the found extension
    //

    pExtension = CertFindExtension(
                         szOID_ENHANCED_KEY_USAGE,
                         pCertContext->pCertInfo->cExtension,
                         pCertContext->pCertInfo->rgExtension
                         );

    if ( pExtension == NULL )
    {
        return( NULL );
    }

    return( &pExtension->Value );
}

//+---------------------------------------------------------------------------
//
//  Function:   EkuGetProperty
//
//  Synopsis:   gets the enhanced key usage property from the certificate
//
//----------------------------------------------------------------------------
HRESULT EkuGetProperty (
              PCCERT_CONTEXT    pCertContext,
              PCRYPT_OBJID_BLOB pEkuBlob
              )
{
    DWORD cb;

    if ( CertGetCertificateContextProperty(
                           pCertContext,
                           CERT_ENHKEY_USAGE_PROP_ID,
                           NULL,
                           &cb
                           ) == FALSE )
    {
        return( GetLastError() );
    }

    pEkuBlob->cbData = cb;
    pEkuBlob->pbData = new BYTE [cb];

    if ( pEkuBlob->pbData == NULL )
    {
        return( E_OUTOFMEMORY );
    }

    if ( CertGetCertificateContextProperty(
                           pCertContext,
                           CERT_ENHKEY_USAGE_PROP_ID,
                           pEkuBlob->pbData,
                           &cb
                           ) == FALSE )
    {
        return( GetLastError() );
    }

    return( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Function:   EkuSetProperty
//
//  Synopsis:   sets an enhanced key usage property on the certificate
//
//----------------------------------------------------------------------------
HRESULT EkuSetProperty (
              PCCERT_CONTEXT    pCertContext,
              PCRYPT_OBJID_BLOB pEkuBlob
              )
{
    if ( CertSetCertificateContextProperty(
                           pCertContext,
                           CERT_ENHKEY_USAGE_PROP_ID,
                           0,
                           pEkuBlob
                           ) == FALSE )
    {
        return( GetLastError() );
    }

    return( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Function:   EkuGetDecodedSize
//
//  Synopsis:   gets the decoded size of the enhanced key usage blob
//
//----------------------------------------------------------------------------
HRESULT EkuGetDecodedSize (
              PCRYPT_OBJID_BLOB pEkuBlob,
              DWORD*            pcbSize
              )
{
    if ( CryptDecodeObject(
              X509_ASN_ENCODING,
              szOID_ENHANCED_KEY_USAGE,
              pEkuBlob->pbData,
              pEkuBlob->cbData,
              0,
              NULL,
              pcbSize
              ) == FALSE )
    {
        return( GetLastError() );
    }

    return( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Function:   EkuGetDecodedUsageSizes
//
//  Synopsis:   gets the decoded sizes for enhanced key usage blobs from the
//              certificate extension and/or the certificate context property
//
//----------------------------------------------------------------------------
HRESULT EkuGetDecodedUsageSizes (
              PCRYPT_OBJID_BLOB pExtBlob,
              PCRYPT_OBJID_BLOB pPropBlob,
              DWORD*            pcbSize,
              DWORD*            pcbExtSize,
              DWORD*            pcbPropSize
              )
{
    HRESULT hr = S_OK;
    DWORD   cbExtSize = 0;
    DWORD   cbPropSize = 0;
    DWORD   cbSize = 0;

    //
    // Get the appropriate decoded size based on what was requested
    //

    if ( pExtBlob != NULL )
    {
        hr = EkuGetDecodedSize(pExtBlob, &cbExtSize);
    }

    if ( ( hr == S_OK ) && ( pPropBlob != NULL ) )
    {
        hr = EkuGetDecodedSize(pPropBlob, &cbPropSize);
    }

    //
    // Collect into the out parameters
    //

    if ( hr == S_OK )
    {
        *pcbExtSize = cbExtSize;
        *pcbPropSize = cbPropSize;
        *pcbSize = cbExtSize + cbPropSize;
    }

    return( hr );
}

//+---------------------------------------------------------------------------
//
//  Function:   EkuGetDecodedUsage
//
//  Synopsis:   gets the decoded enhanced key usage from the encoded blob
//
//----------------------------------------------------------------------------
HRESULT EkuGetDecodedUsage (
              PCRYPT_OBJID_BLOB  pEkuBlob,
              DWORD*             pcbSize,
              PCERT_ENHKEY_USAGE pUsage
              )
{
    if ( CryptDecodeObject(
              X509_ASN_ENCODING,
              szOID_ENHANCED_KEY_USAGE,
              pEkuBlob->pbData,
              pEkuBlob->cbData,
              0,
              pUsage,
              pcbSize
              ) == FALSE )
    {
        return( GetLastError() );
    }

    return( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Function:   EkuMergeUsage
//
//  Synopsis:   merges enhanced key usage structures
//
//              NOTE: The structures are assumed to be in single allocated
//                    block form where the string pointers point back into
//                    the bottom part of the allocated block where the
//                    have been placed
//
//----------------------------------------------------------------------------
HRESULT EkuMergeUsage (
              DWORD              cbSize1,
              PCERT_ENHKEY_USAGE pUsage1,
              DWORD              cbSize2,
              PCERT_ENHKEY_USAGE pUsage2,
              DWORD              cbSizeM,
              PCERT_ENHKEY_USAGE pUsageM
              )
{
    DWORD  cUsage1;
    DWORD  cUsage2;
    DWORD  cUsageM;
    DWORD  cbOids1;
    DWORD  cbOids2;
    DWORD  cbUsage1;
    DWORD  cbUsage2;
    DWORD  cCount;
    DWORD  cbOffset;
    LPSTR* apsz1;
    LPSTR* apsz2;
    LPSTR* apszM;

    //
    // Copy the data from the source to the destination
    //

    cUsage1 = pUsage1->cUsageIdentifier;
    cUsage2 = pUsage2->cUsageIdentifier;
    cUsageM = cUsage1 + cUsage2;

    cbUsage1 = ( cUsage1 * sizeof(LPSTR) ) + sizeof(CERT_ENHKEY_USAGE);
    cbUsage2 = ( cUsage2 * sizeof(LPSTR) ) + sizeof(CERT_ENHKEY_USAGE);

    apsz1 = pUsage1->rgpszUsageIdentifier;
    apsz2 = pUsage2->rgpszUsageIdentifier;
    apszM = (LPSTR *)((LPBYTE)pUsageM+sizeof(CERT_ENHKEY_USAGE));

    pUsageM->cUsageIdentifier = cUsageM;
    pUsageM->rgpszUsageIdentifier = apszM;

    memcpy(apszM, apsz1, cUsage1*sizeof(LPSTR));
    memcpy(&apszM[cUsage1], apsz2, cUsage2*sizeof(LPSTR));

    cbOids1 = cbSize1 - cbUsage1;
    cbOids2 = cbSize2 - cbUsage2;

    memcpy(&apszM[cUsageM], &apsz1[cUsage1], cbOids1);

    memcpy(
       (LPBYTE)(&apszM[cUsageM])+cbOids1,
       &apsz2[cUsage2],
       cbOids2
       );

    //
    // Fix up the pointers
    //

    for ( cCount = 0; cCount < cUsage1; cCount++)
    {
        cbOffset = (DWORD)((LPBYTE)(apsz1[cCount]) - (LPBYTE)apsz1) + cbUsage2;
        apszM[cCount] = (LPSTR)((LPBYTE)pUsageM+cbOffset);
    }

    for ( cCount = 0; cCount < cUsage2; cCount++ )
    {
        cbOffset = (DWORD)((LPBYTE)(apsz2[cCount]) - (LPBYTE)apsz2) + cbUsage1 + cbOids1;
        apszM[cCount+cUsage1] = (LPSTR)((LPBYTE)pUsageM+cbOffset);
    }

    return( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Function:   EkuGetMergedDecodedUsage
//
//  Synopsis:   gets merged decoded enhanced key usage from the certificate
//              extension and the certificate properties
//
//----------------------------------------------------------------------------
HRESULT EkuGetMergedDecodedUsage (
              PCRYPT_OBJID_BLOB  pExtBlob,
              PCRYPT_OBJID_BLOB  pPropBlob,
              DWORD*             pcbSize,
              PCERT_ENHKEY_USAGE pUsage
              )
{
    HRESULT            hr;
    DWORD              cbExtSize = 0;
    DWORD              cbPropSize = 0;
    DWORD              cbMergedSize = 0;
    PCERT_ENHKEY_USAGE pExtUsage = NULL;
    PCERT_ENHKEY_USAGE pPropUsage = NULL;

    //
    // If either the extension or the properties are NULL, we just need
    // to get the other one
    //

    if ( pExtBlob == NULL )
    {
        return( EkuGetDecodedUsage(pPropBlob, pcbSize, pUsage) );
    }
    else if ( pPropBlob == NULL )
    {
        return( EkuGetDecodedUsage(pExtBlob, pcbSize, pUsage) );
    }

    //
    // Get the sizes we will need to allocate for decoding and validate
    // the total against what was passed in
    //

    hr = EkuGetDecodedUsageSizes(
               pExtBlob,
               pPropBlob,
               &cbMergedSize,
               &cbExtSize,
               &cbPropSize
               );

    if ( hr != S_OK )
    {
        return( hr );
    }
    else if ( *pcbSize < cbMergedSize )
    {
        *pcbSize = cbMergedSize;
        return( ERROR_MORE_DATA );
    }

    //
    // Allocate the enhanced key usage structures and decode into them
    //

    pExtUsage = (PCERT_ENHKEY_USAGE)new BYTE [cbExtSize];
    pPropUsage = (PCERT_ENHKEY_USAGE)new BYTE [cbPropSize];

    if ( ( pExtUsage == NULL ) || ( pPropUsage == NULL ) )
    {
        delete pExtUsage;
        delete pPropUsage;
        return( E_OUTOFMEMORY );
    }

    hr = EkuGetDecodedUsage(pExtBlob, &cbExtSize, pExtUsage);
    if ( hr == S_OK )
    {
        hr = EkuGetDecodedUsage(pPropBlob, &cbPropSize, pPropUsage);
    }

    //
    // Merge the usage structures
    //

    if ( hr == S_OK )
    {
        hr = EkuMergeUsage(
                     cbExtSize,
                     pExtUsage,
                     cbPropSize,
                     pPropUsage,
                     *pcbSize,
                     pUsage
                     );
    }

    //
    // Cleanup
    //

    delete pExtUsage;
    delete pPropUsage;

    return( hr );
}

//+---------------------------------------------------------------------------
//
//  Function:   EkuEncodeUsage
//
//  Synopsis:   encodes the enhanced key usage into a blob useful for setting
//              as a certificate property
//
//----------------------------------------------------------------------------
HRESULT EkuEncodeUsage (
              PCERT_ENHKEY_USAGE pUsage,
              PCRYPT_OBJID_BLOB  pEkuBlob
              )
{
    HRESULT hr = S_OK;
    DWORD   cbData = 0;
    LPBYTE  pbData;

    if ( CryptEncodeObject(
              X509_ASN_ENCODING,
              szOID_ENHANCED_KEY_USAGE,
              pUsage,
              NULL,
              &cbData
              ) == FALSE )
    {
        return( GetLastError() );
    }

    pbData = new BYTE [cbData];

    if ( pbData != NULL )
    {
        if ( CryptEncodeObject(
                  X509_ASN_ENCODING,
                  szOID_ENHANCED_KEY_USAGE,
                  pUsage,
                  pbData,
                  &cbData
                  ) == FALSE )
        {
            hr = GetLastError();
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if ( hr == S_OK )
    {
        pEkuBlob->cbData = cbData;
        pEkuBlob->pbData = pbData;
    }
    else
    {
        delete pbData;
    }

    return( hr );
}

//+---------------------------------------------------------------------------
//
//  Function:   EkuGetUsage
//
//  Synopsis:   gets the usage based on the flags with CertGetEnhancedKeyUsage
//
//----------------------------------------------------------------------------
HRESULT EkuGetUsage (
              PCCERT_CONTEXT      pCertContext,
              DWORD               dwFlags,
              DWORD*              pcbSize,
              PCERT_ENHKEY_USAGE* ppUsage
              )
{
    DWORD              cbSize;
    PCERT_ENHKEY_USAGE pUsage;

    //
    // Get an appropriately sized block to hold the usage
    //

    if ( CertGetEnhancedKeyUsage(
                pCertContext,
                dwFlags,
                NULL,
                &cbSize
                ) == FALSE )
    {
        return( GetLastError() );
    }

    pUsage = (PCERT_ENHKEY_USAGE)new BYTE [cbSize];
    if ( pUsage == NULL )
    {
        return( E_OUTOFMEMORY );
    }

    //
    // Now get the enhanced key usage data and fill in the out parameters
    //

    if ( CertGetEnhancedKeyUsage(
                pCertContext,
                dwFlags,
                pUsage,
                &cbSize
                ) == FALSE )
    {
        delete pUsage;
        return( GetLastError() );
    }

    if ( pcbSize != NULL )
    {
        *pcbSize = cbSize;
    }

    *ppUsage = pUsage;

    return( S_OK );
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static BOOL OIDInUsages(PCERT_ENHKEY_USAGE pUsage, LPCSTR pszOID)
{
    DWORD i;

    // check every extension
    for(i=0; i<pUsage->cUsageIdentifier; i++)
    {
        if(!strcmp(pUsage->rgpszUsageIdentifier[i], pszOID))
            break;
    }

    return (i < pUsage->cUsageIdentifier);
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static BOOL OIDExistsInArray(LPSTR *rghPropOIDs, DWORD cPropOIDs, LPSTR pszOID)
{
    DWORD i;

    // check every extension
    for(i=0; i<cPropOIDs; i++)
    {
        if(!strcmp(rghPropOIDs[i], pszOID))
            break;
    }

    return (i < cPropOIDs);
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static LPSTR AllocAndCopyStr(LPSTR psz)
{
    LPSTR pszNew;

    pszNew = (LPSTR) new BYTE[strlen(psz)+1];

    if (pszNew == NULL)
    {
        SetLastError(E_OUTOFMEMORY);
        return NULL;
    }

    strcpy(pszNew, psz);
    return (pszNew);
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static void IntersectUsages(DWORD *pcExtOIDs, LPSTR *rghExtOIDs, PCERT_ENHKEY_USAGE pUsageExt)
{
    DWORD i;
    DWORD dwNumOIDs;

    dwNumOIDs = *pcExtOIDs;
    *pcExtOIDs = 0;

    for (i=0; i<dwNumOIDs; i++)
    {
        if (OIDInUsages(pUsageExt, rghExtOIDs[i]))
        {
            if (*pcExtOIDs != i)
            {
                rghExtOIDs[*pcExtOIDs] = rghExtOIDs[i];
                rghExtOIDs[i] = NULL;
            }
            (*pcExtOIDs)++;
        }
        else
        {
            delete(rghExtOIDs[i]);
            rghExtOIDs[i] = NULL;
        }
    }
}


//////////////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////////////
static BOOL ProcessCertForEKU(
                    PCCERT_CONTEXT  pCert,
                    BOOL            *pfAllProp,
                    DWORD           *pcPropOIDs,
                    LPSTR           *rghPropOIDs,
                    BOOL            *pfAllExt,
                    DWORD           *pcExtOIDs,
                    LPSTR           *rghExtOIDs)
{
    BOOL                fRet        = TRUE;
    PCERT_ENHKEY_USAGE  pExtUsage   = NULL;
    PCERT_ENHKEY_USAGE  pPropUsage  = NULL;
    DWORD               i;

    EkuGetUsage(pCert, CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG, NULL, &pExtUsage);
    EkuGetUsage(pCert, CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG, NULL, &pPropUsage);

    //
    // if there are EKU extensions then we are limited to that set of EKUs at the maximum
    //
    if (pExtUsage != NULL)
    {
        //
        // if this is the first cert with extensions then just copy all the EKUs,
        // otherwise take the intersection of the current certs EKUs and the intersection
        // of all the previous certs EKUs
        //
        if (*pfAllExt == TRUE)
        {
            *pfAllExt = FALSE;
            for (i=0; i<pExtUsage->cUsageIdentifier; i++)
            {
                rghExtOIDs[i] = AllocAndCopyStr(pExtUsage->rgpszUsageIdentifier[i]);
                if (rghExtOIDs[i] == NULL)
                {
                    goto ErrorCleanUp;
                }
                (*pcExtOIDs)++;
            }
        }
        else
        {
            IntersectUsages(pcExtOIDs, rghExtOIDs, pExtUsage);
        }
    }

    //
    // if there are EKU propertis then we are limited to that set of EKUs at the maximum
    //
    if (pPropUsage != NULL)
    {
        //
        // if this is the first cert with extensions then just copy all the EKUs,
        // otherwise take the intersection of the current certs EKUs and the intersection
        // of all the previous certs EKUs
        //
        if (*pfAllProp == TRUE)
        {
            *pfAllProp = FALSE;
            for (i=0; i<pPropUsage->cUsageIdentifier; i++)
            {
                rghPropOIDs[i] = AllocAndCopyStr(pPropUsage->rgpszUsageIdentifier[i]);
                if (rghPropOIDs[i] == NULL)
                {
                    goto ErrorCleanUp;
                }
                (*pcPropOIDs)++;
            }
        }
        else
        {
            IntersectUsages(pcPropOIDs, rghPropOIDs, pPropUsage);
        }
    }

CleanUp:

    if (pExtUsage != NULL)
        delete(pExtUsage);

    if (pPropUsage != NULL)
        delete(pPropUsage);

    return(fRet);

ErrorCleanUp:

    fRet = FALSE;
    goto CleanUp;
}


//+---------------------------------------------------------------------------
//
//  Function:   CertGetValidUsages
//
//  Synopsis:   takes an array of certs and returns an array of usages
//              which consists of the intersection of the the valid usages for each cert.
//              if each cert is good for all possible usages then cNumOIDs is set to -1.
//
//----------------------------------------------------------------------------
BOOL WINAPI CertGetValidUsages(
                    IN      DWORD           cCerts,
                    IN      PCCERT_CONTEXT  *rghCerts,
                    OUT     int             *cNumOIDs,
                    OUT     LPSTR           *rghOIDs,
                    IN OUT  DWORD           *pcbOIDs)
{
    BOOL            fAllExt = TRUE;
    BOOL            fAllProp = TRUE;
    DWORD           cPropOIDs = 0;
    LPSTR           rghPropOIDs[100];
    DWORD           cExtOIDs = 0;
    LPSTR           rghExtOIDs[100];
    BOOL            fRet = TRUE;
    BYTE            *pbBufferLocation;
    DWORD           cIntersectOIDs = 0;
    DWORD           i;
    DWORD           cbNeeded = 0;

    for (i=0; i<cCerts; i++)
    {
        if (!ProcessCertForEKU(rghCerts[i], &fAllProp, &cPropOIDs, rghPropOIDs, &fAllExt, &cExtOIDs, rghExtOIDs))
        {
            goto ErrorCleanUp;
        }
    }

    *cNumOIDs = 0;

    if (fAllExt && fAllProp)
    {
        *pcbOIDs = 0;
        *cNumOIDs = -1;
    }
    else if (!fAllExt && fAllProp)
    {
        for (i=0; i<cExtOIDs; i++)
        {
            cbNeeded += strlen(rghExtOIDs[i]) + 1 + sizeof(LPSTR);
            (*cNumOIDs)++;
        }

        if (*pcbOIDs == 0)
        {
            *pcbOIDs = cbNeeded;
            goto CleanUp;
        }

        if (cbNeeded > *pcbOIDs)
        {
            *pcbOIDs = cbNeeded;
            SetLastError((DWORD) ERROR_MORE_DATA);
            goto ErrorCleanUp;
        }

        pbBufferLocation = ((BYTE *)rghOIDs) + (cExtOIDs * sizeof(LPSTR));
        for (i=0; i<cExtOIDs; i++)
        {
            rghOIDs[i] = (LPSTR) pbBufferLocation;
            strcpy(rghOIDs[i], rghExtOIDs[i]);
            pbBufferLocation += strlen(rghExtOIDs[i]) + 1;
        }
    }
    else if (fAllExt && !fAllProp)
    {
        for (i=0; i<cPropOIDs; i++)
        {
            cbNeeded += strlen(rghPropOIDs[i]) + 1 + sizeof(LPSTR);
            (*cNumOIDs)++;
        }

        if (*pcbOIDs == 0)
        {
            *pcbOIDs = cbNeeded;
            goto CleanUp;
        }

        if (cbNeeded > *pcbOIDs)
        {
            *pcbOIDs = cbNeeded;
            SetLastError((DWORD) ERROR_MORE_DATA);
            goto ErrorCleanUp;
        }

        pbBufferLocation = ((BYTE *)rghOIDs) + (cPropOIDs * sizeof(LPSTR));
        for (i=0; i<cPropOIDs; i++)
        {
            rghOIDs[i] = (LPSTR) pbBufferLocation;
            strcpy(rghOIDs[i], rghPropOIDs[i]);
            pbBufferLocation += strlen(rghPropOIDs[i]) + 1;
        }
    }
    else
    {
        for (i=0; i<cExtOIDs; i++)
        {
            if (OIDExistsInArray(rghPropOIDs, cPropOIDs, rghExtOIDs[i]))
            {
                cbNeeded += strlen(rghExtOIDs[i]) + 1 + sizeof(LPSTR);
                (*cNumOIDs)++;
                cIntersectOIDs++;
            }
        }

        if (*pcbOIDs == 0)
        {
            *pcbOIDs = cbNeeded;
            goto CleanUp;
        }

        if (cbNeeded > *pcbOIDs)
        {
            *pcbOIDs = cbNeeded;
            SetLastError((DWORD) ERROR_MORE_DATA);
            goto ErrorCleanUp;
        }

        pbBufferLocation = ((BYTE *)rghOIDs) + (cIntersectOIDs * sizeof(LPSTR));
        for (i=0; i<cExtOIDs; i++)
        {
            if (OIDExistsInArray(rghPropOIDs, cPropOIDs, rghExtOIDs[i]))
            {
                cIntersectOIDs--;
                rghOIDs[cIntersectOIDs] = (LPSTR) pbBufferLocation;
                strcpy(rghOIDs[cIntersectOIDs], rghExtOIDs[i]);
                pbBufferLocation += strlen(rghExtOIDs[i]) + 1;
            }
        }
    }

CleanUp:

    for (i=0; i<cExtOIDs; i++)
    {
        delete(rghExtOIDs[i]);
    }

    for (i=0; i<cPropOIDs; i++)
    {
        delete(rghPropOIDs[i]);
    }

    return (fRet);

ErrorCleanUp:
    fRet = FALSE;
    goto CleanUp;

}
//+---------------------------------------------------------------------------
//
//  Function:   EkuGetIntersectedUsageViaGetValidUsages
//
//  Synopsis:   get the intersected extension and property usages
//
//----------------------------------------------------------------------------
BOOL
EkuGetIntersectedUsageViaGetValidUsages (
   PCCERT_CONTEXT pCertContext,
   DWORD* pcbSize,
   PCERT_ENHKEY_USAGE pUsage
   )
{
    BOOL  fResult;
    int   cUsage = 0;
    DWORD cbUsage = 0;
    DWORD cbSize = 0;

    fResult = CertGetValidUsages( 1, &pCertContext, &cUsage, NULL, &cbUsage );

    if ( fResult == TRUE )
    {
        cbSize = cbUsage + sizeof( CERT_ENHKEY_USAGE );

        if ( pUsage == NULL )
        {
            *pcbSize = cbSize;
            return( TRUE );
        }
        else if ( ( pUsage != NULL ) && ( *pcbSize < cbSize ) )
        {
            *pcbSize = cbSize;
            SetLastError( ERROR_MORE_DATA );
            return( FALSE );
        }

        pUsage->cUsageIdentifier = 0;
        pUsage->rgpszUsageIdentifier = (LPSTR *)( (LPBYTE)pUsage + sizeof( CERT_ENHKEY_USAGE ) );
        cbUsage = *pcbSize - sizeof( CERT_ENHKEY_USAGE );

        fResult = CertGetValidUsages(
                      1,
                      &pCertContext,
                      (int *)&pUsage->cUsageIdentifier,
                      pUsage->rgpszUsageIdentifier,
                      &cbUsage
                      );

        if ( fResult == TRUE )
        {
            if ( pUsage->cUsageIdentifier == 0xFFFFFFFF )
            {
                pUsage->cUsageIdentifier = 0;
                SetLastError( CRYPT_E_NOT_FOUND );
            }
            else if ( pUsage->cUsageIdentifier == 0 )
            {
                SetLastError( 0 );
            }
        }
    }

    return( fResult );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\certstor\frmtfunc.h ===
//
//  Copyright (C) Microsoft Corporation, 1995 - 1997
//
//  File:     frmtfunc.h
//
//  Contents:   The header for frmtfunc.cpp
//
//  History:    Sept. 1st, 1997
//              
//--------------------------------------------------------------------------

#ifndef __FRMTFUNC_H__
#define __FRMTFUNC_H__

#include <wchar.h> 
        
#include "base64.h"
#include "wintrust.h"
#include "mssip.h"
#include "sipbase.h"
#include "pfx.h"


#ifdef __cplusplus
extern "C" {
#endif

//----------------------------------------------------------------------------
//	 constants
//--------------------------------------------------------------------------
#define	    UPPER_BITS			                        0xF0
#define	    LOWER_BITS			                        0x0F
#define	    CHAR_SIZE			                        2
#define	    HEX_SIZE			                        3    

//for szOID_BASIC_CONSTRAINTS2
#define		SUBJECT_SIZE								256
#define		NONE_SIZE									256
   
//for szOID_CRL_REASON_CODE
#define		CRL_REASON_SIZE								256

//for szOID_ENHANCED_KEY_USAGE
#define     NO_INFO_SIZE                                256

//for szOID_ALT_NAME
#define     UNKNOWN_VALUE_SIZE                          256
#define     ALT_NAME_SIZE                               256

//for SPC_FINANCIAL_CRIERIA
#define     AVAIL_SIZE                                  256
#define     YES_NO_SIZE                                 256

//for Key Usage                                         
#define     KEY_USAGE_SIZE                              256
#define     UNKNOWN_ACCESS_METHOD_SIZE                  256
#define     UNKNOWN_KEY_USAGE_SIZE                      256
#define     DAY_SIZE                                    256
#define     MONTH_SIZE                                  256
#define     CRL_DIST_NAME_SIZE                          256
#define     UNKNOWN_CRL_REASON_SIZE                     256
#define     PRE_FIX_SIZE                                256
//----------------------------------------------------------------------------
//	 WCHAR string contants
//--------------------------------------------------------------------------

//used for formatting
#define	wszPLUS			L" + "
#define	wszCOMMA		L" , "
#define	wszSEMICOLON	L" ; "
#define	wszCRLF			L"\r\n"
#define	wszEQUAL		L"="
#define	strCOMMA			", "
//#define szNEWLN         "\n"
#define wszNEWLN        L"\n"


#define BEGINCERT_W                 L"-----BEGIN CERTIFICATE-----"
#define CBBEGINCERT_W               (sizeof(BEGINCERT_W)/sizeof(WCHAR) - 1)

#define BEGINCERT_A                 "-----BEGIN CERTIFICATE-----"
#define CBBEGINCERT_A               (sizeof(BEGINCERT_A)/sizeof(CHAR) - 1)


//---------------------------------------------------------
//	The following is used by this dll
//
//-----------------------------------------------------------  

const DWORD	g_AllocateSize=128*sizeof(WCHAR);

//---------------------------------------------------------------------------
//
//	Unitlity functions used by the dll
//---------------------------------------------------------------------------								
BOOL	DecodeGenericBLOB(DWORD dwEncodingType, LPCSTR lpszStructType,
			const BYTE *pbEncoded, DWORD cbEncoded,void **ppStructInfo); 
BOOL	FormatMessageUnicode(LPWSTR	*ppwszFormat,UINT ids,...);
HRESULT	SZtoWSZ(LPSTR szStr,LPWSTR *pwsz);
DWORD   FormatToStr(DWORD   dwFormatType);
//BOOL	FormatMessageStr(LPSTR	*ppszFormat,UINT ids,...);

BOOL    GetCertNameMulti(LPWSTR          pwszNameStr,
                         UINT            idsPreFix, 
                         LPWSTR          *ppwsz);

BOOL	FormatFileTime(FILETIME *pFileTime,LPWSTR   *ppwszFormat);

BOOL    FormatCertPolicyID(PCERT_POLICY_ID pCertPolicyID, LPWSTR    *ppwszFormat);

BOOL    FormatCRLReason(DWORD		    dwCertEncodingType,
	                    DWORD		    dwFormatType,
	                    DWORD		    dwFormatStrType,
	                    void		    *pFormatStruct,
	                    LPCSTR		    lpszStructType,
                        PCRYPT_BIT_BLOB pInfo,
                        LPWSTR          *ppwszFormat);



static BOOL
WINAPI
FormatBytesToHex(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded, 
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);


BOOL FormatAltNameInfo(
    DWORD		            dwCertEncodingType,
	DWORD		            dwFormatType,
    DWORD                   dwFormatStrType,
    void	            	*pFormatStruct,
    UINT                    idsPreFix,
    BOOL                    fNewLine,
    PCERT_ALT_NAME_INFO	    pInfo,
    void	                *pbFormat,
	DWORD	                *pcbFormat);

static BOOL
WINAPI
FormatKeyUsageBLOB(
	DWORD		    dwCertEncodingType,
	DWORD		    dwFormatType,
	DWORD		    dwFormatStrType,
	void		    *pFormatStruct,
	LPCSTR		    lpszStructType,
    PCRYPT_BIT_BLOB	pInfo,
	void	        *pbFormat,
	DWORD	        *pcbFormat);

BOOL    FormatDistPointName(
    DWORD		            dwCertEncodingType,                         
	DWORD		            dwFormatType,                               
	DWORD		            dwFormatStrType,                            
	void		            *pFormatStruct,                             
    PCRL_DIST_POINT_NAME    pInfo,                                      
    LPWSTR                  *ppwszFormat);    

BOOL FormatCertQualifier(
	DWORD		                    dwCertEncodingType,
	DWORD		                    dwFormatType,
	DWORD		                    dwFormatStrType,
	void		                    *pFormatStruct,
    PCERT_POLICY_QUALIFIER_INFO     pInfo,
    LPWSTR                          *ppwszFormat);

BOOL FormatSPCObject(
	DWORD		                dwFormatType,
	DWORD		                dwFormatStrType,
    void		                *pFormatStruct,
    UINT                        idsPrefix,
    PSPC_SERIALIZED_OBJECT      pInfo,
    LPWSTR                      *ppwszFormat);

BOOL FormatSPCLink(
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
    void		*pFormatStruct,
    UINT        idsPrefix,
    PSPC_LINK   pInfo,
    LPWSTR      *ppwszFormat);

BOOL FormatSPCImage(
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
    void		*pFormatStruct,
    UINT        idsPrefix,
    PSPC_IMAGE  pInfo,
    LPWSTR      *ppwszImageFormat);


BOOL	CryptDllFormatNameAll(  
				DWORD		dwEncodingType,	
				DWORD		dwFormatType,
				DWORD		dwFormatStrType,
				void		*pStruct,
                UINT        idsPreFix,
                BOOL        fToAllocate,
				const BYTE	*pbEncoded,
				DWORD		cbEncoded,
				void		**ppbBuffer,
				DWORD		*pcbBuffer);

                          


#ifdef __cplusplus
}       // Balance extern "C" above
#endif


#endif // __FRMTFUNC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\certstor\ctlfunc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1997
//
//  File:       ctlfunc.cpp
//
//  Contents:   Certificate Verify CTL Usage Dispatch Functions
//
//  Functions:  I_CertCTLUsageFuncDllMain
//              CertVerifyCTLUsage
//
//  History:    29-Apr-97    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

static HCRYPTOIDFUNCSET hUsageFuncSet;

typedef BOOL (WINAPI *PFN_CERT_DLL_VERIFY_CTL_USAGE)(
    IN DWORD dwEncodingType,
    IN DWORD dwSubjectType,
    IN void *pvSubject,
    IN PCTL_USAGE pSubjectUsage,
    IN DWORD dwFlags,
    IN OPTIONAL PCTL_VERIFY_USAGE_PARA pVerifyUsagePara,
    IN OUT PCTL_VERIFY_USAGE_STATUS pVerifyUsageStatus
    );

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertCTLUsageFuncDllMain(
        HMODULE hModule,
        ULONG  ulReason,
        LPVOID lpReserved)
{
    BOOL    fRet;

    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        if (NULL == (hUsageFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_VERIFY_CTL_USAGE_FUNC,
                0)))                                // dwFlags
            goto CryptInitOIDFunctionSetError;
        break;

    case DLL_PROCESS_DETACH:
    case DLL_THREAD_DETACH:
    default:
        break;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(CryptInitOIDFunctionSetError)
}

static void ZeroUsageStatus(
    IN OUT PCTL_VERIFY_USAGE_STATUS pUsageStatus)
{
    pUsageStatus->dwError = 0;
    pUsageStatus->dwFlags = 0;
    if (pUsageStatus->ppCtl)
        *pUsageStatus->ppCtl = NULL;
    pUsageStatus->dwCtlEntryIndex = 0;
    if (pUsageStatus->ppSigner)
        *pUsageStatus->ppSigner = NULL;
    pUsageStatus->dwSignerIndex = 0;
}

//+-------------------------------------------------------------------------
//  Remember the "most interesting" error
//--------------------------------------------------------------------------
static void UpdateUsageError(
    IN DWORD dwNewError,
    IN OUT DWORD *pdwError
    )
{
    if (0 != dwNewError) {
        DWORD dwError = *pdwError;
        if ((DWORD) CRYPT_E_NOT_IN_CTL == dwNewError ||
                (DWORD) CRYPT_E_NO_VERIFY_USAGE_DLL == dwError
                        ||
            ((DWORD) CRYPT_E_NOT_IN_CTL != dwError &&
                (DWORD) CRYPT_E_NO_TRUSTED_SIGNER != dwError &&
                (DWORD) CRYPT_E_NO_VERIFY_USAGE_CHECK != dwNewError))
            *pdwError = dwNewError;
    }
}

static BOOL VerifyDefaultUsage(
    IN DWORD dwEncodingType,
    IN DWORD dwSubjectType,
    IN void *pvSubject,
    IN PCTL_USAGE pSubjectUsage,
    IN DWORD dwFlags,
    IN OPTIONAL PCTL_VERIFY_USAGE_PARA pVerifyUsagePara,
    IN OUT PCTL_VERIFY_USAGE_STATUS pVerifyUsageStatus
    )
{
    BOOL fResult;
    DWORD dwError = (DWORD) CRYPT_E_NO_VERIFY_USAGE_DLL;
    LPWSTR pwszDllList;       // _alloca'ed
    DWORD cchDllList;
    DWORD cchDll;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr;

    // Iterate through the installed default functions.
    // Setting pwszDll to NULL searches the installed list. Setting
    // hFuncAddr to NULL starts the search at the beginning.
    hFuncAddr = NULL;
    while (CryptGetDefaultOIDFunctionAddress(
                hUsageFuncSet,
                dwEncodingType,
                NULL,               // pwszDll
                0,                  // dwFlags
                &pvFuncAddr,
                &hFuncAddr)) {
        ZeroUsageStatus(pVerifyUsageStatus);
        fResult = ((PFN_CERT_DLL_VERIFY_CTL_USAGE) pvFuncAddr)(
                dwEncodingType,
                dwSubjectType,
                pvSubject,
                pSubjectUsage,
                dwFlags,
                pVerifyUsagePara,
                pVerifyUsageStatus);
        if (fResult) {
            CryptFreeOIDFunctionAddress(hFuncAddr, 0);
            goto CommonReturn;
        } else
            // Unable to verify usage for this installed
            // function. However, remember any "interesting"
            // errors.
            UpdateUsageError(pVerifyUsageStatus->dwError, &dwError);
    }

    if (!CryptGetDefaultOIDDllList(
            hUsageFuncSet,
            dwEncodingType,
            NULL,               // pszDllList
            &cchDllList)) goto GetDllListError;
    __try {
        pwszDllList = (LPWSTR) _alloca(cchDllList * sizeof(WCHAR));
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        goto OutOfMemory;
    }
    if (!CryptGetDefaultOIDDllList(
            hUsageFuncSet,
            dwEncodingType,
            pwszDllList,
            &cchDllList)) goto GetDllListError;

    for (; 0 != (cchDll = wcslen(pwszDllList)); pwszDllList += cchDll + 1) {
        if (CryptGetDefaultOIDFunctionAddress(
                hUsageFuncSet,
                dwEncodingType,
                pwszDllList,
                0,              // dwFlags
                &pvFuncAddr,
                &hFuncAddr)) {
            ZeroUsageStatus(pVerifyUsageStatus);
            fResult = ((PFN_CERT_DLL_VERIFY_CTL_USAGE) pvFuncAddr)(
                    dwEncodingType,
                    dwSubjectType,
                    pvSubject,
                    pSubjectUsage,
                    dwFlags,
                    pVerifyUsagePara,
                    pVerifyUsageStatus);
            CryptFreeOIDFunctionAddress(hFuncAddr, 0);
            if (fResult)
                goto CommonReturn;
            else
                // Unable to verify usage for this registered
                // function. However, remember any "interesting"
                // errors.
                UpdateUsageError(pVerifyUsageStatus->dwError, &dwError);
        }
    }

    goto ErrorReturn;

CommonReturn:
    return fResult;
ErrorReturn:
    pVerifyUsageStatus->dwError = dwError;
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetDllListError)
TRACE_ERROR(OutOfMemory)
}

static BOOL VerifyOIDUsage(
    IN DWORD dwEncodingType,
    IN DWORD dwSubjectType,
    IN void *pvSubject,
    IN PCTL_USAGE pSubjectUsage,
    IN DWORD dwFlags,
    IN OPTIONAL PCTL_VERIFY_USAGE_PARA pVerifyUsagePara,
    IN OUT PCTL_VERIFY_USAGE_STATUS pVerifyUsageStatus
    )
{
    BOOL fResult;
    HCRYPTOIDFUNCADDR hFuncAddr;
    PVOID pvFuncAddr;

    if (pSubjectUsage && pSubjectUsage->cUsageIdentifier > 0 && 
            CryptGetOIDFunctionAddress(
                hUsageFuncSet,
                dwEncodingType,
                pSubjectUsage->rgpszUsageIdentifier[0],
                0,                                      // dwFlags
                &pvFuncAddr,
                &hFuncAddr)) {
            ZeroUsageStatus(pVerifyUsageStatus);
            fResult = ((PFN_CERT_DLL_VERIFY_CTL_USAGE) pvFuncAddr)(
                        dwEncodingType,
                        dwSubjectType,
                        pvSubject,
                        pSubjectUsage,
                        dwFlags,
                        pVerifyUsagePara,
                        pVerifyUsageStatus);
            CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    } else {
        pVerifyUsageStatus->dwError = CRYPT_E_NO_VERIFY_USAGE_DLL;
        fResult = FALSE;
    }

    return fResult;
}

//+-------------------------------------------------------------------------
//  Verify that a subject is trusted for the specified usage by finding a
//  signed and time valid CTL with the usage identifiers and containing the
//  the subject. A subject can be identified by either its certificate context
//  or any identifier such as its SHA1 hash.
//
//  See CertFindSubjectInCTL for definition of dwSubjectType and pvSubject
//  parameters.
//
//  Via pVerifyUsagePara, the caller can specify the stores to be searched
//  to find the CTL. The caller can also specify the stores containing
//  acceptable CTL signers. By setting the ListIdentifier, the caller
//  can also restrict to a particular signer CTL list.
//
//  Via pVerifyUsageStatus, the CTL containing the subject, the subject's
//  index into the CTL's array of entries, and the signer of the CTL
//  are returned. If the caller is interested, ppCtl and ppSigner can be set
//  to NULL. Returned contexts must be freed via the store's free context APIs.
//
//  If the CERT_VERIFY_INHIBIT_CTL_UPDATE_FLAG isn't set, then, a time
//  invalid CTL in one of the CtlStores may be replaced. When replaced, the
//  CERT_VERIFY_UPDATED_CTL_FLAG is set in pVerifyUsageStatus->dwFlags.
//
//  If the CERT_VERIFY_TRUSTED_SIGNERS_FLAG is set, then, only the
//  SignerStores specified in pVerifyUsageStatus are searched to find
//  the signer. Otherwise, the SignerStores provide additional sources
//  to find the signer's certificate.
//
//  If CERT_VERIFY_NO_TIME_CHECK_FLAG is set, then, the CTLs aren't checked
//  for time validity.
//
//  If CERT_VERIFY_ALLOW_MORE_USAGE_FLAG is set, then, the CTL may contain
//  additional usage identifiers than specified by pSubjectUsage. Otherwise,
//  the found CTL will contain the same usage identifers and no more.
//
//  CertVerifyCTLUsage will be implemented as a dispatcher to OID installable
//  functions. First, it will try to find an OID function matching the first
//  usage object identifier in the pUsage sequence. Next, it will dispatch
//  to the default CertDllVerifyCTLUsage functions.
//
//  If the subject is trusted for the specified usage, then, TRUE is
//  returned. Otherwise, FALSE is returned with dwError set to one of the
//  following:
//      CRYPT_E_NO_VERIFY_USAGE_DLL
//      CRYPT_E_NO_VERIFY_USAGE_CHECK
//      CRYPT_E_VERIFY_USAGE_OFFLINE
//      CRYPT_E_NOT_IN_CTL
//      CRYPT_E_NO_TRUSTED_SIGNER
//--------------------------------------------------------------------------
BOOL
WINAPI
CertVerifyCTLUsage(
    IN DWORD dwEncodingType,
    IN DWORD dwSubjectType,
    IN void *pvSubject,
    IN PCTL_USAGE pSubjectUsage,
    IN DWORD dwFlags,
    IN OPTIONAL PCTL_VERIFY_USAGE_PARA pVerifyUsagePara,
    IN OUT PCTL_VERIFY_USAGE_STATUS pVerifyUsageStatus
    )
{
    BOOL fResult;

    assert(NULL == pVerifyUsagePara || pVerifyUsagePara->cbSize >=
        sizeof(CTL_VERIFY_USAGE_PARA));
    assert(pVerifyUsageStatus && pVerifyUsageStatus->cbSize >=
        sizeof(CTL_VERIFY_USAGE_STATUS));
    if (pVerifyUsagePara && pVerifyUsagePara->cbSize <
            sizeof(CTL_VERIFY_USAGE_PARA))
        goto InvalidArg;
    if (NULL == pVerifyUsageStatus || pVerifyUsageStatus->cbSize <
            sizeof(CTL_VERIFY_USAGE_STATUS))
        goto InvalidArg;


    fResult = VerifyOIDUsage(
        dwEncodingType,
        dwSubjectType,
        pvSubject,
        pSubjectUsage,
        dwFlags,
        pVerifyUsagePara,
        pVerifyUsageStatus);
    if (!fResult) {
        DWORD dwError = pVerifyUsageStatus->dwError;

        fResult = VerifyDefaultUsage(
            dwEncodingType,
            dwSubjectType,
            pvSubject,
            pSubjectUsage,
            dwFlags,
            pVerifyUsagePara,
            pVerifyUsageStatus);
        if (!fResult) {
            UpdateUsageError(pVerifyUsageStatus->dwError, &dwError);
            ZeroUsageStatus(pVerifyUsageStatus);
            pVerifyUsageStatus->dwError = dwError;
            SetLastError(dwError);
        }
    }

CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\certstor\fndchain.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1998
//
//  File:       fndchain.cpp
//
//  Contents:   Find Certificate Chain in Store API
//
//  Functions:  CertFindChainInStore
//              IFC_IsEndCertValidForUsage
//
//  History:    28-Feb-98   philh   created
//--------------------------------------------------------------------------


#include "global.hxx"
#include <dbgdef.h>


BOOL IFC_IsEndCertValidForUsages(
    IN PCCERT_CONTEXT pCert,
    IN PCERT_ENHKEY_USAGE pUsage,
    IN BOOL fOrUsage
    )
{
    BOOL fResult;
    int cNumOIDs;
    LPSTR *ppOIDs = NULL;
    DWORD cbOIDs;

    if (0 == pUsage->cUsageIdentifier)
        goto SuccessReturn;

    cbOIDs = 0;
    if (!CertGetValidUsages(
          1,    // cCerts
          &pCert,
          &cNumOIDs,
          NULL,             // rghOIDs
          &cbOIDs
          )) goto CertGetValidUsagesError;

    if (-1 == cNumOIDs)
        // Cert doesn't have any EKU
        goto SuccessReturn;
    else if (0 == cNumOIDs)
        // Intersection of usages in properties and extensions is NONE
        goto NoMatch;

    assert(cbOIDs);

    if (NULL == (ppOIDs = (LPSTR *) PkiNonzeroAlloc(cbOIDs)))
        goto OutOfMemory;

    if (!CertGetValidUsages(
          1,    // cCerts
          &pCert,
          &cNumOIDs,
          ppOIDs,
          &cbOIDs
          )) goto CertGetValidUsagesError;


    {
        DWORD cId1 = pUsage->cUsageIdentifier;
        LPSTR *ppszId1 = pUsage->rgpszUsageIdentifier;
        for ( ; cId1 > 0; cId1--, ppszId1++) {
            DWORD cId2 = cNumOIDs;
            LPSTR *ppszId2 = ppOIDs;
            for ( ; cId2 > 0; cId2--, ppszId2++) {
                if (0 == strcmp(*ppszId1, *ppszId2)) {
                    if (fOrUsage)
                        goto SuccessReturn;
                    else
                        break;
                }
            }
            if (!fOrUsage && 0 == cId2)
                goto NoMatch;
        }

        if (fOrUsage)
            // For the "OR" option we're here without any match
            goto NoMatch;
        // else
        //  For the "AND" option we have matched all the specified
        //  identifiers
    }

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    PkiFree(ppOIDs);
    return fResult;

NoMatch:
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(CertGetValidUsagesError)
TRACE_ERROR(OutOfMemory)
}

BOOL IFC_IsEndCertValidForUsage(
    IN PCCERT_CONTEXT pCert,
    IN LPCSTR pszUsageIdentifier
    )
{
    CERT_ENHKEY_USAGE Usage = { 1, (LPSTR *) &pszUsageIdentifier};

    return IFC_IsEndCertValidForUsages(
        pCert,
        &Usage,
        TRUE        // fOrUsage
        );
}

BOOL CompareChainIssuerNameBlobs(
    IN DWORD dwCertEncodingType,
    IN DWORD dwFindFlags,
    IN PCERT_CHAIN_FIND_ISSUER_PARA pPara,
    IN PCCERT_CHAIN_CONTEXT pChainContext
    )
{
    DWORD i;
    DWORD cIssuer = pPara->cIssuer;
    PCERT_NAME_BLOB pIssuer = pPara->rgIssuer;

    if (0 == cIssuer)
        return TRUE;

    for (i = 0; i < pChainContext->cChain; i++) {
        DWORD j;
        PCERT_SIMPLE_CHAIN pChain;

        if (0 < i && 0 == (dwFindFlags &
                CERT_CHAIN_FIND_BY_ISSUER_COMPLEX_CHAIN_FLAG))
            return FALSE;

        pChain = pChainContext->rgpChain[i];
        for (j = 0; j < pChain->cElement; j++) {
            DWORD k;
            PCCERT_CONTEXT pCert = pChain->rgpElement[j]->pCertContext;
            PCERT_NAME_BLOB pChainIssuer = &pCert->pCertInfo->Issuer;

            for (k = 0; k < cIssuer; k++) {
                if (CertCompareCertificateName(
                        dwCertEncodingType,
                        pChainIssuer,
                        &pIssuer[k]
                        ))
                    return TRUE;
            }
        }
    }

    return FALSE;
}

static DWORD GetChainKeyIdentifierPropId(
    IN PCCERT_CONTEXT pCert,
    IN DWORD dwKeySpec
    )
{
    DWORD dwPropId;
    PCRYPT_KEY_PROV_INFO pKeyProvInfo = NULL;
    DWORD cbKeyProvInfo;
    BYTE rgbKeyId[MAX_HASH_LEN];
    DWORD cbKeyId;
    CRYPT_HASH_BLOB KeyIdentifier;

    cbKeyId = sizeof(rgbKeyId);
    if (!CertGetCertificateContextProperty(
            pCert,
            CERT_KEY_IDENTIFIER_PROP_ID,
            rgbKeyId,
            &cbKeyId
            ))
        return 0;

    KeyIdentifier.pbData = rgbKeyId;
    KeyIdentifier.cbData = cbKeyId;

    if (!CryptGetKeyIdentifierProperty(
            &KeyIdentifier,
            CERT_KEY_PROV_INFO_PROP_ID,
            CRYPT_KEYID_ALLOC_FLAG,
            NULL,                           // pwszComputerName
            NULL,                           // pvReserved
            (void *) &pKeyProvInfo,
            &cbKeyProvInfo
            )) {
        // Try again, searching LocalMachine
        if (!CryptGetKeyIdentifierProperty(
                &KeyIdentifier,
                CERT_KEY_PROV_INFO_PROP_ID,
                CRYPT_KEYID_ALLOC_FLAG | CRYPT_KEYID_MACHINE_FLAG,
                NULL,                           // pwszComputerName
                NULL,                           // pvReserved
                (void *) &pKeyProvInfo,
                &cbKeyProvInfo
                ))
            return 0;
    }

    if (dwKeySpec && dwKeySpec != pKeyProvInfo->dwKeySpec)
        dwPropId = 0;
    else
        dwPropId = CERT_KEY_PROV_INFO_PROP_ID;

    PkiDefaultCryptFree(pKeyProvInfo);
    return dwPropId;
}

DWORD GetChainPrivateKeyPropId(
    IN PCCERT_CONTEXT pCert,
    IN DWORD dwKeySpec
    )
{
    DWORD dwPropId;
    CERT_KEY_CONTEXT KeyContext;
    PCRYPT_KEY_PROV_INFO pKeyProvInfo = NULL;
    DWORD cbProp;

    cbProp = sizeof(KeyContext);
    if (CertGetCertificateContextProperty(
            pCert,
            CERT_KEY_CONTEXT_PROP_ID,
            &KeyContext,
            &cbProp
            )) {
        assert(sizeof(KeyContext) <= cbProp);
        if (dwKeySpec && dwKeySpec != KeyContext.dwKeySpec)
            return 0;
        else
            return CERT_KEY_CONTEXT_PROP_ID;
    }

    if (!CertGetCertificateContextProperty(
            pCert,
            CERT_KEY_PROV_INFO_PROP_ID,
            NULL,                       // pvData
            &cbProp
            ))
        return 0;

    if (NULL == (pKeyProvInfo = (PCRYPT_KEY_PROV_INFO) PkiNonzeroAlloc(
            cbProp)))
        goto OutOfMemory;

    if (!CertGetCertificateContextProperty(
            pCert,
            CERT_KEY_PROV_INFO_PROP_ID,
            pKeyProvInfo,
            &cbProp
            )) goto CertGetCertificateContextPropertyError;

    if (dwKeySpec && dwKeySpec != pKeyProvInfo->dwKeySpec)
        goto NoMatch;

    dwPropId = CERT_KEY_PROV_INFO_PROP_ID;

CommonReturn:
    PkiFree(pKeyProvInfo);
    return dwPropId;

NoMatch:
ErrorReturn:
    dwPropId = 0;
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
TRACE_ERROR(CertGetCertificateContextPropertyError)
}

BOOL FindChainByIssuer(
    IN DWORD dwCertEncodingType,
    IN DWORD dwFindFlags,
    IN PCERT_CHAIN_FIND_ISSUER_PARA pPara,
    IN PCCERT_CONTEXT pCert,
    OUT PCCERT_CHAIN_CONTEXT *ppChainContext
    )
{
    BOOL fResult = TRUE;
    PCCERT_CHAIN_CONTEXT pChainContext = NULL;
    DWORD dwPrivateKeyPropId;
    CERT_CHAIN_PARA ChainPara;
    DWORD dwCreateChainFlags;

    if (NULL == pPara ||
            offsetof(CERT_CHAIN_FIND_BY_ISSUER_PARA, pvFindArg) >
                pPara->cbSize) {
        fResult = FALSE;
        goto InvalidArg;
    }

    if (dwFindFlags & CERT_CHAIN_FIND_BY_ISSUER_NO_KEY_FLAG)
        dwPrivateKeyPropId = CERT_KEY_CONTEXT_PROP_ID;
    else if (0 == (dwPrivateKeyPropId = GetChainPrivateKeyPropId(
            pCert,
            pPara->dwKeySpec
            ))) {
        if (0 == (dwPrivateKeyPropId = GetChainKeyIdentifierPropId(
                pCert,
                pPara->dwKeySpec
                )))
            goto NoMatch;
    }

    if (pPara->pszUsageIdentifier) {
        if (!IFC_IsEndCertValidForUsage(
                pCert,
                pPara->pszUsageIdentifier
                )) goto NoMatch;
    }

    if (pPara->pfnFindCallback) {
        if (!pPara->pfnFindCallback(
                pCert,
                pPara->pvFindArg
                )) goto NoMatch;
    }

    memset(&ChainPara, 0, sizeof(ChainPara));
    ChainPara.cbSize = sizeof(ChainPara);
    if (pPara->pszUsageIdentifier) {
        ChainPara.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;
        ChainPara.RequestedUsage.Usage.cUsageIdentifier = 1;
        ChainPara.RequestedUsage.Usage.rgpszUsageIdentifier =
            (LPSTR *) &pPara->pszUsageIdentifier;
    }

    dwCreateChainFlags = 0;
    if (dwFindFlags & CERT_CHAIN_FIND_BY_ISSUER_CACHE_ONLY_URL_FLAG)
        dwCreateChainFlags |= CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL;
    if (dwFindFlags & CERT_CHAIN_FIND_BY_ISSUER_LOCAL_MACHINE_FLAG)
        dwCreateChainFlags |= CERT_CHAIN_USE_LOCAL_MACHINE_STORE;

    if (!CertGetCertificateChain(
            NULL,                   // hChainEngine
            pCert,
            NULL,                   // pTime
            dwFindFlags & CERT_CHAIN_FIND_BY_ISSUER_CACHE_ONLY_FLAG ?
                0 : pCert->hCertStore,
            &ChainPara,
            dwCreateChainFlags,
            NULL,                   // pvReserved
            &pChainContext
            )) goto CertGetCertificateChainError;

    if (!CompareChainIssuerNameBlobs(
            dwCertEncodingType,
            dwFindFlags,
            pPara,
            pChainContext
            )) goto NoMatch;


    if (dwFindFlags & CERT_CHAIN_FIND_BY_ISSUER_COMPARE_KEY_FLAG) {
        if (CERT_KEY_CONTEXT_PROP_ID != dwPrivateKeyPropId) {
            DWORD dwAcquireFlags = pPara->dwAcquirePrivateKeyFlags |
                CRYPT_ACQUIRE_COMPARE_KEY_FLAG;
            HCRYPTPROV hProv;
            BOOL fCallerFreeProv;

            if (!CryptAcquireCertificatePrivateKey(
                    pCert,
                    dwAcquireFlags,
                    NULL,               // pvReserved
                    &hProv,
                    NULL,               // pdwKeySpec
                    &fCallerFreeProv
                    )) goto CryptAcquireCertificatePrivateKeyError;

            if (fCallerFreeProv)
                CryptReleaseContext(hProv, 0);
        }
    }


CommonReturn:
    *ppChainContext = pChainContext;
    return fResult;

NoMatch:
ErrorReturn:
    if (pChainContext) {
        CertFreeCertificateChain(pChainContext);
        pChainContext = NULL;
    }
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(CertGetCertificateChainError)
TRACE_ERROR(CryptAcquireCertificatePrivateKeyError)
}
    

PCCERT_CHAIN_CONTEXT
WINAPI
CertFindChainInStore(
    IN HCERTSTORE hCertStore,
    IN DWORD dwCertEncodingType,
    IN DWORD dwFindFlags,
    IN DWORD dwFindType,
    IN const void *pvFindPara,
    IN PCCERT_CHAIN_CONTEXT pPrevChainContext
    )
{
    PCCERT_CONTEXT pCert = NULL;
    PCCERT_CHAIN_CONTEXT pChainContext = NULL;

    if (0 == dwCertEncodingType)
        dwCertEncodingType = X509_ASN_ENCODING;

    if (pPrevChainContext) {
        if (pPrevChainContext->cChain) {
            PCERT_SIMPLE_CHAIN pChain = pPrevChainContext->rgpChain[0];
            if (pChain->cElement)
                pCert = CertDuplicateCertificateContext(
                    pChain->rgpElement[0]->pCertContext);
        }
        CertFreeCertificateChain(pPrevChainContext);
    }

    while (pCert = CertEnumCertificatesInStore(hCertStore, pCert)) {
        switch (dwFindType) {
            case CERT_CHAIN_FIND_BY_ISSUER:
                if (!FindChainByIssuer(
                        dwCertEncodingType,
                        dwFindFlags,
                        (PCERT_CHAIN_FIND_ISSUER_PARA) pvFindPara,
                        pCert,
                        &pChainContext
                        )) goto FindChainByIssuerError;
                if (pChainContext)
                    goto CommonReturn;
                break;
            default:
                goto InvalidArg;
        }
    }

    SetLastError((DWORD) CRYPT_E_NOT_FOUND);

CommonReturn:
    if (pCert)
        CertFreeCertificateContext(pCert);
    return pChainContext;
ErrorReturn:
    goto CommonReturn;
SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(FindChainByIssuerError)
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\certstor\ekuhlpr.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       ekuhlpr.h
//
//  Contents:   Certificate Enhanced Key Usage Helper API implementation
//
//  History:    22-May-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__EKUHLPR_H__)
#define __EKUHLPR_H__

PCRYPT_OBJID_BLOB EkuGetExtension (
                        PCCERT_CONTEXT pCertContext
                        );

HRESULT EkuGetProperty (
              PCCERT_CONTEXT    pCertContext,
              PCRYPT_OBJID_BLOB pEkuBlob
              );

HRESULT EkuSetProperty (
              PCCERT_CONTEXT    pCertContext,
              PCRYPT_OBJID_BLOB pEkuBlob
              );

HRESULT EkuGetDecodedSize (
              PCRYPT_OBJID_BLOB pEkuBlob,
              DWORD*            pcbSize
              );

HRESULT EkuGetDecodedUsageSizes (
              PCRYPT_OBJID_BLOB pExtBlob,
              PCRYPT_OBJID_BLOB pPropBlob,
              DWORD*            pcbSize,
              DWORD*            pcbExtSize,
              DWORD*            pcbPropSize
              );

HRESULT EkuGetDecodedUsage (
              PCRYPT_OBJID_BLOB  pEkuBlob,
              DWORD*             pcbSize,
              PCERT_ENHKEY_USAGE pUsage
              );

HRESULT EkuMergeUsage (
              DWORD              cbSize1,
              PCERT_ENHKEY_USAGE pUsage1,
              DWORD              cbSize2,
              PCERT_ENHKEY_USAGE pUsage2,
              DWORD              cbSizeM,
              PCERT_ENHKEY_USAGE pUsageM
              );

HRESULT EkuGetMergedDecodedUsage (
              PCRYPT_OBJID_BLOB  pExtBlob,
              PCRYPT_OBJID_BLOB  pPropBlob,
              DWORD*             pcbSize,
              PCERT_ENHKEY_USAGE pUsage
              );

HRESULT EkuEncodeUsage (
              PCERT_ENHKEY_USAGE pUsage,
              PCRYPT_OBJID_BLOB  pEkuBlob
              );

HRESULT EkuGetUsage (
              PCCERT_CONTEXT      pCertContext,
              DWORD               dwFlags,
              DWORD*              pcbSize,
              PCERT_ENHKEY_USAGE* ppUsage
              );

#define CERT_FIND_ALL_ENHKEY_USAGE_FLAG (CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG |\
                                         CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG)

BOOL
EkuGetIntersectedUsageViaGetValidUsages (
   PCCERT_CONTEXT pCertContext,
   DWORD* pcbSize,
   PCERT_ENHKEY_USAGE pUsage
   );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\certstor\memory.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       memory.cpp
//
//  Contents:   Crypt32 Memory Management Routines
//
//  History:    22-Jul-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
//+---------------------------------------------------------------------------
//
//  Function:   CryptMemAlloc
//
//  Synopsis:   Allocates memory
//
//----------------------------------------------------------------------------
LPVOID WINAPI CryptMemAlloc (
                   IN ULONG cbSize
                   )
{
    return( malloc( cbSize ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CryptMemRealloc
//
//  Synopsis:   reallocates memory
//
//----------------------------------------------------------------------------
LPVOID WINAPI CryptMemRealloc (
                   IN LPVOID pv,
                   IN ULONG cbSize
                   )
{
    return( realloc( pv, cbSize ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CryptMemFree
//
//  Synopsis:   free memory
//
//----------------------------------------------------------------------------
VOID WINAPI CryptMemFree (
                 IN LPVOID pv
                 )
{
    free( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\certstor\frmtfunc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1997
//
//  File:       frmtfunc.cpp
//
//  Contents:   OID format functions
//
//  Functions:  CryptFrmtFuncDllMain
//              CryptFormatObject
//              CryptQueryObject
//
//  History:    15-05-97    xiaohs   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>
#include "frmtfunc.h"

HMODULE hFrmtFuncInst;

static HCRYPTOIDFUNCSET hFormatFuncSet;



//function type define
typedef BOOL (WINAPI *PFN_FORMAT_FUNC)(
	IN DWORD dwCertEncodingType,
    IN DWORD dwFormatType,
	IN DWORD dwFormatStrType,
	IN void	 *pFormatStruct,
    IN LPCSTR lpszStructType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
	OUT void *pbFormat,
    IN OUT DWORD *pcbFormat
    );

static BOOL
WINAPI
FormatBytesToHex(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);


static BOOL	
WINAPI	
CryptDllFormatAttr(
				DWORD		dwEncodingType,	
				DWORD		dwFormatType,
				DWORD		dwFormatStrType,
				void		*pStruct,
				LPCSTR		lpszStructType,
				const BYTE	*pbEncoded,
				DWORD		cbEncoded,
				void		*pBuffer,
				DWORD		*pcBuffer);


static BOOL	
WINAPI	
CryptDllFormatName(
				DWORD		dwEncodingType,	
				DWORD		dwFormatType,
				DWORD		dwFormatStrType,
				void		*pStruct,
				LPCSTR		lpszStructType,
				const BYTE	*pbEncoded,
				DWORD		cbEncoded,
				void		*pbBuffer,
				DWORD		*pcbBuffer);

static BOOL
WINAPI
FormatBasicConstraints2(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

static BOOL
WINAPI
FormatBasicConstraints(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);


static BOOL
WINAPI
FormatCRLReasonCode(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

static BOOL
WINAPI
FormatEnhancedKeyUsage(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);


static BOOL
WINAPI
FormatAltName(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

static BOOL
WINAPI
FormatAuthorityKeyID(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

static BOOL
WINAPI
FormatAuthorityKeyID2(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

static BOOL
WINAPI
FormatNextUpdateLocation(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

static BOOL
WINAPI
FormatSubjectKeyID(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

static BOOL
WINAPI
FormatFinancialCriteria(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);


static BOOL
WINAPI
FormatSMIMECapabilities(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

static BOOL
WINAPI
FormatKeyUsage(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);


static BOOL
WINAPI
FormatAuthortiyInfoAccess(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

static BOOL
WINAPI
FormatKeyAttributes(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);


static BOOL
WINAPI
FormatKeyRestriction(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

static BOOL
WINAPI
FormatCRLDistPoints(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

static BOOL
WINAPI
FormatCertPolicies(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);

static BOOL
WINAPI
FormatSPAgencyInfo(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat);


static const CRYPT_OID_FUNC_ENTRY DefaultFormatTable[] = {
    CRYPT_DEFAULT_OID, FormatBytesToHex};

static const CRYPT_OID_FUNC_ENTRY OIDFormatTable[] = {
				szOID_COMMON_NAME,						CryptDllFormatAttr,	
				szOID_SUR_NAME,                      	CryptDllFormatAttr,
				szOID_DEVICE_SERIAL_NUMBER,          	CryptDllFormatAttr,
				szOID_COUNTRY_NAME,                  	CryptDllFormatAttr,
				szOID_LOCALITY_NAME,                 	CryptDllFormatAttr,
				szOID_STATE_OR_PROVINCE_NAME,        	CryptDllFormatAttr,
				szOID_STREET_ADDRESS,                	CryptDllFormatAttr,
				szOID_ORGANIZATION_NAME,             	CryptDllFormatAttr,
				szOID_ORGANIZATIONAL_UNIT_NAME,      	CryptDllFormatAttr,
				szOID_TITLE,                         	CryptDllFormatAttr,
				szOID_DESCRIPTION,                   	CryptDllFormatAttr,
				szOID_SEARCH_GUIDE,                  	CryptDllFormatAttr,
				szOID_BUSINESS_CATEGORY,             	CryptDllFormatAttr,
				szOID_POSTAL_ADDRESS,                	CryptDllFormatAttr,
				szOID_POSTAL_CODE,                   	CryptDllFormatAttr,
				szOID_POST_OFFICE_BOX,               	CryptDllFormatAttr,
				szOID_PHYSICAL_DELIVERY_OFFICE_NAME, 	CryptDllFormatAttr,
				szOID_TELEPHONE_NUMBER,              	CryptDllFormatAttr,
				szOID_TELEX_NUMBER,                  	CryptDllFormatAttr,
				szOID_TELETEXT_TERMINAL_IDENTIFIER,  	CryptDllFormatAttr,
				szOID_FACSIMILE_TELEPHONE_NUMBER,    	CryptDllFormatAttr,
				szOID_X21_ADDRESS,                   	CryptDllFormatAttr,
				szOID_INTERNATIONAL_ISDN_NUMBER,     	CryptDllFormatAttr,
				szOID_REGISTERED_ADDRESS,            	CryptDllFormatAttr,
				szOID_DESTINATION_INDICATOR,         	CryptDllFormatAttr,
				szOID_PREFERRED_DELIVERY_METHOD,     	CryptDllFormatAttr,
				szOID_PRESENTATION_ADDRESS,          	CryptDllFormatAttr,
				szOID_SUPPORTED_APPLICATION_CONTEXT, 	CryptDllFormatAttr,
				szOID_MEMBER,                        	CryptDllFormatAttr,
				szOID_OWNER,                         	CryptDllFormatAttr,
				szOID_ROLE_OCCUPANT,                 	CryptDllFormatAttr,
				szOID_SEE_ALSO,                      	CryptDllFormatAttr,
				szOID_USER_PASSWORD,                 	CryptDllFormatAttr,
				szOID_USER_CERTIFICATE,              	CryptDllFormatAttr,
				szOID_CA_CERTIFICATE,                	CryptDllFormatAttr,
				szOID_AUTHORITY_REVOCATION_LIST,     	CryptDllFormatAttr,
				szOID_CERTIFICATE_REVOCATION_LIST,   	CryptDllFormatAttr,
				szOID_CROSS_CERTIFICATE_PAIR,        	CryptDllFormatAttr,
				szOID_GIVEN_NAME,                    	CryptDllFormatAttr,
				szOID_INITIALS,                     	CryptDllFormatAttr,
                szOID_DOMAIN_COMPONENT,                 CryptDllFormatAttr,
                szOID_PKCS_12_FRIENDLY_NAME_ATTR,       CryptDllFormatAttr,
                szOID_PKCS_12_LOCAL_KEY_ID,             CryptDllFormatAttr,
				X509_NAME,								CryptDllFormatName,
				X509_UNICODE_NAME,						CryptDllFormatName,
				szOID_BASIC_CONSTRAINTS2,				FormatBasicConstraints2,
				X509_BASIC_CONSTRAINTS2,				FormatBasicConstraints2,
                szOID_BASIC_CONSTRAINTS,                FormatBasicConstraints,
                X509_BASIC_CONSTRAINTS,                 FormatBasicConstraints,
				szOID_CRL_REASON_CODE,					FormatCRLReasonCode,
				X509_CRL_REASON_CODE,					FormatCRLReasonCode,
				szOID_ENHANCED_KEY_USAGE,				FormatEnhancedKeyUsage,
				X509_ENHANCED_KEY_USAGE,				FormatEnhancedKeyUsage,
                szOID_SUBJECT_ALT_NAME,                 FormatAltName,
                szOID_ISSUER_ALT_NAME,                  FormatAltName,
                szOID_SUBJECT_ALT_NAME2,                FormatAltName,
                szOID_ISSUER_ALT_NAME2,                 FormatAltName,
                X509_ALTERNATE_NAME,                    FormatAltName,
                szOID_AUTHORITY_KEY_IDENTIFIER,         FormatAuthorityKeyID,
                X509_AUTHORITY_KEY_ID,                  FormatAuthorityKeyID,
                szOID_AUTHORITY_KEY_IDENTIFIER2,        FormatAuthorityKeyID2,
                X509_AUTHORITY_KEY_ID2,                 FormatAuthorityKeyID2,
                szOID_NEXT_UPDATE_LOCATION,             FormatNextUpdateLocation,
                szOID_SUBJECT_KEY_IDENTIFIER,           FormatSubjectKeyID,
                SPC_FINANCIAL_CRITERIA_OBJID,           FormatFinancialCriteria,
                SPC_FINANCIAL_CRITERIA_STRUCT,          FormatFinancialCriteria,
                szOID_RSA_SMIMECapabilities,            FormatSMIMECapabilities,
                PKCS_SMIME_CAPABILITIES,                FormatSMIMECapabilities,
                szOID_KEY_USAGE,                        FormatKeyUsage,
                X509_KEY_USAGE,                         FormatKeyUsage,
                szOID_AUTHORITY_INFO_ACCESS,            FormatAuthortiyInfoAccess,
                X509_AUTHORITY_INFO_ACCESS,             FormatAuthortiyInfoAccess,
                szOID_KEY_ATTRIBUTES,                   FormatKeyAttributes,
                X509_KEY_ATTRIBUTES,                    FormatKeyAttributes,
                szOID_KEY_USAGE_RESTRICTION,            FormatKeyRestriction,
                X509_KEY_USAGE_RESTRICTION,             FormatKeyRestriction,
                szOID_CRL_DIST_POINTS,                  FormatCRLDistPoints,
                X509_CRL_DIST_POINTS,                   FormatCRLDistPoints,
                szOID_CERT_POLICIES,                    FormatCertPolicies,
                X509_CERT_POLICIES,                     FormatCertPolicies,
				SPC_SP_AGENCY_INFO_OBJID,               FormatSPAgencyInfo,
                SPC_SP_AGENCY_INFO_STRUCT,              FormatSPAgencyInfo,
};

DWORD	dwOIDFormatCount=sizeof(OIDFormatTable)/sizeof(OIDFormatTable[0]);

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptFrmtFuncDllMain(
        HMODULE hModule,
        DWORD  fdwReason,
        LPVOID lpReserved)
{
    BOOL    fRet;

    switch (fdwReason) {
    case DLL_PROCESS_ATTACH:

		hFrmtFuncInst = hModule;

        if (NULL == (hFormatFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_FORMAT_OBJECT_FUNC,
                0)))                                // dwFlags
            goto CryptInitFrmtFuncError;

		//install the default formatting routine
		if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CRYPT_OID_FORMAT_OBJECT_FUNC,
                1,
                DefaultFormatTable,
                0))                         // dwFlags
            goto CryptInstallFrmtFuncError;

		//install the OID formatting routine
		if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CRYPT_OID_FORMAT_OBJECT_FUNC,
                dwOIDFormatCount,
                OIDFormatTable,
                0))                         // dwFlags
            goto CryptInstallFrmtFuncError;


		break;

    case DLL_PROCESS_DETACH:
    case DLL_THREAD_DETACH:
    default:
        break;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(CryptInitFrmtFuncError)
TRACE_ERROR(CryptInstallFrmtFuncError)
}


//------------------------------------------------------------------------
//	   Convert the byte to its Hex presentation.
//
//	   Precondition: byte is less than 15
//
//------------------------------------------------------------------------
ULONG	ByteToHex(BYTE	byte,	LPWSTR	wszZero, LPWSTR wszA)
{
	ULONG	uValue=0;

	if(((ULONG)byte)<=9)
	{
		uValue=((ULONG)byte)+ULONG(*wszZero);	
	}
	else
	{
		uValue=(ULONG)byte-10+ULONG(*wszA);

	}

	return uValue;

}
//--------------------------------------------------------------------------
//
//	 Format the encoded bytes into a hex string in the format of
//   xxxx xxxx xxxx xxxx ...
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatBytesToHex(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	LPWSTR	pwszBuffer=NULL;
	DWORD	dwBufferSize=0;
	DWORD	dwBufferIndex=0;
	DWORD	dwEncodedIndex=0;
	WCHAR	wszSpace[CHAR_SIZE];
	WCHAR	wszZero[CHAR_SIZE];
	WCHAR	wszA[CHAR_SIZE];
	WCHAR	wszHex[HEX_SIZE];
	
	//check for input parameters
	if(( pbEncoded!=NULL && cbEncoded==0)
		||(pbEncoded==NULL && cbEncoded!=0)
		|| (pcbFormat==NULL))
	{
		SetLastError(E_INVALIDARG);
		return FALSE;
	}

	//check for simple case.  No work needed
	if(pbEncoded==NULL && cbEncoded==0)
	{
		*pcbFormat=0;
		return TRUE;
	}


	//calculate the memory needed, in bytes
	//we need 3 wchars per byte, along with the NULL terminator
	dwBufferSize=sizeof(WCHAR)*(cbEncoded*3+1);


	//length only calculation
	if(pcbFormat!=NULL && pbFormat==NULL)
	{
		*pcbFormat=dwBufferSize;
		return TRUE;
	}

	//load the string
	if(!LoadStringU(hFrmtFuncInst, IDS_FRMT_SPACE, wszSpace,
		CHAR_SIZE)
	  ||!LoadStringU(hFrmtFuncInst, IDS_FRMT_ZERO, wszZero,
	    CHAR_SIZE)
	  ||!LoadStringU(hFrmtFuncInst, IDS_FRMT_A, wszA,
	   CHAR_SIZE)
	  ||!LoadStringU(hFrmtFuncInst, IDS_FRMT_HEX, wszHex,
	  HEX_SIZE)
	  )
	{
		SetLastError(E_UNEXPECTED);
		return FALSE;
	}

	pwszBuffer=(LPWSTR)malloc(dwBufferSize);

	if(!pwszBuffer)
	{
		SetLastError(E_OUTOFMEMORY);
		return FALSE;
	}

	dwBufferIndex=0;

	//format the wchar buffer one byte at a time
	for(dwEncodedIndex=0; dwEncodedIndex<cbEncoded; dwEncodedIndex++)
	{
		//copy the space between every two bytes.  Skip for the 1st byte
        if((0!=dwEncodedIndex) && (0==(dwEncodedIndex % 2 )))
        {
		    pwszBuffer[dwBufferIndex]=wszSpace[0];
		    dwBufferIndex++;
        }


		//format the higher 4 bits
		pwszBuffer[dwBufferIndex]=(WCHAR)ByteToHex(
			 (pbEncoded[dwEncodedIndex]&UPPER_BITS)>>4,
			 wszZero, wszA);

		dwBufferIndex++;

		//format the lower 4 bits
		pwszBuffer[dwBufferIndex]=(WCHAR)ByteToHex(
			 pbEncoded[dwEncodedIndex]&LOWER_BITS,
			 wszZero, wszA);

		dwBufferIndex++;

	}

	//add the NULL terminator to the string
	pwszBuffer[dwBufferIndex]=wszSpace[1];

    //calculate the real size for the buffer
    dwBufferSize=sizeof(WCHAR)*(wcslen(pwszBuffer)+1);

	//copy the buffer
	memcpy(pbFormat, pwszBuffer,
		(*pcbFormat>=dwBufferSize) ? dwBufferSize : *pcbFormat);

	free(pwszBuffer);

	//make sure the user has supplied enough memory
	if(*pcbFormat < dwBufferSize)
	{
		*pcbFormat=dwBufferSize;
		SetLastError(ERROR_MORE_DATA);
		return FALSE;
	}
		
	*pcbFormat=dwBufferSize;
	return TRUE;
}


 //+-------------------------------------------------------------------------
// format the specified data structure according to the certificate
// encoding type.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptFormatObject(
    IN DWORD dwCertEncodingType,
    IN DWORD dwFormatType,
	IN DWORD dwFormatStrType,
	IN void	 *pFormatStruct,
    IN LPCSTR lpszStructType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
	OUT void *pbFormat,
    IN OUT DWORD *pcbFormat
    )
{
    BOOL				fResult=FALSE;
    void				*pvFuncAddr;
    HCRYPTOIDFUNCADDR   hFuncAddr;

    if (CryptGetOIDFunctionAddress(
            hFormatFuncSet,
            dwCertEncodingType,
            lpszStructType,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr))
	{
        fResult = ((PFN_FORMAT_FUNC) pvFuncAddr)(
				dwCertEncodingType,
				dwFormatType,
				dwFormatStrType,
				pFormatStruct,
				lpszStructType,
				pbEncoded,
				cbEncoded,
				pbFormat,
				pcbFormat
            );
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    }
	else
	{
        //do not call the default hex dump if CRYPT_FORMAT_STR_NO_HEX is set
        if(0==(dwFormatStrType & CRYPT_FORMAT_STR_NO_HEX))
        {
		    //call the default routine automatically
		    if (CryptGetOIDFunctionAddress(
                hFormatFuncSet,
                dwCertEncodingType,
                CRYPT_DEFAULT_OID,
                0,                      // dwFlags
                &pvFuncAddr,
                &hFuncAddr))
		    {
			    fResult = ((PFN_FORMAT_FUNC) pvFuncAddr)(
					dwCertEncodingType,
					dwFormatType,
					dwFormatStrType,
					pFormatStruct,
					lpszStructType,
					pbEncoded,
					cbEncoded,
					pbFormat,
					pcbFormat);

			    CryptFreeOIDFunctionAddress(hFuncAddr, 0);
		    }
            else
            {
			    *pcbFormat = 0;
			    fResult = FALSE;
            }
        }
		else
		{
			*pcbFormat = 0;
			fResult = FALSE;
		}
	}
    return fResult;
}



//-----------------------------------------------------------
//
//  This is the actual format routine for an particular RDN attribute.
//
//	lpszStructType is any OID for CERT_RDN_ATTR.  pbEncoded is
//	an encoded BLOB for CERT_NAME_INFO struct.  When pBuffer==NULL,
//	*pcbBuffer return the size of memory to be allocated in bytes.
//	Please notice the string is not NULL terminated.
//
//	For example, to ask for an unicode string of common name,
//	pass lpszStructType=szOID_COMMON_NAME,
//	pass dwFormatType==CRYPT_FORMAT_SIMPL,
//  pBuffer will be set the L"xiaohs@microsoft.com".
//
//
//-------------------------------------------------------------
static BOOL	WINAPI	CryptDllFormatAttr(
				DWORD		dwEncodingType,	
				DWORD		dwFormatType,
				DWORD		dwFormatStrType,
				void		*pStruct,
				LPCSTR		lpszStructType,
				const BYTE	*pbEncoded,
				DWORD		cbEncoded,
				void		*pBuffer,
				DWORD		*pcbBuffer)
{
		BOOL		fResult=FALSE;
		WCHAR		*pwszSeperator=NULL;
		BOOL		fHeader=FALSE;
		BOOL		fLengthOnly=FALSE;
		DWORD		dwBufferCount=0;
		DWORD		dwBufferLimit=0;
		DWORD		dwBufferIncrement=0;
		DWORD		dwSeperator=0;
		DWORD		dwHeader=0;
		DWORD		dwIndex=0;
		DWORD		dwOIDSize=0;
		WCHAR		*pwszBuffer=NULL;
		WCHAR		*pwszHeader=NULL;
		BOOL		fAddSeperator=FALSE;


		DWORD			cbStructInfo=0;
		CERT_NAME_INFO	*pStructInfo=NULL;
		DWORD			dwRDNIndex=0;
		DWORD			dwAttrIndex=0;
		DWORD			dwAttrCount=0;
		CERT_RDN_ATTR	*pCertRDNAttr=NULL;
		PCCRYPT_OID_INFO pOIDInfo=NULL;

		
		//check input parameters
		if(lpszStructType==NULL ||
			(pbEncoded==NULL && cbEncoded!=0) ||
			pcbBuffer==NULL	
		  )
			goto InvalidArg;

		if(cbEncoded==0)
		{
			*pcbBuffer=0;
			goto InvalidArg;
		}

		//get the seperator of the attributes
		//wszCOMMA is the default seperator
		if(dwFormatType & CRYPT_FORMAT_COMMA)
			pwszSeperator=wszCOMMA;
		else
		{
			if(dwFormatType & CRYPT_FORMAT_SEMICOLON)
				pwszSeperator=wszSEMICOLON;
			else
			{
				if(dwFormatType & CRYPT_FORMAT_CRLF)
					pwszSeperator=wszCRLF;
				else
                {
					pwszSeperator=wszPLUS;
                }
			}
		}

		//calculate the length of the seperator
		dwSeperator=wcslen(pwszSeperator)*sizeof(WCHAR);

		//check the requirement for the header
		if(dwFormatType & CRYPT_FORMAT_X509 ||
			dwFormatType & CRYPT_FORMAT_OID)
		{	
			fHeader=TRUE;
		}


		if(NULL==pBuffer)
			fLengthOnly=TRUE;

		//decode the X509_UNICODE_NAME
		if(!CryptDecodeObject(dwEncodingType, X509_UNICODE_NAME,
			pbEncoded, cbEncoded, CRYPT_DECODE_NOCOPY_FLAG,
			NULL, &cbStructInfo))
			goto DecodeError;

		//allocate memory
		pStructInfo=(CERT_NAME_INFO *)malloc(cbStructInfo);
		if(!pStructInfo)
			goto MemoryError;	

		//decode the struct
 		if(!CryptDecodeObject(dwEncodingType, X509_UNICODE_NAME,
			pbEncoded, cbEncoded, CRYPT_DECODE_NOCOPY_FLAG,
			pStructInfo, &cbStructInfo))
			goto DecodeError;


		 //allocate the buffer for formatting
		if(!fLengthOnly)
		{
			pwszBuffer=(WCHAR *)malloc(g_AllocateSize);
			if(!pwszBuffer)
				goto MemoryError;
				
			dwBufferLimit=g_AllocateSize;
		}

	   	//search for the OID requested.  If found one, put it
		//to the buffer.  If no requested attribut is found,
		//return.
		for(dwRDNIndex=0; dwRDNIndex<pStructInfo->cRDN; dwRDNIndex++)
		{
			//the following line is for code optimization
			dwAttrCount=(pStructInfo->rgRDN)[dwRDNIndex].cRDNAttr;

			for(dwAttrIndex=0; dwAttrIndex<dwAttrCount; dwAttrIndex++)
			{
				//look for the specific OIDs in the function
				if(_stricmp(lpszStructType,
				(pStructInfo->rgRDN)[dwRDNIndex].rgRDNAttr[dwAttrIndex].pszObjId)==0)
				{
					pCertRDNAttr=&((pStructInfo->rgRDN)[dwRDNIndex].rgRDNAttr[dwAttrIndex]);

					//init the dwBufferIncrement
					dwBufferIncrement=0;

					//get the header of the tag
					if(fHeader)
					{
						if(dwFormatType & CRYPT_FORMAT_X509)
						{
							//get the OID's name
							pOIDInfo=CryptFindOIDInfo(CRYPT_OID_INFO_OID_KEY,
														  (void *)lpszStructType,
														  CRYPT_RDN_ATTR_OID_GROUP_ID);

							if(pOIDInfo)
							{
								//allocate memory, including the NULL terminator
								pwszHeader=(WCHAR *)malloc((wcslen(pOIDInfo->pwszName)+wcslen(wszEQUAL)+1)*
									sizeof(WCHAR));

								if(!pwszHeader)
									goto MemoryError;

								wcscpy(pwszHeader,pOIDInfo->pwszName);

							}
						}

						//use the OID is no mapping is found or
						//OID is requested in the header
						if(pwszHeader==NULL)
						{

							//get the wide character string to the OID
							if(!(dwOIDSize=MultiByteToWideChar(CP_ACP,0,
							lpszStructType,strlen(lpszStructType),NULL,0)))
								goto szTOwszError;

							//allocate memory, including the NULL terminator
							pwszHeader=(WCHAR *)malloc((dwOIDSize+wcslen(wszEQUAL)+1)*
										sizeof(WCHAR));

							if(!pwszHeader)
								goto MemoryError;

							if(!(dwHeader=MultiByteToWideChar(CP_ACP,0,
							lpszStructType,strlen(lpszStructType),pwszHeader,dwOIDSize)))
								 goto szTOwszError;

							//NULL terminate the string
							*(pwszHeader+dwHeader)=L'\0';
							
						}

						//add the euqal sign
						wcscat(pwszHeader,	wszEQUAL);

						//get the header size, in bytes, excluding the NULL terminator
						dwHeader=wcslen(pwszHeader)*sizeof(WCHAR);
						dwBufferIncrement+=dwHeader;
					}


					//allocate enough memory.  Including the NULL terminator
					dwBufferIncrement+=pCertRDNAttr->Value.cbData;
					dwBufferIncrement+=dwSeperator;
					dwBufferIncrement+=2;
	

					if(!fLengthOnly && ((dwBufferCount+dwBufferIncrement)>dwBufferLimit))
					{
					   //reallocate the memory
						pwszBuffer=(WCHAR *)realloc(pwszBuffer,
								max(dwBufferLimit+g_AllocateSize,
								dwBufferLimit+dwBufferIncrement));

						if(!pwszBuffer)
							goto MemoryError;

						dwBufferLimit+=max(g_AllocateSize,dwBufferIncrement);

					}
					
					//add the header if necessary
					if(fHeader)
					{							
						if(!fLengthOnly)
						{
							memcpy((BYTE *)(pwszBuffer+dwBufferCount/sizeof(WCHAR)),
								pwszHeader,dwHeader);
						}

						dwBufferCount+=dwHeader;

						//do not need to do header anymore
						fHeader=FALSE;
					}

					//add the seperator	after the 1st iteration
					if(fAddSeperator)
					{
						
						if(!fLengthOnly)
						{
							memcpy((BYTE *)(pwszBuffer+dwBufferCount/sizeof(WCHAR)),
								pwszSeperator,dwSeperator);
						}

						dwBufferCount+=dwSeperator;
					}
					else
						fAddSeperator=TRUE;

					//add the attr content
					if(!fLengthOnly)
					{
						memcpy((BYTE *)(pwszBuffer+dwBufferCount/sizeof(WCHAR)),
							(pCertRDNAttr->Value.pbData),
							pCertRDNAttr->Value.cbData);
					}

					//increment the buffercount
					dwBufferCount+=pCertRDNAttr->Value.cbData;

				}
			}
		}


		//return the result as requested
		//check if the requested OID is actually in the DN
		if(0==dwBufferCount)
		{
			*pcbBuffer=dwBufferCount;
			goto NotFoundError;
		}


		//we need to NULL terminate the string
		if(!fLengthOnly)
			*(pwszBuffer+dwBufferCount/sizeof(WCHAR))=L'\0';

		dwBufferCount+=2;

		if(pBuffer==NULL)
		{
			*pcbBuffer=dwBufferCount;
			fResult=TRUE;
			goto CommonReturn;
		}

		if((*pcbBuffer)<dwBufferCount)
		{
			*pcbBuffer=dwBufferCount;
			goto MoreDataError;		
		}


		*pcbBuffer=dwBufferCount;
		memcpy(pBuffer, pwszBuffer,dwBufferCount);

		fResult=TRUE;

CommonReturn:
		if(pwszHeader)
			free(pwszHeader);

		if(pwszBuffer)
			free(pwszBuffer);

		if(pStructInfo)
			free(pStructInfo);

		return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;


SET_ERROR(InvalidArg, E_INVALIDARG);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(DecodeError);
TRACE_ERROR(szTOwszError);
SET_ERROR(NotFoundError, E_FAIL);
SET_ERROR(MoreDataError, ERROR_MORE_DATA);
}




//-----------------------------------------------------------
//
//  This is the actual format routine for an complete CERT_NAME
//
//
//	lpszStructType should be X509_NAME  pbEncoded is
//	an encoded BLOB for CERT_NAME_INFO struct.  When pBuffer==NULL,
//	*pcbBuffer return the size of memory to be allocated in bytes.
//	Please notice the string is NULL terminated.
//
//-------------------------------------------------------------
static BOOL	WINAPI	CryptDllFormatName(
				DWORD		dwEncodingType,	
				DWORD		dwFormatType,
				DWORD		dwFormatStrType,
				void		*pStruct,
				LPCSTR		lpszStructType,
				const BYTE	*pbEncoded,
				DWORD		cbEncoded,
				void		*pbBuffer,
				DWORD		*pcbBuffer)
{
    //makesure lpszStructType is X509_NAME or X509_UNICODE_NAME
	if((X509_NAME != lpszStructType) &&
		    (X509_UNICODE_NAME != lpszStructType))
    {
        SetLastError(E_INVALIDARG);
        return FALSE;
    }

 	//check input parameters
	if((pbEncoded==NULL && cbEncoded!=0) || pcbBuffer==NULL)
    {
        SetLastError(E_INVALIDARG);
        return FALSE;
    }

	if(cbEncoded==0)
    {
        SetLastError(E_INVALIDARG);
        return FALSE;
    }

    //call CryptDllFormatNameAll with no prefix
    return  CryptDllFormatNameAll(dwEncodingType,	
                                  dwFormatType,
                                  dwFormatStrType,
                                  pStruct,
                                  0,
                                  FALSE,
                                  pbEncoded,
                                  cbEncoded,
                                  &pbBuffer,
                                  pcbBuffer);

}


//-----------------------------------------------------------
//
//  This is the actual format routine for an complete CERT_NAME
//
//
//	lpszStructType should be X509_NAME  pbEncoded is
//	an encoded BLOB for CERT_NAME_INFO struct.  When pBuffer==NULL,
//	*pcbBuffer return the size of memory to be allocated in bytes.
//	Please notice the string is NULL terminated.
//
//-------------------------------------------------------------
BOOL	CryptDllFormatNameAll(
				DWORD		dwEncodingType,	
				DWORD		dwFormatType,
				DWORD		dwFormatStrType,
				void		*pStruct,
                UINT        idsPreFix,
                BOOL        fToAllocate,
				const BYTE	*pbEncoded,
				DWORD		cbEncoded,
				void		**ppbBuffer,
				DWORD		*pcbBuffer)
{

		BOOL			    fResult=FALSE;
		DWORD			    dwIndex=0;
		DWORD			    dwStrType=0;
		CERT_NAME_BLOB	    Cert_Name_Blob;
		DWORD			    dwSize=0;
        LPWSTR              pwszName=NULL;
        LPWSTR              pwszMulti=NULL;

		Cert_Name_Blob.cbData=cbEncoded;
		Cert_Name_Blob.pbData=(BYTE *)pbEncoded;

	
		//calculate the dwStryType to use for CertNameToStrW
        dwStrType=FormatToStr(dwFormatType);

        //overwrite dwStrType to default if we are doing MULTI line format
        //since the options will be ignored
        //We want to use + and , for the seperator
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
        {

            dwStrType &=~(CERT_NAME_STR_CRLF_FLAG);
            dwStrType &=~(CERT_NAME_STR_COMMA_FLAG);
            dwStrType &=~(CERT_NAME_STR_SEMICOLON_FLAG);
            dwStrType &=~(CERT_NAME_STR_NO_QUOTING_FLAG);
            dwStrType &=~(CERT_NAME_STR_NO_PLUS_FLAG);


        }

        //if this function is not called from CryptDllFormatName,
        //make sure that we use the RESERSE Flag
        if(TRUE == fToAllocate)
            dwStrType |= CERT_NAME_STR_REVERSE_FLAG;

		//call the CertNameToStrW to convert
        dwSize=CertNameToStrW(dwEncodingType,
                        &Cert_Name_Blob,
                        dwStrType,
                        NULL,
                        0);

        if(0==dwSize)
            goto CertNameToStrError;

        pwszName=(LPWSTR)malloc(sizeof(WCHAR)*(dwSize));
        if(NULL==pwszName)
            goto MemoryError;

        dwSize=CertNameToStrW(dwEncodingType,
                        &Cert_Name_Blob,
                        dwStrType,
                        pwszName,
                        dwSize);
        if(0==dwSize)
            goto CertNameToStrError;

        //we do not need to parse the string for single line format
        if(0==(dwFormatStrType &  CRYPT_FORMAT_STR_MULTI_LINE))
        {
            //calculate the bytes needed
            dwSize=sizeof(WCHAR)*(wcslen(pwszName)+1);

            //if FALSE==fToAllocate, we do not allocate the memory on user's
            //behalf; otherwize, allocate memory to eliminate the need for
            //double call
            if(FALSE==fToAllocate)
            {
                if(NULL==(*ppbBuffer))
                {
                    *pcbBuffer=dwSize;
                    fResult=TRUE;
                    goto CommonReturn;
                }

                if(*pcbBuffer < dwSize)
                {
                    *pcbBuffer=dwSize;
                    goto MoreDataError;
                }

                memcpy(*ppbBuffer, pwszName, dwSize);
                *pcbBuffer=dwSize;
            }
            else
            {
                *ppbBuffer=malloc(dwSize);

                if(NULL==(*ppbBuffer))
                    goto MemoryError;

                memcpy(*ppbBuffer, pwszName, dwSize);

                //pcbBuffer can be NULL in this case
            }
        }
        else
        {
            //we need to parse the string to make the multiple format
            if(!GetCertNameMulti(pwszName, idsPreFix, &pwszMulti))
                goto GetCertNameError;

            //calculate the bytes needee
            dwSize=sizeof(WCHAR)*(wcslen(pwszMulti)+1);

            //if FALSE==fToAllocate, we do not allocate the memory on user's
            //behalf; otherwize, allocate memory to eliminate the need for
            //double call
            if(FALSE==fToAllocate)
            {
                if(NULL==(*ppbBuffer))
                {
                    *pcbBuffer=dwSize;
                    fResult=TRUE;
                    goto CommonReturn;
                }

                if(*pcbBuffer < dwSize)
                {
                    *pcbBuffer=dwSize;
                    goto MoreDataError;
                }

                memcpy(*ppbBuffer, pwszMulti, dwSize);
                *pcbBuffer=dwSize;

            }
            else
            {
                *ppbBuffer=malloc(dwSize);

                if(NULL==(*ppbBuffer))
                    goto MemoryError;

                memcpy(*ppbBuffer, pwszMulti, dwSize);

                //pcbBuffer can be NULL in this case
            }
        }


        fResult=TRUE;


CommonReturn:

    if(pwszName)
        free(pwszName);

    if(pwszMulti)
        free(pwszMulti);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(CertNameToStrError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(GetCertNameError);

}

//--------------------------------------------------------------------------
//
//	 FormatBasicConstraints2:   szOID_BASIC_CONSTRAINTS2
//                              X509_BASIC_CONSTRAINTS2
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatBasicConstraints2(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	
	LPWSTR							pwszFormat=NULL;
	WCHAR							wszSubject[SUBJECT_SIZE];
	WCHAR							wszNone[NONE_SIZE];
	PCERT_BASIC_CONSTRAINTS2_INFO	pInfo=NULL;
	DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;
	UINT							idsSub=0;

	
	//check for input parameters
	if((NULL==pbEncoded&& cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,X509_BASIC_CONSTRAINTS2,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

	//load the string for the subjectType
    if (pInfo->fCA)
		idsSub=IDS_SUB_CA;
	else
		idsSub=IDS_SUB_EE;

	if(!LoadStringU(hFrmtFuncInst,idsSub, wszSubject, sizeof(wszSubject)/sizeof(wszSubject[0])))
		goto LoadStringError;

    if (pInfo->fPathLenConstraint)
	{
        //decide between signle line and multi line display
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            idsSub=IDS_BASIC_CONS2_PATH_MULTI;
        else
            idsSub=IDS_BASIC_CONS2_PATH;

        if(!FormatMessageUnicode(&pwszFormat,idsSub,
								wszSubject, pInfo->dwPathLenConstraint))
			goto FormatMsgError;
	}
    else
	{
		if(!LoadStringU(hFrmtFuncInst,IDS_NONE, wszNone, sizeof(wszNone)/sizeof(wszNone[0])))
			goto LoadStringError;

        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            idsSub=IDS_BASIC_CONS2_NONE_MULTI;
        else
            idsSub=IDS_BASIC_CONS2_NONE;

        if(!FormatMessageUnicode(&pwszFormat,idsSub,
								wszSubject, wszNone))
			goto FormatMsgError;
	}


	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:
	if(pwszFormat)
		LocalFree((HLOCAL)pwszFormat);

	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(FormatMsgError);

}


//--------------------------------------------------------------------------
//
//	 FormatSPCObject:
//
//   idsPreFix is the pre fix for mulit-line display
//--------------------------------------------------------------------------
BOOL FormatSPCObject(
	DWORD		                dwFormatType,
	DWORD		                dwFormatStrType,
    void		                *pFormatStruct,
    UINT                        idsPreFix,
    PSPC_SERIALIZED_OBJECT      pInfo,
    LPWSTR                      *ppwszFormat)
{

    BOOL        fResult=FALSE;
    LPWSTR      pwszHex=NULL;
    LPWSTR      pwszClassId=NULL;
    WCHAR       wszPreFix[PRE_FIX_SIZE];
    DWORD       cbNeeded=0;

    LPWSTR      pwszClassFormat=NULL;
    LPWSTR      pwszDataFormat=NULL;

    assert(pInfo);

    *ppwszFormat=NULL;

   //load the pre-dix
   if(0!=idsPreFix)
   {
       if(!LoadStringU(hFrmtFuncInst, idsPreFix,
                        wszPreFix, sizeof(wszPreFix)/sizeof(wszPreFix[0])))
        goto LoadStringError;

   }


    cbNeeded=0;

    if(!FormatBytesToHex(
                        0,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        NULL,
                        pInfo->ClassId,
                        16,
                        NULL,
	                    &cbNeeded))
            goto FormatBytesToHexError;

    pwszClassId=(LPWSTR)malloc(cbNeeded);
    if(NULL==pwszClassId)
         goto MemoryError;

    if(!FormatBytesToHex(
                        0,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        NULL,
                        pInfo->ClassId,
                        16,
                        pwszClassId,
	                    &cbNeeded))
        goto FormatBytesToHexError;


    //format
    if(!FormatMessageUnicode(&pwszClassFormat, IDS_SPC_OBJECT_CLASS, pwszClassId))
            goto FormatMsgError;

    //strcat
    *ppwszFormat=(LPWSTR)malloc(sizeof(WCHAR) * (wcslen(pwszClassFormat)+wcslen(wszPreFix)+wcslen(wszCOMMA)+1));
    if(NULL==*ppwszFormat)
        goto MemoryError;

    **ppwszFormat=L'\0';

    if(0!=idsPreFix)
        wcscat(*ppwszFormat, wszPreFix);

    wcscat(*ppwszFormat, pwszClassFormat);

    //format based on the availability of SerializedData
    if(0!=pInfo->SerializedData.cbData)
    {
        //cancatenate the ", " or \n"
        if(NULL != (*ppwszFormat))
        {
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
               wcscat(*ppwszFormat, wszNEWLN);
            else
               wcscat(*ppwszFormat, wszCOMMA);
        }

       cbNeeded=0;

       if(!FormatBytesToHex(
                        0,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        NULL,
                        pInfo->SerializedData.pbData,
                        pInfo->SerializedData.cbData,
                        NULL,
	                    &cbNeeded))
            goto FormatBytesToHexError;

        pwszHex=(LPWSTR)malloc(cbNeeded);
        if(NULL==pwszHex)
            goto MemoryError;

        if(!FormatBytesToHex(
                        0,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        NULL,
                        pInfo->SerializedData.pbData,
                        pInfo->SerializedData.cbData,
                        pwszHex,
	                    &cbNeeded))
            goto FormatBytesToHexError;

          if(!FormatMessageUnicode(&pwszDataFormat, IDS_SPC_OBJECT_DATA,pwszHex))
            goto FormatMsgError;

        //strcat
        *ppwszFormat=(LPWSTR)realloc(*ppwszFormat,
                sizeof(WCHAR)* (wcslen(*ppwszFormat)+wcslen(pwszDataFormat)+wcslen(wszPreFix)+1));
        if(NULL==*ppwszFormat)
            goto MemoryError;

        if(0!=idsPreFix)
            wcscat(*ppwszFormat, wszPreFix);

        wcscat(*ppwszFormat, pwszDataFormat);

    }

	fResult=TRUE;
	

CommonReturn:
    if(pwszHex)
        free(pwszHex);

    if(pwszClassId)
        free(pwszClassId);

    if(pwszClassFormat)
        LocalFree((HLOCAL)pwszClassFormat);

    if(pwszDataFormat)
        LocalFree((HLOCAL)pwszDataFormat);

	return fResult;

ErrorReturn:
    if(*ppwszFormat)
    {
        free(*ppwszFormat);
        *ppwszFormat=NULL;
    }


	fResult=FALSE;
	goto CommonReturn;


TRACE_ERROR(FormatBytesToHexError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(FormatMsgError);
TRACE_ERROR(LoadStringError);
}


//--------------------------------------------------------------------------
//
//	 FormatSPCLink:
//--------------------------------------------------------------------------
BOOL FormatSPCLink(
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
    void		*pFormatStruct,
    UINT        idsPreFix,
    PSPC_LINK   pInfo,
    LPWSTR      *ppwsz)
{

    BOOL        fResult=FALSE;
    LPWSTR      pwszObj=NULL;
    DWORD       cbNeeded=0;
    UINT        ids=0;
    LPWSTR      pwszFormat=NULL;


    assert(pInfo);

    *ppwsz=NULL;

    switch(pInfo->dwLinkChoice)
    {
        case SPC_URL_LINK_CHOICE:
                if(!FormatMessageUnicode(&pwszFormat, IDS_SPC_URL_LINK,pInfo->pwszUrl))
                    goto FormatMsgError;
            break;

        case SPC_MONIKER_LINK_CHOICE:
                if(!FormatSPCObject(
                            dwFormatType,
                            dwFormatStrType,
                            pFormatStruct,
                            idsPreFix,
                            &(pInfo->Moniker),
                            &pwszObj))
                    goto FormatSPCObjectError;


                //decide between single line and mulitple line format
                if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                    ids=IDS_SPC_MONIKER_LINK_MULTI;
                else
                    ids=IDS_SPC_MONIKER_LINK;

                if(!FormatMessageUnicode(&pwszFormat,ids,pwszObj))
                    goto FormatMsgError;
            break;


        case SPC_FILE_LINK_CHOICE:
               if(!FormatMessageUnicode(&pwszFormat, IDS_SPC_FILE_LINK, pInfo->pwszFile))
                    goto FormatMsgError;

            break;

        default:

               if(!FormatMessageUnicode(&pwszFormat, IDS_SPC_LINK_UNKNOWN,
                        pInfo->dwLinkChoice))
                    goto FormatMsgError;
    }

    *ppwsz=(LPWSTR)malloc(sizeof(WCHAR) * (wcslen(pwszFormat)+1));
    if(NULL==(*ppwsz))
        goto MemoryError;

    memcpy(*ppwsz, pwszFormat, sizeof(WCHAR) * (wcslen(pwszFormat)+1));
	fResult=TRUE;
	

CommonReturn:

    if(pwszObj)
        free(pwszObj);

    if(pwszFormat)
        LocalFree((HLOCAL)pwszFormat);

	return fResult;

ErrorReturn:

    if(*ppwsz)
    {
        free(*ppwsz);
        *ppwsz=NULL;
    }

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(FormatMsgError);
TRACE_ERROR(FormatSPCObjectError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
}


//--------------------------------------------------------------------------
//
//	 FormatSPCImage:
//--------------------------------------------------------------------------
BOOL FormatSPCImage(
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
    void		*pFormatStruct,
    UINT        idsPreFix,
    PSPC_IMAGE  pInfo,
    LPWSTR      *ppwszImageFormat)
{
    BOOL        fResult=FALSE;
    LPWSTR       pwszFormat=NULL;
    LPWSTR       pwszLink=NULL;
    LPWSTR       pwszLinkFormat=NULL;
    LPWSTR      pwszHex=NULL;
    LPWSTR      pwszHexFormat=NULL;
    UINT        ids=0;

    DWORD       cbNeeded=0;

    assert(pInfo);

    //init
    *ppwszImageFormat=NULL;

	pwszFormat=(LPWSTR)malloc(sizeof(WCHAR));
    if(NULL==pwszFormat)
        goto MemoryError;

    *pwszFormat=L'\0';

    if(pInfo->pImageLink)
    {
        if(!FormatSPCLink(dwFormatType,
                          dwFormatStrType,
                          pFormatStruct,
                          idsPreFix,
                          pInfo->pImageLink,
                          &pwszLink))
            goto FormatSPCLinkError;

       //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            ids=IDS_IMAGE_LINK_MULTI;
        else
            ids=IDS_IMAGE_LINK;


        if(!FormatMessageUnicode(&pwszLinkFormat, ids,
                            &pwszLink))
            goto FormatMsgError;

        pwszFormat=(LPWSTR)realloc(pwszFormat, 
                    sizeof(WCHAR) * (wcslen(pwszFormat)+wcslen(wszCOMMA)+wcslen(pwszLinkFormat)+1));
        if(NULL==pwszFormat)
            goto MemoryError;

        wcscat(pwszFormat, pwszLinkFormat);
    }

    if(0!=pInfo->Bitmap.cbData)
    {
        //strcat ", "
        if(0!=wcslen(pwszFormat))
        {
            if(0== (dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                wcscat(pwszFormat, wszCOMMA);
        }

       cbNeeded=0;

       if(!FormatBytesToHex(
                        0,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        NULL,
                        pInfo->Bitmap.pbData,
                        pInfo->Bitmap.cbData,
                        NULL,
	                    &cbNeeded))
            goto FormatBytesToHexError;

        pwszHex=(LPWSTR)malloc(cbNeeded);
        if(NULL==pwszHex)
            goto MemoryError;

        if(!FormatBytesToHex(
                        0,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        NULL,
                        pInfo->Bitmap.pbData,
                        pInfo->Bitmap.cbData,
                        pwszHex,
	                    &cbNeeded))
            goto FormatBytesToHexError;

        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            ids=IDS_IMAGE_BITMAP_MULTI;
        else
            ids=IDS_IMAGE_BITMAP;


        if(!FormatMessageUnicode(&pwszHexFormat, ids, pwszHex))
            goto FormatMsgError;


        pwszFormat=(LPWSTR)realloc(pwszFormat, 
            sizeof(WCHAR) * (wcslen(pwszFormat)+wcslen(wszCOMMA)+wcslen(pwszHexFormat)+1));
        if(NULL==pwszFormat)
            goto MemoryError;

        wcscat(pwszFormat, pwszHexFormat);

       //free memory
        free(pwszHex);
        pwszHex=NULL;
        LocalFree((HLOCAL)pwszHexFormat);
        pwszHexFormat=NULL;

    }

   if(0!=pInfo->Metafile.cbData)
    {
        //strcat ", "
        if(0!=wcslen(pwszFormat))
        {
            if(0== (dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                wcscat(pwszFormat, wszCOMMA);
        }

       cbNeeded=0;

       if(!FormatBytesToHex(
                        0,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        NULL,
                        pInfo->Metafile.pbData,
                        pInfo->Metafile.cbData,
                        NULL,
	                    &cbNeeded))
            goto FormatBytesToHexError;

        pwszHex=(LPWSTR)malloc(cbNeeded);
        if(NULL==pwszHex)
            goto MemoryError;

        if(!FormatBytesToHex(
                        0,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        NULL,
                        pInfo->Metafile.pbData,
                        pInfo->Metafile.cbData,
                        pwszHex,
	                    &cbNeeded))
            goto FormatBytesToHexError;

        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            ids=IDS_IMAGE_METAFILE_MULTI;
        else
            ids=IDS_IMAGE_METAFILE;

        if(!FormatMessageUnicode(&pwszHexFormat, ids, pwszHex))
            goto FormatMsgError;


        pwszFormat=(LPWSTR)realloc(pwszFormat, 
            sizeof(WCHAR) *(wcslen(pwszFormat)+wcslen(wszCOMMA)+wcslen(pwszHexFormat)+1));
        if(NULL==pwszFormat)
            goto MemoryError;

        wcscat(pwszFormat, pwszHexFormat);

       //free memory
        free(pwszHex);
        pwszHex=NULL;
        LocalFree((HLOCAL)pwszHexFormat);
        pwszHexFormat=NULL;

    }

   if(0!=pInfo->EnhancedMetafile.cbData)
    {
        //strcat ", "
        if(0!=wcslen(pwszFormat))
        {
            if(0== (dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                wcscat(pwszFormat, wszCOMMA);
        }

       cbNeeded=0;

       if(!FormatBytesToHex(
                        0,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        NULL,
                        pInfo->EnhancedMetafile.pbData,
                        pInfo->EnhancedMetafile.cbData,
                        NULL,
	                    &cbNeeded))
            goto FormatBytesToHexError;

        pwszHex=(LPWSTR)malloc(cbNeeded);
        if(NULL==pwszHex)
            goto MemoryError;

        if(!FormatBytesToHex(
                        0,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        NULL,
                        pInfo->EnhancedMetafile.pbData,
                        pInfo->EnhancedMetafile.cbData,
                        pwszHex,
	                    &cbNeeded))
            goto FormatBytesToHexError;

        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            ids=IDS_IMAGE_ENHANCED_METAFILE_MULTI;
        else
            ids=IDS_IMAGE_ENHANCED_METAFILE;

        if(!FormatMessageUnicode(&pwszHexFormat, ids, pwszHex))
            goto FormatMsgError;


        pwszFormat=(LPWSTR)realloc(pwszFormat, 
            sizeof(WCHAR) *(wcslen(pwszFormat)+wcslen(wszCOMMA)+wcslen(pwszHexFormat)+1));
        if(NULL==pwszFormat)
            goto MemoryError;

        wcscat(pwszFormat, pwszHexFormat);

       //free memory
        free(pwszHex);
        pwszHex=NULL;
        LocalFree((HLOCAL)pwszHexFormat);
        pwszHexFormat=NULL;

    }

   if(0!=pInfo->GifFile.cbData)
    {
        //strcat ", "
        if(0!=wcslen(pwszFormat))
        {
            if(0== (dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                wcscat(pwszFormat, wszCOMMA);
        }

       cbNeeded=0;

       if(!FormatBytesToHex(
                        0,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        NULL,
                        pInfo->GifFile.pbData,
                        pInfo->GifFile.cbData,
                        NULL,
	                    &cbNeeded))
            goto FormatBytesToHexError;

        pwszHex=(LPWSTR)malloc(cbNeeded);
        if(NULL==pwszHex)
            goto MemoryError;

        if(!FormatBytesToHex(
                        0,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        NULL,
                        pInfo->GifFile.pbData,
                        pInfo->GifFile.cbData,
                        pwszHex,
	                    &cbNeeded))
            goto FormatBytesToHexError;

        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            ids=IDS_IMAGE_GIFFILE_MULTI;
        else
            ids=IDS_IMAGE_GIFFILE;

        if(!FormatMessageUnicode(&pwszHexFormat, IDS_IMAGE_GIFFILE,
            pwszHex))
            goto FormatMsgError;


        pwszFormat=(LPWSTR)realloc(pwszFormat, 
            sizeof(WCHAR) *(wcslen(pwszFormat)+wcslen(wszCOMMA)+wcslen(pwszHexFormat)+1));
        if(NULL==pwszFormat)
            goto MemoryError;

        wcscat(pwszFormat, pwszHexFormat);

       //free memory
        free(pwszHex);
        pwszHex=NULL;
        LocalFree((HLOCAL)pwszHexFormat);
        pwszHexFormat=NULL;

    }

    if(0==wcslen(pwszFormat))
    {
        //fine if nothing is formatted
        *ppwszImageFormat=NULL;
    }
    else
    {
        *ppwszImageFormat=(LPWSTR)malloc(sizeof(WCHAR)*(wcslen(pwszFormat)+1));  

        if(NULL == ppwszImageFormat)
            goto MemoryError;

        memcpy(*ppwszImageFormat, pwszFormat, sizeof(WCHAR)*(wcslen(pwszFormat)+1));
    }

	fResult=TRUE;
	

CommonReturn:
    if(pwszHex)
        free(pwszHex);

    if(pwszHexFormat)
        LocalFree((HLOCAL)pwszHexFormat);

    if(pwszLink)
        free(pwszLink);

    if(pwszLinkFormat)
        LocalFree((HLOCAL)pwszLinkFormat);

    if(pwszFormat)
        free(pwszFormat);

	return fResult;

ErrorReturn:

    if(*ppwszImageFormat)
    {
        free(*ppwszImageFormat);
        *ppwszImageFormat=NULL;
    }

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(FormatSPCLinkError);
TRACE_ERROR(FormatMsgError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(FormatBytesToHexError);

}


//--------------------------------------------------------------------------
//
//	 FormatSPAgencyInfo:   SPC_SP_AGENCY_INFO_STRUCT
//                         SPC_SP_AGENCY_INFO_OBJID
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatSPAgencyInfo(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	
	LPWSTR							pwszFormat=NULL;
    LPWSTR                          pwsz=NULL;
	PSPC_SP_AGENCY_INFO         	pInfo=NULL;

    LPWSTR                           pwszPolicyInfo=NULL;
    LPWSTR                           pwszPolicyInfoFormat=NULL;
    LPWSTR                           pwszLogoLink=NULL;
    LPWSTR                           pwszLogoLinkFormat=NULL;
    LPWSTR                           pwszPolicyDsplyFormat=NULL;
    LPWSTR                           pwszLogoImage=NULL;
    LPWSTR                           pwszLogoImageFormat=NULL;

	DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;
	HRESULT                          hr=S_OK;
    UINT                            ids=0;

	
	//check for input parameters
	if((NULL==pbEncoded&& cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,SPC_SP_AGENCY_INFO_STRUCT,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

	pwsz=(LPWSTR)malloc(sizeof(WCHAR));
    if(NULL==pwsz)
        goto MemoryError;

    *pwsz=L'\0';

    //format pPolicyInformation
    if(pInfo->pPolicyInformation)
    {

        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            ids=IDS_TWO_TABS;
        else
            ids=0;

        if(!FormatSPCLink(dwFormatType,
                             dwFormatStrType,
                             pFormatStruct,
                             ids,
                             pInfo->pPolicyInformation,
                             &pwszPolicyInfo))
            goto FormatSPCLinkError;

        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            ids=IDS_AGENCY_POLICY_INFO_MULTI;
        else
            ids=IDS_AGENCY_POLICY_INFO;

        if(!FormatMessageUnicode(&pwszPolicyInfoFormat, ids, pwszPolicyInfo))
            goto FormatMsgError;

        //strcat
        pwsz=(LPWSTR)realloc(pwsz, 
            sizeof(WCHAR) *(wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszPolicyInfoFormat)+1));
        if(NULL==pwsz)
            goto MemoryError;

        wcscat(pwsz, pwszPolicyInfoFormat);
    }


    //format pwszPolicyDisplayText
    if(pInfo->pwszPolicyDisplayText)
    {
        //strcat ", "
        if(0!=wcslen(pwsz))
        {
            if(0== (dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                wcscat(pwsz, wszCOMMA);
        }

        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            ids=IDS_AGENCY_POLICY_DSPLY_MULTI;
        else
            ids=IDS_AGENCY_POLICY_DSPLY;

        if(!FormatMessageUnicode(&pwszPolicyDsplyFormat, ids, pInfo->pwszPolicyDisplayText))
            goto FormatMsgError;

        //strcat
        pwsz=(LPWSTR)realloc(pwsz,
            sizeof(WCHAR) *(wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszPolicyDsplyFormat)+1));
        if(NULL==pwsz)
            goto MemoryError;

        wcscat(pwsz, pwszPolicyDsplyFormat);
    }

    //pLogoImage
    if(pInfo->pLogoImage)
    {

        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            ids=IDS_THREE_TABS;
        else
            ids=0;


        if(!FormatSPCImage(dwFormatType,
                             dwFormatStrType,
                             pFormatStruct,
                             ids,
                             pInfo->pLogoImage,
                             &pwszLogoImage))
            goto FormatSPCImageError;

        //spcImage can include nothing
        if(NULL!=pwszLogoImage)
        {
            //strcat ", "
            if(0!=wcslen(pwsz))
            {
                if(0== (dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                    wcscat(pwsz, wszCOMMA);
            }

            //decide between single line and mulitple line format
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                ids=IDS_AGENCY_LOGO_IMAGE_MULTI;
            else
                ids=IDS_AGENCY_LOGO_IMAGE;


            if(!FormatMessageUnicode(&pwszLogoImageFormat,ids,pwszLogoImage))
                goto FormatMsgError;

            //strcat
            pwsz=(LPWSTR)realloc(pwsz,
                sizeof(WCHAR) *(wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszLogoImageFormat)+1));
            if(NULL==pwsz)
                goto MemoryError;

            wcscat(pwsz, pwszLogoImageFormat);
        }

    }

    //format pLogoLink
    if(pInfo->pLogoLink)
    {
        //strcat ", "
        if(0!=wcslen(pwsz))
        {
            if(0== (dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                wcscat(pwsz, wszCOMMA);
        }

        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            ids=IDS_TWO_TABS;
        else
            ids=0;


        if(!FormatSPCLink(dwFormatType,
                             dwFormatStrType,
                             pFormatStruct,
                             ids,
                             pInfo->pLogoLink,
                             &pwszLogoLink))
            goto FormatSPCLinkError;


        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            ids=IDS_AGENCY_LOGO_LINK_MULTI;
        else
            ids=IDS_AGENCY_LOGO_LINK;

        if(!FormatMessageUnicode(&pwszLogoLinkFormat, ids, pwszLogoLink))
            goto FormatMsgError;

        //strcat
        pwsz=(LPWSTR)realloc(pwsz,
            sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszLogoLinkFormat)+1));
        if(NULL==pwsz)
            goto MemoryError;

        wcscat(pwsz, pwszLogoLinkFormat);
    }

    if(0==wcslen(pwsz))
    {
       //no data
        pwszFormat=(LPWSTR)malloc((NO_INFO_SIZE+1)*sizeof(WCHAR));
        if(NULL==pwszFormat)
            goto MemoryError;

        if(!LoadStringU(hFrmtFuncInst,IDS_NO_INFO, pwszFormat, NO_INFO_SIZE))
            goto LoadStringError;

    }
    else
    {
        pwszFormat=pwsz;
        pwsz=NULL;
    }


	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:

    if(pwszPolicyInfo)
        free(pwszPolicyInfo);

    if(pwszPolicyInfoFormat)
        LocalFree((HLOCAL)pwszPolicyInfoFormat);

    if(pwszLogoLink)
        free(pwszLogoLink);

    if(pwszLogoLinkFormat)
        LocalFree((HLOCAL)pwszLogoLinkFormat);

    if(pwszPolicyDsplyFormat)
        LocalFree((HLOCAL)pwszPolicyDsplyFormat);

    if(pwszLogoImage)
        free(pwszLogoImage);

    if(pwszLogoImageFormat)
        LocalFree((HLOCAL)pwszLogoImageFormat);

	if(pwszFormat)
		free(pwszFormat);

    if(pwsz)
        free(pwsz);

	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(FormatMsgError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(FormatSPCLinkError);
TRACE_ERROR(FormatSPCImageError);

}

//--------------------------------------------------------------------------
//
//	 FormatCertQualifier:
//--------------------------------------------------------------------------
BOOL FormatCertQualifier(
	DWORD		                    dwCertEncodingType,
	DWORD		                    dwFormatType,
	DWORD		                    dwFormatStrType,
	void		                    *pFormatStruct,
    PCERT_POLICY_QUALIFIER_INFO     pInfo,
    LPWSTR                          *ppwszFormat)
{
    BOOL        fResult=FALSE;
    LPWSTR      pwszHex=NULL;
    DWORD       cbNeeded=0;
    UINT        ids=0;

    *ppwszFormat=NULL;

    if(pInfo->Qualifier.cbData)
    {
       //get the Hex dump of the Key Usage
       cbNeeded=0;

       if(!FormatBytesToHex(
                        dwCertEncodingType,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        NULL,
                        pInfo->Qualifier.pbData,
                        pInfo->Qualifier.cbData,
                        NULL,
	                    &cbNeeded))
            goto FormatBytesToHexError;

        pwszHex=(LPWSTR)malloc(cbNeeded);
        if(NULL==pwszHex)
            goto MemoryError;

        if(!FormatBytesToHex(
                        dwCertEncodingType,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        NULL,
                        pInfo->Qualifier.pbData,
                        pInfo->Qualifier.cbData,
                        pwszHex,
	                    &cbNeeded))
            goto FormatBytesToHexError;


        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            ids=IDS_POLICY_QUALIFIER_MULTI;
        else
            ids=IDS_POLICY_QUALIFIER;


        if(!FormatMessageUnicode(ppwszFormat, ids,
            pInfo->pszPolicyQualifierId, pwszHex))
            goto FormatMsgError;
    }
    else
    {
        if(!FormatMessageUnicode(ppwszFormat, IDS_POLICY_QUALIFIER_NO_BLOB,
            pInfo->pszPolicyQualifierId))
            goto FormatMsgError;

    }

	fResult=TRUE;
	

CommonReturn:

    if(pwszHex)
        free(pwszHex);

	return fResult;

ErrorReturn:

    if(*ppwszFormat)
    {
        LocalFree((HLOCAL)(*ppwszFormat));
        *ppwszFormat=NULL;
    }


	fResult=FALSE;
	goto CommonReturn;


TRACE_ERROR(FormatBytesToHexError);
TRACE_ERROR(FormatMsgError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
}


//--------------------------------------------------------------------------
//
//	 FormatCertPolicies:     X509_CERT_POLICIES
//                           szOID_CERT_POLICIES
//
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatCertPolicies(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	
	LPWSTR							pwszFormat=NULL;
    LPWSTR                           pwsz=NULL;
    LPWSTR                           pwszPolicyFormat=NULL;
    LPWSTR                           pwszQualifiers=NULL;
    LPWSTR                           pwszQualifierFormat=NULL;
    LPWSTR                           pwszOneQualifier=NULL;

	PCERT_POLICIES_INFO	            pInfo=NULL;

    PCERT_POLICY_INFO               pPolicyInfo=NULL;
    DWORD                           dwIndex=0;
    DWORD                           dwQualifierIndex=0;
	DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;
    HRESULT                         hr=S_OK;
    UINT                            ids=0;


	
	//check for input parameters
	if((NULL==pbEncoded&& cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,X509_CERT_POLICIES,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

    pwsz=(LPWSTR)malloc(sizeof(WCHAR));
    if(NULL==pwsz)
        goto MemoryError;

    *pwsz=L'\0';

    for(dwIndex=0; dwIndex < pInfo->cPolicyInfo; dwIndex++)
    {
       //strcat ", "
       if(0!=wcslen(pwsz))
       {
            if(0==(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
               wcscat(pwsz, wszCOMMA);
       }

        pPolicyInfo=&(pInfo->rgPolicyInfo[dwIndex]);


        pwszQualifiers=(LPWSTR)malloc(sizeof(WCHAR));
        if(NULL==pwszQualifiers)
        goto MemoryError;

        *pwszQualifiers=L'\0';

         //format the qualifiers
         for(dwQualifierIndex=0;  dwQualifierIndex < pPolicyInfo->cPolicyQualifier;
            dwQualifierIndex++)
         {

            //strcat ", "
            if(0!=wcslen(pwszQualifiers))
            {
                if(0==(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                    wcscat(pwszQualifiers, wszCOMMA);
            }

             if(!FormatCertQualifier(dwCertEncodingType,
                                     dwFormatType,
                                     dwFormatStrType,
                                     pFormatStruct,
                                     &(pPolicyInfo->rgPolicyQualifier[dwQualifierIndex]),
                                     &pwszOneQualifier))
                    goto FormatCertQualifierError;

            //decide between single line and mulitple line format
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                ids=IDS_POLICY_QUALIFIER_INFO_MULTI;
            else
                ids=IDS_POLICY_QUALIFIER_INFO;


             //format
             if(!FormatMessageUnicode(&pwszQualifierFormat,ids,
                    dwIndex+1,
                    dwQualifierIndex+1,
                    pwszOneQualifier))
                    goto FormatMsgError;

             //strcat
             pwszQualifiers=(LPWSTR)realloc(pwszQualifiers, 
                 sizeof(WCHAR) * (wcslen(pwszQualifiers)+wcslen(wszCOMMA)+wcslen(pwszQualifierFormat)+1));
             if(NULL==pwszQualifiers)
                 goto MemoryError;

             wcscat(pwszQualifiers, pwszQualifierFormat);

             LocalFree((HLOCAL)pwszOneQualifier);
             pwszOneQualifier=NULL;

             LocalFree((HLOCAL)pwszQualifierFormat);
             pwszQualifierFormat=NULL;
         }

         //now, format the certPolicyInfo
         if(0!=pPolicyInfo->cPolicyQualifier)
         {

            //decide between single line and mulitple line format
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                ids=IDS_CERT_POLICY_MULTI;
            else
                ids=IDS_CERT_POLICY;

             if(!FormatMessageUnicode(&pwszPolicyFormat,ids,
                        dwIndex+1, pPolicyInfo->pszPolicyIdentifier,
                        pwszQualifiers))
                goto FormatMsgError;

         }
         else
         {

            //decide between single line and mulitple line format
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                ids=IDS_CERT_POLICY_NO_QUA_MULTI;
            else
                ids=IDS_CERT_POLICY_NO_QUA;

             if(!FormatMessageUnicode(&pwszPolicyFormat, ids,
                        dwIndex+1, pPolicyInfo->pszPolicyIdentifier))
                goto FormatMsgError;

         }

         //strcat
         pwsz=(LPWSTR)realloc(pwsz, 
             sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszPolicyFormat)+1));
         if(NULL==pwsz)
             goto MemoryError;

         wcscat(pwsz, pwszPolicyFormat);

         free(pwszQualifiers);
         pwszQualifiers=NULL;

         LocalFree((HLOCAL)pwszPolicyFormat);
         pwszPolicyFormat=NULL;
    }


    if(0==wcslen(pwsz))
    {
       //no data
        pwszFormat=(LPWSTR)malloc(sizeof(WCHAR)*(NO_INFO_SIZE+1));
        if(NULL==pwszFormat)
            goto MemoryError;

        if(!LoadStringU(hFrmtFuncInst,IDS_NO_INFO, pwszFormat, NO_INFO_SIZE))
            goto LoadStringError;

    }
    else
    {
        pwszFormat=pwsz;
        pwsz=NULL;
    }

	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:
    if(pwszOneQualifier)
        LocalFree((HLOCAL)pwszOneQualifier);

    if(pwszQualifierFormat)
        LocalFree((HLOCAL)pwszQualifierFormat);

    if(pwszQualifiers)
      free(pwszQualifiers);

    if(pwszPolicyFormat)
        LocalFree((HLOCAL)pwszPolicyFormat);

    if(pwsz)
        free(pwsz);

	if(pwszFormat)
		free(pwszFormat);

	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(FormatMsgError);
SET_ERROR(MemoryError,E_OUTOFMEMORY);
TRACE_ERROR(FormatCertQualifierError);
}


//--------------------------------------------------------------------------
//
//	 FormatDistPointName:  Pre-condition: dwDistPointNameChoice!=0
//--------------------------------------------------------------------------
BOOL    FormatDistPointName(DWORD		            dwCertEncodingType,
	                        DWORD		            dwFormatType,
	                        DWORD		            dwFormatStrType,
	                        void		            *pFormatStruct,
                            PCRL_DIST_POINT_NAME    pInfo,
                            LPWSTR                  *ppwszFormat)
{
    BOOL            fResult=FALSE;
    DWORD           cbNeeded=0;
    LPWSTR          pwszCRLIssuer=NULL;
    UINT            ids=0;

    *ppwszFormat=NULL;

    if(CRL_DIST_POINT_FULL_NAME==pInfo->dwDistPointNameChoice)
    {
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
              ids=IDS_THREE_TABS;

        cbNeeded=0;
        if(!FormatAltNameInfo(dwCertEncodingType,
                                 dwFormatType,
                                 dwFormatStrType,
                                 pFormatStruct,
                                 ids,
                                 FALSE,
                                 &(pInfo->FullName),
                                 NULL,
                                 &cbNeeded))
                goto FormatAltNameError;

        pwszCRLIssuer=(LPWSTR)malloc(cbNeeded);
        if(NULL==pwszCRLIssuer)
            goto MemoryError;

         if(!FormatAltNameInfo(dwCertEncodingType,
                                 dwFormatType,
                                 dwFormatStrType,
                                 pFormatStruct,
                                 ids,
                                 FALSE,
                                 &(pInfo->FullName),
                                 pwszCRLIssuer,
                                 &cbNeeded))
              goto FormatAltNameError;

        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
              ids=IDS_CRL_DIST_FULL_NAME_MULTI;
        else
              ids=IDS_CRL_DIST_FULL_NAME;


         if(!FormatMessageUnicode(ppwszFormat, ids,pwszCRLIssuer))
             goto FormatMsgError;
    }
    else
    {
        if(CRL_DIST_POINT_ISSUER_RDN_NAME==pInfo->dwDistPointNameChoice)
        {
            *ppwszFormat=(LPWSTR)malloc(sizeof(WCHAR)*(CRL_DIST_NAME_SIZE+1));
            if(NULL==*ppwszFormat)
                goto MemoryError;

            if(!LoadStringU(hFrmtFuncInst, IDS_CRL_DIST_ISSUER_RDN,
                    *ppwszFormat,CRL_DIST_NAME_SIZE))
                goto LoadStringError;

        }
        else
        {
            if(!FormatMessageUnicode(ppwszFormat, IDS_DWORD,
                pInfo->dwDistPointNameChoice))
                goto FormatMsgError;
        }

    }
	fResult=TRUE;
	

CommonReturn:
    if(pwszCRLIssuer)
        free(pwszCRLIssuer);

	return fResult;

ErrorReturn:
    if(*ppwszFormat)
    {
        LocalFree((HLOCAL)(*ppwszFormat));
        *ppwszFormat=NULL;
    }

	fResult=FALSE;
	goto CommonReturn;


TRACE_ERROR(FormatMsgError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(LoadStringError);
TRACE_ERROR(FormatAltNameError);

}
//--------------------------------------------------------------------------
//
//	 FormatCRLReason:  Pre-condition: pReason.cbData != 0
//--------------------------------------------------------------------------
BOOL    FormatCRLReason(DWORD		    dwCertEncodingType,
	                    DWORD		    dwFormatType,
	                    DWORD		    dwFormatStrType,
	                    void		    *pFormatStruct,
	                    LPCSTR		    lpszStructType,
                        PCRYPT_BIT_BLOB pInfo,
                        LPWSTR          *ppwszFormat)
{
    LPWSTR                          pwszFormat=NULL;
    LPWSTR                          pwszByte=NULL;

    WCHAR                           wszReason[CRL_REASON_SIZE+1];
	DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;
                                               				
		*ppwszFormat=NULL;

        pwszFormat=(LPWSTR)malloc(sizeof(WCHAR));
        if(NULL==pwszFormat)
            goto MemoryError;

        *pwszFormat=L'\0';

        //format the 1st byte
        if(pInfo->pbData[0] & CRL_REASON_UNUSED_FLAG)
        {
            if(!LoadStringU(hFrmtFuncInst, IDS_UNSPECIFIED, wszReason, CRL_REASON_SIZE))
		        goto LoadStringError;

            pwszFormat=(LPWSTR)realloc(pwszFormat, 
				sizeof(WCHAR) * (wcslen(pwszFormat)+wcslen(wszReason)+1+wcslen(wszCOMMA)));
            if(NULL==pwszFormat)
                goto MemoryError;

            wcscat(pwszFormat, wszReason);
            wcscat(pwszFormat, wszCOMMA);
        }

        if(pInfo->pbData[0] & CRL_REASON_KEY_COMPROMISE_FLAG)
        {
            if(!LoadStringU(hFrmtFuncInst, IDS_KEY_COMPROMISE, wszReason,CRL_REASON_SIZE))
		        goto LoadStringError;

            pwszFormat=(LPWSTR)realloc(pwszFormat, 
				sizeof(WCHAR) * (wcslen(pwszFormat)+wcslen(wszReason)+1+wcslen(wszCOMMA)));
            if(NULL==pwszFormat)
                goto MemoryError;

            wcscat(pwszFormat, wszReason);
            wcscat(pwszFormat, wszCOMMA);
        }

        if(pInfo->pbData[0] & CRL_REASON_CA_COMPROMISE_FLAG )
        {
            if(!LoadStringU(hFrmtFuncInst, IDS_CA_COMPROMISE,wszReason, CRL_REASON_SIZE))
		        goto LoadStringError;

            pwszFormat=(LPWSTR)realloc(pwszFormat, 
				sizeof(WCHAR) * (wcslen(pwszFormat)+wcslen(wszReason)+1+wcslen(wszCOMMA)));
            if(NULL==pwszFormat)
                goto MemoryError;

            wcscat(pwszFormat, wszReason);
            wcscat(pwszFormat, wszCOMMA);
       }


        if(pInfo->pbData[0] & CRL_REASON_AFFILIATION_CHANGED_FLAG )
        {
            if(!LoadStringU(hFrmtFuncInst, IDS_AFFILIATION_CHANGED, wszReason, CRL_REASON_SIZE))
		        goto LoadStringError;

            pwszFormat=(LPWSTR)realloc(pwszFormat, 
				sizeof(WCHAR) * (wcslen(pwszFormat)+wcslen(wszReason)+1+wcslen(wszCOMMA)));
            if(NULL==pwszFormat)
                goto MemoryError;

            wcscat(pwszFormat, wszReason);
            wcscat(pwszFormat, wszCOMMA);
        }

        if(pInfo->pbData[0] & CRL_REASON_SUPERSEDED_FLAG )
        {
            if(!LoadStringU(hFrmtFuncInst, IDS_SUPERSEDED, wszReason, CRL_REASON_SIZE))
		        goto LoadStringError;

			pwszFormat=(LPWSTR)realloc(pwszFormat, 
				sizeof(WCHAR) * (wcslen(pwszFormat)+wcslen(wszReason)+1+wcslen(wszCOMMA)));
            if(NULL==pwszFormat)
                goto MemoryError;

            wcscat(pwszFormat, wszReason);
            wcscat(pwszFormat, wszCOMMA);
        }

        if(pInfo->pbData[0] & CRL_REASON_CESSATION_OF_OPERATION_FLAG )
        {
            if(!LoadStringU(hFrmtFuncInst, IDS_CESSATION_OF_OPERATION, wszReason, CRL_REASON_SIZE))
		        goto LoadStringError;

            pwszFormat=(LPWSTR)realloc(pwszFormat, 
				sizeof(WCHAR) * (wcslen(pwszFormat)+wcslen(wszReason)+1+wcslen(wszCOMMA)));
            if(NULL==pwszFormat)
                goto MemoryError;

            wcscat(pwszFormat, wszReason);
            wcscat(pwszFormat, wszCOMMA);
       }

         if(pInfo->pbData[0] & CRL_REASON_CERTIFICATE_HOLD_FLAG  )
        {
            if(!LoadStringU(hFrmtFuncInst, IDS_CERTIFICATE_HOLD, wszReason, CRL_REASON_SIZE))
		        goto LoadStringError;

            pwszFormat=(LPWSTR)realloc(pwszFormat, 
				sizeof(WCHAR) * (wcslen(pwszFormat)+wcslen(wszReason)+1+wcslen(wszCOMMA)));
            if(NULL==pwszFormat)
                goto MemoryError;

            wcscat(pwszFormat, wszReason);
            wcscat(pwszFormat, wszCOMMA);
        }

        if(0==wcslen(pwszFormat))
        {
           pwszFormat=(LPWSTR)realloc(pwszFormat, sizeof(WCHAR) * (UNKNOWN_CRL_REASON_SIZE+1));

           if(!LoadStringU(hFrmtFuncInst, IDS_UNKNOWN_CRL_REASON, pwszFormat,
               UNKNOWN_CRL_REASON_SIZE))
		            goto LoadStringError;
        }
        else
        {
            //get rid of the last comma
            *(pwszFormat+wcslen(pwszFormat)-wcslen(wszCOMMA))=L'\0';
        }

        //get the Hex dump of the Key Usage
       cbNeeded=0;

       if(!FormatBytesToHex(
                        dwCertEncodingType,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        lpszStructType,
                        pInfo->pbData,
                        pInfo->cbData,
                        NULL,
	                    &cbNeeded))
            goto FormatBytesToHexError;

        pwszByte=(LPWSTR)malloc(cbNeeded);
        if(NULL==pwszByte)
            goto MemoryError;

        if(!FormatBytesToHex(
                        dwCertEncodingType,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        lpszStructType,
                        pInfo->pbData,
                        pInfo->cbData,
                        pwszByte,
	                    &cbNeeded))
            goto FormatBytesToHexError;


    //convert the WSZ
    if(!FormatMessageUnicode(ppwszFormat, IDS_BIT_BLOB, pwszFormat,
        pwszByte))
        goto FormatMsgError;

	fResult=TRUE;
	

CommonReturn:
    if(pwszFormat)
        free(pwszFormat);

    if(pwszByte)
        free(pwszByte);

	return fResult;

ErrorReturn:
    if(*ppwszFormat)
    {
        LocalFree((HLOCAL)(*ppwszFormat));
        *ppwszFormat=NULL;
    }

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(LoadStringError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(FormatBytesToHexError);
TRACE_ERROR(FormatMsgError);

}

//--------------------------------------------------------------------------
//
//	 FormatCRLDistPoints:   X509_CRL_DIST_POINTS
//                          szOID_CRL_DIST_POINTS
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatCRLDistPoints(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	
	LPWSTR							    pwszFormat=NULL;
    LPWSTR                              pwsz=NULL;
    LPWSTR                              pwszEntryFormat=NULL;
    LPWSTR                              pwszEntryTagFormat=NULL;

    LPWSTR                              pwszPointName=NULL;
    LPWSTR                              pwszNameFormat=NULL;
    LPWSTR                              pwszCRLReason=NULL;
    LPWSTR                              pwszReasonFormat=NULL;
    LPWSTR                              pwszCRLIssuer=NULL;
    LPWSTR                              pwszIssuerFormat=NULL;

	PCRL_DIST_POINTS_INFO	        pInfo=NULL;

	DWORD							cbNeeded=0;
    DWORD                           dwIndex=0;
	BOOL							fResult=FALSE;
    HRESULT                         hr=S_OK;
    UINT                            ids=0;

	
	//check for input parameters
	if((NULL==pbEncoded&& cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,X509_CRL_DIST_POINTS,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

    pwsz=(LPWSTR)malloc(sizeof(WCHAR));
    if(NULL==pwsz)
        goto MemoryError;
    *pwsz=L'\0';

    for(dwIndex=0; dwIndex<pInfo->cDistPoint; dwIndex++)
    {

        //format distribution name
        if(0!=pInfo->rgDistPoint[dwIndex].DistPointName.dwDistPointNameChoice)
        {
            if(!FormatDistPointName(
                    dwCertEncodingType,
                    dwFormatType,
                    dwFormatStrType,
                    pFormatStruct,
                    &(pInfo->rgDistPoint[dwIndex].DistPointName),
                    &pwszPointName))
                goto FormatDistPointNameError;

           //decide between single line and mulitple line format
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                ids=IDS_CRL_DIST_NAME_MULTI;
            else
                ids=IDS_CRL_DIST_NAME;


            if(!FormatMessageUnicode(&pwszNameFormat, ids,pwszPointName))
                goto FormatMsgError;
        }

        //format the CRL reason
        if(0!=pInfo->rgDistPoint[dwIndex].ReasonFlags.cbData)
        {
            if(!FormatCRLReason(dwCertEncodingType,
                                dwFormatType,
                                dwFormatStrType,
                                pFormatStruct,
                                lpszStructType,
                                &(pInfo->rgDistPoint[dwIndex].ReasonFlags),
                                &pwszCRLReason))
                goto FormatCRLReasonError;


            //decide between single line and mulitple line format
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                ids=IDS_CRL_DIST_REASON_MULTI;
            else
                ids=IDS_CRL_DIST_REASON;

            if(!FormatMessageUnicode(&pwszReasonFormat, ids ,pwszCRLReason))
                goto FormatMsgError;

        }

        //format the Issuer
       if(0!=pInfo->rgDistPoint[dwIndex].CRLIssuer.cAltEntry)
       {
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                ids=IDS_TWO_TABS;
            else
                ids=0;


            cbNeeded=0;
            if(!FormatAltNameInfo(dwCertEncodingType,
                                 dwFormatType,
                                 dwFormatStrType,
                                 pFormatStruct,
                                 ids,
                                 FALSE,
                                 &(pInfo->rgDistPoint[dwIndex].CRLIssuer),
                                 NULL,
                                 &cbNeeded))
                goto FormatAltNameError;

           pwszCRLIssuer=(LPWSTR)malloc(cbNeeded);
           if(NULL==pwszCRLIssuer)
               goto MemoryError;

            if(!FormatAltNameInfo(dwCertEncodingType,
                                 dwFormatType,
                                 dwFormatStrType,
                                 pFormatStruct,
                                 ids,
                                 FALSE,
                                 &(pInfo->rgDistPoint[dwIndex].CRLIssuer),
                                 pwszCRLIssuer,
                                 &cbNeeded))
                goto FormatAltNameError;

            //decide between single line and mulitple line format
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                ids=IDS_CRL_DIST_ISSUER_MULTI;
            else
                ids=IDS_CRL_DIST_ISSUER;

            if(!FormatMessageUnicode(&pwszIssuerFormat,ids,pwszCRLIssuer))
                goto FormatMsgError;
       }

       cbNeeded=0;

       if(pwszNameFormat)
           cbNeeded+=wcslen(pwszNameFormat);

       if(pwszReasonFormat)
           cbNeeded+=wcslen(pwszReasonFormat);

       if(pwszIssuerFormat)
           cbNeeded+=wcslen(pwszIssuerFormat);

       if(0!=cbNeeded)
       {

            //add ", " between each element for single line format
            if(0== (dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
            {
                if(0!=wcslen(pwsz))
                    wcscat(pwsz, wszCOMMA);
            }

            //strcat all the information, including the COMMA
            cbNeeded += wcslen(wszCOMMA)*2;

            pwszEntryFormat=(LPWSTR)malloc(sizeof(WCHAR) * (cbNeeded+1));
            if(NULL==pwszEntryFormat)
                goto MemoryError;

            *pwszEntryFormat=L'\0';

            //strcat all three fields one at a time
            if(pwszNameFormat)
                wcscat(pwszEntryFormat, pwszNameFormat);

            if(pwszReasonFormat)
            {
                if(0!=wcslen(pwszEntryFormat))
                {
                    if(0==(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                        wcscat(pwszEntryFormat, wszCOMMA);
                }

                wcscat(pwszEntryFormat, pwszReasonFormat);
            }

            if(pwszIssuerFormat)
            {
                if(0!=wcslen(pwszEntryFormat))
                {
                    if(0==(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                        wcscat(pwszEntryFormat, wszCOMMA);
                }

                wcscat(pwszEntryFormat, pwszIssuerFormat);
            }

            //format the entry
            //decide between single line and mulitple line format
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                ids=IDS_CRL_DIST_ENTRY_MULTI;
            else
                ids=IDS_CRL_DIST_ENTRY;

            if(!FormatMessageUnicode(&pwszEntryTagFormat, ids, dwIndex+1,
                pwszEntryFormat))
                goto FormatMsgError;

            //strcat the entry
            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszEntryTagFormat)+1));
            if(NULL==pwsz)
                goto MemoryError;

            wcscat(pwsz, pwszEntryTagFormat);

            //free memory
            free(pwszEntryFormat);
            pwszEntryFormat=NULL;

            LocalFree(pwszEntryTagFormat);
            pwszEntryTagFormat=NULL;
       }

       //free memory
       if(pwszPointName)
       {
           LocalFree((HLOCAL)pwszPointName);
           pwszPointName=NULL;
       }

       if(pwszCRLReason)
       {
           LocalFree((HLOCAL)(pwszCRLReason));
           pwszCRLReason=NULL;
       }

       if(pwszCRLIssuer)
       {
           free(pwszCRLIssuer);
           pwszCRLIssuer=NULL;
       }

       if(pwszNameFormat)
       {
            LocalFree((HLOCAL)pwszNameFormat);
            pwszNameFormat=NULL;
       }

       if(pwszReasonFormat)
       {
            LocalFree((HLOCAL)pwszReasonFormat);
            pwszReasonFormat=NULL;
       }

       if(pwszIssuerFormat)
       {
            LocalFree((HLOCAL)pwszIssuerFormat);
            pwszIssuerFormat=NULL;
       }
    }

    if(0==wcslen(pwsz))
    {
       //no data
        pwszFormat=(LPWSTR)malloc(sizeof(WCHAR)*(NO_INFO_SIZE+1));
        if(NULL==pwszFormat)
            goto MemoryError;

        if(!LoadStringU(hFrmtFuncInst,IDS_NO_INFO, pwszFormat, NO_INFO_SIZE))
            goto LoadStringError;

    }
    else
    {
        pwszFormat=pwsz;
        pwsz=NULL;

    }

	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:
    if(pwszEntryFormat)
      free(pwszEntryFormat);

    if(pwszEntryTagFormat)
      LocalFree((HLOCAL)pwszEntryTagFormat);

    //free memory
    if(pwszPointName)
       LocalFree((HLOCAL)pwszPointName);

    if(pwszCRLReason)
       LocalFree((HLOCAL)(pwszCRLReason));

    if(pwszCRLIssuer)
       free(pwszCRLIssuer);

    if(pwszNameFormat)
        LocalFree((HLOCAL)pwszNameFormat);

    if(pwszReasonFormat)
        LocalFree((HLOCAL)pwszReasonFormat);

    if(pwszIssuerFormat)
        LocalFree((HLOCAL)pwszIssuerFormat);

    if(pwsz)
        free(pwsz);

	if(pwszFormat)
		free(pwszFormat);

	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(FormatMsgError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(FormatDistPointNameError);
TRACE_ERROR(FormatCRLReasonError);
TRACE_ERROR(FormatAltNameError);

}

//--------------------------------------------------------------------------
//
//	FormatCertPolicyID:
//
//      Pre-condition: pCertPolicyID has to include the valid information.that is,
//      cCertPolicyElementId can not be 0.
//--------------------------------------------------------------------------
BOOL FormatCertPolicyID(PCERT_POLICY_ID pCertPolicyID, LPWSTR  *ppwszFormat)
{

    BOOL        fResult=FALSE;
    LPSTR       pszFormat=NULL;
    DWORD       dwIndex=0;
    HRESULT     hr=S_OK;

    *ppwszFormat=NULL;

    if(0==pCertPolicyID->cCertPolicyElementId)
        goto InvalidArg;

    pszFormat=(LPSTR)malloc(sizeof(CHAR));
    if(NULL==pszFormat)
        goto MemoryError;

    *pszFormat='\0';


    for(dwIndex=0; dwIndex<pCertPolicyID->cCertPolicyElementId; dwIndex++)
    {

        pszFormat=(LPSTR)realloc(pszFormat, strlen(pszFormat)+
                strlen(pCertPolicyID->rgpszCertPolicyElementId[dwIndex])+strlen(strCOMMA)+1);
        if(NULL==pszFormat)
            goto MemoryError;

        strcat(pszFormat,pCertPolicyID->rgpszCertPolicyElementId[dwIndex]);

        strcat(pszFormat, strCOMMA);
    }

    //get rid of the last COMMA
    *(pszFormat+strlen(pszFormat)-strlen(strCOMMA))='\0';

    //convert to WCHAR
    if(S_OK!=(hr=SZtoWSZ(pszFormat, ppwszFormat)))
        goto SZtoWSZError;

	fResult=TRUE;

CommonReturn:

    if(pszFormat)
        free(pszFormat);

	return fResult;

ErrorReturn:
    if(*ppwszFormat)
    {
        free(*ppwszFormat);
        *ppwszFormat=NULL;
    }

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
SET_ERROR_VAR(SZtoWSZError,hr);
}

//--------------------------------------------------------------------------
//
//	 FormatKeyRestriction:   X509_KEY_USAGE_RESTRICTION
//                           szOID_KEY_USAGE_RESTRICTION
//
//
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatKeyRestriction(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	
	LPWSTR							    pwszFormat=NULL;
    LPWSTR                              pwsz=NULL;
	PCERT_KEY_USAGE_RESTRICTION_INFO	pInfo=NULL;
    LPWSTR                              pwszPolicy=NULL;
    LPWSTR                              pwszPolicyFormat=NULL;
    LPWSTR                              pwszKeyUsage=NULL;
    LPWSTR                              pwszKeyUsageFormat=NULL;



	DWORD							    cbNeeded=0;
    DWORD                               dwIndex=0;
	BOOL							    fResult=FALSE;
    HRESULT                             hr=S_OK;
    UINT                                ids=0;

	
	//check for input parameters
	if((NULL==pbEncoded&& cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,X509_KEY_USAGE_RESTRICTION,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

    pwsz=(LPWSTR)malloc(sizeof(WCHAR));
    if(NULL==pwsz)
        goto MemoryError;

    *pwsz=L'\0';

    for(dwIndex=0; dwIndex<pInfo->cCertPolicyId; dwIndex++)
    {

       if(0!=((pInfo->rgCertPolicyId)[dwIndex].cCertPolicyElementId))
       {
            //concatecate the comma if not the 1st item
            if(0!=wcslen(pwsz))
            {
                if(0== (dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                    wcscat(pwsz, wszCOMMA);
            }

            if(!FormatCertPolicyID(&((pInfo->rgCertPolicyId)[dwIndex]), &pwszPolicy))
                goto FormatCertPolicyIDError;

            //decide between single line and mulitple line format
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                ids=IDS_KEY_RES_ID_MULTI;
            else
                ids=IDS_KEY_RES_ID;

            if(!FormatMessageUnicode(&pwszPolicyFormat, ids,dwIndex+1,pwszPolicy))
                goto FormatMsgError;

            //allocate memory, including the ", "
            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszPolicyFormat)+1));
            if(NULL==pwsz)
                goto MemoryError;

            wcscat(pwsz, pwszPolicyFormat);


            free(pwszPolicy);
            pwszPolicy=NULL;

            LocalFree((HLOCAL)pwszPolicyFormat);
            pwszPolicyFormat=NULL;
       }
    }

    //format the RestrictedKeyUsage
    if(0!=pInfo->RestrictedKeyUsage.cbData)
    {
       //concatecate the comma if not the 1st item
        if(0!=wcslen(pwsz))
        {
            if(0== (dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                wcscat(pwsz, wszCOMMA);
        }


        cbNeeded=0;

        if(!FormatKeyUsageBLOB(
                        dwCertEncodingType,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        lpszStructType,
                        &(pInfo->RestrictedKeyUsage),
                        NULL,
	                    &cbNeeded))
             goto FormatKeyUsageBLOBError;

        pwszKeyUsage=(LPWSTR)malloc(cbNeeded);
        if(NULL==pwszKeyUsage)
               goto MemoryError;

       if(!FormatKeyUsageBLOB(
                        dwCertEncodingType,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        lpszStructType,
                        &(pInfo->RestrictedKeyUsage),
                        pwszKeyUsage,
	                    &cbNeeded))
              goto FormatKeyUsageBLOBError;

      //decide between single line and mulitple line format
      if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                ids=IDS_KEY_RES_USAGE_MULTI;
       else
                ids=IDS_KEY_RES_USAGE;

        //format the element string
        if(!FormatMessageUnicode(&pwszKeyUsageFormat, ids, pwszKeyUsage))
            goto FormatMsgError;

        pwsz=(LPWSTR)realloc(pwsz, 
            sizeof(WCHAR) * (wcslen(pwsz)+wcslen(pwszKeyUsageFormat)+1));
        if(NULL==pwsz)
            goto MemoryError;

        wcscat(pwsz, pwszKeyUsageFormat);
    }

    if(0==wcslen(pwsz))
    {
       //no data
        pwszFormat=(LPWSTR)malloc(sizeof(WCHAR)*(NO_INFO_SIZE+1));
        if(NULL==pwszFormat)
            goto MemoryError;

        if(!LoadStringU(hFrmtFuncInst,IDS_NO_INFO, pwszFormat, NO_INFO_SIZE))
            goto LoadStringError;

    }
    else
    {
        pwszFormat=pwsz;
        pwsz=NULL;
    }

	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:
    if(pwszPolicy)
        free(pwszPolicy);

    if(pwszPolicyFormat)
        LocalFree((HLOCAL)pwszPolicyFormat);

    if(pwszKeyUsage)
        free(pwszKeyUsage);

    if(pwszKeyUsageFormat)
        LocalFree((HLOCAL)pwszKeyUsageFormat);

    if(pwszFormat)
		free(pwszFormat);

    if(pwsz)
        free(pwsz);

	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(FormatMsgError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(FormatCertPolicyIDError);
TRACE_ERROR(FormatKeyUsageBLOBError);

}

//-----------------------------------------------------------------------
//
//	 FormatFileTime
//
//   Pre-condition: pFileTime points to valid data
//
//------------------------------------------------------------------------
BOOL	FormatFileTime(FILETIME *pFileTime,LPWSTR   *ppwszFormat)
{
	SYSTEMTIME		SysTime;
	FILETIME		LocalFileTime;
	BOOL			fResult=FALSE;
    WCHAR           wszDay[DAY_SIZE];
    WCHAR           wszMonth[MONTH_SIZE];
    UINT            idsDay=0;
    UINT            idsMonth=0;

    *ppwszFormat=NULL;


	//now we format FileTime to SysTime as default.
	if(FileTimeToLocalFileTime(pFileTime, &LocalFileTime)
		&& FileTimeToSystemTime(&LocalFileTime,&SysTime)
	   )
	{
        //Sunday is 0
        idsDay=IDS_SUNDAY+SysTime.wDayOfWeek;
        //January is 1
        idsMonth=IDS_JAN+SysTime.wMonth-1;

        //load the string
        if(!LoadStringU(hFrmtFuncInst,idsDay, wszDay, sizeof(wszDay)/sizeof(wszDay[0])))
            goto LoadStringError;

        if(!LoadStringU(hFrmtFuncInst,idsMonth, wszMonth,
                    sizeof(wszMonth)/sizeof(wszMonth[0])))
            goto LoadStringError;

        //"%d:%d:%d  %s  %s %d, %d"
		if(!FormatMessageUnicode(ppwszFormat, IDS_FILE_TIME,
			 SysTime.wHour, SysTime.wMinute, SysTime.wSecond,
			 wszDay, wszMonth,
			 SysTime.wDay, SysTime.wYear))
             goto FormatMsgError;

	}
	else
	{
	  	//if failed, pFileTime is more than 0x8000000000000000.
		// all we can do is to print out the integer
        //"HighDateTime: %d LowDateTime: %d"
        if(!FormatMessageUnicode(ppwszFormat, IDS_FILE_TIME_DWORD,
			pFileTime->dwHighDateTime, pFileTime->dwLowDateTime))
            goto FormatMsgError;

	}



	fResult=TRUE;

CommonReturn:

	return fResult;

ErrorReturn:
    if(*ppwszFormat)
    {
        LocalFree((HLOCAL)(*ppwszFormat));
        *ppwszFormat=NULL;
    }

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(FormatMsgError);
TRACE_ERROR(LoadStringError);

}




//--------------------------------------------------------------------------
//
//	 FormatKeyAttributes:   X509_KEY_ATTRIBUTES
//                          szOID_KEY_ATTRIBUTES
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatKeyAttributes(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{

    LPWSTR							pwszFormat=NULL;
    LPWSTR                          pwsz=NULL;

    LPWSTR                          pwszKeyIDFormat=NULL;
    LPWSTR                          pwszKeyID=NULL;

    LPWSTR                          pwszKeyUsageFormat=NULL;
    LPWSTR                          pwszKeyUsage=NULL;

    LPWSTR                          pwszKeyBeforeFormat=NULL;
    LPWSTR                          pwszKeyBefore=NULL;

    LPWSTR                          pwszKeyAfterFormat=NULL;
    LPWSTR                          pwszKeyAfter=NULL;
	PCERT_KEY_ATTRIBUTES_INFO   	pInfo=NULL;


	DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;
    HRESULT                         hr=S_OK;
    UINT                            ids=0;

	
	//check for input parameters
	if((NULL==pbEncoded&& cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,X509_KEY_ATTRIBUTES,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

    pwsz=(LPWSTR)malloc(sizeof(WCHAR));
    if(NULL==pwsz)
        goto MemoryError;

    *pwsz=L'\0';


    if(0!=pInfo->KeyId.cbData)
    {
        cbNeeded=0;

        if(!FormatBytesToHex(
                        dwCertEncodingType,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        lpszStructType,
                        pInfo->KeyId.pbData,
                        pInfo->KeyId.cbData,
                        NULL,
	                    &cbNeeded))
             goto FormatBytesToHexError;

        pwszKeyID=(LPWSTR)malloc(cbNeeded);
        if(NULL==pwszKeyID)
               goto MemoryError;

       if(!FormatBytesToHex(
                        dwCertEncodingType,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        lpszStructType,
                        pInfo->KeyId.pbData,
                        pInfo->KeyId.cbData,
                        pwszKeyID,
	                    &cbNeeded))
              goto FormatBytesToHexError;


        //format the element string

        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            ids=IDS_KEY_ATTR_ID_MULTI;
        else
            ids=IDS_KEY_ATTR_ID;

        if(!FormatMessageUnicode(&pwszKeyIDFormat, ids, pwszKeyID))
            goto FormatMsgError;

        pwsz=(LPWSTR)realloc(pwsz, 
            sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszKeyIDFormat)+1));
        if(NULL==pwsz)
            goto MemoryError;

        wcscat(pwsz, pwszKeyIDFormat);
    }


    //check the no data situation
    if(0!=pInfo->IntendedKeyUsage.cbData)
    {
        //strcat a ", " symbol for signle line format
       if(0== (dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
        {
            if(0!=wcslen(pwsz))
                wcscat(pwsz, wszCOMMA);
        }


        cbNeeded=0;

        if(!FormatKeyUsageBLOB(
                        dwCertEncodingType,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        lpszStructType,
                        &(pInfo->IntendedKeyUsage),
                        NULL,
	                    &cbNeeded))
             goto FormatKeyUsageBLOBError;

        pwszKeyUsage=(LPWSTR)malloc(cbNeeded);
        if(NULL==pwszKeyUsage)
               goto MemoryError;

       if(!FormatKeyUsageBLOB(
                        dwCertEncodingType,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        lpszStructType,
                        &(pInfo->IntendedKeyUsage),
                        pwszKeyUsage,
	                    &cbNeeded))
              goto FormatKeyUsageBLOBError;


        //format the element string

        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            ids=IDS_KEY_ATTR_USAGE_MULTI;
        else
            ids=IDS_KEY_ATTR_USAGE;

        if(!FormatMessageUnicode(&pwszKeyUsageFormat, ids, pwszKeyUsage))
            goto FormatMsgError;

        pwsz=(LPWSTR)realloc(pwsz, 
            sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszKeyUsageFormat)+1));
        if(NULL==pwsz)
            goto MemoryError;

        wcscat(pwsz, pwszKeyUsageFormat);

    }

    if(NULL!=pInfo->pPrivateKeyUsagePeriod)
    {
        //format only if there is some information
        if(!((0==pInfo->pPrivateKeyUsagePeriod->NotBefore.dwHighDateTime)
           &&(0==pInfo->pPrivateKeyUsagePeriod->NotBefore.dwLowDateTime)))
        {
            //strcat a ", " symbol for signle line format
            if(0== (dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
            {
                if(0!=wcslen(pwsz))
                    wcscat(pwsz, wszCOMMA);
            }


            if(!FormatFileTime(&(pInfo->pPrivateKeyUsagePeriod->NotBefore),
                            &pwszKeyBefore))
                goto FormatFileTimeError;


            //format the element string

            //decide between single line and mulitple line format
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                ids=IDS_KEY_ATTR_BEFORE_MULTI;
            else
                ids=IDS_KEY_ATTR_BEFORE;

            if(!FormatMessageUnicode(&pwszKeyBeforeFormat, ids,
                    pwszKeyBefore))
                goto FormatMsgError;

            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR)*(wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszKeyBeforeFormat)+1));
            if(NULL==pwsz)
                goto MemoryError;

            wcscat(pwsz, pwszKeyBeforeFormat);
        }

        if(!((0==pInfo->pPrivateKeyUsagePeriod->NotAfter.dwHighDateTime)
           &&(0==pInfo->pPrivateKeyUsagePeriod->NotAfter.dwLowDateTime)))
        {

            //strcat a ", " symbol for signle line format
            if(0== (dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
            {
                if(0!=wcslen(pwsz))
                    wcscat(pwsz, wszCOMMA);
            }


            if(!FormatFileTime(&(pInfo->pPrivateKeyUsagePeriod->NotAfter),
                            &pwszKeyAfter))
                goto FormatFileTimeError;

            //format the element string

           //decide between single line and mulitple line format
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                ids=IDS_KEY_ATTR_AFTER_MULTI;
            else
                ids=IDS_KEY_ATTR_AFTER;

            if(!FormatMessageUnicode(&pwszKeyAfterFormat, ids,
                    pwszKeyAfter))
                goto FormatMsgError;

            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszKeyAfterFormat)+1));
            if(NULL==pwsz)
                goto MemoryError;

            wcscat(pwsz, pwszKeyAfterFormat);

        }

    }

    if(0==wcslen(pwsz))
    {
       pwszFormat=(LPWSTR)malloc(sizeof(WCHAR)*(NO_INFO_SIZE+1));
       if(NULL==pwszFormat)
           goto MemoryError;

       if(!LoadStringU(hFrmtFuncInst,IDS_NO_INFO, pwszFormat,NO_INFO_SIZE))
           goto LoadStringError;

    }
    else
    {
        pwszFormat=pwsz;
        pwsz=NULL;

    }

	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:

    if(pwszKeyIDFormat)
        LocalFree((HLOCAL)pwszKeyIDFormat);

    if(pwszKeyID)
        free(pwszKeyID);

    if(pwszKeyUsageFormat)
        LocalFree((HLOCAL)pwszKeyUsageFormat);

    if(pwszKeyUsage)
        free(pwszKeyUsage);

    if(pwszKeyBeforeFormat)
        LocalFree((HLOCAL)pwszKeyBeforeFormat);

    if(pwszKeyBefore)
        LocalFree((HLOCAL)pwszKeyBefore);

    if(pwszKeyAfterFormat)
        LocalFree((HLOCAL)pwszKeyAfterFormat);

    if(pwszKeyAfter)
        LocalFree((HLOCAL)pwszKeyAfter);

	if(pwszFormat)
		free(pwszFormat);

    if(pwsz)
        free(pwsz);

	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(FormatKeyUsageBLOBError);
TRACE_ERROR(FormatFileTimeError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(FormatBytesToHexError);
TRACE_ERROR(FormatMsgError);
}

//--------------------------------------------------------------------------
//
//	 FormatAuthortiyInfoAccess:   X509_AUTHORITY_INFO_ACCESS
//                                szOID_AUTHORITY_INFO_ACCESS
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatAuthortiyInfoAccess(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
    BOOL                            fMethodAllocated=FALSE;
    WCHAR                           wszNoInfo[NO_INFO_SIZE];
    WCHAR                           wszUnknownAccess[UNKNOWN_ACCESS_METHOD_SIZE];
    PCCRYPT_OID_INFO                pOIDInfo=NULL;
    CERT_ALT_NAME_INFO              CertAltNameInfo;


	LPWSTR							pwszFormat=NULL;
    LPWSTR                          pwsz=NULL;
    LPWSTR                          pwszMethod=NULL;
    LPWSTR                          pwszAltName=NULL;
    LPWSTR                          pwszEntryFormat=NULL;
	PCERT_AUTHORITY_INFO_ACCESS	    pInfo=NULL;

    DWORD                           dwIndex=0;
	DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;
    HRESULT                         hr=S_OK;
    UINT                            ids=0;

	
	//check for input parameters
	if((NULL==pbEncoded&& cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,X509_AUTHORITY_INFO_ACCESS,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;


    if(0==pInfo->cAccDescr)
    {
        //load the string "Info Not Available"
	    if(!LoadStringU(hFrmtFuncInst,IDS_NO_INFO, wszNoInfo, sizeof(wszNoInfo)/sizeof(wszNoInfo[0])))
		    goto LoadStringError;

        pwszFormat=wszNoInfo;
    }
    else
    {
        pwsz=(LPWSTR)malloc(sizeof(WCHAR));
        if(NULL==pwsz)
            goto MemoryError;

        *pwsz=L'\0';

        //load the string "Unknown Access Method:
	    if(!LoadStringU(hFrmtFuncInst,IDS_UNKNOWN_ACCESS_METHOD, wszUnknownAccess,
            sizeof(wszUnknownAccess)/sizeof(wszUnknownAccess[0])))
		    goto LoadStringError;

        for(dwIndex=0; dwIndex < pInfo->cAccDescr; dwIndex++)
        {
            fMethodAllocated=FALSE;

            //need a ", " between each element for single line format
            if(0!=wcslen(pwsz))
            {
                if(0==(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE) )
                    wcscat(pwsz, wszCOMMA);
            }

            //get the name of the access method
            if(pInfo->rgAccDescr[dwIndex].pszAccessMethod)
            {

                pOIDInfo=CryptFindOIDInfo(CRYPT_OID_INFO_OID_KEY,
									 (void *)(pInfo->rgAccDescr[dwIndex].pszAccessMethod),
									  CRYPT_EXT_OR_ATTR_OID_GROUP_ID);

                //get the access method OID
                if(pOIDInfo)
			    {
				    //allocate memory, including the NULL terminator
				    pwszMethod=(LPWSTR)malloc((wcslen(pOIDInfo->pwszName)+1)*
				    					sizeof(WCHAR));

				    if(NULL==pwszMethod)
					    goto MemoryError;

                    fMethodAllocated=TRUE;

				    wcscpy(pwszMethod,pOIDInfo->pwszName);

			    }else
                    pwszMethod=wszUnknownAccess;
            }

            memset(&CertAltNameInfo, 0, sizeof(CERT_ALT_NAME_INFO));
            CertAltNameInfo.cAltEntry=1;
            CertAltNameInfo.rgAltEntry=&(pInfo->rgAccDescr[dwIndex].AccessLocation);

            //need to tell if it is for multi line format.  We need two \t\t
            //in front of each alt name entry
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                ids=IDS_TWO_TABS;
            else
                ids=0;

            //get the alternative name entry
            cbNeeded=0;
            if(!FormatAltNameInfo(dwCertEncodingType,
                                 dwFormatType,
                                 dwFormatStrType,
                                 pFormatStruct,
                                 ids,
                                 FALSE,
                                 &CertAltNameInfo,
                                 NULL,
                                 &cbNeeded))
                goto FormatAltNameError;

           pwszAltName=(LPWSTR)malloc(cbNeeded);
           if(NULL==pwszAltName)
               goto MemoryError;

            if(!FormatAltNameInfo(dwCertEncodingType,
                                 dwFormatType,
                                 dwFormatStrType,
                                 pFormatStruct,
                                 ids,
                                 FALSE,
                                 &CertAltNameInfo,
                                 pwszAltName,
                                 &cbNeeded))
                goto FormatAltNameError;

            //format the entry
            if(pInfo->rgAccDescr[dwIndex].pszAccessMethod)
            {

                //decide between single line and mulitple line format
                if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                    ids=IDS_AUTHORITY_ACCESS_INFO_MULTI;
                else
                    ids=IDS_AUTHORITY_ACCESS_INFO;


                if(!FormatMessageUnicode(&pwszEntryFormat, ids,
                    dwIndex+1, pwszMethod, pInfo->rgAccDescr[dwIndex].pszAccessMethod,
                    pwszAltName))
                    goto FormatMsgError;
            }
            else
            {
                //decide between single line and mulitple line format
                if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                    ids=IDS_AUTHORITY_ACCESS_NO_METHOD_MULTI;
                else
                    ids=IDS_AUTHORITY_ACCESS_NO_METHOD;


                if(!FormatMessageUnicode(&pwszEntryFormat, ids, dwIndex+1, pwszAltName))
                    goto FormatMsgError;

            }

            //reallocat the memory.  Leave space for szComma
            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(pwszEntryFormat)+
                                        wcslen(wszCOMMA)+1));
            if(NULL==pwsz)
                goto MemoryError;

            wcscat(pwsz, pwszEntryFormat);

            //free memory
            LocalFree((HLOCAL)pwszEntryFormat);
            pwszEntryFormat=NULL;

            free(pwszAltName);
            pwszAltName=NULL;

            if(TRUE==fMethodAllocated)
                free(pwszMethod);

            pwszMethod=NULL;

        }

        //convert to WCHAR
        pwszFormat=pwsz;
    }


	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:

    if(pwsz)
        free(pwsz);

    if(pwszEntryFormat)
         LocalFree((HLOCAL)pwszEntryFormat);

    if(pwszAltName)
        free(pwszAltName);

    if(fMethodAllocated)
    {
        if(pwszMethod)
             free(pwszMethod);
    }

	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(FormatMsgError);
TRACE_ERROR(FormatAltNameError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);

}

//--------------------------------------------------------------------------
//
//	 FormatKeyUsageBLOB
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatKeyUsageBLOB(
	DWORD		    dwCertEncodingType,
	DWORD		    dwFormatType,
	DWORD		    dwFormatStrType,
	void		    *pFormatStruct,
	LPCSTR		    lpszStructType,
    PCRYPT_BIT_BLOB	pInfo,
	void	        *pbFormat,
	DWORD	        *pcbFormat)
{
   	LPWSTR							pwszFormat=NULL;
    LPWSTR                          pwsz=NULL;
    LPWSTR                          pwszByte=NULL;

    WCHAR                           wszKeyUsage[KEY_USAGE_SIZE+1];
	DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;


        pwsz=(LPWSTR)malloc(sizeof(WCHAR));
        if(NULL==pwsz)
            goto MemoryError;

        *pwsz=L'\0';

        //format the 1st byte
        if(pInfo->pbData[0] & CERT_DIGITAL_SIGNATURE_KEY_USAGE)
        {
            if(!LoadStringU(hFrmtFuncInst, IDS_DIG_SIG, wszKeyUsage, KEY_USAGE_SIZE))
		        goto LoadStringError;

            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
            if(NULL==pwsz)
                goto MemoryError;

            wcscat(pwsz, wszKeyUsage);
            wcscat(pwsz, wszCOMMA);
        }

        if(pInfo->pbData[0] & CERT_NON_REPUDIATION_KEY_USAGE)
        {
            if(!LoadStringU(hFrmtFuncInst, IDS_NON_REPUDIATION, wszKeyUsage, KEY_USAGE_SIZE))
		        goto LoadStringError;

            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
            if(NULL==pwsz)
                goto MemoryError;

            wcscat(pwsz, wszKeyUsage);
            wcscat(pwsz, wszCOMMA);
        }

        if(pInfo->pbData[0] & CERT_KEY_ENCIPHERMENT_KEY_USAGE )
        {
            if(!LoadStringU(hFrmtFuncInst, IDS_KEY_ENCIPHERMENT, wszKeyUsage, KEY_USAGE_SIZE))
		        goto LoadStringError;

            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
            if(NULL==pwsz)
                goto MemoryError;

            wcscat(pwsz, wszKeyUsage);
            wcscat(pwsz, wszCOMMA);
       }


        if(pInfo->pbData[0] & CERT_DATA_ENCIPHERMENT_KEY_USAGE )
        {
            if(!LoadStringU(hFrmtFuncInst, IDS_DATA_ENCIPHERMENT, wszKeyUsage, KEY_USAGE_SIZE))
		        goto LoadStringError;

            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
            if(NULL==pwsz)
                goto MemoryError;

            wcscat(pwsz, wszKeyUsage);
            wcscat(pwsz, wszCOMMA);
        }

        if(pInfo->pbData[0] & CERT_KEY_AGREEMENT_KEY_USAGE )
        {
            if(!LoadStringU(hFrmtFuncInst, IDS_KEY_AGREEMENT, wszKeyUsage, KEY_USAGE_SIZE))
		        goto LoadStringError;

            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
            if(NULL==pwsz)
                goto MemoryError;

            wcscat(pwsz, wszKeyUsage);
            wcscat(pwsz, wszCOMMA);
        }

        if(pInfo->pbData[0] & CERT_KEY_CERT_SIGN_KEY_USAGE )
        {
            if(!LoadStringU(hFrmtFuncInst, IDS_CERT_SIGN, wszKeyUsage, KEY_USAGE_SIZE))
		        goto LoadStringError;

            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
            if(NULL==pwsz)
                goto MemoryError;

            wcscat(pwsz, wszKeyUsage);
            wcscat(pwsz, wszCOMMA);
       }

         if(pInfo->pbData[0] & CERT_OFFLINE_CRL_SIGN_KEY_USAGE )
        {
            if(!LoadStringU(hFrmtFuncInst, IDS_OFFLINE_CRL_SIGN, wszKeyUsage, KEY_USAGE_SIZE))
		        goto LoadStringError;

            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
            if(NULL==pwsz)
                goto MemoryError;

            wcscat(pwsz, wszKeyUsage);
            wcscat(pwsz, wszCOMMA);
        }

        if(pInfo->pbData[0] & CERT_CRL_SIGN_KEY_USAGE )
        {
            if(!LoadStringU(hFrmtFuncInst, IDS_CRL_SIGN, wszKeyUsage, KEY_USAGE_SIZE))
		        goto LoadStringError;

            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
            if(NULL==pwsz)
                goto MemoryError;

            wcscat(pwsz, wszKeyUsage);
            wcscat(pwsz, wszCOMMA);
       }

        if(pInfo->pbData[0] & CERT_ENCIPHER_ONLY_KEY_USAGE  )
        {
            if(!LoadStringU(hFrmtFuncInst, IDS_ENCIPHER_ONLY, wszKeyUsage, KEY_USAGE_SIZE))
		        goto LoadStringError;

            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
            if(NULL==pwsz)
                goto MemoryError;

            wcscat(pwsz, wszKeyUsage);
            wcscat(pwsz, wszCOMMA);
        }

        //deal with the second byte
        if(pInfo->cbData>=2)
        {

            if(pInfo->pbData[1] & CERT_DECIPHER_ONLY_KEY_USAGE  )
            {
                if(!LoadStringU(hFrmtFuncInst, IDS_DECIPHER_ONLY, wszKeyUsage, KEY_USAGE_SIZE))
		            goto LoadStringError;

                pwsz=(LPWSTR)realloc(pwsz, 
                    sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszKeyUsage)+1+wcslen(wszCOMMA)));
                if(NULL==pwsz)
                    goto MemoryError;

                wcscat(pwsz, wszKeyUsage);
                wcscat(pwsz, wszCOMMA);
            }
        }

        if(0==wcslen(pwsz))
        {
           pwsz=(LPWSTR)realloc(pwsz, sizeof(WCHAR) * (UNKNOWN_KEY_USAGE_SIZE+1));

           if(!LoadStringU(hFrmtFuncInst, IDS_UNKNOWN_KEY_USAGE, pwsz,
               UNKNOWN_KEY_USAGE_SIZE))
		            goto LoadStringError;
        }
        else
        {
            //get rid of the last comma
            *(pwsz+wcslen(pwsz)-wcslen(wszCOMMA))=L'\0';
        }

        //get the Hex dump of the Key Usage
       cbNeeded=0;

       if(!FormatBytesToHex(
                        dwCertEncodingType,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        lpszStructType,
                        pInfo->pbData,
                        pInfo->cbData,
                        NULL,
	                    &cbNeeded))
            goto FormatBytesToHexError;

        pwszByte=(LPWSTR)malloc(cbNeeded);
        if(NULL==pwszByte)
            goto MemoryError;

        if(!FormatBytesToHex(
                        dwCertEncodingType,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        lpszStructType,
                        pInfo->pbData,
                        pInfo->cbData,
                        pwszByte,
	                    &cbNeeded))
            goto FormatBytesToHexError;


    //convert the WSZ
    if(!FormatMessageUnicode(&pwszFormat, IDS_BIT_BLOB, pwsz,
        pwszByte))
        goto FormatMsgError;

	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:

    if(pwszFormat)
        LocalFree((HLOCAL)pwszFormat);

    if(pwsz)
        free(pwsz);

    if(pwszByte)
        free(pwszByte);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(FormatBytesToHexError);
TRACE_ERROR(FormatMsgError);

}
//--------------------------------------------------------------------------
//
//	 FormatKeyUsage:  X509_KEY_USAGE
//                    szOID_KEY_USAGE
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatKeyUsage(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	
	LPWSTR							pwszFormat=NULL;
    WCHAR                           wszNoInfo[NO_INFO_SIZE];
	PCRYPT_BIT_BLOB	                pInfo=NULL;
	DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;

	
	//check for input parameters
	if((NULL==pbEncoded&& cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,X509_KEY_USAGE,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

   //load the string "Info Not Available"
	if(!LoadStringU(hFrmtFuncInst,IDS_NO_INFO, wszNoInfo, sizeof(wszNoInfo)/sizeof(wszNoInfo[0])))
		 goto LoadStringError;

    //check the no data situation
    if(0==pInfo->cbData)
        pwszFormat=wszNoInfo;
    else
    {
        if(1==pInfo->cbData)
        {
           if(0==pInfo->pbData[0])
                pwszFormat=wszNoInfo;
        }
        else
        {
            if(2==pInfo->cbData)
            {
                if((0==pInfo->pbData[0])&&(0==pInfo->pbData[1]))
                    pwszFormat=wszNoInfo;
            }
        }
    }

    if(NULL==pwszFormat)
    {

        fResult=FormatKeyUsageBLOB(dwCertEncodingType,
                                   dwFormatType,
                                   dwFormatStrType,
                                   pFormatStruct,
                                   lpszStructType,
                                   pInfo,
                                   pbFormat,
                                   pcbFormat);

        if(FALSE==fResult)
            goto FormatKeyUsageBLOBError;
    }
    else
    {
       	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	    //length only calculation
	    if(NULL==pbFormat)
	    {
		    *pcbFormat=cbNeeded;
		    fResult=TRUE;
		    goto CommonReturn;
    	}


	    if((*pcbFormat)<cbNeeded)
        {
            *pcbFormat=cbNeeded;
		    goto MoreDataError;
        }

	    //copy the data
	    memcpy(pbFormat, pwszFormat, cbNeeded);

	    //copy the size
	    *pcbFormat=cbNeeded;

	    fResult=TRUE;
    }


CommonReturn:
   	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(FormatKeyUsageBLOBError);
}


//--------------------------------------------------------------------------
//
//	 FormatSMIMECapabilities:   PKCS_SMIME_CAPABILITIES
//                              szOID_RSA_SMIMECapabilities
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatSMIMECapabilities(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	
	LPWSTR							pwszFormat=NULL;
    LPWSTR                          pwsz=NULL;
    LPWSTR                          pwszElementFormat=NULL;
    LPWSTR                          pwszParam=NULL;


	WCHAR							wszNoInfo[NO_INFO_SIZE];
    BOOL                            fParamAllocated=FALSE;
	PCRYPT_SMIME_CAPABILITIES	    pInfo=NULL;
	DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;
    DWORD                           dwIndex =0;
    HRESULT                         hr=S_OK;
    UINT                            idsSub=0;

	
	//check for input parameters
	if((NULL==pbEncoded&& cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,PKCS_SMIME_CAPABILITIES,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

	//check to see if information if available
    if(0==pInfo->cCapability)
    {
         //load the string "Info Not Available"
	    if(!LoadStringU(hFrmtFuncInst,IDS_NO_INFO, wszNoInfo, sizeof(wszNoInfo)/sizeof(wszNoInfo[0])))
		    goto LoadStringError;

        pwszFormat=wszNoInfo;
    }
    else
    {
        pwsz=(LPWSTR)malloc(sizeof(WCHAR));
        if(NULL==pwsz)
            goto MemoryError;

        *pwsz=L'\0';

        for(dwIndex=0; dwIndex < pInfo->cCapability; dwIndex++)
        {
            fParamAllocated=FALSE;

           //strcat ", " if single line.  No need for multi-line
            if(0!=wcslen(pwsz))
            {
                if(0==(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                 wcscat(pwsz, wszCOMMA);
            }


            if(0!=(pInfo->rgCapability)[dwIndex].Parameters.cbData)
            {
                cbNeeded=0;

                if(!FormatBytesToHex(
                        dwCertEncodingType,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        lpszStructType,
                        (pInfo->rgCapability)[dwIndex].Parameters.pbData,
                        (pInfo->rgCapability)[dwIndex].Parameters.cbData,
                        NULL,
	                    &cbNeeded))
                        goto FormatBytesToHexError;

                pwszParam=(LPWSTR)malloc(cbNeeded);
                if(NULL==pwszParam)
                    goto MemoryError;

                fParamAllocated=TRUE;

                if(!FormatBytesToHex(
                        dwCertEncodingType,
                        dwFormatType,
                        dwFormatStrType,
                        pFormatStruct,
                        lpszStructType,
                        (pInfo->rgCapability)[dwIndex].Parameters.pbData,
                        (pInfo->rgCapability)[dwIndex].Parameters.cbData,
                        pwszParam,
	                    &cbNeeded))
                        goto FormatBytesToHexError;

                //decide between single line and mulitple line format
                if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                    idsSub=IDS_MIME_CAPABILITY_MULTI;
                else
                    idsSub=IDS_MIME_CAPABILITY;

                 //format the element string
                if(!FormatMessageUnicode(&pwszElementFormat, idsSub,
                        dwIndex+1,
                        (pInfo->rgCapability)[dwIndex].pszObjId,
                        pwszParam))
                    goto FormatMsgError;
            }
            else
            {
                //decide between single line and mulitple line format
                if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                    idsSub=IDS_MIME_CAPABILITY_NO_PARAM_MULTI;
                else
                    idsSub=IDS_MIME_CAPABILITY_NO_PARAM;

                 //format the element string
                if(!FormatMessageUnicode(&pwszElementFormat, idsSub,
                        dwIndex+1,
                        (pInfo->rgCapability)[dwIndex].pszObjId))
                    goto FormatMsgError;
            }

            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszElementFormat)+1));
            if(NULL==pwsz)
                goto MemoryError;

            //strcat the element
            wcscat(pwsz, pwszElementFormat);

            //free the memory
            LocalFree((HLOCAL)pwszElementFormat);
            pwszElementFormat=NULL;

            if(fParamAllocated)
                free(pwszParam);

            pwszParam=NULL;

        }

        pwszFormat=pwsz;

    }


	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:

    if(pwszElementFormat)
        LocalFree((HLOCAL)pwszElementFormat);

    if(fParamAllocated)
    {
        if(pwszParam)
            free(pwszParam);
    }


	if(pInfo)
		free(pInfo);

    if(pwsz)
        free(pwsz);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(FormatMsgError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(FormatBytesToHexError);
}

//--------------------------------------------------------------------------
//
//	 FormatFinancialCriteria: SPC_FINANCIAL_CRITERIA_OBJID
//                            SPC_FINANCIAL_CRITERIA_STRUCT
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatFinancialCriteria(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	
	LPWSTR							pwszFormat=NULL;
	WCHAR							wszYesNo[YES_NO_SIZE];
	WCHAR							wszAvailable[AVAIL_SIZE];
	PSPC_FINANCIAL_CRITERIA     	pInfo=NULL;
	DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;
    UINT                            idsInfo=0;


	
	//check for input parameters
	if((NULL==pbEncoded&& cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,SPC_FINANCIAL_CRITERIA_STRUCT,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

	//load the string for financial info
    if(TRUE==pInfo->fFinancialInfoAvailable)
    {
        if(TRUE==pInfo->fMeetsCriteria)
            idsInfo=IDS_YES;
        else
            idsInfo=IDS_NO;

        //load the string for "yes" or "no"
        if(!LoadStringU(hFrmtFuncInst,idsInfo, wszYesNo, sizeof(wszYesNo)/sizeof(wszYesNo[0])))
		        goto LoadStringError;

        //mark the avaiblility of the financial info
        idsInfo=IDS_AVAILABLE;
    }
    else
        idsInfo=IDS_NOT_AVAILABLE;

	if(!LoadStringU(hFrmtFuncInst,idsInfo, wszAvailable,
        sizeof(wszAvailable)/sizeof(wszAvailable[0])))
		goto LoadStringError;

    //format the output string
    if(TRUE==pInfo->fFinancialInfoAvailable)
    {
        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            idsInfo=IDS_SPC_FINANCIAL_AVAIL_MULTI;
        else
            idsInfo=IDS_SPC_FINANCIAL_AVAIL;

        if(!FormatMessageUnicode(&pwszFormat, idsInfo,
            wszAvailable, wszYesNo))
            goto FormatMsgError;
    }
    else
    {
        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            idsInfo=IDS_SPC_FINANCIAL_NOT_AVAIL_MULTI;
        else
            idsInfo=IDS_SPC_FINANCIAL_NOT_AVAIL;

        if(!FormatMessageUnicode(&pwszFormat, idsInfo,
            wszAvailable))
            goto FormatMsgError;
    }

	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:
	if(pwszFormat)
		LocalFree((HLOCAL)pwszFormat);

	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(FormatMsgError);

}

//--------------------------------------------------------------------------
//
//	 FormatNextUpdateLocation: szOID_NEXT_UPDATE_LOCATION
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatNextUpdateLocation(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	PCERT_ALT_NAME_INFO	            pInfo=NULL;
	BOOL							fResult=FALSE;

	//check for input parameters
	if((NULL==pbEncoded && cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,szOID_NEXT_UPDATE_LOCATION,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

	//format the alternative name
    fResult=FormatAltNameInfo(dwCertEncodingType, dwFormatType,dwFormatStrType,
                            pFormatStruct,
                            0,      //no prefix
                            TRUE,
                            pInfo, pbFormat, pcbFormat);

    if(FALSE==fResult)
        goto FormatAltNameError;

CommonReturn:

	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(FormatAltNameError);

}

//--------------------------------------------------------------------------
//
//	 FormatSubjectKeyID: szOID_SUBJECT_KEY_IDENTIFIER
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatSubjectKeyID(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	PCRYPT_DATA_BLOB	            pInfo=NULL;
	BOOL							fResult=FALSE;
    WCHAR                           wszNoInfo[NO_INFO_SIZE];
    DWORD                           cbNeeded=0;

	//check for input parameters
	if((NULL==pbEncoded && cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,szOID_SUBJECT_KEY_IDENTIFIER,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

	//format the key subject ID
    //handle NULL data case
    if(0==pInfo->cbData)
    {
         //load the string "Info Not Available"
	    if(!LoadStringU(hFrmtFuncInst,IDS_NO_INFO, wszNoInfo, sizeof(wszNoInfo)/sizeof(wszNoInfo[0])))
		    goto LoadStringError;

        cbNeeded=sizeof(WCHAR)*(wcslen(wszNoInfo)+1);

	    //length only calculation
	    if(NULL==pbFormat)
	    {
		    *pcbFormat=cbNeeded;
		    fResult=TRUE;
		    goto CommonReturn;
	    }


	    if((*pcbFormat)<cbNeeded)
        {
            *pcbFormat=cbNeeded;
		    goto MoreDataError;
        }

	    //copy the data
	    memcpy(pbFormat, wszNoInfo, cbNeeded);

	    //copy the size
	    *pcbFormat=cbNeeded;

	    fResult=TRUE;

    }
    else
    {

        fResult=FormatBytesToHex(dwCertEncodingType,
                            dwFormatType,
                            dwFormatStrType,
                            pFormatStruct,
                            lpszStructType,
                            pInfo->pbData,
                            pInfo->cbData,
                            pbFormat,
                            pcbFormat);


        if(FALSE==fResult)
            goto FormatBytestToHexError;
    }


CommonReturn:

	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(FormatBytestToHexError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);

}

//--------------------------------------------------------------------------
//
//	 FormatAuthorityKeyID: szOID_AUTHORITY_KEY_IDENTIFIER
//                         X509_AUTHORITY_KEY_ID
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatAuthorityKeyID(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	
	LPWSTR							pwszFormat=NULL;
    LPWSTR                          pwsz=NULL;

    LPWSTR                          pwszKeyID=NULL;
    LPWSTR                          pwszKeyIDFormat=NULL;
    LPWSTR                          pwszCertIssuer=NULL;
    LPWSTR                          pwszCertIssuerFormat=NULL;
    LPWSTR                          pwszCertNumber=NULL;
    LPWSTR                          pwszCertNumberFormat=NULL;
    BYTE                            *pByte=NULL;

    DWORD                           dwByteIndex=0;
    WCHAR                           wszNoInfo[NO_INFO_SIZE];
	PCERT_AUTHORITY_KEY_ID_INFO	    pInfo=NULL;
	DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;
    HRESULT                         hr=S_OK;
    UINT                            ids=0;

	
	//check for input parameters
	if((NULL==pbEncoded && cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,X509_AUTHORITY_KEY_ID,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

    //load the string "Info Not Available"
    if((0==pInfo->KeyId.cbData)&&(0==pInfo->CertIssuer.cbData)
        &&(0==pInfo->CertSerialNumber.cbData))
    {
	    if(!LoadStringU(hFrmtFuncInst,IDS_NO_INFO, wszNoInfo, sizeof(wszNoInfo)/sizeof(wszNoInfo[0])))
		    goto LoadStringError;

        pwszFormat=wszNoInfo;
    }
    else
    {
        pwsz=(LPWSTR)malloc(sizeof(WCHAR));
        if(NULL==pwsz)
            goto MemoryError;
        *pwsz=L'\0';

        //format the three fields in the struct: KeyID; CertIssuer; CertSerialNumber
        if(0!=pInfo->KeyId.cbData)
        {
            cbNeeded=0;

            if(!FormatBytesToHex(dwCertEncodingType,
                            dwFormatType,
                            dwFormatStrType,
                            NULL,
                            NULL,
                            pInfo->KeyId.pbData,
                            pInfo->KeyId.cbData,
                            NULL,
                            &cbNeeded))
                goto KeyIDBytesToHexError;

            pwszKeyID=(LPWSTR)malloc(cbNeeded);

            if(NULL==pwszKeyID)
                goto MemoryError;

            if(!FormatBytesToHex(dwCertEncodingType,
                            dwFormatType,
                            dwFormatStrType,
                            NULL,
                            NULL,
                            pInfo->KeyId.pbData,
                            pInfo->KeyId.cbData,
                            pwszKeyID,
                            &cbNeeded))
                goto KeyIDBytesToHexError;

            if(!FormatMessageUnicode(&pwszKeyIDFormat, IDS_AUTH_KEY_ID,pwszKeyID))
                goto FormatMsgError;

            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszKeyIDFormat)+1));
            if(NULL==pwsz)
                goto MemoryError;

            //strcat the KeyID
            wcscat(pwsz,pwszKeyIDFormat);

            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                wcscat(pwsz, wszNEWLN);
        }

        //format certIssuer
        if(0!=pInfo->CertIssuer.cbData)
        {
            //strcat ", " if there is data before
            if(0!=wcslen(pwsz))
            {
                if(0==(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                    wcscat(pwsz, wszCOMMA);
            }

            if(!CryptDllFormatNameAll(
				dwCertEncodingType,	
				dwFormatType,
				dwFormatStrType,
				pFormatStruct,
                IDS_ONE_TAB,
                TRUE,             //memory allocation
				pInfo->CertIssuer.pbData,
				pInfo->CertIssuer.cbData,
				(void **)&pwszCertIssuer,
				NULL))
                goto GetCertNameError;

            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                ids=IDS_AUTH_CERT_ISSUER_MULTI;
            else
                ids=IDS_AUTH_CERT_ISSUER;

            if(!FormatMessageUnicode(&pwszCertIssuerFormat, ids,pwszCertIssuer))
                goto FormatMsgError;

            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszCertIssuerFormat)+1));
            if(NULL==pwsz)
                goto MemoryError;

            wcscat(pwsz,pwszCertIssuerFormat);

            //no need for \n for CERT_NAME
        }

        //format CertSerialNumber
        if(0!=pInfo->CertSerialNumber.cbData)
        {

            //strcat ", " if there is data before
            if(0!=wcslen(pwsz))
            {
                if(0==(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                    wcscat(pwsz, wszCOMMA);
            }

            //copy the serial number into the correct order
            pByte=(BYTE *)malloc(pInfo->CertSerialNumber.cbData);
            if(NULL==pByte)
                goto MemoryError;

            for(dwByteIndex=0; dwByteIndex <pInfo->CertSerialNumber.cbData;
                dwByteIndex++)
            {

                pByte[dwByteIndex]=*(pInfo->CertSerialNumber.pbData+
                        pInfo->CertSerialNumber.cbData-1-dwByteIndex);
            }

            cbNeeded=0;

            if(!FormatBytesToHex(dwCertEncodingType,
                            dwFormatType,
                            dwFormatStrType,
                            NULL,
                            NULL,
                            pByte,
                            pInfo->CertSerialNumber.cbData,
                            NULL,
                            &cbNeeded))
                goto CertNumberBytesToHexError;

            pwszCertNumber=(LPWSTR)malloc(cbNeeded);

            if(NULL==pwszCertNumber)
                goto MemoryError;

            if(!FormatBytesToHex(dwCertEncodingType,
                            dwFormatType,
                            dwFormatStrType,
                            NULL,
                            NULL,
                            pByte,
                            pInfo->CertSerialNumber.cbData,
                            pwszCertNumber,
                            &cbNeeded))
             goto CertNumberBytesToHexError;


            if(!FormatMessageUnicode(&pwszCertNumberFormat, IDS_AUTH_CERT_NUMBER,pwszCertNumber))
                goto FormatMsgError;

            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszCertNumberFormat)+1));
            if(NULL==pwsz)
                goto MemoryError;

            wcscat(pwsz,pwszCertNumberFormat);

            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                wcscat(pwsz, wszNEWLN);

        }

        pwszFormat=pwsz;
    }


	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:
    if(pByte)
        free(pByte);

    if(pwszKeyID)
       free(pwszKeyID);

    if(pwszKeyIDFormat)
        LocalFree((HLOCAL)pwszKeyIDFormat);

    if(pwszCertIssuer)
       free(pwszCertIssuer);

    if(pwszCertIssuerFormat)
        LocalFree((HLOCAL)pwszCertIssuerFormat);

    if(pwszCertNumber)
       free(pwszCertNumber);


    if(pwszCertNumberFormat)
        LocalFree((HLOCAL)pwszCertNumberFormat);

    if(pwsz)
        free(pwsz);

	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(FormatMsgError);
TRACE_ERROR(KeyIDBytesToHexError);
TRACE_ERROR(GetCertNameError);
TRACE_ERROR(CertNumberBytesToHexError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
}

//--------------------------------------------------------------------------
//
//	 FormatAuthorityKeyID2: szOID_AUTHORITY_KEY_IDENTIFIER2
//                          X509_AUTHORITY_KEY_ID2
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatAuthorityKeyID2(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
    LPWSTR							pwszFormat=NULL;
    LPWSTR                          pwsz=NULL;

    LPWSTR                          pwszKeyID=NULL;
    LPWSTR                          pwszKeyIDFormat=NULL;
    LPWSTR                          pwszCertIssuer=NULL;
    LPWSTR                          pwszCertIssuerFormat=NULL;
    LPWSTR                          pwszCertNumber=NULL;
    LPWSTR                          pwszCertNumberFormat=NULL;
    BYTE                            *pByte=NULL;

    DWORD                           dwByteIndex=0;
    WCHAR                           wszNoInfo[NO_INFO_SIZE];
	PCERT_AUTHORITY_KEY_ID2_INFO	pInfo=NULL;
	DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;
    HRESULT                         hr=S_OK;
    UINT                            ids=0;

	
	//check for input parameters
	if((NULL==pbEncoded && cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,X509_AUTHORITY_KEY_ID2,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

    //load the string "Info Not Available"
    if((0==pInfo->KeyId.cbData)&&(0==pInfo->AuthorityCertIssuer.cAltEntry)
        &&(0==pInfo->AuthorityCertSerialNumber.cbData))
    {
	    if(!LoadStringU(hFrmtFuncInst,IDS_NO_INFO, wszNoInfo, sizeof(wszNoInfo)/sizeof(wszNoInfo[0])))
		    goto LoadStringError;

        pwszFormat=wszNoInfo;
    }
    else
    {
        pwsz=(LPWSTR)malloc(sizeof(WCHAR));
        if(NULL==pwsz)
            goto MemoryError;
        *pwsz=L'\0';

        //format the three fields in the struct: KeyID; CertIssuer; CertSerialNumber
        if(0!=pInfo->KeyId.cbData)
        {
            cbNeeded=0;

            if(!FormatBytesToHex(dwCertEncodingType,
                            dwFormatType,
                            dwFormatStrType,
                            NULL,
                            NULL,
                            pInfo->KeyId.pbData,
                            pInfo->KeyId.cbData,
                            NULL,
                            &cbNeeded))
                goto KeyIDBytesToHexError;

            pwszKeyID=(LPWSTR)malloc(cbNeeded);

            if(NULL==pwszKeyID)
                goto MemoryError;

            if(!FormatBytesToHex(dwCertEncodingType,
                            dwFormatType,
                            dwFormatStrType,
                            NULL,
                            NULL,
                            pInfo->KeyId.pbData,
                            pInfo->KeyId.cbData,
                            pwszKeyID,
                            &cbNeeded))
                goto KeyIDBytesToHexError;

            if(!FormatMessageUnicode(&pwszKeyIDFormat, IDS_AUTH_KEY_ID,pwszKeyID))
                goto FormatMsgError;

            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+
                                wcslen(pwszKeyIDFormat)+1));
            if(NULL==pwsz)
                goto MemoryError;

            wcscat(pwsz,pwszKeyIDFormat);

            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                wcscat(pwsz, wszNEWLN);

        }

        //format certIssuer
        if(0!=pInfo->AuthorityCertIssuer.cAltEntry)
        {
            //strcat ", " if there is data before
            if(0!=wcslen(pwsz))
            {
                if(0==(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                    wcscat(pwsz, wszCOMMA);
            }


            cbNeeded=0;

            //need a \t before each entry of the alternative name
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                ids=IDS_ONE_TAB;
            else
                ids=0;

            //format the alternative name
            if(!FormatAltNameInfo(dwCertEncodingType,
                            dwFormatType,
                            dwFormatStrType,
                            pFormatStruct,
                            ids,
                            FALSE,
                            &(pInfo->AuthorityCertIssuer),
                            NULL,
                            &cbNeeded))
                goto FormatAltNameError;

            pwszCertIssuer=(LPWSTR)malloc(cbNeeded);
            if(NULL==pwszCertIssuer)
                goto MemoryError;

            if(!FormatAltNameInfo(dwCertEncodingType,
                            dwFormatType,
                            dwFormatStrType,
                            pFormatStruct,
                            ids,
                            FALSE,
                            &(pInfo->AuthorityCertIssuer),
                            pwszCertIssuer,
                            &cbNeeded))
                goto FormatAltNameError;

            //format the element.  Has to distinguish between the multi line
            //and single line for alternative name:
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            {
                if(!FormatMessageUnicode(&pwszCertIssuerFormat, IDS_AUTH_CERT_ISSUER_MULTI,pwszCertIssuer))
                    goto FormatMsgError;
            }
            else
            {
                if(!FormatMessageUnicode(&pwszCertIssuerFormat, IDS_AUTH_CERT_ISSUER,pwszCertIssuer))
                    goto FormatMsgError;
            }


            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)
                        +wcslen(pwszCertIssuerFormat)+1));
            if(NULL==pwsz)
                goto MemoryError;

            wcscat(pwsz,pwszCertIssuerFormat);

            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                wcscat(pwsz, wszNEWLN);
        }

        //format CertSerialNumber
        if(0!=pInfo->AuthorityCertSerialNumber.cbData)
        {
            //strcat ", " if there is data before
            if(0!=wcslen(pwsz))
            {
                if(0==(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE))
                    wcscat(pwsz, wszCOMMA);
            }

            //copy the serial number into the correct order
            pByte=(BYTE *)malloc(pInfo->AuthorityCertSerialNumber.cbData);
            if(NULL==pByte)
                goto MemoryError;

            for(dwByteIndex=0; dwByteIndex <pInfo->AuthorityCertSerialNumber.cbData;
                dwByteIndex++)
            {

                pByte[dwByteIndex]=*(pInfo->AuthorityCertSerialNumber.pbData+
                        pInfo->AuthorityCertSerialNumber.cbData-1-dwByteIndex);
            }

            cbNeeded=0;

            if(!FormatBytesToHex(dwCertEncodingType,
                            dwFormatType,
                            dwFormatStrType,
                            NULL,
                            NULL,
                            pByte,
                            pInfo->AuthorityCertSerialNumber.cbData,
                            NULL,
                            &cbNeeded))
                goto CertNumberBytesToHexError;

            pwszCertNumber=(LPWSTR)malloc(cbNeeded);

            if(NULL==pwszCertNumber)
                goto MemoryError;

            if(!FormatBytesToHex(dwCertEncodingType,
                            dwFormatType,
                            dwFormatStrType,
                            NULL,
                            NULL,
                            pByte,
                            pInfo->AuthorityCertSerialNumber.cbData,
                            pwszCertNumber,
                            &cbNeeded))
             goto CertNumberBytesToHexError;


            if(!FormatMessageUnicode(&pwszCertNumberFormat, IDS_AUTH_CERT_NUMBER,pwszCertNumber))
                goto FormatMsgError;

            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)
                    +wcslen(pwszCertNumberFormat)+1));

            if(NULL==pwsz)
                goto MemoryError;

            wcscat(pwsz,pwszCertNumberFormat);

            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                wcscat(pwsz, wszNEWLN);
        }

        //convert the WCHAR version
        pwszFormat=pwsz;
    }


	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:
    if(pByte)
        free(pByte);

    if(pwszKeyID)
       free(pwszKeyID);

    if(pwszKeyIDFormat)
        LocalFree((HLOCAL)pwszKeyIDFormat);

    if(pwszCertIssuer)
       free(pwszCertIssuer);

    if(pwszCertIssuerFormat)
        LocalFree((HLOCAL)pwszCertIssuerFormat);

    if(pwszCertNumber)
       free(pwszCertNumber);


    if(pwszCertNumberFormat)
        LocalFree((HLOCAL)pwszCertNumberFormat);

    if(pwsz)
        free(pwsz);

	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(FormatMsgError);
TRACE_ERROR(KeyIDBytesToHexError);
TRACE_ERROR(FormatAltNameError);
TRACE_ERROR(CertNumberBytesToHexError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);

}

//--------------------------------------------------------------------------
//
//	 FormatBasicConstraints:   szOID_BASIC_CONSTRAINTS
//                             X509_BASIC_CONSTRAINTS
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatBasicConstraints(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	
	LPWSTR							pwszFormat=NULL;
	WCHAR							wszSubject[SUBJECT_SIZE * 2];
	WCHAR							wszNone[NONE_SIZE];
    LPWSTR                          pwszFormatSub=NULL;
    LPWSTR                          pwszFormatWhole=NULL;
    LPWSTR                          pwszSubtreeName=NULL;
    LPWSTR                          pwszSubtreeFormat=NULL;
    DWORD                           dwIndex=0;
	PCERT_BASIC_CONSTRAINTS_INFO	pInfo=NULL;
	DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;
	UINT							idsSub=0;
    HRESULT                         hr=S_OK;

	
	//check for input parameters
	if((NULL==pbEncoded&& cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,X509_BASIC_CONSTRAINTS,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;


	//load the string for the subjectType
    //init to "\0"
    *wszSubject=L'\0';

    if(0!=pInfo->SubjectType.cbData)
    {
        //get the subjectType info
        if ((pInfo->SubjectType.pbData[0]) & CERT_CA_SUBJECT_FLAG)
        {
       	    if(!LoadStringU(hFrmtFuncInst,IDS_SUB_CA, wszSubject, sizeof(wszSubject)/sizeof(wszSubject[0])))
		        goto LoadStringError;
        }

        if ((pInfo->SubjectType.pbData[0]) & CERT_END_ENTITY_SUBJECT_FLAG)
        {
            if(wcslen(wszSubject)!=0)
            {
                 wcscat(wszSubject, wszCOMMA);
            }

       	    if(!LoadStringU(hFrmtFuncInst,IDS_SUB_EE, wszSubject+wcslen(wszSubject),
                        SUBJECT_SIZE))
		          goto LoadStringError;
       }

        //load string "NONE"
        if(0==wcslen(wszSubject))
        {
            if(!LoadStringU(hFrmtFuncInst,IDS_NONE, wszSubject, sizeof(wszSubject)/sizeof(wszSubject[0])))
		    goto LoadStringError;
        }

    }

    //path contraints
    if (pInfo->fPathLenConstraint)
	{
        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            idsSub=IDS_BASIC_CONS2_PATH_MULTI;
        else
            idsSub=IDS_BASIC_CONS2_PATH;

        if(!FormatMessageUnicode(&pwszFormatSub,idsSub,
								wszSubject, pInfo->dwPathLenConstraint))
			goto FormatMsgError;
	}
    else
	{
		if(!LoadStringU(hFrmtFuncInst,IDS_NONE, wszNone, sizeof(wszNone)/sizeof(wszNone[0])))
			goto LoadStringError;

        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            idsSub=IDS_BASIC_CONS2_NONE_MULTI;
        else
            idsSub=IDS_BASIC_CONS2_NONE;

        if(!FormatMessageUnicode(&pwszFormatSub,idsSub,
								wszSubject, wszNone))
			goto FormatMsgError;
	}

    pwszFormatWhole=(LPWSTR)malloc(sizeof(WCHAR) * (wcslen(pwszFormatSub)+1));
    if(!pwszFormatWhole)
        goto MemoryError;

    wcscpy(pwszFormatWhole, pwszFormatSub);

    //now, format SubTreeContraints one at a time

   for(dwIndex=0; dwIndex<pInfo->cSubtreesConstraint; dwIndex++)
    {
        //get WCHAR version of the name
        if(!CryptDllFormatNameAll(
				dwCertEncodingType,	
				dwFormatType,
				dwFormatStrType,
				pFormatStruct,
                IDS_ONE_TAB,
                TRUE,                 //memory allocation
				pInfo->rgSubtreesConstraint[dwIndex].pbData,
				pInfo->rgSubtreesConstraint[dwIndex].cbData,
				(void **)&pwszSubtreeName,
				NULL))
                goto GetCertNameError;

        //decide between single line and mulitple line format
        if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            idsSub=IDS_SUBTREE_CONSTRAINT_MULTI;
        else
            idsSub=IDS_SUBTREE_CONSTRAINT;

        if(!FormatMessageUnicode(&pwszSubtreeFormat,idsSub,
								dwIndex+1, pwszSubtreeName))
			goto FormatNameError;

        pwszFormatWhole=(LPWSTR)realloc(pwszFormatWhole, 
            sizeof(WCHAR) * (wcslen(pwszFormatWhole)+1+wcslen(pwszSubtreeFormat)));

        if(NULL == pwszFormatWhole)
            goto MemoryError;

        wcscat(pwszFormatWhole,pwszSubtreeFormat);

        LocalFree((HLOCAL)pwszSubtreeFormat);
        pwszSubtreeFormat=NULL;

        free(pwszSubtreeName);
        pwszSubtreeName=NULL;

    }

    //format to the wide char version
    pwszFormat=pwszFormatWhole;

	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:

    if(pwszFormatSub)
        LocalFree((HLOCAL)pwszFormatSub);

    if(pwszSubtreeFormat)
        LocalFree((HLOCAL)pwszSubtreeFormat);

    if(pwszFormatWhole)
        free(pwszFormatWhole);

    if(pwszSubtreeName)
        free(pwszSubtreeName);

	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(FormatMsgError);
TRACE_ERROR(FormatNameError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(GetCertNameError);
}


//--------------------------------------------------------------------------
//
//	 FormatCRLReasonCode:szOID_CRL_REASON_CODE
//                         X509_CRL_REASON_CODE
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatCRLReasonCode(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	
	WCHAR							wszReason[CRL_REASON_SIZE];
    LPWSTR                          pwszFormat=NULL;
	int								*pInfo=NULL;
	DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;
	UINT							idsCRLReason=0;

	
	//check for input parameters
	if((NULL==pbEncoded&& cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,X509_CRL_REASON_CODE,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

	//decide which ids to use
	switch(*pInfo)
	{
		case CRL_REASON_UNSPECIFIED:
				idsCRLReason=IDS_UNSPECIFIED;
			break;
		case CRL_REASON_KEY_COMPROMISE:
				idsCRLReason=IDS_KEY_COMPROMISE;
			break;
		case CRL_REASON_CA_COMPROMISE:
				idsCRLReason=IDS_CA_COMPROMISE;
			break;
		case CRL_REASON_AFFILIATION_CHANGED:
				idsCRLReason=IDS_AFFILIATION_CHANGED;
			break;
		case CRL_REASON_SUPERSEDED:
				idsCRLReason=IDS_SUPERSEDED;
			break;
		case CRL_REASON_CESSATION_OF_OPERATION:
				idsCRLReason=IDS_CESSATION_OF_OPERATION;
			break;
		case CRL_REASON_CERTIFICATE_HOLD:
				idsCRLReason=IDS_CERTIFICATE_HOLD;
			break;
		case CRL_REASON_REMOVE_FROM_CRL:
				idsCRLReason=IDS_REMOVE_FROM_CRL;
			break;
		default:
				idsCRLReason=IDS_UNKNOWN_CRL_REASON;
			break;
	}

	//load string
	if(!LoadStringU(hFrmtFuncInst,idsCRLReason, wszReason, sizeof(wszReason)/sizeof(wszReason[0])))
		goto LoadStringError;

    //format
    if(!FormatMessageUnicode(&pwszFormat, IDS_CRL_REASON, wszReason, *pInfo))
        goto FormatMsgError;

	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:
    if(pwszFormat)
        LocalFree((HLOCAL)pwszFormat);

	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(FormatMsgError);

}

//--------------------------------------------------------------------------
//
//	 FormatEnhancedKeyUsage: szOID_ENHANCED_KEY_USAGE
//							 X509_ENHANCED_KEY_USAGE
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatEnhancedKeyUsage(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	
    BOOL                            fOIDNameAllocated=FALSE;
	WCHAR							wszNoInfo[NO_INFO_SIZE];
    WCHAR                           wszUnknownOID[UNKNOWN_KEY_USAGE_SIZE];
	PCCRYPT_OID_INFO                pOIDInfo=NULL;

    LPWSTR							pwszFormat=NULL;
    LPWSTR                          pwszOIDName=NULL;
	PCERT_ENHKEY_USAGE				pInfo=NULL;
	LPWSTR							pwsz=NULL;
    LPWSTR                          pwszOIDFormat=NULL;

	DWORD							dwIndex=0;
    DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;
    HRESULT                         hr=S_OK;

	
	//check for input parameters
	if((NULL==pbEncoded&& cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,X509_ENHANCED_KEY_USAGE,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

	//load string NONE if there is no value available
	if(0==pInfo->cUsageIdentifier)
	{
		if(!LoadStringU(hFrmtFuncInst,IDS_NO_INFO, wszNoInfo, sizeof(wszNoInfo)/sizeof(wszNoInfo[0])))
			goto LoadStringError;

	    pwszFormat=wszNoInfo;
	}
	else
	{
        //load the string for "unknown key usage"
        if(!LoadStringU(hFrmtFuncInst,IDS_UNKNOWN_KEY_USAGE, wszUnknownOID,
            sizeof(wszUnknownOID)/sizeof(wszUnknownOID[0])))
			goto LoadStringError;

        pwsz=(LPWSTR)malloc(sizeof(WCHAR));
        if(NULL==pwsz)
            goto MemoryError;
        *pwsz=L'\0';

		//build the comma/\n seperated string
		for(dwIndex=0; dwIndex<pInfo->cUsageIdentifier; dwIndex++)
        {
            fOIDNameAllocated=FALSE;

           	pOIDInfo=CryptFindOIDInfo(CRYPT_OID_INFO_OID_KEY,
									 (void *)(pInfo->rgpszUsageIdentifier[dwIndex]),
									  CRYPT_ENHKEY_USAGE_OID_GROUP_ID);

            if(pOIDInfo)
			{
				//allocate memory, including the NULL terminator
				pwszOIDName=(LPWSTR)malloc((wcslen(pOIDInfo->pwszName)+1)*
									sizeof(WCHAR));

				if(NULL==pwszOIDName)
					goto MemoryError;

                fOIDNameAllocated=TRUE;

				wcscpy(pwszOIDName,pOIDInfo->pwszName);

			}else
                pwszOIDName=wszUnknownOID;

            if(!FormatMessageUnicode(&pwszOIDFormat, IDS_ENHANCED_KEY_USAGE, pwszOIDName,
                          (pInfo->rgpszUsageIdentifier)[dwIndex]))
                   goto FormatMsgError;

            pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+
                            wcslen(wszCOMMA)+wcslen(pwszOIDFormat)+1));
            if(NULL==pwsz)
                goto MemoryError;

            //strcat the OID
            wcscat(pwsz, pwszOIDFormat);

            //strcat the , or '\n'
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                wcscat(pwsz, wszNEWLN);
            else
            {
                if(dwIndex!=(pInfo->cUsageIdentifier-1))
                    wcscat(pwsz, wszCOMMA);
            }


            LocalFree((HLOCAL)pwszOIDFormat);
            pwszOIDFormat=NULL;

            if(fOIDNameAllocated)
                free(pwszOIDName);

            pwszOIDName=NULL;
        }

        pwszFormat=pwsz;

	}

	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:

	if(pwsz)
		free(pwsz);

    if(pwszOIDFormat)
        LocalFree((HLOCAL)pwszOIDFormat);

    if(fOIDNameAllocated)
    {
        if(pwszOIDName)
            free(pwszOIDName);
    }


	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(FormatMsgError);
}

//--------------------------------------------------------------------------
//
//	 FormatAltNameInfo:
//
//--------------------------------------------------------------------------
BOOL FormatAltNameInfo(
    DWORD		            dwCertEncodingType,
	DWORD		            dwFormatType,
    DWORD                   dwFormatStrType,
    void	            	*pFormatStruct,
    UINT                    idsPreFix,
    BOOL                    fNewLine,
    PCERT_ALT_NAME_INFO	    pInfo,
    void	                *pbFormat,
	DWORD	                *pcbFormat)
{
	
	LPWSTR							pwszFormat=NULL;
    LPWSTR                          pwsz=NULL;

    LPWSTR                          pwszAltEntryFormat=NULL;
    LPWSTR                          pwszAltEntry=NULL;

	WCHAR							wszNoInfo[NO_INFO_SIZE];
    WCHAR                           wszAltName[ALT_NAME_SIZE];
    WCHAR                           wszPreFix[PRE_FIX_SIZE];
    BOOL                            fEntryAllocated=FALSE;
    DWORD                           dwIndex=0;
	DWORD							cbNeeded=0;
	BOOL							fResult=FALSE;
    HRESULT                         hr=S_OK;
    UINT                            idsAltEntryName=0;

	
    //load the string "info not available"
    if(!LoadStringU(hFrmtFuncInst,IDS_NO_ALT_NAME, wszNoInfo, sizeof(wszNoInfo)/sizeof(wszNoInfo[0])))
		goto LoadStringError;

	//build the list of alternative name entries
    //1st, check if any information is available
    if(0==pInfo->cAltEntry)
    {
	    pwszFormat=wszNoInfo;
    }
    else
    {
        //load the pre-dix
        if(0!=idsPreFix)
        {
            if(!LoadStringU(hFrmtFuncInst, idsPreFix,
                        wszPreFix, sizeof(wszPreFix)/sizeof(wszPreFix[0])))
                goto LoadStringError;

        }

        pwsz=(LPWSTR)malloc(sizeof(WCHAR));
        if(NULL==pwsz)
            goto MemoryError;

        //NULL terminate the string
        *pwsz=L'\0';

        //build the list of alternative name entries
        for(dwIndex=0; dwIndex<pInfo->cAltEntry; dwIndex++)
        {
            fEntryAllocated=FALSE;

             switch((pInfo->rgAltEntry)[dwIndex].dwAltNameChoice)
             {
                case CERT_ALT_NAME_OTHER_NAME:
                        idsAltEntryName=IDS_OTHER_NAME;
                        pwszAltEntry=wszNoInfo;
                    break;

                case CERT_ALT_NAME_RFC822_NAME:
                         idsAltEntryName=IDS_RFC822_NAME;
                         pwszAltEntry=(pInfo->rgAltEntry)[dwIndex].pwszRfc822Name;
                    break;
                case CERT_ALT_NAME_DNS_NAME:
                         idsAltEntryName=IDS_DNS_NAME;
                         pwszAltEntry=(pInfo->rgAltEntry)[dwIndex].pwszDNSName;
                   break;

                case CERT_ALT_NAME_X400_ADDRESS:
                         idsAltEntryName=IDS_X400_ADDRESS;
                         pwszAltEntry=wszNoInfo;
                   break;

                case CERT_ALT_NAME_DIRECTORY_NAME:

                         if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
                            idsAltEntryName=IDS_DIRECTORY_NAME_MULTI;
                         else
                            idsAltEntryName=IDS_DIRECTORY_NAME;

                        if(!CryptDllFormatNameAll(
				            dwCertEncodingType,	
				            dwFormatType,
				            dwFormatStrType,
				            pFormatStruct,
                            (0!=idsPreFix) ? idsPreFix+1 : IDS_ONE_TAB,
                            TRUE,           //memory allocation
				            (pInfo->rgAltEntry)[dwIndex].DirectoryName.pbData,
				            (pInfo->rgAltEntry)[dwIndex].DirectoryName.cbData,
				            (void **)&pwszAltEntry,
				            NULL))
                            goto GetCertNameError;

                         fEntryAllocated=TRUE;

                    break;

                case CERT_ALT_NAME_EDI_PARTY_NAME:
                        idsAltEntryName=IDS_EDI_PARTY_NAME;
                        pwszAltEntry=wszNoInfo;
                    break;

                case CERT_ALT_NAME_URL:
                         idsAltEntryName=IDS_URL;
                         pwszAltEntry=(pInfo->rgAltEntry)[dwIndex].pwszURL;
                   break;

                case CERT_ALT_NAME_IP_ADDRESS:
                        idsAltEntryName=IDS_IP_ADDRESS;

                        if(!FormatBytesToHex(dwCertEncodingType,
                                            dwFormatType,
                                            dwFormatStrType,
                                            pFormatStruct,
                                            NULL,
                                            (pInfo->rgAltEntry)[dwIndex].IPAddress.pbData,
                                            (pInfo->rgAltEntry)[dwIndex].IPAddress.cbData,
                                            NULL,
                                            &cbNeeded))
                            goto FormatByesToHexError;

                        pwszAltEntry=(LPWSTR)malloc(cbNeeded);

                        if(NULL==pwszAltEntry)
                            goto MemoryError;

                        if(!FormatBytesToHex(dwCertEncodingType,
                                            dwFormatType,
                                            dwFormatStrType,
                                            pFormatStruct,
                                            NULL,
                                            (pInfo->rgAltEntry)[dwIndex].IPAddress.pbData,
                                            (pInfo->rgAltEntry)[dwIndex].IPAddress.cbData,
                                            pwszAltEntry,
                                            &cbNeeded))
                            goto FormatByesToHexError;

                        fEntryAllocated=TRUE;


                    break;

                case CERT_ALT_NAME_REGISTERED_ID:

                        idsAltEntryName=IDS_REGISTERED_ID;

                        if(S_OK!=(hr=SZtoWSZ((pInfo->rgAltEntry)[dwIndex].pszRegisteredID,
                                            &pwszAltEntry)))
                            goto SZtoWSZError;

                        fEntryAllocated=TRUE;
                    break;

                default:
                        idsAltEntryName=IDS_UNKNOWN_VALUE;
                        pwszAltEntry=wszNoInfo;
                    break;

             }

             //load the alternative name string
            if(!LoadStringU(hFrmtFuncInst,idsAltEntryName, wszAltName, sizeof(wszAltName)/sizeof(wszAltName[0])))
		            goto LoadStringError;

            //format message
            if(idsAltEntryName!=IDS_UNKNOWN_VALUE)
            {
                if(!FormatMessageUnicode(&pwszAltEntryFormat,IDS_ALT_NAME_ENTRY, wszAltName,
                    pwszAltEntry))
                    goto FormatMsgError;
            }
            else
            {
                if(!FormatMessageUnicode(&pwszAltEntryFormat,IDS_ALT_NAME_ENTRY_UNKNOWN, wszAltName,
                    (pInfo->rgAltEntry)[dwIndex].dwAltNameChoice))
                    goto FormatMsgError;
            }

            //concatenate the string, including the postfix and prefix if necessary
            if(0!=idsPreFix)
                pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(wszPreFix)+wcslen(pwszAltEntryFormat)+1));
            else
                pwsz=(LPWSTR)realloc(pwsz, 
                sizeof(WCHAR) * (wcslen(pwsz)+wcslen(wszCOMMA)+wcslen(pwszAltEntryFormat)+1));

            if(NULL==pwsz)
                goto MemoryError;

            //strcat the preFix
            if(0!=idsPreFix)
                wcscat(pwsz, wszPreFix);

            //strcat the entry
            wcscat(pwsz, pwszAltEntryFormat);

            //strcat the postFix
            if(dwFormatStrType & CRYPT_FORMAT_STR_MULTI_LINE)
            {
                if((TRUE==fNewLine) || (dwIndex != (pInfo->cAltEntry-1)))
                {
                    //no need for \n if the name is directory name (CERT_NAME)
                    //in multi line format
                    if(idsAltEntryName !=IDS_DIRECTORY_NAME_MULTI)
                        wcscat(pwsz, wszNEWLN);
                }

            }
            else
            {
                if(dwIndex != (pInfo->cAltEntry-1))
                    wcscat(pwsz, wszCOMMA);
            }

            LocalFree((HLOCAL)pwszAltEntryFormat);
            pwszAltEntryFormat=NULL;

            if(fEntryAllocated)
                free(pwszAltEntry);
            pwszAltEntry=NULL;
        }

        //if the last entry in the alternative name is  IDS_DIRECTORY_NAME_MULTI,
        //we need to get rid of the last \n if fNewLine is FALSE
        if(FALSE==fNewLine)
        {

            if(idsAltEntryName==IDS_DIRECTORY_NAME_MULTI)
            {
                *(pwsz+wcslen(pwsz)-wcslen(wszNEWLN))=L'\0';
            }
        }

        //conver to the WCHAR format

        pwszFormat=pwsz;
    }


	cbNeeded=sizeof(WCHAR)*(wcslen(pwszFormat)+1);

	//length only calculation
	if(NULL==pbFormat)
	{
		*pcbFormat=cbNeeded;
		fResult=TRUE;
		goto CommonReturn;
	}


	if((*pcbFormat)<cbNeeded)
    {
        *pcbFormat=cbNeeded;
		goto MoreDataError;
    }

	//copy the data
	memcpy(pbFormat, pwszFormat, cbNeeded);

	//copy the size
	*pcbFormat=cbNeeded;

	fResult=TRUE;
	

CommonReturn:

    if(pwsz)
        free(pwsz);

    if(pwszAltEntryFormat)
        LocalFree((HLOCAL)pwszAltEntryFormat);

    if(fEntryAllocated)
    {
        if(pwszAltEntry)
            free(pwszAltEntry);
    }


	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

TRACE_ERROR(LoadStringError);
SET_ERROR(MoreDataError,ERROR_MORE_DATA);
TRACE_ERROR(FormatMsgError);
SET_ERROR_VAR(SZtoWSZError, hr);
TRACE_ERROR(GetCertNameError);
TRACE_ERROR(FormatByesToHexError);
SET_ERROR(MemoryError, E_OUTOFMEMORY);

}

//--------------------------------------------------------------------------
//
//	 FormatAltName:  X509_ALTERNATE_NAME
//                   szOID_SUBJECT_ALT_NAME
//                   szOID_ISSUER_ALT_NAME
//                   szOID_SUBJECT_ALT_NAME2
//                   szOID_ISSUER_ALT_NAME2
//
//--------------------------------------------------------------------------
static BOOL
WINAPI
FormatAltName(
	DWORD		dwCertEncodingType,
	DWORD		dwFormatType,
	DWORD		dwFormatStrType,
	void		*pFormatStruct,
	LPCSTR		lpszStructType,
	const BYTE *pbEncoded,
	DWORD		cbEncoded,
	void	   *pbFormat,
	DWORD	   *pcbFormat)
{
	
	BOOL							fResult=FALSE;
	PCERT_ALT_NAME_INFO	            pInfo=NULL;
	
	//check for input parameters
	if((NULL==pbEncoded&& cbEncoded!=0) ||
			(NULL==pcbFormat))
		goto InvalidArg;

	if(cbEncoded==0)
	{
		*pcbFormat=0;
		goto InvalidArg;
	}

    if (!DecodeGenericBLOB(dwCertEncodingType,X509_ALTERNATE_NAME,
			pbEncoded,cbEncoded, (void **)&pInfo))
		goto DecodeGenericError;

    fResult=FormatAltNameInfo(dwCertEncodingType, dwFormatType,dwFormatStrType,
                            pFormatStruct,
                            0,
                            TRUE,
                            pInfo, pbFormat, pcbFormat);

    if(FALSE==fResult)
        goto FormatAltNameError;

CommonReturn:

	if(pInfo)
		free(pInfo);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG);
TRACE_ERROR(DecodeGenericError);
TRACE_ERROR(FormatAltNameError);

}

//--------------------------------------------------------------------------
//
//	  GetCertNameMulti
//
//    Get the multi line display of the certificate name
//--------------------------------------------------------------------------
BOOL    GetCertNameMulti(LPWSTR          pwszNameStr,
                         UINT            idsPreFix,
                         LPWSTR          *ppwsz)
{

    BOOL            fResult=FALSE;
    WCHAR           wszPreFix[PRE_FIX_SIZE];
    LPWSTR          pwszStart=NULL;
    LPWSTR          pwszEnd=NULL;
    DWORD           dwCopy=0;
    LPWSTR          pwszNameStart=NULL;
    BOOL            fDone=FALSE;
    BOOL            fInQuote=FALSE;


    //init
    *ppwsz=NULL;

    //load string for the preFix
    if(0!=idsPreFix && 1!=idsPreFix)
    {
        if(!LoadStringU(hFrmtFuncInst, idsPreFix, wszPreFix, PRE_FIX_SIZE))
            goto LoadStringError;
    }

   *ppwsz=(LPWSTR)malloc(sizeof(WCHAR));
   if(NULL==*ppwsz)
        goto MemoryError;
   **ppwsz=L'\0';

   //now, start the search for the symbol '+' or ','
   pwszStart=pwszNameStr;
   pwszEnd=pwszNameStr;

   //parse the whole string
   for(;FALSE==fDone; pwszEnd++)
   {
       //mark fInQuote to TRUE if we are inside " "
       if(L'\"'==*pwszEnd)
           fInQuote=!fInQuote;

       if((L'+'==*pwszEnd) || (L','==*pwszEnd) ||(L'\0'==*pwszEnd))
       {
           //make sure + and ; are not quoted
           if((L'+'==*pwszEnd) || (L','==*pwszEnd))
           {
                if(TRUE==fInQuote)
                    continue;

           }

           //skip the leading spaces
           for(;*pwszStart != L'\0'; pwszStart++)
           {
                if(*pwszStart != L' ')
                    break;
           }

           //we are done if NULL is reached
           if(L'\0'==*pwszStart)
               break;

           //calculate the length to copy
           dwCopy=(DWORD)(pwszEnd-pwszStart);

           if(0!=idsPreFix && 1!=idsPreFix)
                *ppwsz=(LPWSTR)realloc(*ppwsz,
                    (wcslen(*ppwsz)+dwCopy+wcslen(wszPreFix)+wcslen(wszNEWLN)+1)*sizeof(WCHAR));
           else
                *ppwsz=(LPWSTR)realloc(*ppwsz,
                    (wcslen(*ppwsz)+dwCopy+wcslen(wszNEWLN)+1)*sizeof(WCHAR));

           if(NULL == *ppwsz)
               goto MemoryError;

           //copy the prefix
           if(0!=idsPreFix && 1!=idsPreFix)
                wcscat(*ppwsz, wszPreFix);

           pwszNameStart=(*ppwsz)+wcslen(*ppwsz);

           //copy the string to *ppwsz
           memcpy(pwszNameStart, pwszStart, dwCopy*sizeof(WCHAR));
           pwszNameStart += dwCopy;

           //NULL terminate the string
           *pwszNameStart=L'\0';

           //copy the "\n"
           wcscat(*ppwsz, wszNEWLN);

           //reset pwszStart and pwszEnd.
           pwszStart=pwszEnd+1;

           if(L'\0'==*pwszEnd)
               fDone=TRUE;
       }

   }


    fResult=TRUE;

CommonReturn:

     return fResult;

ErrorReturn:

     if(*ppwsz)
     {
         free(*ppwsz);
         *ppwsz=NULL;
     }

     fResult=FALSE;

     goto CommonReturn;

SET_ERROR(MemoryError, E_OUTOFMEMORY);
TRACE_ERROR(LoadStringError);
}

//--------------------------------------------------------------------------
//
//	  FormatMessageUnicode
//
//--------------------------------------------------------------------------
BOOL	FormatMessageUnicode(LPWSTR	*ppwszFormat,UINT ids,...)
{
    // get format string from resources
    WCHAR		wszFormat[1000];
	va_list		argList;
	DWORD		cbMsg=0;
	BOOL		fResult=FALSE;
	HRESULT		hr=S_OK;

    if(NULL == ppwszFormat)
        goto InvalidArgErr;

    if(!LoadStringU(hFrmtFuncInst, ids, wszFormat, sizeof(wszFormat)))
		goto LoadStringError;

    // format message into requested buffer
    va_start(argList, ids);

    cbMsg = FormatMessageU(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
        wszFormat,
        0,                  // dwMessageId
        0,                  // dwLanguageId
        (LPWSTR) (ppwszFormat),
        0,                  // minimum size to allocate
        &argList);

    va_end(argList);

	if(!cbMsg)
		goto FormatMessageError;

	fResult=TRUE;

CommonReturn:
	
	return fResult;

ErrorReturn:
	fResult=FALSE;

	goto CommonReturn;


TRACE_ERROR(LoadStringError);
TRACE_ERROR(FormatMessageError);
SET_ERROR(InvalidArgErr, E_INVALIDARG);
}

//--------------------------------------------------------------------------
//
//	  FormatMessageStr
//
//--------------------------------------------------------------------------
/*BOOL	FormatMessageStr(LPSTR	*ppszFormat,UINT ids,...)
{
    // get format string from resources
    CHAR		szFormat[1000];
	va_list		argList;
	BOOL		fResult=FALSE;
	HRESULT		hr=S_OK;

    if(!LoadStringA(hFrmtFuncInst, ids, szFormat, sizeof(szFormat)))
		goto LoadStringError;

    // format message into requested buffer
    va_start(argList, ids);

    if(0==FormatMessageA(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
        szFormat,
        0,                  // dwMessageId
        0,                  // dwLanguageId
        (LPSTR) ppszFormat,
        0,                  // minimum size to allocate
        &argList))
        goto FormatMessageError;

    va_end(argList);

	fResult=TRUE;

CommonReturn:
	
	return fResult;

ErrorReturn:
	fResult=FALSE;

	goto CommonReturn;


TRACE_ERROR(LoadStringError);
TRACE_ERROR(FormatMessageError);

} */

//--------------------------------------------------------------------------
//
//	  Decode a generic BLOB
//
//--------------------------------------------------------------------------
BOOL	DecodeGenericBLOB(DWORD dwEncodingType, LPCSTR lpszStructType,
			const BYTE *pbEncoded, DWORD cbEncoded,void **ppStructInfo)
{
	DWORD	cbStructInfo=0;

	//decode the object.  No copying
	if(!CryptDecodeObject(dwEncodingType,lpszStructType,pbEncoded, cbEncoded,
		0,NULL,	&cbStructInfo))
		return FALSE;

	*ppStructInfo=malloc(cbStructInfo);

	if(!(*ppStructInfo))
	{
		SetLastError(E_OUTOFMEMORY);
		return FALSE;
	}

	return CryptDecodeObject(dwEncodingType,lpszStructType,pbEncoded, cbEncoded,
		0,*ppStructInfo,&cbStructInfo);
}

////////////////////////////////////////////////////////
//
// Convert STR to WSTR
//
HRESULT	SZtoWSZ(LPSTR szStr,LPWSTR *pwsz)
{
	DWORD	dwSize=0;
	DWORD	dwError=0;

	*pwsz=NULL;

	//return NULL
	if(!szStr)
		return S_OK;

	dwSize=MultiByteToWideChar(0, 0,szStr, -1,NULL,0);

	if(dwSize==0)
	{
		dwError=GetLastError();
		return HRESULT_FROM_WIN32(dwError);
	}

	//allocate memory
	*pwsz=(LPWSTR)malloc(dwSize * sizeof(WCHAR));

	if(*pwsz==NULL)
		return E_OUTOFMEMORY;

	if(MultiByteToWideChar(0, 0,szStr, -1,
		*pwsz,dwSize))
	{
		return S_OK;
	}
	else
	{
		 free(*pwsz);
         *pwsz=NULL;
		 dwError=GetLastError();
		 return HRESULT_FROM_WIN32(dwError);
	}
}

//--------------------------------------------------------------------------
//
//	  Convert dwFormatType to dwStrType
//
//--------------------------------------------------------------------------
DWORD   FormatToStr(DWORD   dwFormatType)
{
    DWORD   dwStrType=0;

    //we default to CERT_X500_NAME_STR
    if(0==dwFormatType)
    {
        return CERT_X500_NAME_STR;
    }

    if(dwFormatType &  CRYPT_FORMAT_SIMPLE)
		dwStrType |= CERT_SIMPLE_NAME_STR;

	if(dwFormatType & CRYPT_FORMAT_X509)
		dwStrType |= CERT_X500_NAME_STR;

	if(dwFormatType & CRYPT_FORMAT_OID)
		dwStrType |= CERT_OID_NAME_STR;

	if(dwFormatType & CRYPT_FORMAT_RDN_SEMICOLON)
		dwStrType |= CERT_NAME_STR_SEMICOLON_FLAG;

	if(dwFormatType & CRYPT_FORMAT_RDN_CRLF)
		dwStrType |= CERT_NAME_STR_CRLF_FLAG;

	if(dwFormatType & CRYPT_FORMAT_RDN_UNQUOTE)
		dwStrType |= CERT_NAME_STR_NO_QUOTING_FLAG;

	if(dwFormatType & CRYPT_FORMAT_RDN_REVERSE)
		dwStrType |= CERT_NAME_STR_REVERSE_FLAG;

    return dwStrType;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\certstor\logstor.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1997
//
//  File:       logstor.cpp
//
//  Contents:   Registry Certificate Store Provider APIs
//
//  Functions:  I_RegStoreDllMain
//              I_CertDllOpenRegStoreProv
//              CertRegisterSystemStore
//              CertRegisterPhysicalStore
//              CertUnregisterSystemStore
//              CertUnregisterPhysicalStore
//              CertEnumSystemStoreLocation
//              CertEnumSystemStore
//              CertEnumPhysicalStore
//              I_CertDllOpenSystemRegistryStoreProvW
//              I_CertDllOpenSystemRegistryStoreProvA
//              I_CertDllOpenSystemStoreProvW
//              I_CertDllOpenSystemStoreProvA
//              I_CertDllOpenPhysicalStoreProvW
//
//  History:    28-Dec-96    philh   created
//              13-Aug-96    philh   added change notify and resync support
//              24-Aug-96    philh   added logical store support
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>
#include "xwinreg.h"
#include "xdbg.h"

#ifdef STATIC
#undef STATIC
#endif
#define STATIC


// Pointer to an allocated LONG containing thread's enum recursion depth
static HCRYPTTLS hTlsEnumPhysicalStoreDepth;
#define MAX_ENUM_PHYSICAL_STORE_DEPTH       20

#define SYSTEM_STORE_REGPATH        L"Software\\Microsoft\\SystemCertificates"
#define PHYSICAL_STORES_SUBKEY_NAME L"PhysicalStores"
#define CONST_OID_STR_PREFIX_CHAR   '#'
#define SERVICES_REGPATH            L"Software\\Microsoft\\Cryptography\\Services"
#define SYSTEM_CERTIFICATES_SUBKEY_NAME L"SystemCertificates"
#define GROUP_POLICY_STORE_REGPATH  L"Software\\Policies\\Microsoft\\SystemCertificates"
#define ENTERPRISE_STORE_REGPATH    L"Software\\Microsoft\\EnterpriseCertificates"

#define ROAMING_MY_STORE_SUBDIR     L"Microsoft\\SystemCertificates\\My"

#define REGISTER_FLAGS_MASK         (CERT_SYSTEM_STORE_MASK | \
                                        CERT_STORE_CREATE_NEW_FLAG)
#define UNREGISTER_FLAGS_MASK       (CERT_SYSTEM_STORE_MASK | \
                                        CERT_STORE_DELETE_FLAG | \
                                        CERT_STORE_OPEN_EXISTING_FLAG)
#define ENUM_FLAGS_MASK             (CERT_SYSTEM_STORE_MASK | \
                                        CERT_STORE_OPEN_EXISTING_FLAG | \
                                        CERT_STORE_MAXIMUM_ALLOWED_FLAG | \
                                        CERT_STORE_READONLY_FLAG)

#define OPEN_REG_FLAGS_MASK         (CERT_STORE_CREATE_NEW_FLAG | \
                                        CERT_STORE_DELETE_FLAG | \
                                        CERT_STORE_OPEN_EXISTING_FLAG | \
                                        CERT_STORE_MAXIMUM_ALLOWED_FLAG | \
                                        CERT_STORE_READONLY_FLAG | \
                                        CERT_STORE_MANIFOLD_FLAG | \
                                        CERT_STORE_UPDATE_KEYID_FLAG | \
                                        CERT_STORE_ENUM_ARCHIVED_FLAG | \
                                        CERT_STORE_SET_LOCALIZED_NAME_FLAG | \
                                        CERT_STORE_NO_CRYPT_RELEASE_FLAG | \
                                        CERT_REGISTRY_STORE_REMOTE_FLAG | \
                                        CERT_REGISTRY_STORE_SERIALIZED_FLAG | \
                                        CERT_REGISTRY_STORE_ROAMING_FLAG | \
                                        CERT_REGISTRY_STORE_CLIENT_GPT_FLAG | \
                                        CERT_REGISTRY_STORE_MY_IE_DIRTY_FLAG | \
                                        CERT_REGISTRY_STORE_LM_GPT_FLAG)
#define OPEN_SYS_FLAGS_MASK         (CERT_SYSTEM_STORE_MASK | \
                                        CERT_STORE_CREATE_NEW_FLAG | \
                                        CERT_STORE_DELETE_FLAG | \
                                        CERT_STORE_OPEN_EXISTING_FLAG | \
                                        CERT_STORE_MAXIMUM_ALLOWED_FLAG | \
                                        CERT_STORE_READONLY_FLAG | \
                                        CERT_STORE_MANIFOLD_FLAG | \
                                        CERT_STORE_UPDATE_KEYID_FLAG | \
                                        CERT_STORE_ENUM_ARCHIVED_FLAG | \
                                        CERT_STORE_SET_LOCALIZED_NAME_FLAG | \
                                        CERT_STORE_NO_CRYPT_RELEASE_FLAG)
#define OPEN_PHY_FLAGS_MASK         (CERT_SYSTEM_STORE_MASK | \
                                        CERT_STORE_DELETE_FLAG | \
                                        CERT_STORE_OPEN_EXISTING_FLAG | \
                                        CERT_STORE_MAXIMUM_ALLOWED_FLAG | \
                                        CERT_STORE_READONLY_FLAG | \
                                        CERT_STORE_MANIFOLD_FLAG | \
                                        CERT_STORE_UPDATE_KEYID_FLAG | \
                                        CERT_STORE_ENUM_ARCHIVED_FLAG | \
                                        CERT_STORE_SET_LOCALIZED_NAME_FLAG | \
                                        CERT_STORE_NO_CRYPT_RELEASE_FLAG)
//+-------------------------------------------------------------------------
//  Common, global logical store critical section. Used by:
//      GptStore, Win95Store, RoamingStore.
//--------------------------------------------------------------------------
static CRITICAL_SECTION ILS_CriticalSection;


//+-------------------------------------------------------------------------
//  Registry Store Context SubKeys
//--------------------------------------------------------------------------

#ifdef CAPI_INCLUDE_CTL
#define CONTEXT_COUNT       3
#elif defined(CAPI_INCLUDE_CRL)
#define CONTEXT_COUNT		2
#else
#define CONTEXT_COUNT		1
#endif

static const LPCWSTR rgpwszContextSubKeyName[CONTEXT_COUNT] = {
    L"Certificates",

#if CONTEXT_COUNT > 1
    L"CRLs",
#endif

#if CONTEXT_COUNT > 2
    L"CTLs"
#endif    
};

#define KEYID_CONTEXT_NAME          L"Keys"

static DWORD rgdwContextTypeFlags[CONTEXT_COUNT] = {
    CERT_STORE_CERTIFICATE_CONTEXT_FLAG,

#if CONTEXT_COUNT > 1
    CERT_STORE_CRL_CONTEXT_FLAG,
#endif

#if CONTEXT_COUNT > 2
    CERT_STORE_CTL_CONTEXT_FLAG
#endif    
};

#define MY_SYSTEM_INDEX         0
#define ROOT_SYSTEM_INDEX       1
#define TRUST_SYSTEM_INDEX      2
#define CA_SYSTEM_INDEX         3
#define USER_DS_SYSTEM_INDEX    4

#define MY_SYSTEM_FLAG          (1 << MY_SYSTEM_INDEX)
#define ROOT_SYSTEM_FLAG        (1 << ROOT_SYSTEM_INDEX)
#define TRUST_SYSTEM_FLAG       (1 << TRUST_SYSTEM_INDEX)
#define CA_SYSTEM_FLAG          (1 << CA_SYSTEM_INDEX)
#define USER_DS_SYSTEM_FLAG     (1 << USER_DS_SYSTEM_INDEX)

#define COMMON_SYSTEM_FLAGS     ( \
    MY_SYSTEM_FLAG | \
    ROOT_SYSTEM_FLAG | \
    TRUST_SYSTEM_FLAG | \
    CA_SYSTEM_FLAG \
    )

#define wsz_MY_STORE        L"My"
#define wsz_ROOT_STORE      L"Root"
#define wsz_TRUST_STORE     L"Trust"
#define wsz_CA_STORE        L"CA"
#define wsz_USER_DS_STORE   L"UserDS"
static LPCWSTR rgpwszPredefinedSystemStore[] = {
    wsz_MY_STORE,
    wsz_ROOT_STORE,
    wsz_TRUST_STORE,
    wsz_CA_STORE,
    wsz_USER_DS_STORE
};
#define NUM_PREDEFINED_SYSTEM_STORE (sizeof(rgpwszPredefinedSystemStore) / \
                                        sizeof(rgpwszPredefinedSystemStore[0]))


#define DEFAULT_PHYSICAL_INDEX          0
#define GROUP_POLICY_PHYSICAL_INDEX     1
#define LOCAL_MACHINE_PHYSICAL_INDEX    2
#define DS_USER_CERT_PHYSICAL_INDEX     3
#define LMGP_PHYSICAL_INDEX             4
#define ENTERPRISE_PHYSICAL_INDEX       5
#define NUM_PREDEFINED_PHYSICAL         6

#define DEFAULT_PHYSICAL_FLAG           (1 << DEFAULT_PHYSICAL_INDEX)
#ifdef CE_BUILD
#define GROUP_POLICY_PHYSICAL_FLAG		0	// hack to make sure GP store are not in predefined collections
#else
#define GROUP_POLICY_PHYSICAL_FLAG      (1 << GROUP_POLICY_PHYSICAL_INDEX)
#endif
#define LOCAL_MACHINE_PHYSICAL_FLAG     (1 << LOCAL_MACHINE_PHYSICAL_INDEX)
#define DS_USER_CERT_PHYSICAL_FLAG      (1 << DS_USER_CERT_PHYSICAL_INDEX)
#define LMGP_PHYSICAL_FLAG              (1 << LMGP_PHYSICAL_INDEX)
#define ENTERPRISE_PHYSICAL_FLAG        (1 << ENTERPRISE_PHYSICAL_INDEX)

static LPCWSTR rgpwszPredefinedPhysical[NUM_PREDEFINED_PHYSICAL] = {
    CERT_PHYSICAL_STORE_DEFAULT_NAME,
    CERT_PHYSICAL_STORE_GROUP_POLICY_NAME,
    CERT_PHYSICAL_STORE_LOCAL_MACHINE_NAME,
    CERT_PHYSICAL_STORE_DS_USER_CERTIFICATE_NAME,
    CERT_PHYSICAL_STORE_LOCAL_MACHINE_GROUP_POLICY_NAME,
    CERT_PHYSICAL_STORE_ENTERPRISE_NAME,
};

#define NOT_IN_REGISTRY_SYSTEM_STORE_LOCATION_FLAG  0x1
#define REMOTABLE_SYSTEM_STORE_LOCATION_FLAG        0x2
#define SERIALIZED_SYSTEM_STORE_LOCATION_FLAG       0x4

typedef struct _SYSTEM_STORE_LOCATION_INFO {
    DWORD       dwFlags;
    DWORD       dwPredefinedSystemFlags;
    DWORD       dwPredefinedPhysicalFlags;
} SYSTEM_STORE_LOCATION_INFO, *PSYSTEM_STORE_LOCATION_INFO;


static const SYSTEM_STORE_LOCATION_INFO rgSystemStoreLocationInfo[] = {
    //  Not Defined                                     0
    NOT_IN_REGISTRY_SYSTEM_STORE_LOCATION_FLAG,
    0,
    0,

    //  CERT_SYSTEM_STORE_CURRENT_USER_ID               1
    0,
    COMMON_SYSTEM_FLAGS | USER_DS_SYSTEM_FLAG,
    DEFAULT_PHYSICAL_FLAG | GROUP_POLICY_PHYSICAL_FLAG |
        LOCAL_MACHINE_PHYSICAL_FLAG,

    // CERT_SYSTEM_STORE_LOCAL_MACHINE_ID               2
    REMOTABLE_SYSTEM_STORE_LOCATION_FLAG,
    COMMON_SYSTEM_FLAGS,
    DEFAULT_PHYSICAL_FLAG | GROUP_POLICY_PHYSICAL_FLAG |
        ENTERPRISE_PHYSICAL_FLAG,

    //  Not Defined                                     3
    NOT_IN_REGISTRY_SYSTEM_STORE_LOCATION_FLAG,
    0,
    0,

#ifndef UNDER_CE
    // CERT_SYSTEM_STORE_CURRENT_SERVICE_ID             4
    0,
    COMMON_SYSTEM_FLAGS,
    DEFAULT_PHYSICAL_FLAG | LOCAL_MACHINE_PHYSICAL_FLAG,

    // CERT_SYSTEM_STORE_SERVICES_ID                    5
    REMOTABLE_SYSTEM_STORE_LOCATION_FLAG,
    COMMON_SYSTEM_FLAGS,
    DEFAULT_PHYSICAL_FLAG | LOCAL_MACHINE_PHYSICAL_FLAG,

    // CERT_SYSTEM_STORE_USERS_ID                       6
    REMOTABLE_SYSTEM_STORE_LOCATION_FLAG,
    COMMON_SYSTEM_FLAGS,
    DEFAULT_PHYSICAL_FLAG | LOCAL_MACHINE_PHYSICAL_FLAG,

    // CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY_ID   7
    //SERIALIZED_SYSTEM_STORE_LOCATION_FLAG,
    0,
    COMMON_SYSTEM_FLAGS,
    DEFAULT_PHYSICAL_FLAG,

    // CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY_ID  8
    //SERIALIZED_SYSTEM_STORE_LOCATION_FLAG |
        REMOTABLE_SYSTEM_STORE_LOCATION_FLAG,
    COMMON_SYSTEM_FLAGS,
    DEFAULT_PHYSICAL_FLAG,

    // CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE_ID    9
    REMOTABLE_SYSTEM_STORE_LOCATION_FLAG,
    COMMON_SYSTEM_FLAGS,
    DEFAULT_PHYSICAL_FLAG
#else
// CE does not support the following locations:
    // CERT_SYSTEM_STORE_CURRENT_SERVICE_ID             4
    NOT_IN_REGISTRY_SYSTEM_STORE_LOCATION_FLAG,
    0,
    0,

    // CERT_SYSTEM_STORE_SERVICES_ID                    5
    NOT_IN_REGISTRY_SYSTEM_STORE_LOCATION_FLAG,
    0,
    0,

    // CERT_SYSTEM_STORE_USERS_ID                       6
    NOT_IN_REGISTRY_SYSTEM_STORE_LOCATION_FLAG,
    0,
    0,

    // CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY_ID   7
    //SERIALIZED_SYSTEM_STORE_LOCATION_FLAG,
    NOT_IN_REGISTRY_SYSTEM_STORE_LOCATION_FLAG,
    0,
    0,
    // CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY_ID  8
    //SERIALIZED_SYSTEM_STORE_LOCATION_FLAG |
    NOT_IN_REGISTRY_SYSTEM_STORE_LOCATION_FLAG,
    0,
    0,

    // CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE_ID    9
    NOT_IN_REGISTRY_SYSTEM_STORE_LOCATION_FLAG,
    0,
    0,
#endif
};

#define NUM_SYSTEM_STORE_LOCATION   (sizeof(rgSystemStoreLocationInfo) / \
                                        sizeof(rgSystemStoreLocationInfo[0]))

#define CURRENT_USER_ROOT_PHYSICAL_FLAGS ( \
    DEFAULT_PHYSICAL_FLAG | \
    LOCAL_MACHINE_PHYSICAL_FLAG \
    )

#define USERS_ROOT_PHYSICAL_FLAGS ( \
    LOCAL_MACHINE_PHYSICAL_FLAG \
    )

#define MY_PHYSICAL_FLAGS ( \
    DEFAULT_PHYSICAL_FLAG \
    )

#define USER_DS_PHYSICAL_FLAGS ( \
    DS_USER_CERT_PHYSICAL_FLAG \
    )


#define sz_CRYPTNET_DLL             "cryptnet.dll"
#define sz_GetUserDsStoreUrl        "I_CryptNetGetUserDsStoreUrl"
typedef BOOL (WINAPI *PFN_GET_USER_DS_STORE_URL)(
          IN LPWSTR pwszUserAttribute,
          OUT LPWSTR* ppwszUrl
          );

#define wsz_USER_CERTIFICATE_ATTR   L"userCertificate"


#define PHYSICAL_NAME_INDEX     0
#define SYSTEM_NAME_INDEX       1
#define SERVICE_NAME_INDEX      2
#define USER_NAME_INDEX         2
#define COMPUTER_NAME_INDEX     3
#define SYSTEM_NAME_PATH_COUNT  4

#define DEFAULT_USER_NAME       L".Default"

typedef struct _SYSTEM_NAME_INFO {
    LPWSTR      rgpwszName[SYSTEM_NAME_PATH_COUNT];
    // non-NULL for relocated store. Note hKeyBase isn't opened and
    // doesn't need to be closed
    HKEY        hKeyBase;
} SYSTEM_NAME_INFO, *PSYSTEM_NAME_INFO;


typedef struct _REG_STORE REG_STORE, *PREG_STORE;

typedef struct _ILS_RESYNC_ENTRY {
    HANDLE              hOrigEvent;
    HANDLE              hEvent;
    PREG_STORE          pRegStore;
} ILS_RESYNC_ENTRY, *PILS_RESYNC_ENTRY;

typedef struct _REGISTRY_STORE_CHANGE_INFO {
    HANDLE              hChange;
    HANDLE              hRegWaitFor;
    DWORD               cNotifyEntry;
    PILS_RESYNC_ENTRY   rgNotifyEntry;
} REGISTRY_STORE_CHANGE_INFO, *PREGISTRY_STORE_CHANGE_INFO;

//+-------------------------------------------------------------------------
//  Registry Store Provider handle information
//
//  hMyNotifyChange is our internal NotifyChange event handle.
//--------------------------------------------------------------------------
struct _REG_STORE {
    HCERTSTORE          hCertStore;         // not duplicated
    CRITICAL_SECTION    CriticalSection;
    HANDLE              hMyNotifyChange;
    BOOL                fResync;            // when set, ignore callback deletes
    HKEY                hKey;
    DWORD               dwFlags;

    // Following field is applicable to the CurrentUser "Root" store
    BOOL                fProtected;

    // Following field is applicable when
    // CERT_REGISTRY_STORE_SERIALIZED_FLAG is set in dwFlags
    BOOL                fTouched;      // set for write, delete or set property

    union {
        // Following field is applicable when
        // CERT_REGISTRY_STORE_CLIENT_GPT_FLAG is set in dwFlags
        CERT_REGISTRY_STORE_CLIENT_GPT_PARA GptPara;

        // Following field is applicable when
        // CERT_REGISTRY_STORE_ROAMING_FLAG is set in dwFlags
        LPWSTR              pwszStoreDirectory;
    };

    // Following field is applicable for change notify of registry or
    // roaming file store
    PREGISTRY_STORE_CHANGE_INFO pRegistryStoreChangeInfo;
};


typedef struct _ENUM_SYSTEM_STORE_LOCATION_INFO {
    DWORD               dwFlags;
    LPCWSTR             pwszLocation;
} ENUM_SYSTEM_STORE_LOCATION_INFO, *PENUM_SYSTEM_STORE_LOCATION_INFO;

// Predefined crypt32.dll locations. MUST NOT BE REGISTERED!!!
static const ENUM_SYSTEM_STORE_LOCATION_INFO rgEnumSystemStoreLocationInfo[] = {
    CERT_SYSTEM_STORE_CURRENT_USER, L"CurrentUser",
    CERT_SYSTEM_STORE_LOCAL_MACHINE, L"LocalMachine",
    CERT_SYSTEM_STORE_CURRENT_SERVICE, L"CurrentService",
    CERT_SYSTEM_STORE_SERVICES, L"Services",
    CERT_SYSTEM_STORE_USERS, L"Users",
    CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY, L"CurrentUserGroupPolicy",
    CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY, L"LocalMachineGroupPolicy",
    CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE, L"LocalMachineEnterprise"
};
#define ENUM_SYSTEM_STORE_LOCATION_CNT \
        (sizeof(rgEnumSystemStoreLocationInfo) / \
            sizeof(rgEnumSystemStoreLocationInfo[0]))

#define OPEN_SYSTEM_STORE_PROV_FUNC_SET     0
#define REGISTER_SYSTEM_STORE_FUNC_SET      1
#define UNREGISTER_SYSTEM_STORE_FUNC_SET    2
#define ENUM_SYSTEM_STORE_FUNC_SET          3
#define REGISTER_PHYSICAL_STORE_FUNC_SET    4
#define UNREGISTER_PHYSICAL_STORE_FUNC_SET  5
#define ENUM_PHYSICAL_STORE_FUNC_SET        6
#define FUNC_SET_COUNT                      7

static HCRYPTOIDFUNCSET rghFuncSet[FUNC_SET_COUNT];
static const LPCSTR rgpszFuncName[FUNC_SET_COUNT] = {
    CRYPT_OID_OPEN_SYSTEM_STORE_PROV_FUNC,
    CRYPT_OID_REGISTER_SYSTEM_STORE_FUNC,
    CRYPT_OID_UNREGISTER_SYSTEM_STORE_FUNC,
    CRYPT_OID_ENUM_SYSTEM_STORE_FUNC,
    CRYPT_OID_REGISTER_PHYSICAL_STORE_FUNC,
    CRYPT_OID_UNREGISTER_PHYSICAL_STORE_FUNC,
    CRYPT_OID_ENUM_PHYSICAL_STORE_FUNC
};

typedef BOOL (WINAPI *PFN_REGISTER_SYSTEM_STORE)(
    IN const void *pvSystemStore,
    IN DWORD dwFlags,
    IN PCERT_SYSTEM_STORE_INFO pStoreInfo,
    IN OPTIONAL void *pvReserved
    );
typedef BOOL (WINAPI *PFN_UNREGISTER_SYSTEM_STORE)(
    IN const void *pvSystemStore,
    IN DWORD dwFlags
    );
typedef BOOL (WINAPI *PFN_ENUM_SYSTEM_STORE)(
    IN DWORD dwFlags,
    IN OPTIONAL void *pvSystemStoreLocationPara,
    IN void *pvArg,
    IN PFN_CERT_ENUM_SYSTEM_STORE pfnEnum
    );

typedef BOOL (WINAPI *PFN_REGISTER_PHYSICAL_STORE)(
    IN const void *pvSystemStore,
    IN DWORD dwFlags,
    IN LPCWSTR pwszStoreName,
    IN PCERT_PHYSICAL_STORE_INFO pStoreInfo,
    IN OPTIONAL void *pvReserved
    );
typedef BOOL (WINAPI *PFN_UNREGISTER_PHYSICAL_STORE)(
    IN const void *pvSystemStore,
    IN DWORD dwFlags,
    IN LPCWSTR pwszStoreName
    );
typedef BOOL (WINAPI *PFN_ENUM_PHYSICAL_STORE)(
    IN const void *pvSystemStore,
    IN DWORD dwFlags,
    IN void *pvArg,
    IN PFN_CERT_ENUM_PHYSICAL_STORE pfnEnum
    );


//+-------------------------------------------------------------------------
//  Registry Store Provider Functions.
//--------------------------------------------------------------------------
STATIC void WINAPI RegStoreProvClose(
        IN HCERTSTOREPROV hStoreProv,
        IN DWORD dwFlags
        );
STATIC BOOL WINAPI RegStoreProvReadCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pStoreCertContext,
        IN DWORD dwFlags,
        OUT PCCERT_CONTEXT *ppProvCertContext
        );
STATIC BOOL WINAPI RegStoreProvWriteCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwFlags
        );
STATIC BOOL WINAPI RegStoreProvDeleteCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwFlags
        );
STATIC BOOL WINAPI RegStoreProvSetCertProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        IN const void *pvData
        );

STATIC BOOL WINAPI RegStoreProvReadCrl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pStoreCrlContext,
        IN DWORD dwFlags,
        OUT PCCRL_CONTEXT *ppProvCrlContext
        );
STATIC BOOL WINAPI RegStoreProvWriteCrl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pCrlContext,
        IN DWORD dwFlags
        );
STATIC BOOL WINAPI RegStoreProvDeleteCrl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pCrlContext,
        IN DWORD dwFlags
        );
STATIC BOOL WINAPI RegStoreProvSetCrlProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pCrlContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        IN const void *pvData
        );

STATIC BOOL WINAPI RegStoreProvReadCtl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pStoreCtlContext,
        IN DWORD dwFlags,
        OUT PCCTL_CONTEXT *ppProvCtlContext
        );
STATIC BOOL WINAPI RegStoreProvWriteCtl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pCtlContext,
        IN DWORD dwFlags
        );
STATIC BOOL WINAPI RegStoreProvDeleteCtl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pCtlContext,
        IN DWORD dwFlags
        );
STATIC BOOL WINAPI RegStoreProvSetCtlProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pCtlContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        IN const void *pvData
        );

STATIC BOOL WINAPI RegStoreProvControl(
        IN HCERTSTOREPROV hStoreProv,
        IN DWORD dwFlags,
        IN DWORD dwCtrlType,
        IN void const *pvCtrlPara
        );

static void * const rgpvRegStoreProvFunc[] = {
    // CERT_STORE_PROV_CLOSE_FUNC              0
    RegStoreProvClose,
    // CERT_STORE_PROV_READ_CERT_FUNC          1
    RegStoreProvReadCert,
    // CERT_STORE_PROV_WRITE_CERT_FUNC         2
    RegStoreProvWriteCert,
    // CERT_STORE_PROV_DELETE_CERT_FUNC        3
    RegStoreProvDeleteCert,
    // CERT_STORE_PROV_SET_CERT_PROPERTY_FUNC  4
    RegStoreProvSetCertProperty,
#ifdef CAPI_INCLUDE_CRL    
    // CERT_STORE_PROV_READ_CRL_FUNC           5
    RegStoreProvReadCrl,
    // CERT_STORE_PROV_WRITE_CRL_FUNC          6
    RegStoreProvWriteCrl,
    // CERT_STORE_PROV_DELETE_CRL_FUNC         7
    RegStoreProvDeleteCrl,
    // CERT_STORE_PROV_SET_CRL_PROPERTY_FUNC   8
    RegStoreProvSetCrlProperty,
#else
	NULL,NULL,NULL,NULL,
#endif
#ifdef CAPI_INCLUDE_CTL
    // CERT_STORE_PROV_READ_CTL_FUNC           9
    RegStoreProvReadCtl,
    // CERT_STORE_PROV_WRITE_CTL_FUNC          10
    RegStoreProvWriteCtl,
    // CERT_STORE_PROV_DELETE_CTL_FUNC         11
    RegStoreProvDeleteCtl,
    // CERT_STORE_PROV_SET_CTL_PROPERTY_FUNC   12
    RegStoreProvSetCtlProperty,
  #else
 	NULL,NULL,NULL,NULL,
 #endif

#ifndef CE_BUILD
   // CERT_STORE_PROV_CONTROL_FUNC            13
    RegStoreProvControl
#else
	NULL
#endif	
};
#define REG_STORE_PROV_FUNC_COUNT (sizeof(rgpvRegStoreProvFunc) / \
                                    sizeof(rgpvRegStoreProvFunc[0]))

STATIC BOOL WINAPI RootStoreProvWriteCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwFlags
        );

STATIC BOOL WINAPI RootStoreProvDeleteCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwFlags
        );

static void * const rgpvRootStoreProvFunc[] = {
    // CERT_STORE_PROV_CLOSE_FUNC              0
    RegStoreProvClose,
    // CERT_STORE_PROV_READ_CERT_FUNC          1
    RegStoreProvReadCert,
    // CERT_STORE_PROV_WRITE_CERT_FUNC         2
    RootStoreProvWriteCert,
    // CERT_STORE_PROV_DELETE_CERT_FUNC        3
    RootStoreProvDeleteCert,
    // CERT_STORE_PROV_SET_CERT_PROPERTY_FUNC  4
    RegStoreProvSetCertProperty,
#ifdef CAPI_INCLUDE_CRL
    // CERT_STORE_PROV_READ_CRL_FUNC           5
    RegStoreProvReadCrl,
    // CERT_STORE_PROV_WRITE_CRL_FUNC          6
    RegStoreProvWriteCrl,
    // CERT_STORE_PROV_DELETE_CRL_FUNC         7
    RegStoreProvDeleteCrl,
    // CERT_STORE_PROV_SET_CRL_PROPERTY_FUNC   8
    RegStoreProvSetCrlProperty,
#else
	NULL,NULL,NULL,NULL,
#endif
#ifdef CAPI_INCLUDE_CTL
    // CERT_STORE_PROV_READ_CTL_FUNC           9
    RegStoreProvReadCtl,
    // CERT_STORE_PROV_WRITE_CTL_FUNC          10
    RegStoreProvWriteCtl,
    // CERT_STORE_PROV_DELETE_CTL_FUNC         11
    RegStoreProvDeleteCtl,
    // CERT_STORE_PROV_SET_CTL_PROPERTY_FUNC   12
    RegStoreProvSetCtlProperty,
#else
	NULL,NULL,NULL,NULL,
#endif

#ifndef CE_BUILD
    // CERT_STORE_PROV_CONTROL_FUNC            13
    RegStoreProvControl
#else
	NULL
#endif
};
#define ROOT_STORE_PROV_FUNC_COUNT (sizeof(rgpvRootStoreProvFunc) / \
                                    sizeof(rgpvRootStoreProvFunc[0]))

//+-------------------------------------------------------------------------
//  Add the serialized store to the store.
//
//  from newstor.cpp
//--------------------------------------------------------------------------
extern BOOL WINAPI I_CertAddSerializedStore(
        IN HCERTSTORE hCertStore,
        IN BYTE *pbStore,
        IN DWORD cbStore
        );

//+-------------------------------------------------------------------------
//  CertStore allocation and free functions
//--------------------------------------------------------------------------
STATIC LPWSTR AllocAndCopyString(
    IN LPCWSTR pwszSrc,
    IN LONG cchSrc = -1
    )
{
    LPWSTR pwszDst;

    if (cchSrc < 0)
        cchSrc = wcslen(pwszSrc);
    if (NULL == (pwszDst = (LPWSTR) PkiNonzeroAlloc(
            (cchSrc + 1) * sizeof(WCHAR))))
        return NULL;
    if (0 < cchSrc)
        memcpy((BYTE *) pwszDst, (BYTE *) pwszSrc, cchSrc * sizeof(WCHAR));
    pwszDst[cchSrc] = L'\0';
    return pwszDst;
}

#if 1
// BUGBUG move to crypt32.dll
extern
BOOL
WINAPI
I_ProtectedRootDllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved);
#endif

//+=========================================================================
//  Register WaitFor Forward Function References
//==========================================================================
STATIC void RegWaitForProcessAttach();
STATIC void RegWaitForProcessDetach();

//+=========================================================================
//  Client "GPT" Store Forward Function References
//==========================================================================
STATIC void GptStoreProcessAttach();
STATIC void GptStoreProcessDetach();

STATIC BOOL OpenAllFromGptRegistry(
    IN PREG_STORE pRegStore,
    IN HCERTSTORE hCertStore
    );

STATIC BOOL CommitAllToGptRegistry(
    IN PREG_STORE pRegStore,
    IN DWORD dwFlags
    );

STATIC void GptStoreSignalAndFreeRegStoreResyncEntries(
    IN PREG_STORE pRegStore
    );

STATIC BOOL RegGptStoreChange(
    IN PREG_STORE pRegStore,
    IN HANDLE hEvent
    );

static inline BOOL IsClientGptStore(
    IN PSYSTEM_NAME_INFO pInfo,
    IN DWORD dwFlags
    )
{
    DWORD dwStoreLocation = dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK;

    if (!(CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY == dwStoreLocation ||
          CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY == dwStoreLocation))
        return FALSE;

    if (dwFlags & (CERT_SYSTEM_STORE_RELOCATE_FLAG | CERT_STORE_DELETE_FLAG))
        return FALSE;

    return TRUE;
}

//+=========================================================================
//  Win95 Notify Store Forward Function References
//==========================================================================

// Following is created at ProcessAttach for Win95 clients
static HANDLE hWin95NotifyEvent = NULL;

STATIC void Win95StoreProcessAttach();
STATIC void Win95StoreProcessDetach();

STATIC void Win95StoreSignalAndFreeRegStoreResyncEntries(
    IN PREG_STORE pRegStore
    );

STATIC BOOL RegWin95StoreChange(
    IN PREG_STORE pRegStore,
    IN HANDLE hEvent
    );

//+=========================================================================
// Roaming Store Forward Function References
//==========================================================================
STATIC void RoamingStoreProcessAttach();
STATIC void RoamingStoreProcessDetach();

LPWSTR
ILS_GetRoamingStoreDirectory(
    IN LPCWSTR pwszStoreName
    );

BOOL
ILS_WriteElementToFile(
    IN LPCWSTR pwszStoreDir,
    IN LPCWSTR pwszContextName,
    IN const WCHAR wszHashName[MAX_HASH_NAME_LEN],
    IN DWORD dwFlags,       // CERT_STORE_CREATE_NEW_FLAG may be set
    IN const BYTE *pbElement,
    IN DWORD cbElement
    );

BOOL
ILS_ReadElementFromFile(
    IN LPCWSTR pwszStoreDir,
    IN LPCWSTR pwszContextName,
    IN const WCHAR wszHashName[MAX_HASH_NAME_LEN],
    IN DWORD dwFlags,
    OUT BYTE **ppbElement,
    OUT DWORD *pcbElement
    );

BOOL
ILS_DeleteElementFromDirectory(
    IN LPCWSTR pwszStoreDir,
    IN LPCWSTR pwszContextName,
    IN const WCHAR wszHashName[MAX_HASH_NAME_LEN],
    IN DWORD dwFlags
    );

typedef BOOL (*PFN_ILS_OPEN_ELEMENT)(
    IN const WCHAR wszHashName[MAX_HASH_NAME_LEN],
    IN const BYTE *pbElement,
    IN DWORD cbElement,
    IN void *pvArg
    );

BOOL
ILS_OpenAllElementsFromDirectory(
    IN LPCWSTR pwszStoreDir,
    IN LPCWSTR pwszContextName,
    IN DWORD dwFlags,
    IN void *pvArg,
    IN PFN_ILS_OPEN_ELEMENT pfnOpenElement
    );

//+=========================================================================
// Registry or Roaming Store Change Notify Functions
//==========================================================================
STATIC BOOL RegRegistryStoreChange(
    IN PREG_STORE pRegStore,
    IN HANDLE hEvent
    );

STATIC void FreeRegistryStoreChange(
    IN PREG_STORE pRegStore
    );

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL
WINAPI
I_RegStoreDllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved)
{
    BOOL    fRet;
    DWORD   i;

#ifndef CE_BUILD
    // BUGBUG move to crypt32.dll
    if (!I_ProtectedRootDllMain(hInst, ulReason, lpReserved))
        goto ErrorReturn;
#endif

    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        InitializeCriticalSection(&ILS_CriticalSection);
#ifndef CE_BUILD     
        RegWaitForProcessAttach();
        GptStoreProcessAttach();
        Win95StoreProcessAttach();
        RoamingStoreProcessAttach();
#endif
        for (i = 0; i < FUNC_SET_COUNT; i++) {
            if (NULL == (rghFuncSet[i] = CryptInitOIDFunctionSet(
                rgpszFuncName[i], 0)))
            goto CryptInitOIDFunctionSetError;
        }
        if (NULL == (hTlsEnumPhysicalStoreDepth = I_CryptAllocTls()))
            goto CryptAllocTlsError;
        break;

    case DLL_PROCESS_DETACH:
#ifndef CE_BUILD    
        RoamingStoreProcessDetach();
        Win95StoreProcessDetach();
        GptStoreProcessDetach();
        RegWaitForProcessDetach();
#endif        
        DeleteCriticalSection(&ILS_CriticalSection);
        I_CryptFreeTls(hTlsEnumPhysicalStoreDepth, PkiFree);
        break;

    case DLL_THREAD_DETACH:
        PkiFree(I_CryptDetachTls(hTlsEnumPhysicalStoreDepth));
        break;
    default:
        break;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(CryptInitOIDFunctionSetError)
TRACE_ERROR(CryptAllocTlsError)
}

//+-------------------------------------------------------------------------
//  Converts the bytes into UNICODE ASCII HEX
//
//  Needs (cb * 2 + 1) * sizeof(WCHAR) bytes of space in wsz
//--------------------------------------------------------------------------
STATIC void BytesToWStr(DWORD cb, void* pv, LPWSTR wsz)
{
    BYTE* pb = (BYTE*) pv;
    for (DWORD i = 0; i<cb; i++) {
        int b;
        b = (*pb & 0xF0) >> 4;
        *wsz++ = (b <= 9) ? b + L'0' : (b - 10) + L'A';
        b = *pb & 0x0F;
        *wsz++ = (b <= 9) ? b + L'0' : (b - 10) + L'A';
        pb++;
    }
    *wsz++ = 0;
}

//+-------------------------------------------------------------------------
//  Converts the UNICODE ASCII HEX to an array of bytes
//--------------------------------------------------------------------------
STATIC void WStrToBytes(
    IN const WCHAR wsz[MAX_HASH_NAME_LEN],
    OUT BYTE rgb[MAX_HASH_LEN],
    OUT DWORD *pcb
    )
{
    BOOL fUpperNibble = TRUE;
    DWORD cb = 0;
    LPCWSTR pwsz = wsz;
    WCHAR wch;

    while (cb < MAX_HASH_LEN && (wch = *pwsz++)) {
        BYTE b;

        // only convert ascii hex characters 0..9, a..f, A..F
        // silently ignore all others
        if (wch >= L'0' && wch <= L'9')
            b = wch - L'0';
        else if (wch >= L'a' && wch <= L'f')
            b = 10 + wch - L'a';
        else if (wch >= L'A' && wch <= L'F')
            b = 10 + wch - L'A';
        else
            continue;

        if (fUpperNibble) {
            rgb[cb] = b << 4;
            fUpperNibble = FALSE;
        } else {
            rgb[cb] = rgb[cb] | b;
            cb++;
            fUpperNibble = TRUE;
        }
    }

    *pcb = cb;
}

//+-------------------------------------------------------------------------
//  Lock and unlock registry functions
//--------------------------------------------------------------------------
static inline void LockRegStore(IN PREG_STORE pRegStore)
{
    EnterCriticalSection(&pRegStore->CriticalSection);
}
static inline void UnlockRegStore(IN PREG_STORE pRegStore)
{
    LeaveCriticalSection(&pRegStore->CriticalSection);
}

//+-------------------------------------------------------------------------
//  Checks if current thread is doing a Resync. Other threads block until
//  the resync completes
//--------------------------------------------------------------------------
STATIC BOOL IsInResync(IN PREG_STORE pRegStore)
{
    BOOL fResync;

    LockRegStore(pRegStore);
    fResync = pRegStore->fResync;
    UnlockRegStore(pRegStore);
    return fResync;
}

//+=========================================================================
//  Low level registry support functions
//==========================================================================

// LastError can get globbered when doing remote registry access
void
ILS_CloseRegistryKey(
    IN HKEY hKey
    )
{
#ifndef _XBOX
    if (hKey) {
        DWORD dwErr = GetLastError();
        LONG RegCloseKeyStatus;
        RegCloseKeyStatus = RegCloseKey(hKey);
        assert(ERROR_SUCCESS == RegCloseKeyStatus);
        SetLastError(dwErr);
    }
#endif
}

STATIC BOOL WriteDWORDValueToRegistry(
    IN HKEY hKey,
    IN LPCWSTR pwszValueName,
    IN DWORD dwValue
    )
{
#ifndef _XBOX
    LONG err;
    if (ERROR_SUCCESS == (err = RegSetValueExU(
            hKey,
            pwszValueName,
            0,          // dwReserved
            REG_DWORD,
            (BYTE *) &dwValue,
            sizeof(DWORD))))
        return TRUE;
    else {
        SetLastError((DWORD) err);
        return FALSE;
    }
#else
	return TRUE;
#endif
}

BOOL
ILS_ReadDWORDValueFromRegistry(
    IN HKEY hKey,
    IN LPCWSTR pwszValueName,
    IN DWORD *pdwValue
    )
{
#ifndef _XBOX
    BOOL fResult;
    LONG err;
    DWORD dwType;
    DWORD dwValue;
    DWORD cbValue = sizeof(DWORD);

    if (ERROR_SUCCESS != (err = RegQueryValueExU(
            hKey,
            pwszValueName,
            NULL,       // pdwReserved
            &dwType,
            (BYTE *) &dwValue,
            &cbValue))) goto RegQueryValueError;
    if (dwType != REG_DWORD || cbValue != sizeof(DWORD))
        goto InvalidRegistryValue;
    fResult = TRUE;
CommonReturn:
    *pdwValue = dwValue;
    return fResult;
ErrorReturn:
    dwValue = 0;
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR_VAR(RegQueryValueError, err)
SET_ERROR(InvalidRegistryValue, CRYPT_E_FILE_ERROR)
#else
	return TRUE;
#endif
}

// Ensure a binary value that may contain a LPCWSTR is NULL terminated.
// Always adds a NULL terminator not included in the returned cbValue.
//
// May return an allocated pbValue with a cbValue = 0.
BOOL
ILS_ReadBINARYValueFromRegistry(
    IN HKEY hKey,
    IN LPCWSTR pwszValueName,
    OUT BYTE **ppbValue,
    OUT DWORD *pcbValue
    )
{
#ifndef _XBOX
    BOOL fResult;
    LONG err;
    DWORD dwType;
    BYTE *pbValue = NULL;
    DWORD cbValue;
    DWORD cbAllocValue;

    err = RegQueryValueExU(
            hKey,
            pwszValueName,
            NULL,       // pdwReserved
            &dwType,
            NULL,       // lpData
            &cbValue);
    // For Win95 Remote Registry Access:: returns ERROR_MORE_DATA
    if (!(ERROR_SUCCESS == err || ERROR_MORE_DATA == err))
        goto RegQueryValueError;
    if (dwType != REG_BINARY)
        goto InvalidRegistryValue;
    cbAllocValue = cbValue + 3;
    if (NULL == (pbValue = (BYTE *) PkiNonzeroAlloc(cbAllocValue)))
        goto OutOfMemory;
    if (0 < cbValue) {
        if (ERROR_SUCCESS != (err = RegQueryValueExU(
                hKey,
                pwszValueName,
                NULL,       // pdwReserved
                &dwType,
                pbValue,
                &cbValue))) goto RegQueryValueError;
    }
    assert(cbAllocValue >= cbValue + 3);

    // Ensure an LPWSTR is null terminated
    memset(pbValue + cbValue, 0, 3);

    fResult = TRUE;
CommonReturn:
    *ppbValue = pbValue;
    *pcbValue = cbValue;
    return fResult;
ErrorReturn:
    fResult = FALSE;
    PkiFree(pbValue);
    pbValue = NULL;
    cbValue = 0;
    goto CommonReturn;

SET_ERROR_VAR(RegQueryValueError, err)
SET_ERROR(InvalidRegistryValue, CRYPT_E_FILE_ERROR)
TRACE_ERROR(OutOfMemory)
#else
	return TRUE;
#endif
}

//+-------------------------------------------------------------------------
//  Get and allocate the REG_SZ value
//--------------------------------------------------------------------------
STATIC LPWSTR ReadSZValueFromRegistry(
    IN HKEY hKey,
    IN LPCWSTR pwszValueName
    )
{
#ifndef _XBOX
    LONG err;
    DWORD dwType;
    LPWSTR pwszValue = NULL;
    DWORD cbValue;

    err = RegQueryValueExU(
            hKey,
            pwszValueName,
            NULL,       // pdwReserved
            &dwType,
            NULL,       // lpData
            &cbValue);
    // For Win95 Remote Registry Access:: returns ERROR_MORE_DATA
    if (!(ERROR_SUCCESS == err || ERROR_MORE_DATA == err))
        goto RegQueryValueError;
    if (dwType != REG_SZ || cbValue == 0)
        goto InvalidRegistryValue;
    if (NULL == (pwszValue = (LPWSTR) PkiNonzeroAlloc(cbValue)))
        goto OutOfMemory;
    if (ERROR_SUCCESS != (err = RegQueryValueExU(
            hKey,
            pwszValueName,
            NULL,       // pdwReserved
            &dwType,
            (BYTE *) pwszValue,
            &cbValue))) goto RegQueryValueError;
CommonReturn:
    return pwszValue;
ErrorReturn:
    PkiFree(pwszValue);
    pwszValue = NULL;
    goto CommonReturn;

SET_ERROR_VAR(RegQueryValueError, err)
SET_ERROR(InvalidRegistryValue, CRYPT_E_FILE_ERROR)
TRACE_ERROR(OutOfMemory)
#else
	return NULL;
#endif
}

#ifndef CE_BUILD
STATIC LPSTR ReadSZValueFromRegistry(
    IN HKEY hKey,
    IN LPCSTR pszValueName
    )
{
    LONG err;
    DWORD dwType;
    LPSTR pszValue = NULL;
    DWORD cbValue;

    err = RegQueryValueExA(
            hKey,
            pszValueName,
            NULL,       // pdwReserved
            &dwType,
            NULL,       // lpData
            &cbValue);
    // For Win95 Remote Registry Access:: returns ERROR_MORE_DATA
    if (!(ERROR_SUCCESS == err || ERROR_MORE_DATA == err))
        goto RegQueryValueError;
    if (dwType != REG_SZ || cbValue == 0)
        goto InvalidRegistryValue;
    if (NULL == (pszValue = (LPSTR) PkiNonzeroAlloc(cbValue)))
        goto OutOfMemory;
    if (ERROR_SUCCESS != (err = RegQueryValueExA(
            hKey,
            pszValueName,
            NULL,       // pdwReserved
            &dwType,
            (BYTE *) pszValue,
            &cbValue))) goto RegQueryValueError;
CommonReturn:
    return pszValue;
ErrorReturn:
    PkiFree(pszValue);
    pszValue = NULL;
    goto CommonReturn;

SET_ERROR_VAR(RegQueryValueError, err)
SET_ERROR(InvalidRegistryValue, CRYPT_E_FILE_ERROR)
TRACE_ERROR(OutOfMemory)
}

#endif

STATIC BOOL GetSubKeyInfo(
    IN HKEY hKey,
    OUT OPTIONAL DWORD *pcSubKeys,
    OUT OPTIONAL DWORD *pcchMaxSubKey = NULL
    )
{
    BOOL fResult;
    LONG err;
    if (ERROR_SUCCESS != (err = RegQueryInfoKeyU(
            hKey,
            NULL,       // lpszClass
            NULL,       // lpcchClass
            NULL,       // lpdwReserved
            pcSubKeys,
            pcchMaxSubKey,
            NULL,       // lpcchMaxClass
            NULL,       // lpcValues
            NULL,       // lpcchMaxValuesName
            NULL,       // lpcbMaxValueData
            NULL,       // lpcbSecurityDescriptor
            NULL        // lpftLastWriteTime
            ))) goto RegQueryInfoKeyError;
    fResult = TRUE;

CommonReturn:
    // For Win95 Remote Registry Access:: returns half of the cch
    if (pcchMaxSubKey && *pcchMaxSubKey)
        *pcchMaxSubKey = (*pcchMaxSubKey + 1) * 2 + 2;
    return fResult;
ErrorReturn:
    fResult = FALSE;
    if (pcSubKeys)
        *pcSubKeys = 0;
    if (pcchMaxSubKey)
        *pcchMaxSubKey = 0;
    goto CommonReturn;
SET_ERROR_VAR(RegQueryInfoKeyError, err)
}

//+-------------------------------------------------------------------------
//  Open the SubKey.
//
//  dwFlags:
//      CERT_STORE_READONLY_FLAG
//      CERT_STORE_OPEN_EXISTING_FLAG
//      CERT_STORE_CREATE_NEW_FLAG
//--------------------------------------------------------------------------
STATIC HKEY OpenSubKey(
    IN HKEY hKey,
    IN LPCWSTR pwszSubKeyName,
    IN DWORD dwFlags
    )
{
#ifndef _XBOX
    LONG err;
    HKEY hSubKey;

    if (dwFlags & CERT_STORE_CREATE_NEW_FLAG) {
        // First check if SubKey already exists
        if (hSubKey = OpenSubKey(
                hKey,
                pwszSubKeyName,
                (dwFlags & ~CERT_STORE_CREATE_NEW_FLAG) |
                    CERT_STORE_OPEN_EXISTING_FLAG |
                    CERT_STORE_READONLY_FLAG
                )) {
            RegCloseKey(hSubKey);
            goto ExistingSubKey;
        } else if (ERROR_FILE_NOT_FOUND != GetLastError())
            goto OpenNewSubKeyError;
    }

    if (dwFlags & (CERT_STORE_READONLY_FLAG | CERT_STORE_OPEN_EXISTING_FLAG)) {
        REGSAM samDesired;
        if (dwFlags & CERT_STORE_READONLY_FLAG)
            samDesired = KEY_READ;
        else
            samDesired = KEY_ALL_ACCESS;

        if (ERROR_SUCCESS != (err = RegOpenHKCUKeyExU(
                hKey,
                pwszSubKeyName,
                0,                      // dwReserved
                samDesired,
                &hSubKey)))
            goto RegOpenKeyError;
    } else {
        DWORD dwDisposition;
        if (ERROR_SUCCESS != (err = RegCreateHKCUKeyExU(
                hKey,
                pwszSubKeyName,
                0,                      // dwReserved
                NULL,                   // lpClass
                REG_OPTION_NON_VOLATILE,
                KEY_ALL_ACCESS,
                NULL,                   // lpSecurityAttributes
                &hSubKey,
                &dwDisposition)))
            goto RegCreateKeyError;
    }

CommonReturn:
    return hSubKey;
ErrorReturn:
    hSubKey = NULL;
    goto CommonReturn;

SET_ERROR_VAR(ExistingSubKey, ERROR_FILE_EXISTS)
TRACE_ERROR(OpenNewSubKeyError)
SET_ERROR_VAR(RegOpenKeyError, err)
SET_ERROR_VAR(RegCreateKeyError, err)
#else
	ASSERT(!"OpenSubKey called");
	return NULL;
#endif
}


STATIC BOOL RecursiveDeleteSubKey(
    IN HKEY hKey,
    IN LPCWSTR pwszSubKeyName
    )
{
#ifndef _XBOX
    BOOL fResult;
    LONG err;

    while (TRUE) {
        HKEY hSubKey;
        DWORD cSubKeys;
        DWORD cchMaxSubKey;
        BOOL fDidDelete;

        if (ERROR_SUCCESS != RegOpenHKCUKeyExU(
                hKey,
                pwszSubKeyName,
                0,                      // dwReserved
                KEY_ALL_ACCESS,
                &hSubKey))
            break;

        GetSubKeyInfo(
            hSubKey,
            &cSubKeys,
            &cchMaxSubKey
            );

        fDidDelete = FALSE;
        if (cSubKeys && cchMaxSubKey) {
            LPWSTR pwszEnumSubKeyName;
            cchMaxSubKey++;

            if (pwszEnumSubKeyName = (LPWSTR) PkiNonzeroAlloc(
                    cchMaxSubKey * sizeof(WCHAR))) {
                if (ERROR_SUCCESS == RegEnumKeyExU(
                        hSubKey,
                        0,
                        pwszEnumSubKeyName,
                        &cchMaxSubKey,
                        NULL,               // lpdwReserved
                        NULL,               // lpszClass
                        NULL,               // lpcchClass
                        NULL                // lpftLastWriteTime
                        ))
                    fDidDelete = RecursiveDeleteSubKey(
                        hSubKey, pwszEnumSubKeyName);
                PkiFree(pwszEnumSubKeyName);
            }
        }
        RegCloseKey(hSubKey);
        if (!fDidDelete)
            break;
    }

    if (ERROR_SUCCESS != (err = RegDeleteKeyU(hKey, pwszSubKeyName)))
        goto RegDeleteKeyError;
    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR_VAR(RegDeleteKeyError, err)
#else
	ASSERT(!"RecursiveDeleteSubKey called");
	return NULL;
#endif
}

//+=========================================================================
//  Win95 Registry Functions
//
//  Note, as of 10/17/97 the following is also done on NT to allow
//  registry hive roaming from NT to Win95 systems.
//
//  Certs, CRLs and CTLs are stored in SubKeys instead of as Key values.
//
//  Note: Win95 has the following registry limitations:
//   - Max single key value is 16K
//   - Max total values per key is 64K
//
//  For WIN95, write each cert, CRL, CTL to its own key when the
//  above limitations are exceeded. If encoded blob exceeds 12K, partition
//  and write to multiple SubKeys. Blobs are written to values named
//  "Blob". Partitioned blobs, have "BlobCount" and "BlobLength" values and
//  SubKeys named "Blob0", "Blob1", "Blob2" ... .
//
//  The IE4.0 version of crypt32 wrote the blob to a "File" if the blob
//  exceeded 12K. For backwards compatibility, continue to read "File" based
//  blobs. On write enabled, non-remote opens, "File" blobs are moved to
//  "Blob0", ... SubKeys and the file is deleted.
//
//  If CERT_REGISTRY_STORE_SERIALIZED_FLAG is set when the registry store
//  is opened, then, the entire store resides in a partitioned blob under the
//  "Serialized" subkey.
//==========================================================================
#define KEY_BLOB_VALUE_NAME             L"Blob"
#define KEY_FILE_VALUE_NAME             L"File"
#define KEY_BLOB_COUNT_VALUE_NAME       L"BlobCount"
#define KEY_BLOB_LENGTH_VALUE_NAME      L"BlobLength"
#define KEY_BLOB_N_SUBKEY_PREFIX        "Blob"
#define KEY_BLOB_N_SUBKEY_PREFIX_LENGTH 4
#define SYSTEM_STORE_SUBDIR             L"SystemCertificates"
#define FILETIME_ASCII_HEX_LEN          (2 * sizeof(FILETIME) + 1)
#define MAX_KEY_BLOB_VALUE_LEN          0x3000
#define MAX_NEW_FILE_CREATE_ATTEMPTS    100

#define SERIALIZED_SUBKEY_NAME          L"Serialized"


//+-------------------------------------------------------------------------
//  Read and allocate the element bytes by reading the file pointed to
//  by the SubKey's "File" value
//--------------------------------------------------------------------------
STATIC BOOL ReadKeyFileElementFromRegistry(
    IN HKEY hSubKey,
    OUT BYTE **ppbElement,
    OUT DWORD *pcbElement
    )
{
#ifndef _XBOX
    BOOL fResult;
    LPWSTR pwszFilename = NULL;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD cbBytesRead;
    BYTE *pbElement = NULL;
    DWORD cbElement;

    if (NULL == (pwszFilename = ReadSZValueFromRegistry(
            hSubKey, KEY_FILE_VALUE_NAME)))
        goto GetKeyFilenameError;

    if (INVALID_HANDLE_VALUE == (hFile = CreateFileU(
              pwszFilename,
              GENERIC_READ,
              FILE_SHARE_READ,
              NULL,                   // lpsa
              OPEN_EXISTING,
              FILE_ATTRIBUTE_NORMAL,
              NULL                    // hTemplateFile
              )))
        goto CreateFileError;

    cbElement = GetFileSize(hFile, NULL);
    if (0xFFFFFFFF == cbElement) goto FileError;
    if (0 == cbElement) goto EmptyFile;
    if (NULL == (pbElement = (BYTE *) PkiNonzeroAlloc(cbElement)))
        goto OutOfMemory;
    if (!ReadFile(
            hFile,
            pbElement,
            cbElement,
            &cbBytesRead,
            NULL            // lpOverlapped
            )) goto FileError;

    fResult = TRUE;
CommonReturn:
    PkiFree(pwszFilename);
    if (INVALID_HANDLE_VALUE != hFile)
        CloseHandle(hFile);
    *ppbElement = pbElement;
    *pcbElement = cbElement;
    return fResult;
ErrorReturn:
    fResult = FALSE;
    PkiFree(pbElement);
    pbElement = NULL;
    cbElement = 0;
    goto CommonReturn;

TRACE_ERROR(GetKeyFilenameError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(CreateFileError)
TRACE_ERROR(FileError)
SET_ERROR(EmptyFile, CRYPT_E_FILE_ERROR)
#else
	ASSERT(!"ReadKeyFileElementFromRegistry called");
	return NULL;
#endif
}

//+-------------------------------------------------------------------------
//  Read as multiple SubKeys containing the element bytes. The SubKeys
//  are named Blob0, Blob1, Blob2, ... BlobN.
//  Each BlobN SubKey has a value named "Blob" containing the bytes to be read.
//
//  The passed in SubKey is expected to have 2 values:
//      BlobCount - # of BlobN SubKeys
//      BlobLength - total length of all the concatenated Blob Subkey bytes
//
//  A single allocated element byte array is returned.
//--------------------------------------------------------------------------
STATIC BOOL ReadMultipleKeyBlobsFromRegistry(
    IN HKEY hSubKey,
    OUT BYTE **ppbElement,
    OUT DWORD *pcbElement
    )
{
    BOOL fResult;
    LONG err;
    HKEY hBlobKey = NULL;
    BYTE *pbElement = NULL;
    DWORD cbElement;
    DWORD BlobCount;
    DWORD BlobLength;
    DWORD i;
    char szBlobN[KEY_BLOB_N_SUBKEY_PREFIX_LENGTH + 33];

    ILS_ReadDWORDValueFromRegistry(
            hSubKey,
            KEY_BLOB_COUNT_VALUE_NAME,
            &BlobCount
            );
    ILS_ReadDWORDValueFromRegistry(
            hSubKey,
            KEY_BLOB_LENGTH_VALUE_NAME,
            &BlobLength
            );

    if (0 == BlobCount || 0 == BlobLength)
        goto NoMultipleKeyBlobs;

    if (NULL == (pbElement = (BYTE *) PkiNonzeroAlloc(BlobLength)))
        goto OutOfMemory;

    cbElement = 0;
    strcpy(szBlobN, KEY_BLOB_N_SUBKEY_PREFIX);
    for (i = 0; i < BlobCount; i++) {
        DWORD cbData;
        DWORD dwType;

        _ltoa((long) i, szBlobN + KEY_BLOB_N_SUBKEY_PREFIX_LENGTH, 10);
        if (ERROR_SUCCESS != (err = RegOpenKeyExA(
                hSubKey,
                szBlobN,
                0,                  // dwReserved
                KEY_READ,
                &hBlobKey)))
            goto OpenBlobNError;

        cbData = BlobLength - cbElement;
        if (0 == cbData)
            goto ExtraMultipleKeyBlobs;

        if (ERROR_SUCCESS != (err = RegQueryValueExU(
                hBlobKey,
                KEY_BLOB_VALUE_NAME,
                NULL,       // pdwReserved
                &dwType,
                pbElement + cbElement,
                &cbData)))
            goto RegQueryValueError;
        if (dwType != REG_BINARY)
            goto InvalidRegistryValue;

        cbElement += cbData;
        if (cbElement > BlobLength)
            goto UnexpectedError;

        RegCloseKey(hBlobKey);
        hBlobKey = NULL;
    }

    if (cbElement != BlobLength)
        goto MissingMultipleKeyBlobsBytes;

    assert(NULL == hBlobKey);

    fResult = TRUE;
CommonReturn:
    *ppbElement = pbElement;
    *pcbElement = cbElement;
    return fResult;
ErrorReturn:
    PkiFree(pbElement);
    ILS_CloseRegistryKey(hBlobKey);
    fResult = FALSE;
    pbElement = NULL;
    cbElement = 0;
    goto CommonReturn;

SET_ERROR(NoMultipleKeyBlobs, ERROR_FILE_NOT_FOUND)
TRACE_ERROR(OutOfMemory)
SET_ERROR_VAR(OpenBlobNError, err)
SET_ERROR(UnexpectedError, E_UNEXPECTED)
SET_ERROR(InvalidRegistryValue, CRYPT_E_FILE_ERROR)
SET_ERROR(ExtraMultipleKeyBlobs, CRYPT_E_FILE_ERROR)
SET_ERROR_VAR(RegQueryValueError, err)
SET_ERROR(MissingMultipleKeyBlobsBytes, CRYPT_E_FILE_ERROR)
}

//+-------------------------------------------------------------------------
//  Write as multiple BlobN SubKeys containing the element bytes.
//
//  See ReadMultipleKeyBlobsFromRegistry() for details.
//--------------------------------------------------------------------------
STATIC BOOL WriteMultipleKeyBlobsToRegistry(
    IN HKEY hSubKey,
    IN const BYTE *pbElement,
    IN DWORD cbElement
    )
{
    BOOL fResult;
    LONG err;
    HKEY hBlobKey = NULL;
    DWORD BlobCount = 0;
    DWORD BlobLength;
    DWORD i;
    char szBlobN[KEY_BLOB_N_SUBKEY_PREFIX_LENGTH + 33];

    if (0 == cbElement)
        goto UnexpectedError;
    BlobCount = cbElement / MAX_KEY_BLOB_VALUE_LEN;
    if (cbElement % MAX_KEY_BLOB_VALUE_LEN)
        BlobCount++;

    BlobLength = 0;
    strcpy(szBlobN, KEY_BLOB_N_SUBKEY_PREFIX);
    for (i = 0; i < BlobCount; i++) {
        DWORD cbData;
        DWORD dwDisposition;

        _ltoa((long) i, szBlobN + KEY_BLOB_N_SUBKEY_PREFIX_LENGTH, 10);
        if (ERROR_SUCCESS != (err = RegCreateKeyExA(
                hSubKey,
                szBlobN,
                0,                      // dwReserved
                NULL,                   // lpClass
                REG_OPTION_NON_VOLATILE,
                KEY_WRITE,
                NULL,                   // lpSecurityAttributes
                &hBlobKey,
                &dwDisposition))) goto RegCreateKeyError;

        assert(cbElement > BlobLength);
        cbData = cbElement - BlobLength;
        if (cbData > MAX_KEY_BLOB_VALUE_LEN)
            cbData = MAX_KEY_BLOB_VALUE_LEN;

        if (ERROR_SUCCESS != (err = RegSetValueExU(
                hBlobKey,
                KEY_BLOB_VALUE_NAME,
                NULL,
                REG_BINARY,
                pbElement + BlobLength,
                cbData))) goto RegSetValueError;

        BlobLength += cbData;

        RegCloseKey(hBlobKey);
        hBlobKey = NULL;
    }

    assert(BlobLength == cbElement);

    if (!WriteDWORDValueToRegistry(
            hSubKey,
            KEY_BLOB_COUNT_VALUE_NAME,
            BlobCount))
        goto WriteDWORDError;
    if (!WriteDWORDValueToRegistry(
            hSubKey,
            KEY_BLOB_LENGTH_VALUE_NAME,
            BlobLength))
        goto WriteDWORDError;

    assert(NULL == hBlobKey);
    fResult = TRUE;

CommonReturn:
    return fResult;
ErrorReturn:
    ILS_CloseRegistryKey(hBlobKey);
    for (i = 0; i < BlobCount; i++) {
        _ltoa((long) i, szBlobN + KEY_BLOB_N_SUBKEY_PREFIX_LENGTH, 10);
        RegDeleteKeyA(hSubKey, szBlobN);
    }
    RegDeleteValueU(hSubKey, KEY_BLOB_COUNT_VALUE_NAME);
    RegDeleteValueU(hSubKey, KEY_BLOB_LENGTH_VALUE_NAME);
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(UnexpectedError, E_UNEXPECTED)
SET_ERROR_VAR(RegCreateKeyError, err)
SET_ERROR_VAR(RegSetValueError, err)
TRACE_ERROR(WriteDWORDError)
}

//+-------------------------------------------------------------------------
//  If the SubKey has a "File" value, delete the file.
//--------------------------------------------------------------------------
STATIC void DeleteKeyFile(
    IN HKEY hKey,
    IN const WCHAR wszSubKeyName[MAX_CERT_REG_VALUE_NAME_LEN]
    )
{
    HKEY hSubKey;

    if (ERROR_SUCCESS == RegOpenHKCUKeyExU(
            hKey,
            wszSubKeyName,
            0,
            KEY_ALL_ACCESS,
            &hSubKey)) {
        LPWSTR pwszFilename;
        if (pwszFilename = ReadSZValueFromRegistry(hSubKey,
                KEY_FILE_VALUE_NAME)) {
            SetFileAttributesU(pwszFilename, FILE_ATTRIBUTE_NORMAL);
            DeleteFileU(pwszFilename);
            PkiFree(pwszFilename);
        }
        RegDeleteValueU(hSubKey, KEY_FILE_VALUE_NAME);
        RegCloseKey(hSubKey);
    }
}

//+-------------------------------------------------------------------------
//  Get the context by either getting the SubKey's "Blob" value or getting
//  the SubKey's "BlobCount" and "BlobLength" values and then
//  reading and concatenating multiple Blob<N> SubKeys containing the bytes or
//  reading the file pointed to by the SubKey's "File" value.
//
//  If the "File" value is found and used, then, migrate to being stored
//  in the registry using multiple Blob<N> SubKeys.
//
//  If CERT_REGISTRY_STORE_REMOTE_FLAG is set, then, don't attempt to read
//  from the file.
//
//  If CERT_STORE_READONLY_FLAG is set, don't attempt to migrate from the
//  "File".
//--------------------------------------------------------------------------
STATIC BOOL ReadKeyElementFromRegistry(
        IN HKEY hKey,
        IN const WCHAR wszSubKeyName[MAX_CERT_REG_VALUE_NAME_LEN],
        IN DWORD dwFlags,
        OUT BYTE **ppbElement,
        OUT DWORD *pcbElement
        )
{
    LONG err;
    BOOL fResult;
    BYTE *pbElement = NULL;
    DWORD cbElement;
    HKEY hSubKey = NULL;

    if (ERROR_SUCCESS != (err = RegOpenHKCUKeyExU(
            hKey,
            wszSubKeyName,
            0,                      // dwReserved
            KEY_READ,
            &hSubKey)))
        goto RegOpenKeyError;

    fResult = ILS_ReadBINARYValueFromRegistry(hSubKey, KEY_BLOB_VALUE_NAME,
         &pbElement, &cbElement);
    if (!fResult || 0 == cbElement) {
        PkiFree(pbElement);

        fResult = ReadMultipleKeyBlobsFromRegistry(hSubKey, &pbElement,
            &cbElement);
        if (!fResult && 0 == (dwFlags & CERT_REGISTRY_STORE_REMOTE_FLAG)) {
            // For backwards compatibility with IE4.0. See if it exists
            // in a file
            fResult = ReadKeyFileElementFromRegistry(hSubKey, &pbElement,
                &cbElement);
            if (fResult && 0 == (dwFlags & CERT_STORE_READONLY_FLAG)) {
                // Move from the file back to the registry.
                if (WriteMultipleKeyBlobsToRegistry(hSubKey, pbElement,
                        cbElement))
                    DeleteKeyFile(hKey, wszSubKeyName);
            }
        }

        if (!fResult)
            goto ReadKeyElementError;
    }

    fResult = TRUE;
CommonReturn:
    ILS_CloseRegistryKey(hSubKey);
    *ppbElement = pbElement;
    *pcbElement = cbElement;

    return fResult;
ErrorReturn:
    fResult = FALSE;
    PkiFree(pbElement);
    pbElement = NULL;
    cbElement = 0;
    goto CommonReturn;

SET_ERROR_VAR(RegOpenKeyError, err)
TRACE_ERROR(ReadKeyElementError)
}

STATIC BOOL ReadKeyFromRegistry(
        IN HKEY hKey,
        IN const WCHAR wszSubKeyName[MAX_CERT_REG_VALUE_NAME_LEN],
        IN HCERTSTORE hCertStore,
        IN DWORD dwContextTypeFlags,
        IN DWORD dwFlags,
        OUT OPTIONAL const void **ppvContext
        )
{
    BOOL fResult;
    BYTE *pbElement = NULL;
    DWORD cbElement;

    if (!ReadKeyElementFromRegistry(
            hKey,
            wszSubKeyName,
            dwFlags,
            &pbElement,
            &cbElement
            ))
        goto ErrorReturn;

    if (!CertAddSerializedElementToStore(
            hCertStore,
            pbElement,
            cbElement,
            CERT_STORE_ADD_ALWAYS,
            0,                              // dwFlags
            dwContextTypeFlags,
            NULL,                           // pdwContextType
            ppvContext))
        goto AddSerializedElementError;

    fResult = TRUE;
CommonReturn:
    PkiFree(pbElement);

    return fResult;
ErrorReturn:
    fResult = FALSE;
    if (ppvContext)
        *ppvContext = NULL;
    goto CommonReturn;

TRACE_ERROR(AddSerializedElementError)
}


//+-------------------------------------------------------------------------
//  Get the Certificates, CRLs or CTLs from the registry by reading as
//  SubKeys and not Key values as done by OpenFromRegistry.
//
//  If CERT_STORE_DELETE_FLAG is set, delete the file, if stored there.
//
//  If CERT_REGISTRY_STORE_REMOTE_FLAG is set, then, don't attempt to read
//  from the file.
//
//  If CERT_STORE_READONLY_FLAG is set, don't attempt to migrate from the
//  "File".
//--------------------------------------------------------------------------
STATIC BOOL OpenKeysFromRegistry(
    IN HCERTSTORE hCertStore,
    IN HKEY hKey,
    IN DWORD dwFlags
    )
{
    BOOL fResult;
    LONG err;
    DWORD cSubKeys;
    DWORD i;

    // see how many SubKeys in the registry
    if (!GetSubKeyInfo(hKey, &cSubKeys))
        goto GetSubKeyInfoError;

    for (i = 0; i < cSubKeys; i++) {
        WCHAR wszSubKeyName[MAX_CERT_REG_VALUE_NAME_LEN];
        DWORD cchSubKeyName = MAX_CERT_REG_VALUE_NAME_LEN;
        err = RegEnumKeyExU(
            hKey,
            i,
            wszSubKeyName,
            &cchSubKeyName,
            NULL,               // lpdwReserved
            NULL,               // lpszClass
            NULL,               // lpcchClass
            NULL                // lpftLastWriteTime
            );
        if (ERROR_SUCCESS != err)
            continue;
        else if (dwFlags & CERT_STORE_DELETE_FLAG) {
            if (0 == (dwFlags & CERT_REGISTRY_STORE_REMOTE_FLAG))
                DeleteKeyFile(hKey, wszSubKeyName);
        } else
            // Ignore any read errors
            ReadKeyFromRegistry(
                hKey,
                wszSubKeyName,
                hCertStore,
                CERT_STORE_ALL_CONTEXT_FLAG,
                dwFlags,
                NULL                            // ppvContext
                );
    }
    fResult = TRUE;

CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetSubKeyInfoError)
}

#if 0
//
// The following was done in IE4.0 on Win95
//

//+-------------------------------------------------------------------------
//  Create the filename to contain the encoded element. The filename will
//  be something like:
//      C:\Windows\SystemCertificates\
//          00112233445566778899AABBCCDDEEFF00112233.0011223344556677
//  Where:
//      C:\Windows              - obtained via GetWindowsDirectory
//      SystemCertificates      - subdirectory containing all file elements
//      00112233445566778899AABBCCDDEEFF00112233
//                              - wszSubKeyName (ascii hex sha1)
//      0011223344556677        - ascii hex of current filetime
//
//
//  In addition to creating the filename, also creates the
//  "SystemCertificates" directory under C:\Windows.
//--------------------------------------------------------------------------
STATIC LPWSTR CreateKeyFilename(
    IN const WCHAR wszSubKeyName[MAX_CERT_REG_VALUE_NAME_LEN],
    IN LPFILETIME pft
    )
{
    LPWSTR pwszWindowsDir = NULL;
    DWORD cchWindowsDir;
    WCHAR rgwc[1];

    BYTE rgbft[sizeof(FILETIME)];
    WCHAR wszft[FILETIME_ASCII_HEX_LEN];

    LPWSTR pwszFilename = NULL;
    DWORD cchFilename;

    if (0 == (cchWindowsDir = GetWindowsDirectoryU(rgwc, 1)))
        goto GetWindowsDirError;
    cchWindowsDir++;    // bump to include null terminator
    if (NULL == (pwszWindowsDir = (LPWSTR) PkiNonzeroAlloc(
            cchWindowsDir * sizeof(WCHAR))))
        goto OutOfMemory;
    if (0 == GetWindowsDirectoryU(pwszWindowsDir, cchWindowsDir))
        goto GetWindowsDirError;

    // Convert filetime to ascii hex. First reverse the filetime bytes.
    memcpy(rgbft, pft, sizeof(rgbft));
    PkiAsn1ReverseBytes(rgbft, sizeof(rgbft));
    BytesToWStr(sizeof(rgbft), rgbft, wszft);

    // Get total length of filename and allocate
    cchFilename = cchWindowsDir + 1 +
        wcslen(SYSTEM_STORE_SUBDIR) + 1 +
        MAX_CERT_REG_VALUE_NAME_LEN + 1 +
        FILETIME_ASCII_HEX_LEN + 1;
    if (NULL == (pwszFilename = (LPWSTR) PkiNonzeroAlloc(
            cchFilename * sizeof(WCHAR))))
        goto OutOfMemory;

    // Create C:\Windows\SystemCertificates directory if it doesn't already
    // exist
    wcscpy(pwszFilename, pwszWindowsDir);
    cchWindowsDir = wcslen(pwszWindowsDir);
    if (cchWindowsDir && L'\\' != pwszWindowsDir[cchWindowsDir - 1])
        wcscat(pwszFilename, L"\\");
    wcscat(pwszFilename, SYSTEM_STORE_SUBDIR);
    if (0xFFFFFFFF == GetFileAttributesU(pwszFilename)) {
        if (!CreateDirectoryU(
            pwszFilename,
            NULL            // lpsa
            )) goto CreateDirError;
    }

    // Append \<AsciiHexSubKeyName>.<AsciiHexFileTime> to the above directory
    // name to complete the filename string
    wcscat(pwszFilename, L"\\");
    wcscat(pwszFilename, wszSubKeyName);
    wcscat(pwszFilename, L".");
    wcscat(pwszFilename, wszft);

CommonReturn:
    PkiFree(pwszWindowsDir);
    return pwszFilename;
ErrorReturn:
    PkiFree(pwszFilename);
    pwszFilename = NULL;
    goto CommonReturn;
TRACE_ERROR(GetWindowsDirError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(CreateDirError)
}

//+-------------------------------------------------------------------------
//  Write the bytes to a a file and update the SubKey's "File" value to
//  point to.
//
//  This code is here to show what was done in IE4.0.
//--------------------------------------------------------------------------
STATIC BOOL WriteKeyFileElementToRegistry(
    IN HKEY hSubKey,
    IN const WCHAR wszSubKeyName[MAX_CERT_REG_VALUE_NAME_LEN],
    IN BYTE *pbElement,
    IN DWORD cbElement
    )
{
    BOOL fResult;
    LONG err;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    LPWSTR pwszFilename = NULL;
    SYSTEMTIME st;
    FILETIME ft;
    DWORD i;

    GetSystemTime(&st);
    SystemTimeToFileTime(&st, &ft);

    for (i = 0; i < MAX_NEW_FILE_CREATE_ATTEMPTS; i++) {
        DWORD cbBytesWritten;

        if (NULL == (pwszFilename = CreateKeyFilename(wszSubKeyName, &ft)))
            goto CreateKeyFilenameError;

        if (INVALID_HANDLE_VALUE == (hFile = CreateFileU(
                  pwszFilename,
                  GENERIC_WRITE,
                  0,                        // fdwShareMode
                  NULL,                     // lpsa
                  CREATE_NEW,
                  FILE_ATTRIBUTE_NORMAL,
                  NULL                      // hTemplateFile
                  ))) {
            if (ERROR_FILE_EXISTS != GetLastError())
                goto CreateFileError;
            else {
                PkiFree(pwszFilename);
                pwszFilename = NULL;
                *((_int64 *) &ft) += 1;
                continue;
            }
        }

        if (!WriteFile(
                hFile,
                pbElement,
                cbElement,
                &cbBytesWritten,
                NULL            // lpOverlapped
                )) goto WriteFileError;

        CloseHandle(hFile);
        hFile = INVALID_HANDLE_VALUE;
        if (!SetFileAttributesU(pwszFilename,
                FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY ))
            goto SetFileAttributesError;

        if (ERROR_SUCCESS != (err = RegSetValueExU(
                hSubKey,
                KEY_FILE_VALUE_NAME,
                NULL,
                REG_SZ,
                (BYTE *) pwszFilename,
                (wcslen(pwszFilename) + 1) * sizeof(WCHAR))))
            goto RegSetValueError;
        else
            goto SuccessReturn;
    }

    goto ExceededMaxFileCreateAttemptsError;

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    if (INVALID_HANDLE_VALUE != hFile)
        CloseHandle(hFile);
    PkiFree(pwszFilename);

    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR_VAR(RegSetValueError, err)
TRACE_ERROR(CreateKeyFilenameError)
TRACE_ERROR(CreateFileError)
TRACE_ERROR(WriteFileError)
TRACE_ERROR(SetFileAttributesError)
SET_ERROR(ExceededMaxFileCreateAttemptsError, CRYPT_E_FILE_ERROR)

}

#endif  // end of IE4.0 "File" support

//+-------------------------------------------------------------------------
//  If the length of the element is <= MAX_KEY_BLOB_VALUE_LEN, then,
//  write it as the SubKey's "Blob" value. Otherwise, write it as multiple
//  SubKeys each containing a "Blob" value no larger than
//  MAX_KEY_BLOB_VALUE_LEN.
//--------------------------------------------------------------------------
STATIC BOOL WriteKeyToRegistry(
        IN HKEY hKey,
        IN const WCHAR wszSubKeyName[MAX_CERT_REG_VALUE_NAME_LEN],
        IN const BYTE *pbElement,
        IN DWORD cbElement
        )
{
    BOOL fResult;
    LONG err;
    HKEY hSubKey = NULL;
    DWORD dwDisposition;

    if (ERROR_SUCCESS != (err = RegCreateHKCUKeyExU(
            hKey,
            wszSubKeyName,
            NULL,
            NULL,
            0,
            KEY_ALL_ACCESS,
            NULL,
            &hSubKey,
            &dwDisposition))) goto RegCreateKeyError;

    if (MAX_KEY_BLOB_VALUE_LEN >= cbElement) {
        // Write as a single "Blob" value
        if (ERROR_SUCCESS != (err = RegSetValueExU(
                hSubKey,
                KEY_BLOB_VALUE_NAME,
                NULL,
                REG_BINARY,
                pbElement,
                cbElement))) goto RegSetValueError;
    } else {
        // Write as a multiple Blob<N> SubKeys
        if (!WriteMultipleKeyBlobsToRegistry(hSubKey, pbElement, cbElement))
            goto WriteMultipleKeyBlobsError;
//        if (!WriteKeyFileElementToRegistry(wszSubKeyName, hSubKey, pbElement, cbElement))
//            goto ErrorReturn;
    }

    fResult = TRUE;
CommonReturn:
    ILS_CloseRegistryKey(hSubKey);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR_VAR(RegCreateKeyError, err)
SET_ERROR_VAR(RegSetValueError, err)
TRACE_ERROR(WriteMultipleKeyBlobsError)
}

//+=========================================================================
//  Registry Functions
//==========================================================================

//+-------------------------------------------------------------------------
//  First attempt to read as Key's value. If that fails for Win95, then,
//  read as a value in one or more SubKeys or as a
//  file with a SubKey pointing to it.
//
//  If CERT_REGISTRY_STORE_REMOTE_FLAG is set, then, don't attempt to read
//  from the file.
//
//  If CERT_STORE_READONLY_FLAG is set, don't attempt to migrate from the
//  "File".
//--------------------------------------------------------------------------
BOOL
ILS_ReadElementFromRegistry(
    IN HKEY hKey,
    IN LPCWSTR pwszContextName,
    IN const WCHAR wszHashName[MAX_HASH_NAME_LEN],
    IN DWORD dwFlags,
    OUT BYTE **ppbElement,
    OUT DWORD *pcbElement
    )
{
    LONG err;
    BOOL fResult;
    HKEY hSubKey = NULL;
    DWORD dwType;
    BYTE *pbElement = NULL;
    DWORD cbElement;

    if (pwszContextName) {
        if (NULL == (hSubKey = OpenSubKey(
                hKey,
                pwszContextName,
                dwFlags | CERT_STORE_READONLY_FLAG
                )))
            goto OpenSubKeyError;
    } else
        hSubKey = hKey;

    err = RegQueryValueExU(
            hSubKey,
            wszHashName,
            NULL,       // pdwReserved
            &dwType,
            NULL,       // lpData
            &cbElement);
    // For Win95 Remote Registry Access:: returns ERROR_MORE_DATA
    if (!(ERROR_SUCCESS == err || ERROR_MORE_DATA == err)) {
        fResult = ReadKeyElementFromRegistry(
            hSubKey,
            wszHashName,
            dwFlags,
            &pbElement,
            &cbElement
            );
        goto CommonReturn;
    }
    if (dwType != REG_BINARY || cbElement == 0)
        goto InvalidRegistryValue;
    if (NULL == (pbElement = (BYTE *) PkiNonzeroAlloc(cbElement)))
        goto OutOfMemory;
    if (ERROR_SUCCESS != (err = RegQueryValueExU(
            hSubKey,
            wszHashName,
            NULL,       // pdwReserved
            &dwType,
            pbElement,
            &cbElement))) goto RegQueryValueError;

    fResult = TRUE;
CommonReturn:
    if (pwszContextName)
        ILS_CloseRegistryKey(hSubKey);
    *ppbElement = pbElement;
    *pcbElement = cbElement;
    return fResult;
ErrorReturn:
    fResult = FALSE;
    PkiFree(pbElement);
    pbElement = NULL;
    cbElement = 0;
    goto CommonReturn;

TRACE_ERROR(OpenSubKeyError)
SET_ERROR_VAR(RegQueryValueError, err)
SET_ERROR(InvalidRegistryValue, CRYPT_E_FILE_ERROR)
TRACE_ERROR(OutOfMemory)
}

//+-------------------------------------------------------------------------
//  First delete as the Key's value. Then, for Win95 also delete as the
//  Key's SubKey and possibly file.
//--------------------------------------------------------------------------
BOOL
ILS_DeleteElementFromRegistry(
    IN HKEY hKey,
    IN LPCWSTR pwszContextName,
    IN const WCHAR wszHashName[MAX_HASH_NAME_LEN],
    IN DWORD dwFlags
    )
{
    BOOL fResult;
    HKEY hSubKey = NULL;

    if (NULL == (hSubKey = OpenSubKey(
            hKey,
            pwszContextName,
            dwFlags | CERT_STORE_OPEN_EXISTING_FLAG
            )))
        goto OpenSubKeyError;

    RegDeleteValueU(hSubKey, wszHashName);
    if (0 == (dwFlags & CERT_REGISTRY_STORE_REMOTE_FLAG))
        DeleteKeyFile(hSubKey, wszHashName);
    fResult = RecursiveDeleteSubKey(hSubKey, wszHashName);

CommonReturn:
    ILS_CloseRegistryKey(hSubKey);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OpenSubKeyError)
}

//+-------------------------------------------------------------------------
//  If the length of the element is less than the maximum allowed Win95 value
//  length, then, attempt to set the wszRegName SubKey's "Blob" value as
//  a single registry API call. Versus, first doing registry deletes.
//--------------------------------------------------------------------------
STATIC BOOL AtomicUpdateRegistry(
        IN HKEY hKey,
        IN const WCHAR wszHashName[MAX_HASH_NAME_LEN],
        IN const BYTE *pbElement,
        IN DWORD cbElement
        )
{
    BOOL fResult;
    LONG err;
    HKEY hSubKey = NULL;

    if (MAX_KEY_BLOB_VALUE_LEN < cbElement)
        return FALSE;

    // In case the element still exists as a wszHashName value instead of as a
    // wszHashName subkey
    RegDeleteValueU(hKey, wszHashName);

    err = RegOpenHKCUKeyExU(
        hKey,
        wszHashName,
        0,                      // dwReserved
        KEY_ALL_ACCESS,
        &hSubKey);
    if (ERROR_SUCCESS == err) {
        DWORD dwType;
        DWORD cbData;

        assert(hSubKey);
        err = RegQueryValueExU(
            hSubKey,
            KEY_BLOB_VALUE_NAME,
            NULL,       // pdwReserved
            &dwType,
            NULL,       // lpData
            &cbData);
        if (!(ERROR_SUCCESS == err || ERROR_MORE_DATA == err))
            // Most likely persisted as partioned "Blob0", "Blob1" values.
            // These can't be updated in a single atomic set value.
            goto AtomicQueryValueError;

        // "Blob" value exists. We can do an atomic update.

    } else if (ERROR_FILE_NOT_FOUND == err) {
        DWORD dwDisposition;

        if (ERROR_SUCCESS != (err = RegCreateHKCUKeyExU(
                hKey,
                wszHashName,
                NULL,
                NULL,
                0,
                KEY_ALL_ACCESS,
                NULL,
                &hSubKey,
                &dwDisposition))) goto AtomicRegCreateKeyError;

        // SubKey doesn't exist. We can do an atomic update
    } else
        goto AtomicRegOpenKeyError;

    assert(hSubKey);
    // Either update or create the "Blob" value
    if (ERROR_SUCCESS != (err = RegSetValueExU(
            hSubKey,
            KEY_BLOB_VALUE_NAME,
            NULL,
            REG_BINARY,
            pbElement,
            cbElement))) goto AtomicRegSetValueError;
    fResult = TRUE;

CommonReturn:
    ILS_CloseRegistryKey(hSubKey);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR_VAR(AtomicRegOpenKeyError, err)
SET_ERROR_VAR(AtomicQueryValueError, err)
SET_ERROR_VAR(AtomicRegCreateKeyError, err)
SET_ERROR_VAR(AtomicRegSetValueError, err)
}

//+-------------------------------------------------------------------------
//  First attempt as an atomic registry update of the wszRegName's "Blob"
//  value. If that fails, then, delete everything and write as either a
//  single or partitioned blob value under the wszRegName's subkey.
//--------------------------------------------------------------------------
BOOL
ILS_WriteElementToRegistry(
    IN HKEY hKey,
    IN LPCWSTR pwszContextName,
    IN const WCHAR wszHashName[MAX_HASH_NAME_LEN],
    IN DWORD dwFlags,       //  CERT_REGISTRY_STORE_REMOTE_FLAG may be set
    IN const BYTE *pbElement,
    IN DWORD cbElement
    )
{
    BOOL fResult;
    HKEY hSubKey = NULL;

    if (NULL == (hSubKey = OpenSubKey(
            hKey,
            pwszContextName,
            dwFlags
            )))
        goto OpenSubKeyError;

    // See if we can do the update as a single, atomic, set registry value API
    // call.
    if (AtomicUpdateRegistry(
            hSubKey,
            wszHashName,
            pbElement,
            cbElement
            )) {
        fResult = TRUE;
        goto CommonReturn;
    }

    // If any version exists for this guy, get rid of it.
    ILS_DeleteElementFromRegistry(hKey, pwszContextName, wszHashName,
        dwFlags);

#if 1
    fResult = WriteKeyToRegistry(hSubKey, wszHashName, pbElement, cbElement);
#else
    LONG err;
    if (ERROR_SUCCESS != (err = RegSetValueExU(
            hSubKey,
            wszHashName,
            NULL,
            REG_BINARY,
            pbElement,
            cbElement))) {
        // Win95 returns:
        //  ERROR_INVALID_PARAMETER if exceeded single SubKey value byte
        //      limitation
        //  ERROR_OUTOFMEMORY if exceeded total SubKey values byte
        //      limitation
        if (ERROR_INVALID_PARAMETER == err ||
                ERROR_OUTOFMEMORY == err ||
                MAX_KEY_BLOB_VALUE_LEN < cbElement)
            return WriteKeyToRegistry(hSubKey, wszHashName, pbElement,
                cbElement);

         goto RegSetValueError;
    }
    fResult = TRUE;
#endif

CommonReturn:
    ILS_CloseRegistryKey(hSubKey);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OpenSubKeyError)
#if 1
#else
SET_ERROR_VAR(RegSetValueError, err)
#endif
}

BOOL
ILS_OpenAllElementsFromRegistry(
    IN HKEY hKey,
    IN LPCWSTR pwszContextName,
    IN DWORD dwFlags,
    IN void *pvArg,
    IN PFN_ILS_OPEN_ELEMENT pfnOpenElement
    )
{
    BOOL fResult;
    HKEY hSubKey = NULL;
    LONG err;
    DWORD cSubKeys;
    DWORD i;

    dwFlags |= CERT_STORE_READONLY_FLAG;

    if (NULL == (hSubKey = OpenSubKey(
            hKey,
            pwszContextName,
            dwFlags
            )))
        goto OpenSubKeyError;

    // see how many SubKeys in the registry
    if (!GetSubKeyInfo(hSubKey, &cSubKeys))
        goto GetSubKeyInfoError;

    for (i = 0; i < cSubKeys; i++) {
        WCHAR wszHashName[MAX_HASH_NAME_LEN];
        DWORD cchHashName = MAX_HASH_NAME_LEN;
        BYTE *pbElement;
        DWORD cbElement;

        err = RegEnumKeyExU(
            hSubKey,
            i,
            wszHashName,
            &cchHashName,
            NULL,               // lpdwReserved
            NULL,               // lpszClass
            NULL,               // lpcchClass
            NULL                // lpftLastWriteTime
            );
        if (ERROR_SUCCESS != err)
            continue;

        if (ILS_ReadElementFromRegistry(
                hSubKey,
                NULL,                   // pwszContextName
                wszHashName,
                0,                      // dwFlags
                &pbElement,
                &cbElement
                )) {
            fResult = pfnOpenElement(
                wszHashName,
                pbElement,
                cbElement,
                pvArg
                );

            PkiFree(pbElement);
            if (!fResult)
                goto CommonReturn;
        }
    }
    fResult = TRUE;

CommonReturn:
    ILS_CloseRegistryKey(hSubKey);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetSubKeyInfoError)
TRACE_ERROR(OpenSubKeyError)
}

//+-------------------------------------------------------------------------
//  Get the Certificates, CRLs or CTLs from the registry
//
//  If CERT_REGISTRY_STORE_REMOTE_FLAG is set, then, don't attempt to read
//  from the file.
//
//  If CERT_STORE_READONLY_FLAG is set, don't attempt to migrate from the
//  "File".
//
//  If any contexts are persisted as values instead of as subkeys, then,
//  if not READONLY, migrate from values to subkeys.
//--------------------------------------------------------------------------
STATIC BOOL OpenFromRegistry(
    IN HCERTSTORE hCertStore,
    IN HKEY hKeyT,
    IN DWORD dwFlags
    )
{
    BOOL    fOK = TRUE;
    LONG    err;
    DWORD   cValues, cchValuesNameMax, cbValuesMax;
    WCHAR * wszValueName = NULL;
    DWORD   i, dwType, cchHash;
    BYTE  * pbElement = NULL;
    DWORD   cbElement;

    // see how many and how big the registry is
    if (ERROR_SUCCESS != (err = RegQueryInfoKeyU(
            hKeyT,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            &cValues,
            &cchValuesNameMax,
            &cbValuesMax,
            NULL,
            NULL))) goto RegQueryInfoKeyError;


    if (cValues && cbValuesMax) {
        // allocate the memory needed to read the reg
        // Remote Registry calls on Win95 includes the NULL terminator, that's
        // why we add +2 and not just +1
        if (NULL == (wszValueName = (WCHAR *) PkiNonzeroAlloc(
                (cchValuesNameMax+2) * sizeof(WCHAR))))
            goto OutOfMemory;
        if (NULL == (pbElement = (BYTE *) PkiNonzeroAlloc(cbValuesMax)))
            goto OutOfMemory;

        // enum the registry getting certs, CRLs or CTLs
        for (i=0; i<cValues; i++ ) {
            cbElement = cbValuesMax;
            // Remote Registry calls on Win95 includes the NULL terminator
            cchHash = cchValuesNameMax + 2;
            err = RegEnumValueU( hKeyT,
                                i,
                                wszValueName,
                                &cchHash,
                                NULL,
                                &dwType,
                                pbElement,
                                &cbElement);
            // any error get it set
            // but we want to continue to get all good certs
            if( err != ERROR_SUCCESS )
                continue;
            else
                fOK &= CertAddSerializedElementToStore(
                    hCertStore,
                    pbElement,
                    cbElement,
                    CERT_STORE_ADD_ALWAYS,
                    0,                              // dwFlags
                    CERT_STORE_ALL_CONTEXT_FLAG,
                    NULL,                           // pdwContextType
                    NULL);                          // ppvContext
        }

    }

    fOK &= OpenKeysFromRegistry(hCertStore, hKeyT, dwFlags);

    if (cValues && cbValuesMax && fOK &&
            0 == (dwFlags & CERT_STORE_READONLY_FLAG)) {
        // Migrate from values to subkeys. This allows registry roaming
        // from NT to Win95 without exceeding the Win95 registry
        // limitations

        HKEY hSubKey = NULL;
        while (TRUE) {
            if (NULL == (hSubKey = OpenSubKey(
                    hKeyT,
                    NULL,       // pwszSubKey
                    CERT_STORE_OPEN_EXISTING_FLAG
                    )))
                break;

            cbElement = cbValuesMax;
            // Remote Registry calls on Win95 includes the NULL terminator
            cchHash = cchValuesNameMax + 2;
            if (ERROR_SUCCESS != RegEnumValueU(
                    hSubKey,
                    0,                  // iValue
                    wszValueName,
                    &cchHash,
                    NULL,
                    &dwType,
                    pbElement,
                    &cbElement))
                break;

            if (!WriteKeyToRegistry(hSubKey, wszValueName, pbElement,
                    cbElement))
                break;
            if (ERROR_SUCCESS != RegDeleteValueU(hSubKey, wszValueName))
                break;
            RegCloseKey(hSubKey);
        }

        if (hSubKey)
            RegCloseKey(hSubKey);
    }

CommonReturn:
    // done with our memory
    PkiFree(wszValueName);
    PkiFree(pbElement);

    return fOK;
ErrorReturn:
    fOK = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(RegQueryInfoKeyError, err)
TRACE_ERROR(OutOfMemory)
}


STATIC BOOL MoveFromRegistryToRoamingFiles(
    IN HKEY hSubKey,
    IN LPCWSTR pwszStoreDirectory,
    IN LPCWSTR pwszContextName
    )
{
    BYTE *pbElement = NULL;
    DWORD cbElement;

    while (TRUE) {
        WCHAR wszSubKeyName[MAX_CERT_REG_VALUE_NAME_LEN];
        DWORD cchSubKeyName = MAX_CERT_REG_VALUE_NAME_LEN;

        if (ERROR_SUCCESS != RegEnumKeyExU(
                hSubKey,
                0,
                wszSubKeyName,
                &cchSubKeyName,
                NULL,               // lpdwReserved
                NULL,               // lpszClass
                NULL,               // lpcchClass
                NULL                // lpftLastWriteTime
                ))
            break;

        if (!ILS_ReadElementFromRegistry(
                hSubKey,
                NULL,               // pwszContextName
                wszSubKeyName,
                CERT_STORE_READONLY_FLAG,
                &pbElement,
                &cbElement
                ))
            goto ReadElementFromRegistryError;

        if (!ILS_WriteElementToFile(
                pwszStoreDirectory,
                pwszContextName,
                wszSubKeyName,
                CERT_STORE_CREATE_NEW_FLAG,
                pbElement,
                cbElement
                )) {
            if (ERROR_FILE_EXISTS != GetLastError())
                goto WriteElementToFileError;
        }

        PkiFree(pbElement);
        pbElement = NULL;

        if (!RecursiveDeleteSubKey(
                hSubKey,
                wszSubKeyName
                ))
            goto DeleteSubKeyError;
    }

CommonReturn:
    return TRUE;
ErrorReturn:
    PkiFree(pbElement);
    goto CommonReturn;

TRACE_ERROR(ReadElementFromRegistryError)
TRACE_ERROR(WriteElementToFileError)
TRACE_ERROR(DeleteSubKeyError)
}


typedef struct _READ_CONTEXT_CALLBACK_ARG {
    BOOL                        fOK;
    HCERTSTORE                  hCertStore;
} READ_CONTEXT_CALLBACK_ARG, *PREAD_CONTEXT_CALLBACK_ARG;

STATIC BOOL ReadContextCallback(
    IN const WCHAR wszHashName[MAX_HASH_NAME_LEN],
    IN const BYTE *pbElement,
    IN DWORD cbElement,
    IN void *pvArg
    )
{
    PREAD_CONTEXT_CALLBACK_ARG pReadContextArg =
        (PREAD_CONTEXT_CALLBACK_ARG) pvArg;

    pReadContextArg->fOK &= CertAddSerializedElementToStore(
            pReadContextArg->hCertStore,
            pbElement,
            cbElement,
            CERT_STORE_ADD_ALWAYS,
            0,                              // dwFlags
            CERT_STORE_ALL_CONTEXT_FLAG,
            NULL,                           // pdwContextType
            NULL                            // ppvContext
            );

    return TRUE;
}

//+-------------------------------------------------------------------------
//  Get all the Certificates, CRLs and CTLs from the registry
//--------------------------------------------------------------------------
STATIC BOOL OpenAllFromRegistry(
    IN PREG_STORE pRegStore,
    IN HCERTSTORE hCertStore
    )
{
    BOOL fResult;
    HKEY hSubKey = NULL;
    DWORD i;

    for (i = 0; i < CONTEXT_COUNT; i++) {
        if (pRegStore->hKey) {
            if (NULL == (hSubKey = OpenSubKey(
                    pRegStore->hKey,
                    rgpwszContextSubKeyName[i],
                    pRegStore->dwFlags
                    ))) {
                if (ERROR_FILE_NOT_FOUND != GetLastError())
                    goto OpenSubKeyError;
            } else {
                // Ignore any registry errors
                OpenFromRegistry(hCertStore, hSubKey, pRegStore->dwFlags);
            }
        }

        if (pRegStore->dwFlags & CERT_REGISTRY_STORE_ROAMING_FLAG) {
            READ_CONTEXT_CALLBACK_ARG ReadContextArg;

            ReadContextArg.fOK = TRUE;
            ReadContextArg.hCertStore = hCertStore;

            if (!ILS_OpenAllElementsFromDirectory(
                    pRegStore->pwszStoreDirectory,
                    rgpwszContextSubKeyName[i],
                    pRegStore->dwFlags,
                    (void *) &ReadContextArg,
                    ReadContextCallback
                    )) {
                DWORD dwErr = GetLastError();
                if (!(ERROR_PATH_NOT_FOUND == dwErr ||
                        ERROR_FILE_NOT_FOUND == dwErr))
                    goto OpenRoamingFilesError;
            }
            // Ignore any read context errors

            if (hSubKey &&
                    0 == (pRegStore->dwFlags & CERT_STORE_READONLY_FLAG)) {
                MoveFromRegistryToRoamingFiles(
                    hSubKey,
                    pRegStore->pwszStoreDirectory,
                    rgpwszContextSubKeyName[i]
                    );
            }
        }

        if (hSubKey) {
            ILS_CloseRegistryKey(hSubKey);
            hSubKey = NULL;
        }
    }

    if ((pRegStore->dwFlags & CERT_REGISTRY_STORE_ROAMING_FLAG) &&
            pRegStore->hKey &&
            0 == (pRegStore->dwFlags & CERT_STORE_READONLY_FLAG)) {
        // Move the Key Identifiers from the registry to roaming files
        if (hSubKey = OpenSubKey(
                pRegStore->hKey,
                KEYID_CONTEXT_NAME,
                pRegStore->dwFlags
                )) {
            MoveFromRegistryToRoamingFiles(
                hSubKey,
                pRegStore->pwszStoreDirectory,
                KEYID_CONTEXT_NAME
                );

            ILS_CloseRegistryKey(hSubKey);
            hSubKey = NULL;
        }
    }

    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    ILS_CloseRegistryKey(hSubKey);
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OpenSubKeyError)
TRACE_ERROR(OpenRoamingFilesError)
}

//+-------------------------------------------------------------------------
//  Delete all the Certificates, CRLs and CTLs context subkeys. For Win95
//  also delete context files.
//
//  Also, if it exists, delete the "Serialized" subkey.
//--------------------------------------------------------------------------
STATIC BOOL DeleteAllFromRegistry(
    IN HKEY hKey,
    IN DWORD dwFlags        //  CERT_REGISTRY_STORE_REMOTE_FLAG may be set
    )
{
    BOOL fResult;
    DWORD i;

    for (i = 0; i < CONTEXT_COUNT; i++) {
        LPCWSTR pwszSubKeyName = rgpwszContextSubKeyName[i];
        if (0 == (dwFlags & CERT_REGISTRY_STORE_REMOTE_FLAG)) {
            // For WIN95, if a context is stored in a file, delete the
            // file
            HKEY hSubKey;
            if (NULL == (hSubKey = OpenSubKey(
                    hKey,
                    pwszSubKeyName,
                    CERT_STORE_OPEN_EXISTING_FLAG
                    ))) {
                if (ERROR_FILE_NOT_FOUND != GetLastError())
                    goto OpenContextSubKeyError;
                continue;
            }
            fResult = OpenKeysFromRegistry(
                NULL,       // hCertStore
                hSubKey,
                dwFlags
                );
            ILS_CloseRegistryKey(hSubKey);
            if (!fResult)
                goto DeleteKeysError;
        }

        if (!RecursiveDeleteSubKey(hKey, pwszSubKeyName)) {
            if (ERROR_FILE_NOT_FOUND != GetLastError()
            	&& ERROR_INVALID_PARAMETER != GetLastError())	// for CE
                goto DeleteSubKeyError;
        }
    }

    if (!RecursiveDeleteSubKey(hKey, SERIALIZED_SUBKEY_NAME)) {
        if (ERROR_FILE_NOT_FOUND != GetLastError() 
        	&& ERROR_INVALID_PARAMETER != GetLastError())	// for CE
            goto DeleteSubKeyError;
    }


    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OpenContextSubKeyError)
TRACE_ERROR(DeleteKeysError)
TRACE_ERROR(DeleteSubKeyError)
}



//+=========================================================================
//  Serialized Registry Functions
//==========================================================================

static inline BOOL IsReadSerializedRegistry(
    IN PREG_STORE pRegStore
    )
{
    return (pRegStore->dwFlags & CERT_REGISTRY_STORE_SERIALIZED_FLAG);
}

static inline BOOL IsWriteSerializedRegistry(
    IN PREG_STORE pRegStore
    )
{
    if (0 == (pRegStore->dwFlags & CERT_REGISTRY_STORE_SERIALIZED_FLAG))
        return FALSE;

    pRegStore->fTouched = TRUE;
    return TRUE;
}

#ifdef CAPI_INCLUDE_SERIALIZED_STORE
//+-------------------------------------------------------------------------
//  Get all the Certificates, CRLs and CTLs from a single serialized
//  partitioned "blob" stored in the registry. The "blob" is stored under
//  the "Serialized" subkey.
//
//  Either called during initial open or with RegStore locked.
//--------------------------------------------------------------------------
STATIC BOOL OpenAllFromSerializedRegistry(
    IN PREG_STORE pRegStore,
    IN HCERTSTORE hCertStore
    )
{
    BOOL fResult;
    HKEY hSubKey = NULL;
    BYTE *pbStore = NULL;
    DWORD cbStore;

    assert(pRegStore->dwFlags & CERT_REGISTRY_STORE_SERIALIZED_FLAG);

    if (NULL == (hSubKey = OpenSubKey(
            pRegStore->hKey,
            SERIALIZED_SUBKEY_NAME,
            pRegStore->dwFlags
            )))
        goto OpenSubKeyError;

    if (!ReadMultipleKeyBlobsFromRegistry(
            hSubKey,
            &pbStore,
            &cbStore
            ))
        goto ReadError;

    if (!I_CertAddSerializedStore(
            hCertStore,
            pbStore,
            cbStore
            ))
        goto AddError;

    fResult = TRUE;
CommonReturn:
    ILS_CloseRegistryKey(hSubKey);
    PkiFree(pbStore);
    return fResult;
ErrorReturn:
    if (ERROR_FILE_NOT_FOUND == GetLastError())
        fResult = TRUE;
    else
        fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OpenSubKeyError)
TRACE_ERROR(ReadError)
TRACE_ERROR(AddError)
}
#else
#define OpenAllFromSerializedRegistry(pRegStore,hCertStore) (FALSE)
#endif


//+=========================================================================
//  Serialized Control Functions
//==========================================================================

STATIC BOOL IsEmptyStore(
    IN HCERTSTORE hCertStore
    )
{
    PCCERT_CONTEXT pCert;

    if (pCert = CertEnumCertificatesInStore(hCertStore, NULL)) {
        CertFreeCertificateContext(pCert);
        return FALSE;
    }

#ifdef CAPI_INCLUDE_CRL
    PCCRL_CONTEXT pCrl;
    if (pCrl = CertEnumCRLsInStore(hCertStore, NULL)) {
        CertFreeCRLContext(pCrl);
        return FALSE;
    }
#endif

#ifdef CAPI_INCLUDE_CTL
    PCCTL_CONTEXT pCtl;
    if (pCtl = CertEnumCTLsInStore(hCertStore, NULL)) {
        CertFreeCTLContext(pCtl);
        return FALSE;
    }
#endif

    return TRUE;

}

STATIC BOOL CommitAllToSerializedRegistry(
    IN PREG_STORE pRegStore,
    IN DWORD dwFlags
    )
{
    BOOL fResult;
    BOOL fTouched;
    CRYPT_DATA_BLOB SerializedData = {0, NULL};
    HKEY hSubKey = NULL;

    LockRegStore(pRegStore);

    assert(pRegStore->dwFlags & CERT_REGISTRY_STORE_SERIALIZED_FLAG);

    if (dwFlags & CERT_STORE_CTRL_COMMIT_FORCE_FLAG)
        fTouched = TRUE;
    else if (dwFlags & CERT_STORE_CTRL_COMMIT_CLEAR_FLAG)
        fTouched = FALSE;
    else
        fTouched = pRegStore->fTouched;

    if (fTouched) {
        BOOL fEmpty;

        if (pRegStore->dwFlags & CERT_STORE_READONLY_FLAG)
            goto AccessDenied;

        fEmpty = IsEmptyStore(pRegStore->hCertStore);
        if (!fEmpty) {
            if (!CertSaveStore(
                    pRegStore->hCertStore,
                    0,                      // dwEncodingType
                    CERT_STORE_SAVE_AS_STORE,
                    CERT_STORE_SAVE_TO_MEMORY,
                    &SerializedData,
                    0))                     // dwFlags
                goto SaveStoreError;
            assert(SerializedData.cbData);
            if (NULL == (SerializedData.pbData = (BYTE *) PkiNonzeroAlloc(
                    SerializedData.cbData)))
                goto OutOfMemory;
            if (!CertSaveStore(
                    pRegStore->hCertStore,
                    0,                      // dwEncodingType
                    CERT_STORE_SAVE_AS_STORE,
                    CERT_STORE_SAVE_TO_MEMORY,
                    &SerializedData,
                    0))                     // dwFlags
                goto SaveStoreError;
        }

        if (!RecursiveDeleteSubKey(pRegStore->hKey, SERIALIZED_SUBKEY_NAME)) {
            if (ERROR_FILE_NOT_FOUND != GetLastError())
                goto DeleteSubKeyError;
        }

        if (!fEmpty) {
            if (NULL == (hSubKey = OpenSubKey(
                    pRegStore->hKey,
                    SERIALIZED_SUBKEY_NAME,
                    pRegStore->dwFlags
                    )))
                goto OpenSubKeyError;

            if (!WriteMultipleKeyBlobsToRegistry(
                    hSubKey,
                    SerializedData.pbData,
                    SerializedData.cbData
                    ))
                goto WriteStoreError;
        }
    }
    pRegStore->fTouched = FALSE;
    fResult = TRUE;

CommonReturn:
    ILS_CloseRegistryKey(hSubKey);
    PkiFree(SerializedData.pbData);
    UnlockRegStore(pRegStore);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(AccessDenied, E_ACCESSDENIED)
TRACE_ERROR(SaveStoreError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(DeleteSubKeyError)
TRACE_ERROR(OpenSubKeyError)
TRACE_ERROR(WriteStoreError)
}


//+-------------------------------------------------------------------------
//  Open the registry's store by reading its serialized certificates,
//  CRLs and CTLs and adding to the specified certificate store.
//
//  Note for an error return, the caller will free any certs, CRLs or CTLs
//  successfully added to the store.
//
//  Only return HKEY for success. For a CertOpenStore error the caller
//  will close the HKEY.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertDllOpenRegStoreProv(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
    BOOL fResult;
    HKEY hKey = (HKEY) pvPara;
    PREG_STORE pRegStore = NULL;

    assert(hKey);

    if (dwFlags & ~OPEN_REG_FLAGS_MASK)
        goto InvalidArg;

    if (dwFlags & CERT_STORE_DELETE_FLAG) {
        if (DeleteAllFromRegistry(hKey, dwFlags)) {
            pStoreProvInfo->dwStoreProvFlags |= CERT_STORE_PROV_DELETED_FLAG;
            return TRUE;
        } else
            return FALSE;
    }


    if (NULL == (pRegStore = (PREG_STORE) PkiZeroAlloc(sizeof(REG_STORE))))
        goto OutOfMemory;
    InitializeCriticalSection(&pRegStore->CriticalSection);
    pRegStore->hCertStore = hCertStore;
    pRegStore->dwFlags = dwFlags;

#ifndef CE_BUILD
    if (dwFlags & CERT_REGISTRY_STORE_CLIENT_GPT_FLAG) {
        PCERT_REGISTRY_STORE_CLIENT_GPT_PARA pGptPara =
            (PCERT_REGISTRY_STORE_CLIENT_GPT_PARA) pvPara;
        DWORD cbRegPath = (wcslen(pGptPara->pwszRegPath) + 1) * sizeof(WCHAR);

        if (NULL == (pRegStore->GptPara.pwszRegPath =
                (LPWSTR) PkiNonzeroAlloc(cbRegPath)))
            goto OutOfMemory;
        memcpy(pRegStore->GptPara.pwszRegPath, pGptPara->pwszRegPath,
            cbRegPath);

        // Make a copy of the base hKey
        // BUG in NT4.0 and NT5.0. Doesn't support opening of the HKLM with
        // a NULL pwszSubKey
        if (HKEY_LOCAL_MACHINE == pGptPara->hKeyBase)
            pRegStore->GptPara.hKeyBase = HKEY_LOCAL_MACHINE;
        else if (NULL == (pRegStore->GptPara.hKeyBase = OpenSubKey(
                pGptPara->hKeyBase,
                NULL,       // pwszSubKey
                (dwFlags & ~CERT_STORE_CREATE_NEW_FLAG) |
                    CERT_STORE_OPEN_EXISTING_FLAG
                )))
            goto OpenSubKeyError;

        fResult = OpenAllFromGptRegistry(pRegStore,
            pRegStore->hCertStore);

#if 1
        // For subsequent opens, allow subkey create if it doesn't already
        // exist.
        pRegStore->dwFlags &= ~(CERT_STORE_OPEN_EXISTING_FLAG |
            CERT_STORE_CREATE_NEW_FLAG);
#else

        // For subsequent opens, allow subkey create if it doesn't already
        // exist. However, preserve open existing.
        pRegStore->dwFlags &= ~CERT_STORE_CREATE_NEW_FLAG;
#endif

    }    
    else
#endif // CE_BUILD    
    if (dwFlags & CERT_REGISTRY_STORE_ROAMING_FLAG) {
        PCERT_REGISTRY_STORE_ROAMING_PARA pRoamingPara =
            (PCERT_REGISTRY_STORE_ROAMING_PARA) pvPara;
        DWORD cbDir = (wcslen(pRoamingPara->pwszStoreDirectory) + 1) *
            sizeof(WCHAR);

        if (NULL == (pRegStore->pwszStoreDirectory = (LPWSTR) PkiNonzeroAlloc(
                cbDir)))
            goto OutOfMemory;
        memcpy(pRegStore->pwszStoreDirectory, pRoamingPara->pwszStoreDirectory,
            cbDir);

        dwFlags &= ~CERT_STORE_CREATE_NEW_FLAG;
        dwFlags |= CERT_STORE_OPEN_EXISTING_FLAG;
        pRegStore->dwFlags = dwFlags;
        if (pRoamingPara->hKey) {
            // Make a copy of the input hKey
            if (NULL == (pRegStore->hKey = OpenSubKey(
                    pRoamingPara->hKey,
                    NULL,       // pwszSubKey
                    dwFlags
                    )))
                goto OpenSubKeyError;
        }

        fResult = OpenAllFromRegistry(pRegStore, pRegStore->hCertStore);
    } else {
        // Make a copy of the input hKey
        if (NULL == (pRegStore->hKey = OpenSubKey(
                hKey,
                NULL,       // pwszSubKey
                (dwFlags & ~CERT_STORE_CREATE_NEW_FLAG) |
                    CERT_STORE_OPEN_EXISTING_FLAG
                )))
            goto OpenSubKeyError;

        if (dwFlags & CERT_REGISTRY_STORE_SERIALIZED_FLAG)
            fResult = OpenAllFromSerializedRegistry(pRegStore,
                pRegStore->hCertStore);
        else
            fResult = OpenAllFromRegistry(pRegStore, pRegStore->hCertStore);

        // For subsequent opens, allow subkey create if it doesn't already
        // exist.
        pRegStore->dwFlags &= ~(CERT_STORE_OPEN_EXISTING_FLAG |
            CERT_STORE_CREATE_NEW_FLAG);
    }
    if (!fResult)
        goto OpenAllError;


    pStoreProvInfo->cStoreProvFunc = REG_STORE_PROV_FUNC_COUNT;
    pStoreProvInfo->rgpvStoreProvFunc = (void **) rgpvRegStoreProvFunc;
    pStoreProvInfo->hStoreProv = (HCERTSTOREPROV) pRegStore;
    fResult = TRUE;

CommonReturn:
    return fResult;

ErrorReturn:
    RegStoreProvClose((HCERTSTOREPROV) pRegStore, 0);
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(OpenSubKeyError)
TRACE_ERROR(OpenAllError)
}


//+-------------------------------------------------------------------------
//  Close the registry's store by closing its opened registry subkeys
//--------------------------------------------------------------------------
STATIC void WINAPI RegStoreProvClose(
        IN HCERTSTOREPROV hStoreProv,
        IN DWORD dwFlags
        )
{
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;
    if (pRegStore) {
        if (pRegStore->hMyNotifyChange)
            CloseHandle(pRegStore->hMyNotifyChange);
#ifndef CE_BUILD
        FreeRegistryStoreChange(pRegStore);

        if (hWin95NotifyEvent)
            Win95StoreSignalAndFreeRegStoreResyncEntries(pRegStore);

        if (pRegStore->dwFlags & CERT_REGISTRY_STORE_CLIENT_GPT_FLAG) {
            if (pRegStore->fTouched)
                CommitAllToGptRegistry(
                    pRegStore,
                    0               // dwFlags
                    );
            GptStoreSignalAndFreeRegStoreResyncEntries(pRegStore);
            PkiFree(pRegStore->GptPara.pwszRegPath);
            // BUG in NT4.0 and NT5.0. Doesn't support opening of the HKLM with
            // a NULL pwszSubKey
            if (pRegStore->GptPara.hKeyBase &&
                    HKEY_LOCAL_MACHINE != pRegStore->GptPara.hKeyBase)
                RegCloseKey(pRegStore->GptPara.hKeyBase);
        } else 
#endif        
        if (pRegStore->dwFlags & CERT_REGISTRY_STORE_ROAMING_FLAG) {
            PkiFree(pRegStore->pwszStoreDirectory);
        } else if (pRegStore->dwFlags & CERT_REGISTRY_STORE_SERIALIZED_FLAG) {
            if (pRegStore->fTouched)
                CommitAllToSerializedRegistry(
                    pRegStore,
                    0               // dwFlags
                    );
        }

        if (pRegStore->hKey)
            RegCloseKey(pRegStore->hKey);
        DeleteCriticalSection(&pRegStore->CriticalSection);
        PkiFree(pRegStore);
    }
}

//+-------------------------------------------------------------------------
//  Get the certificate's registry value name by formatting its SHA1 hash as
//  UNICODE hex.
//--------------------------------------------------------------------------
STATIC BOOL GetCertRegValueName(
        IN PCCERT_CONTEXT pCertContext,
        OUT WCHAR wszRegName[MAX_CERT_REG_VALUE_NAME_LEN]
        )
{
    BYTE    rgbHash[MAX_HASH_LEN];
    DWORD   cbHash = MAX_HASH_LEN;

    // get the thumbprint
    if(!CertGetCertificateContextProperty(
            pCertContext,
            CERT_SHA1_HASH_PROP_ID,
            rgbHash,
            &cbHash))
        return FALSE;

    // convert to a string
    BytesToWStr(cbHash, rgbHash, wszRegName);
    return TRUE;
}

#ifdef CAPI_INCLUDE_CRL
//+-------------------------------------------------------------------------
//  Get the CRL's registry value name by formatting its SHA1 hash as
//  UNICODE hex.
//--------------------------------------------------------------------------
STATIC BOOL GetCrlRegValueName(
        IN PCCRL_CONTEXT pCrlContext,
        OUT WCHAR wszRegName[MAX_CERT_REG_VALUE_NAME_LEN]
        )
{
    BYTE    rgbHash[MAX_HASH_LEN];
    DWORD   cbHash = MAX_HASH_LEN;

    // get the thumbprint
    if(!CertGetCRLContextProperty(
            pCrlContext,
            CERT_SHA1_HASH_PROP_ID,
            rgbHash,
            &cbHash))
        return FALSE;

    // convert to a string
    BytesToWStr(cbHash, rgbHash, wszRegName);
    return TRUE;
}
#endif

#ifdef CAPI_INCLUDE_CTL
//+-------------------------------------------------------------------------
//  Get the CTL's registry value name by formatting its SHA1 hash as
//  UNICODE hex.
//--------------------------------------------------------------------------
STATIC BOOL GetCtlRegValueName(
        IN PCCTL_CONTEXT pCtlContext,
        OUT WCHAR wszRegName[MAX_CERT_REG_VALUE_NAME_LEN]
        )
{
    BYTE    rgbHash[MAX_HASH_LEN];
    DWORD   cbHash = MAX_HASH_LEN;

    // get the thumbprint
    if(!CertGetCTLContextProperty(
            pCtlContext,
            CERT_SHA1_HASH_PROP_ID,
            rgbHash,
            &cbHash))
        return FALSE;

    // convert to a string
    BytesToWStr(cbHash, rgbHash, wszRegName);
    return TRUE;
}
#endif

//+-------------------------------------------------------------------------
//  Read the serialized copy of the context from either the registry or
//  a roaming file and create a new context.
//--------------------------------------------------------------------------
STATIC BOOL ReadContext(
    IN PREG_STORE pRegStore,
    IN DWORD dwContextType,
    IN const WCHAR wszSubKeyName[MAX_CERT_REG_VALUE_NAME_LEN],
    OUT const void **ppvContext
    )
{
    BOOL fResult;
    BYTE *pbElement = NULL;
    DWORD cbElement;

	assert(dwContextType < CONTEXT_COUNT);
    if (pRegStore->dwFlags & CERT_REGISTRY_STORE_ROAMING_FLAG) {
        if (!ILS_ReadElementFromFile(
                pRegStore->pwszStoreDirectory,
                rgpwszContextSubKeyName[dwContextType],
                wszSubKeyName,
                pRegStore->dwFlags,
                &pbElement,
                &cbElement
                ))
            goto ReadElementFromFileError;
    } else {
        if (pRegStore->dwFlags & CERT_REGISTRY_STORE_CLIENT_GPT_FLAG) {
            assert(NULL == pRegStore->hKey);
            if (NULL == (pRegStore->hKey = OpenSubKey(
                    pRegStore->GptPara.hKeyBase,
                    pRegStore->GptPara.pwszRegPath,
                    pRegStore->dwFlags
                    )))
                goto OpenSubKeyError;
        }

        fResult = ILS_ReadElementFromRegistry(
                pRegStore->hKey,
                rgpwszContextSubKeyName[dwContextType],
                wszSubKeyName,
                pRegStore->dwFlags,
                &pbElement,
                &cbElement
                );

        if (pRegStore->dwFlags & CERT_REGISTRY_STORE_CLIENT_GPT_FLAG) {
            ILS_CloseRegistryKey(pRegStore->hKey);
            pRegStore->hKey = NULL;
        }

        if (!fResult)
            goto ReadElementFromRegistryError;
    }

    if (!CertAddSerializedElementToStore(
            NULL,                           // hCertStore,
            pbElement,
            cbElement,
            CERT_STORE_ADD_ALWAYS,
            0,                              // dwFlags
            rgdwContextTypeFlags[dwContextType],
            NULL,                           // pdwContextType
            ppvContext))
        goto AddSerializedElementError;

    fResult = TRUE;
CommonReturn:
    PkiFree(pbElement);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    *ppvContext = NULL;
    goto CommonReturn;

TRACE_ERROR(ReadElementFromFileError)
TRACE_ERROR(ReadElementFromRegistryError)
TRACE_ERROR(AddSerializedElementError)
TRACE_ERROR(OpenSubKeyError)
}

//+-------------------------------------------------------------------------
//  Write the serialized context and its properties to
//  the registry or a roaming file.
//
//  Called before the context is written to the store.
//--------------------------------------------------------------------------
STATIC BOOL WriteSerializedContext(
    IN PREG_STORE pRegStore,
    IN DWORD dwContextType,
    IN const WCHAR wszSubKeyName[MAX_CERT_REG_VALUE_NAME_LEN],
    IN const BYTE *pbElement,
    IN DWORD cbElement
    )
{
    BOOL fResult;

	assert(dwContextType < CONTEXT_COUNT);
    if (pRegStore->dwFlags & CERT_REGISTRY_STORE_ROAMING_FLAG)
        fResult = ILS_WriteElementToFile(
                pRegStore->pwszStoreDirectory,
                rgpwszContextSubKeyName[dwContextType],
                wszSubKeyName,
                pRegStore->dwFlags,
                pbElement,
                cbElement
                );
    else {
        if (pRegStore->dwFlags & CERT_REGISTRY_STORE_CLIENT_GPT_FLAG) {
            assert(NULL == pRegStore->hKey);
            if (NULL == (pRegStore->hKey = OpenSubKey(
                    pRegStore->GptPara.hKeyBase,
                    pRegStore->GptPara.pwszRegPath,
                    pRegStore->dwFlags
                    )))
                return FALSE;
        }

        fResult = ILS_WriteElementToRegistry(
                pRegStore->hKey,
                rgpwszContextSubKeyName[dwContextType],
                wszSubKeyName,
                pRegStore->dwFlags,
                pbElement,
                cbElement
                );
        if (pRegStore->dwFlags & CERT_REGISTRY_STORE_CLIENT_GPT_FLAG) {
            ILS_CloseRegistryKey(pRegStore->hKey);
            pRegStore->hKey = NULL;
        }

        if (hWin95NotifyEvent && fResult)
            PulseEvent(hWin95NotifyEvent);
    }
    return fResult;
}

//+-------------------------------------------------------------------------
//  Delete the context and its properties from the
//  the registry or a roaming file.
//
//  Called before the context is deleted from the store.
//--------------------------------------------------------------------------
STATIC BOOL DeleteContext(
    IN PREG_STORE pRegStore,
    IN DWORD dwContextType,
    IN const WCHAR wszSubKeyName[MAX_CERT_REG_VALUE_NAME_LEN]
    )
{
    BOOL fResult;

	assert(dwContextType < CONTEXT_COUNT);
    if (pRegStore->dwFlags & CERT_REGISTRY_STORE_ROAMING_FLAG)
        fResult = ILS_DeleteElementFromDirectory(
                pRegStore->pwszStoreDirectory,
                rgpwszContextSubKeyName[dwContextType],
                wszSubKeyName,
                pRegStore->dwFlags
                );
    else {
        if (pRegStore->dwFlags & CERT_REGISTRY_STORE_CLIENT_GPT_FLAG) {
            assert(NULL == pRegStore->hKey);
            if (NULL == (pRegStore->hKey = OpenSubKey(
                    pRegStore->GptPara.hKeyBase,
                    pRegStore->GptPara.pwszRegPath,
                    pRegStore->dwFlags
                    )))
                return FALSE;
        }

        fResult = ILS_DeleteElementFromRegistry(
                pRegStore->hKey,
                rgpwszContextSubKeyName[dwContextType],
                wszSubKeyName,
                pRegStore->dwFlags
                );

#ifdef UNDER_CE
		// RegDeleteKey returns the wrong error. Remove when the right error is returned
		if (!fResult && GetLastError() == ERROR_INVALID_PARAMETER)
			SetLastError(ERROR_FILE_NOT_FOUND);
#endif			

        if (pRegStore->dwFlags & CERT_REGISTRY_STORE_CLIENT_GPT_FLAG) {
            ILS_CloseRegistryKey(pRegStore->hKey);
            pRegStore->hKey = NULL;
        }

        if (hWin95NotifyEvent && fResult)
            PulseEvent(hWin95NotifyEvent);
    }

    if (!fResult) {
        DWORD dwErr = GetLastError();
        if (ERROR_PATH_NOT_FOUND == dwErr || ERROR_FILE_NOT_FOUND == dwErr)
            fResult = TRUE;
    }
    return fResult;
}

//+-------------------------------------------------------------------------
//  Read the serialized copy of the certificate and its properties from
//  the registry and create a new certificate context.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI RegStoreProvReadCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pStoreCertContext,
        IN DWORD dwFlags,
        OUT PCCERT_CONTEXT *ppProvCertContext
        )
{
    BOOL fResult;
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;
    WCHAR wsz[MAX_CERT_REG_VALUE_NAME_LEN];

    assert(pRegStore);
    if (IsReadSerializedRegistry(pRegStore))
        goto UnexpectedReadError;

    if (!GetCertRegValueName(pStoreCertContext, wsz))
        goto GetRegValueNameError;

    fResult = ReadContext(
        pRegStore,
        CERT_STORE_CERTIFICATE_CONTEXT - 1,
        wsz,
        (const void **) ppProvCertContext
        );

CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    *ppProvCertContext = NULL;
    goto CommonReturn;

SET_ERROR(UnexpectedReadError, E_UNEXPECTED)
TRACE_ERROR(GetRegValueNameError)
}

STATIC void SetMyIEDirtyFlag()
{
    LONG err;
    DWORD dwDisposition;
    HKEY hSubKey;

    if (ERROR_SUCCESS != (err = RegCreateKeyExU(
            HKEY_LOCAL_MACHINE,
            CERT_IE_DIRTY_FLAGS_REGPATH,
            0,                      // dwReserved
            NULL,                   // lpClass
            REG_OPTION_NON_VOLATILE,
            MAXIMUM_ALLOWED,
            NULL,                   // lpSecurityAttributes
            &hSubKey,
            &dwDisposition))) {
#if DBG
        DbgPrintf(DBG_SS_CRYPT32,
            "RegCreateKeyEx(%S) returned error: %d 0x%x\n",
            CERT_IE_DIRTY_FLAGS_REGPATH, err, err);
#endif
    } else {
        WriteDWORDValueToRegistry(hSubKey, L"My", 0x1);
        RegCloseKey(hSubKey);
    }
}

//+-------------------------------------------------------------------------
//  Serialize the encoded certificate and its properties and write to
//  the registry.
//
//  Called before the certificate is written to the store.
//
//  Note, don't set the IEDirtyFlag if setting a property.
//--------------------------------------------------------------------------

STATIC BOOL WINAPI RegStoreProvWriteCertEx(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwFlags,
        IN BOOL fSetProperty
        )
{
    BOOL fResult;
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;
    WCHAR wsz[MAX_CERT_REG_VALUE_NAME_LEN];
    BYTE *pbElement = NULL;
    DWORD cbElement;

    assert(pRegStore);
    if (IsInResync(pRegStore))
        // Only update the store cache, don't write back to registry
        return TRUE;

    if (pRegStore->dwFlags & CERT_STORE_READONLY_FLAG)
        goto AccessDenied;
    if (IsWriteSerializedRegistry(pRegStore))
        return TRUE;

    if (!GetCertRegValueName(pCertContext, wsz))
        goto GetRegValueNameError;

    // get the size
    if (!CertSerializeCertificateStoreElement(
            pCertContext, 0, NULL, &cbElement))
        goto SerializeStoreElementError;
    if (NULL == (pbElement = (BYTE *) PkiNonzeroAlloc(cbElement)))
        goto OutOfMemory;

    // put it into the buffer
    if (!CertSerializeCertificateStoreElement(
            pCertContext, 0, pbElement, &cbElement))
        goto SerializeStoreElementError;

    // write it to the registry or roaming file
    fResult = WriteSerializedContext(
        pRegStore,
        CERT_STORE_CERTIFICATE_CONTEXT - 1,
        wsz,
        pbElement,
        cbElement
        );

    if (fResult && !fSetProperty &&
            0 != (pRegStore->dwFlags & CERT_REGISTRY_STORE_MY_IE_DIRTY_FLAG))
        SetMyIEDirtyFlag();

CommonReturn:
    PkiFree(pbElement);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(AccessDenied, E_ACCESSDENIED)
TRACE_ERROR(GetRegValueNameError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(SerializeStoreElementError)
}

STATIC BOOL WINAPI RegStoreProvWriteCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwFlags
        )
{
    return RegStoreProvWriteCertEx(
        hStoreProv,
        pCertContext,
        dwFlags,
        FALSE                       // fSetProperty
        );
}


//+-------------------------------------------------------------------------
//  Delete the specified certificate from the registry.
//
//  Called before the certificate is deleted from the store.
//+-------------------------------------------------------------------------
STATIC BOOL WINAPI RegStoreProvDeleteCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwFlags
        )
{
    BOOL fResult;
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;
    WCHAR wsz[MAX_CERT_REG_VALUE_NAME_LEN];

    assert(pRegStore);
    if (IsInResync(pRegStore))
        // Only delete from store cache, not from registry
        return TRUE;

    if (pRegStore->dwFlags & CERT_STORE_READONLY_FLAG)
        goto AccessDenied;
    if (IsWriteSerializedRegistry(pRegStore))
        return TRUE;

    if (!GetCertRegValueName(pCertContext, wsz))
        goto GetRegValueNameError;

    // delete this cert
    fResult = DeleteContext(
        pRegStore,
        CERT_STORE_CERTIFICATE_CONTEXT - 1,
        wsz
        );
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(AccessDenied, E_ACCESSDENIED)
TRACE_ERROR(GetRegValueNameError)
}

//+-------------------------------------------------------------------------
//  Read the specified certificate from the registry and update its
//  property.
//
//  Note, ignore the CERT_SHA1_HASH_PROP_ID property which is implicitly
//  set before we write the certificate to the registry. If we don't ignore,
//  we will have indefinite recursion.
//
//  Called before setting the property of the certificate in the store.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI RegStoreProvSetCertProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        IN const void *pvData
        )
{
    BOOL fResult;
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;
    PCCERT_CONTEXT pProvCertContext = NULL;

    // This property is implicitly written whenever we do a CertWrite.
    if (CERT_SHA1_HASH_PROP_ID == dwPropId)
        return TRUE;

    assert(pRegStore);
    if (IsInResync(pRegStore))
        // Only update the store cache, don't write back to registry
        return TRUE;

    if (pRegStore->dwFlags & CERT_STORE_READONLY_FLAG)
        goto AccessDenied;
    if (IsWriteSerializedRegistry(pRegStore))
        return TRUE;

    // Create a certificate context from the current serialized value stored
    // in the registry.
    if (!RegStoreProvReadCert(
            hStoreProv,
            pCertContext,
            0,              // dwFlags
            &pProvCertContext)) goto ReadError;

    // Set the property in the above created certificate context.
    if (!CertSetCertificateContextProperty(
            pProvCertContext,
            dwPropId,
            dwFlags,
            pvData)) goto SetPropertyError;

    // Serialize and write the above updated certificate back to the
    // registry.
    if (!RegStoreProvWriteCertEx(
            hStoreProv,
            pProvCertContext,
            0,                  // dwFlags
            TRUE                // fSetProperty
            ))
        goto WriteError;
    fResult = TRUE;
CommonReturn:
    CertFreeCertificateContext(pProvCertContext);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(AccessDenied, E_ACCESSDENIED)
TRACE_ERROR(ReadError)
TRACE_ERROR(SetPropertyError)
TRACE_ERROR(WriteError)
}

#ifdef CAPI_INCLUDE_CRL
//+-------------------------------------------------------------------------
//  Read the serialized copy of the CRL and its properties from
//  the registry and create a new CRL context.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI RegStoreProvReadCrl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pStoreCrlContext,
        IN DWORD dwFlags,
        OUT PCCRL_CONTEXT *ppProvCrlContext
        )
{
    BOOL fResult;
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;
    WCHAR wsz[MAX_CERT_REG_VALUE_NAME_LEN];

    assert(pRegStore);
    if (IsReadSerializedRegistry(pRegStore))
        goto UnexpectedReadError;

    if (!GetCrlRegValueName(pStoreCrlContext, wsz))
        goto GetRegValueNameError;

    fResult = ReadContext(
        pRegStore,
        CERT_STORE_CRL_CONTEXT - 1,
        wsz,
        (const void **) ppProvCrlContext
        );

CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    *ppProvCrlContext = NULL;
    goto CommonReturn;

SET_ERROR(UnexpectedReadError, E_UNEXPECTED)
TRACE_ERROR(GetRegValueNameError)
}

//+-------------------------------------------------------------------------
//  Serialize the encoded CRL and its properties and write to
//  the registry.
//
//  Called before the CRL is written to the store.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI RegStoreProvWriteCrl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pCrlContext,
        IN DWORD dwFlags
        )
{
    BOOL fResult;
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;
    WCHAR wsz[MAX_CERT_REG_VALUE_NAME_LEN];
    BYTE *pbElement = NULL;
    DWORD cbElement;

    assert(pRegStore);
    if (IsInResync(pRegStore))
        // Only update the store cache, don't write back to registry
        return TRUE;

    if (pRegStore->dwFlags & CERT_STORE_READONLY_FLAG)
        goto AccessDenied;
    if (IsWriteSerializedRegistry(pRegStore))
        return TRUE;

    if (!GetCrlRegValueName(pCrlContext, wsz))
        goto GetRegValueNameError;

    // get the size
    if (!CertSerializeCRLStoreElement(pCrlContext, 0, NULL, &cbElement))
        goto SerializeStoreElementError;
    if (NULL == (pbElement = (BYTE *) PkiNonzeroAlloc(cbElement)))
        goto OutOfMemory;

    // put it into the buffer
    if (!CertSerializeCRLStoreElement(pCrlContext, 0, pbElement, &cbElement))
        goto SerializeStoreElementError;

    // write it to the registry or roaming file
    fResult = WriteSerializedContext(
        pRegStore,
        CERT_STORE_CRL_CONTEXT - 1,
        wsz,
        pbElement,
        cbElement
        );

CommonReturn:
    PkiFree(pbElement);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(AccessDenied, E_ACCESSDENIED)
TRACE_ERROR(GetRegValueNameError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(SerializeStoreElementError)
}


//+-------------------------------------------------------------------------
//  Delete the specified CRL from the registry.
//
//  Called before the CRL is deleted from the store.
//+-------------------------------------------------------------------------
STATIC BOOL WINAPI RegStoreProvDeleteCrl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pCrlContext,
        IN DWORD dwFlags
        )
{
    BOOL fResult;
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;
    WCHAR wsz[MAX_CERT_REG_VALUE_NAME_LEN];

    assert(pRegStore);
    if (IsInResync(pRegStore))
        // Only delete from store cache, not from registry
        return TRUE;

    if (pRegStore->dwFlags & CERT_STORE_READONLY_FLAG)
        goto AccessDenied;
    if (IsWriteSerializedRegistry(pRegStore))
        return TRUE;

    if (!GetCrlRegValueName(pCrlContext, wsz))
        goto GetRegValueNameError;

    // delete this CRL
    fResult = DeleteContext(
        pRegStore,
        CERT_STORE_CRL_CONTEXT - 1,
        wsz
        );

CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(AccessDenied, E_ACCESSDENIED)
TRACE_ERROR(GetRegValueNameError)
}

//+-------------------------------------------------------------------------
//  Read the specified CRL from the registry and update its
//  property.
//
//  Note, ignore the CERT_SHA1_HASH_PROP_ID property which is implicitly
//  set before we write the CRL to the registry. If we don't ignore,
//  we will have indefinite recursion.
//
//  Called before setting the property of the CRL in the store.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI RegStoreProvSetCrlProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pCrlContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        IN const void *pvData
        )
{
    BOOL fResult;
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;
    PCCRL_CONTEXT pProvCrlContext = NULL;

    // This property is implicitly written whenever we do a CertWrite.
    if (CERT_SHA1_HASH_PROP_ID == dwPropId)
        return TRUE;

    assert(pRegStore);
    if (IsInResync(pRegStore))
        // Only update the store cache, don't write back to registry
        return TRUE;

    if (pRegStore->dwFlags & CERT_STORE_READONLY_FLAG)
        goto AccessDenied;
    if (IsWriteSerializedRegistry(pRegStore))
        return TRUE;

    // Create a certificate context from the current serialized value stored
    // in the registry.
    if (!RegStoreProvReadCrl(
            hStoreProv,
            pCrlContext,
            0,              // dwFlags
            &pProvCrlContext)) goto ReadError;

    // Set the property in the above created certificate context.
    if (!CertSetCRLContextProperty(
            pProvCrlContext,
            dwPropId,
            dwFlags,
            pvData)) goto SetPropertyError;

    // Serialize and write the above updated certificate back to the
    // registry.
    if (!RegStoreProvWriteCrl(
            hStoreProv,
            pProvCrlContext,
            0))                 //dwFlags
        goto WriteError;
    fResult = TRUE;
CommonReturn:
    CertFreeCRLContext(pProvCrlContext);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(AccessDenied, E_ACCESSDENIED)
TRACE_ERROR(ReadError)
TRACE_ERROR(SetPropertyError)
TRACE_ERROR(WriteError)
}

#endif CAPI_INCLUDE_CRL

#ifdef CAPI_INCLUDE_CTL
//+-------------------------------------------------------------------------
//  Read the serialized copy of the CTL and its properties from
//  the registry and create a new CTL context.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI RegStoreProvReadCtl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pStoreCtlContext,
        IN DWORD dwFlags,
        OUT PCCTL_CONTEXT *ppProvCtlContext
        )
{
    BOOL fResult;
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;
    WCHAR wsz[MAX_CERT_REG_VALUE_NAME_LEN];

    assert(pRegStore);
    if (IsReadSerializedRegistry(pRegStore))
        goto UnexpectedReadError;

    if (!GetCtlRegValueName(pStoreCtlContext, wsz))
        goto GetRegValueNameError;

    fResult = ReadContext(
        pRegStore,
        CERT_STORE_CTL_CONTEXT - 1,
        wsz,
        (const void **) ppProvCtlContext
        );
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    *ppProvCtlContext = NULL;
    goto CommonReturn;

SET_ERROR(UnexpectedReadError, E_UNEXPECTED)
TRACE_ERROR(GetRegValueNameError)
}

//+-------------------------------------------------------------------------
//  Serialize the encoded CTL and its properties and write to
//  the registry.
//
//  Called before the CTL is written to the store.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI RegStoreProvWriteCtl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pCtlContext,
        IN DWORD dwFlags
        )
{
    BOOL fResult;
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;
    WCHAR wsz[MAX_CERT_REG_VALUE_NAME_LEN];
    BYTE *pbElement = NULL;
    DWORD cbElement;

    assert(pRegStore);
    if (IsInResync(pRegStore))
        // Only update the store cache, don't write back to registry
        return TRUE;

    if (pRegStore->dwFlags & CERT_STORE_READONLY_FLAG)
        goto AccessDenied;
    if (IsWriteSerializedRegistry(pRegStore))
        return TRUE;

    if (!GetCtlRegValueName(pCtlContext, wsz))
        goto GetRegValueNameError;

    // get the size
    if (!CertSerializeCTLStoreElement(pCtlContext, 0, NULL, &cbElement))
        goto SerializeStoreElementError;
    if (NULL == (pbElement = (BYTE *) PkiNonzeroAlloc(cbElement)))
        goto OutOfMemory;

    // put it into the buffer
    if (!CertSerializeCTLStoreElement(pCtlContext, 0, pbElement, &cbElement))
        goto SerializeStoreElementError;

    // write it to the registry or roaming file
    fResult = WriteSerializedContext(
        pRegStore,
        CERT_STORE_CTL_CONTEXT - 1,
        wsz,
        pbElement,
        cbElement
        );
CommonReturn:
    PkiFree(pbElement);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(AccessDenied, E_ACCESSDENIED)
TRACE_ERROR(GetRegValueNameError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(SerializeStoreElementError)
}


//+-------------------------------------------------------------------------
//  Delete the specified CTL from the registry.
//
//  Called before the CTL is deleted from the store.
//+-------------------------------------------------------------------------
STATIC BOOL WINAPI RegStoreProvDeleteCtl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pCtlContext,
        IN DWORD dwFlags
        )
{
    BOOL fResult;
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;
    WCHAR wsz[MAX_CERT_REG_VALUE_NAME_LEN];

    assert(pRegStore);
    if (IsInResync(pRegStore))
        // Only delete from store cache, not from registry
        return TRUE;

    if (pRegStore->dwFlags & CERT_STORE_READONLY_FLAG)
        goto AccessDenied;
    if (IsWriteSerializedRegistry(pRegStore))
        return TRUE;

    if (!GetCtlRegValueName(pCtlContext, wsz))
        goto GetRegValueNameError;

    // delete this CTL
    fResult = DeleteContext(
        pRegStore,
        CERT_STORE_CTL_CONTEXT - 1,
        wsz
        );
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(AccessDenied, E_ACCESSDENIED)
TRACE_ERROR(GetRegValueNameError)
}

//+-------------------------------------------------------------------------
//  Read the specified CTL from the registry and update its
//  property.
//
//  Note, ignore the CERT_SHA1_HASH_PROP_ID property which is implicitly
//  set before we write the CTL to the registry. If we don't ignore,
//  we will have indefinite recursion.
//
//  Called before setting the property of the CTL in the store.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI RegStoreProvSetCtlProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pCtlContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        IN const void *pvData
        )
{
    BOOL fResult;
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;
    PCCTL_CONTEXT pProvCtlContext = NULL;

    // This property is implicitly written whenever we do a CertWrite.
    if (CERT_SHA1_HASH_PROP_ID == dwPropId)
        return TRUE;

    assert(pRegStore);
    if (IsInResync(pRegStore))
        // Only update the store cache, don't write back to registry
        return TRUE;

    if (pRegStore->dwFlags & CERT_STORE_READONLY_FLAG)
        goto AccessDenied;
    if (IsWriteSerializedRegistry(pRegStore))
        return TRUE;

    // Create a CTL context from the current serialized value stored
    // in the registry.
    if (!RegStoreProvReadCtl(
            hStoreProv,
            pCtlContext,
            0,              // dwFlags
            &pProvCtlContext)) goto ReadError;

    // Set the property in the above created certificate context.
    if (!CertSetCTLContextProperty(
            pProvCtlContext,
            dwPropId,
            dwFlags,
            pvData)) goto SetPropertyError;

    // Serialize and write the above updated certificate back to the
    // registry.
    if (!RegStoreProvWriteCtl(
            hStoreProv,
            pProvCtlContext,
            0))                 //dwFlags
        goto WriteError;
    fResult = TRUE;
CommonReturn:
    CertFreeCTLContext(pProvCtlContext);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(AccessDenied, E_ACCESSDENIED)
TRACE_ERROR(ReadError)
TRACE_ERROR(SetPropertyError)
TRACE_ERROR(WriteError)
}

#endif

#ifndef CE_BUILD
//+=========================================================================
//  Control functions
//==========================================================================

STATIC BOOL RegNotifyChange(
    IN PREG_STORE pRegStore,
    HANDLE hEvent
    )
{
    if (pRegStore->dwFlags & CERT_REGISTRY_STORE_ROAMING_FLAG)
        return RegRegistryStoreChange(pRegStore, hEvent);
    else if (hWin95NotifyEvent)
        return RegWin95StoreChange(pRegStore, hEvent);
    else if (pRegStore->dwFlags & CERT_REGISTRY_STORE_CLIENT_GPT_FLAG)
        return RegGptStoreChange(pRegStore, hEvent);
    else
        return RegRegistryStoreChange(pRegStore, hEvent);
}

STATIC BOOL ResyncFromRegistry(
    IN PREG_STORE pRegStore,
    IN OPTIONAL HANDLE hEvent
    )
{
    BOOL fResult;
    HCERTSTORE hNewStore = NULL;
    HANDLE hMyNotifyChange;

    // Serialize resyncs
    LockRegStore(pRegStore);

    if (hEvent) {
        // Re-arm the specified event
        if (!RegNotifyChange(pRegStore, hEvent))
            goto NotifyChangeError;
    }

    hMyNotifyChange = pRegStore->hMyNotifyChange;
    if (hMyNotifyChange) {
        // Check if any changes since last resync
        if (WAIT_TIMEOUT == WaitForSingleObjectEx(
                hMyNotifyChange,
                0,                          // dwMilliseconds
                FALSE                       // bAlertable
                )) {
            // No change
            fResult = TRUE;
            goto CommonReturn;
        } else {
            // Re-arm our event handle
            if (!RegNotifyChange(pRegStore, hMyNotifyChange))
                goto NotifyChangeError;
        }
    }

    if (NULL == (hNewStore = CertOpenStore(
            CERT_STORE_PROV_MEMORY,
            0,                      // dwEncodingType
            0,                      // hCryptProv
            0,                      // dwFlags
            NULL                    // pvPara
            )))
        goto OpenMemoryStoreError;

    if (pRegStore->dwFlags & CERT_REGISTRY_STORE_CLIENT_GPT_FLAG) {
        fResult = OpenAllFromGptRegistry(pRegStore, hNewStore);
        pRegStore->fTouched = FALSE;
    } else if (pRegStore->dwFlags & CERT_REGISTRY_STORE_SERIALIZED_FLAG) {
        fResult = OpenAllFromSerializedRegistry(pRegStore, hNewStore);
        pRegStore->fTouched = FALSE;
    } else
        fResult = OpenAllFromRegistry(pRegStore, hNewStore);

    if (!fResult) {
        if (ERROR_KEY_DELETED == GetLastError())
            fResult = TRUE;
    }

    if (fResult) {
        if (pRegStore->fProtected) {
            BOOL fProtected;

            // For the "Root" delete any roots that aren't in the protected root
            // list.
            if (!IPR_DeleteUnprotectedRootsFromStore(
                    hNewStore,
                    &fProtected
                    )) goto DeleteUnprotectedRootsError;
        }

        // Set fResync to inhibit the sync from writing back to the registry.
        pRegStore->fResync = TRUE;
        I_CertSyncStore(pRegStore->hCertStore, hNewStore);
        pRegStore->fResync = FALSE;
    }

CommonReturn:
    UnlockRegStore(pRegStore);
    if (hNewStore)
        CertCloseStore(hNewStore, 0);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(NotifyChangeError)
TRACE_ERROR(OpenMemoryStoreError)
TRACE_ERROR(DeleteUnprotectedRootsError)
}


STATIC BOOL RegistryNotifyChange(
    IN PREG_STORE pRegStore,
    IN HANDLE hEvent
    )
{
    BOOL fResult;
    HANDLE hMyNotifyChange;

    LockRegStore(pRegStore);

    hMyNotifyChange = pRegStore->hMyNotifyChange;
    if (NULL == hMyNotifyChange) {
        // Create "my" event and register it to be signaled for any changes
        if (NULL == (hMyNotifyChange = CreateEvent(
                NULL,       // lpsa
                FALSE,      // fManualReset
                FALSE,      // fInitialState
                NULL)))     // lpszEventName
            goto CreateEventError;

        // For the first notification, want to ensure the store is in sync.
        // Also does a RegNotifyChange
        if (!ResyncFromRegistry(pRegStore, hMyNotifyChange)) {
            DWORD dwErr = GetLastError();
            CloseHandle(hMyNotifyChange);
            SetLastError(dwErr);
            goto ResyncFromRegistryError;
        }

        // Note, must update after making the above Resync call to
        // force the store to be resync'ed
        pRegStore->hMyNotifyChange = hMyNotifyChange;
    }
    // else
    //  Already created and registered my event

    if (hEvent) {
        if (!RegNotifyChange(pRegStore, hEvent))
            goto NotifyChangeError;
    }

    fResult = TRUE;
CommonReturn:
    UnlockRegStore(pRegStore);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(CreateEventError)
TRACE_ERROR(ResyncFromRegistryError)
TRACE_ERROR(NotifyChangeError)
}


STATIC BOOL WINAPI RegStoreProvControl(
        IN HCERTSTOREPROV hStoreProv,
        IN DWORD dwFlags,
        IN DWORD dwCtrlType,
        IN void const *pvCtrlPara
        )
{
    BOOL fResult;
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;

    switch (dwCtrlType) {
        case CERT_STORE_CTRL_RESYNC:
            {
                HANDLE *phEvent = (HANDLE *) pvCtrlPara;
                HANDLE hEvent = phEvent ? *phEvent : NULL;
                fResult = ResyncFromRegistry(pRegStore, hEvent);
            }
            break;
        case CERT_STORE_CTRL_NOTIFY_CHANGE:
            {
                HANDLE *phEvent = (HANDLE *) pvCtrlPara;
                HANDLE hEvent = phEvent ? *phEvent : NULL;
                fResult = RegistryNotifyChange(pRegStore, hEvent);
            }
            break;
        case CERT_STORE_CTRL_COMMIT:
            if (pRegStore->dwFlags & CERT_REGISTRY_STORE_CLIENT_GPT_FLAG)
                fResult = CommitAllToGptRegistry(pRegStore, dwFlags);
            else if (pRegStore->dwFlags & CERT_REGISTRY_STORE_SERIALIZED_FLAG)
                fResult = CommitAllToSerializedRegistry(pRegStore, dwFlags);
            else
                fResult = TRUE;
            break;
        default:
            goto NotSupported;
    }

CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(NotSupported, ERROR_CALL_NOT_IMPLEMENTED)
}

#endif

//+=========================================================================
//  System and physical store support functions
//==========================================================================

STATIC BOOL HasBackslash(
    IN LPCWSTR pwsz
    )
{
    WCHAR wch;

    if (NULL == pwsz)
        return FALSE;

    while (L'\0' != (wch = *pwsz++)) {
        if (L'\\' == wch)
            return TRUE;
    }
    return FALSE;
}

static inline LPCSTR GetSystemStoreLocationOID(
    IN DWORD dwFlags
    )
{
    return (LPCSTR)(DWORD_PTR) ((dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK) >>
        CERT_SYSTEM_STORE_LOCATION_SHIFT);
}

static inline DWORD GetSystemStoreLocationID(
    IN DWORD dwFlags
    )
{
    return ((dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK) >>
        CERT_SYSTEM_STORE_LOCATION_SHIFT);
}

static inline BOOL IsSystemStoreLocationInRegistry(
    IN DWORD dwFlags
    )
{
    DWORD dwID = GetSystemStoreLocationID(dwFlags);
    return (dwID < NUM_SYSTEM_STORE_LOCATION &&
        0 == (rgSystemStoreLocationInfo[dwID].dwFlags &
                NOT_IN_REGISTRY_SYSTEM_STORE_LOCATION_FLAG));
}

static inline BOOL IsRemotableSystemStoreLocationInRegistry(
    IN DWORD dwFlags
    )
{
    DWORD dwID = GetSystemStoreLocationID(dwFlags);
    return (dwID < NUM_SYSTEM_STORE_LOCATION &&
        0 != (rgSystemStoreLocationInfo[dwID].dwFlags &
                REMOTABLE_SYSTEM_STORE_LOCATION_FLAG));
}


static inline BOOL IsSerializedSystemStoreLocationInRegistry(
    IN DWORD dwFlags
    )
{
    DWORD dwID = GetSystemStoreLocationID(dwFlags);
    return (dwID < NUM_SYSTEM_STORE_LOCATION &&
        0 != (rgSystemStoreLocationInfo[dwID].dwFlags &
                SERIALIZED_SYSTEM_STORE_LOCATION_FLAG));
}

STATIC BOOL IsPredefinedSystemStore(
    IN LPCWSTR pwszSystemName,
    IN DWORD dwFlags
    )
{
    DWORD i;
    DWORD dwCheckFlag;
    DWORD dwLocID;
    DWORD dwPredefinedSystemFlags;

    dwLocID = GetSystemStoreLocationID(dwFlags);
    assert(NUM_SYSTEM_STORE_LOCATION > dwLocID);
    dwPredefinedSystemFlags =
        rgSystemStoreLocationInfo[dwLocID].dwPredefinedSystemFlags;

    for (i = 0, dwCheckFlag = 1; i < NUM_PREDEFINED_SYSTEM_STORE;
                                        i++, dwCheckFlag = dwCheckFlag << 1) {
        if ((dwCheckFlag & dwPredefinedSystemFlags) &&
                0 == _wcsicmp(rgpwszPredefinedSystemStore[i], pwszSystemName))
            return TRUE;
    }
    return FALSE;
}

#define UNICODE_SYSTEM_PROVIDER_FLAG    0x1
#define ASCII_SYSTEM_PROVIDER_FLAG      0x2
#define PHYSICAL_PROVIDER_FLAG          0x4

STATIC DWORD GetSystemProviderFlags(
    IN LPCSTR pszStoreProvider
    )
{
    DWORD dwFlags;

    if (0xFFFF < (DWORD_PTR) pszStoreProvider &&
            CONST_OID_STR_PREFIX_CHAR == pszStoreProvider[0])
        // Convert "#<number>" string to its corresponding constant OID value
        pszStoreProvider = (LPCSTR)(DWORD_PTR) atol(pszStoreProvider + 1);

    dwFlags = 0;
    if (CERT_STORE_PROV_SYSTEM_A == pszStoreProvider)
        dwFlags = ASCII_SYSTEM_PROVIDER_FLAG;
    else if (CERT_STORE_PROV_SYSTEM_W == pszStoreProvider)
        dwFlags = UNICODE_SYSTEM_PROVIDER_FLAG;
    else if (CERT_STORE_PROV_SYSTEM_REGISTRY_A == pszStoreProvider)
        dwFlags = ASCII_SYSTEM_PROVIDER_FLAG;
    else if (CERT_STORE_PROV_SYSTEM_REGISTRY_W == pszStoreProvider)
        dwFlags = UNICODE_SYSTEM_PROVIDER_FLAG;
    else if (CERT_STORE_PROV_PHYSICAL_W == pszStoreProvider)
        dwFlags = UNICODE_SYSTEM_PROVIDER_FLAG | PHYSICAL_PROVIDER_FLAG;
    else if (0xFFFF < (DWORD_PTR) pszStoreProvider) {
        if (0 == _stricmp(sz_CERT_STORE_PROV_SYSTEM_W, pszStoreProvider))
            dwFlags = UNICODE_SYSTEM_PROVIDER_FLAG;
        else if (0 == _stricmp(sz_CERT_STORE_PROV_SYSTEM_REGISTRY_W,
                pszStoreProvider))
            dwFlags = UNICODE_SYSTEM_PROVIDER_FLAG;
        else if (0 == _stricmp(sz_CERT_STORE_PROV_PHYSICAL_W,
                pszStoreProvider))
            dwFlags = UNICODE_SYSTEM_PROVIDER_FLAG | PHYSICAL_PROVIDER_FLAG;
    }

    return dwFlags;
}

STATIC LPCSTR ChangeAsciiToUnicodeProvider(
    IN LPCSTR pszStoreProvider
    )
{
    LPCSTR pszUnicodeProvider = NULL;

    if (0xFFFF < (DWORD_PTR) pszStoreProvider &&
            CONST_OID_STR_PREFIX_CHAR == pszStoreProvider[0])
        // Convert "#<number>" string to its corresponding constant OID value
        pszStoreProvider = (LPCSTR)(DWORD_PTR) atol(pszStoreProvider + 1);

    if (CERT_STORE_PROV_SYSTEM_A == pszStoreProvider)
        pszUnicodeProvider = CERT_STORE_PROV_SYSTEM_W;
    else if (CERT_STORE_PROV_SYSTEM_REGISTRY_A == pszStoreProvider)
        pszUnicodeProvider = CERT_STORE_PROV_SYSTEM_REGISTRY_W;

    assert(pszUnicodeProvider);
    return pszUnicodeProvider;
}


STATIC void FreeSystemNameInfo(
    IN PSYSTEM_NAME_INFO pInfo
    )
{
    DWORD i;
    for (i = 0; i < SYSTEM_NAME_PATH_COUNT; i++) {
        if (pInfo->rgpwszName[i]) {
            PkiFree(pInfo->rgpwszName[i]);
            pInfo->rgpwszName[i] = NULL;
        }
    }
}

//+-------------------------------------------------------------------------
//  If CERT_SYSTEM_STORE_RELOCATE_FLAG is set in dwFlags, then, treat the
//  parameter as a pointer to a relocate data structure consisting of
//  the relocate HKEY base and the pointer to the system name path.
//  Otherwise, treat the parameter as a pointer to the system name path.
//
//  Parses and validates the system name path according to the system store
//  location and the number of required System and Physical name components.
//  All name components are separated by the backslash, "\", character.
//
//  Depending on the system store location and the number of required System
//  and Physical name components, the system name path can have the following
//  name components:
//
//  CERT_SYSTEM_STORE_CURRENT_USER or
//  CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY
//      []
//      SystemName
//      SystemName\PhysicalName
//  CERT_SYSTEM_STORE_LOCAL_MACHINE or
//  CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY or
//  CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE
//      []
//      [[\\]ComputerName]
//      [[\\]ComputerName\]SystemName
//      [[\\]ComputerName\]SystemName\PhysicalName
//  CERT_SYSTEM_STORE_CURRENT_SERVICE
//      []
//      SystemName
//      SystemName\PhysicalName
//  CERT_SYSTEM_STORE_SERVICES
//      []
//      [\\ComputerName]
//      [[\\]ComputerName\]
//      [ServiceName]
//      [[\\]ComputerName\ServiceName]
//      [[\\]ComputerName\]ServiceName\SystemName
//      [[\\]ComputerName\]ServiceName\SystemName\PhysicalName
//  CERT_SYSTEM_STORE_USERS
//      []
//      [\\ComputerName]
//      [[\\]ComputerName\]
//      [UserName]
//      [[\\]ComputerName\UserName]
//      [[\\]ComputerName\]UserName\SystemName
//      [[\\]ComputerName\]UserName\SystemName\PhysicalName
//
//  For enumeration, where cReqName = 0, all store locations allow the no name
//  components option. CERT_SYSTEM_STORE_CURRENT_USER,
//  CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY,
//  CERT_SYSTEM_CURRENT_SERVICE only allow the no name component option.
//
//  The leading \\ before the ComputerName is optional.
//
//  A PhysicalName always requires a preceding SystemName.
//
//  For CERT_SYSTEM_STORE_SERVICES or CERT_SYSTEM_STORE_USERS,
//  for enumeration, if only a single
//  name component, then, interpretted as a ServiceName or UserName unless it
//  contains a leading \\ or a trailing \, in which case its interpretted as a
//  ComputerName. Otherwise, when not enumeration, the ServiceName or UserName
//  is required.
//--------------------------------------------------------------------------
STATIC BOOL ParseSystemStorePara(
    IN const void *pvPara,
    IN DWORD dwFlags,
    IN DWORD cReqName,      // 0 for enum, 1 for OpenSystem, 2 for OpenPhysical
    OUT PSYSTEM_NAME_INFO pInfo
    )
{
    LPCWSTR pwszPath;       // not allocated
    BOOL fResult;
    DWORD cMaxOptName;
    DWORD cMaxTotalName;
    DWORD cOptName;
    DWORD cTotalName;
    BOOL fHasComputerNameBackslashes;
    DWORD i;

    LPCWSTR pwszEnd;
    LPCWSTR pwsz;
    LPCWSTR rgpwszStart[SYSTEM_NAME_PATH_COUNT];
    DWORD cchName[SYSTEM_NAME_PATH_COUNT];

    memset(pInfo, 0, sizeof(*pInfo));
    if (dwFlags & CERT_SYSTEM_STORE_RELOCATE_FLAG) {
        PCERT_SYSTEM_STORE_RELOCATE_PARA pRelocatePara =
            (PCERT_SYSTEM_STORE_RELOCATE_PARA) pvPara;

        if (NULL == pRelocatePara)
            goto NullRelocateParaError;

        if (NULL == pRelocatePara->hKeyBase)
            goto NullRelocateHKEYError;
        pInfo->hKeyBase = pRelocatePara->hKeyBase;
        pwszPath = pRelocatePara->pwszSystemStore;
    } else
        pwszPath = (LPCWSTR) pvPara;

    if (NULL == pwszPath || L'\0' == *pwszPath) {
        if (0 == cReqName)
            goto SuccessReturn;
        else
            goto MissingSystemName;
    }

    dwFlags &= CERT_SYSTEM_STORE_LOCATION_MASK;
    switch (dwFlags) {
        case CERT_SYSTEM_STORE_CURRENT_USER:
        case CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY:
        case CERT_SYSTEM_STORE_CURRENT_SERVICE:
            cMaxOptName = 0;
            break;
        case CERT_SYSTEM_STORE_LOCAL_MACHINE:
        case CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY:
        case CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE:
            cMaxOptName = 1;        // Allow ComputerName
            break;
        case CERT_SYSTEM_STORE_SERVICES:
        case CERT_SYSTEM_STORE_USERS:
            // Allow ComputerName and/or ServiceOrUserName
            cMaxOptName = 2;
            break;
        default:
            goto InvalidStoreLocation;
    }

    cMaxTotalName = cReqName + cMaxOptName;
    assert(cReqName <= SERVICE_NAME_INDEX);
    assert(cMaxTotalName <= SYSTEM_NAME_PATH_COUNT);
    if (0 == cMaxTotalName)
        goto MachineOrServiceNameNotAllowed;

    if (L'\\' == pwszPath[0] && L'\\' == pwszPath[1]) {
        pwszPath += 2;
        fHasComputerNameBackslashes = TRUE;
    } else
        fHasComputerNameBackslashes = FALSE;

    // Starting at the end, get up through cMaxTotalName strings separated
    // by backslashes. Note, don't parse the left-most name component. This
    // allows a ComputerName to contain embedded backslashes.
    pwszEnd = pwszPath + wcslen(pwszPath);
    pwsz = pwszEnd;

    cTotalName = 0;
    while (cTotalName < cMaxTotalName - 1) {
        while (pwsz > pwszPath && L'\\' != *pwsz)
            pwsz--;
        if (L'\\' != *pwsz) {
            // Left-most name component.
            assert(pwsz == pwszPath);
            break;
        }
        assert(L'\\' == *pwsz);
        cchName[cTotalName] = (DWORD)(pwszEnd - pwsz) - 1; // exclude "\"
        rgpwszStart[cTotalName] = pwsz + 1;         // exclude "\"
        cTotalName++;

        pwszEnd = pwsz;         // remember pointer to "\"
        if (pwsz == pwszPath)
            // Left-most name component is empty
            break;
        pwsz--;                 // skip before the "\"
    }
    // Left-most name component. Note, it may have embedded backslashes
    cchName[cTotalName] = (DWORD)(pwszEnd - pwszPath);
    rgpwszStart[cTotalName] = pwszPath;
    cTotalName++;

    if (cTotalName < cReqName)
        goto MissingSystemOrPhysicalName;

    // Allocate and copy the required name components
    for (i = 0; i < cReqName; i++) {
        if (0 == cchName[i])
            goto EmptySystemOrPhysicalName;
        if (NULL == (pInfo->rgpwszName[SERVICE_NAME_INDEX - cReqName + i] =
                AllocAndCopyString(rgpwszStart[i], cchName[i])))
            goto OutOfMemory;
    }

    cOptName = cTotalName - cReqName;
    assert(cOptName || cReqName);
    if (0 == cOptName) {
        assert(cReqName);
        // No ComputerName and/or ServiceName prefix

        // Check if left-most name component (SystemName) has any backslashes
        assert(pInfo->rgpwszName[SYSTEM_NAME_INDEX]);
        if (fHasComputerNameBackslashes || HasBackslash(
                pInfo->rgpwszName[SYSTEM_NAME_INDEX]))
            goto InvalidBackslashInSystemName;
        if (CERT_SYSTEM_STORE_SERVICES == dwFlags ||
                CERT_SYSTEM_STORE_USERS == dwFlags)
            // For non-enumeration, require the ServiceName
            goto MissingServiceOrUserName;
    } else {
        if (CERT_SYSTEM_STORE_SERVICES == dwFlags ||
                CERT_SYSTEM_STORE_USERS == dwFlags) {
            // ServiceName or UserName prefix

            if (0 == cchName[cReqName] ||
                    (1 == cOptName && fHasComputerNameBackslashes)) {
                if (0 != cReqName)
                    goto MissingServiceOrUserName;
                // else
                //  ComputerName only Enumeration with either:
                //      ComputerName\       <- trailing backslash
                //      \\ComputerName      <- leading backslashes
                //      \\ComputerName\     <- both
            } else {
                if (NULL == (pInfo->rgpwszName[SERVICE_NAME_INDEX] =
                        AllocAndCopyString(rgpwszStart[cReqName],
                            cchName[cReqName])))
                    goto OutOfMemory;
            }
        }

        if (CERT_SYSTEM_STORE_LOCAL_MACHINE == dwFlags ||
                CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY == dwFlags ||
                CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE == dwFlags ||
                2 == cOptName || fHasComputerNameBackslashes) {
            // ComputerName prefix
            DWORD cchComputer = cchName[cTotalName - 1];
            if (0 == cchComputer)
                goto EmptyComputerName;

            if (pInfo->hKeyBase)
                goto BothRemoteAndRelocateNotAllowed;

            if (NULL == (pInfo->rgpwszName[COMPUTER_NAME_INDEX] =
                    (LPWSTR) PkiNonzeroAlloc(
                    (2 + cchComputer + 1) * sizeof(WCHAR))))
                goto OutOfMemory;
            wcscpy(pInfo->rgpwszName[COMPUTER_NAME_INDEX], L"\\\\");
            memcpy((BYTE *) (pInfo->rgpwszName[COMPUTER_NAME_INDEX] + 2),
                (BYTE *) rgpwszStart[cTotalName -1],
                cchComputer * sizeof(WCHAR));
            *(pInfo->rgpwszName[COMPUTER_NAME_INDEX] + 2 + cchComputer) = L'\0';
        }
    }

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    FreeSystemNameInfo(pInfo);
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(MissingSystemName, E_INVALIDARG)
SET_ERROR(NullRelocateParaError, E_INVALIDARG)
SET_ERROR(NullRelocateHKEYError, E_INVALIDARG)
SET_ERROR(MissingSystemOrPhysicalName, E_INVALIDARG)
SET_ERROR(InvalidStoreLocation, E_INVALIDARG)
SET_ERROR(MachineOrServiceNameNotAllowed, E_INVALIDARG)
SET_ERROR(EmptySystemOrPhysicalName, E_INVALIDARG)
SET_ERROR(InvalidBackslashInSystemName, E_INVALIDARG)
SET_ERROR(MissingServiceOrUserName, E_INVALIDARG)
SET_ERROR(EmptyComputerName, E_INVALIDARG)
SET_ERROR(BothRemoteAndRelocateNotAllowed, E_INVALIDARG)
TRACE_ERROR(OutOfMemory)
}

typedef struct _SYSTEM_NAME_GROUP {
    DWORD cName;
    LPCWSTR *rgpwszName;
} SYSTEM_NAME_GROUP, *PSYSTEM_NAME_GROUP;

//+-------------------------------------------------------------------------
//  Formats a System Name Path by concatenating together the name components
//  with an intervening "\" separator.
//--------------------------------------------------------------------------
STATIC LPWSTR FormatSystemNamePath(
    IN DWORD cNameGroup,
    IN SYSTEM_NAME_GROUP rgNameGroup[]
    )
{
    DWORD cchPath;
    LPWSTR pwszPath;
    BOOL fFirst;
    DWORD iGroup;

    // First, get total length of formatted path
    cchPath = 0;
    fFirst = TRUE;
    for (iGroup = 0; iGroup < cNameGroup; iGroup++) {
        DWORD iName;
        for (iName = 0; iName < rgNameGroup[iGroup].cName; iName++) {
            LPCWSTR pwszName = rgNameGroup[iGroup].rgpwszName[iName];
            if (pwszName && *pwszName) {
                if (fFirst)
                    fFirst = FALSE;
                else
                    cchPath++;          // "\" separator
                cchPath += wcslen(pwszName);
            }
        }
    }
    cchPath++;          // "\0" terminator

    if (NULL == (pwszPath = (LPWSTR) PkiNonzeroAlloc(cchPath * sizeof(WCHAR))))
        return NULL;

    // Now do concatenated copies with intervening '\'
    fFirst = TRUE;
    for (iGroup = 0; iGroup < cNameGroup; iGroup++) {
        DWORD iName;
        for (iName = 0; iName < rgNameGroup[iGroup].cName; iName++) {
            LPCWSTR pwszName = rgNameGroup[iGroup].rgpwszName[iName];
            if (pwszName && *pwszName) {
                if (fFirst) {
                    wcscpy(pwszPath, pwszName);
                    fFirst = FALSE;
                } else {
                    wcscat(pwszPath, L"\\");
                    wcscat(pwszPath, pwszName);
                }
            }
        }
    }
    if (fFirst)
        // Empty string
        *pwszPath = L'\0';
    return pwszPath;
}

//+-------------------------------------------------------------------------
//  If the SystemNameInfo has a non-NULL hKeyBase, then, the returned
//  pvPara is a pointer to a CERT_SYSTEM_STORE_RELOCATE_PARA containing both
//  the hKeyBase and the formatted system name path. Otherwise, returns
//  pointer to only the formatted system name path.
//
//  Calls the above FormatSystemNamePath() to do the actual formatting.
//--------------------------------------------------------------------------
STATIC void * FormatSystemNamePara(
    IN DWORD cNameGroup,
    IN SYSTEM_NAME_GROUP rgNameGroup[],
    IN PSYSTEM_NAME_INFO pSystemNameInfo
    )
{
    if (NULL == pSystemNameInfo->hKeyBase)
        return FormatSystemNamePath(cNameGroup, rgNameGroup);
    else {
        PCERT_SYSTEM_STORE_RELOCATE_PARA pRelocatePara;

        if (NULL == (pRelocatePara =
                (PCERT_SYSTEM_STORE_RELOCATE_PARA) PkiNonzeroAlloc(
                    sizeof(CERT_SYSTEM_STORE_RELOCATE_PARA))))
            return NULL;

        pRelocatePara->hKeyBase = pSystemNameInfo->hKeyBase;

        if (NULL == (pRelocatePara->pwszSystemStore = FormatSystemNamePath(
                cNameGroup, rgNameGroup))) {
            PkiFree(pRelocatePara);
            return NULL;
        } else
            return pRelocatePara;
    }
}

STATIC void FreeSystemNamePara(
    IN void *pvSystemNamePara,
    IN PSYSTEM_NAME_INFO pSystemNameInfo
    )
{
    if (pvSystemNamePara) {
        if (pSystemNameInfo->hKeyBase) {
            PCERT_SYSTEM_STORE_RELOCATE_PARA pRelocatePara =
                (PCERT_SYSTEM_STORE_RELOCATE_PARA) pvSystemNamePara;
            PkiFree((LPWSTR) pRelocatePara->pwszSystemStore);
        }
        PkiFree(pvSystemNamePara);
    }
}


//+-------------------------------------------------------------------------
//  Localizes the physical, system and service name components. If unable
//  to find a localized name string, uses the unlocalized name component.
//
//  Re-formats the system name path with intervening backslashes and
//  sets the store's CERT_STORE_LOCALIZED_NAME_PROP_ID property.
//--------------------------------------------------------------------------
STATIC void SetLocalizedNameStoreProperty(
    IN HCERTSTORE hCertStore,
    IN PSYSTEM_NAME_INFO pSystemNameInfo
    )
{
    LPWSTR pwszLocalizedPath = NULL;
    LPCWSTR rgpwszLocalizedName[SYSTEM_NAME_PATH_COUNT];
    SYSTEM_NAME_GROUP NameGroup;
    CRYPT_DATA_BLOB Property;
    DWORD i;

    // Except for the computer name, try to get localized name components.
    // If unable to find a localized name, use the original name component.
    for (i = 0; i < SYSTEM_NAME_PATH_COUNT; i++) {
        LPCWSTR pwszName;
        LPCWSTR pwszLocalizedName;

        pwszName = pSystemNameInfo->rgpwszName[i];
        if (NULL == pwszName || COMPUTER_NAME_INDEX == i)
            pwszLocalizedName = pwszName;
        else {
            // Returned pwszLocalizedName isn't allocated
            if (NULL == (pwszLocalizedName = CryptFindLocalizedName(
                    pwszName)) || L'\0' == *pwszLocalizedName)
                pwszLocalizedName = pwszName;
        }

        // Before formatting, need to reverse.
        rgpwszLocalizedName[SYSTEM_NAME_PATH_COUNT - 1 - i] =
            pwszLocalizedName;
    }

    NameGroup.cName = SYSTEM_NAME_PATH_COUNT;
    NameGroup.rgpwszName = rgpwszLocalizedName;
    if (NULL == (pwszLocalizedPath = FormatSystemNamePath(1, &NameGroup)))
        goto FormatSystemNamePathError;

    Property.pbData = (BYTE *) pwszLocalizedPath;
    Property.cbData = (wcslen(pwszLocalizedPath) + 1) * sizeof(WCHAR);
    if (!CertSetStoreProperty(
            hCertStore,
            CERT_STORE_LOCALIZED_NAME_PROP_ID,
            0,                                  // dwFlags
            (const void *) &Property
            ))
        goto SetStorePropertyError;

CommonReturn:
    PkiFree(pwszLocalizedPath);
    return;
ErrorReturn:
    goto CommonReturn;
TRACE_ERROR(FormatSystemNamePathError)
TRACE_ERROR(SetStorePropertyError)
}

#ifndef CE_BUILD
//+-------------------------------------------------------------------------
//  For NT, get the formatted SID. For Win95, get the current user name.
//--------------------------------------------------------------------------
STATIC LPWSTR GetCurrentServiceOrUserName()
{
    LPWSTR pwszCurrentService = NULL;

    if (!FIsWinNT()) {
        DWORD cch = _MAX_PATH;
        if (NULL == (pwszCurrentService = (LPWSTR) PkiNonzeroAlloc(
                (cch + 1) * sizeof(WCHAR))))
            goto OutOfMemory;
        if (!GetUserNameU(pwszCurrentService, &cch))
            goto GetUserNameError;
    } else {
        DWORD cch = 256;
        if (NULL == (pwszCurrentService = (LPWSTR) PkiNonzeroAlloc(
                (cch + 1) * sizeof(WCHAR))))
            goto OutOfMemory;
        if (!GetUserTextualSidHKCU(pwszCurrentService, &cch)) {
            if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
                goto GetUserTextualSidHKUCError;
            PkiFree(pwszCurrentService);
            if (NULL == (pwszCurrentService = (LPWSTR) PkiNonzeroAlloc(
                    (cch + 1) * sizeof(WCHAR))))
                goto OutOfMemory;
            if (!GetUserTextualSidHKCU(pwszCurrentService, &cch))
                goto GetUserTextualSidHKUCError;
        }
    }

CommonReturn:
    return pwszCurrentService;

ErrorReturn:
    if (pwszCurrentService)
        wcscpy(pwszCurrentService, DEFAULT_USER_NAME);
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(GetUserNameError)
TRACE_ERROR(GetUserTextualSidHKUCError)
}

//+-------------------------------------------------------------------------
//  For NT and Win95, get the computer name
//--------------------------------------------------------------------------
STATIC LPWSTR GetCurrentComputerName()
{
    LPWSTR pwszCurrentComputer = NULL;
    DWORD cch = _MAX_PATH;
    if (NULL == (pwszCurrentComputer = (LPWSTR) PkiNonzeroAlloc(
            (cch + 1) * sizeof(WCHAR))))
        goto OutOfMemory;
    if (!GetComputerNameU(pwszCurrentComputer, &cch))
        goto GetComputerNameError;

CommonReturn:
    return pwszCurrentComputer;

ErrorReturn:
    PkiFree(pwszCurrentComputer);
    pwszCurrentComputer = NULL;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(GetComputerNameError)
}

#else // CE_BUILD
#define GetCurrentServiceOrUserName() (NULL)
#define GetCurrentComputerName() (NULL)
#endif

//+-------------------------------------------------------------------------
//  Uses the store location in the upper word of dwFlags, the parsed
//  System Name components consisting of: computer, service/user, system and
//  physical names, and the optional SubKey name to open the appropriate
//  registry key. If the Computer name is non-NULL, does a RegConnectRegistry
//  to connect a registry key on a remote computer. If the hKeyBase is
//  non-NULL, does a relocated open instead of using HKCU or HKLM.
//--------------------------------------------------------------------------
STATIC LPWSTR FormatSystemRegPath(
    IN PSYSTEM_NAME_INFO pInfo,
    IN OPTIONAL LPCWSTR pwszSubKeyName,
    IN DWORD dwFlags,
    OUT HKEY *phKey
    )
{
    HKEY hKey = NULL;
    LPWSTR pwszRegPath = NULL;
    LPWSTR pwszCurrentService = NULL;
    DWORD dwStoreLocation;

    SYSTEM_NAME_GROUP rgNameGroup[3];
    DWORD cNameGroup;
    LPCWSTR rgpwszService[3];
    LPCWSTR rgpwszUser[2];
    LPCWSTR rgpwszStore[3];

    if (pwszSubKeyName) {
        cNameGroup = 3;
        rgNameGroup[2].cName = 1;
        rgNameGroup[2].rgpwszName = &pwszSubKeyName;
    } else
        cNameGroup = 2;

    dwStoreLocation = dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK;
    switch (dwStoreLocation) {
        case CERT_SYSTEM_STORE_CURRENT_SERVICE:
        case CERT_SYSTEM_STORE_SERVICES:
            rgNameGroup[0].cName = 3;
            rgNameGroup[0].rgpwszName = rgpwszService;
            rgpwszService[0] = SERVICES_REGPATH;
            rgpwszService[2] = SYSTEM_CERTIFICATES_SUBKEY_NAME;

            if (CERT_SYSTEM_STORE_CURRENT_SERVICE == dwStoreLocation) {
                assert(NULL == pInfo->rgpwszName[COMPUTER_NAME_INDEX]);
                assert(NULL == pInfo->rgpwszName[SERVICE_NAME_INDEX]);
                if (NULL == (pwszCurrentService =
                        GetCurrentServiceOrUserName()))
                    goto GetCurrentServiceNameError;
                rgpwszService[1] = pwszCurrentService;
            } else {
                if (NULL == pInfo->rgpwszName[SERVICE_NAME_INDEX]) {
                    // May be NULL for CertEnumSystemStore
                    assert(NULL == pInfo->rgpwszName[SYSTEM_NAME_INDEX]);
                    assert(NULL == pInfo->rgpwszName[PHYSICAL_NAME_INDEX]);
                    rgNameGroup[0].cName = 1;
                } else
                    rgpwszService[1] = pInfo->rgpwszName[SERVICE_NAME_INDEX];
            }
            break;
        case CERT_SYSTEM_STORE_CURRENT_USER:
        case CERT_SYSTEM_STORE_LOCAL_MACHINE:
            rgpwszUser[0] = SYSTEM_STORE_REGPATH;
            rgNameGroup[0].cName = 1;
            rgNameGroup[0].rgpwszName = rgpwszUser;
            break;
        case CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY:
        case CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY:
            rgpwszUser[0] = GROUP_POLICY_STORE_REGPATH;
            rgNameGroup[0].cName = 1;
            rgNameGroup[0].rgpwszName = rgpwszUser;
            break;
        case CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE:
            rgpwszUser[0] = ENTERPRISE_STORE_REGPATH;
            rgNameGroup[0].cName = 1;
            rgNameGroup[0].rgpwszName = rgpwszUser;
            break;
        case CERT_SYSTEM_STORE_USERS:
            if (NULL == pInfo->rgpwszName[USER_NAME_INDEX]) {
                // May be NULL for CertEnumSystemStore
                assert(NULL == pInfo->rgpwszName[SYSTEM_NAME_INDEX]);
                assert(NULL == pInfo->rgpwszName[PHYSICAL_NAME_INDEX]);
                rgNameGroup[0].cName = 0;
            } else {
                rgpwszUser[0] = pInfo->rgpwszName[USER_NAME_INDEX];
                rgpwszUser[1] = SYSTEM_STORE_REGPATH;
                rgNameGroup[0].cName = 2;
                rgNameGroup[0].rgpwszName = rgpwszUser;
            }
            break;
        default:
            goto InvalidArg;
    }

    rgNameGroup[1].rgpwszName = rgpwszStore;
    rgpwszStore[0] = pInfo->rgpwszName[SYSTEM_NAME_INDEX];
    if (pInfo->rgpwszName[PHYSICAL_NAME_INDEX]) {
        assert(pInfo->rgpwszName[SYSTEM_NAME_INDEX]);
        rgNameGroup[1].cName = 3;
        rgpwszStore[1] = PHYSICAL_STORES_SUBKEY_NAME;
        rgpwszStore[2] = pInfo->rgpwszName[PHYSICAL_NAME_INDEX];
    } else
        rgNameGroup[1].cName = 1;

#ifndef CE_BUILD
    if (pInfo->rgpwszName[COMPUTER_NAME_INDEX]) {
    	LONG err;
        assert(IsRemotableSystemStoreLocationInRegistry(dwFlags));
        assert(NULL == pInfo->hKeyBase);
        if (ERROR_SUCCESS != (err = RegConnectRegistryU(
                pInfo->rgpwszName[COMPUTER_NAME_INDEX],
                (CERT_SYSTEM_STORE_USERS == dwStoreLocation) ?
                    HKEY_USERS : HKEY_LOCAL_MACHINE,
                &hKey)))
            goto RegConnectRegistryError;
    } 
    else 
#endif
    if (pInfo->hKeyBase) {
        assert(dwFlags & CERT_SYSTEM_STORE_RELOCATE_FLAG);
        hKey = pInfo->hKeyBase;
    } else {
        switch (dwStoreLocation) {
            case CERT_SYSTEM_STORE_CURRENT_USER:
            case CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY:
                hKey = HKEY_CURRENT_USER;
                break;
            case CERT_SYSTEM_STORE_LOCAL_MACHINE:
            case CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY:
            case CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE:
            case CERT_SYSTEM_STORE_CURRENT_SERVICE:
            case CERT_SYSTEM_STORE_SERVICES:
                hKey = HKEY_LOCAL_MACHINE;
                break;
            case CERT_SYSTEM_STORE_USERS:
                hKey = HKEY_USERS;
                break;
            default:
                goto InvalidArg;
        }
    }

    if (NULL == (pwszRegPath = FormatSystemNamePath(
            cNameGroup,
            rgNameGroup
            )))
        goto FormatSystemNamePathError;

CommonReturn:
    PkiFree(pwszCurrentService);
    *phKey = hKey;
    return pwszRegPath;
ErrorReturn:
    pwszRegPath = NULL;
    goto CommonReturn;

TRACE_ERROR(GetCurrentServiceNameError)
SET_ERROR(InvalidArg, E_INVALIDARG)
#ifndef CE_BUILD
SET_ERROR_VAR(RegConnectRegistryError, err)
#endif
TRACE_ERROR(FormatSystemNamePathError)
}

STATIC HKEY OpenSystemRegPathKey(
    IN PSYSTEM_NAME_INFO pInfo,
    IN OPTIONAL LPCWSTR pwszSubKeyName,
    IN DWORD dwFlags
    )
{
    LPWSTR pwszRegPath;
    HKEY hKey = NULL;
    HKEY hKeyRegPath;

    if (NULL == (pwszRegPath = FormatSystemRegPath(
            pInfo,
            pwszSubKeyName,
            dwFlags,
            &hKey
            )))
        goto FormatSystemRegPathError;

    hKeyRegPath = OpenSubKey(
        hKey,
        pwszRegPath,
        dwFlags
        );

CommonReturn:
    PkiFree(pwszRegPath);
    if (pInfo->rgpwszName[COMPUTER_NAME_INDEX] && hKey)
        ILS_CloseRegistryKey(hKey);
    return hKeyRegPath;
ErrorReturn:
    hKeyRegPath = NULL;
    goto CommonReturn;

TRACE_ERROR(FormatSystemRegPathError)
}


STATIC HKEY OpenSystemStore(
    IN const void *pvPara,
    IN DWORD dwFlags
    )
{
    HKEY hKey;
    SYSTEM_NAME_INFO SystemNameInfo;

    if (!ParseSystemStorePara(
            pvPara,
            dwFlags,
            1,                  // cReqName
            &SystemNameInfo))   // zero'ed on error
        goto ParseSystemStoreParaError;

    hKey = OpenSystemRegPathKey(
        &SystemNameInfo,
        NULL,               // pwszSubKeyName
        dwFlags
        );

CommonReturn:
    FreeSystemNameInfo(&SystemNameInfo);
    return hKey;
ErrorReturn:
    hKey = NULL;
    goto CommonReturn;
TRACE_ERROR(ParseSystemStoreParaError)
}

STATIC HKEY OpenPhysicalStores(
    IN const void *pvPara,
    IN DWORD dwFlags
    )
{
    HKEY hKey;
    SYSTEM_NAME_INFO SystemNameInfo;

    if (!ParseSystemStorePara(
            pvPara,
            dwFlags,
            1,                  // cReqName
            &SystemNameInfo))   // zero'ed on error
        goto ParseSystemStoreParaError;

    hKey = OpenSystemRegPathKey(
        &SystemNameInfo,
        PHYSICAL_STORES_SUBKEY_NAME,
        dwFlags
        );

CommonReturn:
    FreeSystemNameInfo(&SystemNameInfo);
    return hKey;
ErrorReturn:
    hKey = NULL;
    goto CommonReturn;
TRACE_ERROR(ParseSystemStoreParaError)
}


#ifdef CAPI_INCLUDE_REGISTER_STORE
//+-------------------------------------------------------------------------
//  Register a system store.
//
//  The upper word of the dwFlags parameter is used to specify the location of
//  the system store.
//
//  Set CERT_STORE_CREATE_NEW_FLAG to cause a failure if the system store
//  already exists in the store location.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertRegisterSystemStore(
    IN const void *pvSystemStore,
    IN DWORD dwFlags,
    IN PCERT_SYSTEM_STORE_INFO pStoreInfo,
    IN OPTIONAL void *pvReserved
    )
{
    BOOL fResult;
    HKEY hKey;

    if (!IsSystemStoreLocationInRegistry(dwFlags)) {
        void *pvFuncAddr;
        HCRYPTOIDFUNCADDR hFuncAddr;

        if (!CryptGetOIDFunctionAddress(
                rghFuncSet[REGISTER_SYSTEM_STORE_FUNC_SET],
                0,                      // dwEncodingType,
                GetSystemStoreLocationOID(dwFlags),
                0,                      // dwFlags
                &pvFuncAddr,
                &hFuncAddr))
            return FALSE;

        fResult = ((PFN_REGISTER_SYSTEM_STORE) pvFuncAddr)(
            pvSystemStore,
            dwFlags,
            pStoreInfo,
            pvReserved
            );
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
        return fResult;
    }

    if (dwFlags & ~REGISTER_FLAGS_MASK)
        goto InvalidArg;

    if (NULL == (hKey = OpenSystemStore(pvSystemStore, dwFlags)))
        goto OpenSystemStoreError;
    RegCloseKey(hKey);
    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(OpenSystemStoreError)
}

//+-------------------------------------------------------------------------
//  Register a physical store for the specified system store.
//
//  The upper word of the dwFlags parameter is used to specify the location of
//  the system store.
//
//  Set CERT_STORE_CREATE_NEW_FLAG to cause a failure if the physical store
//  already exists in the system store.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertRegisterPhysicalStore(
    IN const void *pvSystemStore,
    IN DWORD dwFlags,
    IN LPCWSTR pwszStoreName,
    IN PCERT_PHYSICAL_STORE_INFO pStoreInfo,
    IN OPTIONAL void *pvReserved
    )
{
    BOOL fResult;
    LONG err;
    HKEY hKey = NULL;

    SYSTEM_NAME_INFO SystemNameInfo;

    char szOID[34];
    LPCSTR pszOID;

    if (!IsSystemStoreLocationInRegistry(dwFlags)) {
        void *pvFuncAddr;
        HCRYPTOIDFUNCADDR hFuncAddr;

        if (!CryptGetOIDFunctionAddress(
                rghFuncSet[REGISTER_PHYSICAL_STORE_FUNC_SET],
                0,                      // dwEncodingType,
                GetSystemStoreLocationOID(dwFlags),
                0,                      // dwFlags
                &pvFuncAddr,
                &hFuncAddr))
            return FALSE;

        fResult = ((PFN_REGISTER_PHYSICAL_STORE) pvFuncAddr)(
            pvSystemStore,
            dwFlags,
            pwszStoreName,
            pStoreInfo,
            pvReserved
            );
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
        return fResult;
    }

    if (!ParseSystemStorePara(
            pvSystemStore,
            dwFlags,
            1,                  // cReqName
            &SystemNameInfo))   // zero'ed on error
        goto ParseSystemStoreParaError;

    if (NULL == pwszStoreName || L'\0' == *pwszStoreName ||
            HasBackslash(pwszStoreName))
        goto InvalidArg;
    assert(SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX]);
    assert(NULL == SystemNameInfo.rgpwszName[PHYSICAL_NAME_INDEX]);
    SystemNameInfo.rgpwszName[PHYSICAL_NAME_INDEX] = (LPWSTR) pwszStoreName;

    if (dwFlags & ~REGISTER_FLAGS_MASK)
        goto InvalidArg;

    if (NULL == pStoreInfo ||
            sizeof(CERT_PHYSICAL_STORE_INFO) > pStoreInfo->cbSize)
        goto InvalidArg;

    if (NULL == (hKey = OpenSystemRegPathKey(
            &SystemNameInfo,
            NULL,               // pwszSubKeyName
            dwFlags
            )))
        goto OpenSystemRegPathKeyError;

    pszOID = pStoreInfo->pszOpenStoreProvider;
    if (0xFFFF >= (DWORD_PTR) pszOID) {
        // Convert to "#<number>" string
        szOID[0] = CONST_OID_STR_PREFIX_CHAR;
        _ltoa((long) ((DWORD_PTR) pszOID), szOID + 1, 10);
        pszOID = szOID;
    }
    if (ERROR_SUCCESS != (err = RegSetValueExA(
            hKey,
            "OpenStoreProvider",
            0,          // dwReserved
            REG_SZ,
            (BYTE *) pszOID,
            strlen(pszOID) + 1)))
        goto RegSetOpenStoreProviderError;

    if (!WriteDWORDValueToRegistry(
            hKey,
            L"OpenEncodingType",
            pStoreInfo->dwOpenEncodingType))
        goto WriteDWORDError;
    if (!WriteDWORDValueToRegistry(
            hKey,
            L"OpenFlags",
            pStoreInfo->dwOpenFlags))
        goto WriteDWORDError;

    if (ERROR_SUCCESS != (err = RegSetValueExU(
            hKey,
            L"OpenParameters",
            0,          // dwReserved
            REG_BINARY,
            pStoreInfo->OpenParameters.pbData,
            pStoreInfo->OpenParameters.cbData)))
        goto RegSetOpenParametersError;

    if (!WriteDWORDValueToRegistry(
            hKey,
            L"Flags",
            pStoreInfo->dwFlags))
        goto WriteDWORDError;
    if (!WriteDWORDValueToRegistry(
            hKey,
            L"Priority",
            pStoreInfo->dwPriority))
        goto WriteDWORDError;

    fResult = TRUE;

CommonReturn:
    SystemNameInfo.rgpwszName[PHYSICAL_NAME_INDEX] = NULL;   // not allocated
    FreeSystemNameInfo(&SystemNameInfo);
    ILS_CloseRegistryKey(hKey);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(ParseSystemStoreParaError)
TRACE_ERROR(OpenSystemRegPathKeyError)
SET_ERROR_VAR(RegSetOpenStoreProviderError, err)
SET_ERROR_VAR(RegSetOpenParametersError, err)
TRACE_ERROR(WriteDWORDError)
}

#endif // CAPI_INCLUDE_REGISTER_STORE
// 
// Unregister functions used by CERT_DELETE_STORE

//+-------------------------------------------------------------------------
//  Unregister the specified system store.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertUnregisterSystemStore(
    IN const void *pvSystemStore,
    IN DWORD dwFlags
    )
{
    BOOL fResult;
    HKEY hKey = NULL;
    SYSTEM_NAME_INFO SystemNameInfo;
    LPWSTR pwszStore;       // not allocated

    if (!IsSystemStoreLocationInRegistry(dwFlags)) {
        void *pvFuncAddr;
        HCRYPTOIDFUNCADDR hFuncAddr;

        if (!CryptGetOIDFunctionAddress(
                rghFuncSet[UNREGISTER_SYSTEM_STORE_FUNC_SET],
                0,                      // dwEncodingType,
                GetSystemStoreLocationOID(dwFlags),
                0,                      // dwFlags
                &pvFuncAddr,
                &hFuncAddr))
            return FALSE;

        fResult = ((PFN_UNREGISTER_SYSTEM_STORE) pvFuncAddr)(
            pvSystemStore,
            dwFlags
            );
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
        return fResult;
    }

    if (!ParseSystemStorePara(
            pvSystemStore,
            dwFlags,
            1,                      // cReqName
            &SystemNameInfo))       // zero'ed on error
        goto ParseSystemStoreParaError;

    if (dwFlags & ~UNREGISTER_FLAGS_MASK)
        goto InvalidArg;

    // Delete the SystemRegistry components
    if (NULL == (hKey = OpenSystemRegPathKey(
            &SystemNameInfo,
            NULL,                   // pwszSubKeyName
            dwFlags | CERT_STORE_OPEN_EXISTING_FLAG
            )))
        goto OpenSystemRegPathKeyError;
    if (!DeleteAllFromRegistry(
            hKey,
            SystemNameInfo.rgpwszName[COMPUTER_NAME_INDEX] ?
                    CERT_REGISTRY_STORE_REMOTE_FLAG : 0
            ))
        goto DeleteAllError;

    RegCloseKey(hKey);
    hKey = NULL;

    // Open SystemCertificates SubKey preceding the store. In order to do this
    // the SYSTEM_NAME component must be NULL.
    assert(SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX]);
    pwszStore = SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX];
    SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX] = NULL;
    hKey = OpenSystemRegPathKey(
            &SystemNameInfo,
            NULL,                   // pwszSubKeyName
            dwFlags | CERT_STORE_OPEN_EXISTING_FLAG
            );
    SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX] = pwszStore;
    if (NULL == hKey)
        goto OpenSystemRegPathKeyError;

    // Delete the remaining System components (such as PhysicalStores) and
    // the System store itself
    if (!RecursiveDeleteSubKey(hKey, pwszStore))
        goto DeleteSubKeyError;
    fResult = TRUE;

CommonReturn:
    FreeSystemNameInfo(&SystemNameInfo);
    ILS_CloseRegistryKey(hKey);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(ParseSystemStoreParaError)
SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(DeleteAllError)
TRACE_ERROR(OpenSystemRegPathKeyError)
TRACE_ERROR(DeleteSubKeyError)
}

//+-------------------------------------------------------------------------
//  Unregister the physical store from the specified system store.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertUnregisterPhysicalStore(
    IN const void *pvSystemStore,
    IN DWORD dwFlags,
    IN LPCWSTR pwszStoreName
    )
{
    BOOL fResult;
    HKEY hKey = NULL;
    LPWSTR pwszSubKeyName = NULL;

    if (!IsSystemStoreLocationInRegistry(dwFlags)) {
        void *pvFuncAddr;
        HCRYPTOIDFUNCADDR hFuncAddr;

        if (!CryptGetOIDFunctionAddress(
                rghFuncSet[UNREGISTER_PHYSICAL_STORE_FUNC_SET],
                0,                      // dwEncodingType,
                GetSystemStoreLocationOID(dwFlags),
                0,                      // dwFlags
                &pvFuncAddr,
                &hFuncAddr))
            return FALSE;

        fResult = ((PFN_UNREGISTER_PHYSICAL_STORE) pvFuncAddr)(
            pvSystemStore,
            dwFlags,
            pwszStoreName
            );
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
        return fResult;
    }

    if (dwFlags & ~UNREGISTER_FLAGS_MASK)
        goto InvalidArg;

    if (NULL == (hKey = OpenPhysicalStores(
            pvSystemStore,
            dwFlags | CERT_STORE_OPEN_EXISTING_FLAG
            )))
        goto OpenPhysicalStoresError;
    if (!RecursiveDeleteSubKey(hKey, pwszStoreName))
        goto DeleteSubKeyError;
    fResult = TRUE;

CommonReturn:
    ILS_CloseRegistryKey(hKey);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(OpenPhysicalStoresError)
TRACE_ERROR(DeleteSubKeyError)
}


typedef struct _ENUM_REGISTERED_SYSTEM_STORE_LOCATION_INFO {
    DWORD                               dwLastError;
    void                                *pvArg;
    PFN_CERT_ENUM_SYSTEM_STORE_LOCATION pfnEnum;
} ENUM_REGISTERED_SYSTEM_STORE_LOCATION_INFO,
    *PENUM_REGISTERED_SYSTEM_STORE_LOCATION_INFO;

#ifdef CAPI_INCLUDE_REGISTER_OID
STATIC BOOL WINAPI EnumRegisteredSystemStoreLocationCallback(
    IN DWORD dwEncodingType,
    IN LPCSTR pszFuncName,
    IN LPCSTR pszOID,
    IN DWORD cValue,
    IN const DWORD rgdwValueType[],
    IN LPCWSTR const rgpwszValueName[],
    IN const BYTE * const rgpbValueData[],
    IN const DWORD rgcbValueData[],
    IN void *pvArg
    )
{
    PENUM_REGISTERED_SYSTEM_STORE_LOCATION_INFO pEnumRegisteredInfo =
        (PENUM_REGISTERED_SYSTEM_STORE_LOCATION_INFO) pvArg;

    LPCWSTR pwszLocation = L"";
    DWORD dwFlags;

    if (0 != pEnumRegisteredInfo->dwLastError)
        return FALSE;

    if (CONST_OID_STR_PREFIX_CHAR != *pszOID)
        return TRUE;
    dwFlags =
        (((DWORD) atol(pszOID + 1)) << CERT_SYSTEM_STORE_LOCATION_SHIFT) &
            CERT_SYSTEM_STORE_LOCATION_MASK;
    if (0 == dwFlags)
        return TRUE;

    // Try to find the SystemStoreLocation value
    while (cValue--) {
        if (0 == _wcsicmp(rgpwszValueName[cValue],
                    CRYPT_OID_SYSTEM_STORE_LOCATION_VALUE_NAME) &&
                REG_SZ == rgdwValueType[cValue]) {
            pwszLocation = (LPCWSTR) rgpbValueData[cValue];
            break;
        }
    }

    if (!pEnumRegisteredInfo->pfnEnum(
            pwszLocation,
            dwFlags,
            NULL,                                       // pvReserved
            pEnumRegisteredInfo->pvArg
            )) {
        if (0 == (pEnumRegisteredInfo->dwLastError = GetLastError()))
            pEnumRegisteredInfo->dwLastError = (DWORD) E_UNEXPECTED;
        return FALSE;
    } else
        return TRUE;
}

#endif
//+-------------------------------------------------------------------------
//  Enumerate the system store locations.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertEnumSystemStoreLocation(
    IN DWORD dwFlags,
    IN void *pvArg,
    IN PFN_CERT_ENUM_SYSTEM_STORE_LOCATION pfnEnum
    )
{
    DWORD i;
    ENUM_REGISTERED_SYSTEM_STORE_LOCATION_INFO EnumRegisteredInfo;

    if (dwFlags & ~ENUM_FLAGS_MASK) {
        SetLastError((DWORD) E_INVALIDARG);
        return FALSE;
    }

    // Enumerate through the predefined, crypt32.dll system store locations
    for (i = 0; i < ENUM_SYSTEM_STORE_LOCATION_CNT; i++) {
        if (!pfnEnum(
                rgEnumSystemStoreLocationInfo[i].pwszLocation,
                rgEnumSystemStoreLocationInfo[i].dwFlags,
                NULL,                                       // pvReserved
                pvArg
                ))
            return FALSE;
    }

    // Enumerate through the registered system store locations
    EnumRegisteredInfo.dwLastError = 0;
    EnumRegisteredInfo.pvArg = pvArg;
    EnumRegisteredInfo.pfnEnum = pfnEnum;
#ifdef CAPI_INCLUDE_REGISTER_OID
    CryptEnumOIDFunction(
            0,                              // dwEncodingType
            CRYPT_OID_ENUM_SYSTEM_STORE_FUNC,
            NULL,                           // pszOID
            0,                              // dwFlags
            (void *) &EnumRegisteredInfo,   // pvArg
            EnumRegisteredSystemStoreLocationCallback
            );
#endif //CAPI_INCLUDE_REGISTER_OID
    if (0 != EnumRegisteredInfo.dwLastError) {
        SetLastError(EnumRegisteredInfo.dwLastError);
        return FALSE;
    } else
        return TRUE;
}

STATIC BOOL EnumServicesOrUsersSystemStore(
    IN OUT PSYSTEM_NAME_INFO pLocationNameInfo,
    IN DWORD dwFlags,
    IN void *pvArg,
    IN PFN_CERT_ENUM_SYSTEM_STORE pfnEnum
    )
{
    BOOL fResult;
    HKEY hKey = NULL;
    DWORD cSubKeys;
    DWORD cchMaxSubKey;
    LPWSTR pwszEnumServiceName = NULL;
    void *pvEnumServicePara = NULL;
    BOOL fDidEnum;

    assert(NULL == pLocationNameInfo->rgpwszName[SERVICE_NAME_INDEX]);

    // Opens ..\Cryptography\Services SubKey or HKEY_USERS SubKey
    if (NULL == (hKey = OpenSystemRegPathKey(
            pLocationNameInfo,
            NULL,               // pwszSubKeyName
            dwFlags | CERT_STORE_OPEN_EXISTING_FLAG | CERT_STORE_READONLY_FLAG
            )))
        goto OpenSystemRegPathKeyError;

    if (!GetSubKeyInfo(
            hKey,
            &cSubKeys,
            &cchMaxSubKey
            ))
        goto GetSubKeyInfoError;

    // Enumerates the ServiceOrUserNames
    fDidEnum = FALSE;
    if (cSubKeys && cchMaxSubKey) {
        DWORD i;

        LPCWSTR rgpwszEnumName[2];
        SYSTEM_NAME_GROUP EnumNameGroup;
        EnumNameGroup.cName = 2;
        EnumNameGroup.rgpwszName = rgpwszEnumName;

        cchMaxSubKey++;
        if (NULL == (pwszEnumServiceName = (LPWSTR) PkiNonzeroAlloc(
                cchMaxSubKey * sizeof(WCHAR))))
            goto OutOfMemory;

        rgpwszEnumName[0] = pLocationNameInfo->rgpwszName[COMPUTER_NAME_INDEX];
        rgpwszEnumName[1] = pwszEnumServiceName;

        for (i = 0; i < cSubKeys; i++) {
            DWORD cchEnumServiceName = cchMaxSubKey;
            LONG err;
            if (ERROR_SUCCESS != (err = RegEnumKeyExU(
                    hKey,
                    i,
                    pwszEnumServiceName,
                    &cchEnumServiceName,
                    NULL,               // lpdwReserved
                    NULL,               // lpszClass
                    NULL,               // lpcchClass
                    NULL                // lpftLastWriteTime
                    )) || 0 == cchEnumServiceName ||
                            L'\0' == *pwszEnumServiceName)
                continue;
            if (NULL == (pvEnumServicePara = FormatSystemNamePara(
                        1, &EnumNameGroup, pLocationNameInfo)))
                goto FormatSystemNameParaError;

            if (!CertEnumSystemStore(
                    dwFlags,
                    pvEnumServicePara,
                    pvArg,
                    pfnEnum
                    )) {
                if (ERROR_FILE_NOT_FOUND != GetLastError())
                    goto EnumSystemStoreError;
            } else
                fDidEnum = TRUE;
            FreeSystemNamePara(pvEnumServicePara, pLocationNameInfo);
            pvEnumServicePara = NULL;
        }
    }

    if (!fDidEnum)
        goto NoSystemStores;
    fResult = TRUE;
CommonReturn:
    ILS_CloseRegistryKey(hKey);
    PkiFree(pwszEnumServiceName);
    FreeSystemNamePara(pvEnumServicePara, pLocationNameInfo);
    FreeSystemNameInfo(pLocationNameInfo);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OpenSystemRegPathKeyError)
TRACE_ERROR(GetSubKeyInfoError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(FormatSystemNameParaError)
TRACE_ERROR(EnumSystemStoreError)
SET_ERROR(NoSystemStores, ERROR_FILE_NOT_FOUND)
}

//+-------------------------------------------------------------------------
//  Enumerate the system stores.
//
//  The upper word of the dwFlags parameter is used to specify the location of
//  the system store.
//
//  All registry based system store locations have the predefined stores
//  of: My, Root, Trust and CA.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertEnumSystemStore(
    IN DWORD dwFlags,
    IN OPTIONAL void *pvSystemStoreLocationPara,
    IN void *pvArg,
    IN PFN_CERT_ENUM_SYSTEM_STORE pfnEnum
    )
{
    BOOL fResult;
    HKEY hKey = NULL;
    DWORD cSubKeys;
    DWORD cchMaxSubKey;
    SYSTEM_NAME_INFO LocationNameInfo;
    LPWSTR pwszEnumSystemStore = NULL;
    void *pvEnumSystemPara = NULL;

    DWORD i;
    DWORD dwCheckFlag;
    DWORD dwLocID;
    DWORD dwPredefinedSystemFlags;

    CERT_SYSTEM_STORE_INFO NullSystemStoreInfo;
    LPCWSTR rgpwszEnumName[3];
    SYSTEM_NAME_GROUP EnumNameGroup;

    if (!IsSystemStoreLocationInRegistry(dwFlags)) {
        void *pvFuncAddr;
        HCRYPTOIDFUNCADDR hFuncAddr;

        if (!CryptGetOIDFunctionAddress(
                rghFuncSet[ENUM_SYSTEM_STORE_FUNC_SET],
                0,                      // dwEncodingType,
                GetSystemStoreLocationOID(dwFlags),
                0,                      // dwFlags
                &pvFuncAddr,
                &hFuncAddr))
            return FALSE;

        fResult = ((PFN_ENUM_SYSTEM_STORE) pvFuncAddr)(
            dwFlags,
            pvSystemStoreLocationPara,
            pvArg,
            pfnEnum
            );
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
        return fResult;
    }

    if (!ParseSystemStorePara(
            pvSystemStoreLocationPara,
            dwFlags,
            0,                  // cReqName, none for enumeration
            &LocationNameInfo   // zero'ed for error
            ))
        goto ParseSystemStoreParaError;

    if (dwFlags & ~ENUM_FLAGS_MASK)
        goto InvalidArg;

    dwLocID = GetSystemStoreLocationID(dwFlags);
    if ((CERT_SYSTEM_STORE_SERVICES_ID == dwLocID ||
             CERT_SYSTEM_STORE_USERS_ID == dwLocID)
                                &&
            NULL == LocationNameInfo.rgpwszName[SERVICE_NAME_INDEX])
        // Following frees rgpwszLocationName entries
        return EnumServicesOrUsersSystemStore(
            &LocationNameInfo,
            dwFlags,
            pvArg,
            pfnEnum
            );

    // Opens SystemCertificates subkey
    if (NULL == (hKey = OpenSystemRegPathKey(
            &LocationNameInfo,
            NULL,               // pwszSubKeyName
            dwFlags | CERT_STORE_OPEN_EXISTING_FLAG | CERT_STORE_READONLY_FLAG
            ))) {
        if (ERROR_FILE_NOT_FOUND != GetLastError())
            goto OpenSystemRegPathKeyError;

        // Note, a registry entry isn't needed for the predefined stores
        cSubKeys = 0;
    } else if (!GetSubKeyInfo(
            hKey,
            &cSubKeys,
            &cchMaxSubKey
            ))
        goto GetSubKeyInfoError;

    memset(&NullSystemStoreInfo, 0, sizeof(NullSystemStoreInfo));
    NullSystemStoreInfo.cbSize = sizeof(NullSystemStoreInfo);
    EnumNameGroup.cName = 3;
    EnumNameGroup.rgpwszName = rgpwszEnumName;
    rgpwszEnumName[0] = LocationNameInfo.rgpwszName[COMPUTER_NAME_INDEX];
    rgpwszEnumName[1] = LocationNameInfo.rgpwszName[SERVICE_NAME_INDEX];

    // Enumerate the predefined system stores.
    assert(NUM_SYSTEM_STORE_LOCATION > dwLocID);
    dwPredefinedSystemFlags =
        rgSystemStoreLocationInfo[dwLocID].dwPredefinedSystemFlags;
    for (i = 0, dwCheckFlag = 1; i < NUM_PREDEFINED_SYSTEM_STORE;
                                        i++, dwCheckFlag = dwCheckFlag << 1) {
        if (0 == (dwCheckFlag & dwPredefinedSystemFlags))
            continue;
        rgpwszEnumName[2] = rgpwszPredefinedSystemStore[i];
        if (NULL == (pvEnumSystemPara = FormatSystemNamePara(
                1, &EnumNameGroup, &LocationNameInfo)))
            goto FormatSystemNameParaError;
        if (!pfnEnum(
                pvEnumSystemPara,
                dwFlags & CERT_SYSTEM_STORE_MASK,
                &NullSystemStoreInfo,
                NULL,               // pvReserved
                pvArg
                ))
            goto EnumCallbackError;
        FreeSystemNamePara(pvEnumSystemPara, &LocationNameInfo);
        pvEnumSystemPara = NULL;
    }

    // Enumerate the registered systems stores. Skip past any of the above
    // predefined stores
    if (cSubKeys && cchMaxSubKey) {
        cchMaxSubKey++;
        if (NULL == (pwszEnumSystemStore = (LPWSTR) PkiNonzeroAlloc(
                cchMaxSubKey * sizeof(WCHAR))))
            goto OutOfMemory;

        rgpwszEnumName[2] = pwszEnumSystemStore;

        for (i = 0; i < cSubKeys; i++) {
            DWORD cchEnumSystemStore = cchMaxSubKey;
            if (ERROR_SUCCESS != RegEnumKeyExU(
                    hKey,
                    i,
                    pwszEnumSystemStore,
                    &cchEnumSystemStore,
                    NULL,               // lpdwReserved
                    NULL,               // lpszClass
                    NULL,               // lpcchClass
                    NULL                // lpftLastWriteTime
                    ) || 0 == cchEnumSystemStore)
                continue;
            if (IsPredefinedSystemStore(pwszEnumSystemStore, dwFlags))
                // Already enumerated above
                continue;
            if (NULL == (pvEnumSystemPara = FormatSystemNamePara(
                        1, &EnumNameGroup, &LocationNameInfo)))
                goto FormatSystemNameParaError;

            if (!pfnEnum(
                    pvEnumSystemPara,
                    dwFlags & CERT_SYSTEM_STORE_MASK,
                    &NullSystemStoreInfo,
                    NULL,               // pvReserved
                    pvArg
                    ))
                goto EnumCallbackError;
            FreeSystemNamePara(pvEnumSystemPara, &LocationNameInfo);
            pvEnumSystemPara = NULL;
        }
    }

    fResult = TRUE;
CommonReturn:
    ILS_CloseRegistryKey(hKey);
    PkiFree(pwszEnumSystemStore);
    FreeSystemNamePara(pvEnumSystemPara, &LocationNameInfo);
    FreeSystemNameInfo(&LocationNameInfo);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(ParseSystemStoreParaError)
SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(OpenSystemRegPathKeyError)
TRACE_ERROR(GetSubKeyInfoError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(FormatSystemNameParaError)
TRACE_ERROR(EnumCallbackError)
}

typedef struct _ENUM_PHYSICAL_STORE_INFO ENUM_PHYSICAL_STORE_INFO,
    *PENUM_PHYSICAL_STORE_INFO;
struct _ENUM_PHYSICAL_STORE_INFO {
    CERT_PHYSICAL_STORE_INFO    RegistryInfo;
    LPWSTR                      pwszStoreName;
    PENUM_PHYSICAL_STORE_INFO   pNext;
};

STATIC void FreeEnumPhysicalStoreInfo(
    IN PENUM_PHYSICAL_STORE_INFO pStoreInfo
    )
{
    PCERT_PHYSICAL_STORE_INFO pRegistryInfo = &pStoreInfo->RegistryInfo;
    PkiFree(pRegistryInfo->OpenParameters.pbData);
    PkiFree(pRegistryInfo->pszOpenStoreProvider);
    PkiFree(pStoreInfo->pwszStoreName);
    PkiFree(pStoreInfo);
}


STATIC PENUM_PHYSICAL_STORE_INFO GetEnumPhysicalStoreInfo(
    IN HKEY hKey,
    IN LPCWSTR pwszStoreName
    )
{
    LONG err;
    HKEY hSubKey = NULL;
    PENUM_PHYSICAL_STORE_INFO pStoreInfo;
    PCERT_PHYSICAL_STORE_INFO pRegistryInfo;        // not allocated

    if (NULL == (pStoreInfo = (PENUM_PHYSICAL_STORE_INFO) PkiZeroAlloc(
            sizeof(ENUM_PHYSICAL_STORE_INFO))))
        return NULL;
    pRegistryInfo = &pStoreInfo->RegistryInfo;
    pRegistryInfo->cbSize = sizeof(*pRegistryInfo);

    if (NULL == (pStoreInfo->pwszStoreName =
            AllocAndCopyString(pwszStoreName)))
        goto OutOfMemory;

    if (ERROR_SUCCESS != (err = RegOpenKeyExU(
            hKey,
            pwszStoreName,
            0,                      // dwReserved
            KEY_READ,
            &hSubKey)))
        goto RegOpenKeyError;

    if (!ILS_ReadBINARYValueFromRegistry(
            hSubKey,
            L"OpenParameters",
            &pRegistryInfo->OpenParameters.pbData,
            &pRegistryInfo->OpenParameters.cbData
            )) {
        LPWSTR pwszParameters;
        if (pwszParameters = ReadSZValueFromRegistry(
                hSubKey,
                L"OpenParameters"
                )) {
            pRegistryInfo->OpenParameters.pbData = (BYTE *) pwszParameters;
            pRegistryInfo->OpenParameters.cbData =
                (wcslen(pwszParameters) + 1) * sizeof(WCHAR);
        } else {
            // Default to empty string
            if (NULL == (pRegistryInfo->OpenParameters.pbData =
                    (BYTE *) AllocAndCopyString(L"")))
                goto OutOfMemory;
            pRegistryInfo->OpenParameters.cbData = 0;
        }
    }

#ifdef CE_BUILD
	// doesnt make sense why pszOpenStoreProvider is LPSTR and not LPWSTR
	{
	LPWSTR pwsz;
	CHAR szTemp[MAX_PATH];
	size_t len;
	pRegistryInfo->pszOpenStoreProvider = NULL;       
	if (NULL == (pwsz = ReadSZValueFromRegistry(
            hSubKey,
            L"OpenStoreProvider"
            )))
         
        goto NoOpenStoreProviderError;
	len = wcstombs(szTemp,pwsz,sizeof(szTemp));
	memcpy(pwsz,szTemp,len+1);
	pRegistryInfo->pszOpenStoreProvider = (LPSTR)pwsz;
	}
    
#else
	if (NULL == (pRegistryInfo->pszOpenStoreProvider = ReadSZValueFromRegistry(
            hSubKey,
            "OpenStoreProvider"
            )))
        goto NoOpenStoreProviderError;

#endif        

    ILS_ReadDWORDValueFromRegistry(
        hSubKey,
        L"OpenFlags",
        &pRegistryInfo->dwOpenFlags
        );

    ILS_ReadDWORDValueFromRegistry(
        hSubKey,
        L"OpenEncodingType",
        &pRegistryInfo->dwOpenEncodingType
        );

    ILS_ReadDWORDValueFromRegistry(
        hSubKey,
        L"Flags",
        &pRegistryInfo->dwFlags
        );

    ILS_ReadDWORDValueFromRegistry(
        hSubKey,
        L"Priority",
        &pRegistryInfo->dwPriority
        );

CommonReturn:
    ILS_CloseRegistryKey(hSubKey);
    return pStoreInfo;
ErrorReturn:
    FreeEnumPhysicalStoreInfo(pStoreInfo);
    pStoreInfo = NULL;
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
SET_ERROR_VAR(RegOpenKeyError, err)
TRACE_ERROR(NoOpenStoreProviderError)
}


STATIC BOOL IsSelfPhysicalStoreInfo(
    IN PSYSTEM_NAME_INFO pSystemNameInfo,
    IN DWORD dwFlags,
    IN PCERT_PHYSICAL_STORE_INFO pStoreInfo,
    OUT DWORD *pdwSystemProviderFlags
    )
{
    BOOL fResult;
    DWORD dwSystemProviderFlags;
    LPWSTR pwszStoreName = (LPWSTR) pStoreInfo->OpenParameters.pbData;
    SYSTEM_NAME_INFO StoreNameInfo;

    LPWSTR pwszCurrentServiceName = NULL;
    LPWSTR pwszCurrentComputerName = NULL;

    DWORD dwSystemLocation;
    DWORD dwInfoLocation;
    BOOL fSameLocation;

    *pdwSystemProviderFlags = 0;

    dwSystemLocation = dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK;
    // Note, if the RELOCATE_FLAG is incorrectly set in the dwOpenFlags
    // then, never match
    dwInfoLocation = pStoreInfo->dwOpenFlags &
        (CERT_SYSTEM_STORE_LOCATION_MASK | CERT_SYSTEM_STORE_RELOCATE_FLAG);


    // Check if in same system store location
    fSameLocation = (dwSystemLocation == dwInfoLocation);
    if (!fSameLocation) {
        if (CERT_SYSTEM_STORE_CURRENT_SERVICE == dwInfoLocation)
            dwInfoLocation = CERT_SYSTEM_STORE_SERVICES;
        if (CERT_SYSTEM_STORE_CURRENT_SERVICE == dwSystemLocation)
            dwSystemLocation = CERT_SYSTEM_STORE_SERVICES;
        if (CERT_SYSTEM_STORE_CURRENT_USER == dwInfoLocation)
            dwInfoLocation = CERT_SYSTEM_STORE_USERS;
        if (CERT_SYSTEM_STORE_CURRENT_USER == dwSystemLocation)
            dwSystemLocation = CERT_SYSTEM_STORE_USERS;

        if (dwSystemLocation != dwInfoLocation)
            return FALSE;
    }

    // Check if SYSTEM or SYSTEM_REGISTRY store.
    dwSystemProviderFlags = GetSystemProviderFlags(
        pStoreInfo->pszOpenStoreProvider);
    if (0 == dwSystemProviderFlags ||
            (dwSystemProviderFlags & PHYSICAL_PROVIDER_FLAG))
        return FALSE;

    if (dwSystemProviderFlags & ASCII_SYSTEM_PROVIDER_FLAG) {
        if (NULL == (pwszStoreName = MkWStr((LPSTR) pwszStoreName)))
            return FALSE;
    }

    if (!ParseSystemStorePara(
            pwszStoreName,
            pStoreInfo->dwOpenFlags,
            1,                  // cReq, 1 for OpenSystemStore
            &StoreNameInfo      // zero'ed for error
            ))
        goto ParseSystemStoreParaError;

    // Default to not self
    fResult = FALSE;

    if (StoreNameInfo.rgpwszName[COMPUTER_NAME_INDEX]) {
        if (NULL == pSystemNameInfo->rgpwszName[COMPUTER_NAME_INDEX]) {
            LPCWSTR pwszStoreComputerName;

            if (NULL == (pwszCurrentComputerName = GetCurrentComputerName()))
                goto GetCurrentComputerNameError;

            pwszStoreComputerName =
                StoreNameInfo.rgpwszName[COMPUTER_NAME_INDEX];
            assert(L'\\' == pwszStoreComputerName[0] &&
                L'\\' == pwszStoreComputerName[1]);
            if (!('\\' == pwszCurrentComputerName[0] &&
                    L'\\' == pwszCurrentComputerName[1]))
                pwszStoreComputerName += 2;
            if (0 != _wcsicmp(pwszStoreComputerName, pwszCurrentComputerName))
                goto CommonReturn;
        } else if (0 != _wcsicmp(StoreNameInfo.rgpwszName[COMPUTER_NAME_INDEX],
                pSystemNameInfo->rgpwszName[COMPUTER_NAME_INDEX]))
            goto CommonReturn;
    }
    // else
    //  Opening using none or the same computer name

    if (StoreNameInfo.rgpwszName[SERVICE_NAME_INDEX]) {
        if (NULL == pSystemNameInfo->rgpwszName[SERVICE_NAME_INDEX]) {
            if (NULL == (pwszCurrentServiceName =
                    GetCurrentServiceOrUserName()))
                goto GetCurrentServiceOrUserNameError;
            if (0 != _wcsicmp(StoreNameInfo.rgpwszName[SERVICE_NAME_INDEX],
                    pwszCurrentServiceName))
                goto CommonReturn;
        } else if (0 != _wcsicmp(StoreNameInfo.rgpwszName[SERVICE_NAME_INDEX],
                pSystemNameInfo->rgpwszName[SERVICE_NAME_INDEX]))
            goto CommonReturn;
    }
    // else
    //  Opening using none or the same service/user name

    assert(StoreNameInfo.rgpwszName[SYSTEM_NAME_INDEX] &&
         pSystemNameInfo->rgpwszName[SYSTEM_NAME_INDEX]);
    if (0 != _wcsicmp(StoreNameInfo.rgpwszName[SYSTEM_NAME_INDEX],
            pSystemNameInfo->rgpwszName[SYSTEM_NAME_INDEX]))
        goto CommonReturn;

    // We have a match !!!
    fResult = TRUE;
    *pdwSystemProviderFlags = dwSystemProviderFlags;

CommonReturn:
    if (dwSystemProviderFlags & ASCII_SYSTEM_PROVIDER_FLAG)
        FreeWStr(pwszStoreName);
    FreeSystemNameInfo(&StoreNameInfo);
    PkiFree(pwszCurrentServiceName);
    PkiFree(pwszCurrentComputerName);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetCurrentComputerNameError)
TRACE_ERROR(GetCurrentServiceOrUserNameError)
TRACE_ERROR(ParseSystemStoreParaError)
}

// List is sorted according to physical store priority
STATIC void AddToEnumPhysicalStoreList(
    IN PENUM_PHYSICAL_STORE_INFO *ppStoreInfoHead,
    IN PENUM_PHYSICAL_STORE_INFO pAddInfo
    )
{

    if (NULL == *ppStoreInfoHead)
        *ppStoreInfoHead = pAddInfo;
    else {
        PENUM_PHYSICAL_STORE_INFO pListInfo;
        DWORD dwPriority = pAddInfo->RegistryInfo.dwPriority;

        pListInfo = *ppStoreInfoHead;
        if (dwPriority > pListInfo->RegistryInfo.dwPriority) {
            // Insert at beginning before first entry
            pAddInfo->pNext = pListInfo;
            *ppStoreInfoHead = pAddInfo;
        } else {
            // Insert after the entry whose next entry has
            // lower priority or insert after the last entry
            while (pListInfo->pNext &&
                    dwPriority <= pListInfo->pNext->RegistryInfo.dwPriority)
                pListInfo = pListInfo->pNext;

            pAddInfo->pNext = pListInfo->pNext;
            pListInfo->pNext = pAddInfo;
        }
    }
}


STATIC void FreeEnumPhysicalStoreList(
    IN PENUM_PHYSICAL_STORE_INFO pStoreInfoHead
    )
{
    while (pStoreInfoHead) {
        PENUM_PHYSICAL_STORE_INFO pStoreInfo = pStoreInfoHead;
        pStoreInfoHead = pStoreInfo->pNext;
        FreeEnumPhysicalStoreInfo(pStoreInfo);
    }

}

#ifndef CE_BUILD
// Returns NULL if unable to successfully get the Url. Returned string
// must be freed by calling CryptMemFree
STATIC LPWSTR GetUserDsUserCertificateUrl()
{
    DWORD dwErr;
    LPWSTR pwszUrl = NULL;
    HMODULE hDll = NULL;
    PFN_GET_USER_DS_STORE_URL pfnGetUserDsStoreUrl;

    if (NULL == (hDll = LoadLibraryA(sz_CRYPTNET_DLL)))
        goto LoadCryptNetDllError;

    if (NULL == (pfnGetUserDsStoreUrl =
            (PFN_GET_USER_DS_STORE_URL) GetProcAddress(hDll,
                sz_GetUserDsStoreUrl)))
        goto GetUserDsStoreUrlProcAddressError;

    if (!pfnGetUserDsStoreUrl(wsz_USER_CERTIFICATE_ATTR, &pwszUrl)) {
        dwErr = GetLastError();
        goto GetUserDsStoreUrlError;
    }

CommonReturn:
    if (hDll)
        FreeLibrary(hDll);
    return pwszUrl;
ErrorReturn:
    pwszUrl = NULL;
    goto CommonReturn;
TRACE_ERROR(LoadCryptNetDllError)
TRACE_ERROR(GetUserDsStoreUrlProcAddressError)
SET_ERROR_VAR(GetUserDsStoreUrlError, dwErr)
}
#else
#define GetUserDsUserCertificateUrl() (NULL)
#endif

//+-------------------------------------------------------------------------
//  Unless, CERT_STORE_OPEN_EXISTING_FLAG or CERT_STORE_READONLY_FLAG is
//  set, the pvSystemStore will be created if it doesn't already exist.
//
//  Note, depending on the store location and possibly the store name, there
//  are predefined physical stores of .Default, .LocalMachine, .GroupPolicy,
//  .Enterprise
//--------------------------------------------------------------------------
#ifdef _ARM_
#pragma optimize("", off)
#endif

STATIC BOOL EnumPhysicalStore(
    IN const void *pvSystemStore,
    IN DWORD dwFlags,
    IN void *pvArg,
    IN PFN_CERT_ENUM_PHYSICAL_STORE pfnEnum
    )
{
    BOOL fResult;
    LONG *plDepth = NULL;    // allocated per thread, don't free here
    HKEY hKey = NULL;
    DWORD cSubKeys;
    DWORD cchMaxSubKey;
    LPWSTR pwszStoreName = NULL;
    PENUM_PHYSICAL_STORE_INFO pStoreInfoHead = NULL;
    PENUM_PHYSICAL_STORE_INFO pStoreInfo;       // not allocated
    SYSTEM_NAME_INFO SystemNameInfo;

    DWORD dwStoreLocationID;
    DWORD dwPredefinedPhysicalFlags;

    if (!IsSystemStoreLocationInRegistry(dwFlags)) {
        void *pvFuncAddr;
        HCRYPTOIDFUNCADDR hFuncAddr;

        if (!CryptGetOIDFunctionAddress(
                rghFuncSet[ENUM_PHYSICAL_STORE_FUNC_SET],
                0,                      // dwEncodingType,
                GetSystemStoreLocationOID(dwFlags),
                0,                      // dwFlags
                &pvFuncAddr,
                &hFuncAddr))
            return FALSE;

        fResult = ((PFN_ENUM_PHYSICAL_STORE) pvFuncAddr)(
            pvSystemStore,
            dwFlags,
            pvArg,
            pfnEnum
            );
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
        return fResult;
    }

    if (!ParseSystemStorePara(
            pvSystemStore,
            dwFlags,
            1,                      // cReqName
            &SystemNameInfo))       // zero'ed on error
        goto ParseSystemStoreParaError;

    if (dwFlags & ~ENUM_FLAGS_MASK)
        goto InvalidArg;

    // Check for cross store recursion by checking the thread's enum
    // depth
    if (NULL == (plDepth = (LONG *) I_CryptGetTls(
            hTlsEnumPhysicalStoreDepth))) {
        if (NULL == (plDepth = (LONG *) PkiNonzeroAlloc(sizeof(*plDepth))))
            goto OutOfMemory;
        *plDepth = 1;
        I_CryptSetTls(hTlsEnumPhysicalStoreDepth, plDepth);
    } else {
        *plDepth += 1;
        if (MAX_ENUM_PHYSICAL_STORE_DEPTH < *plDepth)
            goto ExceededEnumPhysicalStoreDepth_PossibleCrossStoreRecursion;
    }

    if (IsClientGptStore(&SystemNameInfo, dwFlags)) {
        cSubKeys = 0;
    } else if (NULL == (hKey = OpenSystemRegPathKey(
            &SystemNameInfo,
            PHYSICAL_STORES_SUBKEY_NAME,
            dwFlags | CERT_STORE_OPEN_EXISTING_FLAG | CERT_STORE_READONLY_FLAG
            ))) {
        if (ERROR_FILE_NOT_FOUND != GetLastError())
            goto OpenPhysicalStoresError;

        // Check if we have a system store without the "PhysicalStores" subkey
        if (NULL == (hKey = OpenSystemRegPathKey(
                &SystemNameInfo,
                NULL,               // pwszSubKeyName
                dwFlags
                ))) {
            if (dwFlags & CERT_STORE_MAXIMUM_ALLOWED_FLAG)
                hKey = OpenSystemRegPathKey(
                    &SystemNameInfo,
                    NULL,               // pwszSubKeyName
                    dwFlags | CERT_STORE_OPEN_EXISTING_FLAG |
                        CERT_STORE_READONLY_FLAG
                    );
        }

        if (NULL == hKey) {
            // Note, the predefined stores don't need to exist in the
            // registry
            if (ERROR_FILE_NOT_FOUND != GetLastError())
                goto OpenSystemStoreError;
        } else {
            RegCloseKey(hKey);
            hKey = NULL;
        }

        cSubKeys = 0;
    } else if (!GetSubKeyInfo(
            hKey,
            &cSubKeys,
            &cchMaxSubKey
            ))
        goto GetSubKeyInfoError;

    // Get flags containing list of predefined physical stores according to
    // store name and/or store location
    dwStoreLocationID = GetSystemStoreLocationID(dwFlags);
    if (0 == _wcsicmp(SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX],
            wsz_MY_STORE))
        // Only .Default is predefined for "My" store
        dwPredefinedPhysicalFlags = MY_PHYSICAL_FLAGS;
    else if (0 == _wcsicmp(SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX],
             wsz_ROOT_STORE)) {
        if (CERT_SYSTEM_STORE_CURRENT_USER_ID == dwStoreLocationID) {
            if (IPR_OnlyLocalMachineGroupPolicyRootsAllowed()) {
                // Only .LocalMachineGroupPolicy. Don't read CurrentUser's
                // SystemRegistry or LocalMachine SystemRegistry.
                dwPredefinedPhysicalFlags = LMGP_PHYSICAL_FLAG;
                // Since we won't be reading the SystemRegistry, ensure
                // the protected list of roots is initialized.
                IPR_InitProtectedRootInfo();
            } else if (IPR_IsCurrentUserRootsAllowed()) {
                // .Default and .LocalMachine physical stores are predefined
                dwPredefinedPhysicalFlags = CURRENT_USER_ROOT_PHYSICAL_FLAGS;
            } else {
                // Don't read the CurrentUser's SystemRegistry
                dwPredefinedPhysicalFlags = CURRENT_USER_ROOT_PHYSICAL_FLAGS &
                    ~DEFAULT_PHYSICAL_FLAG;
                // Since we won't be reading the SystemRegistry, ensure
                // the protected list of roots is initialized.
                IPR_InitProtectedRootInfo();
            }
            // Only the predefined physical stores are allowed for Root
            cSubKeys = 0;
        } else if (CERT_SYSTEM_STORE_USERS_ID == dwStoreLocationID) {
            // Only .LocalMachine physical stores is predefined

            dwPredefinedPhysicalFlags = USERS_ROOT_PHYSICAL_FLAGS;
            // Only the predefined physical stores are allowed for Root
            cSubKeys = 0;
        } else {
            // According to store location.
            dwPredefinedPhysicalFlags =
                rgSystemStoreLocationInfo[
                    dwStoreLocationID].dwPredefinedPhysicalFlags;
        }
    } else if (0 == _wcsicmp(SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX],
             wsz_USER_DS_STORE)) {
        // Only .UserCertificate is predefined for "UserDS"
        dwPredefinedPhysicalFlags = USER_DS_PHYSICAL_FLAGS;
    } else
        // According to store location
        dwPredefinedPhysicalFlags =
            rgSystemStoreLocationInfo[
                dwStoreLocationID].dwPredefinedPhysicalFlags;


    if (cSubKeys && cchMaxSubKey) {
        DWORD i;

        cchMaxSubKey++;
        if (NULL == (pwszStoreName = (LPWSTR) PkiNonzeroAlloc(
                cchMaxSubKey * sizeof(WCHAR))))
            goto OutOfMemory;

        for (i = 0; i < cSubKeys; i++) {
            DWORD cchStoreName = cchMaxSubKey;

            if (ERROR_SUCCESS != RegEnumKeyExU(
                    hKey,
                    i,
                    pwszStoreName,
                    &cchStoreName,
                    NULL,               // lpdwReserved
                    NULL,               // lpszClass
                    NULL,               // lpcchClass
                    NULL                // lpftLastWriteTime
                    ) || 0 == cchStoreName)
                continue;

            if (NULL == (pStoreInfo = GetEnumPhysicalStoreInfo(
                    hKey,
                    pwszStoreName
                    )))
                continue;
            AddToEnumPhysicalStoreList(&pStoreInfoHead, pStoreInfo);
        }
    }

    for (pStoreInfo = pStoreInfoHead; pStoreInfo;
                                            pStoreInfo = pStoreInfo->pNext) {
        PCERT_PHYSICAL_STORE_INFO pRegistryInfo = &pStoreInfo->RegistryInfo;
        BOOL fSelfPhysicalStoreInfo;
        DWORD dwSystemProviderFlags;
        char szOID[34];

        if (IsSelfPhysicalStoreInfo(
                &SystemNameInfo,
                dwFlags,
                pRegistryInfo,
                &dwSystemProviderFlags)) {
            assert((dwSystemProviderFlags & UNICODE_SYSTEM_PROVIDER_FLAG) ||
                (dwSystemProviderFlags & ASCII_SYSTEM_PROVIDER_FLAG));
            // Force to use SYSTEM_REGISTRY provider to inhibit recursion.
            PkiFree(pRegistryInfo->pszOpenStoreProvider);
            if (dwSystemProviderFlags & ASCII_SYSTEM_PROVIDER_FLAG) {
                // Convert to "#<number>" string
                szOID[0] = CONST_OID_STR_PREFIX_CHAR;
                _ltoa((long) ((DWORD_PTR)CERT_STORE_PROV_SYSTEM_REGISTRY_A), szOID + 1, 10);
                pRegistryInfo->pszOpenStoreProvider = szOID;
            } else
                pRegistryInfo->pszOpenStoreProvider =
                    sz_CERT_STORE_PROV_SYSTEM_REGISTRY_W;

            dwPredefinedPhysicalFlags &= ~DEFAULT_PHYSICAL_FLAG;
            fSelfPhysicalStoreInfo = TRUE;
        } else {
            if (0 != dwPredefinedPhysicalFlags) {
                // Check if matches one of the predefined physical stores

                DWORD i;
                DWORD dwCheckFlag;
                for (i = 0, dwCheckFlag = 1; i < NUM_PREDEFINED_PHYSICAL;
                                        i++, dwCheckFlag = dwCheckFlag << 1) {
                    if ((dwCheckFlag & dwPredefinedPhysicalFlags) &&
                            0 == _wcsicmp(pStoreInfo->pwszStoreName,
                                rgpwszPredefinedPhysical[i])) {
                        dwPredefinedPhysicalFlags &= ~dwCheckFlag;
                        break;
                    }
                }
            }
            fSelfPhysicalStoreInfo = FALSE;
        }

        if (dwFlags & CERT_STORE_MAXIMUM_ALLOWED_FLAG) {
            pRegistryInfo->dwOpenFlags |= CERT_STORE_MAXIMUM_ALLOWED_FLAG;
            pRegistryInfo->dwOpenFlags &= ~CERT_STORE_READONLY_FLAG;
        }
        fResult = pfnEnum(
            pvSystemStore,
            dwFlags & CERT_SYSTEM_STORE_MASK,
            pStoreInfo->pwszStoreName,
            &pStoreInfo->RegistryInfo,
            NULL,                           // pvReserved
            pvArg
            );

        if (fSelfPhysicalStoreInfo) {
            // Not allocated. Set to NULL to inhibit subsequent free.
            pRegistryInfo->pszOpenStoreProvider = NULL;
        }

        if (!fResult)
            goto EnumCallbackError;
    }


    if (0 != dwPredefinedPhysicalFlags) {
        CERT_PHYSICAL_STORE_INFO SelfInfo;
        LPWSTR pwszLocalStore;
        DWORD cbLocalStore;
        DWORD i;
        DWORD dwCheckFlag;

        if (SystemNameInfo.rgpwszName[COMPUTER_NAME_INDEX]) {
            // Format local store name without the ComputerName
            LPCWSTR rgpwszGroupName[2];
            SYSTEM_NAME_GROUP NameGroup;
            NameGroup.cName = 2;
            NameGroup.rgpwszName = rgpwszGroupName;

            assert(IsRemotableSystemStoreLocationInRegistry(dwFlags));
            rgpwszGroupName[0] = SystemNameInfo.rgpwszName[SERVICE_NAME_INDEX];
            rgpwszGroupName[1] = SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX];
            if (NULL == (pwszLocalStore = FormatSystemNamePath(1, &NameGroup)))
                goto FormatSystemNamePathError;
        } else {
            if (dwFlags & CERT_SYSTEM_STORE_RELOCATE_FLAG) {
                PCERT_SYSTEM_STORE_RELOCATE_PARA pRelocatePara =
                    (PCERT_SYSTEM_STORE_RELOCATE_PARA) pvSystemStore;
                pwszLocalStore = (LPWSTR) pRelocatePara->pwszSystemStore;
            } else
                pwszLocalStore = (LPWSTR) pvSystemStore;
        }
        cbLocalStore = (wcslen(pwszLocalStore) + 1) * sizeof(WCHAR);

        memset(&SelfInfo, 0, sizeof(SelfInfo));
        SelfInfo.cbSize = sizeof(SelfInfo);

        fResult = TRUE;
        for (i = 0, dwCheckFlag = 1; i < NUM_PREDEFINED_PHYSICAL;
                                        i++, dwCheckFlag = dwCheckFlag << 1) {
            LPWSTR pwszUserDsUserCertificateUrl;
            if (0 == (dwCheckFlag & dwPredefinedPhysicalFlags))
                continue;

            SelfInfo.pszOpenStoreProvider = sz_CERT_STORE_PROV_SYSTEM_W;
            SelfInfo.OpenParameters.pbData =
                (BYTE *) SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX];
            SelfInfo.OpenParameters.cbData =
                (wcslen(SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX]) + 1) *
                    sizeof(WCHAR);
            SelfInfo.dwFlags = 0;
            pwszUserDsUserCertificateUrl = NULL;
            switch (i) {
                case DEFAULT_PHYSICAL_INDEX:
                    SelfInfo.pszOpenStoreProvider =
                        sz_CERT_STORE_PROV_SYSTEM_REGISTRY_W;
                    SelfInfo.dwOpenFlags = dwFlags &
                        CERT_SYSTEM_STORE_LOCATION_MASK;
                    if (0 == _wcsicmp(
                        SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX],
                            wsz_MY_STORE))
                        SelfInfo.dwOpenFlags |= CERT_STORE_UPDATE_KEYID_FLAG;
                    SelfInfo.OpenParameters.pbData = (BYTE *) pwszLocalStore;
                    SelfInfo.OpenParameters.cbData = cbLocalStore;
                    SelfInfo.dwFlags = CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG;
                    break;
                case GROUP_POLICY_PHYSICAL_INDEX:
                    if (CERT_SYSTEM_STORE_LOCAL_MACHINE_ID ==
                            dwStoreLocationID)
                        SelfInfo.dwOpenFlags =
                            CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY |
                                CERT_STORE_READONLY_FLAG;
                    else
                        SelfInfo.dwOpenFlags =
                            CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY |
                                CERT_STORE_READONLY_FLAG;
                    break;
                case LOCAL_MACHINE_PHYSICAL_INDEX:
                    SelfInfo.dwOpenFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE |
                        CERT_STORE_READONLY_FLAG;
                    break;
                case DS_USER_CERT_PHYSICAL_INDEX:
                    if (NULL == (pwszUserDsUserCertificateUrl =
                            GetUserDsUserCertificateUrl()))
                        continue;
                    SelfInfo.pszOpenStoreProvider = sz_CERT_STORE_PROV_LDAP_W;
                    SelfInfo.dwOpenFlags = 0;
                    SelfInfo.OpenParameters.pbData =
                        (BYTE *) pwszUserDsUserCertificateUrl;
                    SelfInfo.OpenParameters.cbData = (wcslen(
                        pwszUserDsUserCertificateUrl) + 1) * sizeof(WCHAR);
                    SelfInfo.dwFlags = CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG;
                    break;
                case LMGP_PHYSICAL_INDEX:
                    SelfInfo.dwOpenFlags =
                        CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY |
                            CERT_STORE_READONLY_FLAG;
                    break;
                case ENTERPRISE_PHYSICAL_INDEX:
                    SelfInfo.dwOpenFlags =
                        CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE |
                            CERT_STORE_READONLY_FLAG;
                    break;
                default:
                    assert(i < NUM_PREDEFINED_PHYSICAL);
                    continue;

            }

            if (dwFlags & CERT_STORE_MAXIMUM_ALLOWED_FLAG) {
                SelfInfo.dwOpenFlags |= CERT_STORE_MAXIMUM_ALLOWED_FLAG;
                SelfInfo.dwOpenFlags &= ~CERT_STORE_READONLY_FLAG;
            }

            fResult = pfnEnum(
                    pvSystemStore,
                    (dwFlags & CERT_SYSTEM_STORE_MASK) |
                        CERT_PHYSICAL_STORE_PREDEFINED_ENUM_FLAG,
                    rgpwszPredefinedPhysical[i],        // pwszStoreName
                    &SelfInfo,
                    NULL,                               // pvReserved
                    pvArg
                    );
            if (pwszUserDsUserCertificateUrl)
                CryptMemFree(pwszUserDsUserCertificateUrl);
            if (!fResult)
                break;
        }

        if (SystemNameInfo.rgpwszName[COMPUTER_NAME_INDEX])
            PkiFree(pwszLocalStore);
        if (!fResult)
            goto EnumCallbackError;
    }

    fResult = TRUE;
CommonReturn:
    if (plDepth)
        *plDepth -= 1;
    ILS_CloseRegistryKey(hKey);
    FreeSystemNameInfo(&SystemNameInfo);
    PkiFree(pwszStoreName);
    FreeEnumPhysicalStoreList(pStoreInfoHead);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(ParseSystemStoreParaError)
SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(OutOfMemory)
SET_ERROR(ExceededEnumPhysicalStoreDepth_PossibleCrossStoreRecursion, E_UNEXPECTED)
TRACE_ERROR(OpenPhysicalStoresError)
TRACE_ERROR(OpenSystemStoreError)
TRACE_ERROR(GetSubKeyInfoError)
TRACE_ERROR(FormatSystemNamePathError)
TRACE_ERROR(EnumCallbackError)
}

#ifdef _ARM_
#pragma optimize ("", on)
#endif

//+-------------------------------------------------------------------------
//  Enumerate the physical stores for the specified system store.
//
//  The upper word of the dwFlags parameter is used to specify the location of
//  the system store.
//
//  If the system store location only supports system stores and doesn't
//  support physical stores, LastError is set to ERROR_CALL_NOT_IMPLEMENTED.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertEnumPhysicalStore(
    IN const void *pvSystemStore,
    IN DWORD dwFlags,
    IN void *pvArg,
    IN PFN_CERT_ENUM_PHYSICAL_STORE pfnEnum
    )
{
    return EnumPhysicalStore(
        pvSystemStore,
        dwFlags | CERT_STORE_OPEN_EXISTING_FLAG | CERT_STORE_READONLY_FLAG,
        pvArg,
        pfnEnum
        );
}

STATIC BOOL IsHKCUMyStore(
    IN PSYSTEM_NAME_INFO pInfo,
    IN DWORD dwFlags
    )
{
    DWORD dwStoreLocation = dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK;

    if (CERT_SYSTEM_STORE_CURRENT_USER != dwStoreLocation ||
            0 != _wcsicmp(pInfo->rgpwszName[SYSTEM_NAME_INDEX], wsz_MY_STORE))
        return FALSE;

    if (dwFlags & (CERT_SYSTEM_STORE_RELOCATE_FLAG | CERT_STORE_DELETE_FLAG))
        return FALSE;

    return TRUE;
}

//+-------------------------------------------------------------------------
//  Open the system registry store provider (unicode version)
//
//  Open the system registry store specified by its name. For example,
//  L"My".
//
//  pvPara contains the LPCWSTR system registry store name.
//
//  Note for an error return, the caller will free any certs, CRLs or CTLs
//  successfully added to the store.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertDllOpenSystemRegistryStoreProvW(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
    BOOL fResult;
    LONG err;
    HKEY hKey = NULL;
    SYSTEM_NAME_INFO SystemNameInfo;
    BOOL fUserRoot;
    HKEY hHKCURoot = NULL;
    DWORD dwOpenRegFlags;
    const void *pvOpenRegPara;
    LPWSTR pwszRoamingDirectory = NULL;
    CERT_REGISTRY_STORE_ROAMING_PARA RoamingStorePara;

    CERT_REGISTRY_STORE_CLIENT_GPT_PARA ClientGptStorePara;
    memset(&ClientGptStorePara, 0, sizeof(ClientGptStorePara));

    if (!ParseSystemStorePara(
            pvPara,
            dwFlags,
            1,                  // cReqName
            &SystemNameInfo))   // zero'ed on error
        goto ParseSystemStoreParaError;

    if (dwFlags & ~OPEN_SYS_FLAGS_MASK)
        goto InvalidArg;

    // Check for the CurrentUser "Root" store.
    fUserRoot = FALSE;
    if (0 == _wcsicmp(SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX],
            wsz_ROOT_STORE) &&
                0 == (dwFlags & CERT_SYSTEM_STORE_UNPROTECTED_FLAG)) {
        DWORD dwStoreLocation = dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK;

        // Note, LOCAL_MACHINE check is needed to prevent use of relocation
        // to access the current user's root store
        if (CERT_SYSTEM_STORE_CURRENT_USER == dwStoreLocation) {
            fUserRoot = TRUE;
            if (NULL == SystemNameInfo.hKeyBase) {
                if (ERROR_SUCCESS != (err = RegOpenHKCUEx(
                        &hHKCURoot,
                        REG_HKCU_DISABLE_DEFAULT_FLAG
                        )))
                    goto RegOpenHKCUExRootError;

                SystemNameInfo.hKeyBase = hHKCURoot;
                dwFlags |= CERT_SYSTEM_STORE_RELOCATE_FLAG;
            }
        } else if (CERT_SYSTEM_STORE_USERS == dwStoreLocation ||
                ((dwFlags & CERT_SYSTEM_STORE_RELOCATE_FLAG) &&
                    CERT_SYSTEM_STORE_LOCAL_MACHINE == dwStoreLocation))
            goto RootAccessDenied;
    }

    if (IsClientGptStore(&SystemNameInfo, dwFlags)) {
        DWORD dwStoreLocation;

        assert(!fUserRoot);
        if (NULL == (ClientGptStorePara.pwszRegPath = FormatSystemRegPath(
                &SystemNameInfo,
                NULL,               // pwszSubKeyName
                dwFlags,
                &ClientGptStorePara.hKeyBase)))
            goto FormatSystemRegPathError;
        pvOpenRegPara = (const void *) &ClientGptStorePara;

        dwOpenRegFlags =
            dwFlags & ~(CERT_SYSTEM_STORE_MASK |
                CERT_STORE_SET_LOCALIZED_NAME_FLAG);
        dwOpenRegFlags |= CERT_REGISTRY_STORE_CLIENT_GPT_FLAG;
            // | CERT_REGISTRY_STORE_SERIALIZED_FLAG;

        dwStoreLocation = dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK;
        if (CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY == dwStoreLocation)
            dwOpenRegFlags |= CERT_REGISTRY_STORE_LM_GPT_FLAG;

        if (SystemNameInfo.rgpwszName[COMPUTER_NAME_INDEX])
            dwOpenRegFlags |= CERT_REGISTRY_STORE_REMOTE_FLAG;
    } else {
        BOOL fIsHKCUMyStore;

        fIsHKCUMyStore = IsHKCUMyStore(&SystemNameInfo, dwFlags);

        if (fIsHKCUMyStore && NULL != (pwszRoamingDirectory =
                ILS_GetRoamingStoreDirectory(ROAMING_MY_STORE_SUBDIR))) {
            // OK for this to fail. After the first open, all contexts should
            // be persisted in files and not the registry.
            hKey = OpenSystemRegPathKey(
                &SystemNameInfo,
                NULL,               // pwszSubKeyName
                (dwFlags & ~CERT_STORE_CREATE_NEW_FLAG) |
                    CERT_STORE_OPEN_EXISTING_FLAG
                );

            RoamingStorePara.hKey = hKey;
            RoamingStorePara.pwszStoreDirectory = pwszRoamingDirectory;
            pvOpenRegPara = (const void *) &RoamingStorePara;

            dwOpenRegFlags =
                dwFlags & ~(CERT_SYSTEM_STORE_MASK |
                    CERT_STORE_CREATE_NEW_FLAG |
                    CERT_STORE_SET_LOCALIZED_NAME_FLAG);
            dwOpenRegFlags |= CERT_REGISTRY_STORE_ROAMING_FLAG;
        } else {
            if (NULL == (hKey = OpenSystemRegPathKey(
                    &SystemNameInfo,
                    NULL,               // pwszSubKeyName
                    dwFlags)))
                goto OpenSystemStoreError;
            pvOpenRegPara = (const void *) hKey;

            dwOpenRegFlags =
                dwFlags & ~(CERT_SYSTEM_STORE_MASK |
                    CERT_STORE_CREATE_NEW_FLAG |
                    CERT_STORE_SET_LOCALIZED_NAME_FLAG);
            if (SystemNameInfo.rgpwszName[COMPUTER_NAME_INDEX])
                dwOpenRegFlags |= CERT_REGISTRY_STORE_REMOTE_FLAG;
            if (IsSerializedSystemStoreLocationInRegistry(dwFlags)) {
                assert(!fUserRoot);
                dwOpenRegFlags |= CERT_REGISTRY_STORE_SERIALIZED_FLAG;
            }
        }

        if (fIsHKCUMyStore)
            dwOpenRegFlags |= CERT_REGISTRY_STORE_MY_IE_DIRTY_FLAG;
    }

    if (fUserRoot)
        IPR_InitProtectedRootInfo();

    if (!I_CertDllOpenRegStoreProv(
            NULL,                       // lpszStoreProvider
            dwEncodingType,
            hCryptProv,
            dwOpenRegFlags,
            pvOpenRegPara,
            hCertStore,
            pStoreProvInfo))
        goto OpenRegStoreProvError;

    if (fUserRoot) {
        PREG_STORE pRegStore = (PREG_STORE) pStoreProvInfo->hStoreProv;

        // Set count to 0 to inhibit any callbacks from being called.
        pStoreProvInfo->cStoreProvFunc = 0;

        // For the "Root" delete any roots that aren't in the protected root
        // list.
        if (!IPR_DeleteUnprotectedRootsFromStore(
                hCertStore,
                &pRegStore->fProtected
                )) goto DeleteUnprotectedRootsError;

        // For the "Root" replace some of the provider callback functions
        // that first prompt the user directly (if not protected) or
        // prompt the user via the system service (if protected).
        pStoreProvInfo->cStoreProvFunc = ROOT_STORE_PROV_FUNC_COUNT;
        pStoreProvInfo->rgpvStoreProvFunc = (void **) rgpvRootStoreProvFunc;
    }

    if (dwFlags & CERT_STORE_SET_LOCALIZED_NAME_FLAG)
        SetLocalizedNameStoreProperty(hCertStore, &SystemNameInfo);

    pStoreProvInfo->dwStoreProvFlags |= CERT_STORE_PROV_SYSTEM_STORE_FLAG;
    fResult = TRUE;
CommonReturn:
    if (SystemNameInfo.rgpwszName[COMPUTER_NAME_INDEX] &&
            ClientGptStorePara.hKeyBase)
        ILS_CloseRegistryKey(ClientGptStorePara.hKeyBase);
    PkiFree(ClientGptStorePara.pwszRegPath);

    FreeSystemNameInfo(&SystemNameInfo);
    PkiFree(pwszRoamingDirectory);
    ILS_CloseRegistryKey(hKey);
    if (hHKCURoot)
        RegCloseHKCU(hHKCURoot);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(ParseSystemStoreParaError)
SET_ERROR(InvalidArg, E_INVALIDARG)
SET_ERROR(RootAccessDenied, E_ACCESSDENIED)
SET_ERROR_VAR(RegOpenHKCUExRootError, err)
TRACE_ERROR(FormatSystemRegPathError)
TRACE_ERROR(OpenSystemStoreError)
TRACE_ERROR(OpenRegStoreProvError)
TRACE_ERROR(DeleteUnprotectedRootsError)
}

//+-------------------------------------------------------------------------
//  Open the system registry store provider (ascii version)
//
//  Open the system registry store specified by its name. For example,
//  "My".
//
//  pvPara contains the LPCSTR system store name.
//
//  Note for an error return, the caller will free any certs or CRLs
//  successfully added to the store.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertDllOpenSystemRegistryStoreProvA(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
    BOOL fResult;
    LPCSTR pszStoreName;    // not allocated
    LPWSTR pwszStoreName;

    CERT_SYSTEM_STORE_RELOCATE_PARA RelocatePara;

    if (dwFlags & CERT_SYSTEM_STORE_RELOCATE_FLAG) {
        PCERT_SYSTEM_STORE_RELOCATE_PARA pInPara;

        assert(pvPara);
        pInPara = (PCERT_SYSTEM_STORE_RELOCATE_PARA) pvPara;
        RelocatePara.hKeyBase = pInPara->hKeyBase;
        pszStoreName = pInPara->pszSystemStore;
    } else
        pszStoreName = (LPCSTR) pvPara;

    assert(pszStoreName);

    if (NULL == (pwszStoreName = MkWStr((LPSTR) pszStoreName)))
        fResult = FALSE;
    else {
        const void *pvParaW;

        if (dwFlags & CERT_SYSTEM_STORE_RELOCATE_FLAG) {
            RelocatePara.pwszSystemStore = pwszStoreName;
            pvParaW = (const void *) &RelocatePara;
        } else
            pvParaW = (const void *) pwszStoreName;

        fResult = I_CertDllOpenSystemRegistryStoreProvW(
            NULL,                       // lpszStoreProvider
            dwEncodingType,
            hCryptProv,
            dwFlags,
            pvParaW,
            hCertStore,
            pStoreProvInfo
            );
        FreeWStr(pwszStoreName);
    }
    return fResult;
}

typedef struct _OPEN_PHYSICAL_STORE_INFO {
    HCERTSTORE      hCollectionStore;
    LPCWSTR         pwszComputerName;       // NULL implies local
    LPCWSTR         pwszServiceName;        // NULL implies current
    LPCWSTR         pwszPhysicalName;       // NULL implies any
    HKEY            hKeyBase;               // non-NULL, relocatable
    DWORD           dwFlags;
    BOOL            fDidOpen;
} OPEN_PHYSICAL_STORE_INFO, *POPEN_PHYSICAL_STORE_INFO;


STATIC BOOL WINAPI OpenPhysicalStoreCallback(
    IN const void *pvSystemStore,
    IN DWORD dwFlags,
    IN LPCWSTR pwszStoreName,
    IN PCERT_PHYSICAL_STORE_INFO pStoreInfo,
    IN OPTIONAL void *pvReserved,
    IN OPTIONAL void *pvArg
    )
{
    BOOL fResult;
    HCERTSTORE hPhysicalStore = NULL;
    POPEN_PHYSICAL_STORE_INFO pOpenInfo =
        (POPEN_PHYSICAL_STORE_INFO) pvArg;
    void *pvOpenParameters;
    LPWSTR pwszRemoteOpenParameters = NULL;
    LPCSTR pszOpenStoreProvider;
    DWORD dwOpenFlags;
    DWORD dwAddFlags;

    CERT_SYSTEM_STORE_RELOCATE_PARA RelocateOpenParameters;

    if ((pStoreInfo->dwFlags & CERT_PHYSICAL_STORE_OPEN_DISABLE_FLAG)
                        ||
            (pOpenInfo->pwszPhysicalName &&
                0 != _wcsicmp(pOpenInfo->pwszPhysicalName, pwszStoreName))
                        ||
            (pOpenInfo->pwszComputerName &&
                (pStoreInfo->dwFlags &
                    CERT_PHYSICAL_STORE_REMOTE_OPEN_DISABLE_FLAG)))
        return TRUE;

    pvOpenParameters = pStoreInfo->OpenParameters.pbData;
    assert(pvOpenParameters);
    dwOpenFlags = pStoreInfo->dwOpenFlags;
    pszOpenStoreProvider = pStoreInfo->pszOpenStoreProvider;

    if (pOpenInfo->pwszComputerName || pOpenInfo->pwszServiceName) {
        // Possibly insert the \\ComputerName\ServiceName before the
        // OpenParameters

        LPCWSTR pwszComputerName = NULL;
        LPCWSTR pwszServiceName = NULL;
        LPWSTR pwszSystemStore = (LPWSTR) pvOpenParameters;
        DWORD dwSystemProviderFlags =
            GetSystemProviderFlags(pszOpenStoreProvider);

        if (0 != dwSystemProviderFlags) {
            SYSTEM_NAME_INFO ProviderNameInfo;
            DWORD cReqName;

            if (dwOpenFlags & CERT_SYSTEM_STORE_RELOCATE_FLAG)
                goto RelocateFlagSetInPhysicalStoreInfoError;

            if (dwSystemProviderFlags & ASCII_SYSTEM_PROVIDER_FLAG) {
                if (NULL == (pwszSystemStore =
                        MkWStr((LPSTR) pvOpenParameters)))
                    goto OutOfMemory;
            }

            if (dwSystemProviderFlags & PHYSICAL_PROVIDER_FLAG)
                cReqName = 2;
            else
                cReqName = 1;

            ParseSystemStorePara(
                    pwszSystemStore,
                    dwOpenFlags,
                    cReqName,
                    &ProviderNameInfo      // zero'ed on error
                    );
            if (ProviderNameInfo.rgpwszName[COMPUTER_NAME_INDEX]) {
                // Already has \\ComputerName\ prefix. For Services or
                // Users, already has ServiceName\ prefix.
                ;
            } else if (ProviderNameInfo.rgpwszName[SYSTEM_NAME_INDEX]) {
                // Needed above check if ParseSystemStorePara failed.
                pwszComputerName = pOpenInfo->pwszComputerName;

                if (pOpenInfo->pwszServiceName) {
                    // If the provider store is located in CURRENT_SERVICE or
                    // CURRENT_USER use outer store's SERVICE_NAME and change
                    // store location accordingly

                    DWORD dwOpenLocation =
                        dwOpenFlags & CERT_SYSTEM_STORE_LOCATION_MASK;
                    if (CERT_SYSTEM_STORE_CURRENT_SERVICE == dwOpenLocation) {
                        pwszServiceName = pOpenInfo->pwszServiceName;
                        dwOpenFlags =
                            (dwOpenFlags & ~CERT_SYSTEM_STORE_LOCATION_MASK) |
                                CERT_SYSTEM_STORE_SERVICES;
                    } else if (CERT_SYSTEM_STORE_CURRENT_USER ==
                            dwOpenLocation) {
                        pwszServiceName = pOpenInfo->pwszServiceName;
                        dwOpenFlags =
                            (dwOpenFlags & ~CERT_SYSTEM_STORE_LOCATION_MASK) |
                                CERT_SYSTEM_STORE_USERS;
                    }

                }
            }
            FreeSystemNameInfo(&ProviderNameInfo);
        } else if (pStoreInfo->dwFlags &
                CERT_PHYSICAL_STORE_INSERT_COMPUTER_NAME_ENABLE_FLAG)
            pwszComputerName = pOpenInfo->pwszComputerName;

        if (pwszComputerName || pwszServiceName) {
            // Insert \\ComputerName\ServiceName before and re-format
            // open parameters
            LPCWSTR rgpwszName[3];
            SYSTEM_NAME_GROUP NameGroup;

            assert(pwszSystemStore);

            NameGroup.cName = 3;
            NameGroup.rgpwszName = rgpwszName;
            rgpwszName[0] = pwszComputerName;
            rgpwszName[1] = pwszServiceName;
            rgpwszName[2] = pwszSystemStore;
            pwszRemoteOpenParameters = FormatSystemNamePath(1, &NameGroup);
            pvOpenParameters = pwszRemoteOpenParameters;

            if (dwSystemProviderFlags & ASCII_SYSTEM_PROVIDER_FLAG)
                pszOpenStoreProvider = ChangeAsciiToUnicodeProvider(
                    pszOpenStoreProvider);
        }

        if (dwSystemProviderFlags & ASCII_SYSTEM_PROVIDER_FLAG) {
            FreeWStr(pwszSystemStore);
            if (NULL == pszOpenStoreProvider)
                goto UnableToChangeToUnicodeProvider;
        }
        if (NULL == pvOpenParameters)
            goto FormatSystemNamePathError;
    }

    if (NULL != pOpenInfo->hKeyBase &&
            0 != GetSystemProviderFlags(pszOpenStoreProvider)) {
        if (dwOpenFlags & CERT_SYSTEM_STORE_RELOCATE_FLAG)
            goto RelocateFlagSetInPhysicalStoreInfoError;

        // Inherit outer store's hKeyBase and convert to a relocated
        // physical store
        RelocateOpenParameters.hKeyBase = pOpenInfo->hKeyBase;
        RelocateOpenParameters.pvSystemStore = pvOpenParameters;
        pvOpenParameters = &RelocateOpenParameters;
        dwOpenFlags |= CERT_SYSTEM_STORE_RELOCATE_FLAG;
    }

    if (NULL == (hPhysicalStore = CertOpenStore(
            pszOpenStoreProvider,
            pStoreInfo->dwOpenEncodingType,
            0,                                  // hCryptProv
            dwOpenFlags | (pOpenInfo->dwFlags &
                                 (CERT_STORE_READONLY_FLAG |
                                  CERT_STORE_OPEN_EXISTING_FLAG |
                                  CERT_STORE_MANIFOLD_FLAG |
                                  CERT_STORE_UPDATE_KEYID_FLAG |
                                  CERT_STORE_ENUM_ARCHIVED_FLAG)),
            pvOpenParameters))) {
        DWORD dwErr = GetLastError();
        if (ERROR_FILE_NOT_FOUND == dwErr || ERROR_PROC_NOT_FOUND == dwErr ||
                ERROR_GEN_FAILURE == dwErr) {
            if (pOpenInfo->pwszPhysicalName &&
                    (dwFlags & CERT_PHYSICAL_STORE_PREDEFINED_ENUM_FLAG)) {
                // For a predefined physical convert to an empty collection
                CertAddStoreToCollection(
                    pOpenInfo->hCollectionStore,
                    NULL,           // hSiblingStore, NULL implies convert only
                    0,              // dwFlags
                    0               // dwPriority
                    );
                goto OpenReturn;
            } else
                goto SuccessReturn;
        } else
            goto OpenPhysicalStoreError;
    }

    dwAddFlags = pStoreInfo->dwFlags;
    if ((dwOpenFlags & CERT_STORE_MAXIMUM_ALLOWED_FLAG) &&
            0 == (dwAddFlags & CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG) &&
            pOpenInfo->pwszPhysicalName) {
        DWORD dwAccessStateFlags;
        DWORD cbData = sizeof(dwAccessStateFlags);

        if (CertGetStoreProperty(
                hPhysicalStore,
                CERT_ACCESS_STATE_PROP_ID,
                &dwAccessStateFlags,
                &cbData
                )) {
            if (dwAccessStateFlags & CERT_ACCESS_STATE_WRITE_PERSIST_FLAG)
                dwAddFlags |= CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG;
        }
    }

    if (!CertAddStoreToCollection(
            pOpenInfo->hCollectionStore,
            hPhysicalStore,
            dwAddFlags,
            pStoreInfo->dwPriority))
        goto AddStoreToCollectionError;

OpenReturn:
    pOpenInfo->fDidOpen = TRUE;
SuccessReturn:
    fResult = TRUE;
CommonReturn:
    PkiFree(pwszRemoteOpenParameters);
    if (hPhysicalStore)
        CertCloseStore(hPhysicalStore, 0);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
SET_ERROR(UnableToChangeToUnicodeProvider, E_UNEXPECTED)
TRACE_ERROR(OpenPhysicalStoreError)
TRACE_ERROR(AddStoreToCollectionError)
TRACE_ERROR(FormatSystemNamePathError)
SET_ERROR(RelocateFlagSetInPhysicalStoreInfoError, E_INVALIDARG)
}

//+-------------------------------------------------------------------------
//  Open the system store provider (unicode version)
//
//  Open the system store specified by its name. For example,
//  L"My".
//
//  pvPara contains the LPCWSTR system store name.
//
//  Note for an error return, the caller will free any certs, CRLs or CTLs
//  successfully added to the store.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertDllOpenSystemStoreProvW(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
    BOOL fResult;
    SYSTEM_NAME_INFO SystemNameInfo;

    pStoreProvInfo->dwStoreProvFlags |= CERT_STORE_PROV_SYSTEM_STORE_FLAG;

    if (!IsSystemStoreLocationInRegistry(dwFlags)) {
        void *pvFuncAddr;

        assert(NULL == pStoreProvInfo->hStoreProvFuncAddr2);
        if (!CryptGetOIDFunctionAddress(
                rghFuncSet[OPEN_SYSTEM_STORE_PROV_FUNC_SET],
                0,                      // dwEncodingType,
                GetSystemStoreLocationOID(dwFlags),
                0,                      // dwFlags
                &pvFuncAddr,
                &pStoreProvInfo->hStoreProvFuncAddr2))
            return FALSE;

        fResult = ((PFN_CERT_DLL_OPEN_STORE_PROV_FUNC) pvFuncAddr)(
            lpszStoreProvider,
            dwEncodingType,
            hCryptProv,
            dwFlags,
            pvPara,
            hCertStore,
            pStoreProvInfo
            );
        // Note, hStoreProvFuncAddr2 is CryptFreeOIDFunctionAddress'ed by
        // CertCloseStore()
        return fResult;
    }

    if (!ParseSystemStorePara(
            pvPara,
            dwFlags,
            1,                      // cReqName
            &SystemNameInfo))       // zero'ed on error
        goto ParseSystemStoreParaError;

    if (dwFlags & ~OPEN_SYS_FLAGS_MASK)
        goto InvalidArg;

    if (dwFlags & CERT_STORE_DELETE_FLAG) {
        // Need to clear out CERT_STORE_NO_CRYPT_RELEASE_FLAG
        if (!CertUnregisterSystemStore(
                pvPara,
                dwFlags & UNREGISTER_FLAGS_MASK
                ))
            goto UnregisterSystemStoreError;
        pStoreProvInfo->dwStoreProvFlags |= CERT_STORE_PROV_DELETED_FLAG;
    } else {
        OPEN_PHYSICAL_STORE_INFO OpenInfo;

        if (dwFlags & CERT_STORE_CREATE_NEW_FLAG) {
            HKEY hKey;
            if (NULL == (hKey = OpenSystemStore(pvPara, dwFlags)))
                goto OpenSystemStoreError;
            RegCloseKey(hKey);
            dwFlags &= ~CERT_STORE_CREATE_NEW_FLAG;
        }

        OpenInfo.hCollectionStore = hCertStore;
        OpenInfo.pwszComputerName =
            SystemNameInfo.rgpwszName[COMPUTER_NAME_INDEX];
        OpenInfo.pwszServiceName =
            SystemNameInfo.rgpwszName[SERVICE_NAME_INDEX];
        OpenInfo.pwszPhysicalName = NULL;       // NULL implies any
        OpenInfo.hKeyBase = SystemNameInfo.hKeyBase;
        OpenInfo.dwFlags = dwFlags & ~CERT_STORE_SET_LOCALIZED_NAME_FLAG;
        OpenInfo.fDidOpen = FALSE;

        // Need to clear out CERT_STORE_NO_CRYPT_RELEASE_FLAG
        if (!EnumPhysicalStore(
                pvPara,
                dwFlags & ENUM_FLAGS_MASK,
                &OpenInfo,
                OpenPhysicalStoreCallback
                ))
            goto EnumPhysicalStoreError;

        if (!OpenInfo.fDidOpen) {
            if (IsPredefinedSystemStore(
                    SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX], dwFlags))
                // Convert to a collection store
                CertAddStoreToCollection(
                    hCertStore,
                    NULL,           // hSiblingStore, NULL implies convert only
                    0,              // dwFlags
                    0               // dwPriority
                    );
            else
                goto PhysicalStoreNotFound;
        }

        if (dwFlags & CERT_STORE_SET_LOCALIZED_NAME_FLAG)
            SetLocalizedNameStoreProperty(hCertStore, &SystemNameInfo);
    }

    fResult = TRUE;
CommonReturn:
    FreeSystemNameInfo(&SystemNameInfo);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(ParseSystemStoreParaError)
SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(UnregisterSystemStoreError)
TRACE_ERROR(OpenSystemStoreError)
TRACE_ERROR(EnumPhysicalStoreError)
SET_ERROR(PhysicalStoreNotFound, ERROR_FILE_NOT_FOUND)
}

//+-------------------------------------------------------------------------
//  Open the system store provider (ascii version)
//
//  Open the system store specified by its name. For example,
//  "My".
//
//  pvPara contains the LPCSTR system store name.
//
//  Note for an error return, the caller will free any certs or CRLs
//  successfully added to the store.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertDllOpenSystemStoreProvA(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
    BOOL fResult;
    LPCSTR pszStoreName;    // not allocated
    LPWSTR pwszStoreName;

    CERT_SYSTEM_STORE_RELOCATE_PARA RelocatePara;

    if (dwFlags & CERT_SYSTEM_STORE_RELOCATE_FLAG) {
        PCERT_SYSTEM_STORE_RELOCATE_PARA pInPara;

        assert(pvPara);
        pInPara = (PCERT_SYSTEM_STORE_RELOCATE_PARA) pvPara;
        RelocatePara.hKeyBase = pInPara->hKeyBase;
        pszStoreName = pInPara->pszSystemStore;
    } else
        pszStoreName = (LPCSTR) pvPara;

    assert(pszStoreName);

    if (NULL == (pwszStoreName = MkWStr((LPSTR) pszStoreName)))
        fResult = FALSE;
    else {
        const void *pvParaW;

        if (dwFlags & CERT_SYSTEM_STORE_RELOCATE_FLAG) {
            RelocatePara.pwszSystemStore = pwszStoreName;
            pvParaW = (const void *) &RelocatePara;
        } else
            pvParaW = (const void *) pwszStoreName;

        fResult = I_CertDllOpenSystemStoreProvW(
            NULL,                       // lpszStoreProvider
            dwEncodingType,
            hCryptProv,
            dwFlags,
            pvParaW,
            hCertStore,
            pStoreProvInfo
            );
        FreeWStr(pwszStoreName);
    }
    return fResult;
}


//+-------------------------------------------------------------------------
//  Open the physical store provider (unicode version)
//
//  Open the physical store in the specified system store. For example,
//  L"My\.Default".
//
//  pvPara contains the LPCWSTR pwszSystemAndPhysicalName which is the
//  concatenation of the system and physical store names with an
//  intervening "\".
//
//  Note for an error return, the caller will free any certs, CRLs or CTLs
//  successfully added to the store.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertDllOpenPhysicalStoreProvW(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
    BOOL fResult;
    LPCWSTR pwszBoth;           // not allocated
    LPWSTR pwszSystem = NULL;   // allocated
    DWORD cchSystem;
    LPCWSTR pwszPhysical;       // not allocated

    void *pvSystemPara;         // not allocated
    CERT_SYSTEM_STORE_RELOCATE_PARA RelocatePara;

    if (dwFlags & ~OPEN_PHY_FLAGS_MASK)
        goto InvalidArg;

    if (dwFlags & CERT_SYSTEM_STORE_RELOCATE_FLAG) {
        PCERT_SYSTEM_STORE_RELOCATE_PARA pInPara;

        if (NULL == pvPara)
            goto InvalidArg;
        pInPara = (PCERT_SYSTEM_STORE_RELOCATE_PARA) pvPara;
        pwszBoth = pInPara->pwszSystemStore;
    } else
        pwszBoth = (LPCWSTR) pvPara;

    // Extract the system and physical name components by starting at
    // the end and searching backwards for the first "\"
    if (NULL == pwszBoth)
        goto InvalidArg;
    pwszPhysical = pwszBoth + wcslen(pwszBoth);
    while (pwszPhysical > pwszBoth && L'\\' != *pwszPhysical)
        pwszPhysical--;

    cchSystem = (DWORD)(pwszPhysical - pwszBoth);
    pwszPhysical++;     // advance past "\"
    if (0 < cchSystem && L'\0' != *pwszPhysical) {
        if (NULL == (pwszSystem = AllocAndCopyString(pwszBoth, cchSystem)))
            goto OutOfMemory;
    } else
        // Missing "\" or empty System or Physical Name.
        goto InvalidArg;

    if (dwFlags & CERT_SYSTEM_STORE_RELOCATE_FLAG) {
        PCERT_SYSTEM_STORE_RELOCATE_PARA pInPara =
            (PCERT_SYSTEM_STORE_RELOCATE_PARA) pvPara;
        RelocatePara.hKeyBase = pInPara->hKeyBase;
        RelocatePara.pwszSystemStore = pwszSystem;
        pvSystemPara = &RelocatePara;
    } else
        pvSystemPara = pwszSystem;

    if (dwFlags & CERT_STORE_DELETE_FLAG) {
        // Need to clear out CERT_STORE_NO_CRYPT_RELEASE_FLAG
        if (!CertUnregisterPhysicalStore(
                pvSystemPara,
                dwFlags & UNREGISTER_FLAGS_MASK,
                pwszPhysical
                ))
            goto UnregisterPhysicalStoreError;
        pStoreProvInfo->dwStoreProvFlags |= CERT_STORE_PROV_DELETED_FLAG;
    } else {
        SYSTEM_NAME_INFO SystemNameInfo;
        OPEN_PHYSICAL_STORE_INFO OpenInfo;

        // Note, already removed PhysicalName above. That's why
        // cReqName is 1 and not 2.
        if (!ParseSystemStorePara(
                pvSystemPara,
                dwFlags,
                1,                      // cReqName
                &SystemNameInfo))       // zero'ed on error
            goto ParseSystemStoreParaError;

        OpenInfo.hCollectionStore = hCertStore;
        OpenInfo.pwszComputerName =
            SystemNameInfo.rgpwszName[COMPUTER_NAME_INDEX];
        OpenInfo.pwszServiceName =
            SystemNameInfo.rgpwszName[SERVICE_NAME_INDEX];
        OpenInfo.pwszPhysicalName = pwszPhysical;
        OpenInfo.hKeyBase = SystemNameInfo.hKeyBase;
        OpenInfo.dwFlags = dwFlags & ~CERT_STORE_SET_LOCALIZED_NAME_FLAG;
        OpenInfo.fDidOpen = FALSE;

        // For .Default physical store, allow the store to be created.
        // Otherwise, the store must already exist.
        if (0 != _wcsicmp(CERT_PHYSICAL_STORE_DEFAULT_NAME, pwszPhysical))
            dwFlags |= CERT_STORE_OPEN_EXISTING_FLAG |
                CERT_STORE_READONLY_FLAG;

        // Need to clear out CERT_STORE_NO_CRYPT_RELEASE_FLAG
        fResult = EnumPhysicalStore(
                pvSystemPara,
                dwFlags & ENUM_FLAGS_MASK,
                &OpenInfo,
                OpenPhysicalStoreCallback
                );

        if (dwFlags & CERT_STORE_SET_LOCALIZED_NAME_FLAG) {
            assert(NULL == SystemNameInfo.rgpwszName[PHYSICAL_NAME_INDEX]);
            SystemNameInfo.rgpwszName[PHYSICAL_NAME_INDEX] =
                (LPWSTR) pwszPhysical;
            SetLocalizedNameStoreProperty(hCertStore, &SystemNameInfo);
            SystemNameInfo.rgpwszName[PHYSICAL_NAME_INDEX] = NULL;
        }

        FreeSystemNameInfo(&SystemNameInfo);
        if (!fResult)
            goto EnumPhysicalStoreError;
        if (!OpenInfo.fDidOpen)
            goto PhysicalStoreNotFound;

    }

    pStoreProvInfo->dwStoreProvFlags |= CERT_STORE_PROV_SYSTEM_STORE_FLAG;
    fResult = TRUE;
CommonReturn:
    PkiFree(pwszSystem);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(UnregisterPhysicalStoreError)
TRACE_ERROR(ParseSystemStoreParaError)
TRACE_ERROR(EnumPhysicalStoreError)
SET_ERROR(PhysicalStoreNotFound, ERROR_FILE_NOT_FOUND)
}



//+=========================================================================
//  "ROOT" STORE
//==========================================================================
#ifdef CE_BUILD
#define ROOTMSGBOX_REGPATH            L"Software\\Microsoft\\Cryptography\\UI"
#define ADD_ROOT_CERT		0
#define DELETE_ROOT_CERT	1


//
// On Windows CE, the warning message that is displayed when a certificate is imported or
// removed from a root store is optional. If a UI dll is specified in
// HKLM\Software\Microsoft\Cryptography\UI, CAPI2 loads this dll and calls its "RootStorePrompt"
// entry point. The implementation of this function can display a suitable prompt to the
// user. If the function returns anything other than IDYES, the operation is cancelled.
// If the registry key is not present or the Dll is not found, we assume it is okay
// to import/delete the root cert and return IDYES.
//
typedef int (* PFNROOTSTOREPROMPT)(PCCERT_CONTEXT, UINT, UINT);

int
CeRootMessageBox(
    IN PCCERT_CONTEXT pCert, // cert being added or deleted
    IN UINT wActionID,	// 0 -> Add, 1 -> Delete
    IN UINT uFlags
    )
{
	HMODULE hDll = NULL;
	int iRet = IDYES;
	LPWSTR pszDllPath = NULL;
	HKEY hKey;
	PFNROOTSTOREPROMPT pfnRootStoreMessageBox;

	DEBUGMSG(1,(TEXT("CRYPT32: %s certificate in Root Store\n"), wActionID ? TEXT("Deleting") : TEXT("Adding")));
    if (ERROR_SUCCESS != RegOpenKeyExU(
            HKEY_LOCAL_MACHINE,
            ROOTMSGBOX_REGPATH,
            0,                      // dwReserved
            KEY_READ,
            &hKey))
	
	{
		return iRet;
	}
	pszDllPath =  ReadSZValueFromRegistry(hKey, TEXT("Dll"));
	if (pszDllPath
		&& (hDll = LoadLibraryW(pszDllPath))
		&& (pfnRootStoreMessageBox = (PFNROOTSTOREPROMPT) GetProcAddress(hDll,TEXT("RootStorePrompt"))))
	{
		__try {
			iRet = pfnRootStoreMessageBox(pCert, wActionID, uFlags);
		} __except(EXCEPTION_EXECUTE_HANDLER)
		{
			// there was a DLL but it faulted
			// play it safe and return a failure
			iRet = IDABORT;
		}
	}
	if (hDll)
		FreeLibrary(hDll);
	if (hKey)
		RegCloseKey(hKey);
	PkiFree(pszDllPath);
	
	return iRet;
}

#endif
//+-------------------------------------------------------------------------
//  For "Root": prompt before adding a cert.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI RootStoreProvWriteCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwFlags
        )
{
    BOOL fResult;
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;
    PCCERT_CONTEXT pProvCertContext = NULL;
    BYTE *pbSerializedElement = NULL;
    DWORD cbSerializedElement = 0;

    assert(pRegStore);
    if (pRegStore->dwFlags & CERT_STORE_READONLY_FLAG)
        goto AccessDenied;
#ifndef CE_BUILD
    if (pRegStore->fProtected) {
        if (!CertSerializeCertificateStoreElement(
                pCertContext,
                0,              // dwFlags
                NULL,           // pbElement
                &cbSerializedElement
                )) goto SerializeCertError;
        if (NULL == (pbSerializedElement = (BYTE *) PkiNonzeroAlloc(
                cbSerializedElement)))
            goto OutOfMemory;
        if (!CertSerializeCertificateStoreElement(
                pCertContext,
                0,              // dwFlags
                pbSerializedElement,
                &cbSerializedElement
                )) goto SerializeCertError;

        fResult = I_CertProtectFunction(
            CERT_PROT_ADD_ROOT_FUNC_ID,
            0,                          // dwFlags
            NULL,                       // pwszIn
            pbSerializedElement,
            cbSerializedElement,
            NULL,                       // ppbOut
            NULL                        // pcbOut
            );
    } else 
#endif    
    {
        // If the certificate doesn't already exist, then, prompt the user
        if (!RegStoreProvReadCert(
                hStoreProv,
                pCertContext,
                0,              // dwFlags
                &pProvCertContext)) {
#ifdef CE_BUILD
            if (IDYES != CeRootMessageBox(pCertContext,
                    ADD_ROOT_CERT, 0))
#else
            if (IDYES != IPR_ProtectedRootMessageBox(pCertContext,
                    IDS_ROOT_MSG_BOX_ADD_ACTION, 0))
#endif                    
                goto Cancelled;
        }

        fResult = RegStoreProvWriteCert(
            hStoreProv,
            pCertContext,
            dwFlags
            );
    }

CommonReturn:
    CertFreeCertificateContext(pProvCertContext);
    PkiFree(pbSerializedElement);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(AccessDenied, E_ACCESSDENIED)
SET_ERROR(Cancelled, ERROR_CANCELLED)
#ifndef CE_BUILD
TRACE_ERROR(SerializeCertError)
TRACE_ERROR(OutOfMemory)
#endif
}


//+-------------------------------------------------------------------------
//  For "Root": prompt before deleting a cert.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI RootStoreProvDeleteCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwFlags
        )
{
    BOOL fResult;
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;
    PCCERT_CONTEXT pProvCertContext = NULL;

    assert(pRegStore);
    if (IsInResync(pRegStore))
        // Only delete from store cache, not from registry
        return TRUE;

    if (pRegStore->dwFlags & CERT_STORE_READONLY_FLAG)
        goto AccessDenied;

#ifndef CE_BUILD
    if (pRegStore->fProtected) {
        BYTE    rgbHash[MAX_HASH_LEN];
        DWORD   cbHash = MAX_HASH_LEN;

        // get the thumbprint
        if(!CertGetCertificateContextProperty(
                pCertContext,
                CERT_SHA1_HASH_PROP_ID,
                rgbHash,
                &cbHash
                )) goto GetCertHashPropError;
        fResult = I_CertProtectFunction(
            CERT_PROT_DELETE_ROOT_FUNC_ID,
            0,                          // dwFlags
            NULL,                       // pwszIn
            rgbHash,
            cbHash,
            NULL,                       // ppbOut
            NULL                        // pcbOut
            );
    } else 
#endif    
    {
        // Prompt the user before deleting
        if (RegStoreProvReadCert(
                hStoreProv,
                pCertContext,
                0,              // dwFlags
                &pProvCertContext)) {
#ifdef CE_BUILD
            if (IDYES != CeRootMessageBox(pCertContext,
                    DELETE_ROOT_CERT, 0))
#else
            if (IDYES != IPR_ProtectedRootMessageBox(pCertContext,
                    IDS_ROOT_MSG_BOX_DELETE_ACTION, 0))
#endif                    
                goto Cancelled;

            fResult = RegStoreProvDeleteCert(
                hStoreProv,
                pCertContext,
                dwFlags
                );
        } else
            fResult = TRUE;
    }

CommonReturn:
    CertFreeCertificateContext(pProvCertContext);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(AccessDenied, E_ACCESSDENIED)
SET_ERROR(Cancelled, ERROR_CANCELLED)
#ifndef CE_BUILD
TRACE_ERROR(GetCertHashPropError)
#endif
}

//+=========================================================================
// Change Notify Support Functions
//==========================================================================

#if 0
typedef VOID (NTAPI * WAITORTIMERCALLBACKFUNC) (PVOID, BOOLEAN );
typedef WAITORTIMERCALLBACKFUNC WAITORTIMERCALLBACK ;

WINBASEAPI
HANDLE
WINAPI
RegisterWaitForSingleObject(
    HANDLE hObject,
    WAITORTIMERCALLBACK Callback,
    PVOID Context,
    ULONG dwMilliseconds
    );

WINBASEAPI
BOOL
WINAPI
UnregisterWait(
    HANDLE WaitHandle
    );
#endif


typedef HANDLE (WINAPI *PFN_ILS_REGISTER_WAIT_FOR_SINGLE_OBJECT_EX)(
    HANDLE hObject,
    ILS_WAITORTIMERCALLBACK Callback,
    PVOID Context,
    ULONG dwMilliseconds,
    ULONG dwFlags
    );

typedef BOOL (WINAPI *PFN_ILS_UNREGISTER_WAIT)(
    HANDLE WaitHandle
    );

#define sz_KERNEL32_DLL                 "kernel32.dll"
#define sz_RegisterWaitForSingleObjectEx "RegisterWaitForSingleObjectEx"
#define sz_UnregisterWait               "UnregisterWait"

static HMODULE hKernel32Dll = NULL;
PFN_ILS_REGISTER_WAIT_FOR_SINGLE_OBJECT_EX pfnILS_RegisterWaitForSingleObjectEx;
PFN_ILS_UNREGISTER_WAIT pfnILS_UnregisterWait;

#define ILS_REG_WAIT_EXIT_HANDLE_INDEX      0
#define ILS_REG_WAIT_OBJECT_HANDLE_INDEX    1
#define ILS_REG_WAIT_HANDLE_COUNT           2

typedef struct _ILS_REG_WAIT_INFO {
    HANDLE                  hThread;
    DWORD                   dwThreadId;
    HANDLE                  rghWait[ILS_REG_WAIT_HANDLE_COUNT];
    ILS_WAITORTIMERCALLBACK Callback;
    PVOID                   Context;
    ULONG                   dwMilliseconds;
} ILS_REG_WAIT_INFO, *PILS_REG_WAIT_INFO;


DWORD WINAPI ILS_WaitForThreadProc(
    LPVOID lpThreadParameter
    )
{
    PILS_REG_WAIT_INFO pWaitInfo = (PILS_REG_WAIT_INFO) lpThreadParameter;
    DWORD cWait;

    if (pWaitInfo->rghWait[ILS_REG_WAIT_OBJECT_HANDLE_INDEX])
        cWait = ILS_REG_WAIT_HANDLE_COUNT;
    else
        cWait = ILS_REG_WAIT_HANDLE_COUNT - 1;

    while (TRUE) {
        DWORD dwWaitObject;

        dwWaitObject = WaitForMultipleObjectsEx(
            cWait,
            pWaitInfo->rghWait,
            FALSE,      // bWaitAll
            pWaitInfo->dwMilliseconds,
            FALSE       // bAlertable
            );

        switch (dwWaitObject) {
            case WAIT_OBJECT_0 + ILS_REG_WAIT_OBJECT_HANDLE_INDEX:
                pWaitInfo->Callback(pWaitInfo->Context, TRUE);
                break;
            case WAIT_TIMEOUT:
                pWaitInfo->Callback(pWaitInfo->Context, FALSE);
                break;
            case WAIT_OBJECT_0 + ILS_REG_WAIT_EXIT_HANDLE_INDEX:
                goto CommonReturn;
                break;
            default:
                goto InvalidWaitForObject;
        }
    }

CommonReturn:
    return 0;
ErrorReturn:
    goto CommonReturn;
TRACE_ERROR(InvalidWaitForObject)
}

#ifndef CE_BUILD
HANDLE
WINAPI
ILS_RegisterWaitForSingleObjectEx(
    HANDLE hObject,
    ILS_WAITORTIMERCALLBACK Callback,
    PVOID Context,
    ULONG dwMilliseconds,
    ULONG dwFlags
    )
{
    PILS_REG_WAIT_INFO pWaitInfo = NULL;
    HANDLE hDupObject = NULL;

    if ( dwMilliseconds == 0 )
    {
        dwMilliseconds = INFINITE ;
    }

    if (NULL == (pWaitInfo = (PILS_REG_WAIT_INFO) PkiZeroAlloc(
            sizeof(ILS_REG_WAIT_INFO))))
        goto OutOfMemory;

    if (hObject) {
        if (!DuplicateHandle(
                GetCurrentProcess(),
                hObject,
                GetCurrentProcess(),
                &hDupObject,
                0,                      // dwDesiredAccess
                FALSE,                  // bInheritHandle
                DUPLICATE_SAME_ACCESS
                ) || NULL == hDupObject)
            goto DuplicateEventError;
        pWaitInfo->rghWait[ILS_REG_WAIT_OBJECT_HANDLE_INDEX] = hDupObject;
    }
    pWaitInfo->Callback = Callback;
    pWaitInfo->Context = Context;
    pWaitInfo->dwMilliseconds = dwMilliseconds;

    // Create event to be signaled to terminate the thread
    if (NULL == (pWaitInfo->rghWait[ILS_REG_WAIT_EXIT_HANDLE_INDEX] =
            CreateEvent(
                NULL,       // lpsa
                FALSE,      // fManualReset
                FALSE,      // fInitialState
                NULL)))     // lpszEventName
        goto CreateThreadExitEventError;

    // Create the thread to do the wait for
    if (NULL == (pWaitInfo->hThread = CreateThread(
            NULL,           // lpThreadAttributes
            0,              // dwStackSize
            ILS_WaitForThreadProc,
            pWaitInfo,
            0,              // dwCreationFlags
            &pWaitInfo->dwThreadId
            )))
        goto CreateThreadError;

CommonReturn:
    return (HANDLE) pWaitInfo;

ErrorReturn:
    if (pWaitInfo) {
        DWORD dwErr = GetLastError();

        for (DWORD i = 0; i < ILS_REG_WAIT_HANDLE_COUNT; i++) {
            if (pWaitInfo->rghWait[i])
                CloseHandle(pWaitInfo->rghWait[i]);
        }
        PkiFree(pWaitInfo);
        pWaitInfo = NULL;

        SetLastError(dwErr);
    }
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
TRACE_ERROR(DuplicateEventError)
TRACE_ERROR(CreateThreadExitEventError)
TRACE_ERROR(CreateThreadError)
}


BOOL
WINAPI
ILS_UnregisterWait(
    HANDLE WaitHandle
    )
{
    PILS_REG_WAIT_INFO pWaitInfo = (PILS_REG_WAIT_INFO) WaitHandle;

    // Terminate the wait for thread and wait for it to exit
    SetEvent(pWaitInfo->rghWait[ILS_REG_WAIT_EXIT_HANDLE_INDEX]);
    if (pWaitInfo->dwThreadId != GetCurrentThreadId())
        // On Win98 at ProcessDetach it might switch to one of the
        // threads we created.
        //
        // Alternatively, we may be called from the callback itself via
        // ILS_ExitWait()
        WaitForSingleObjectEx(
            pWaitInfo->hThread,
            INFINITE,
            FALSE                       // bAlertable
            );
    CloseHandle(pWaitInfo->hThread);

    for (DWORD i = 0; i < ILS_REG_WAIT_HANDLE_COUNT; i++) {
        if (pWaitInfo->rghWait[i])
            CloseHandle(pWaitInfo->rghWait[i]);
    }
    PkiFree(pWaitInfo);

    return TRUE;
}

// Called from the callback function
BOOL
WINAPI
ILS_ExitWait(
    HANDLE WaitHandle
    )
{
    ILS_UnregisterWait(WaitHandle);
    ExitThread(0);
    assert(FALSE);
    return TRUE;
}

STATIC void RegWaitForProcessAttach()
{
    if (NULL == (hKernel32Dll = LoadLibraryA(sz_KERNEL32_DLL)))
        goto LoadKernel32DllError;

    if (NULL == (pfnILS_RegisterWaitForSingleObjectEx =
            (PFN_ILS_REGISTER_WAIT_FOR_SINGLE_OBJECT_EX) GetProcAddress(
                hKernel32Dll, sz_RegisterWaitForSingleObjectEx)))
        goto GetRegisterWaitForSingleObjectProcAddressError;
    if (NULL == (pfnILS_UnregisterWait =
            (PFN_ILS_UNREGISTER_WAIT) GetProcAddress(
                hKernel32Dll, sz_UnregisterWait)))
        goto GetUnregisterWaitProcAddressError;

CommonReturn:
    return;
ErrorReturn:
    pfnILS_RegisterWaitForSingleObjectEx = ILS_RegisterWaitForSingleObjectEx;
    pfnILS_UnregisterWait = ILS_UnregisterWait;
    goto CommonReturn;

TRACE_ERROR(LoadKernel32DllError)
TRACE_ERROR(GetRegisterWaitForSingleObjectProcAddressError)
TRACE_ERROR(GetUnregisterWaitProcAddressError)
}

STATIC void RegWaitForProcessDetach()
{
    if (hKernel32Dll) {
        FreeLibrary(hKernel32Dll);
        hKernel32Dll = NULL;
    }
}


// Upon entry/exit, the resync list is locked by the caller
BOOL ILS_AddEventToResyncList(
    IN PREG_STORE pRegStore,
    IN HANDLE hEvent,
    IN OUT DWORD *pcEntry,
    IN OUT PILS_RESYNC_ENTRY *ppEntry
    )
{
    BOOL fResult;
    HANDLE hDupEvent = NULL;
    DWORD cEntry;
    PILS_RESYNC_ENTRY pEntry;
    DWORD i;

    assert(hEvent);
    cEntry = *pcEntry;
    pEntry = *ppEntry;

    // First check if the hEvent is already in the list
    for (i = 0; i < cEntry; i++) {
        if (hEvent == pEntry[i].hOrigEvent)
            return TRUE;
    }

    if (!DuplicateHandle(
            GetCurrentProcess(),
            hEvent,
            GetCurrentProcess(),
            &hDupEvent,
            0,                      // dwDesiredAccess
            FALSE,                  // bInheritHandle
            DUPLICATE_SAME_ACCESS
            ) || NULL == hDupEvent)
        goto DuplicateEventError;

    if (NULL == (pEntry = (PILS_RESYNC_ENTRY) PkiRealloc(pEntry,
            (cEntry + 1) * sizeof(ILS_RESYNC_ENTRY))))
        goto OutOfMemory;
    pEntry[cEntry].hOrigEvent = hEvent;
    pEntry[cEntry].pRegStore = pRegStore;
    pEntry[cEntry].hEvent = hDupEvent;
    *pcEntry = cEntry + 1;
    *ppEntry = pEntry;
    fResult = TRUE;

CommonReturn:
    return fResult;
ErrorReturn:
    if (hDupEvent)
        CloseHandle(hDupEvent);
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(DuplicateEventError)
TRACE_ERROR(OutOfMemory)
}

// Upon entry/exit, the resync list is locked by the caller
void ILS_SignalEventsOnResyncList(
    IN OUT DWORD *pcEntry,
    IN OUT PILS_RESYNC_ENTRY *ppEntry
    )
{
    DWORD cEntry = *pcEntry;
    PILS_RESYNC_ENTRY pEntry = *ppEntry;

    while (cEntry--) {
        HANDLE hEvent = pEntry[cEntry].hEvent;
        SetEvent(hEvent);
        CloseHandle(hEvent);
    }

    PkiFree(pEntry);

    *pcEntry = 0;
    *ppEntry = NULL;
}

// Upon entry/exit, the resync list is locked by the caller
void ILS_SignalAndFreeRegStoreResyncEntries(
    IN PREG_STORE pRegStore,
    IN OUT DWORD *pcEntry,
    IN OUT PILS_RESYNC_ENTRY *ppEntry
    )
{
    DWORD cOrigEntry = *pcEntry;
    DWORD cNewEntry = 0;
    PILS_RESYNC_ENTRY pEntry = *ppEntry;
    DWORD i;

    for (i = 0; i < cOrigEntry; i++) {
        if (pEntry[i].pRegStore == pRegStore) {
            HANDLE hEvent = pEntry[i].hEvent;
            SetEvent(hEvent);
            CloseHandle(hEvent);
        } else {
            if (i != cNewEntry)
                pEntry[cNewEntry] = pEntry[i];
            cNewEntry++;
        }
    }

    *pcEntry = cNewEntry;
}

STATIC BOOL ILS_RegNotifyChangeKeyValue(
    IN HKEY hKey,
    IN HANDLE hEvent
    )
{
    BOOL fResult;
    LONG err;

    err = RegNotifyChangeKeyValue(
        hKey,
        TRUE,                       // bWatchSubtree
        REG_NOTIFY_CHANGE_NAME |
        REG_NOTIFY_CHANGE_LAST_SET,
        hEvent,
        TRUE                        // fAsynchronus
        );
    if (!(ERROR_SUCCESS == err || ERROR_KEY_DELETED == err))
        goto RegNotifyChangeKeyValueError;

    fResult = TRUE;

CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR_VAR(RegNotifyChangeKeyValueError, err)
}


//+=========================================================================
//  Client "GPT" Store Data Structures and Functions
//==========================================================================

#define CU_GPT_STORE_INDEX                  0
#define LM_GPT_STORE_INDEX                  1
#define GPT_STORE_COUNT                     2

#ifndef GROUP_POLICY_USER_EVENTA
#define GROUP_POLICY_USER_EVENTA       "UserGroupPolicyApplied"
#endif

#ifndef GROUP_POLICY_MACHINE_EVENTA
#define GROUP_POLICY_MACHINE_EVENTA    "MachineGroupPolicyApplied"
#endif

static LPCSTR rgpszGptStorePolicyEvent[GPT_STORE_COUNT] = {
    GROUP_POLICY_USER_EVENTA,
    GROUP_POLICY_MACHINE_EVENTA
};

static const HKEY rghGptPoliciesBaseKey[GPT_STORE_COUNT] = {
    HKEY_CURRENT_USER,
    HKEY_LOCAL_MACHINE
};

static BOOL fGptStoreInitialized[GPT_STORE_COUNT];
static BOOL fRegisterGPNotification[GPT_STORE_COUNT];
static HKEY rghGptPoliciesKey[GPT_STORE_COUNT];
static HANDLE rghGptStorePolicyEvent[GPT_STORE_COUNT];
static HANDLE rghGptRegWaitFor[GPT_STORE_COUNT];

static DWORD rgcGptStoreResyncEntry[GPT_STORE_COUNT];
static ILS_RESYNC_ENTRY *rgpGptStoreResyncEntry[GPT_STORE_COUNT];


typedef HANDLE (WINAPI *PFN_ENTER_CRITICAL_POLICY_SECTION)(
    IN BOOL bMachine
    );
typedef BOOL (WINAPI *PFN_LEAVE_CRITICAL_POLICY_SECTION)(
    IN HANDLE hSection
    );

typedef BOOL (WINAPI *PFN_REGISTER_GP_NOTIFICATION)(
    IN HANDLE hEvent,
    IN BOOL bMachine
    );

typedef BOOL (WINAPI *PFN_UNREGISTER_GP_NOTIFICATION)(
    IN HANDLE hEvent
    );

#define sz_USERENV_DLL                  "userenv.dll"
#define sz_EnterCriticalPolicySection   "EnterCriticalPolicySection"
#define sz_LeaveCriticalPolicySection   "LeaveCriticalPolicySection"
#define sz_RegisterGPNotification       "RegisterGPNotification"
#define sz_UnregisterGPNotification     "UnregisterGPNotification"

static fLoadedUserEnvDll = FALSE;
static HMODULE hUserEnvDll = NULL;
static PFN_ENTER_CRITICAL_POLICY_SECTION pfnEnterCriticalPolicySection = NULL;
static PFN_LEAVE_CRITICAL_POLICY_SECTION pfnLeaveCriticalPolicySection = NULL;
static PFN_REGISTER_GP_NOTIFICATION pfnRegisterGPNotification = NULL;
static PFN_UNREGISTER_GP_NOTIFICATION pfnUnregisterGPNotification = NULL;


//+-------------------------------------------------------------------------
//  Lock and unlock GPT_STORE functions
//--------------------------------------------------------------------------
static inline void GptStoreLock()
{
    EnterCriticalSection(&ILS_CriticalSection);
}
static inline void GptStoreUnlock()
{
    LeaveCriticalSection(&ILS_CriticalSection);
}

STATIC void GptLoadUserEnvDll()
{
    HMODULE hDll;
    if (fLoadedUserEnvDll)
        return;

    // Do load library without holding a lock
    hDll = LoadLibraryA(sz_USERENV_DLL);

    GptStoreLock();
    if (fLoadedUserEnvDll) {
        if (hDll)
            FreeLibrary(hDll);
        goto CommonReturn;
    }

    if (NULL == hDll)
        goto LoadUserEnvDllError;

    if (pfnEnterCriticalPolicySection =
            (PFN_ENTER_CRITICAL_POLICY_SECTION) GetProcAddress(
                hDll, sz_EnterCriticalPolicySection)) {
        if (NULL == (pfnLeaveCriticalPolicySection =
                (PFN_LEAVE_CRITICAL_POLICY_SECTION) GetProcAddress(
                    hDll, sz_LeaveCriticalPolicySection))) {
            pfnEnterCriticalPolicySection = NULL;
#if DBG
            DWORD dwErr = GetLastError();
            DbgPrintf(DBG_SS_CRYPT32,
                "userenv.dll:: GetProcAddress(%s) returned error: %d 0x%x\n",
                    sz_LeaveCriticalPolicySection, dwErr, dwErr);
#endif
        }
    } else {
#if DBG
        DWORD dwErr = GetLastError();
        DbgPrintf(DBG_SS_CRYPT32,
            "userenv.dll:: GetProcAddress(%s) returned error: %d 0x%x\n",
                sz_EnterCriticalPolicySection, dwErr, dwErr);
#endif
    }

    if (pfnRegisterGPNotification = 
        (PFN_REGISTER_GP_NOTIFICATION) GetProcAddress(
                hDll, sz_RegisterGPNotification)) {
        if (NULL == (pfnUnregisterGPNotification =
                (PFN_UNREGISTER_GP_NOTIFICATION) GetProcAddress(
                    hDll, sz_UnregisterGPNotification))) {
            pfnRegisterGPNotification = NULL; 
#if DBG
            DWORD dwErr = GetLastError();
            DbgPrintf(DBG_SS_CRYPT32,
                "userenv.dll:: GetProcAddress(%s) returned error: %d 0x%x\n",
                    sz_UnregisterGPNotification, dwErr, dwErr);
#endif
        }
    } else {
#if DBG
        DWORD dwErr = GetLastError();
        DbgPrintf(DBG_SS_CRYPT32,
            "userenv.dll:: GetProcAddress(%s) returned error: %d 0x%x\n",
                sz_RegisterGPNotification, dwErr, dwErr);
#endif
    }

    if (pfnEnterCriticalPolicySection || pfnRegisterGPNotification)
        hUserEnvDll = hDll;
    else
        FreeLibrary(hDll);

CommonReturn:
    fLoadedUserEnvDll = TRUE;
    GptStoreUnlock();

    return;
ErrorReturn:
    goto CommonReturn;
TRACE_ERROR(LoadUserEnvDllError)
}

STATIC HANDLE GptStoreEnterCriticalPolicySection(
    IN BOOL bMachine
    )
{
#if 1
    // BUGBUG entering this critical section is causing numerous hanging,
    // deadlock problems
    return NULL;
#else
    HANDLE hSection;

    GptLoadUserEnvDll();
    if (NULL == pfnEnterCriticalPolicySection)
        return NULL;

    assert(hUserEnvDll);
    assert(pfnLeaveCriticalPolicySection);
    if (NULL == (hSection = pfnEnterCriticalPolicySection(bMachine)))
        goto EnterCriticalPolicySectionError;

CommonReturn:
    return hSection;
ErrorReturn:
    goto CommonReturn;

TRACE_ERROR(EnterCriticalPolicySectionError)
#endif
}

STATIC void GptStoreLeaveCriticalPolicySection(
    IN HANDLE hSection
    )
{
    if (hSection) {
        assert(hUserEnvDll);
        assert(pfnLeaveCriticalPolicySection);
        if (!pfnLeaveCriticalPolicySection(hSection))
            goto LeaveCriticalPolicySectionError;
    }

CommonReturn:
    return;
ErrorReturn:
    goto CommonReturn;

TRACE_ERROR(LeaveCriticalPolicySectionError)
}

STATIC void GptStoreSignalAndFreeRegStoreResyncEntries(
    IN PREG_STORE pRegStore
    )
{
    DWORD dwGptStoreIndex;

    GptStoreLock();

    for (dwGptStoreIndex = 0; dwGptStoreIndex < GPT_STORE_COUNT;
                                                        dwGptStoreIndex++) {

        ILS_SignalAndFreeRegStoreResyncEntries(
            pRegStore,
            &rgcGptStoreResyncEntry[dwGptStoreIndex],
            &rgpGptStoreResyncEntry[dwGptStoreIndex]
            );
    }

    GptStoreUnlock();
}

STATIC void GptStoreProcessAttach()
{
}

STATIC void GptStoreProcessDetach()
{
    DWORD dwGptStoreIndex;
    for (dwGptStoreIndex = 0; dwGptStoreIndex < GPT_STORE_COUNT;
                                                        dwGptStoreIndex++) {
        if (!fGptStoreInitialized[dwGptStoreIndex])
            continue;

        // Unregister the wait for callback
        if (rghGptRegWaitFor[dwGptStoreIndex])
            pfnILS_UnregisterWait(rghGptRegWaitFor[dwGptStoreIndex]);

        if (fRegisterGPNotification[dwGptStoreIndex]) {
            assert(hUserEnvDll && pfnUnregisterGPNotification &&
                rghGptStorePolicyEvent[dwGptStoreIndex]);
            pfnUnregisterGPNotification(
                rghGptStorePolicyEvent[dwGptStoreIndex]);
        }

        if (rghGptStorePolicyEvent[dwGptStoreIndex])
            CloseHandle(rghGptStorePolicyEvent[dwGptStoreIndex]);

        // If no RegisterGPNotification API or
        // if we were unable to open the GPT event, then, the following
        // registry key was opened
        ILS_CloseRegistryKey(rghGptPoliciesKey[dwGptStoreIndex]);

        // To inhibit any potential deadlock, do following without entering
        // the critical section
        ILS_SignalEventsOnResyncList(
            &rgcGptStoreResyncEntry[dwGptStoreIndex],
            &rgpGptStoreResyncEntry[dwGptStoreIndex]
            );

        fGptStoreInitialized[dwGptStoreIndex] = FALSE;
    }

    if (hUserEnvDll) {
        FreeLibrary(hUserEnvDll);
        hUserEnvDll = NULL;
    }
}

STATIC VOID NTAPI GptWaitForCallback(
    PVOID Context,
    BOOLEAN fWaitOrTimedOut        // ???
    )
{
    DWORD cEntry;
    PILS_RESYNC_ENTRY pEntry;

    const DWORD dwGptStoreIndex = (DWORD) ((DWORD_PTR)Context);
    assert(dwGptStoreIndex < GPT_STORE_COUNT);

    if (rghGptPoliciesKey[dwGptStoreIndex])
        // Re-arm the registry notify
        ILS_RegNotifyChangeKeyValue(
            rghGptPoliciesKey[dwGptStoreIndex],
            rghGptStorePolicyEvent[dwGptStoreIndex]
            );

    GptStoreLock();
        cEntry = rgcGptStoreResyncEntry[dwGptStoreIndex];
        pEntry = rgpGptStoreResyncEntry[dwGptStoreIndex];

        rgcGptStoreResyncEntry[dwGptStoreIndex] = 0;
        rgpGptStoreResyncEntry[dwGptStoreIndex] = NULL;
    GptStoreUnlock();

    ILS_SignalEventsOnResyncList(
        &cEntry,
        &pEntry
        );

}

STATIC BOOL GptStoreChangeInit(
    IN DWORD dwGptStoreIndex
    )
{
    BOOL fResult;
    DWORD dwErr;
    HANDLE hRegWaitFor;
    HANDLE hTmpEvent;

    if (fGptStoreInitialized[dwGptStoreIndex])
        return TRUE;

    GptLoadUserEnvDll();

    GptStoreLock();

    if (fGptStoreInitialized[dwGptStoreIndex])
        goto SuccessReturn;

    // Create our own event to be notified on a change
    if (NULL ==
        (rghGptStorePolicyEvent[dwGptStoreIndex] =
            CreateEvent(
                NULL,       // lpsa
                FALSE,      // fManualReset
                FALSE,      // fInitialState
                NULL)))     // lpszEventName
            goto CreateEventError;

    // If the RegisterGPNotification API exists in userenv.dll, use it.
    if (pfnRegisterGPNotification) {
        if (pfnRegisterGPNotification(
                rghGptStorePolicyEvent[dwGptStoreIndex],
                dwGptStoreIndex == LM_GPT_STORE_INDEX
                )) {
            fRegisterGPNotification[dwGptStoreIndex] = TRUE;
            goto RegWaitFor;
        }
#if DBG
        else {
            DWORD dwErr = GetLastError();
            DbgPrintf(DBG_SS_CRYPT32,
                "RegisterGPNotification returned error: %d 0x%x\n",
                    dwErr, dwErr);
        }
#endif
    }
    
    // Open the GPT event to be signaled after policy is applied to the
    // registry
    if (hTmpEvent = OpenEventA(
            SYNCHRONIZE,
            FALSE,                  // bInheritHandle
            rgpszGptStorePolicyEvent[dwGptStoreIndex]
            )) {
        CloseHandle(rghGptStorePolicyEvent[dwGptStoreIndex]);
        rghGptStorePolicyEvent[dwGptStoreIndex] = hTmpEvent;
    } else {
#if DBG
        DWORD dwErr = GetLastError();
        DbgPrintf(DBG_SS_CRYPT32, "OpenEvent(%s) returned error: %d 0x%x\n",
            rgpszGptStorePolicyEvent[dwGptStoreIndex], dwErr, dwErr);
#endif

        // Open the Software\Policies\Microsoft\SystemCertificates registry key
        if (NULL == (rghGptPoliciesKey[dwGptStoreIndex] =
                OpenSubKey(
                    rghGptPoliciesBaseKey[dwGptStoreIndex],
                    GROUP_POLICY_STORE_REGPATH,
                    CERT_STORE_READONLY_FLAG
                    ))) {
            // Ignore error if subkey doesn't exist.
            if (ERROR_FILE_NOT_FOUND == GetLastError())
                goto SuccessReturn;
            goto OpenSubKeyError;
        }

        // Arm the registry notify
        if (!ILS_RegNotifyChangeKeyValue(
                rghGptPoliciesKey[dwGptStoreIndex],
                rghGptStorePolicyEvent[dwGptStoreIndex]
                ))
            goto RegNotifyChangeKeyValueError;
    }

RegWaitFor:
    hRegWaitFor = pfnILS_RegisterWaitForSingleObjectEx(
        rghGptStorePolicyEvent[dwGptStoreIndex],
        GptWaitForCallback,
        (PVOID)(DWORD_PTR) dwGptStoreIndex,
        INFINITE,  // no timeout
        (fRegisterGPNotification[dwGptStoreIndex] ||
            rghGptPoliciesKey[dwGptStoreIndex]) ? WT_EXECUTEINWAITTHREAD : 0
        );
    if (INVALID_HANDLE_VALUE == hRegWaitFor || NULL == hRegWaitFor) {
        dwErr = GetLastError();
        goto RegisterWaitForError;
    }

    rghGptRegWaitFor[dwGptStoreIndex] = hRegWaitFor;

SuccessReturn:
    fResult = TRUE;
    fGptStoreInitialized[dwGptStoreIndex] = TRUE;

CommonReturn:
    GptStoreUnlock();
    return fResult;;
ErrorReturn:
    dwErr = GetLastError();

    if (fRegisterGPNotification[dwGptStoreIndex]) {
        assert(hUserEnvDll && pfnUnregisterGPNotification &&
            rghGptStorePolicyEvent[dwGptStoreIndex]);
        pfnUnregisterGPNotification(
            rghGptStorePolicyEvent[dwGptStoreIndex]);
        fRegisterGPNotification[dwGptStoreIndex] = FALSE;
    }

    if (rghGptStorePolicyEvent[dwGptStoreIndex]) {
        CloseHandle(rghGptStorePolicyEvent[dwGptStoreIndex]);
        rghGptStorePolicyEvent[dwGptStoreIndex] = NULL;
    }

    ILS_CloseRegistryKey(rghGptPoliciesKey[dwGptStoreIndex]);
    rghGptPoliciesKey[dwGptStoreIndex] = NULL;

    SetLastError(dwErr);
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(CreateEventError)
TRACE_ERROR(OpenSubKeyError)
TRACE_ERROR(RegNotifyChangeKeyValueError)
SET_ERROR_VAR(RegisterWaitForError, dwErr)
}

STATIC BOOL RegGptStoreChange(
    IN PREG_STORE pRegStore,
    IN HANDLE hEvent
    )
{
    BOOL fResult;

    DWORD dwGptStoreIndex =
        (pRegStore->dwFlags & CERT_REGISTRY_STORE_LM_GPT_FLAG) ?
            LM_GPT_STORE_INDEX : CU_GPT_STORE_INDEX;

    if (pRegStore->dwFlags & CERT_REGISTRY_STORE_REMOTE_FLAG) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if (!GptStoreChangeInit(dwGptStoreIndex))
        return FALSE;

    GptStoreLock();
    fResult = ILS_AddEventToResyncList(
            pRegStore,
            hEvent,
            &rgcGptStoreResyncEntry[dwGptStoreIndex],
            &rgpGptStoreResyncEntry[dwGptStoreIndex]
            );
    GptStoreUnlock();
    return fResult;
}

STATIC BOOL OpenAllFromGptRegistry(
    IN PREG_STORE pRegStore,
    IN HCERTSTORE hCertStore
    )
{
    BOOL fResult;
    HANDLE hSection = NULL;

    LockRegStore(pRegStore);

    if (0 == (pRegStore->dwFlags & CERT_REGISTRY_STORE_REMOTE_FLAG))
        hSection = GptStoreEnterCriticalPolicySection(
            pRegStore->dwFlags & CERT_REGISTRY_STORE_LM_GPT_FLAG
            );

    assert(NULL == pRegStore->hKey);
    if (NULL == (pRegStore->hKey = OpenSubKey(
            pRegStore->GptPara.hKeyBase,
            pRegStore->GptPara.pwszRegPath,
            pRegStore->dwFlags
            ))) {
        if (ERROR_FILE_NOT_FOUND != GetLastError() ||
                (pRegStore->dwFlags & CERT_STORE_OPEN_EXISTING_FLAG))
            goto OpenSubKeyError;
        fResult = TRUE;
        goto CommonReturn;
    }

//    fResult = OpenAllFromSerializedRegistry(pRegStore, hCertStore);

    // Ignore any errors
    OpenAllFromRegistry(pRegStore, hCertStore);
    fResult = TRUE;

CommonReturn:
    ILS_CloseRegistryKey(pRegStore->hKey);
    pRegStore->hKey = NULL;
    GptStoreLeaveCriticalPolicySection(hSection);
    UnlockRegStore(pRegStore);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OpenSubKeyError)
}

STATIC BOOL CommitAllToGptRegistry(
    IN PREG_STORE pRegStore,
    IN DWORD dwFlags
    )
{
#if 1
    return TRUE;
#else
    BOOL fResult;
    BOOL fTouched;
    DWORD dwSaveFlags;

    LockRegStore(pRegStore);

    if (dwFlags & CERT_STORE_CTRL_COMMIT_FORCE_FLAG)
        fTouched = TRUE;
    else if (dwFlags & CERT_STORE_CTRL_COMMIT_CLEAR_FLAG)
        fTouched = FALSE;
    else
        fTouched = pRegStore->fTouched;

    if (fTouched) {
        if (pRegStore->dwFlags & CERT_STORE_READONLY_FLAG)
            goto AccessDenied;
    } else {
        pRegStore->fTouched = FALSE;
        fResult = TRUE;
        goto CommonReturn;
    }

    assert(NULL == pRegStore->hKey);
    if (NULL == (pRegStore->hKey = OpenSubKey(
            pRegStore->GptPara.hKeyBase,
            pRegStore->GptPara.pwszRegPath,
            pRegStore->dwFlags
            )))
        goto OpenSubKeyError;

    dwSaveFlags = pRegStore->dwFlags;
    pRegStore->dwFlags &= ~CERT_STORE_OPEN_EXISTING_FLAG;
    fResult = CommitAllToSerializedRegistry(pRegStore, dwFlags);
    pRegStore->dwFlags = dwSaveFlags;
CommonReturn:
    ILS_CloseRegistryKey(pRegStore->hKey);
    pRegStore->hKey = NULL;
    UnlockRegStore(pRegStore);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(AccessDenied, E_ACCESSDENIED)
TRACE_ERROR(OpenSubKeyError)
#endif
}

#endif

#ifndef CE_BUILD // GEORGEJ - could add this back later, if needed 
//+=========================================================================
//  Win95 Notify Store Data Structures and Functions
//
//  Win95/Win98 don't support registry change notification.
//
//  On Win95 we pulse an event each time a store context element is written
//  or deleted.
//==========================================================================
static BOOL fWin95StoreInitialized;
static HANDLE hWin95RegWaitFor;

static DWORD cWin95StoreResyncEntry;
static ILS_RESYNC_ENTRY *pWin95StoreResyncEntry;


//+-------------------------------------------------------------------------
//  Lock and unlock WIN95_STORE functions
//--------------------------------------------------------------------------
static inline void Win95StoreLock()
{
    EnterCriticalSection(&ILS_CriticalSection);
}
static inline void Win95StoreUnlock()
{
    LeaveCriticalSection(&ILS_CriticalSection);
}

STATIC void Win95StoreSignalAndFreeRegStoreResyncEntries(
    IN PREG_STORE pRegStore
    )
{
    if (NULL == hWin95NotifyEvent)
        return;

    Win95StoreLock();

    ILS_SignalAndFreeRegStoreResyncEntries(
        pRegStore,
        &cWin95StoreResyncEntry,
        &pWin95StoreResyncEntry
        );

    Win95StoreUnlock();
}

STATIC void Win95StoreProcessAttach()
{
    HKEY hKey = NULL;
    HANDLE hEvent = NULL;

    if (FIsWinNT())
        return;

    // Check if Win98. Win98 supports Registry Change Notify
    if (NULL == (hKey = OpenSubKey(
            HKEY_CURRENT_USER,
            L"Software",
            CERT_STORE_READONLY_FLAG
            )))
        goto Win95StoreProcessAttachOpenSubKeyError;

    if (NULL == (hEvent = CreateEvent(
            NULL,       // lpsa
            FALSE,      // fManualReset
            FALSE,      // fInitialState
            NULL)))     // lpszEventName
        goto Win95StoreProcessAttachCreateEventError;

    if (ILS_RegNotifyChangeKeyValue(
            hKey,
            hEvent
            )) {
#if DBG
        DbgPrintf(DBG_SS_CRYPT32,
            "Win95Store:: RegNotifyChangeKeyValue Succeeded\n");
#endif
        goto CommonReturn;
    }


#if DBG
    DbgPrintf(DBG_SS_CRYPT32,
        "Win95Store:: RegNotifyChangeKeyValue Failed\n");
#endif

    hWin95NotifyEvent = CreateEventA(
            NULL,           // lpsa
            TRUE,           // fManualReset
            FALSE,          // fInitialState
            "Win95CertStoreNotifyEvent"
            );
    if (NULL == hWin95NotifyEvent)
        goto CreateWin95NotifyEventError;

CommonReturn:
    ILS_CloseRegistryKey(hKey);
    if (hEvent)
        CloseHandle(hEvent);
    return;
ErrorReturn:
    goto CommonReturn;
TRACE_ERROR(Win95StoreProcessAttachOpenSubKeyError)
TRACE_ERROR(Win95StoreProcessAttachCreateEventError)
TRACE_ERROR(CreateWin95NotifyEventError)
}

STATIC void Win95StoreProcessDetach()
{
    if (NULL == hWin95NotifyEvent)
        return;

    if (fWin95StoreInitialized) {
        // Unregister the wait for callback
        assert(hWin95RegWaitFor);
        pfnILS_UnregisterWait(hWin95RegWaitFor);

        // To inhibit any potential deadlock, do following without entering
        // the critical section
        ILS_SignalEventsOnResyncList(
            &cWin95StoreResyncEntry,
            &pWin95StoreResyncEntry
            );

        fWin95StoreInitialized = FALSE;
    }

    CloseHandle(hWin95NotifyEvent);
}

STATIC VOID NTAPI Win95WaitForCallback(
    PVOID Context,
    BOOLEAN fWaitOrTimedOut        // ???
    )
{
    DWORD cEntry;
    PILS_RESYNC_ENTRY pEntry;

    Win95StoreLock();
        cEntry = cWin95StoreResyncEntry;
        pEntry = pWin95StoreResyncEntry;

        cWin95StoreResyncEntry = 0;
        pWin95StoreResyncEntry = NULL;
    Win95StoreUnlock();

    ILS_SignalEventsOnResyncList(
        &cEntry,
        &pEntry
        );
}

STATIC BOOL Win95StoreChangeInit()
{
    BOOL fResult;
    DWORD dwErr;
    HANDLE hRegWaitFor;

    if (fWin95StoreInitialized)
        return TRUE;

    Win95StoreLock();

    if (fWin95StoreInitialized)
        goto SuccessReturn;

    assert(hWin95NotifyEvent);
    hRegWaitFor = pfnILS_RegisterWaitForSingleObjectEx(
        hWin95NotifyEvent,
        Win95WaitForCallback,
        NULL,                   // Context
        INFINITE,               // no timeout
        0                       // no flags (normal)
        );
    if (INVALID_HANDLE_VALUE == hRegWaitFor || NULL == hRegWaitFor) {
        dwErr = GetLastError();
        goto RegisterWaitForError;
    }

    hWin95RegWaitFor = hRegWaitFor;

SuccessReturn:
    fResult = TRUE;
    fWin95StoreInitialized = TRUE;

CommonReturn:
    Win95StoreUnlock();
    return fResult;;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR_VAR(RegisterWaitForError, dwErr)
}

STATIC BOOL RegWin95StoreChange(
    IN PREG_STORE pRegStore,
    IN HANDLE hEvent
    )
{
    BOOL fResult;

    assert(hWin95NotifyEvent);

    if (!Win95StoreChangeInit())
        return FALSE;

    Win95StoreLock();
    fResult = ILS_AddEventToResyncList(
            pRegStore,
            hEvent,
            &cWin95StoreResyncEntry,
            &pWin95StoreResyncEntry
            );
    Win95StoreUnlock();
    return fResult;
}

#endif //CE_BUILD

//+=========================================================================
// Roaming Store Functions
//==========================================================================

#if 0
SHSTDAPI SHGetFolderPathW(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPWSTR lpszPath);
#endif

typedef HRESULT (STDAPICALLTYPE *PFN_GET_FOLDER_PATH) (
    HWND hwnd,
    int csidl,
    HANDLE hToken,
    DWORD dwFlags,
    LPWSTR lpszPath
    );

#define sz_SHELL32_DLL              "shell32.dll"
#define sz_GetFolderPath            "SHGetFolderPathW"

static fLoadedShell32Dll = FALSE;
static HMODULE hShell32Dll = NULL;
static PFN_GET_FOLDER_PATH pfnGetFolderPath = NULL;

static inline void RoamingStoreLock()
{
    EnterCriticalSection(&ILS_CriticalSection);
}
static inline void RoamingStoreUnlock()
{
    LeaveCriticalSection(&ILS_CriticalSection);
}

STATIC void RoamingStoreProcessAttach()
{
}

STATIC void RoamingStoreProcessDetach()
{
    if (hShell32Dll) {
        FreeLibrary(hShell32Dll);
        hShell32Dll = NULL;
    }
}

#ifndef CE_BUILD

STATIC void RoamingStoreLoadShell32Dll()
{
    if (fLoadedShell32Dll)
        return;

    RoamingStoreLock();
    if (fLoadedShell32Dll)
        goto CommonReturn;

    if (NULL == (hShell32Dll = LoadLibraryA(sz_SHELL32_DLL)))
        goto LoadShell32DllError;

    if (NULL == (pfnGetFolderPath =
            (PFN_GET_FOLDER_PATH) GetProcAddress(hShell32Dll,
                sz_GetFolderPath)))
        goto GetFolderPathProcAddressError;

CommonReturn:
    fLoadedShell32Dll = TRUE;
    RoamingStoreUnlock();
    return;

ErrorReturn:
    if (hShell32Dll) {
        FreeLibrary(hShell32Dll);
        hShell32Dll = NULL;
        pfnGetFolderPath = NULL;
    }
    goto CommonReturn;
TRACE_ERROR(LoadShell32DllError)
TRACE_ERROR(GetFolderPathProcAddressError)
}

STATIC HANDLE GetRoamingToken()
{
    HANDLE hToken = NULL;
    DWORD dwErr;

    if (!FIsWinNT()) {
        return NULL;
    }

    //
    // first, attempt to look at the thread token.  If none exists,
    // which is true if the thread is not impersonating, try the
    // process token.
    //

    if (!OpenThreadToken(
                GetCurrentThread(),
                TOKEN_QUERY | TOKEN_IMPERSONATE,
                TRUE,
                &hToken
                )) {
        dwErr = GetLastError();
        if (ERROR_NO_TOKEN != dwErr)
            goto OpenThreadTokenError;

        if (!OpenProcessToken(GetCurrentProcess(),
                TOKEN_QUERY | TOKEN_IMPERSONATE | TOKEN_DUPLICATE, &hToken)) {
            dwErr = GetLastError();
            goto OpenProcessTokenError;
        }
    }

CommonReturn:
    return hToken;
ErrorReturn:
    hToken = NULL;
    goto CommonReturn;
SET_ERROR_VAR(OpenThreadTokenError, dwErr)
SET_ERROR_VAR(OpenProcessTokenError, dwErr)
}

#endif

LPWSTR
ILS_GetRoamingStoreDirectory(
    IN LPCWSTR pwszStoreName
    )
{
    HANDLE hToken = NULL;
    LPWSTR pwszDir = NULL;
    WCHAR wszFolderPath[MAX_PATH];
    LPCWSTR rgpwszName[] = { wszFolderPath, pwszStoreName };
    SYSTEM_NAME_GROUP NameGroup;

// BUGBUG:: Remove following goto once the following APIs work during
// impersonation.
#if 0
    goto ErrorReturn;
#endif

#ifdef CE_BUILD
    wcscpy(wszFolderPath, L"\\Roaming");
#else
    HRESULT hr;
    RoamingStoreLoadShell32Dll();
    if (NULL == hShell32Dll)
        goto ErrorReturn;
    assert(pfnGetFolderPath);

    hToken = GetRoamingToken();
    wszFolderPath[0] = L'\0';
    hr = pfnGetFolderPath(
            NULL,                   // hwndOwner
            CSIDL_APPDATA | CSIDL_FLAG_CREATE,
            hToken,
            0,                      // dwFlags
            wszFolderPath
            );
    if (S_OK != hr || L'\0' == wszFolderPath[0])
        goto GetFolderPathError;
#endif

#if DBG
        DbgPrintf(DBG_SS_CRYPT32, "SHFolderPath(CSIDL_APPDATA):: %S\n",
            wszFolderPath);
#endif

    NameGroup.cName = sizeof(rgpwszName) / sizeof(rgpwszName[0]);
    NameGroup.rgpwszName = rgpwszName;
    if (NULL == (pwszDir = FormatSystemNamePath(1, &NameGroup)))
        goto FormatSystemNamePathError;

CommonReturn:
    if (hToken)
        CloseHandle(hToken);
    return pwszDir;
ErrorReturn:
    pwszDir = NULL;
    goto CommonReturn;

#ifndef CE_BUILD
SET_ERROR_VAR(GetFolderPathError, hr)
#endif
TRACE_ERROR(FormatSystemNamePathError)
}

STATIC BOOL RecursiveCreateDirectory(
    IN LPCWSTR pwszDir
    )
{
    BOOL fResult;

    DWORD dwAttr;
    DWORD dwErr;
    LPCWSTR pwsz;
    DWORD cch;
    WCHAR wch;
    LPWSTR pwszParent = NULL;

    dwAttr = GetFileAttributesU(pwszDir);

    if (0xFFFFFFFF != dwAttr) {
        if (FILE_ATTRIBUTE_DIRECTORY & dwAttr)
            return TRUE;
        goto InvalidDirectoryAttr;
    }

    dwErr = GetLastError();
    if (!(ERROR_PATH_NOT_FOUND == dwErr || ERROR_FILE_NOT_FOUND == dwErr))
        goto GetFileAttrError;

    if (CreateDirectoryU(
            pwszDir,
            NULL                // lpSecurityAttributes
            )) {
        SetFileAttributesU(pwszDir, FILE_ATTRIBUTE_SYSTEM);
        return TRUE;
    }

    dwErr = GetLastError();
    if (!(ERROR_PATH_NOT_FOUND == dwErr || ERROR_FILE_NOT_FOUND == dwErr))
        goto CreateDirectoryError;

    // Peal off the last path name component
    cch = wcslen(pwszDir);
    pwsz = pwszDir + cch;

    while (L'\\' != *pwsz) {
        if (pwsz == pwszDir)
            // Path didn't have a \.
            goto BadDirectoryPath;
        pwsz--;
    }

    cch = (DWORD)(pwsz - pwszDir);
    if (0 == cch)
        // Detected leading \Path
        goto BadDirectoryPath;


    // Check for leading \\ or x:\.
    wch = *(pwsz - 1);
    if ((1 == cch && L'\\' == wch) || (2 == cch && L':' == wch))
        goto BadDirectoryPath;

    if (NULL == (pwszParent = (LPWSTR) PkiNonzeroAlloc((cch + 1) *
            sizeof(WCHAR))))
        goto OutOfMemory;
    memcpy(pwszParent, pwszDir, cch * sizeof(WCHAR));
    pwszParent[cch] = L'\0';

    if (!RecursiveCreateDirectory(pwszParent))
        goto ErrorReturn;
    if (!CreateDirectoryU(
            pwszDir,
            NULL                // lpSecurityAttributes
            )) {
        dwErr = GetLastError();
        goto CreateDirectory2Error;
    }
    SetFileAttributesU(pwszDir, FILE_ATTRIBUTE_SYSTEM);

    fResult = TRUE;
CommonReturn:
    PkiFree(pwszParent);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidDirectoryAttr, ERROR_FILE_INVALID)
SET_ERROR_VAR(GetFileAttrError, dwErr)
SET_ERROR_VAR(CreateDirectoryError, dwErr)
SET_ERROR(BadDirectoryPath, ERROR_BAD_PATHNAME)
TRACE_ERROR(OutOfMemory)
SET_ERROR_VAR(CreateDirectory2Error, dwErr)
}

static DWORD rgdwCreateFileRetryMilliseconds[] =
    { 1, 10, 100, 500, 1000, 5000 };

#define MAX_CREATE_FILE_RETRY_COUNT     \
            (sizeof(rgdwCreateFileRetryMilliseconds) / \
                sizeof(rgdwCreateFileRetryMilliseconds[0]))

BOOL
ILS_ReadElementFromFile(
    IN LPCWSTR pwszStoreDir,
    IN LPCWSTR pwszContextName,
    IN const WCHAR wszHashName[MAX_HASH_NAME_LEN],
    IN DWORD dwFlags,
    OUT BYTE **ppbElement,
    OUT DWORD *pcbElement
    )
{
    BOOL fResult;
    DWORD dwErr;
    LPWSTR pwszFilename = NULL;
    LPCWSTR rgpwszName[] = { pwszStoreDir, pwszContextName, wszHashName };
    SYSTEM_NAME_GROUP NameGroup;

    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD cbBytesRead;
    BYTE *pbElement = NULL;
    DWORD cbElement;
    DWORD dwRetryCount;

    NameGroup.cName = sizeof(rgpwszName) / sizeof(rgpwszName[0]);
    NameGroup.rgpwszName = rgpwszName;
    if (NULL == (pwszFilename = FormatSystemNamePath(1, &NameGroup)))
        goto FormatSystemNamePathError;

    dwRetryCount = 0;
    while (INVALID_HANDLE_VALUE == (hFile = CreateFileU(
              pwszFilename,
              GENERIC_READ,
              FILE_SHARE_READ,
              NULL,                   // lpsa
              OPEN_EXISTING,
              FILE_ATTRIBUTE_NORMAL,
              NULL                    // hTemplateFile
              ))) {
        dwErr = GetLastError();
        if ((ERROR_SHARING_VIOLATION == dwErr ||
                ERROR_ACCESS_DENIED == dwErr) &&
                MAX_CREATE_FILE_RETRY_COUNT > dwRetryCount) {
            Sleep(rgdwCreateFileRetryMilliseconds[dwRetryCount]);
            dwRetryCount++;
        } else {
            if (ERROR_PATH_NOT_FOUND == dwErr)
                dwErr = ERROR_FILE_NOT_FOUND;
            goto CreateFileError;
        }
    }

    cbElement = GetFileSize(hFile, NULL);
    if (0xFFFFFFFF == cbElement) goto FileSizeError;
    if (0 == cbElement) goto EmptyFile;
    if (NULL == (pbElement = (BYTE *) PkiNonzeroAlloc(cbElement)))
        goto OutOfMemory;
    if (!ReadFile(
            hFile,
            pbElement,
            cbElement,
            &cbBytesRead,
            NULL            // lpOverlapped
            )) {
        dwErr = GetLastError();
        goto FileError;
    }

    fResult = TRUE;
CommonReturn:
    PkiFree(pwszFilename);
    if (INVALID_HANDLE_VALUE != hFile)
        CloseHandle(hFile);
    *ppbElement = pbElement;
    *pcbElement = cbElement;
    return fResult;
ErrorReturn:
    fResult = FALSE;
    PkiFree(pbElement);
    pbElement = NULL;
    cbElement = 0;
    goto CommonReturn;

TRACE_ERROR(FormatSystemNamePathError)
TRACE_ERROR(OutOfMemory)
SET_ERROR_VAR(CreateFileError, dwErr)
TRACE_ERROR(FileSizeError)
SET_ERROR_VAR(FileError, dwErr)
SET_ERROR(EmptyFile, CRYPT_E_FILE_ERROR)
}

BOOL
ILS_WriteElementToFile(
    IN LPCWSTR pwszStoreDir,
    IN LPCWSTR pwszContextName,
    IN const WCHAR wszHashName[MAX_HASH_NAME_LEN],
    IN DWORD dwFlags,       // CERT_STORE_CREATE_NEW_FLAG may be set
    IN const BYTE *pbElement,
    IN DWORD cbElement
    )
{
    BOOL fResult;
    DWORD dwErr;
    LPWSTR pwszDir = NULL;
    LPWSTR pwszFilename = NULL;
    LPCWSTR rgpwszName[] = { pwszStoreDir, pwszContextName, wszHashName };
    SYSTEM_NAME_GROUP NameGroup;

    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD cbBytesWritten;
    DWORD dwRetryCount;

    NameGroup.cName = sizeof(rgpwszName) / sizeof(rgpwszName[0]);
    NameGroup.rgpwszName = rgpwszName;
    if (NULL == (pwszFilename = FormatSystemNamePath(1, &NameGroup)))
        goto FormatSystemNamePathError;
    NameGroup.cName--;
    if (NULL == (pwszDir = FormatSystemNamePath(1, &NameGroup)))
        goto FormatSystemNamePathError;

    if (!RecursiveCreateDirectory(pwszDir))
        goto CreateDirError;

    dwRetryCount = 0;
    while (INVALID_HANDLE_VALUE == (hFile = CreateFileU(
            pwszFilename,
            GENERIC_WRITE,
            0,                        // fdwShareMode
            NULL,                     // lpsa
            (dwFlags & CERT_STORE_CREATE_NEW_FLAG) ?
                CREATE_NEW : CREATE_ALWAYS,
            FILE_ATTRIBUTE_SYSTEM,
            NULL                      // hTemplateFile
            ))) {
        dwErr = GetLastError();
        if ((ERROR_SHARING_VIOLATION == dwErr ||
                ERROR_ACCESS_DENIED == dwErr) &&
                MAX_CREATE_FILE_RETRY_COUNT > dwRetryCount) {
            Sleep(rgdwCreateFileRetryMilliseconds[dwRetryCount]);
            dwRetryCount++;
        } else
            goto CreateFileError;
    }

    if (!WriteFile(
            hFile,
            pbElement,
            cbElement,
            &cbBytesWritten,
            NULL            // lpOverlapped
            )) {
        dwErr = GetLastError();
        goto WriteFileError;
    }

    fResult = TRUE;
CommonReturn:
    if (INVALID_HANDLE_VALUE != hFile)
        CloseHandle(hFile);
    PkiFree(pwszFilename);
    PkiFree(pwszDir);

    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(FormatSystemNamePathError)
TRACE_ERROR(CreateDirError)
SET_ERROR_VAR(CreateFileError, dwErr)
SET_ERROR_VAR(WriteFileError, dwErr)
}

BOOL
ILS_DeleteElementFromDirectory(
    IN LPCWSTR pwszStoreDir,
    IN LPCWSTR pwszContextName,
    IN const WCHAR wszHashName[MAX_HASH_NAME_LEN],
    IN DWORD dwFlags
    )
{
    BOOL fResult;
    DWORD dwErr;
    LPWSTR pwszFilename = NULL;
    LPCWSTR rgpwszName[] = { pwszStoreDir, pwszContextName, wszHashName };
    SYSTEM_NAME_GROUP NameGroup;
    DWORD dwRetryCount;

    NameGroup.cName = sizeof(rgpwszName) / sizeof(rgpwszName[0]);
    NameGroup.rgpwszName = rgpwszName;
    if (NULL == (pwszFilename = FormatSystemNamePath(1, &NameGroup)))
        goto FormatSystemNamePathError;

    dwRetryCount = 0;
    while (!DeleteFileU(pwszFilename)) {
        dwErr = GetLastError();
        if ((ERROR_SHARING_VIOLATION == dwErr ||
                ERROR_ACCESS_DENIED == dwErr) &&
                MAX_CREATE_FILE_RETRY_COUNT > dwRetryCount) {
            Sleep(rgdwCreateFileRetryMilliseconds[dwRetryCount]);
            dwRetryCount++;
        } else
            goto DeleteFileError;
    }

    fResult = TRUE;

CommonReturn:
    PkiFree(pwszFilename);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(FormatSystemNamePathError)
SET_ERROR_VAR(DeleteFileError, dwErr)
}

#ifndef CE_BUILD
STATIC HANDLE FindFirstFileU(
    LPCWSTR pwszDir,
    LPWIN32_FIND_DATAA lpFindFileData
    )
{
    HANDLE hFindFile;
    BYTE rgb[_MAX_PATH];
    LPSTR pszDir;

    if (!MkMBStr(rgb, _MAX_PATH, pwszDir, &pszDir))
        return INVALID_HANDLE_VALUE;

    hFindFile = FindFirstFileA(pszDir, lpFindFileData);
    FreeMBStr(rgb, pszDir);
    return hFindFile;
}
#else // CE_BUILD
STATIC HANDLE FindFirstFileU(
    LPCWSTR pwszDir,
    LPWIN32_FIND_DATAW lpFindFileData
    )
{
    HANDLE hFindFile;
	hFindFile = FindFirstFileW(pwszDir, lpFindFileData);
	if (hFindFile==INVALID_HANDLE_VALUE && GetLastError() == ERROR_NO_MORE_FILES )
	{	// Fix the error code on CE
		SetLastError(ERROR_FILE_NOT_FOUND);
	}
    return hFindFile;
}
#endif


BOOL
ILS_OpenAllElementsFromDirectory(
    IN LPCWSTR pwszStoreDir,
    IN LPCWSTR pwszContextName,
    IN DWORD dwFlags,
    IN void *pvArg,
    IN PFN_ILS_OPEN_ELEMENT pfnOpenElement
    )
{
    BOOL fResult;
    DWORD dwErr;
    LPWSTR pwszDir = NULL;
    LPCWSTR rgpwszName[] = { pwszStoreDir, pwszContextName, L"*" };
    SYSTEM_NAME_GROUP NameGroup;

    HANDLE hFindFile = INVALID_HANDLE_VALUE;
#ifndef CE_BUILD    
    WIN32_FIND_DATAA FindFileData;
#else
	WIN32_FIND_DATAW FindFileData;
#endif	

    NameGroup.cName = sizeof(rgpwszName) / sizeof(rgpwszName[0]);
    NameGroup.rgpwszName = rgpwszName;
    if (NULL == (pwszDir = FormatSystemNamePath(1, &NameGroup)))
        goto FormatSystemNamePathError;

    if (INVALID_HANDLE_VALUE == (hFindFile = FindFirstFileU(
            pwszDir,
            &FindFileData
            ))) {
        dwErr = GetLastError();
        if (!(ERROR_PATH_NOT_FOUND == dwErr || ERROR_FILE_NOT_FOUND == dwErr))
            goto FindFirstFileError;

        if (dwFlags & CERT_STORE_READONLY_FLAG)
            goto FindFirstFileError;

        // Attempt to create the directory. Need to remove trailing L"*".
        PkiFree(pwszDir);
        NameGroup.cName--;
        if (NULL == (pwszDir = FormatSystemNamePath(1, &NameGroup)))
            goto FormatSystemNamePathError;
        if (!RecursiveCreateDirectory(pwszDir))
            goto CreateDirError;

        goto SuccessReturn;
    }

    while (TRUE) {
        if (0 == (FILE_ATTRIBUTE_DIRECTORY & FindFileData.dwFileAttributes) &&
                0 == FindFileData.nFileSizeHigh &&
                0 != FindFileData.nFileSizeLow) {
#ifndef CE_BUILD
            WCHAR wszHashName[MAX_HASH_NAME_LEN];
            DWORD cchFilename;

            cchFilename = strlen(FindFileData.cFileName);
            if (0 != cchFilename && MAX_HASH_NAME_LEN > cchFilename &&
                    0 < MultiByteToWideChar(
                        CP_ACP,
                        0,                      // dwFlags
                        FindFileData.cFileName,
                        cchFilename + 1,
                        wszHashName,
                        MAX_HASH_NAME_LEN
                        )) 
#else
			WCHAR *wszHashName = FindFileData.cFileName;
			if (*wszHashName)
#endif			
            {
                BYTE *pbElement;
                DWORD cbElement;

                if (ILS_ReadElementFromFile(
                        pwszStoreDir,
                        pwszContextName,
                        wszHashName,
                        0,                      // dwFlags
                        &pbElement,
                        &cbElement
                        )) {
                    fResult = pfnOpenElement(
                        wszHashName,
                        pbElement,
                        cbElement,
                        pvArg
                        );

                    PkiFree(pbElement);
                    if (!fResult)
                        goto CommonReturn;
                }
            }
        }


#ifndef CE_BUILD
        if (!FindNextFileA(hFindFile, &FindFileData)) 
#else
        if (!FindNextFileW(hFindFile, &FindFileData)) 
#endif	
        {
            dwErr = GetLastError();
            if (ERROR_NO_MORE_FILES == dwErr)
                goto SuccessReturn;
            else
                goto FindNextFileError;
        }
    }

SuccessReturn:
    fResult = TRUE;

CommonReturn:
    PkiFree(pwszDir);
    if (INVALID_HANDLE_VALUE != hFindFile)
        FindClose(hFindFile);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(FormatSystemNamePathError)
SET_ERROR_VAR(FindFirstFileError, dwErr)
TRACE_ERROR(CreateDirError)
SET_ERROR_VAR(FindNextFileError, dwErr)
}

#ifndef CE_BUILD
//+=========================================================================
// Registry or Roaming Store Change Notify Functions
//==========================================================================

HANDLE
WINAPI
FindFirstChangeNotificationU(
    LPCWSTR pwszPath,
    BOOL bWatchSubtree,
    DWORD dwNotifyFilter
    )
{
    if (FIsWinNT())
        return FindFirstChangeNotificationW(
            pwszPath, bWatchSubtree, dwNotifyFilter);

    HANDLE hChange;
    BYTE rgb[_MAX_PATH];
    LPSTR pszPath;

    if (!MkMBStr(rgb, _MAX_PATH, pwszPath, &pszPath))
        return INVALID_HANDLE_VALUE;

    hChange = FindFirstChangeNotificationA(pszPath, bWatchSubtree,
        dwNotifyFilter);
    FreeMBStr(rgb, pszPath);
    return hChange;
}

STATIC VOID NTAPI RegistryStoreChangeCallback(
    PVOID Context,
    BOOLEAN fWaitOrTimedOut        // ???
    )
{
    BOOL fRearm;
    DWORD dwErr;
    PREG_STORE pRegStore = (PREG_STORE) Context;
    PREGISTRY_STORE_CHANGE_INFO pInfo;

    DWORD cEntry;
    PILS_RESYNC_ENTRY pEntry;

    pInfo = pRegStore->pRegistryStoreChangeInfo;
    assert(pInfo);
    if (NULL == pInfo)
        return;

    if (pRegStore->dwFlags & CERT_REGISTRY_STORE_ROAMING_FLAG)
        fRearm = FindNextChangeNotification(pInfo->hChange);
    else
        fRearm = ILS_RegNotifyChangeKeyValue(pRegStore->hKey, pInfo->hChange);
    if (!fRearm)
        dwErr = GetLastError();

    // Minimize window of potential deadlock by only getting the values
    // while holding the lock.
    LockRegStore(pRegStore);
    cEntry = pInfo->cNotifyEntry;
    pEntry = pInfo->rgNotifyEntry;

    pInfo->cNotifyEntry = 0;
    pInfo->rgNotifyEntry = NULL;
    UnlockRegStore(pRegStore);

    ILS_SignalEventsOnResyncList(&cEntry, &pEntry);

    if (!fRearm)
        goto RegistryStoreChangeRearmError;
CommonReturn:
    return;
ErrorReturn:
    goto CommonReturn;
SET_ERROR_VAR(RegistryStoreChangeRearmError, dwErr)
}

// Upon entry/exit the pRegStore is locked
STATIC BOOL InitRegistryStoreChange(
    IN PREG_STORE pRegStore
    )
{
    BOOL fResult;
    DWORD dwErr;
    BOOL fRoaming;
    PREGISTRY_STORE_CHANGE_INFO pInfo = NULL;
    HANDLE hChange = INVALID_HANDLE_VALUE;
    HANDLE hRegWaitFor;

    fRoaming = (pRegStore->dwFlags & CERT_REGISTRY_STORE_ROAMING_FLAG);

    assert(NULL == pRegStore->pRegistryStoreChangeInfo);
    if (NULL == (pInfo = (PREGISTRY_STORE_CHANGE_INFO) PkiZeroAlloc(
            sizeof(REGISTRY_STORE_CHANGE_INFO))))
        goto OutOfMemory;

    if (fRoaming) {
        if (INVALID_HANDLE_VALUE == (hChange = FindFirstChangeNotificationU(
                pRegStore->pwszStoreDirectory,
                TRUE,                           // bWatchSubtree
                FILE_NOTIFY_CHANGE_FILE_NAME |
                    FILE_NOTIFY_CHANGE_DIR_NAME |
                    FILE_NOTIFY_CHANGE_SIZE |
                    FILE_NOTIFY_CHANGE_LAST_WRITE
                ))) {
            dwErr = GetLastError();
            goto FindFirstChangeNotificationError;
        }
    } else {
        if (NULL == (hChange = CreateEvent(
                NULL,       // lpsa
                FALSE,      // fManualReset
                FALSE,      // fInitialState
                NULL)))     // lpszEventName
            goto CreateEventError;
        assert(pRegStore->hKey);
        if (!ILS_RegNotifyChangeKeyValue(pRegStore->hKey, hChange))
            goto RegNotifyChangeKeyValueError;
    }
    pInfo->hChange = hChange;

    // The following must be set before the following register.
    // The thread may be scheduled to run before the function returns.
    pRegStore->pRegistryStoreChangeInfo = pInfo;

    hRegWaitFor = pfnILS_RegisterWaitForSingleObjectEx(
        hChange,
        RegistryStoreChangeCallback,
        (PVOID) pRegStore,
        INFINITE,                                      // no timeout
        WT_EXECUTEINWAITTHREAD
        );
    if (INVALID_HANDLE_VALUE == hRegWaitFor || NULL == hRegWaitFor) {
        pRegStore->pRegistryStoreChangeInfo = NULL;
        dwErr = GetLastError();
        goto RegisterWaitForError;
    }

    pInfo->hRegWaitFor = hRegWaitFor;
    fResult = TRUE;

CommonReturn:
    return fResult;
ErrorReturn:
    if (INVALID_HANDLE_VALUE != hChange && hChange) {
        if (fRoaming)
            FindCloseChangeNotification(hChange);
        else
            CloseHandle(hChange);
    }
    PkiFree(pInfo);
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
SET_ERROR_VAR(FindFirstChangeNotificationError, dwErr)
TRACE_ERROR(CreateEventError)
TRACE_ERROR(RegNotifyChangeKeyValueError)
SET_ERROR_VAR(RegisterWaitForError, dwErr)
}

STATIC BOOL RegRegistryStoreChange(
    IN PREG_STORE pRegStore,
    IN HANDLE hEvent
    )
{
    BOOL fResult;
    PREGISTRY_STORE_CHANGE_INFO pInfo;

    LockRegStore(pRegStore);

    if (NULL == (pInfo = pRegStore->pRegistryStoreChangeInfo)) {
        if (!InitRegistryStoreChange(pRegStore))
            goto ChangeInitError;
        pInfo = pRegStore->pRegistryStoreChangeInfo;
        assert(pInfo);
    }

    if (!ILS_AddEventToResyncList(
            pRegStore,
            hEvent,
            &pInfo->cNotifyEntry,
            &pInfo->rgNotifyEntry
            ))
        goto AddEventError;

    fResult = TRUE;

CommonReturn:
    UnlockRegStore(pRegStore);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(ChangeInitError)
TRACE_ERROR(AddEventError)
}


STATIC void FreeRegistryStoreChange(
    IN PREG_STORE pRegStore
    )
{
    PREGISTRY_STORE_CHANGE_INFO pInfo;
    if (NULL == (pInfo = pRegStore->pRegistryStoreChangeInfo))
        return;

    assert(pInfo->hRegWaitFor);
    pfnILS_UnregisterWait(pInfo->hRegWaitFor);

    assert(pInfo->hChange);
    if (pRegStore->dwFlags & CERT_REGISTRY_STORE_ROAMING_FLAG)
        FindCloseChangeNotification(pInfo->hChange);
    else
        CloseHandle(pInfo->hChange);

    ILS_SignalEventsOnResyncList(
        &pInfo->cNotifyEntry,
        &pInfo->rgNotifyEntry
        );

    PkiFree(pInfo);
    pRegStore->pRegistryStoreChangeInfo = NULL;
}

#else	//CE_BUILD
STATIC BOOL RegRegistryStoreChange(
    IN PREG_STORE pRegStore,
    IN HANDLE hEvent
    )
{
	return FALSE;
}
#endif

//+=========================================================================
// Key Identifier Functions
//==========================================================================

STATIC HKEY OpenKeyIdStoreSubKey(
    IN DWORD dwFlags,
    IN OPTIONAL LPCWSTR pwszComputerName
    )
{
    SYSTEM_NAME_INFO SystemNameInfo;
    memset(&SystemNameInfo, 0, sizeof(SystemNameInfo));
    SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX] = wsz_MY_STORE;
    SystemNameInfo.rgpwszName[COMPUTER_NAME_INDEX] = (LPWSTR) pwszComputerName;

    return OpenSystemRegPathKey(
        &SystemNameInfo,
        NULL,               // pwszSubKeyName
        dwFlags
        );
}

BOOL
ILS_ReadKeyIdElement(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN BOOL fLocalMachine,
    IN OPTIONAL LPCWSTR pwszComputerName,
    OUT BYTE **ppbElement,
    OUT DWORD *pcbElement
    )
{
    BOOL fResult;
    BYTE *pbElement = NULL;
    DWORD cbElement = 0;
    WCHAR wszHashName[MAX_HASH_NAME_LEN];

    if (0 == pKeyIdentifier->cbData || MAX_HASH_LEN < pKeyIdentifier->cbData)
        goto InvalidArg;
    BytesToWStr(pKeyIdentifier->cbData, pKeyIdentifier->pbData, wszHashName);

    if (!fLocalMachine) {
        LPWSTR pwszRoamingStoreDir;
        if (pwszRoamingStoreDir = ILS_GetRoamingStoreDirectory(
                ROAMING_MY_STORE_SUBDIR)) {
            fResult = ILS_ReadElementFromFile(
                pwszRoamingStoreDir,
                KEYID_CONTEXT_NAME,
                wszHashName,
                0,                          // dwFlags
                &pbElement,
                &cbElement
                );
            PkiFree(pwszRoamingStoreDir);
            if (!fResult) {
                if (ERROR_FILE_NOT_FOUND != GetLastError())
                    goto ReadElementFromFileError;
            } else
                goto CommonReturn;
        }
    }

    {
        HKEY hKey;
        DWORD dwOpenFlags;

        if (fLocalMachine)
            dwOpenFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE;
        else
            dwOpenFlags = CERT_SYSTEM_STORE_CURRENT_USER;
        if (NULL == (hKey = OpenKeyIdStoreSubKey(
                dwOpenFlags | CERT_STORE_READONLY_FLAG,
                pwszComputerName
                )))
            goto OpenKeyIdStoreSubKeyError;

        fResult = ILS_ReadElementFromRegistry(
            hKey,
            KEYID_CONTEXT_NAME,
            wszHashName,
            0,                          // dwFlags
            &pbElement,
            &cbElement
            );

        ILS_CloseRegistryKey(hKey);
        if (!fResult)
            goto ReadElementFromRegistryError;
    }

    fResult = TRUE;

CommonReturn:
    *ppbElement = pbElement;
    *pcbElement = cbElement;
    return fResult;

ErrorReturn:
    assert(NULL == pbElement && 0 == cbElement);
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(ReadElementFromFileError)
TRACE_ERROR(OpenKeyIdStoreSubKeyError)
TRACE_ERROR(ReadElementFromRegistryError)
}

BOOL
ILS_WriteKeyIdElement(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN BOOL fLocalMachine,
    IN OPTIONAL LPCWSTR pwszComputerName,
    IN const BYTE *pbElement,
    IN DWORD cbElement
    )
{
    BOOL fResult;
    WCHAR wszHashName[MAX_HASH_NAME_LEN];

    if (0 == pKeyIdentifier->cbData || MAX_HASH_LEN < pKeyIdentifier->cbData)
        goto InvalidArg;
    BytesToWStr(pKeyIdentifier->cbData, pKeyIdentifier->pbData, wszHashName);

    if (!fLocalMachine) {
        LPWSTR pwszRoamingStoreDir;
        if (pwszRoamingStoreDir = ILS_GetRoamingStoreDirectory(
                ROAMING_MY_STORE_SUBDIR)) {
            fResult = ILS_WriteElementToFile(
                pwszRoamingStoreDir,
                KEYID_CONTEXT_NAME,
                wszHashName,
                0,                          // dwFlags
                pbElement,
                cbElement
                );
            PkiFree(pwszRoamingStoreDir);
            if (!fResult)
                goto WriteElementToFileError;
            else
                goto CommonReturn;
        }
    }

    {
        HKEY hKey;
        DWORD dwOpenFlags;

        if (fLocalMachine)
            dwOpenFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE;
        else
            dwOpenFlags = CERT_SYSTEM_STORE_CURRENT_USER;
        if (NULL == (hKey = OpenKeyIdStoreSubKey(
                dwOpenFlags,
                pwszComputerName
                )))
            goto OpenKeyIdStoreSubKeyError;

        fResult = ILS_WriteElementToRegistry(
            hKey,
            KEYID_CONTEXT_NAME,
            wszHashName,
            0,                          // dwFlags
            pbElement,
            cbElement
            );

        ILS_CloseRegistryKey(hKey);
        if (!fResult)
            goto WriteElementToRegistryError;
    }

    fResult = TRUE;

CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(WriteElementToFileError)
TRACE_ERROR(OpenKeyIdStoreSubKeyError)
TRACE_ERROR(WriteElementToRegistryError)
}


BOOL
ILS_DeleteKeyIdElement(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN BOOL fLocalMachine,
    IN OPTIONAL LPCWSTR pwszComputerName
    )
{
    BOOL fResult;
    WCHAR wszHashName[MAX_HASH_NAME_LEN];

    if (0 == pKeyIdentifier->cbData || MAX_HASH_LEN < pKeyIdentifier->cbData)
        goto InvalidArg;
    BytesToWStr(pKeyIdentifier->cbData, pKeyIdentifier->pbData, wszHashName);

    if (!fLocalMachine) {
        LPWSTR pwszRoamingStoreDir;
        if (pwszRoamingStoreDir = ILS_GetRoamingStoreDirectory(
                ROAMING_MY_STORE_SUBDIR)) {
            fResult = ILS_DeleteElementFromDirectory(
                pwszRoamingStoreDir,
                KEYID_CONTEXT_NAME,
                wszHashName,
                0                           // dwFlags
                );
            PkiFree(pwszRoamingStoreDir);
            if (!fResult)
                goto DeleteElementFromDirectoryError;
            else
                goto CommonReturn;
        }
    }

    {
        HKEY hKey;
        DWORD dwOpenFlags;

        if (fLocalMachine)
            dwOpenFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE;
        else
            dwOpenFlags = CERT_SYSTEM_STORE_CURRENT_USER;
        if (NULL == (hKey = OpenKeyIdStoreSubKey(
                dwOpenFlags,
                pwszComputerName
                )))
            goto OpenKeyIdStoreSubKeyError;

        fResult = ILS_DeleteElementFromRegistry(
            hKey,
            KEYID_CONTEXT_NAME,
            wszHashName,
            0                           // dwFlags
            );

        ILS_CloseRegistryKey(hKey);
        if (!fResult)
            goto DeleteElementFromRegistryError;
    }

    fResult = TRUE;

CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(DeleteElementFromDirectoryError)
TRACE_ERROR(OpenKeyIdStoreSubKeyError)
TRACE_ERROR(DeleteElementFromRegistryError)
}

typedef struct _OPEN_KEYID_CALLBACK_ARG {
    void                        *pvArg;
    PFN_ILS_OPEN_KEYID_ELEMENT  pfnOpenKeyId;
} OPEN_KEYID_CALLBACK_ARG, *POPEN_KEYID_CALLBACK_ARG;

STATIC BOOL OpenKeyIdElementCallback(
    IN const WCHAR wszHashName[MAX_HASH_NAME_LEN],
    IN const BYTE *pbElement,
    IN DWORD cbElement,
    IN void *pvArg
    )
{
    POPEN_KEYID_CALLBACK_ARG pKeyIdArg = (POPEN_KEYID_CALLBACK_ARG) pvArg;

    DWORD cbHash;
    BYTE rgbHash[MAX_HASH_LEN];
    CRYPT_HASH_BLOB KeyIdentifier;

    WStrToBytes(wszHashName, rgbHash, &cbHash);
    KeyIdentifier.cbData = cbHash;
    KeyIdentifier.pbData = rgbHash;

    return pKeyIdArg->pfnOpenKeyId(
        &KeyIdentifier,
        pbElement,
        cbElement,
        pKeyIdArg->pvArg
        );
}

BOOL
ILS_OpenAllKeyIdElements(
    IN BOOL fLocalMachine,
    IN OPTIONAL LPCWSTR pwszComputerName,
    IN void *pvArg,
    IN PFN_ILS_OPEN_KEYID_ELEMENT pfnOpenKeyId
    )
{
    BOOL fResult;
    BOOL fOpenFile = FALSE;

    OPEN_KEYID_CALLBACK_ARG KeyIdArg = { pvArg, pfnOpenKeyId };

    if (!fLocalMachine) {
        LPWSTR pwszRoamingStoreDir;
        if (pwszRoamingStoreDir = ILS_GetRoamingStoreDirectory(
                ROAMING_MY_STORE_SUBDIR)) {
            fResult = ILS_OpenAllElementsFromDirectory(
                pwszRoamingStoreDir,
                KEYID_CONTEXT_NAME,
                0,                          // dwFlags
                (void *) &KeyIdArg,
                OpenKeyIdElementCallback
                );
            PkiFree(pwszRoamingStoreDir);
            if (!fResult)
                goto ErrorReturn;
            else
                fOpenFile = TRUE;
        }
    }

    {
        HKEY hKey;
        DWORD dwOpenFlags;

        if (fLocalMachine)
            dwOpenFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE;
        else
            dwOpenFlags = CERT_SYSTEM_STORE_CURRENT_USER;
        if (NULL == (hKey = OpenKeyIdStoreSubKey(
                dwOpenFlags | CERT_STORE_READONLY_FLAG,
                pwszComputerName
                )))
            goto OpenKeyIdStoreSubKeyError;

        fResult = ILS_OpenAllElementsFromRegistry(
            hKey,
            KEYID_CONTEXT_NAME,
            0,                          // dwFlags
            (void *) &KeyIdArg,
            OpenKeyIdElementCallback
            );

        ILS_CloseRegistryKey(hKey);
    }

CommonReturn:
    if (fOpenFile)
        // Ignore any registry errors
        return TRUE;
    else
        return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OpenKeyIdStoreSubKeyError)
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\certstor\mstest1.h ===
0x30,0x47,0x02,0x40,0x81,0x55,0x22,0xB9,0x8A,0xA4,0x6F,0xED,0xD6,0xE7,0xD9,0x66,
0x0F,0x55,0xBC,0xD7,0xCD,0xD5,0xBC,0x4E,0x40,0x02,0x21,0xA2,0xB1,0xF7,0x87,0x30,
0x85,0x5E,0xD2,0xF2,0x44,0xB9,0xDC,0x9B,0x75,0xB6,0xFB,0x46,0x5F,0x42,0xB6,0x9D,
0x23,0x36,0x0B,0xDE,0x54,0x0F,0xCD,0xBD,0x1F,0x99,0x2A,0x10,0x58,0x11,0xCB,0x40,
0xCB,0xB5,0xA7,0x41,0x02,0x03,0x01,0x00,0x01
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\certstor\mstestb1.h ===
0x30,0x47,0x02,0x40,0x9C,0x50,0x05,0x1D,0xE2,0x0E,0x4C,0x53,0xD8,0xD9,0xB5,0xE5,
0xFD,0xE9,0xE3,0xAD,0x83,0x4B,0x80,0x08,0xD9,0xDC,0xE8,0xE8,0x35,0xF8,0x11,0xF1,
0xE9,0x9B,0x03,0x7A,0x65,0x64,0x76,0x35,0xCE,0x38,0x2C,0xF2,0xB6,0x71,0x9E,0x06,
0xD9,0xBF,0xBB,0x31,0x69,0xA3,0xF6,0x30,0xA0,0x78,0x7B,0x18,0xDD,0x50,0x4D,0x79,
0x1E,0xEB,0x61,0xC1,0x02,0x03,0x01,0x00,0x01
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\certstor\mstest2.h ===
0x30,0x48,0x02,0x41,0x00,0x81,0x55,0x22,0xB9,0x8A,0xA4,0x6F,0xED,0xD6,0xE7,0xD9,0x66,
0x0F,0x55,0xBC,0xD7,0xCD,0xD5,0xBC,0x4E,0x40,0x02,0x21,0xA2,0xB1,0xF7,0x87,0x30,
0x85,0x5E,0xD2,0xF2,0x44,0xB9,0xDC,0x9B,0x75,0xB6,0xFB,0x46,0x5F,0x42,0xB6,0x9D,
0x23,0x36,0x0B,0xDE,0x54,0x0F,0xCD,0xBD,0x1F,0x99,0x2A,0x10,0x58,0x11,0xCB,0x40,
0xCB,0xB5,0xA7,0x41,0x02,0x03,0x01,0x00,0x01
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\certstor\oidconv.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1998
//
//  File:       oidconv.cpp
//
//  Contents:   Object ID (OID) Conv Functions
//
//  Functions:  I_CryptOIDConvDllMain
//              I_CryptSetEncodedOID
//              I_CryptGetEncodedOID
//
//  Comments:
//
//  History:    08_Feb-98    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

// All the *pvInfo extra stuff needs to be aligned
#define INFO_LEN_ALIGN(Len)  ((Len + 7) & ~7)

typedef struct _OID_HASH_BUCKET_ENTRY
    OID_HASH_BUCKET_ENTRY, *POID_HASH_BUCKET_ENTRY;

// pbEncodedOID immediately follows the data structure. pszDotOID
// is at pbEncodedOID + cbEncodedOID. pszDotOID is null terminated.
// cchDotOID doesn't include the null terminator.
struct _OID_HASH_BUCKET_ENTRY {
    DWORD                   cbEncodedOID;
    DWORD                   cchDotOID;
    POID_HASH_BUCKET_ENTRY  pEncodedNext;
    POID_HASH_BUCKET_ENTRY  pDotNext;
};

static inline BYTE * GetEncodedOIDPointer(
    IN POID_HASH_BUCKET_ENTRY pEntry
    )
{
    return ((BYTE *) pEntry) + sizeof(OID_HASH_BUCKET_ENTRY);
}
static inline LPSTR GetDotOIDPointer(
    IN POID_HASH_BUCKET_ENTRY pEntry
    )
{
    return (LPSTR) (((BYTE *) pEntry) + sizeof(OID_HASH_BUCKET_ENTRY) +
        pEntry->cbEncodedOID);
}

// Some prime numbers: 11, 13, 19, 23, 29, 31, 47, 53, 61, 73, 97,
//                     101, 127, 251, 509

#define ENCODED_OID_HASH_BUCKET_COUNT   47
#define DOT_OID_HASH_BUCKET_COUNT       31

static POID_HASH_BUCKET_ENTRY
            rgpEncodedOIDHashBucket[ENCODED_OID_HASH_BUCKET_COUNT];
static POID_HASH_BUCKET_ENTRY rgpDotOIDHashBucket[DOT_OID_HASH_BUCKET_COUNT];

static CRITICAL_SECTION OIDHashBucketCriticalSection;

static void OIDHashBucketProcessAttach()
{
    InitializeCriticalSection(&OIDHashBucketCriticalSection);
}

static void OIDHashBucketProcessDetach()
{
    DWORD i;
    for (i = 0; i < DOT_OID_HASH_BUCKET_COUNT; i++) {
        POID_HASH_BUCKET_ENTRY pEntry = rgpDotOIDHashBucket[i];
        while (pEntry) {
            POID_HASH_BUCKET_ENTRY pFreeEntry = pEntry;
            pEntry = pEntry->pDotNext;
            PkiFree(pFreeEntry);
        }
    }

    DeleteCriticalSection(&OIDHashBucketCriticalSection);
}

BOOL
WINAPI
I_CryptOIDConvDllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved)
{
    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        OIDHashBucketProcessAttach();
        break;

    case DLL_PROCESS_DETACH:
        OIDHashBucketProcessDetach();
        break;
    case DLL_THREAD_DETACH:
    default:
        break;
    }

    return TRUE;
}

extern HCRYPTASN1MODULE hX509Asn1Module;  // From wincert.cpp
static inline ASN1encoding_t GetEncoder(void)
{
    return I_CryptGetAsn1Encoder(hX509Asn1Module);
}
static inline ASN1decoding_t GetDecoder(void)
{
    return I_CryptGetAsn1Decoder(hX509Asn1Module);
}

static DWORD GetOIDHashBucketIndex(
    IN DWORD cHashBucket,
    IN const BYTE *pb,
    IN DWORD cb
    )
{
    DWORD dwIndex;

    dwIndex = 0;
    while (cb--) {
        if (dwIndex & 0x80000000)
            dwIndex = (dwIndex << 1) | 1;
        else
            dwIndex = dwIndex << 1;
        dwIndex += *pb++;
    }
    return dwIndex % cHashBucket;
}

static POID_HASH_BUCKET_ENTRY FindOIDHashBucketEntryFromEncodedOID(
    IN ASN1encodedOID_t *pEncodedOid
    )
{
    POID_HASH_BUCKET_ENTRY pEntry;
    BYTE *pbEncodedOID = pEncodedOid->value;
    DWORD cbEncodedOID = pEncodedOid->length;
    DWORD dwIndex;

    dwIndex = GetOIDHashBucketIndex(
        ENCODED_OID_HASH_BUCKET_COUNT,
        pbEncodedOID,
        cbEncodedOID
        );

    for (pEntry = rgpEncodedOIDHashBucket[dwIndex]; pEntry;
                                            pEntry = pEntry->pEncodedNext) {
        if (cbEncodedOID == pEntry->cbEncodedOID &&
                0 == memcmp(pbEncodedOID, GetEncodedOIDPointer(pEntry),
                        cbEncodedOID))
            return pEntry;
    }

    return NULL;
}

static POID_HASH_BUCKET_ENTRY FindOIDHashBucketEntryFromDotOID(
    IN LPSTR pszDotOID
    )
{
    POID_HASH_BUCKET_ENTRY pEntry;
    DWORD cchDotOID = strlen(pszDotOID);
    DWORD dwIndex;

    dwIndex = GetOIDHashBucketIndex(
        DOT_OID_HASH_BUCKET_COUNT,
        (const BYTE *) pszDotOID,
        cchDotOID
        );

    for (pEntry = rgpDotOIDHashBucket[dwIndex]; pEntry;
                                            pEntry = pEntry->pDotNext) {
        if (cchDotOID == pEntry->cchDotOID &&
                0 == memcmp(pszDotOID, GetDotOIDPointer(pEntry), cchDotOID))
            return pEntry;
    }

    return NULL;
}


// If after entering the critical section, the entry already exists, then,
// return it and free the input entry. Otherwise, add the input entry and
// return it.
static POID_HASH_BUCKET_ENTRY AddOIDHashBucketEntry(
    IN POID_HASH_BUCKET_ENTRY pEntry
    )
{
    POID_HASH_BUCKET_ENTRY pFindEntry;
    ASN1encodedOID_t EncodedOid;

    EnterCriticalSection(&OIDHashBucketCriticalSection);

    EncodedOid.value = GetEncodedOIDPointer(pEntry);
    EncodedOid.length = (ASN1uint16_t) pEntry->cbEncodedOID;
    if (pFindEntry = FindOIDHashBucketEntryFromEncodedOID(&EncodedOid)) {
        PkiFree(pEntry);
        pEntry = pFindEntry;
    } else {
        DWORD dwIndex;

        dwIndex = GetOIDHashBucketIndex(
            ENCODED_OID_HASH_BUCKET_COUNT,
            GetEncodedOIDPointer(pEntry),
            pEntry->cbEncodedOID
            );
        pEntry->pEncodedNext = rgpEncodedOIDHashBucket[dwIndex];
        // Since we do finds outside of CriticalSection, must update
        // the following last!!!
        rgpEncodedOIDHashBucket[dwIndex] = pEntry;

        dwIndex = GetOIDHashBucketIndex(
            DOT_OID_HASH_BUCKET_COUNT,
            (const BYTE *) GetDotOIDPointer(pEntry),
            pEntry->cchDotOID
            );
        pEntry->pDotNext = rgpDotOIDHashBucket[dwIndex];
        // Since we do finds outside of CriticalSection, must update
        // the following last!!!
        rgpDotOIDHashBucket[dwIndex] = pEntry;
    }

    LeaveCriticalSection(&OIDHashBucketCriticalSection);

    return pEntry;
}


static POID_HASH_BUCKET_ENTRY CreateOIDHashBucketEntry(
    IN const BYTE *pbEncodedOID,
    IN DWORD cbEncodedOID,
    IN LPSTR pszDotOID,
    IN DWORD cchDotOID
    )
{
    POID_HASH_BUCKET_ENTRY pEntry;
    DWORD cbEntry;

    cbEntry = sizeof(OID_HASH_BUCKET_ENTRY) + cbEncodedOID + cchDotOID + 1;
    if (NULL == (pEntry = (POID_HASH_BUCKET_ENTRY) PkiZeroAlloc(cbEntry)))
        return NULL;

    pEntry->cbEncodedOID = cbEncodedOID;
    pEntry->cchDotOID = cchDotOID;
    memcpy(GetEncodedOIDPointer(pEntry), pbEncodedOID, cbEncodedOID);
    memcpy(GetDotOIDPointer(pEntry), pszDotOID, cchDotOID + 1);

    return pEntry;
}

static POID_HASH_BUCKET_ENTRY CreateOIDHashBucketEntryFromEncodedOID(
    IN ASN1encodedOID_t *pEncodedOid
    )
{
    POID_HASH_BUCKET_ENTRY pEntry;
    ASN1decoding_t pDec = GetDecoder();
    const BYTE *pbEncodedOID;       // not allocated
    DWORD cbEncodedOID;
    LPSTR pszDotOID = NULL; 
    DWORD cchDotOID;

    if (NULL == (pszDotOID = PkiAsn1EncodedOidToDotVal(pDec, pEncodedOid)))
        goto EncodedOidToDotValError;
    cchDotOID = (DWORD) strlen(pszDotOID);

    pbEncodedOID = pEncodedOid->value;
    cbEncodedOID = pEncodedOid->length;
    pEntry = CreateOIDHashBucketEntry(
        pbEncodedOID,
        cbEncodedOID,
        pszDotOID,
        cchDotOID
        );

CommonReturn:
    PkiAsn1FreeDotVal(pDec, pszDotOID);
    return pEntry;

ErrorReturn:
    pEntry = NULL;
    goto CommonReturn;

TRACE_ERROR(EncodedOidToDotValError)
}

static POID_HASH_BUCKET_ENTRY CreateOIDHashBucketEntryFromDotOID(
    IN LPSTR pszDotOID
    )
{
    POID_HASH_BUCKET_ENTRY pEntry;
    ASN1encoding_t pEnc = GetEncoder();
    ASN1encodedOID_t EncodedOid;
    memset(&EncodedOid, 0, sizeof(EncodedOid));

    const BYTE *pbEncodedOID;
    DWORD cbEncodedOID;

    if (NULL == pszDotOID || '\0' == *pszDotOID)
        goto EmptyDotOIDError;
    if (!PkiAsn1DotValToEncodedOid(pEnc, pszDotOID, &EncodedOid))
        goto DotValToEncodedOidError;
    pbEncodedOID = EncodedOid.value;
    cbEncodedOID = EncodedOid.length;

    pEntry = CreateOIDHashBucketEntry(
        pbEncodedOID,
        cbEncodedOID,
        pszDotOID,
        strlen(pszDotOID)
        );

CommonReturn:
    PkiAsn1FreeEncodedOid(pEnc, &EncodedOid);
    return pEntry;
ErrorReturn:
    pEntry = NULL;
    goto CommonReturn;

SET_ERROR(EmptyDotOIDError, E_INVALIDARG)
SET_ERROR_VAR(DotValToEncodedOidError, PkiAsn1ErrToHr(ASN1_ERR_BADARGS))
}



//+-------------------------------------------------------------------------
//  Set/Get Encoded OID
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptSetEncodedOID(
        IN LPSTR pszObjId,
        OUT ASN1encodedOID_t *pEncodedOid
        )
{
    BOOL fResult;
    POID_HASH_BUCKET_ENTRY pEntry;

    if (NULL == (pEntry = FindOIDHashBucketEntryFromDotOID(pszObjId))) {
        if (NULL == (pEntry = CreateOIDHashBucketEntryFromDotOID(pszObjId)))
            goto CreateOIDHashBucketEntryError;
        pEntry = AddOIDHashBucketEntry(pEntry);
    }

    pEncodedOid->length = (ASN1uint16_t) pEntry->cbEncodedOID;
    pEncodedOid->value = GetEncodedOIDPointer(pEntry);
    fResult = TRUE;

CommonReturn:
    return fResult;
ErrorReturn:
    pEncodedOid->length = 0;
    pEncodedOid->value = NULL;
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(CreateOIDHashBucketEntryError)    
}


static const LPCSTR pszInvalidOID = "";

void
WINAPI
I_CryptGetEncodedOID(
        IN ASN1encodedOID_t *pEncodedOid,
        IN DWORD dwFlags,
        OUT LPSTR *ppszObjId,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    POID_HASH_BUCKET_ENTRY pEntry;
    LONG lRemainExtra = *plRemainExtra;
    LPSTR pszDotOID;
    DWORD cchDotOID;

    if ((dwFlags & CRYPT_DECODE_SHARE_OID_STRING_FLAG) &&
            lRemainExtra < 0)
        // Length only calculation. Don't need any extra bytes.
        return;

    if (NULL == (pEntry = FindOIDHashBucketEntryFromEncodedOID(pEncodedOid))) {
        if (pEntry = CreateOIDHashBucketEntryFromEncodedOID(pEncodedOid))
            pEntry = AddOIDHashBucketEntry(pEntry);
    }

    if (pEntry) {
        pszDotOID = GetDotOIDPointer(pEntry);
        cchDotOID = pEntry->cchDotOID + 1;
    } else {
        pszDotOID = (LPSTR) pszInvalidOID;
        cchDotOID = strlen(pszInvalidOID) + 1;
    }

    if (dwFlags & CRYPT_DECODE_SHARE_OID_STRING_FLAG) {
        assert(lRemainExtra >= 0);
        *ppszObjId = pszDotOID;
    } else {
        LONG lAlignExtra = INFO_LEN_ALIGN(cchDotOID);
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            memcpy(*ppbExtra, pszDotOID, cchDotOID);
            *ppszObjId = (LPSTR) *ppbExtra;
            *ppbExtra += lAlignExtra;
        }

        *plRemainExtra = lRemainExtra;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\tools\capi\certstor\newstor.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1997
//
//  File:       newstor.cpp
//
//  Contents:   Certificate, CRL and CTL Store APIs
//
//  Functions:  CertStoreDllMain
//              CertOpenStore
//              CertDuplicateStore
//              CertCloseStore
//              CertSaveStore
//              CertControlStore
//              CertAddStoreToCollection
//              CertRemoveStoreFromCollection
//              CertSetStoreProperty
//              CertGetStoreProperty
//              CertGetSubjectCertificateFromStore
//              CertEnumCertificatesInStore
//              CertFindCertificateInStore
//              CertGetIssuerCertificateFromStore
//              CertVerifySubjectCertificateContext
//              CertDuplicateCertificateContext
//              CertCreateCertificateContext
//              CertFreeCertificateContext
//              CertSetCertificateContextProperty
//              CertGetCertificateContextProperty
//              CertEnumCertificateContextProperties
//              CertGetCRLFromStore
//              CertEnumCRLsInStore
//              CertFindCRLInStore
//              CertDuplicateCRLContext
//              CertCreateCRLContext
//              CertFreeCRLContext
//              CertSetCRLContextProperty
//              CertGetCRLContextProperty
//              CertEnumCRLContextProperties
//              CertFindCertificateInCRL
//              CertAddEncodedCertificateToStore
//              CertAddCertificateContextToStore
//              CertSerializeCertificateStoreElement
//              CertDeleteCertificateFromStore
//              CertAddEncodedCRLToStore
//              CertAddCRLContextToStore
//              CertSerializeCRLStoreElement
//              CertDeleteCRLFromStore
//              CertAddSerializedElementToStore
//
//              CertDuplicateCTLContext
//              CertCreateCTLContext
//              CertFreeCTLContext
//              CertSetCTLContextProperty
//              CertGetCTLContextProperty
//              CertEnumCTLContextProperties
//              CertEnumCTLsInStore
//              CertFindSubjectInCTL
//              CertFindCTLInStore
//              CertAddEncodedCTLToStore
//              CertAddCTLContextToStore
//              CertSerializeCTLStoreElement
//              CertDeleteCTLFromStore
//
//              CertAddCertificateLinkToStore
//              CertAddCRLLinkToStore
//              CertAddCTLLinkToStore
//
//              I_CertAddSerializedStore
//              CryptAcquireCertificatePrivateKey
//              I_CertSyncStore
//
//              CryptGetKeyIdentifierProperty
//              CryptSetKeyIdentifierProperty
//              CryptEnumKeyIdentifierProperties
//
//  History:    17-Feb-96    philh   created
//              29-Dec-96    philh   redo using provider functions
//              01-May-97    philh   added CTL functions
//              01-Aug-97    philh   NT 5.0 Changes. Support context links,
//                                   collections and external stores.
//--------------------------------------------------------------------------


#include "global.hxx"
#include <dbgdef.h>

#ifdef STATIC
#undef STATIC
#endif
#define STATIC

HMODULE hCertStoreInst;

// Maximum # of verified CRLs allowed per issuer.
// This array of CRLs is passed to CertHelperVerifyRevocation
#define MAX_CRL_LIST    5

//+-------------------------------------------------------------------------
//  Store data structure definitions
//--------------------------------------------------------------------------

// Assumes
//  0 - Certificates
//  1 - CRLs
//  2 - CTLs
#define CONTEXT_COUNT       3

typedef struct _CONTEXT_ELEMENT CONTEXT_ELEMENT, *PCONTEXT_ELEMENT;
typedef struct _PROP_ELEMENT PROP_ELEMENT, *PPROP_ELEMENT;

typedef struct _CERT_STORE CERT_STORE, *PCERT_STORE;
typedef struct _CERT_STORE_LINK CERT_STORE_LINK, *PCERT_STORE_LINK;

typedef struct _COLLECTION_STACK_ENTRY COLLECTION_STACK_ENTRY,
    *PCOLLECTION_STACK_ENTRY;

// Used to maintain collection state across context find next calls.
//
// Ref count on pStoreLink. No ref count on pCollection.
// pStoreLink may be NULL.
struct _COLLECTION_STACK_ENTRY {
    PCERT_STORE                 pCollection;
    PCERT_STORE_LINK            pStoreLink;
    PCOLLECTION_STACK_ENTRY     pPrev;
};

typedef struct _CONTEXT_CACHE_INFO {
    PPROP_ELEMENT               pPropHead;
} CONTEXT_CACHE_INFO;

typedef struct _CONTEXT_EXTERNAL_INFO {
    // For ELEMENT_FIND_NEXT_FLAG
    void                        *pvProvInfo;
} CONTEXT_EXTERNAL_INFO;

typedef struct _CONTEXT_COLLECTION_INFO {
    // For Find
    PCOLLECTION_STACK_ENTRY     pCollectionStack;
} CONTEXT_COLLECTION_INFO;

#define ELEMENT_DELETED_FLAG                    0x00010000

// Only set for external elements
#define ELEMENT_FIND_NEXT_FLAG                  0x00020000

// Set during CertCloseStore if ELEMENT_FIND_NEXT_FLAG was set.
#define ELEMENT_CLOSE_FIND_NEXT_FLAG            0x00040000

// Set if the element has a CERT_ARCHIVED_PROP_ID
#define ELEMENT_ARCHIVED_FLAG                   0x00080000

// A cache element is the actual context element. Its the only element,
// where pEle points to itself. All other elements will eventually
// point to a cache element. Cache elements may only reside in a cache
// store. The pProvStore is the same as the pStore. Note, during a
// context add, a cache element may temporarily be in a collection store
// during the call to the provider's add callback.
//
// A link context element is a link to another element, including a link
// to another link context element. Link context elements may only reside
// in a cache store. The pProvStore is the same as the linked to element's
// pProvStore.
//
// An external element is a link to the element returned by a provider
// that stores elements externally. External elements may only reside in
// an external store. The pProvStore is the external store's
// provider. The store doesn't hold a reference on an external element,
// its ELEMENT_DELETED_FLAG is always set.
//
// A collection element is a link to an element in a cache or external store.
// Its returned when finding in or adding to a collection store. The store
// doesn't hold a reference on a collection element, its
// ELEMENT_DELETED_FLAG is always set.
//
#define ELEMENT_TYPE_CACHE                      1
#define ELEMENT_TYPE_LINK_CONTEXT               2
#define ELEMENT_TYPE_EXTERNAL                   3
#define ELEMENT_TYPE_COLLECTION                 4


#define MAX_LINK_DEPTH  100

typedef struct _CONTEXT_NOCOPY_INFO {
    PFN_CRYPT_FREE      pfnFree;
    void                *pvFree;
} CONTEXT_NOCOPY_INFO, *PCONTEXT_NOCOPY_INFO;

// The CONTEXT_ELEMENT is inserted before the CERT_CONTEXT, CRL_CONTEXT or
// CTL_CONTEXT. The dwContextType used is 0 based and not 1 based. For
// example, dwContextType = CERT_STORE_CERTIFICATE_CONTEXT - 1.
struct _CONTEXT_ELEMENT {
    DWORD               dwElementType;
    DWORD               dwContextType;
    DWORD               dwFlags;
    LONG                lRefCnt;

    // For ELEMENT_TYPE_CACHE, pEle points to itself. Otherwise, pEle points
    // to the element being linked to and the pEle is addRef'ed. The
    // cached element is found by iterating through the pEle's until pEle
    // points to itself.
    PCONTEXT_ELEMENT    pEle;
    PCERT_STORE         pStore;
    PCONTEXT_ELEMENT    pNext;
    PCONTEXT_ELEMENT    pPrev;
    PCERT_STORE         pProvStore;
    PCONTEXT_NOCOPY_INFO pNoCopyInfo;

    union {
        CONTEXT_CACHE_INFO      Cache;      // ELEMENT_TYPE_CACHE
        CONTEXT_EXTERNAL_INFO   External;   // ELEMENT_TYPE_EXTERNAL
        CONTEXT_COLLECTION_INFO Collection; // ELEMENT_TYPE_COLLECTION
    };
};

// For CRL, follows the above CONTEXT_ELEMENT
typedef struct _CRL_CONTEXT_SUFFIX {
    PCRL_ENTRY          *ppSortedEntry;
} CRL_CONTEXT_SUFFIX, *PCRL_CONTEXT_SUFFIX;


typedef struct _HASH_BUCKET_ENTRY HASH_BUCKET_ENTRY, *PHASH_BUCKET_ENTRY;
struct _HASH_BUCKET_ENTRY {
    union {
        DWORD               dwEntryIndex;
        DWORD               dwEntryOffset;
        const BYTE          *pbEntry;
    };
    union {
        PHASH_BUCKET_ENTRY  pNext;
        DWORD               iNext;
    };
};

typedef struct _SORTED_CTL_FIND_INFO {
    DWORD                   cHashBucket;
    BOOL                    fHashedIdentifier;

    // Encoded sequence of TrustedSubjects
    const BYTE              *pbEncodedSubjects;         // not allocated
    DWORD                   cbEncodedSubjects;

    // Following is NON-NULL for a szOID_SORTED_CTL extension
    const BYTE              *pbEncodedHashBucket;       // not allocated

    // Following are NON-NULL when there isn't a szOID_SORTED_CTL extension
    DWORD                   *pdwHashBucketHead;         // allocated
    PHASH_BUCKET_ENTRY      pHashBucketEntry;           // allocated
} SORTED_CTL_FIND_INFO, *PSORTED_CTL_FIND_INFO;

// For CTL, follows the above CONTEXT_ELEMENT
typedef struct _CTL_CONTEXT_SUFFIX {
    PCTL_ENTRY              *ppSortedEntry;             // allocated

    BOOL                    fFastCreate;
    // Following only applicable for a FastCreateCtlElement
    PCTL_ENTRY              pCTLEntry;                  // allocated
    PCERT_EXTENSIONS        pExtInfo;                   // allocated
    PSORTED_CTL_FIND_INFO   pSortedCtlFindInfo;         // not allocated
} CTL_CONTEXT_SUFFIX, *PCTL_CONTEXT_SUFFIX;

struct _PROP_ELEMENT {
    DWORD               dwPropId;
    DWORD               dwFlags;
    BYTE                *pbData;
    DWORD               cbData;
    PPROP_ELEMENT       pNext;
    PPROP_ELEMENT       pPrev;
};


#define STORE_LINK_DELETED_FLAG        0x00010000
struct _CERT_STORE_LINK {
    DWORD               dwFlags;
    LONG                lRefCnt;

    // Whatever is passed to CertAddStoreToCollection
    DWORD               dwUpdateFlags;
    DWORD               dwPriority;

    PCERT_STORE         pCollection;
    PCERT_STORE         pSibling;       // CertStoreDuplicate'd.
    PCERT_STORE_LINK    pNext;
    PCERT_STORE_LINK    pPrev;
};


// Store types
#define STORE_TYPE_CACHE            1
#define STORE_TYPE_EXTERNAL         2
#define STORE_TYPE_COLLECTION       3

// CACHE store may have CACHE or LINK_CONTEXT elements. Until deleted,
// the store has a reference count to.

// EXTERNAL store only has EXTERNAL elements. These elements are always
// deleted, wherein, the store doesn't hold a refCnt.

// COLLECTION store has COLLECTION elements. These elements
// are always deleted, wherein, the store doesn't hold a refCnt.


struct _CERT_STORE {
    DWORD               dwStoreType;
    LONG                lRefCnt;
    HCRYPTPROV          hCryptProv;
    DWORD               dwFlags;
    DWORD               dwState;
    CRITICAL_SECTION    CriticalSection;
    PCONTEXT_ELEMENT    rgpContextListHead[CONTEXT_COUNT];
    PCERT_STORE_LINK    pStoreListHead;                     // COLLECTION
    PPROP_ELEMENT       pPropHead;      // properties for entire store

    // For CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG
    // Incremented for each context duplicated
    LONG                lDeferCloseRefCnt;

    // Event handle set by CertControlStore(CERT_STORE_CTRL_AUTO_RESYNC)
    HANDLE              hAutoResyncEvent;

    // Store provider info
    LONG                lStoreProvRefCnt;
    HANDLE              hStoreProvWait;
    HCRYPTOIDFUNCADDR   hStoreProvFuncAddr;
    CERT_STORE_PROV_INFO StoreProvInfo;
};

//+-------------------------------------------------------------------------
//  Store states
//--------------------------------------------------------------------------
#define STORE_STATE_DELETED         0
#define STORE_STATE_NULL            1
#define STORE_STATE_OPENING         2
#define STORE_STATE_OPEN            3
#define STORE_STATE_DEFER_CLOSING   4
#define STORE_STATE_CLOSING         5
#define STORE_STATE_CLOSED          6


//+-------------------------------------------------------------------------
//  Key Identifier Element
//--------------------------------------------------------------------------
typedef struct _KEYID_ELEMENT {
    CRYPT_HASH_BLOB     KeyIdentifier;
    PPROP_ELEMENT       pPropHead;
} KEYID_ELEMENT, *PKEYID_ELEMENT;


//+-------------------------------------------------------------------------
//  The "Find ANY" INFO data structure.
//
//  0 is the ANY dwFindType for all context types.
//--------------------------------------------------------------------------
static CCERT_STORE_PROV_FIND_INFO FindAnyInfo = {
    sizeof(CCERT_STORE_PROV_FIND_INFO),         // cbSize
    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,    // dwMsgAndCertEncodingType
    0,                                          // dwFindFlags
    0,                                          // dwFindType
    NULL                                        // pvFindPara
};

//+-------------------------------------------------------------------------
//  NULL Store.
//
//  HANDLE of all CONTEXTs created by CertCreateCertificateContext or
//  CertCreateCRLContext. Created CONTEXTs are immediately added to the
//  NULL store's free list. (ie, the store doesn't have a RefCnt on the
//  CONTEXT.)
//--------------------------------------------------------------------------
static CERT_STORE NullCertStore;

//+-------------------------------------------------------------------------
//  Bug in rsabase.dll. Its not thread safe across multiple crypt prov
//  handles.
//--------------------------------------------------------------------------
static CRITICAL_SECTION     CryptProvCriticalSection;

//+-------------------------------------------------------------------------
//  Store file definitions
//
//  The file consist of the FILE_HDR followed by 1 or more FILE_ELEMENTs.
//  Each FILE_ELEMENT has a FILE_ELEMENT_HDR + its value.
//
//  First the CERT elements are written. If a CERT has any properties, then,
//  the PROP elements immediately precede the CERT's element. Next the CRL
//  elements are written. If a CRL has any properties, then, the PROP elements
//  immediately precede the CRL's element. Likewise for CTL elements and its
//  properties. Finally, the END element is written.
//--------------------------------------------------------------------------
typedef struct _FILE_HDR {
    DWORD               dwVersion;
    DWORD               dwMagic;
} FILE_HDR, *PFILE_HDR;

#define CERT_FILE_VERSION_0             0
#define CERT_MAGIC ((DWORD)'C'+((DWORD)'E'<<8)+((DWORD)'R'<<16)+((DWORD)'T'<<24))

// The element's data follows the HDR
typedef struct _FILE_ELEMENT_HDR {
    DWORD               dwEleType;
    DWORD               dwEncodingType;
    DWORD               dwLen;
} FILE_ELEMENT_HDR, *PFILE_ELEMENT_HDR;

#define FILE_ELEMENT_END_TYPE           0
// FILE_ELEMENT_PROP_TYPEs              !(0 | CERT | CRL | CTL | KEYID)
// Note CERT_KEY_CONTEXT_PROP_ID (and CERT_KEY_PROV_HANDLE_PROP_ID)
// isn't written
#define FILE_ELEMENT_CERT_TYPE          32
#define FILE_ELEMENT_CRL_TYPE           33
#define FILE_ELEMENT_CTL_TYPE           34
#define FILE_ELEMENT_KEYID_TYPE         35

// BUGBUG upper limit for CTL ??
//#define MAX_FILE_ELEMENT_DATA_LEN       (4096 * 16)
#define MAX_FILE_ELEMENT_DATA_LEN       0xFFFFFFFF

//+-------------------------------------------------------------------------
//  Used when reading an element
//--------------------------------------------------------------------------
#define CSError     0
#define CSContinue  1
#define CSEnd       2

//+-------------------------------------------------------------------------
//  Read & Write to memory/file function definitions
//--------------------------------------------------------------------------
typedef BOOL (* PFNWRITE)(HANDLE h, void * p, DWORD cb);
typedef BOOL (* PFNREAD)(HANDLE h, void * p, DWORD cb);


//+-------------------------------------------------------------------------
//  Store Provider Functions
//--------------------------------------------------------------------------
STATIC BOOL WINAPI OpenMsgStoreProv(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        );

STATIC BOOL WINAPI OpenMemoryStoreProv(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
    pStoreProvInfo->dwStoreProvFlags |= CERT_STORE_PROV_NO_PERSIST_FLAG;
    return TRUE;
}

STATIC BOOL WINAPI OpenFileStoreProv(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        );

STATIC BOOL WINAPI OpenPKCS7StoreProv(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        );

STATIC BOOL WINAPI OpenSerializedStoreProv(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        );

STATIC BOOL WINAPI OpenFilenameStoreProvA(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        );

STATIC BOOL WINAPI OpenFilenameStoreProvW(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        );

STATIC BOOL WINAPI OpenCollectionStoreProv(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
    PCERT_STORE pStore = (PCERT_STORE) hCertStore;

    pStore->dwStoreType = STORE_TYPE_COLLECTION;
    return TRUE;
}

// from regstor.cpp
extern BOOL WINAPI I_CertDllOpenRegStoreProv(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        );
extern BOOL WINAPI I_CertDllOpenSystemStoreProvA(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        );
extern BOOL WINAPI I_CertDllOpenSystemStoreProvW(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        );

extern BOOL WINAPI I_CertDllOpenSystemRegistryStoreProvW(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        );
extern BOOL WINAPI I_CertDllOpenSystemRegistryStoreProvA(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        );
extern BOOL WINAPI I_CertDllOpenPhysicalStoreProvW(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        );

static HCRYPTOIDFUNCSET hOpenStoreProvFuncSet;
static const CRYPT_OID_FUNC_ENTRY OpenStoreProvFuncTable[] = {
#ifdef CAPI_INCLUDE_PKCS7
    CERT_STORE_PROV_MSG, OpenMsgStoreProv,
#endif
    CERT_STORE_PROV_MEMORY, OpenMemoryStoreProv,
#ifdef CAPI_INCLUDE_SERIALIZED_STORE
    CERT_STORE_PROV_FILE, OpenFileStoreProv,
#endif
    CERT_STORE_PROV_REG, I_CertDllOpenRegStoreProv,
#ifdef CAPI_INCLUDE_PKCS7
    CERT_STORE_PROV_PKCS7, OpenPKCS7StoreProv,
#endif
#ifdef CAPI_INCLUDE_SERIALIZED_STORE
    CERT_STORE_PROV_SERIALIZED, OpenSerializedStoreProv,
#endif
#ifdef CAPI_INCLUDE_FILENAME_STORE
    CERT_STORE_PROV_FILENAME_A, OpenFilenameStoreProvA,
    CERT_STORE_PROV_FILENAME_W, OpenFilenameStoreProvW,
#endif
    CERT_STORE_PROV_SYSTEM_A, I_CertDllOpenSystemStoreProvA,
    CERT_STORE_PROV_SYSTEM_W, I_CertDllOpenSystemStoreProvW,
    CERT_STORE_PROV_COLLECTION, OpenCollectionStoreProv,
    CERT_STORE_PROV_SYSTEM_REGISTRY_A, I_CertDllOpenSystemRegistryStoreProvA,
    CERT_STORE_PROV_SYSTEM_REGISTRY_W, I_CertDllOpenSystemRegistryStoreProvW,
    CERT_STORE_PROV_PHYSICAL_W, I_CertDllOpenPhysicalStoreProvW,
#ifdef CAPI_INCLUDE_SMARTCARD_STORE
    CERT_STORE_PROV_SMART_CARD_W, SmartCardProvOpenStore,
#endif

    sz_CERT_STORE_PROV_MEMORY, OpenMemoryStoreProv,
    sz_CERT_STORE_PROV_SYSTEM_W, I_CertDllOpenSystemStoreProvW,
#ifdef CAPI_INCLUDE_FILENAME_STORE
    sz_CERT_STORE_PROV_FILENAME_W, OpenFilenameStoreProvW,
#endif
#ifdef CAPI_INCLUDE_PKCS7
    sz_CERT_STORE_PROV_PKCS7, OpenPKCS7StoreProv,
#endif
#ifdef CAPI_INCLUDE_SERIALIZED_STORE
    sz_CERT_STORE_PROV_SERIALIZED, OpenSerializedStoreProv,
#endif
    sz_CERT_STORE_PROV_COLLECTION, OpenCollectionStoreProv,
    sz_CERT_STORE_PROV_SYSTEM_REGISTRY_W, I_CertDllOpenSystemRegistryStoreProvW,
    sz_CERT_STORE_PROV_PHYSICAL_W, I_CertDllOpenPhysicalStoreProvW,
#ifdef CAPI_INCLUDE_SMARTCARD_STORE
    sz_CERT_STORE_PROV_SMART_CARD_W, SmartCardProvOpenStore
#endif
};
#define OPEN_STORE_PROV_FUNC_COUNT (sizeof(OpenStoreProvFuncTable) / \
                                    sizeof(OpenStoreProvFuncTable[0]))


//+-------------------------------------------------------------------------
//  NULL Store: initialization and free
//--------------------------------------------------------------------------
STATIC void InitNullCertStore()
{
    memset(&NullCertStore, 0, sizeof(NullCertStore));
    NullCertStore.dwStoreType = STORE_TYPE_CACHE;
    NullCertStore.lRefCnt = 1;
    NullCertStore.dwState = STORE_STATE_NULL;
    InitializeCriticalSection(&NullCertStore.CriticalSection);
    NullCertStore.StoreProvInfo.dwStoreProvFlags =
        CERT_STORE_PROV_NO_PERSIST_FLAG;
}
STATIC void FreeNullCertStore()
{
    DeleteCriticalSection(&NullCertStore.CriticalSection);
}

//+-------------------------------------------------------------------------
//  CryptProv: initialization and free
//--------------------------------------------------------------------------
STATIC void InitCryptProv()
{
    InitializeCriticalSection(&CryptProvCriticalSection);
}
STATIC void FreeCryptProv()
{
    DeleteCriticalSection(&CryptProvCriticalSection);
}

#if 1
// BUGBUG move to crypt32.dll
extern
BOOL
WINAPI
I_RegStoreDllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved);
#endif

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL
WINAPI
CertStoreDllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved)
{
    BOOL    fRet;

#if 1
    // BUGBUG move to crypt32.dll
    if (!I_RegStoreDllMain(hInst, ulReason, lpReserved))
        goto ErrorReturn;
#endif

    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        InitNullCertStore();
        InitCryptProv();

        // Used for "root" system store's message box
        hCertStoreInst = hInst;

        if (NULL == (hOpenStoreProvFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_OPEN_STORE_PROV_FUNC, 0)))
            goto CryptInitOIDFunctionSetError;

        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                0,                          // dwEncodingType
                CRYPT_OID_OPEN_STORE_PROV_FUNC,
                OPEN_STORE_PROV_FUNC_COUNT,
                OpenStoreProvFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError;
        break;

    case DLL_PROCESS_DETACH:
        FreeCryptProv();
        FreeNullCertStore();
        break;
    case DLL_THREAD_DETACH:
    default:
        break;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(CryptInitOIDFunctionSetError)
TRACE_ERROR(CryptInstallOIDFunctionAddressError)
}


//+=========================================================================
//  Context Type Tables
//==========================================================================

//+-------------------------------------------------------------------------
//  Provider callback function indices
//--------------------------------------------------------------------------
static const DWORD rgdwStoreProvFindIndex[CONTEXT_COUNT] = {
    CERT_STORE_PROV_FIND_CERT_FUNC,
    CERT_STORE_PROV_FIND_CRL_FUNC,
    CERT_STORE_PROV_FIND_CTL_FUNC
};

static const DWORD rgdwStoreProvWriteIndex[CONTEXT_COUNT] = {
    CERT_STORE_PROV_WRITE_CERT_FUNC,
    CERT_STORE_PROV_WRITE_CRL_FUNC,
    CERT_STORE_PROV_WRITE_CTL_FUNC
};

static const DWORD rgdwStoreProvDeleteIndex[CONTEXT_COUNT] = {
    CERT_STORE_PROV_DELETE_CERT_FUNC,
    CERT_STORE_PROV_DELETE_CRL_FUNC,
    CERT_STORE_PROV_DELETE_CTL_FUNC
};

static const DWORD rgdwStoreProvFreeFindIndex[CONTEXT_COUNT] = {
    CERT_STORE_PROV_FREE_FIND_CERT_FUNC,
    CERT_STORE_PROV_FREE_FIND_CRL_FUNC,
    CERT_STORE_PROV_FREE_FIND_CTL_FUNC
};

static const DWORD rgdwStoreProvGetPropertyIndex[CONTEXT_COUNT] = {
    CERT_STORE_PROV_GET_CERT_PROPERTY_FUNC,
    CERT_STORE_PROV_GET_CRL_PROPERTY_FUNC,
    CERT_STORE_PROV_GET_CTL_PROPERTY_FUNC
};

static const DWORD rgdwStoreProvSetPropertyIndex[CONTEXT_COUNT] = {
    CERT_STORE_PROV_SET_CERT_PROPERTY_FUNC,
    CERT_STORE_PROV_SET_CRL_PROPERTY_FUNC,
    CERT_STORE_PROV_SET_CTL_PROPERTY_FUNC
};

//+-------------------------------------------------------------------------
//  Context data structure length and field offsets
//--------------------------------------------------------------------------
static const DWORD rgcbContext[CONTEXT_COUNT] = {
    sizeof(CERT_CONTEXT),
    sizeof(CRL_CONTEXT),
    sizeof(CTL_CONTEXT)
};

static const DWORD rgOffsetofStoreHandle[CONTEXT_COUNT] = {
    offsetof(CERT_CONTEXT, hCertStore),
    offsetof(CRL_CONTEXT, hCertStore),
    offsetof(CTL_CONTEXT, hCertStore)
};

static const DWORD rgOffsetofEncodingType[CONTEXT_COUNT] = {
    offsetof(CERT_CONTEXT, dwCertEncodingType),
    offsetof(CRL_CONTEXT, dwCertEncodingType),
    offsetof(CTL_CONTEXT, dwMsgAndCertEncodingType)
};

static const DWORD rgOffsetofEncodedPointer[CONTEXT_COUNT] = {
    offsetof(CERT_CONTEXT, pbCertEncoded),
    offsetof(CRL_CONTEXT, pbCrlEncoded),
    offsetof(CTL_CONTEXT, pbCtlEncoded)
};

static const DWORD rgOffsetofEncodedCount[CONTEXT_COUNT] = {
    offsetof(CERT_CONTEXT, cbCertEncoded),
    offsetof(CRL_CONTEXT, cbCrlEncoded),
    offsetof(CTL_CONTEXT, cbCtlEncoded)
};

//+-------------------------------------------------------------------------
//  Find Types
//--------------------------------------------------------------------------
static const DWORD rgdwFindTypeToFindExisting[CONTEXT_COUNT] = {
    CERT_FIND_EXISTING,
    CRL_FIND_EXISTING,
    CTL_FIND_EXISTING
};

//+-------------------------------------------------------------------------
//  File Element Types
//--------------------------------------------------------------------------
static const DWORD rgdwFileElementType[CONTEXT_COUNT] = {
    FILE_ELEMENT_CERT_TYPE,
    FILE_ELEMENT_CRL_TYPE,
    FILE_ELEMENT_CTL_TYPE
};

//+=========================================================================
//  Context Type Specific Functions
//==========================================================================

//+-------------------------------------------------------------------------
//  CERT_CONTEXT Element
//--------------------------------------------------------------------------

// pbCertEncoded has already been allocated
STATIC PCONTEXT_ELEMENT CreateCertElement(
    IN PCERT_STORE pStore,
    IN DWORD dwCertEncodingType,
    IN BYTE *pbCertEncoded,
    IN DWORD cbCertEncoded
    );
STATIC void FreeCertElement(IN PCONTEXT_ELEMENT pEle);

STATIC BOOL IsSameCert(
    IN PCCERT_CONTEXT pCert,
    IN PCCERT_CONTEXT pNew
    );

STATIC BOOL CompareCertElement(
    IN PCONTEXT_ELEMENT pEle,
    IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
    IN BOOL fArchived
    );

STATIC BOOL IsNewerCertElement(
    IN PCONTEXT_ELEMENT pNewEle,
    IN PCONTEXT_ELEMENT pExistingEle
    );

static inline PCONTEXT_ELEMENT ToContextElement(
    IN PCCERT_CONTEXT pCertContext
    )
{
    if (pCertContext)
        return (PCONTEXT_ELEMENT)
            (((BYTE *) pCertContext) - sizeof(CONTEXT_ELEMENT));
    else
        return NULL;
}
static inline PCCERT_CONTEXT ToCertContext(
    IN PCONTEXT_ELEMENT pEle
    )
{
    if (pEle)
        return (PCCERT_CONTEXT)
            (((BYTE *) pEle) + sizeof(CONTEXT_ELEMENT));
    else
        return NULL;
}

#ifdef CAPI_INCLUDE_CRL
//+-------------------------------------------------------------------------
//  CRL_CONTEXT Element
//--------------------------------------------------------------------------

// pbCrlEncoded has already been allocated
STATIC PCONTEXT_ELEMENT CreateCrlElement(
    IN PCERT_STORE pStore,
    IN DWORD dwCertEncodingType,
    IN BYTE *pbCrlEncoded,
    IN DWORD cbCrlEncoded
    );
STATIC void FreeCrlElement(IN PCONTEXT_ELEMENT pEle);
STATIC BOOL CompareCrlElement(
    IN PCONTEXT_ELEMENT pEle,
    IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
    IN BOOL fArchived
    );

STATIC BOOL IsNewerCrlElement(
    IN PCONTEXT_ELEMENT pNewEle,
    IN PCONTEXT_ELEMENT pExistingEle
    );

static inline PCONTEXT_ELEMENT ToContextElement(
    IN PCCRL_CONTEXT pCrlContext
    )
{
    if (pCrlContext)
        return (PCONTEXT_ELEMENT)
            (((BYTE *) pCrlContext) - sizeof(CONTEXT_ELEMENT));
    else
        return NULL;
}
static inline PCCRL_CONTEXT ToCrlContext(
    IN PCONTEXT_ELEMENT pEle
    )
{
    if (pEle)
        return (PCCRL_CONTEXT)
            (((BYTE *) pEle) + sizeof(CONTEXT_ELEMENT));
    else
        return NULL;
}

static inline PCRL_CONTEXT_SUFFIX ToCrlContextSuffix(
    IN PCONTEXT_ELEMENT pEle
    )
{
    if (pEle)
        return (PCRL_CONTEXT_SUFFIX)
            (((BYTE *) pEle) + sizeof(CONTEXT_ELEMENT) + sizeof(CRL_CONTEXT));
    else
        return NULL;
}
#endif

#ifdef CAPI_INCLUDE_CTL
//+-------------------------------------------------------------------------
//  CTL_CONTEXT Element
//--------------------------------------------------------------------------

// pbCtlEncoded has already been allocated
STATIC PCONTEXT_ELEMENT CreateCtlElement(
    IN PCERT_STORE pStore,
    IN DWORD dwMsgAndCertEncodingType,
    IN BYTE *pbCtlEncoded,
    IN DWORD cbCtlEncoded
    );
STATIC void FreeCtlElement(IN PCONTEXT_ELEMENT pEle);
STATIC BOOL CompareCtlElement(
    IN PCONTEXT_ELEMENT pEle,
    IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
    IN BOOL fArchived
    );

STATIC BOOL IsNewerCtlElement(
    IN PCONTEXT_ELEMENT pNewEle,
    IN PCONTEXT_ELEMENT pExistingEle
    );

static inline PCONTEXT_ELEMENT ToContextElement(
    IN PCCTL_CONTEXT pCtlContext
    )
{
    if (pCtlContext)
        return (PCONTEXT_ELEMENT)
            (((BYTE *) pCtlContext) - sizeof(CONTEXT_ELEMENT));
    else
        return NULL;
}
static inline PCCTL_CONTEXT ToCtlContext(
    IN PCONTEXT_ELEMENT pEle
    )
{
    if (pEle)
        return (PCCTL_CONTEXT)
            (((BYTE *) pEle) + sizeof(CONTEXT_ELEMENT));
    else
        return NULL;
}

static inline PCTL_CONTEXT_SUFFIX ToCtlContextSuffix(
    IN PCONTEXT_ELEMENT pEle
    )
{
    if (pEle)
        return (PCTL_CONTEXT_SUFFIX)
            (((BYTE *) pEle) + sizeof(CONTEXT_ELEMENT) + sizeof(CTL_CONTEXT));
    else
        return NULL;
}
#endif

//+=========================================================================
//  Context Type Function Tables
//==========================================================================
typedef PCONTEXT_ELEMENT (*PFN_CREATE_ELEMENT)(
    IN PCERT_STORE pStore,
    IN DWORD dwCertEncodingType,
    IN BYTE *pbCertEncoded,
    IN DWORD cbCertEncoded
    );

static PFN_CREATE_ELEMENT const rgpfnCreateElement[CONTEXT_COUNT] = {
    CreateCertElement,
#ifdef CAPI_INCLUDE_CRL
    CreateCrlElement,
#else
	NULL,
#endif

#ifdef CAPI_INCLUDE_CTL
    CreateCtlElement
#else
	NULL
#endif
};

typedef void (*PFN_FREE_ELEMENT)(
    IN PCONTEXT_ELEMENT pEle
    );

static PFN_FREE_ELEMENT const rgpfnFreeElement[CONTEXT_COUNT] = {
    FreeCertElement,
#ifdef CAPI_INCLUDE_CRL
    FreeCrlElement,
#else
	NULL,
#endif
#ifdef CAPI_INCLUDE_CTL
    FreeCtlElement
#else
	NULL
#endif
};

typedef BOOL (*PFN_COMPARE_ELEMENT)(
    IN PCONTEXT_ELEMENT pEle,
    IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
    IN BOOL fArchived
    );

static PFN_COMPARE_ELEMENT const rgpfnCompareElement[CONTEXT_COUNT] = {
    CompareCertElement,
#ifdef CAPI_INCLUDE_CRL
    CompareCrlElement,
#else
	NULL,
#endif
#ifdef CAPI_INCLUDE_CTL
    CompareCtlElement
#else
	NULL
#endif
};

typedef BOOL (*PFN_IS_NEWER_ELEMENT)(
    IN PCONTEXT_ELEMENT pNewEle,
    IN PCONTEXT_ELEMENT pExistingEle
    );

static PFN_IS_NEWER_ELEMENT const rgpfnIsNewerElement[CONTEXT_COUNT] = {
    IsNewerCertElement,
#ifdef CAPI_INCLUDE_CRL
    IsNewerCrlElement,
#else
	NULL,
#endif
#ifdef CAPI_INCLUDE_CTL
    IsNewerCtlElement
#else
	NULL
#endif
};

//+=========================================================================
//  Store Link Functions
//==========================================================================

STATIC PCERT_STORE_LINK CreateStoreLink(
    IN PCERT_STORE pCollection,
    IN PCERT_STORE pSibling,
    IN DWORD dwUpdateFlags,
    IN DWORD dwPriority
    );
STATIC void FreeStoreLink(
    IN PCERT_STORE_LINK pStoreLink
    );
STATIC void RemoveStoreLink(
    IN PCERT_STORE_LINK pStoreLink
    );
STATIC void RemoveAndFreeStoreLink(
    IN PCERT_STORE_LINK pStoreLink
    );

static inline void AddRefStoreLink(
    IN PCERT_STORE_LINK pStoreLink
    )
{
    InterlockedIncrement(&pStoreLink->lRefCnt);
}

STATIC void ReleaseStoreLink(
    IN PCERT_STORE_LINK pStoreLink
    );

//+=========================================================================
//  Context Element Functions
//==========================================================================

STATIC DWORD GetContextEncodingType(
    IN PCONTEXT_ELEMENT pEle
    );

STATIC void GetContextEncodedInfo(
    IN PCONTEXT_ELEMENT pEle,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded
    );

STATIC PCONTEXT_ELEMENT GetCacheElement(
    IN PCONTEXT_ELEMENT pCacheEle
    );

STATIC void AddContextElement(
    IN PCONTEXT_ELEMENT pEle
    );
STATIC void RemoveContextElement(
    IN PCONTEXT_ELEMENT pEle
    );
STATIC void FreeContextElement(
    IN PCONTEXT_ELEMENT pEle
    );
STATIC void RemoveAndFreeContextElement(
    IN PCONTEXT_ELEMENT pEle
    );

STATIC void AddRefContextElement(
    IN PCONTEXT_ELEMENT pEle
    );
STATIC void AddRefDeferClose(
    IN PCONTEXT_ELEMENT pEle
    );
STATIC void ReleaseContextElement(
    IN PCONTEXT_ELEMENT pEle
    );
STATIC BOOL DeleteContextElement(
    IN PCONTEXT_ELEMENT pEle
    );

STATIC BOOL SerializeStoreElement(
    IN HANDLE h,
    IN PFNWRITE pfn,
    IN PCONTEXT_ELEMENT pEle
    );

STATIC BOOL SerializeContextElement(
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwFlags,
    OUT BYTE *pbElement,
    IN OUT DWORD *pcbElement
    );

STATIC PCONTEXT_ELEMENT CreateLinkElement(
    IN DWORD dwContextType
    );

static inline void FreeLinkElement(
    IN PCONTEXT_ELEMENT pLinkEle
    )
{
    PkiFree(pLinkEle);
}

STATIC void FreeLinkContextElement(
    IN PCONTEXT_ELEMENT pLinkEle
    );

// Upon entry no locks
STATIC void RemoveAndFreeLinkElement(
    IN PCONTEXT_ELEMENT pEle
    );

STATIC PCONTEXT_ELEMENT FindElementInStore(
    IN PCERT_STORE pStore,
    IN DWORD dwContextType,
    IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
    IN OPTIONAL PCONTEXT_ELEMENT pPrevEle
    );

STATIC PCONTEXT_ELEMENT CheckAutoResyncAndFindElementInStore(
    IN PCERT_STORE pStore,
    IN DWORD dwContextType,
    IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
    IN OPTIONAL PCONTEXT_ELEMENT pPrevEle
    );

STATIC BOOL AddLinkContextToCacheStore(
    IN PCERT_STORE pStore,
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCONTEXT_ELEMENT *ppStoreEle
    );

// pEle is used or freed for success only, Otherwise, its left alone and
// will be freed by the caller.
//
// This routine may be called recursively
STATIC BOOL AddElementToStore(
    IN PCERT_STORE pStore,
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCONTEXT_ELEMENT *ppStoreEle
    );

STATIC BOOL AddEncodedContextToStore(
    IN PCERT_STORE pStore,
    IN DWORD dwContextType,
    IN DWORD dwCertEncodingType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCONTEXT_ELEMENT *ppStoreEle
    );

STATIC BOOL AddContextToStore(
    IN PCERT_STORE pStore,
    IN PCONTEXT_ELEMENT pSrcEle,
    IN DWORD dwCertEncodingType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCONTEXT_ELEMENT *ppStoreEle
    );

//+=========================================================================
//  PROP_ELEMENT Functions
//==========================================================================
// pbData has already been allocated
STATIC PPROP_ELEMENT CreatePropElement(
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN BYTE *pbData,
    IN DWORD cbData
    );
STATIC void FreePropElement(IN PPROP_ELEMENT pEle);

// Upon entry/exit: Store/Element is locked
STATIC PPROP_ELEMENT FindPropElement(
    IN PPROP_ELEMENT pPropEle,
    IN DWORD dwPropId
    );
STATIC PPROP_ELEMENT FindPropElement(
    IN PCONTEXT_ELEMENT pCacheEle,
    IN DWORD dwPropId
    );

// Upon entry/exit: Store/Element is locked
STATIC void AddPropElement(
    IN OUT PPROP_ELEMENT *ppPropHead,
    IN PPROP_ELEMENT pPropEle
    );
STATIC void AddPropElement(
    IN OUT PCONTEXT_ELEMENT pCacheEle,
    IN PPROP_ELEMENT pPropEle
    );

// Upon entry/exit: Store/Element is locked
STATIC void RemovePropElement(
    IN OUT PPROP_ELEMENT *ppPropHead,
    IN PPROP_ELEMENT pPropEle
    );
STATIC void RemovePropElement(
    IN OUT PCONTEXT_ELEMENT pCacheEle,
    IN PPROP_ELEMENT pPropEle
    );

//+=========================================================================
//  Property Functions
//==========================================================================

//+-------------------------------------------------------------------------
//  Set the property for the specified element
//--------------------------------------------------------------------------
STATIC BOOL SetProperty(
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN const void *pvData,
    IN BOOL fInhibitProvSet = FALSE
    );

//+-------------------------------------------------------------------------
//  Get the property for the specified element
//--------------------------------------------------------------------------
STATIC BOOL GetProperty(
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwPropId,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    );

// Upon entry/exit the store is locked
STATIC void DeleteProperty(
    IN OUT PPROP_ELEMENT *ppPropHead,
    IN DWORD dwPropId
    );
STATIC void DeleteProperty(
    IN OUT PCONTEXT_ELEMENT pCacheEle,
    IN DWORD dwPropId
    );

//+-------------------------------------------------------------------------
//  Serialize a Property
//--------------------------------------------------------------------------
STATIC BOOL SerializeProperty(
    IN HANDLE h,
    IN PFNWRITE pfn,
    IN PCONTEXT_ELEMENT pEle
    );

#define COPY_PROPERTY_USE_EXISTING_FLAG     0x1
#define COPY_PROPERTY_INHIBIT_PROV_SET_FLAG 0x2
#define COPY_PROPERTY_SYNC_FLAG             0x4
STATIC BOOL CopyProperties(
    IN PCONTEXT_ELEMENT pSrcEle,
    IN PCONTEXT_ELEMENT pDstEle,
    IN DWORD dwFlags
    );

//+-------------------------------------------------------------------------
//  Get the first or next PropId for the specified element
//
//  Set dwPropId = 0, to get the first. Returns 0, if no more properties.
//--------------------------------------------------------------------------
STATIC DWORD EnumProperties(
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwPropId
    );

//+-------------------------------------------------------------------------
//  Get or set the caller properties for a store or KeyId element.
//--------------------------------------------------------------------------
STATIC BOOL GetCallerProperty(
    IN PPROP_ELEMENT pPropHead,
    IN DWORD dwPropId,
    BOOL fAlloc,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    );

BOOL SetCallerProperty(
    IN OUT PPROP_ELEMENT *ppPropHead,
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN const void *pvData
    );

//+-------------------------------------------------------------------------
//  CRYPT_KEY_PROV_INFO: Encode and Decode Functions
//--------------------------------------------------------------------------
STATIC BOOL AllocAndEncodeKeyProvInfo(
    IN PCRYPT_KEY_PROV_INFO pKeyProvInfo,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded
    );
STATIC void DecodeKeyProvInfo(
    IN OUT BYTE *pbData
    );

//+=========================================================================
//  KEYID_ELEMENT Functions
//==========================================================================
// pbKeyIdEncoded has already been allocated
STATIC PKEYID_ELEMENT CreateKeyIdElement(
    IN BYTE *pbKeyIdEncoded,
    IN DWORD cbKeyIdEncoded
    );
STATIC void FreeKeyIdElement(IN PKEYID_ELEMENT pEle);

//+=========================================================================
// Key Identifier Property Functions
//
// If dwPropId == 0, check if the element has a KEY_PROV_INFO property
//==========================================================================
STATIC void SetCryptKeyIdentifierKeyProvInfoProperty(
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwPropId = 0,
    IN const void *pvData = NULL
    );

STATIC BOOL GetKeyIdProperty(
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwPropId,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    );

//+-------------------------------------------------------------------------
//  Alloc and NOCOPY Decode
//--------------------------------------------------------------------------
STATIC void *AllocAndDecodeObject(
    IN DWORD dwCertEncodingType,
    IN LPCSTR lpszStructType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN DWORD dwFlags = CRYPT_DECODE_NOCOPY_FLAG
    )
{
    DWORD cbStructInfo;
    void *pvStructInfo;

    if (!CryptDecodeObjectEx(
            dwCertEncodingType,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            dwFlags |
                CRYPT_DECODE_SHARE_OID_STRING_FLAG | CRYPT_DECODE_ALLOC_FLAG,
            &PkiDecodePara,
            (void *) &pvStructInfo,
            &cbStructInfo
            ))
        goto ErrorReturn;

CommonReturn:
    return pvStructInfo;
ErrorReturn:
    pvStructInfo = NULL;
    goto CommonReturn;
}

#ifdef CAPI_INCLUDE_PKCS7
//+-------------------------------------------------------------------------
//  Allocates and returns the specified cryptographic message parameter.
//--------------------------------------------------------------------------
STATIC void *AllocAndGetMsgParam(
    IN HCRYPTMSG hMsg,
    IN DWORD dwParamType,
    IN DWORD dwIndex,
    OUT DWORD *pcbData
    )
{
    void *pvData;
    DWORD cbData;

    if (!CryptMsgGetParam(
            hMsg,
            dwParamType,
            dwIndex,
            NULL,           // pvData
            &cbData) || 0 == cbData)
        goto GetParamError;
    if (NULL == (pvData = PkiNonzeroAlloc(cbData)))
        goto OutOfMemory;
    if (!CryptMsgGetParam(
            hMsg,
            dwParamType,
            dwIndex,
            pvData,
            &cbData)) {
        PkiFree(pvData);
        goto GetParamError;
    }

CommonReturn:
    *pcbData = cbData;
    return pvData;
ErrorReturn:
    pvData = NULL;
    cbData = 0;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(GetParamError)
}
#endif	//CAPI_INCLUDE_PKCS7

//+-------------------------------------------------------------------------
//  First try to get the EncodingType from the lower 16 bits. If 0, get
//  from the upper 16 bits.
//--------------------------------------------------------------------------
static inline DWORD GetCertEncodingType(
    IN DWORD dwEncodingType
    )
{
    if (0 == dwEncodingType)
        return X509_ASN_ENCODING;
    else
        return (dwEncodingType & CERT_ENCODING_TYPE_MASK) ?
            (dwEncodingType & CERT_ENCODING_TYPE_MASK) :
            ((dwEncodingType >> 16) & CERT_ENCODING_TYPE_MASK);
}

STATIC DWORD AdjustEncodedLength(
    IN DWORD dwCertEncodingType,
    IN const BYTE *pbDER,
    IN DWORD cbDER
    )
{
    if (X509_ASN_ENCODING == GET_CERT_ENCODING_TYPE(dwCertEncodingType))
        return Asn1UtilAdjustEncodedLength(pbDER, cbDER);
    else
        return cbDER;
}

//+-------------------------------------------------------------------------
//  Read  & Write to file functions
//--------------------------------------------------------------------------
BOOL WriteToFile(HANDLE h, void * p, DWORD cb) {

    DWORD   cbBytesWritten;

    return(WriteFile(h, p, cb, &cbBytesWritten, NULL));
}
BOOL ReadFromFile(
    IN HANDLE h,
    IN void * p,
    IN DWORD cb
    )
{
    DWORD   cbBytesRead;

    return(ReadFile(h, p, cb, &cbBytesRead, NULL));
}


//+-------------------------------------------------------------------------
//  Read & Write to memory fucntion
//--------------------------------------------------------------------------
typedef struct _MEMINFO {
    BYTE *  pByte;
    DWORD   cb;
    DWORD   cbSeek;
} MEMINFO, * PMEMINFO;

BOOL WriteToMemory(HANDLE h, void * p, DWORD cb) {

    PMEMINFO pMemInfo = (PMEMINFO) h;

    // See if we have room. The caller will detect an error after the final
    // write
    if(pMemInfo->cbSeek + cb <= pMemInfo->cb)
        // copy the bytes
        memcpy(&pMemInfo->pByte[pMemInfo->cbSeek], p, cb);

    pMemInfo->cbSeek += cb;

    return(TRUE);

}
BOOL ReadFromMemory(
    IN HANDLE h,
    IN void * p,
    IN DWORD cb
    ) {

    PMEMINFO pMemInfo = (PMEMINFO) h;
    BOOL    fResult;


    fResult = !((pMemInfo->cb - pMemInfo->cbSeek) < cb);
    cb = min((pMemInfo->cb - pMemInfo->cbSeek), cb);

    // copy the bytes
    memcpy(p, &pMemInfo->pByte[pMemInfo->cbSeek], cb);
    pMemInfo->cbSeek += cb;

    if(!fResult)
        SetLastError(ERROR_END_OF_MEDIA);

    return(fResult);
}

//+-------------------------------------------------------------------------
//  Lock and unlock functions
//--------------------------------------------------------------------------
STATIC void LockStore(IN PCERT_STORE pStore)
{
    EnterCriticalSection(&pStore->CriticalSection);
}
STATIC void UnlockStore(IN PCERT_STORE pStore)
{
    LeaveCriticalSection(&pStore->CriticalSection);
}

//+-------------------------------------------------------------------------
//  Reference count calls to provider functions. This is necessary since
//  the store provider functions are called without a lock on the
//  store. CertCloseStore waits until the provider reference count
//  is decremented to zero before completing the close.
//
//  Also used to reference count use of the store's CryptProv handle when
//  used without a store lock.
//--------------------------------------------------------------------------

// Upon entry/exit the store is locked
static inline void AddRefStoreProv(IN PCERT_STORE pStore)
{
    pStore->lStoreProvRefCnt++;
}

// Upon entry/exit the store is locked
static inline void ReleaseStoreProv(IN PCERT_STORE pStore)
{
    if (0 == --pStore->lStoreProvRefCnt && pStore->hStoreProvWait)
        SetEvent(pStore->hStoreProvWait);
}

//+-------------------------------------------------------------------------
//  Try to get the store's CryptProv handle.
//  If we get the store's CryptProv handle,
//  then, increment the provider reference count to force another
//  thread's CertCloseStore to wait until we make a call to ReleaseCryptProv.
//
//  Leave while still in the CryptProvCriticalSection.
//
//  ReleaseCryptProv() must always be called.
//
//  Note, if returned hCryptProv is NULL, the called CertHelper functions
//  will acquire and use the appropriate default provider.
//--------------------------------------------------------------------------
#define RELEASE_STORE_CRYPT_PROV_FLAG   0x1

STATIC HCRYPTPROV GetCryptProv(
    IN PCERT_STORE pStore,
    OUT DWORD *pdwFlags
    )
{
    HCRYPTPROV hCryptProv;

    LockStore(pStore);
    hCryptProv = pStore->hCryptProv;
    if (hCryptProv) {
        AddRefStoreProv(pStore);
        *pdwFlags = RELEASE_STORE_CRYPT_PROV_FLAG;
    } else
        *pdwFlags = 0;
    UnlockStore(pStore);

    EnterCriticalSection(&CryptProvCriticalSection);
    return hCryptProv;
}

STATIC void ReleaseCryptProv(
    IN PCERT_STORE pStore,
    IN DWORD dwFlags
    )
{
    LeaveCriticalSection(&CryptProvCriticalSection);

    if (dwFlags & RELEASE_STORE_CRYPT_PROV_FLAG) {
        LockStore(pStore);
        ReleaseStoreProv(pStore);
        UnlockStore(pStore);
    }
}

//+-------------------------------------------------------------------------
//  Forward references
//--------------------------------------------------------------------------
STATIC BOOL IsEmptyStore(
    IN PCERT_STORE pStore
    );
STATIC BOOL CloseStore(
    IN PCERT_STORE pStore,
    DWORD dwFlags
    );

void ArchiveManifoldCertificatesInStore(
    IN PCERT_STORE pStore
    );

//+-------------------------------------------------------------------------
//  Open the cert store using the specified store provider.
//
//  hCryptProv specifies the crypto provider to use to create the hash
//  properties or verify the signature of a subject certificate or CRL.
//  The store doesn't need to use a private
//  key. If the CERT_STORE_NO_CRYPT_RELEASE_FLAG isn't set, hCryptProv is
//  CryptReleaseContext'ed on the final CertCloseStore.
//
//  Note, if the open fails, hCryptProv is released if it would have been
//  released when the store was closed.
//
//  If hCryptProv is zero, then, the default provider and container for the
//  PROV_RSA_FULL provider type is CryptAcquireContext'ed with
//  CRYPT_VERIFYCONTEXT access. The CryptAcquireContext is deferred until
//  the first create hash or verify signature. In addition, once acquired,
//  the default provider isn't released until process exit when crypt32.dll
//  is unloaded. The acquired default provider is shared across all stores
//  and threads.
//
//  Use of the dwEncodingType parameter is provider dependent. The type
//  definition for pvPara also depends on the provider.
//--------------------------------------------------------------------------
HCERTSTORE
WINAPI
CertOpenStore(
    IN LPCSTR lpszStoreProvider,
    IN DWORD dwEncodingType,
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwFlags,
    IN const void *pvPara
    )
{
    PCERT_STORE pStore;
    PFN_CERT_DLL_OPEN_STORE_PROV_FUNC pfnOpenStoreProv;

    pStore = (PCERT_STORE) PkiZeroAlloc(sizeof(*pStore));
    if (pStore == NULL) {
        if (hCryptProv && (dwFlags & CERT_STORE_NO_CRYPT_RELEASE_FLAG) == 0)
            CryptReleaseContext(hCryptProv, 0);
        return NULL;
    }

    pStore->StoreProvInfo.cbSize = sizeof(CERT_STORE_PROV_INFO);
    pStore->dwStoreType = STORE_TYPE_CACHE;
    pStore->lRefCnt = 1;
    pStore->dwState = STORE_STATE_OPENING;
    InitializeCriticalSection(&pStore->CriticalSection);
    pStore->hCryptProv = hCryptProv;
    pStore->dwFlags = dwFlags;

    if (CERT_STORE_PROV_MEMORY == lpszStoreProvider)
        pStore->StoreProvInfo.dwStoreProvFlags |=
            CERT_STORE_PROV_NO_PERSIST_FLAG;
    else {
        if (!CryptGetOIDFunctionAddress(
                hOpenStoreProvFuncSet,
                0,                      // dwEncodingType,
                lpszStoreProvider,
                0,                      // dwFlags
                (void **) &pfnOpenStoreProv,
                &pStore->hStoreProvFuncAddr))
            goto GetOIDFuncAddrError;
        if (!pfnOpenStoreProv(
                lpszStoreProvider,
                dwEncodingType,
                hCryptProv,
                dwFlags & ~CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG,
                pvPara,
                (HCERTSTORE) pStore,
                &pStore->StoreProvInfo)) {
            if (0 == (dwFlags & CERT_STORE_MAXIMUM_ALLOWED_FLAG))
                goto OpenStoreProvError;

            pStore->hCryptProv = NULL;
            CertCloseStore((HCERTSTORE) pStore, 0);

            return CertOpenStore(
                lpszStoreProvider,
                dwEncodingType,
                hCryptProv,
                (dwFlags & ~CERT_STORE_MAXIMUM_ALLOWED_FLAG) |
                    CERT_STORE_READONLY_FLAG,
                pvPara
                );
        }

        if (pStore->StoreProvInfo.dwStoreProvFlags &
                CERT_STORE_PROV_EXTERNAL_FLAG) {
            assert(STORE_TYPE_CACHE == pStore->dwStoreType &&
                IsEmptyStore(pStore));
            pStore->dwStoreType = STORE_TYPE_EXTERNAL;
        }

        if ((dwFlags & CERT_STORE_MANIFOLD_FLAG) &&
                STORE_TYPE_CACHE == pStore->dwStoreType)
            ArchiveManifoldCertificatesInStore(pStore);
    }

    if (dwFlags & CERT_STORE_DELETE_FLAG) {
        if (0 == (pStore->StoreProvInfo.dwStoreProvFlags &
                CERT_STORE_PROV_DELETED_FLAG))
            goto DeleteNotSupported;
        CertCloseStore((HCERTSTORE) pStore, 0);
        pStore = NULL;
        SetLastError(0);
    } else
        pStore->dwState = STORE_STATE_OPEN;

CommonReturn:
    return (HCERTSTORE) pStore;

ErrorReturn:
    CertCloseStore((HCERTSTORE) pStore, 0);
    pStore = NULL;
    if (dwFlags & CERT_STORE_DELETE_FLAG) {
        if (0 == GetLastError())
            SetLastError((DWORD) E_UNEXPECTED);
    }
    goto CommonReturn;

TRACE_ERROR(GetOIDFuncAddrError)
TRACE_ERROR(OpenStoreProvError)
SET_ERROR(DeleteNotSupported, ERROR_CALL_NOT_IMPLEMENTED)
}

//+-------------------------------------------------------------------------
//  Duplicate a cert store handle
//--------------------------------------------------------------------------
HCERTSTORE
WINAPI
CertDuplicateStore(
    IN HCERTSTORE hCertStore
    )
{
    PCERT_STORE pStore = (PCERT_STORE) hCertStore;
    assert(pStore->dwState == STORE_STATE_OPEN ||
        pStore->dwState == STORE_STATE_OPENING ||
        pStore->dwState == STORE_STATE_DEFER_CLOSING ||
        pStore->dwState == STORE_STATE_NULL);
    InterlockedIncrement(&pStore->lRefCnt);
    return hCertStore;
}

//+-------------------------------------------------------------------------
//  Checks if the store has any Certs, CRLs, CTLs, collection stores or
//  links
//--------------------------------------------------------------------------
STATIC BOOL IsEmptyStore(
    IN PCERT_STORE pStore
    )
{
    DWORD i;

    // Check that all the context lists are empty
    for (i = 0; i < CONTEXT_COUNT; i++) {
        if (pStore->rgpContextListHead[i])
            return FALSE;
    }

    // For collection, check that all stores have been removed
    if (pStore->pStoreListHead)
        return FALSE;

    return TRUE;
}

//+-------------------------------------------------------------------------
//  Free the store if empty
//
//  Store is locked upon input and unlocked or freed upon returning
//--------------------------------------------------------------------------
STATIC void FreeStore(
    IN PCERT_STORE pStore)
{
    if (STORE_STATE_DEFER_CLOSING == pStore->dwState) {
        // Check if duplicated context reference count is zero.
        InterlockedIncrement(&pStore->lDeferCloseRefCnt);
        if (InterlockedDecrement(&pStore->lDeferCloseRefCnt) == 0)
            CloseStore(pStore, 0);
        else
            UnlockStore(pStore);
    } else if (STORE_STATE_CLOSED == pStore->dwState && IsEmptyStore(pStore)) {
        UnlockStore(pStore);
        pStore->dwState = STORE_STATE_DELETED;
        if (pStore->hAutoResyncEvent)
            CloseHandle(pStore->hAutoResyncEvent);
        DeleteCriticalSection(&pStore->CriticalSection);
        PkiFree(pStore);
    } else
        UnlockStore(pStore);
}

//  Store is locked upon input and unlocked or freed upon returning
STATIC BOOL CloseStore(
    IN PCERT_STORE pStore,
    DWORD dwFlags
    )
{
    DWORD dwFailFlags = 0;
    DWORD i;
    PCONTEXT_ELEMENT pFreeLinkEleHead;
    PCERT_STORE_LINK pStoreLink;
    PCERT_STORE_LINK pFreeStoreLinkHead;
    PPROP_ELEMENT pPropEle;
    DWORD cStoreProvFunc;
    BOOL fFreeFindNext;

    PFN_CERT_STORE_PROV_CLOSE pfnStoreProvClose;
    HCRYPTPROV hCryptProv;

    assert(pStore);

    // Assert that another thread isn't already waiting for a provider
    // function to complete.
    assert(NULL == pStore->hStoreProvWait);
    // Assert that another thread isn't already waiting for a provider
    // to return from its close callback.
    assert(pStore->dwState != STORE_STATE_CLOSING &&
         pStore->dwState != STORE_STATE_CLOSED);
    if (pStore->hStoreProvWait || pStore->dwState == STORE_STATE_CLOSING ||
            pStore->dwState == STORE_STATE_CLOSED)
        goto UnexpectedError;

    assert(pStore->dwState == STORE_STATE_OPEN ||
        pStore->dwState == STORE_STATE_OPENING ||
        pStore->dwState == STORE_STATE_DEFER_CLOSING);
    pStore->dwState = STORE_STATE_CLOSING;

    cStoreProvFunc = pStore->StoreProvInfo.cStoreProvFunc;
    // By setting the following to 0 inhibits anyone else from calling
    // the provider's functions.
    pStore->StoreProvInfo.cStoreProvFunc = 0;
    if (cStoreProvFunc > CERT_STORE_PROV_CLOSE_FUNC)
        pfnStoreProvClose = (PFN_CERT_STORE_PROV_CLOSE)
                pStore->StoreProvInfo.rgpvStoreProvFunc[
                    CERT_STORE_PROV_CLOSE_FUNC];
    else
        pfnStoreProvClose = NULL;

    hCryptProv = pStore->hCryptProv;
    // By setting the following to 0 inhibits anyone else from using
    // the store's CryptProv handle
    pStore->hCryptProv = 0;

    fFreeFindNext = FALSE;
    if (STORE_TYPE_EXTERNAL == pStore->dwStoreType) {
        // Check if any FIND_NEXT external elements are remaining to be freed
        for (i = 0; i < CONTEXT_COUNT; i++) {
            PCONTEXT_ELEMENT pEle = pStore->rgpContextListHead[i];
            for ( ; pEle; pEle = pEle->pNext) {
                if (pEle->dwFlags & ELEMENT_FIND_NEXT_FLAG) {
                    pEle->dwFlags &= ~ELEMENT_FIND_NEXT_FLAG;
                    pEle->dwFlags |= ELEMENT_CLOSE_FIND_NEXT_FLAG;
                    AddRefContextElement(pEle);
                    fFreeFindNext = TRUE;
                }
            }
        }
    }

    if (pStore->lStoreProvRefCnt) {
        // Wait for all the provider functions to complete and all
        // uses of the hCryptProv handle to finish
        if (NULL == (pStore->hStoreProvWait = CreateEvent(
                NULL,       // lpsa
                FALSE,      // fManualReset
                FALSE,      // fInitialState
                NULL))) {   // lpszEventName
            assert(pStore->hStoreProvWait);
            goto UnexpectedError;
        }

        while (pStore->lStoreProvRefCnt) {
            UnlockStore(pStore);
            WaitForSingleObject(pStore->hStoreProvWait, INFINITE);
            LockStore(pStore);
        }
        CloseHandle(pStore->hStoreProvWait);
        pStore->hStoreProvWait = NULL;
    }

    if (fFreeFindNext) {
        // Call the provider to free the FIND_NEXT element. Must call
        // without holding a store lock.
        for (i = 0; i < CONTEXT_COUNT; i++) {
            const DWORD dwStoreProvFreeFindIndex =
                rgdwStoreProvFreeFindIndex[i];
            PCONTEXT_ELEMENT pEle = pStore->rgpContextListHead[i];
            while (pEle) {
                if (pEle->dwFlags & ELEMENT_CLOSE_FIND_NEXT_FLAG) {
                    PCONTEXT_ELEMENT pEleFree = pEle;
                    PFN_CERT_STORE_PROV_FREE_FIND_CERT pfnStoreProvFreeFindCert;

                    pEle = pEle->pNext;
                    while (pEle && 0 ==
                            (pEle->dwFlags & ELEMENT_CLOSE_FIND_NEXT_FLAG))
                        pEle = pEle->pNext;

                    UnlockStore(pStore);
                    if (dwStoreProvFreeFindIndex < cStoreProvFunc &&
                            NULL != (pfnStoreProvFreeFindCert =
                                (PFN_CERT_STORE_PROV_FREE_FIND_CERT)
                            pStore->StoreProvInfo.rgpvStoreProvFunc[
                                dwStoreProvFreeFindIndex]))
                        pfnStoreProvFreeFindCert(
                            pStore->StoreProvInfo.hStoreProv,
                            ToCertContext(pEleFree->pEle),
                            pEleFree->External.pvProvInfo,
                            0                       // dwFlags
                            );
                    ReleaseContextElement(pEleFree);
                    LockStore(pStore);
                } else
                    pEle = pEle->pNext;
            }
        }
    }

    if (pfnStoreProvClose) {
        // To prevent any type of deadlock, call the provider functions
        // without a lock on the store.
        //
        // Note our state is CLOSING, not CLOSED. This prevents any other
        // calls to FreeStore() from prematurely deleting the store.
        UnlockStore(pStore);
        pfnStoreProvClose(pStore->StoreProvInfo.hStoreProv, dwFlags);
        LockStore(pStore);
    }

    if (pStore->hStoreProvFuncAddr)
        CryptFreeOIDFunctionAddress(pStore->hStoreProvFuncAddr, 0);
    if (pStore->StoreProvInfo.hStoreProvFuncAddr2)
        CryptFreeOIDFunctionAddress(
            pStore->StoreProvInfo.hStoreProvFuncAddr2, 0);

    // Since hCryptProv was passed to the provider it must be released
    // last!!!
    if (hCryptProv &&
            0 == (pStore->dwFlags & CERT_STORE_NO_CRYPT_RELEASE_FLAG))
        CryptReleaseContext(hCryptProv, 0);

    // Iterate through the elements. If the element hasn't already been
    // deleted, remove the store's reference on the element. Remove and
    // free if no other references.
    pFreeLinkEleHead = NULL;
    for (i = 0; i < CONTEXT_COUNT; i++) {
        PCONTEXT_ELEMENT pEle = pStore->rgpContextListHead[i];
        while (pEle) {
            PCONTEXT_ELEMENT pEleNext = pEle->pNext;
            if (0 == (pEle->dwFlags & ELEMENT_DELETED_FLAG)) {
                if (0 == InterlockedDecrement(&pEle->lRefCnt)) {
                    if (ELEMENT_TYPE_LINK_CONTEXT == pEle->dwElementType) {
                        // The LINK_CONTEXT can't be freed while holding
                        // the store lock. Will free later after unlocking.
                        RemoveContextElement(pEle);
                        pEle->pNext = pFreeLinkEleHead;
                        pFreeLinkEleHead = pEle;
                    } else {
                        assert(ELEMENT_TYPE_CACHE == pEle->dwElementType);
                        RemoveAndFreeContextElement(pEle);
                    }
                } else
                    //  Still a reference on the element
                    pEle->dwFlags |= ELEMENT_DELETED_FLAG;
            }
            // else
            //  A previous delete has already removed the store's reference

            pEle = pEleNext;
        }
    }

    // Iterate through the store links. If the store link hasn't already been
    // deleted, remove the store's reference on the link. Remove and free
    // if no other references.
    pFreeStoreLinkHead = NULL;
    pStoreLink = pStore->pStoreListHead;
    while (pStoreLink) {
        PCERT_STORE_LINK pStoreLinkNext = pStoreLink->pNext;

        if (0 == (pStoreLink->dwFlags & STORE_LINK_DELETED_FLAG)) {
            if (0 == InterlockedDecrement(&pStoreLink->lRefCnt)) {
                // The STORE_LINK can't be freed while holding
                // the store lock. Will free later after unlocking.
                RemoveStoreLink(pStoreLink);
                pStoreLink->pNext = pFreeStoreLinkHead;
                pFreeStoreLinkHead = pStoreLink;
            } else
                //  Still a reference on the store link
                pStoreLink->dwFlags |= STORE_LINK_DELETED_FLAG;
        }
        // else
        //  A previous delete has already removed the store's reference

        pStoreLink = pStoreLinkNext;
    }

    if (pFreeLinkEleHead || pFreeStoreLinkHead) {
        // Unlock the store before freeing links
        UnlockStore(pStore);
        while (pFreeLinkEleHead) {
            PCONTEXT_ELEMENT pEle = pFreeLinkEleHead;
            pFreeLinkEleHead = pFreeLinkEleHead->pNext;
            FreeLinkContextElement(pEle);
        }

        while (pFreeStoreLinkHead) {
            pStoreLink = pFreeStoreLinkHead;
            pFreeStoreLinkHead = pFreeStoreLinkHead->pNext;
            FreeStoreLink(pStoreLink);
        }

        LockStore(pStore);
    }

    // Free the store's property elements
    while (pPropEle = pStore->pPropHead) {
        RemovePropElement(&pStore->pPropHead, pPropEle);
        FreePropElement(pPropEle);
    }

    if (dwFlags & CERT_CLOSE_STORE_CHECK_FLAG) {
        if (!IsEmptyStore(pStore))
            dwFailFlags = CERT_CLOSE_STORE_CHECK_FLAG;
    }

    if (dwFlags & CERT_CLOSE_STORE_FORCE_FLAG) {
        UnlockStore(pStore);

        for (i = 0; i < CONTEXT_COUNT; i++) {
            PCONTEXT_ELEMENT pEle;
            while (pEle = pStore->rgpContextListHead[i]) {
                if (ELEMENT_TYPE_CACHE == pEle->dwElementType)
                    RemoveAndFreeContextElement(pEle);
                else
                    RemoveAndFreeLinkElement(pEle);
            }
        }

        while (pStoreLink = pStore->pStoreListHead)
            RemoveAndFreeStoreLink(pStoreLink);

        LockStore(pStore);
        assert(IsEmptyStore(pStore));
    }

    pStore->dwState = STORE_STATE_CLOSED;
    // Either frees or unlocks the store
    FreeStore(pStore);

    if (dwFlags & dwFailFlags) {
        SetLastError((DWORD) CRYPT_E_PENDING_CLOSE);
        return FALSE;
    } else
        return TRUE;

UnexpectedError:
    UnlockStore(pStore);
    SetLastError((DWORD) E_UNEXPECTED);
    return FALSE;
}

//+-------------------------------------------------------------------------
//  Close a cert store handle.
//
//  There needs to be a corresponding close for each open and duplicate.
//
//  Even on the final close, the cert store isn't freed until all of its
//  certificate, CRL and CTL contexts have also been freed.
//
//  On the final close, the hCryptProv passed to CertOpenStore is
//  CryptReleaseContext'ed.
//
//  LastError is preserved unless CERT_CLOSE_STORE_CHECK_FLAG is set and FALSE
//  is returned.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertCloseStore(
    IN HCERTSTORE hCertStore,
    DWORD dwFlags
    )
{
    BOOL fResult;
    BOOL fPendingError = FALSE;
    PCERT_STORE pStore = (PCERT_STORE) hCertStore;
    DWORD dwErr = GetLastError();   // For success, don't globber LastError

    if (pStore == NULL)
        return TRUE;

    if (dwFlags & CERT_CLOSE_STORE_FORCE_FLAG) {
        LockStore(pStore);
        if (pStore->lRefCnt != 1) {
            if (dwFlags & CERT_CLOSE_STORE_CHECK_FLAG)
                fPendingError = TRUE;
        }
        pStore->lRefCnt = 0;
    } else if (InterlockedDecrement(&pStore->lRefCnt) == 0) {
        LockStore(pStore);
        if (pStore->dwFlags & CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG) {
            // Check if duplicated context reference count is zero.
            InterlockedIncrement(&pStore->lDeferCloseRefCnt);
            if (InterlockedDecrement(&pStore->lDeferCloseRefCnt) != 0) {
                assert(pStore->dwState == STORE_STATE_OPEN ||
                    pStore->dwState == STORE_STATE_OPENING ||
                    pStore->dwState == STORE_STATE_DEFER_CLOSING);
                pStore->dwState = STORE_STATE_DEFER_CLOSING;
                UnlockStore(pStore);
                goto PendingCloseReturn;
            }
        }
    } else
        // Still holding a reference count on the store
        goto PendingCloseReturn;

    // Don't allow the NULL store to be closed
    assert(pStore->dwState != STORE_STATE_NULL);
    if (pStore->dwState == STORE_STATE_NULL) {
        pStore->lRefCnt = 1;
        UnlockStore(pStore);
        SetLastError((DWORD) E_UNEXPECTED);
        return FALSE;
    }

    // CloseStore() unlocks or frees store
    fResult = CloseStore(pStore, dwFlags);
    if (fResult) {
        if (fPendingError) {
            fResult = FALSE;
            SetLastError((DWORD) CRYPT_E_PENDING_CLOSE);
        } else
            SetLastError(dwErr);
    }
    return fResult;

PendingCloseReturn:
    if (dwFlags & CERT_CLOSE_STORE_CHECK_FLAG) {
        SetLastError((DWORD) CRYPT_E_PENDING_CLOSE);
        fResult = FALSE;
    } else
        fResult = TRUE;
    return fResult;
}

//+=========================================================================
//  ArchiveManifoldCertificatesInStore
//==========================================================================

#define SORTED_MANIFOLD_ALLOC_COUNT     25

typedef struct _SORTED_MANIFOLD_ENTRY {
    PCCERT_CONTEXT      pCert;
    CRYPT_OBJID_BLOB    Value;
} SORTED_MANIFOLD_ENTRY, *PSORTED_MANIFOLD_ENTRY;

//+-------------------------------------------------------------------------
//  Called by qsort.
//
//  The Manifold entries are sorted according to manifold value and
//  the certificate's NotAfter and NotBefore times.
//--------------------------------------------------------------------------
STATIC int __cdecl CompareManifoldEntry(
    IN const void *pelem1,
    IN const void *pelem2
    )
{
    PSORTED_MANIFOLD_ENTRY p1 = (PSORTED_MANIFOLD_ENTRY) pelem1;
    PSORTED_MANIFOLD_ENTRY p2 = (PSORTED_MANIFOLD_ENTRY) pelem2;

    DWORD cb1 = p1->Value.cbData;
    DWORD cb2 = p2->Value.cbData;

    if (cb1 == cb2) {
        int iCmp;

        if (0 == cb1)
            iCmp = 0;
        else
            iCmp = memcmp(p1->Value.pbData, p2->Value.pbData, cb1);

        if (0 != iCmp)
            return iCmp;

        // Same manifold value. Compare the certificate NotAfter and
        // NotBefore times.
        iCmp = CompareFileTime(&p1->pCert->pCertInfo->NotAfter,
            &p2->pCert->pCertInfo->NotAfter);
        if (0 == iCmp)
            iCmp = CompareFileTime(&p1->pCert->pCertInfo->NotBefore,
                &p2->pCert->pCertInfo->NotBefore);
        return iCmp;
    } else if (cb1 < cb2)
        return -1;
    else
        return 1;
}

void ArchiveManifoldCertificatesInStore(
    IN PCERT_STORE pStore
    )
{
    PCONTEXT_ELEMENT pEle;
    DWORD cAlloc = 0;
    DWORD cManifold = 0;
    PSORTED_MANIFOLD_ENTRY pManifold = NULL;

    assert(STORE_TYPE_CACHE == pStore->dwStoreType);
    LockStore(pStore);

    // Create an array of non-archived certificates having the Manifold
    // extension
    pEle = pStore->rgpContextListHead[CERT_STORE_CERTIFICATE_CONTEXT - 1];
    for ( ; pEle; pEle = pEle->pNext) {
        PCCERT_CONTEXT pCert;
        PCERT_INFO pCertInfo;
        PCERT_EXTENSION pExt;

        assert(ELEMENT_TYPE_CACHE == pEle->dwElementType ||
            ELEMENT_TYPE_LINK_CONTEXT == pEle->dwElementType);

        // Skip past deleted or archived elements
        if (pEle->dwFlags & (ELEMENT_DELETED_FLAG | ELEMENT_ARCHIVED_FLAG))
            continue;

        pCert = ToCertContext(pEle);
        pCertInfo = pCert->pCertInfo;

        if (pExt = CertFindExtension(
                szOID_CERT_MANIFOLD,
                pCertInfo->cExtension,
                pCertInfo->rgExtension
                )) {
            if (cManifold >= cAlloc) {
                PSORTED_MANIFOLD_ENTRY pNewManifold;

                if (NULL == (pNewManifold = (PSORTED_MANIFOLD_ENTRY) PkiRealloc(
                        pManifold, (cAlloc + SORTED_MANIFOLD_ALLOC_COUNT) *
                            sizeof(SORTED_MANIFOLD_ENTRY))))
                    continue;
                pManifold = pNewManifold;
                cAlloc += SORTED_MANIFOLD_ALLOC_COUNT;
            }
            pManifold[cManifold].pCert =
                CertDuplicateCertificateContext(pCert);
            pManifold[cManifold].Value = pExt->Value;
            cManifold++;
        }
    }

    UnlockStore(pStore);

    if (cManifold) {
        const CRYPT_DATA_BLOB ManifoldBlob = { 0, NULL };

        // Sort the Manifold entries according to manifold value and
        // the certificate's NotAfter and NotBefore times.
        qsort(pManifold, cManifold, sizeof(SORTED_MANIFOLD_ENTRY),
            CompareManifoldEntry);

        // Set the Archive property for previous entries having the same
        // manifold value.
        for (DWORD i = 0; i < cManifold - 1; i++) {
            if (pManifold[i].Value.cbData == pManifold[i+1].Value.cbData &&
                    (0 == pManifold[i].Value.cbData ||
                        0 == memcmp(pManifold[i].Value.pbData,
                            pManifold[i+1].Value.pbData,
                            pManifold[i].Value.cbData)))
                CertSetCertificateContextProperty(
                    pManifold[i].pCert,
                    CERT_ARCHIVED_PROP_ID,
                    CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG,
                    (const void *) &ManifoldBlob
                    );
        }

        while (cManifold--)
            CertFreeCertificateContext(pManifold[cManifold].pCert);

        PkiFree(pManifold);
    }
}

//+-------------------------------------------------------------------------
//  Write the CERT, CRL, CTL, PROP or END element to the file or memory
//
//  Upon entry/exit the store is locked.
//--------------------------------------------------------------------------
STATIC BOOL WriteStoreElement(
    IN HANDLE h,
    IN PFNWRITE pfnWrite,
    IN DWORD dwEncodingType,
    IN DWORD dwEleType,
    IN BYTE *pbData,
    IN DWORD cbData
    )
{
    FILE_ELEMENT_HDR EleHdr;
    BOOL fResult;

    EleHdr.dwEleType = dwEleType;
    EleHdr.dwEncodingType = dwEncodingType;
    EleHdr.dwLen = cbData;
    assert(cbData <= MAX_FILE_ELEMENT_DATA_LEN);
    fResult = pfnWrite(
        h,
        &EleHdr,
        sizeof(EleHdr)
        );
    if (fResult && cbData > 0)
        fResult = pfnWrite(
                h,
                pbData,
                cbData
                );

    return fResult;
}

//+-------------------------------------------------------------------------
//  Serialize the certs, CRLs, CTLs and properties in the store. Prepend with a
//  file header and append with an end element.
//--------------------------------------------------------------------------
STATIC BOOL SerializeStore(
    IN HANDLE h,
    IN PFNWRITE pfnWrite,
    IN PCERT_STORE pStore
    )
{
    BOOL fResult;

    DWORD i;
    FILE_HDR FileHdr;

    FileHdr.dwVersion = CERT_FILE_VERSION_0;
    FileHdr.dwMagic = CERT_MAGIC;
    if (!pfnWrite(h, &FileHdr, sizeof(FileHdr))) goto WriteError;

    for (i = 0; i < CONTEXT_COUNT; i++) {
        PCONTEXT_ELEMENT pEle = NULL;
        while (pEle = FindElementInStore(pStore, i, &FindAnyInfo, pEle)) {
            if (!SerializeStoreElement(h, pfnWrite, pEle)) {
                ReleaseContextElement(pEle);
                goto SerializeError;
            }
        }
    }

    if (!WriteStoreElement(
            h,
            pfnWrite,
            0,                      // dwEncodingType
            FILE_ELEMENT_END_TYPE,
            NULL,                   // pbData
            0                       // cbData
            )) goto WriteError;

    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(WriteError)
TRACE_ERROR(SerializeError)
}


//+-------------------------------------------------------------------------
//  Called by CertStoreSaveEx for CERT_STORE_SAVE_AS_STORE
//--------------------------------------------------------------------------
STATIC BOOL SaveAsStore(
    IN PCERT_STORE pStore,
    IN DWORD dwSaveTo,
    IN OUT void *pvSaveToPara,
    IN DWORD dwFlags
    )
{
    BOOL fResult;

    switch (dwSaveTo) {
        case CERT_STORE_SAVE_TO_FILE:
            fResult = SerializeStore(
                (HANDLE) pvSaveToPara,
                WriteToFile,
                pStore);
            break;
        case CERT_STORE_SAVE_TO_MEMORY:
            {
                PCRYPT_DATA_BLOB pData = (PCRYPT_DATA_BLOB) pvSaveToPara;
                MEMINFO MemInfo;

                MemInfo.pByte = pData->pbData;
                if (NULL == pData->pbData)
                    MemInfo.cb = 0;
                else
                    MemInfo.cb = pData->cbData;
                MemInfo.cbSeek = 0;

                if (fResult = SerializeStore(
                        (HANDLE) &MemInfo,
                        WriteToMemory,
                        pStore)) {
                    if (MemInfo.cbSeek > MemInfo.cb && pData->pbData) {
                        SetLastError((DWORD) ERROR_MORE_DATA);
                        fResult = FALSE;
                    }
                    pData->cbData = MemInfo.cbSeek;
                } else
                    pData->cbData = 0;
            }
            break;
        default:
            SetLastError((DWORD) E_UNEXPECTED);
            fResult = FALSE;
    }
    return fResult;
}

#ifdef CAPI_INCLUDE_PKCS7
//+-------------------------------------------------------------------------
//  Following routines support the SaveAsPKCS7 function
//--------------------------------------------------------------------------

STATIC void FreeSaveAsPKCS7Info(
    IN PCMSG_SIGNED_ENCODE_INFO pInfo,
    IN PCCERT_CONTEXT *ppCert,
    IN PCCRL_CONTEXT *ppCrl
    )
{
    DWORD dwIndex;

    dwIndex = pInfo->cCertEncoded;
    while (dwIndex--)
        CertFreeCertificateContext(ppCert[dwIndex]);
    PkiFree(ppCert);
    PkiFree(pInfo->rgCertEncoded);
    pInfo->cCertEncoded = 0;
    pInfo->rgCertEncoded = NULL;

    dwIndex = pInfo->cCrlEncoded;
    while (dwIndex--)
        CertFreeCRLContext(ppCrl[dwIndex]);
    PkiFree(ppCrl);
    PkiFree(pInfo->rgCrlEncoded);
    pInfo->cCrlEncoded = 0;
    pInfo->rgCrlEncoded = NULL;
}

#define SAVE_AS_PKCS7_ALLOC_COUNT    50

// Upon entry: store is unlocked
STATIC BOOL InitSaveAsPKCS7Info(
    IN PCERT_STORE pStore,
    IN OUT PCMSG_SIGNED_ENCODE_INFO pInfo,
    OUT PCCERT_CONTEXT **pppCert,
    OUT PCCRL_CONTEXT **pppCrl
    )
{
    BOOL fResult;
    DWORD cAlloc;
    DWORD dwIndex;
    PCRYPT_DATA_BLOB pBlob;

    PCCERT_CONTEXT pCert = NULL;
    PCCERT_CONTEXT *ppCert = NULL;
    PCCRL_CONTEXT pCrl = NULL;
    PCCRL_CONTEXT *ppCrl = NULL;

    memset(pInfo, 0, sizeof(CMSG_SIGNED_ENCODE_INFO));
    pInfo->cbSize = sizeof(CMSG_SIGNED_ENCODE_INFO);

    dwIndex = 0;
    cAlloc = 0;
    pBlob = NULL;
    while (pCert = CertEnumCertificatesInStore((HCERTSTORE) pStore, pCert)) {
        if (dwIndex >= cAlloc) {
            PCRYPT_DATA_BLOB pNewBlob;
            PCCERT_CONTEXT *ppNewCert;

            if (NULL == (pNewBlob = (PCRYPT_DATA_BLOB) PkiRealloc(
                    pBlob, (cAlloc + SAVE_AS_PKCS7_ALLOC_COUNT) *
                        sizeof(CRYPT_DATA_BLOB))))
                goto OutOfMemory;
            pBlob = pNewBlob;
            pInfo->rgCertEncoded = pBlob;

            if (NULL == (ppNewCert = (PCCERT_CONTEXT *) PkiRealloc(
                    ppCert, (cAlloc + SAVE_AS_PKCS7_ALLOC_COUNT) *
                        sizeof(PCCERT_CONTEXT))))
                goto OutOfMemory;
            ppCert = ppNewCert;

            cAlloc += SAVE_AS_PKCS7_ALLOC_COUNT;
        }
        ppCert[dwIndex] = CertDuplicateCertificateContext(pCert);
        pBlob[dwIndex].pbData = pCert->pbCertEncoded;
        pBlob[dwIndex].cbData = pCert->cbCertEncoded;
        pInfo->cCertEncoded = ++dwIndex;
    }

    dwIndex = 0;
    cAlloc = 0;
    pBlob = NULL;
    while (pCrl = CertEnumCRLsInStore((HCERTSTORE) pStore, pCrl)) {
        if (dwIndex >= cAlloc) {
            PCRYPT_DATA_BLOB pNewBlob;
            PCCRL_CONTEXT *ppNewCrl;

            if (NULL == (pNewBlob = (PCRYPT_DATA_BLOB) PkiRealloc(
                    pBlob, (cAlloc + SAVE_AS_PKCS7_ALLOC_COUNT) *
                        sizeof(CRYPT_DATA_BLOB))))
                goto OutOfMemory;
            pBlob = pNewBlob;
            pInfo->rgCrlEncoded = pBlob;

            if (NULL == (ppNewCrl = (PCCRL_CONTEXT *) PkiRealloc(
                    ppCrl, (cAlloc + SAVE_AS_PKCS7_ALLOC_COUNT) *
                        sizeof(PCCRL_CONTEXT))))
                goto OutOfMemory;
            ppCrl = ppNewCrl;

            cAlloc += SAVE_AS_PKCS7_ALLOC_COUNT;
        }
        ppCrl[dwIndex] = CertDuplicateCRLContext(pCrl);
        pBlob[dwIndex].pbData = pCrl->pbCrlEncoded;
        pBlob[dwIndex].cbData = pCrl->cbCrlEncoded;
        pInfo->cCrlEncoded = ++dwIndex;
    }

    fResult = TRUE;
CommonReturn:
    *pppCert = ppCert;
    *pppCrl = ppCrl;
    return fResult;
ErrorReturn:
    if (pCert)
        CertFreeCertificateContext(pCert);
    if (pCrl)
        CertFreeCRLContext(pCrl);
    FreeSaveAsPKCS7Info(pInfo, ppCert, ppCrl);
    ppCert = NULL;
    ppCrl = NULL;
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
}

STATIC BOOL EncodePKCS7(
    IN DWORD dwEncodingType,
    IN PCMSG_SIGNED_ENCODE_INFO pInfo,
    OUT BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    BOOL fResult = TRUE;
    DWORD cbEncoded;

    if (NULL == pbEncoded)
        cbEncoded = 0;
    else
        cbEncoded = *pcbEncoded;

    if (0 == cbEncoded)
        cbEncoded = CryptMsgCalculateEncodedLength(
            dwEncodingType,
            0,                      // dwFlags
            CMSG_SIGNED,
            pInfo,
            NULL,                   // pszInnerContentObjID
            0                       // cbData
            );
    else {
        HCRYPTMSG hMsg;
        if (NULL == (hMsg = CryptMsgOpenToEncode(
                dwEncodingType,
                0,                  // dwFlags
                CMSG_SIGNED,
                pInfo,
                NULL,               // pszInnerContentObjID
                NULL                // pStreamInfo
                )))
            cbEncoded = 0;
        else {
            if (CryptMsgUpdate(
                    hMsg,
                    NULL,       // pbData
                    0,          // cbData
                    TRUE        // fFinal
                    ))
                fResult = CryptMsgGetParam(
                    hMsg,
                    CMSG_CONTENT_PARAM,
                    0,              // dwIndex
                    pbEncoded,
                    &cbEncoded);
            else
                cbEncoded = 0;
            CryptMsgClose(hMsg);
        }

    }

    if (fResult) {
        if (0 == cbEncoded)
            fResult = FALSE;
        else if (pbEncoded && cbEncoded > *pcbEncoded) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fResult = FALSE;
        }
    }
    *pcbEncoded = cbEncoded;
    return fResult;
}


//+-------------------------------------------------------------------------
//  Called by CertStoreSaveEx for CERT_STORE_SAVE_AS_PKCS7
//--------------------------------------------------------------------------
STATIC BOOL SaveAsPKCS7(
    IN PCERT_STORE pStore,
    IN DWORD dwEncodingType,
    IN DWORD dwSaveTo,
    IN OUT void *pvSaveToPara,
    IN DWORD dwFlags
    )
{
    BOOL fResult;
    CMSG_SIGNED_ENCODE_INFO SignedEncodeInfo;
    PCCERT_CONTEXT *ppCert;
    PCCRL_CONTEXT *ppCrl;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    if (0 == GET_CERT_ENCODING_TYPE(dwEncodingType) ||
            0 == GET_CMSG_ENCODING_TYPE(dwEncodingType)) {
        SetLastError((DWORD) E_INVALIDARG);
        return FALSE;
    }

    if (!InitSaveAsPKCS7Info(
            pStore,
            &SignedEncodeInfo,
            &ppCert,
            &ppCrl)) goto InitInfoError;

    switch (dwSaveTo) {
        case CERT_STORE_SAVE_TO_FILE:
            if (!EncodePKCS7(
                    dwEncodingType,
                    &SignedEncodeInfo,
                    NULL,               // pbEncoded
                    &cbEncoded)) goto EncodePKCS7Error;
            if (NULL == (pbEncoded = (BYTE *) PkiNonzeroAlloc(cbEncoded)))
                goto OutOfMemory;
            if (!EncodePKCS7(
                    dwEncodingType,
                    &SignedEncodeInfo,
                    pbEncoded,
                    &cbEncoded))
                goto EncodePKCS7Error;
             else {
                DWORD cbBytesWritten;
                if (!WriteFile(
                        (HANDLE) pvSaveToPara,
                        pbEncoded,
                        cbEncoded,
                        &cbBytesWritten,
                        NULL            // lpOverlapped
                        )) goto WriteError;
            }
            break;
        case CERT_STORE_SAVE_TO_MEMORY:
            {
                PCRYPT_DATA_BLOB pData = (PCRYPT_DATA_BLOB) pvSaveToPara;
                if (!EncodePKCS7(
                        dwEncodingType,
                        &SignedEncodeInfo,
                        pData->pbData,
                        &pData->cbData)) goto EncodePKCS7Error;
            }
            break;
        default:
            goto UnexpectedError;
    }

    fResult = TRUE;
CommonReturn:
    FreeSaveAsPKCS7Info(&SignedEncodeInfo, ppCert, ppCrl);
    PkiFree(pbEncoded);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(InitInfoError)
TRACE_ERROR(EncodePKCS7Error)
TRACE_ERROR(WriteError)
TRACE_ERROR(OutOfMemory)
SET_ERROR(UnexpectedError, E_UNEXPECTED)
}
#endif //CAPI_INCLUDE_PKCS7

//+-------------------------------------------------------------------------
//  Save the cert store. Enhanced version with lots of options.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertSaveStore(
    IN HCERTSTORE hCertStore,
    IN DWORD dwEncodingType,
    IN DWORD dwSaveAs,
    IN DWORD dwSaveTo,
    IN OUT void *pvSaveToPara,
    IN DWORD dwFlags
    )
{
    assert(pvSaveToPara);
    switch (dwSaveTo) {
        case CERT_STORE_SAVE_TO_FILENAME_A:
            {
                BOOL fResult;
                LPWSTR pwszFilename;
                if (NULL == (pwszFilename = MkWStr((LPSTR) pvSaveToPara)))
                    return FALSE;
                fResult = CertSaveStore(
                    hCertStore,
                    dwEncodingType,
                    dwSaveAs,
                    CERT_STORE_SAVE_TO_FILENAME_W,
                    (void *) pwszFilename,
                    dwFlags);
                FreeWStr(pwszFilename);
                return fResult;
            }
            break;
        case CERT_STORE_SAVE_TO_FILENAME_W:
#ifndef _XBOX
            {
                BOOL fResult;
                HANDLE hFile;
                if (INVALID_HANDLE_VALUE == (hFile = CreateFileU(
                          (LPWSTR) pvSaveToPara,
                          GENERIC_WRITE,
                          0,                        // fdwShareMode
                          NULL,                     // lpsa
                          CREATE_ALWAYS,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL                      // hTemplateFile
                          )))
                    return FALSE;
                fResult = CertSaveStore(
                    hCertStore,
                    dwEncodingType,
                    dwSaveAs,
                    CERT_STORE_SAVE_TO_FILE,
                    (void *) hFile,
                    dwFlags);
                CloseHandle(hFile);
                return fResult;
            }
            break;
#endif
        case CERT_STORE_SAVE_TO_FILE:
        case CERT_STORE_SAVE_TO_MEMORY:
            break;
        default:
            SetLastError((DWORD) E_INVALIDARG);
            return FALSE;
    }

    switch (dwSaveAs) {
        case CERT_STORE_SAVE_AS_STORE:
            return SaveAsStore(
                (PCERT_STORE) hCertStore,
                dwSaveTo,
                pvSaveToPara,
                dwFlags);
            break;
        case CERT_STORE_SAVE_AS_PKCS7:
#ifdef CAPI_INCLUDE_PKCS7        
            return SaveAsPKCS7(
                (PCERT_STORE) hCertStore,
                dwEncodingType,
                dwSaveTo,
                pvSaveToPara,
                dwFlags);
            break;
#endif    
        default:
            SetLastError((DWORD) E_INVALIDARG);
            return FALSE;
    }
    return FALSE;
}

//+-------------------------------------------------------------------------
//  Loads a serialized certificate, CRL or CTL with properties into a store.
//
//  Also supports decoding of KeyIdentifier properties.
//--------------------------------------------------------------------------
STATIC DWORD LoadStoreElement(
    IN HANDLE h,
    IN PFNREAD pfn,
    IN DWORD cbReadSize,
    IN PCERT_STORE pStore,
    IN DWORD dwAddDisposition,
    IN DWORD dwContextTypeFlags,
    OUT OPTIONAL DWORD *pdwContextType,
    OUT OPTIONAL const void **ppvContext,
    IN BOOL fKeyIdAllowed = FALSE
    )
{
    BYTE *pbEncoded = NULL;
    PCONTEXT_ELEMENT pContextEle = NULL;
    PCONTEXT_ELEMENT pStoreEle = NULL;
    PPROP_ELEMENT pPropHead = NULL;
    FILE_ELEMENT_HDR EleHdr;
    BOOL fIsProp;
    DWORD csStatus;

    do {
        fIsProp = FALSE;

        if (!pfn(
                h,
                &EleHdr,
                sizeof(EleHdr))) goto ReadError;

        if (EleHdr.dwEleType == FILE_ELEMENT_END_TYPE) {
            if (pPropHead != NULL)
                goto PrematureEndError;

            csStatus = CSEnd;
            goto ZeroOutParameterReturn;
        }

        if (EleHdr.dwLen > cbReadSize)
            goto ExceedReadSizeError;

        // EleHdr.dwLen may be 0 for a property
        if (EleHdr.dwLen > 0) {
            if (NULL == (pbEncoded = (BYTE *) PkiNonzeroAlloc(EleHdr.dwLen)))
                goto OutOfMemory;
            if (!pfn(
                    h,
                    pbEncoded,
                    EleHdr.dwLen)) goto ReadError;
        }

        if (EleHdr.dwEleType == FILE_ELEMENT_CERT_TYPE) {
            if (0 == (dwContextTypeFlags &
                    CERT_STORE_CERTIFICATE_CONTEXT_FLAG))
                goto CertNotAllowedError;
            if (NULL == (pContextEle = CreateCertElement(
                    pStore,
                    EleHdr.dwEncodingType,
                    pbEncoded,
                    EleHdr.dwLen))) goto CreateCertElementError;
            pbEncoded = NULL;
            pContextEle->Cache.pPropHead = pPropHead;
            pPropHead = NULL;
            if (!AddElementToStore(pStore, pContextEle, dwAddDisposition,
                    ppvContext ? &pStoreEle : NULL))
                goto AddCertElementToStoreError;
            else
                pContextEle = NULL;

            if (pdwContextType)
                *pdwContextType = CERT_STORE_CERTIFICATE_CONTEXT;
            if (ppvContext)
                *((PCCERT_CONTEXT *) ppvContext) = ToCertContext(pStoreEle);
        } else if (EleHdr.dwEleType == FILE_ELEMENT_CRL_TYPE) {
#ifdef CAPI_INCLUDE_CRL       
            if (0 == (dwContextTypeFlags &
                    CERT_STORE_CRL_CONTEXT_FLAG))
                goto CRLNotAllowedError;
            if (NULL == (pContextEle = CreateCrlElement(
                    pStore,
                    EleHdr.dwEncodingType,
                    pbEncoded,
                    EleHdr.dwLen))) goto CreateCRLElementError;
            pbEncoded = NULL;
            pContextEle->Cache.pPropHead = pPropHead;
            pPropHead = NULL;
            if (!AddElementToStore(pStore, pContextEle, dwAddDisposition,
                    ppvContext ? &pStoreEle : NULL))
                goto AddCRLElementToStoreError;
            else
                pContextEle = NULL;

            if (pdwContextType)
                *pdwContextType = CERT_STORE_CRL_CONTEXT;
            if (ppvContext)
                *((PCCRL_CONTEXT *) ppvContext) = ToCrlContext(pStoreEle);
#else
            PkiFree(pbEncoded);
            pbEncoded = NULL;
#endif	// CAPI_INCLUDE_CRL            
        } else if (EleHdr.dwEleType == FILE_ELEMENT_CTL_TYPE) {
#ifdef CAPI_INCLUDE_CTL       
            if (0 == (dwContextTypeFlags &
                    CERT_STORE_CTL_CONTEXT_FLAG))
                goto CTLNotAllowedError;
            if (NULL == (pContextEle = CreateCtlElement(
                    pStore,
                    EleHdr.dwEncodingType,
                    pbEncoded,
                    EleHdr.dwLen))) goto CreateCTLElementError;
            pbEncoded = NULL;
            pContextEle->Cache.pPropHead = pPropHead;
            pPropHead = NULL;
            if (!AddElementToStore(pStore, pContextEle, dwAddDisposition,
                    ppvContext ? &pStoreEle : NULL))
                goto AddCTLElementToStoreError;
            else
                pContextEle = NULL;

            if (pdwContextType)
                *pdwContextType = CERT_STORE_CTL_CONTEXT;
            if (ppvContext)
                *((PCCTL_CONTEXT *) ppvContext) = ToCtlContext(pStoreEle);
#else
            PkiFree(pbEncoded);
            pbEncoded = NULL;
#endif // CAPI_INCLUDE_CTL
        } else if (EleHdr.dwEleType == FILE_ELEMENT_KEYID_TYPE) {
            PKEYID_ELEMENT pKeyIdEle;

            if (!fKeyIdAllowed)
                goto KeyIdNotAllowedError;
            if (NULL == (pKeyIdEle = CreateKeyIdElement(
                    pbEncoded,
                    EleHdr.dwLen
                    )))
                goto CreateKeyIdElementError;
            pbEncoded = NULL;
            pKeyIdEle->pPropHead = pPropHead;
            pPropHead = NULL;
            assert(ppvContext);
            if (ppvContext)
                *((PKEYID_ELEMENT *) ppvContext) = pKeyIdEle;

        } else if (EleHdr.dwEleType > CERT_LAST_USER_PROP_ID) {
            // Silently discard any IDs exceeding 0xFFFF. The
            // FIRST_USER_PROP_ID used to start at 0x10000.
            fIsProp = TRUE;
            PkiFree(pbEncoded);
            pbEncoded = NULL;
        } else {
            PPROP_ELEMENT pPropEle;

            fIsProp = TRUE;
            if (NULL == (pPropEle = CreatePropElement(
                    EleHdr.dwEleType,
                    0,                  // dwFlags
                    pbEncoded,
                    EleHdr.dwLen
                    ))) goto CreatePropElementError;
            pbEncoded = NULL;
            AddPropElement(&pPropHead, pPropEle);
        }
    } while (fIsProp);

    assert(pPropHead == NULL);
    assert(pbEncoded == NULL);
    assert(pContextEle == NULL);

    csStatus = CSContinue;
CommonReturn:
    return csStatus;
ErrorReturn:
    PkiFree(pbEncoded);
    if (pContextEle)
        FreeContextElement(pContextEle);
    while (pPropHead) {
        PPROP_ELEMENT pEle = pPropHead;
        pPropHead = pPropHead->pNext;
        FreePropElement(pEle);
    }
    csStatus = CSError;
ZeroOutParameterReturn:
    if (pdwContextType)
        *pdwContextType = 0;
    if (ppvContext)
        *ppvContext = NULL;
    goto CommonReturn;

TRACE_ERROR(ReadError)
SET_ERROR(PrematureEndError, CRYPT_E_FILE_ERROR)
SET_ERROR(ExceedReadSizeError, CRYPT_E_FILE_ERROR)
TRACE_ERROR(OutOfMemory)
SET_ERROR(CertNotAllowedError, E_INVALIDARG)
TRACE_ERROR(CreateCertElementError)
TRACE_ERROR(AddCertElementToStoreError)
#ifdef CAPI_INCLUDE_CRL
SET_ERROR(CRLNotAllowedError, E_INVALIDARG)
TRACE_ERROR(CreateCRLElementError)
TRACE_ERROR(AddCRLElementToStoreError)
#endif
#ifdef CAPI_INCLUDE_CTL
SET_ERROR(CTLNotAllowedError, E_INVALIDARG)
TRACE_ERROR(CreateCTLElementError)
TRACE_ERROR(AddCTLElementToStoreError)
#endif
TRACE_ERROR(CreatePropElementError)
SET_ERROR(KeyIdNotAllowedError, E_INVALIDARG)
TRACE_ERROR(CreateKeyIdElementError)
}

//+-------------------------------------------------------------------------
//  Add the serialized certificate, CRL or CTL element to the store.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertAddSerializedElementToStore(
    IN HCERTSTORE hCertStore,
    IN const BYTE *pbElement,
    IN DWORD cbElement,
    IN DWORD dwAddDisposition,
    IN DWORD dwFlags,
    IN DWORD dwContextTypeFlags,
    OUT OPTIONAL DWORD *pdwContextType,
    OUT OPTIONAL const void **ppvContext
    )
{
    MEMINFO MemInfo;
    DWORD csStatus;
    PCERT_STORE pStore =
        hCertStore ? (PCERT_STORE) hCertStore : &NullCertStore;

    MemInfo.pByte = (BYTE*) pbElement;
    MemInfo.cb = cbElement;
    MemInfo.cbSeek = 0;

    csStatus = LoadStoreElement(
        (HANDLE) &MemInfo,
        ReadFromMemory,
        cbElement,
        pStore,
        dwAddDisposition,
        dwContextTypeFlags,
        pdwContextType,
        ppvContext);
    if (CSContinue == csStatus)
        return TRUE;
    else {
        if (CSEnd == csStatus)
            SetLastError((DWORD) CRYPT_E_NOT_FOUND);
        return FALSE;
    }
}


//+=========================================================================
//  Store Control APIs
//==========================================================================

STATIC BOOL EnableAutoResync(
    IN PCERT_STORE pStore
    )
{
    BOOL fResult;
    HANDLE hEvent;

    fResult = TRUE;
    hEvent = NULL;
    LockStore(pStore);
    if (NULL == pStore->hAutoResyncEvent) {
        // Create event to be notified
        if (hEvent = CreateEvent(
                NULL,       // lpsa
                FALSE,      // fManualReset
                FALSE,      // fInitialState
                NULL))      // lpszEventName
            pStore->hAutoResyncEvent = hEvent;
        else
            fResult = FALSE;
    }
    UnlockStore(pStore);
    if (!fResult)
        goto CreateEventError;

    if (hEvent) {
        if (!CertControlStore(
                (HCERTSTORE) pStore,
                0,              // dwFlags
                CERT_STORE_CTRL_NOTIFY_CHANGE,
                &hEvent
                )) {
            DWORD dwErr = GetLastError();

            LockStore(pStore);
            pStore->hAutoResyncEvent = NULL;
            UnlockStore(pStore);
            CloseHandle(hEvent);
            SetLastError(dwErr);
            goto CtrlNotifyChangeError;
        }
    }

CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(CreateEventError)
TRACE_ERROR(CtrlNotifyChangeError)
}

// For a collection, iterates through all the sibling stores. For an error,
// continues on to the remaining stores. LastError is updated with the
// LastError of the first failing store.
STATIC BOOL ControlCollectionStore(
    IN PCERT_STORE pCollection,
    IN DWORD dwFlags,
    IN DWORD dwCtrlType,
    IN void const *pvCtrlPara
    )
{
    BOOL fResult = TRUE;
    BOOL fOneSiblingSuccess = FALSE;
    DWORD dwError = ERROR_CALL_NOT_IMPLEMENTED;

    PCERT_STORE_LINK pStoreLink;
    PCERT_STORE_LINK pPrevStoreLink = NULL;

    // Iterate through all the siblings and call the control function
    LockStore(pCollection);
    pStoreLink = pCollection->pStoreListHead;
    for (; pStoreLink; pStoreLink = pStoreLink->pNext) {
        // Advance past deleted store link
        if (pStoreLink->dwFlags & STORE_LINK_DELETED_FLAG)
            continue;

        AddRefStoreLink(pStoreLink);
        UnlockStore(pCollection);
        if (pPrevStoreLink)
            ReleaseStoreLink(pPrevStoreLink);
        pPrevStoreLink = pStoreLink;

        if (CertControlStore(
                (HCERTSTORE) pStoreLink->pSibling,
                dwFlags,
                dwCtrlType,
                pvCtrlPara
                )) {
            fOneSiblingSuccess = TRUE;
            if (ERROR_CALL_NOT_IMPLEMENTED == dwError)
                fResult = TRUE;
        } else if (ERROR_CALL_NOT_IMPLEMENTED == dwError) {
            dwError = GetLastError();
            if (!fOneSiblingSuccess || ERROR_CALL_NOT_IMPLEMENTED != dwError)
                fResult = FALSE;
        }

        LockStore(pCollection);
    }
    UnlockStore(pCollection);

    if (pPrevStoreLink)
        ReleaseStoreLink(pPrevStoreLink);
    if (!fResult)
        SetLastError(dwError);
    return fResult;
}

BOOL
WINAPI
CertControlStore(
    IN HCERTSTORE hCertStore,
    IN DWORD dwFlags,
    IN DWORD dwCtrlType,
    IN void const *pvCtrlPara
    )
{
    BOOL fResult;
    PCERT_STORE pStore = (PCERT_STORE) hCertStore;
    PFN_CERT_STORE_PROV_CONTROL pfnStoreProvControl;

    if (CERT_STORE_CTRL_AUTO_RESYNC == dwCtrlType)
        return EnableAutoResync(pStore);

    if (STORE_TYPE_COLLECTION == pStore->dwStoreType)
        return ControlCollectionStore(
            pStore,
            dwFlags,
            dwCtrlType,
            pvCtrlPara
            );

    // Check if the store supports the control callback
    if (pStore->StoreProvInfo.cStoreProvFunc <=
            CERT_STORE_PROV_CONTROL_FUNC  ||
        NULL == (pfnStoreProvControl = (PFN_CERT_STORE_PROV_CONTROL)
            pStore->StoreProvInfo.rgpvStoreProvFunc[
                CERT_STORE_PROV_CONTROL_FUNC]))
        goto ProvControlNotSupported;

    // The caller is holding a reference count on the store.
    if (!pfnStoreProvControl(
            pStore->StoreProvInfo.hStoreProv,
            dwFlags,
            dwCtrlType,
            pvCtrlPara
            ))
        goto StoreProvControlError;

    fResult = TRUE;

CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(ProvControlNotSupported, ERROR_CALL_NOT_IMPLEMENTED)
TRACE_ERROR(StoreProvControlError)
}

//+=========================================================================
//  Store Collection APIs
//==========================================================================

BOOL
WINAPI
CertAddStoreToCollection(
    IN HCERTSTORE hCollectionStore,
    IN OPTIONAL HCERTSTORE hSiblingStore,
    IN DWORD dwUpdateFlags,
    IN DWORD dwPriority
    )
{
    BOOL fResult;
    PCERT_STORE pCollection = (PCERT_STORE) hCollectionStore;
    PCERT_STORE pSibling = (PCERT_STORE) hSiblingStore;

    PCERT_STORE_LINK pAddLink = NULL;

    LockStore(pCollection);
    if (STORE_TYPE_COLLECTION == pCollection->dwStoreType)
        fResult = TRUE;
    else if (STORE_TYPE_CACHE == pCollection->dwStoreType &&
            STORE_STATE_OPENING == pCollection->dwState &&
            IsEmptyStore(pCollection)) {
        pCollection->dwStoreType = STORE_TYPE_COLLECTION;
        fResult = TRUE;
    } else
        fResult = FALSE;
    UnlockStore(pCollection);
    if (!fResult)
        goto InvalidCollectionStore;
    if (NULL == hSiblingStore)
        goto CommonReturn;

    // Create a link to the store to be added. It duplicates pSibling.
    if (NULL == (pAddLink = CreateStoreLink(
            pCollection,
            pSibling,
            dwUpdateFlags,
            dwPriority)))
        goto CreateStoreLinkError;

    LockStore(pCollection);

    if (NULL == pCollection->pStoreListHead)
        pCollection->pStoreListHead = pAddLink;
    else {
        PCERT_STORE_LINK pLink;

        pLink = pCollection->pStoreListHead;
        if (dwPriority > pLink->dwPriority) {
            // Insert at beginning before first link
            pAddLink->pNext = pLink;
            pLink->pPrev = pAddLink;
            pCollection->pStoreListHead = pAddLink;
        } else {
            // Insert after the link whose next link has
            // lower priority or insert after the last link
            while (pLink->pNext && dwPriority <= pLink->pNext->dwPriority)
                pLink = pLink->pNext;

            pAddLink->pPrev = pLink;
            pAddLink->pNext = pLink->pNext;
            if (pLink->pNext)
                pLink->pNext->pPrev = pAddLink;
            pLink->pNext = pAddLink;
        }
    }

    UnlockStore(pCollection);
    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidCollectionStore, E_INVALIDARG)
TRACE_ERROR(CreateStoreLinkError)
}

void
WINAPI
CertRemoveStoreFromCollection(
    IN HCERTSTORE hCollectionStore,
    IN HCERTSTORE hSiblingStore
    )
{
    PCERT_STORE pCollection = (PCERT_STORE) hCollectionStore;
    PCERT_STORE pSibling = (PCERT_STORE) hSiblingStore;
    PCERT_STORE_LINK pLink;

    LockStore(pCollection);
    assert(STORE_TYPE_COLLECTION == pCollection->dwStoreType);
    pLink = pCollection->pStoreListHead;
    for (; pLink; pLink = pLink->pNext) {
        if (pSibling == pLink->pSibling &&
                0 == (pLink->dwFlags & STORE_LINK_DELETED_FLAG)) {
            // Remove the collection's reference
            pLink->dwFlags |= STORE_LINK_DELETED_FLAG;

            UnlockStore(pCollection);
            ReleaseStoreLink(pLink);
            return;
        }
    }

    UnlockStore(pCollection);
}

//+=========================================================================
//  Cert Store Property Functions
//==========================================================================

//+-------------------------------------------------------------------------
//  Set a store property.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertSetStoreProperty(
    IN HCERTSTORE hCertStore,
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN const void *pvData
    )
{
    BOOL fResult;
    PCERT_STORE pStore = (PCERT_STORE) hCertStore;

    LockStore(pStore);

    fResult = SetCallerProperty(
        &pStore->pPropHead,
        dwPropId,
        dwFlags,
        pvData
        );

    UnlockStore(pStore);
    return fResult;
}


//+-------------------------------------------------------------------------
//  Get a store property.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertGetStoreProperty(
    IN HCERTSTORE hCertStore,
    IN DWORD dwPropId,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    )
{
    BOOL fResult;
    PCERT_STORE pStore = (PCERT_STORE) hCertStore;

    if (dwPropId == CERT_ACCESS_STATE_PROP_ID) {
        DWORD dwAccessStateFlags;
        DWORD cbIn;

        dwAccessStateFlags = 0;
        if (0 == (pStore->dwFlags & CERT_STORE_READONLY_FLAG) &&
                0 == (pStore->StoreProvInfo.dwStoreProvFlags &
                     CERT_STORE_PROV_NO_PERSIST_FLAG))
        {
            if (STORE_TYPE_COLLECTION == pStore->dwStoreType) {
                // If all its children are READONLY, then NO WRITE_PERSIST

                PCERT_STORE_LINK pStoreLink;
                PCERT_STORE_LINK pPrevStoreLink = NULL;
                LockStore(pStore);
                for (pStoreLink = pStore->pStoreListHead;
                                pStoreLink; pStoreLink = pStoreLink->pNext) {

                    DWORD dwSiblingAccessStateFlags;
                    DWORD cbSiblingData;

                    // Advance past deleted store link
                    if (pStoreLink->dwFlags & STORE_LINK_DELETED_FLAG)
                        continue;

                    AddRefStoreLink(pStoreLink);
                    UnlockStore(pStore);
                    if (pPrevStoreLink)
                        ReleaseStoreLink(pPrevStoreLink);
                    pPrevStoreLink = pStoreLink;

                    dwSiblingAccessStateFlags = 0;
                    cbSiblingData = sizeof(dwSiblingAccessStateFlags);
                    CertGetStoreProperty(
                        (HCERTSTORE) pStoreLink->pSibling,
                        CERT_ACCESS_STATE_PROP_ID,
                        &dwSiblingAccessStateFlags,
                        &cbSiblingData
                        );
                    LockStore(pStore);

                    if (dwSiblingAccessStateFlags &
                            CERT_ACCESS_STATE_WRITE_PERSIST_FLAG) {
                        dwAccessStateFlags =
                            CERT_ACCESS_STATE_WRITE_PERSIST_FLAG;
                        break;
                    }
                }
                UnlockStore(pStore);
                if (pPrevStoreLink)
                    ReleaseStoreLink(pPrevStoreLink);
            } else
                dwAccessStateFlags = CERT_ACCESS_STATE_WRITE_PERSIST_FLAG;
        }

        if (pStore->StoreProvInfo.dwStoreProvFlags &
                CERT_STORE_PROV_SYSTEM_STORE_FLAG)
            dwAccessStateFlags |= CERT_ACCESS_STATE_SYSTEM_STORE_FLAG;

        fResult = TRUE;
        if (pvData == NULL)
            cbIn = 0;
        else
            cbIn = *pcbData;
        if (cbIn < sizeof(DWORD)) {
            if (pvData) {
                SetLastError((DWORD) ERROR_MORE_DATA);
                fResult = FALSE;
            }
        } else
            *((DWORD * ) pvData) = dwAccessStateFlags;
        *pcbData = sizeof(DWORD);
        return fResult;
    }

    LockStore(pStore);

    fResult = GetCallerProperty(
        pStore->pPropHead,
        dwPropId,
        FALSE,                  // fAlloc
        pvData,
        pcbData
        );

    UnlockStore(pStore);
    return fResult;
}

//+=========================================================================
//  Certificate APIs
//==========================================================================

BOOL
WINAPI
CertAddEncodedCertificateToStore(
    IN HCERTSTORE hCertStore,
    IN DWORD dwCertEncodingType,
    IN const BYTE *pbCertEncoded,
    IN DWORD cbCertEncoded,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCCERT_CONTEXT *ppCertContext
    )
{
    BOOL fResult;
    PCONTEXT_ELEMENT pStoreEle;
    fResult = AddEncodedContextToStore(
        (PCERT_STORE) hCertStore,
        CERT_STORE_CERTIFICATE_CONTEXT - 1,
        dwCertEncodingType,
        pbCertEncoded,
        cbCertEncoded,
        dwAddDisposition,
        ppCertContext ? &pStoreEle : NULL
        );
    if (ppCertContext)
        *ppCertContext = ToCertContext(pStoreEle);
    return fResult;
}

BOOL
WINAPI
CertAddCertificateContextToStore(
    IN HCERTSTORE hCertStore,
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCCERT_CONTEXT *ppStoreContext
    )
{
    BOOL fResult;
    PCONTEXT_ELEMENT pStoreEle;

    fResult = AddContextToStore(
        (PCERT_STORE) hCertStore,
        ToContextElement(pCertContext),
        pCertContext->dwCertEncodingType,
        pCertContext->pbCertEncoded,
        pCertContext->cbCertEncoded,
        dwAddDisposition,
        ppStoreContext ? &pStoreEle : NULL
        );
    if (ppStoreContext)
        *ppStoreContext = ToCertContext(pStoreEle);
    return fResult;
}

BOOL
WINAPI
CertAddCertificateLinkToStore(
    IN HCERTSTORE hCertStore,
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCCERT_CONTEXT *ppStoreContext
    )
{
    BOOL fResult;
    PCONTEXT_ELEMENT pStoreEle;

    fResult = AddLinkContextToCacheStore(
        (PCERT_STORE) hCertStore,
        ToContextElement(pCertContext),
        dwAddDisposition,
        ppStoreContext ? &pStoreEle : NULL
        );
    if (ppStoreContext)
        *ppStoreContext = ToCertContext(pStoreEle);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Serialize the certificate context's encoded certificate and its
//  properties.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertSerializeCertificateStoreElement(
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwFlags,
    OUT BYTE *pbElement,
    IN OUT DWORD *pcbElement
    )
{
    return SerializeContextElement(
        ToContextElement(pCertContext),
        dwFlags,
        pbElement,
        pcbElement
        );
}

//+-------------------------------------------------------------------------
//  Delete the specified certificate from the store.
//
//  All subsequent gets or finds for the certificate will fail. However,
//  memory allocated for the certificate isn't freed until all of its contexts
//  have also been freed.
//
//  The pCertContext is obtained from a get, find or duplicate.
//
//  Some store provider implementations might also delete the issuer's CRLs
//  if this is the last certificate for the issuer in the store.
//
//  NOTE: the pCertContext is always CertFreeCertificateContext'ed by
//  this function, even for an error.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertDeleteCertificateFromStore(
    IN PCCERT_CONTEXT pCertContext
    )
{
    assert(NULL == pCertContext || (CERT_STORE_CERTIFICATE_CONTEXT - 1) ==
        ToContextElement(pCertContext)->dwContextType);
    return DeleteContextElement(ToContextElement(pCertContext));
}

//+-------------------------------------------------------------------------
//  Get the subject certificate context uniquely identified by its Issuer and
//  SerialNumber from the store.
//
//  If the certificate isn't found, NULL is returned. Otherwise, a pointer to
//  a read only CERT_CONTEXT is returned. CERT_CONTEXT must be freed by calling
//  CertFreeCertificateContext. CertDuplicateCertificateContext can be called to make a
//  duplicate.
//
//  The returned certificate might not be valid. Normally, it would be
//  verified when getting its issuer certificate (CertGetIssuerCertificateFromStore).
//--------------------------------------------------------------------------
PCCERT_CONTEXT
WINAPI
CertGetSubjectCertificateFromStore(
    IN HCERTSTORE hCertStore,
    IN DWORD dwCertEncodingType,
    IN PCERT_INFO pCertId           // Only the Issuer and SerialNumber
                                    // fields are used
    )
{
    CERT_STORE_PROV_FIND_INFO FindInfo;

    if (pCertId == NULL) {
        SetLastError((DWORD) E_INVALIDARG);
        return NULL;
    }

    FindInfo.cbSize = sizeof(FindInfo);
    FindInfo.dwMsgAndCertEncodingType = dwCertEncodingType,
    FindInfo.dwFindFlags = 0;
    FindInfo.dwFindType = CERT_FIND_SUBJECT_CERT;
    FindInfo.pvFindPara = pCertId;

    return ToCertContext(CheckAutoResyncAndFindElementInStore(
        (PCERT_STORE) hCertStore,
        CERT_STORE_CERTIFICATE_CONTEXT - 1,
        &FindInfo,
        NULL                                // pPrevEle
        ));
}

//+-------------------------------------------------------------------------
//  Enumerate the certificate contexts in the store.
//
//  If a certificate isn't found, NULL is returned.
//  Otherwise, a pointer to a read only CERT_CONTEXT is returned. CERT_CONTEXT
//  must be freed by calling CertFreeCertificateContext or is freed when passed as the
//  pPrevCertContext on a subsequent call. CertDuplicateCertificateContext
//  can be called to make a duplicate.
//
//  pPrevCertContext MUST BE NULL to enumerate the first
//  certificate in the store. Successive certificates are enumerated by setting
//  pPrevCertContext to the CERT_CONTEXT returned by a previous call.
//
//  NOTE: a NON-NULL pPrevCertContext is always CertFreeCertificateContext'ed by
//  this function, even for an error.
//--------------------------------------------------------------------------
PCCERT_CONTEXT
WINAPI
CertEnumCertificatesInStore(
    IN HCERTSTORE hCertStore,
    IN PCCERT_CONTEXT pPrevCertContext
    )
{
    return ToCertContext(CheckAutoResyncAndFindElementInStore(
        (PCERT_STORE) hCertStore,
        CERT_STORE_CERTIFICATE_CONTEXT - 1,
        &FindAnyInfo,
        ToContextElement(pPrevCertContext)
        ));
}

//+-------------------------------------------------------------------------
//  Find the first or next certificate context in the store.
//
//  The certificate is found according to the dwFindType and its pvFindPara.
//  See below for a list of the find types and its parameters.
//
//  Currently dwFindFlags is only used for CERT_FIND_SUBJECT_ATTR or
//  CERT_FIND_ISSUER_ATTR. Otherwise, must be set to 0.
//
//  Usage of dwCertEncodingType depends on the dwFindType.
//
//  If the first or next certificate isn't found, NULL is returned.
//  Otherwise, a pointer to a read only CERT_CONTEXT is returned. CERT_CONTEXT
//  must be freed by calling CertFreeCertificateContext or is freed when passed as the
//  pPrevCertContext on a subsequent call. CertDuplicateCertificateContext
//  can be called to make a duplicate.
//
//  pPrevCertContext MUST BE NULL on the first
//  call to find the certificate. To find the next certificate, the
//  pPrevCertContext is set to the CERT_CONTEXT returned by a previous call.
//
//  NOTE: a NON-NULL pPrevCertContext is always CertFreeCertificateContext'ed by
//  this function, even for an error.
//--------------------------------------------------------------------------
PCCERT_CONTEXT
WINAPI
CertFindCertificateInStore(
    IN HCERTSTORE hCertStore,
    IN DWORD dwCertEncodingType,
    IN DWORD dwFindFlags,
    IN DWORD dwFindType,
    IN const void *pvFindPara,
    IN PCCERT_CONTEXT pPrevCertContext
    )
{
    CERT_STORE_PROV_FIND_INFO FindInfo;

    FindInfo.cbSize = sizeof(FindInfo);
    FindInfo.dwMsgAndCertEncodingType = dwCertEncodingType;
    FindInfo.dwFindFlags = dwFindFlags;
    FindInfo.dwFindType = dwFindType;
    FindInfo.pvFindPara = pvFindPara;

    return ToCertContext(CheckAutoResyncAndFindElementInStore(
        (PCERT_STORE) hCertStore,
        CERT_STORE_CERTIFICATE_CONTEXT - 1,
        &FindInfo,
        ToContextElement(pPrevCertContext)
        ));
}

#ifdef CAPI_INCLUDE_CRL
//+-------------------------------------------------------------------------
//  Perform the revocation check on the subject certificate
//  using the issuer certificate and store
//--------------------------------------------------------------------------
STATIC void VerifySubjectCertRevocation(
    IN PCCERT_CONTEXT pSubject,
    IN PCCERT_CONTEXT pIssuer,
    IN HCERTSTORE hIssuerStore,
    IN OUT DWORD *pdwFlags
    )
{

    PCCRL_CONTEXT rgpCrlContext[MAX_CRL_LIST];
    PCRL_INFO rgpCrlInfo[MAX_CRL_LIST];
    PCCRL_CONTEXT pCrlContext = NULL;
    DWORD cCrl = 0;

    assert(pIssuer && hIssuerStore);
    assert(*pdwFlags & CERT_STORE_REVOCATION_FLAG);

    while (TRUE) {
        DWORD dwFlags = CERT_STORE_SIGNATURE_FLAG;
        pCrlContext = CertGetCRLFromStore(
            hIssuerStore,
            pIssuer,
            pCrlContext,
            &dwFlags
            );

        if (pCrlContext == NULL) break;
        if (cCrl == MAX_CRL_LIST) {
            // BUGBUG what needs to be done ???? Error Logging ????
            assert(cCrl > MAX_CRL_LIST);
            CertFreeCRLContext(pCrlContext);
            break;
        }

        if (dwFlags == 0) {
            rgpCrlContext[cCrl] = CertDuplicateCRLContext(pCrlContext);
            rgpCrlInfo[cCrl] = pCrlContext->pCrlInfo;
            cCrl++;
        } else {
            // Need to log or remove a bad CRL from the store
            ;
        }
    }
    if (cCrl == 0)
        *pdwFlags |= CERT_STORE_NO_CRL_FLAG;
    else {
        if (CertVerifyCRLRevocation(
                pSubject->dwCertEncodingType,
                pSubject->pCertInfo,
                cCrl,
                rgpCrlInfo
                ))
            *pdwFlags &= ~CERT_STORE_REVOCATION_FLAG;

        while (cCrl--)
            CertFreeCRLContext(rgpCrlContext[cCrl]);
    }
}

#endif	//CAPI_INCLUDE_CRL

#ifdef CMS_PKCS7
//+-------------------------------------------------------------------------
//  If the verify certificate signature fails with CRYPT_E_MISSING_PUBKEY_PARA,
//  build a certificate chain. Retry. Hopefully, the issuer's
//  CERT_PUBKEY_ALG_PARA_PROP_ID property gets set while building the chain.
//--------------------------------------------------------------------------
STATIC BOOL VerifyCertificateSignatureWithChainPubKeyParaInheritance(
    IN HCRYPTPROV   hCryptProv,
    IN DWORD        dwCertEncodingType,
    IN DWORD        dwSubjectType,
    IN void         *pvSubject,
    IN PCCERT_CONTEXT pIssuer
    );
#endif  // CMS_PKCS7

//+-------------------------------------------------------------------------
//  Perform the enabled verification checks on the subject certificate
//  using the issuer
//--------------------------------------------------------------------------
STATIC void VerifySubjectCert(
    IN PCCERT_CONTEXT pSubject,
    IN OPTIONAL PCCERT_CONTEXT pIssuer,
    IN OUT DWORD *pdwFlags
    )
{
    if (*pdwFlags & CERT_STORE_TIME_VALIDITY_FLAG) {
        if (CertVerifyTimeValidity(NULL,
                pSubject->pCertInfo) == 0)
            *pdwFlags &= ~CERT_STORE_TIME_VALIDITY_FLAG;
    }

    if (pIssuer == NULL) {
        if (*pdwFlags & (CERT_STORE_SIGNATURE_FLAG |
                         CERT_STORE_REVOCATION_FLAG))
            *pdwFlags |= CERT_STORE_NO_ISSUER_FLAG;
        return;
    }

    if (*pdwFlags & CERT_STORE_SIGNATURE_FLAG) {
        PCERT_STORE pStore = (PCERT_STORE) pIssuer->hCertStore;
        HCRYPTPROV hProv;
        DWORD dwProvFlags;

        // Attempt to get the store's crypt provider. Serialize crypto
        // operations by entering critical section.
        hProv = GetCryptProv(pStore, &dwProvFlags);
#if 0
        // Slow down the provider while holding the provider reference
        // count
        Sleep(1700);
#endif

#ifdef CMS_PKCS7
        if (VerifyCertificateSignatureWithChainPubKeyParaInheritance(
                hProv,
                pSubject->dwCertEncodingType,
                CRYPT_VERIFY_CERT_SIGN_SUBJECT_CERT,
                (void *) pSubject,
                pIssuer
                ))
#else
        if (CryptVerifyCertificateSignature(
                hProv,
                pSubject->dwCertEncodingType,
                pSubject->pbCertEncoded,
                pSubject->cbCertEncoded,
                &pIssuer->pCertInfo->SubjectPublicKeyInfo
                ))
#endif  // CMS_PKCS7
            *pdwFlags &= ~CERT_STORE_SIGNATURE_FLAG;

        // For the store's crypt provider, release reference count. Leave
        // crypto operations critical section.
        ReleaseCryptProv(pStore, dwProvFlags);
    }


    if (*pdwFlags & CERT_STORE_REVOCATION_FLAG) {
#ifdef CAPI_INCLUDE_CRL   
        *pdwFlags &= ~CERT_STORE_NO_CRL_FLAG;

        VerifySubjectCertRevocation(
            pSubject,
            pIssuer,
            pIssuer->hCertStore,
            pdwFlags
            );

        if (*pdwFlags & CERT_STORE_NO_CRL_FLAG) {
            PCONTEXT_ELEMENT pIssuerEle = ToContextElement(pIssuer);

            if (ELEMENT_TYPE_LINK_CONTEXT == pIssuerEle->dwElementType) {
                // Skip past the link elements. A store containing a link
                // may not have any CRLs. Try the store containing the
                // real issuer element.

                DWORD dwInnerDepth = 0;
                for ( ; ELEMENT_TYPE_LINK_CONTEXT ==
                             pIssuerEle->dwElementType;
                                            pIssuerEle = pIssuerEle->pEle) {
                    dwInnerDepth++;
                    assert(dwInnerDepth <= MAX_LINK_DEPTH);
                    assert(pIssuerEle != pIssuerEle->pEle);
                    if (dwInnerDepth > MAX_LINK_DEPTH)
                        break;
                }
                if ((HCERTSTORE) pIssuerEle->pStore != pIssuer->hCertStore) {
                    *pdwFlags &= ~CERT_STORE_NO_CRL_FLAG;
                    VerifySubjectCertRevocation(
                        pSubject,
                        pIssuer,
                        (HCERTSTORE) pIssuerEle->pStore,
                        pdwFlags
                        );
                }
            }
        }
#else
		*pdwFlags |= CERT_STORE_NO_CRL_FLAG;	//CRL checking not enabled
#endif // CAPI_INCLUDE_CRL
    }
}

//+-------------------------------------------------------------------------
//  Get the certificate context from the store for the first or next issuer
//  of the specified subject certificate. Perform the enabled
//  verification checks on the subject. (Note, the checks are on the subject
//  using the returned issuer certificate.)
//
//  If the first or next issuer certificate isn't found, NULL is returned.
//  Otherwise, a pointer to a read only CERT_CONTEXT is returned. CERT_CONTEXT
//  must be freed by calling CertFreeCertificateContext or is freed when passed as the
//  pPrevIssuerContext on a subsequent call. CertDuplicateCertificateContext
//  can be called to make a duplicate.
//
//  The pSubjectContext may have been obtained from this store, another store
//  or created by the caller application. When created by the caller, the
//  CertCreateCertificateContext function must have been called.
//
//  An issuer may have multiple certificates. This may occur when the validity
//  period is about to change. pPrevIssuerContext MUST BE NULL on the first
//  call to get the issuer. To get the next certificate for the issuer, the
//  pPrevIssuerContext is set to the CERT_CONTEXT returned by a previous call.
//
//  NOTE: a NON-NULL pPrevIssuerContext is always CertFreeCertificateContext'ed by
//  this function, even for an error.
//
//  The following flags can be set in *pdwFlags to enable verification checks
//  on the subject certificate context:
//      CERT_STORE_SIGNATURE_FLAG     - use the public key in the returned
//                                      issuer certificate to verify the
//                                      signature on the subject certificate.
//                                      Note, if pSubjectContext->hCertStore ==
//                                      hCertStore, the store provider might
//                                      be able to eliminate a redo of
//                                      the signature verify.
//      CERT_STORE_TIME_VALIDITY_FLAG - get the current time and verify that
//                                      its within the subject certificate's
//                                      validity period
//      CERT_STORE_REVOCATION_FLAG    - check if the subject certificate is on
//                                      the issuer's revocation list
//
//  If an enabled verification check fails, then, its flag is set upon return.
//  If CERT_STORE_REVOCATION_FLAG was enabled and the issuer doesn't have a
//  CRL in the store, then, CERT_STORE_NO_CRL_FLAG is set in addition to
//  the CERT_STORE_REVOCATION_FLAG.
//
//  If CERT_STORE_SIGNATURE_FLAG or CERT_STORE_REVOCATION_FLAG is set, then,
//  CERT_STORE_NO_ISSUER_FLAG is set if it doesn't have an issuer certificate
//  in the store.
//
//  For a verification check failure, a pointer to the issuer's CERT_CONTEXT
//  is still returned and SetLastError isn't updated.
//--------------------------------------------------------------------------
PCCERT_CONTEXT
WINAPI
CertGetIssuerCertificateFromStore(
    IN HCERTSTORE hCertStore,
    IN PCCERT_CONTEXT pSubjectContext,
    IN OPTIONAL PCCERT_CONTEXT pPrevIssuerContext,
    IN OUT DWORD *pdwFlags
    )
{
    PCCERT_CONTEXT pIssuerContext;

    if (*pdwFlags & ~(CERT_STORE_SIGNATURE_FLAG |
                      CERT_STORE_TIME_VALIDITY_FLAG |
                      CERT_STORE_REVOCATION_FLAG))
        goto InvalidArg;

    // Check if self signed certificate, issuer == subject
    if (CertCompareCertificateName(
            pSubjectContext->dwCertEncodingType,
            &pSubjectContext->pCertInfo->Subject,
            &pSubjectContext->pCertInfo->Issuer
            )) {
        VerifySubjectCert(
            pSubjectContext,
            pSubjectContext,
            pdwFlags
            );
        SetLastError((DWORD) CRYPT_E_SELF_SIGNED);
        goto ErrorReturn;
    } else {
        CERT_STORE_PROV_FIND_INFO FindInfo;
        FindInfo.cbSize = sizeof(FindInfo);
        FindInfo.dwMsgAndCertEncodingType = pSubjectContext->dwCertEncodingType;
        FindInfo.dwFindFlags = 0;
        FindInfo.dwFindType = CERT_FIND_ISSUER_OF;
        FindInfo.pvFindPara = pSubjectContext;

        if (pIssuerContext = ToCertContext(CheckAutoResyncAndFindElementInStore(
                (PCERT_STORE) hCertStore,
                CERT_STORE_CERTIFICATE_CONTEXT - 1,
                &FindInfo,
                ToContextElement(pPrevIssuerContext)
                )))
            VerifySubjectCert(
                pSubjectContext,
                pIssuerContext,
                pdwFlags
                );
    }

CommonReturn:
    return pIssuerContext;

ErrorReturn:
    if (pPrevIssuerContext)
        CertFreeCertificateContext(pPrevIssuerContext);
    pIssuerContext = NULL;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
}

//+-------------------------------------------------------------------------
//  Perform the enabled verification checks on the subject certificate
//  using the issuer. Same checks and flags definitions as for the above
//  CertGetIssuerCertificateFromStore.
//
//  For a verification check failure, SUCCESS is still returned.
//
//  pIssuer must come from a store that is still open.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertVerifySubjectCertificateContext(
    IN PCCERT_CONTEXT pSubject,
    IN OPTIONAL PCCERT_CONTEXT pIssuer,
    IN OUT DWORD *pdwFlags
    )
{
    if (*pdwFlags & ~(CERT_STORE_SIGNATURE_FLAG |
                      CERT_STORE_TIME_VALIDITY_FLAG |
                      CERT_STORE_REVOCATION_FLAG)) {
        SetLastError((DWORD) E_INVALIDARG);
        return FALSE;
    }
    if (*pdwFlags & (CERT_STORE_SIGNATURE_FLAG | CERT_STORE_REVOCATION_FLAG)) {
        if (pIssuer == NULL) {
            SetLastError((DWORD) E_INVALIDARG);
            return FALSE;
        }
    }

    VerifySubjectCert(
        pSubject,
        pIssuer,
        pdwFlags
        );
    return TRUE;
}

//+-------------------------------------------------------------------------
//  Duplicate a certificate context
//--------------------------------------------------------------------------
PCCERT_CONTEXT
WINAPI
CertDuplicateCertificateContext(
    IN PCCERT_CONTEXT pCertContext
    )
{
    if (pCertContext)
        AddRefContextElement(ToContextElement(pCertContext));
    return pCertContext;
}

//+-------------------------------------------------------------------------
//  Create a certificate context from the encoded certificate. The created
//  context isn't put in a store.
//
//  Makes a copy of the encoded certificate in the created context.
//
//  If unable to decode and create the certificate context, NULL is returned.
//  Otherwise, a pointer to a read only CERT_CONTEXT is returned.
//  CERT_CONTEXT must be freed by calling CertFreeCertificateContext.
//  CertDuplicateCertificateContext can be called to make a duplicate.
//
//  CertSetCertificateContextProperty and CertGetCertificateContextProperty can be called
//  to store properties for the certificate.
//--------------------------------------------------------------------------
PCCERT_CONTEXT
WINAPI
CertCreateCertificateContext(
    IN DWORD dwCertEncodingType,
    IN const BYTE *pbCertEncoded,
    IN DWORD cbCertEncoded
    )
{
    PCCERT_CONTEXT pCertContext;

    CertAddEncodedCertificateToStore(
        NULL,                   // hCertStore
        dwCertEncodingType,
        pbCertEncoded,
        cbCertEncoded,
        CERT_STORE_ADD_ALWAYS,
        &pCertContext
        );
    return pCertContext;
}

//+-------------------------------------------------------------------------
//  Free a certificate context
//
//  There needs to be a corresponding free for each context obtained by a
//  get, find, duplicate or create.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertFreeCertificateContext(
    IN PCCERT_CONTEXT pCertContext
    )
{
    ReleaseContextElement(ToContextElement(pCertContext));
    return TRUE;
}

//+-------------------------------------------------------------------------
//  Set the property for the specified certificate context.
//
//  If the certificate context was obtained from a store, then, the property
//  is added to the store.
//
//  The type definition for pvData depends on the dwPropId value. There are
//  three predefined types:
//      CERT_KEY_PROV_HANDLE_PROP_ID - a HCRYPTPROV for the certificate's
//      private key is passed in pvData. If the
//      CERT_STORE_NO_CRYPT_RELEASE_FLAG isn't set, HCRYPTPROV is implicitly
//      released when either the property is set to NULL or on the final
//      free of the CertContext.
//
//      CERT_KEY_PROV_INFO_PROP_ID - a PCRYPT_KEY_PROV_INFO for the certificate's
//      private key is passed in pvData.
//
//      CERT_SHA1_HASH_PROP_ID       -
//      CERT_MD5_HASH_PROP_ID        -
//      CERT_SIGNATURE_HASH_PROP_ID  - normally, a hash property is implicitly
//      set by doing a CertGetCertificateContextProperty. pvData points to a
//      CRYPT_HASH_BLOB.
//
//  For all the other PROP_IDs: an encoded PCRYPT_DATA_BLOB is passed in pvData.
//
//  If the property already exists, then, the old value is deleted and silently
//  replaced. Setting, pvData to NULL, deletes the property.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertSetCertificateContextProperty(
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN const void *pvData
    )
{
    return SetProperty(
        ToContextElement(pCertContext),
        dwPropId,
        dwFlags,
        pvData
        );
}

//+-------------------------------------------------------------------------
//  Get the property for the specified certificate context.
//
//  For CERT_KEY_PROV_HANDLE_PROP_ID, pvData points to a HCRYPTPROV.
//
//  For CERT_KEY_PROV_INFO_PROP_ID, pvData points to a CRYPT_KEY_PROV_INFO structure.
//  Elements pointed to by fields in the pvData structure follow the
//  structure. Therefore, *pcbData may exceed the size of the structure.
//
//  For CERT_SHA1_HASH_PROP_ID or CERT_MD5_HASH_PROP_ID, if the hash
//  doesn't already exist, then, its computed via CryptHashCertificate()
//  and then set. pvData points to the computed hash. Normally, the length
//  is 20 bytes for SHA and 16 for MD5.
//  MD5.
//
//  For CERT_SIGNATURE_HASH_PROP_ID, if the hash
//  doesn't already exist, then, its computed via CryptHashToBeSigned()
//  and then set. pvData points to the computed hash. Normally, the length
//  is 20 bytes for SHA and 16 for MD5.
//
//  For all other PROP_IDs, pvData points to an encoded array of bytes.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertGetCertificateContextProperty(
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwPropId,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    )
{
    return GetProperty(
        ToContextElement(pCertContext),
            dwPropId,
            pvData,
            pcbData
            );
}

//+-------------------------------------------------------------------------
//  Enumerate the properties for the specified certificate context.
//--------------------------------------------------------------------------
DWORD
WINAPI
CertEnumCertificateContextProperties(
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwPropId
    )
{
    return EnumProperties(
        ToContextElement(pCertContext),
        dwPropId
        );
}


#ifdef CAPI_INCLUDE_CRL
//+=========================================================================
//  CRL APIs
//==========================================================================

BOOL
WINAPI
CertAddEncodedCRLToStore(
    IN HCERTSTORE hCertStore,
    IN DWORD dwCertEncodingType,
    IN const BYTE *pbCrlEncoded,
    IN DWORD cbCrlEncoded,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCCRL_CONTEXT *ppCrlContext
    )
{
    BOOL fResult;
    PCONTEXT_ELEMENT pStoreEle;
    fResult = AddEncodedContextToStore(
        (PCERT_STORE) hCertStore,
        CERT_STORE_CRL_CONTEXT - 1,
        dwCertEncodingType,
        pbCrlEncoded,
        cbCrlEncoded,
        dwAddDisposition,
        ppCrlContext ? &pStoreEle : NULL
        );
    if (ppCrlContext)
        *ppCrlContext = ToCrlContext(pStoreEle);
    return fResult;
}

BOOL
WINAPI
CertAddCRLContextToStore(
    IN HCERTSTORE hCertStore,
    IN PCCRL_CONTEXT pCrlContext,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCCRL_CONTEXT *ppStoreContext
    )
{
    BOOL fResult;
    PCONTEXT_ELEMENT pStoreEle;

    fResult = AddContextToStore(
        (PCERT_STORE) hCertStore,
        ToContextElement(pCrlContext),
        pCrlContext->dwCertEncodingType,
        pCrlContext->pbCrlEncoded,
        pCrlContext->cbCrlEncoded,
        dwAddDisposition,
        ppStoreContext ? &pStoreEle : NULL
        );
    if (ppStoreContext)
        *ppStoreContext = ToCrlContext(pStoreEle);
    return fResult;
}

BOOL
WINAPI
CertAddCRLLinkToStore(
    IN HCERTSTORE hCertStore,
    IN PCCRL_CONTEXT pCrlContext,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCCRL_CONTEXT *ppStoreContext
    )
{
    BOOL fResult;
    PCONTEXT_ELEMENT pStoreEle;

    fResult = AddLinkContextToCacheStore(
        (PCERT_STORE) hCertStore,
        ToContextElement(pCrlContext),
        dwAddDisposition,
        ppStoreContext ? &pStoreEle : NULL
        );
    if (ppStoreContext)
        *ppStoreContext = ToCrlContext(pStoreEle);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Serialize the CRL context's encoded CRL and its properties.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertSerializeCRLStoreElement(
    IN PCCRL_CONTEXT pCrlContext,
    IN DWORD dwFlags,
    OUT BYTE *pbElement,
    IN OUT DWORD *pcbElement
    )
{
    return SerializeContextElement(
        ToContextElement(pCrlContext),
        dwFlags,
        pbElement,
        pcbElement
        );
}

//+-------------------------------------------------------------------------
//  Delete the specified CRL from the store.
//
//  All subsequent gets for the CRL will fail. However,
//  memory allocated for the CRL isn't freed until all of its contexts
//  have also been freed.
//
//  The pCrlContext is obtained from a get or duplicate.
//
//  NOTE: the pCrlContext is always CertFreeCRLContext'ed by
//  this function, even for an error.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertDeleteCRLFromStore(
    IN PCCRL_CONTEXT pCrlContext
    )
{
    assert(NULL == pCrlContext || (CERT_STORE_CRL_CONTEXT - 1) ==
        ToContextElement(pCrlContext)->dwContextType);
    return DeleteContextElement(ToContextElement(pCrlContext));
}

//+-------------------------------------------------------------------------
//  Perform the enabled verification checks on the CRL using the issuer
//--------------------------------------------------------------------------
STATIC void VerifyCrl(
    IN PCCRL_CONTEXT pCrl,
    IN OPTIONAL PCCERT_CONTEXT pIssuer,
    IN OUT DWORD *pdwFlags
    )
{
    if (*pdwFlags & CERT_STORE_TIME_VALIDITY_FLAG) {
        if (CertVerifyCRLTimeValidity(NULL,
                pCrl->pCrlInfo) == 0)
            *pdwFlags &= ~CERT_STORE_TIME_VALIDITY_FLAG;
    }

    if (pIssuer == NULL) {
        if (*pdwFlags & CERT_STORE_SIGNATURE_FLAG)
            *pdwFlags |= CERT_STORE_NO_ISSUER_FLAG;
        return;
    }

    if (*pdwFlags & CERT_STORE_SIGNATURE_FLAG) {
        PCERT_STORE pStore = (PCERT_STORE) pIssuer->hCertStore;
        HCRYPTPROV hProv;
        DWORD dwProvFlags;

        // Attempt to get the store's crypt provider. Serialize crypto
        // operations by entering critical section.
        hProv = GetCryptProv(pStore, &dwProvFlags);
#ifdef CMS_PKCS7
        if (VerifyCertificateSignatureWithChainPubKeyParaInheritance(
                hProv,
                pCrl->dwCertEncodingType,
                CRYPT_VERIFY_CERT_SIGN_SUBJECT_CRL,
                (void *) pCrl,
                pIssuer
                ))
#else
        if (CryptVerifyCertificateSignature(
                hProv,
                pCrl->dwCertEncodingType,
                pCrl->pbCrlEncoded,
                pCrl->cbCrlEncoded,
                &pIssuer->pCertInfo->SubjectPublicKeyInfo
                ))
#endif  // CMS_PKCS7
            *pdwFlags &= ~CERT_STORE_SIGNATURE_FLAG;
        // For the store's crypt provider, release reference count. Leave
        // crypto operations critical section.
        ReleaseCryptProv(pStore, dwProvFlags);
    }
}

//+-------------------------------------------------------------------------
//  Get the first or next CRL context from the store for the specified
//  issuer certificate. Perform the enabled verification checks on the CRL.
//
//  If the first or next CRL isn't found, NULL is returned.
//  Otherwise, a pointer to a read only CRL_CONTEXT is returned. CRL_CONTEXT
//  must be freed by calling CertFreeCRLContext or is freed when passed as the
//  pPrevCrlContext on a subsequent call. CertDuplicateCRLContext
//  can be called to make a duplicate.
//
//  The pIssuerContext may have been obtained from this store, another store
//  or created by the caller application. When created by the caller, the
//  CertCreateCertificateContext function must have been called.
//
//  If pIssuerContext == NULL, finds all the CRLs in the store.
//
//  An issuer may have multiple CRLs. For example, it generates delta CRLs
//  using a X.509 v3 extension. pPrevCrlContext MUST BE NULL on the first
//  call to get the CRL. To get the next CRL for the issuer, the
//  pPrevCrlContext is set to the CRL_CONTEXT returned by a previous call.
//
//  NOTE: a NON-NULL pPrevCrlContext is always CertFreeCRLContext'ed by
//  this function, even for an error.
//
//  The following flags can be set in *pdwFlags to enable verification checks
//  on the returned CRL:
//      CERT_STORE_SIGNATURE_FLAG     - use the public key in the
//                                      issuer's certificate to verify the
//                                      signature on the returned CRL.
//                                      Note, if pIssuerContext->hCertStore ==
//                                      hCertStore, the store provider might
//                                      be able to eliminate a redo of
//                                      the signature verify.
//      CERT_STORE_TIME_VALIDITY_FLAG - get the current time and verify that
//                                      its within the CRL's ThisUpdate and
//                                      NextUpdate validity period.
//
//  If an enabled verification check fails, then, its flag is set upon return.
//
//  If pIssuerContext == NULL, then, an enabled CERT_STORE_SIGNATURE_FLAG
//  always fails and the CERT_STORE_NO_ISSUER_FLAG is also set.
//
//  For a verification check failure, a pointer to the first or next
//  CRL_CONTEXT is still returned and SetLastError isn't updated.
//--------------------------------------------------------------------------
PCCRL_CONTEXT
WINAPI
CertGetCRLFromStore(
    IN HCERTSTORE hCertStore,
    IN OPTIONAL PCCERT_CONTEXT pIssuerContext,
    IN PCCRL_CONTEXT pPrevCrlContext,
    IN OUT DWORD *pdwFlags
    )
{
    CERT_STORE_PROV_FIND_INFO FindInfo;
    PCCERT_STORE_PROV_FIND_INFO pFindInfo;
    PCCRL_CONTEXT pCrlContext;

    if (*pdwFlags & ~(CERT_STORE_SIGNATURE_FLAG |
                      CERT_STORE_TIME_VALIDITY_FLAG))
        goto InvalidArg;

    if (NULL == pIssuerContext)
        pFindInfo = &FindAnyInfo;
    else {
        pFindInfo = &FindInfo;
        FindInfo.cbSize = sizeof(FindInfo);
        FindInfo.dwMsgAndCertEncodingType = pIssuerContext->dwCertEncodingType;
        FindInfo.dwFindFlags = 0;
        FindInfo.dwFindType = CRL_FIND_ISSUED_BY;
        FindInfo.pvFindPara = pIssuerContext;
    }

    if (pCrlContext = ToCrlContext(CheckAutoResyncAndFindElementInStore(
            (PCERT_STORE) hCertStore,
            CERT_STORE_CRL_CONTEXT - 1,
            pFindInfo,
            ToContextElement(pPrevCrlContext)
            )))
        VerifyCrl(
            pCrlContext,
            pIssuerContext,
            pdwFlags
            );

CommonReturn:
    return pCrlContext;

ErrorReturn:
    if (pPrevCrlContext)
        CertFreeCRLContext(pPrevCrlContext);
    pCrlContext = NULL;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
}

//+-------------------------------------------------------------------------
//  Enumerate the CRL contexts in the store.
//
//  If a CRL isn't found, NULL is returned.
//  Otherwise, a pointer to a read only CRL_CONTEXT is returned. CRL_CONTEXT
//  must be freed by calling CertFreeCRLContext or is freed when passed as the
//  pPrevCrlContext on a subsequent call. CertDuplicateCRLContext
//  can be called to make a duplicate.
//
//  pPrevCrlContext MUST BE NULL to enumerate the first
//  CRL in the store. Successive CRLs are enumerated by setting
//  pPrevCrlContext to the CRL_CONTEXT returned by a previous call.
//
//  NOTE: a NON-NULL pPrevCrlContext is always CertFreeCRLContext'ed by
//  this function, even for an error.
//--------------------------------------------------------------------------
PCCRL_CONTEXT
WINAPI
CertEnumCRLsInStore(
    IN HCERTSTORE hCertStore,
    IN PCCRL_CONTEXT pPrevCrlContext
    )
{
    return ToCrlContext(CheckAutoResyncAndFindElementInStore(
        (PCERT_STORE) hCertStore,
        CERT_STORE_CRL_CONTEXT - 1,
        &FindAnyInfo,
        ToContextElement(pPrevCrlContext)
        ));
}

//+-------------------------------------------------------------------------
//  Find the first or next CRL context in the store.
//
//  The CRL is found according to the dwFindType and its pvFindPara.
//  See below for a list of the find types and its parameters.
//
//  Currently dwFindFlags isn't used and must be set to 0.
//
//  Usage of dwCertEncodingType depends on the dwFindType.
//
//  If the first or next CRL isn't found, NULL is returned.
//  Otherwise, a pointer to a read only CRL_CONTEXT is returned. CRL_CONTEXT
//  must be freed by calling CertFreeCRLContext or is freed when passed as the
//  pPrevCrlContext on a subsequent call. CertDuplicateCRLContext
//  can be called to make a duplicate.
//
//  pPrevCrlContext MUST BE NULL on the first
//  call to find the CRL. To find the next CRL, the
//  pPrevCrlContext is set to the CRL_CONTEXT returned by a previous call.
//
//  NOTE: a NON-NULL pPrevCrlContext is always CertFreeCRLContext'ed by
//  this function, even for an error.
//--------------------------------------------------------------------------
PCCRL_CONTEXT
WINAPI
CertFindCRLInStore(
    IN HCERTSTORE hCertStore,
    IN DWORD dwCertEncodingType,
    IN DWORD dwFindFlags,
    IN DWORD dwFindType,
    IN const void *pvFindPara,
    IN PCCRL_CONTEXT pPrevCrlContext
    )
{
    CERT_STORE_PROV_FIND_INFO FindInfo;

    FindInfo.cbSize = sizeof(FindInfo);
    FindInfo.dwMsgAndCertEncodingType = dwCertEncodingType;
    FindInfo.dwFindFlags = dwFindFlags;
    FindInfo.dwFindType = dwFindType;
    FindInfo.pvFindPara = pvFindPara;

    return ToCrlContext(CheckAutoResyncAndFindElementInStore(
        (PCERT_STORE) hCertStore,
        CERT_STORE_CRL_CONTEXT - 1,
        &FindInfo,
        ToContextElement(pPrevCrlContext)
        ));
}

//+-------------------------------------------------------------------------
//  Duplicate a CRL context
//--------------------------------------------------------------------------
PCCRL_CONTEXT
WINAPI
CertDuplicateCRLContext(
    IN PCCRL_CONTEXT pCrlContext
    )
{
    if (pCrlContext)
        AddRefContextElement(ToContextElement(pCrlContext));
    return pCrlContext;
}

//+-------------------------------------------------------------------------
//  Create a CRL context from the encoded CRL. The created
//  context isn't put in a store.
//
//  Makes a copy of the encoded CRL in the created context.
//
//  If unable to decode and create the CRL context, NULL is returned.
//  Otherwise, a pointer to a read only CRL_CONTEXT is returned.
//  CRL_CONTEXT must be freed by calling CertFreeCRLContext.
//  CertDuplicateCRLContext can be called to make a duplicate.
//
//  CertSetCRLContextProperty and CertGetCRLContextProperty can be called
//  to store properties for the CRL.
//--------------------------------------------------------------------------
PCCRL_CONTEXT
WINAPI
CertCreateCRLContext(
    IN DWORD dwCertEncodingType,
    IN const BYTE *pbCrlEncoded,
    IN DWORD cbCrlEncoded
    )
{
    PCCRL_CONTEXT pCrlContext;

    CertAddEncodedCRLToStore(
        NULL,                   // hCertStore
        dwCertEncodingType,
        pbCrlEncoded,
        cbCrlEncoded,
        CERT_STORE_ADD_ALWAYS,
        &pCrlContext
        );
    return pCrlContext;
}


//+-------------------------------------------------------------------------
//  Free a CRL context
//
//  There needs to be a corresponding free for each context obtained by a
//  get, duplicate or create.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertFreeCRLContext(
    IN PCCRL_CONTEXT pCrlContext
    )
{
    ReleaseContextElement(ToContextElement(pCrlContext));
    return TRUE;
}

//+-------------------------------------------------------------------------
//  Set the property for the specified CRL context.
//
//  Same Property Ids and semantics as CertSetCertificateContextProperty.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertSetCRLContextProperty(
    IN PCCRL_CONTEXT pCrlContext,
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN const void *pvData
    )
{
    return SetProperty(
        ToContextElement(pCrlContext),
        dwPropId,
        dwFlags,
        pvData
        );
}

//+-------------------------------------------------------------------------
//  Get the property for the specified CRL context.
//
//  Same Property Ids and semantics as CertGetCertificateContextProperty.
//
//  CERT_SHA1_HASH_PROP_ID, CERT_MD5_HASH_PROP_ID or
//  CERT_SIGNATURE_HASH_PROP_ID is the predefined property of most interest.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertGetCRLContextProperty(
    IN PCCRL_CONTEXT pCrlContext,
    IN DWORD dwPropId,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    )
{
    return GetProperty(
        ToContextElement(pCrlContext),
        dwPropId,
        pvData,
        pcbData
        );
}

//+-------------------------------------------------------------------------
//  Enumerate the properties for the specified CRL context.
//--------------------------------------------------------------------------
DWORD
WINAPI
CertEnumCRLContextProperties(
    IN PCCRL_CONTEXT pCrlContext,
    IN DWORD dwPropId
    )
{
    return EnumProperties(
        ToContextElement(pCrlContext),
        dwPropId
        );
}

//+-------------------------------------------------------------------------
//  Called by qsort.
//
//  Compare's the CRL entry's serial numbers. Note, since we won't be adding
//  any entries, don't need to worry about leading 0's or ff's. Also, ASN.1
//  decoding should have removed them.
//
//  The elements being sorted are pointers to the CRL entries. Not the
//  CRL entries.
//--------------------------------------------------------------------------
STATIC int __cdecl CompareCrlEntry(
    IN const void *pelem1,
    IN const void *pelem2
    )
{
    PCRL_ENTRY p1 = *((PCRL_ENTRY *) pelem1);
    PCRL_ENTRY p2 = *((PCRL_ENTRY *) pelem2);

    DWORD cb1 = p1->SerialNumber.cbData;
    DWORD cb2 = p2->SerialNumber.cbData;

    if (cb1 == cb2) {
        if (0 == cb1)
            return 0;
        else
            return memcmp(p1->SerialNumber.pbData, p2->SerialNumber.pbData,
                cb1);
    } else if (cb1 < cb2)
        return -1;
    else
        return 1;
}

//+-------------------------------------------------------------------------
//  Called by bsearch.
//
//  Compare's the key's serial number with the CRL entry's serial number
//
//  The elements being searched are pointers to the CRL entries. Not the
//  CRL entries.
//--------------------------------------------------------------------------
STATIC int __cdecl CompareCrlEntrySerialNumber(
    IN const void *pkey,
    IN const void *pvalue
    )
{
    PCRYPT_INTEGER_BLOB pSerialNumber = (PCRYPT_INTEGER_BLOB) pkey;
    PCRL_ENTRY pCrlEntry = *((PCRL_ENTRY *) pvalue);

    DWORD cb1 = pSerialNumber->cbData;
    DWORD cb2 = pCrlEntry->SerialNumber.cbData;

    if (cb1 == cb2) {
        if (0 == cb1)
            return 0;
        else
            return memcmp(pSerialNumber->pbData,
                pCrlEntry->SerialNumber.pbData, cb1);
    } else if (cb1 < cb2)
        return -1;
    else
        return 1;
}

//+-------------------------------------------------------------------------
//  Search the CRL's list of entries for the specified certificate.
//
//  TRUE is returned if we were able to search the list. Otherwise, FALSE is
//  returned,
//
//  For success, if the certificate was found in the list, *ppCrlEntry is
//  updated with a pointer to the entry. Otherwise, *ppCrlEntry is set to NULL.
//  The returned entry isn't allocated and must not be freed.
//
//  dwFlags and pvReserved currently aren't used and must be set to 0 or NULL.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertFindCertificateInCRL(
    IN PCCERT_CONTEXT pCert,
    IN PCCRL_CONTEXT pCrlContext,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT PCRL_ENTRY *ppCrlEntry
    )
{
    BOOL fResult;
    PCRL_INFO pInfo = pCrlContext->pCrlInfo;
    PCONTEXT_ELEMENT pCacheEle;
    PCERT_STORE pCacheStore;
    PCRL_ENTRY *ppSortedEntry;
    DWORD cEntry;
    PCRL_ENTRY *ppFoundEntry;

    *ppCrlEntry = NULL;

    // Get qsorted pointers to the CRL Entries
    if (0 == (cEntry = pInfo->cCRLEntry))
        goto SuccessReturn;

    if (NULL == (pCacheEle = GetCacheElement(ToContextElement(pCrlContext))))
        goto NoCacheElementError;
    pCacheStore = pCacheEle->pStore;

    LockStore(pCacheStore);
    if (NULL == (ppSortedEntry =
            ToCrlContextSuffix(pCacheEle)->ppSortedEntry)) {
        if (ppSortedEntry = (PCRL_ENTRY *) PkiNonzeroAlloc(
                cEntry * sizeof(PCRL_ENTRY))) {
            // Initialize the array of entry pointers
            DWORD c = cEntry;
            PCRL_ENTRY p = pInfo->rgCRLEntry;
            PCRL_ENTRY *pp = ppSortedEntry;

            for ( ; c > 0; c--, p++, pp++)
                *pp = p;

            // Now sort the CRL entry pointers
            qsort(ppSortedEntry, cEntry, sizeof(PCRL_ENTRY), CompareCrlEntry);

            ToCrlContextSuffix(pCacheEle)->ppSortedEntry = ppSortedEntry;
        }
    }
    UnlockStore(pCacheStore);
    if (NULL == ppSortedEntry)
        goto OutOfMemory;

    // Search the sorted subject entry pointers
    if (ppFoundEntry = (PCRL_ENTRY *) bsearch(&pCert->pCertInfo->SerialNumber,
            ppSortedEntry, cEntry, sizeof(PCRL_ENTRY),
                CompareCrlEntrySerialNumber))
        *ppCrlEntry = *ppFoundEntry;

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    *ppCrlEntry = (PCRL_ENTRY) 1;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(NoCacheElementError)
TRACE_ERROR(OutOfMemory)
}

#endif //CAPI_INCLUDE_CRL

#ifdef CAPI_INCLUDE_CTL
//+=========================================================================
//  CTL APIs
//==========================================================================
BOOL
WINAPI
CertAddEncodedCTLToStore(
    IN HCERTSTORE hCertStore,
    IN DWORD dwMsgAndCertEncodingType,
    IN const BYTE *pbCtlEncoded,
    IN DWORD cbCtlEncoded,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCCTL_CONTEXT *ppCtlContext
    )
{
    BOOL fResult;
    PCONTEXT_ELEMENT pStoreEle;
    fResult = AddEncodedContextToStore(
        (PCERT_STORE) hCertStore,
        CERT_STORE_CTL_CONTEXT - 1,
        dwMsgAndCertEncodingType,
        pbCtlEncoded,
        cbCtlEncoded,
        dwAddDisposition,
        ppCtlContext ? &pStoreEle : NULL
        );
    if (ppCtlContext)
        *ppCtlContext = ToCtlContext(pStoreEle);
    return fResult;
}

BOOL
WINAPI
CertAddCTLContextToStore(
    IN HCERTSTORE hCertStore,
    IN PCCTL_CONTEXT pCtlContext,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCCTL_CONTEXT *ppStoreContext
    )
{
    BOOL fResult;
    PCONTEXT_ELEMENT pStoreEle;

    fResult = AddContextToStore(
        (PCERT_STORE) hCertStore,
        ToContextElement(pCtlContext),
        pCtlContext->dwMsgAndCertEncodingType,
        pCtlContext->pbCtlEncoded,
        pCtlContext->cbCtlEncoded,
        dwAddDisposition,
        ppStoreContext ? &pStoreEle : NULL
        );
    if (ppStoreContext)
        *ppStoreContext = ToCtlContext(pStoreEle);
    return fResult;
}

BOOL
WINAPI
CertAddCTLLinkToStore(
    IN HCERTSTORE hCertStore,
    IN PCCTL_CONTEXT pCtlContext,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCCTL_CONTEXT *ppStoreContext
    )
{
    BOOL fResult;
    PCONTEXT_ELEMENT pStoreEle;

    fResult = AddLinkContextToCacheStore(
        (PCERT_STORE) hCertStore,
        ToContextElement(pCtlContext),
        dwAddDisposition,
        ppStoreContext ? &pStoreEle : NULL
        );
    if (ppStoreContext)
        *ppStoreContext = ToCtlContext(pStoreEle);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Serialize the CTL context's encoded CTL and its properties.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertSerializeCTLStoreElement(
    IN PCCTL_CONTEXT pCtlContext,
    IN DWORD dwFlags,
    OUT BYTE *pbElement,
    IN OUT DWORD *pcbElement
    )
{
    return SerializeContextElement(
        ToContextElement(pCtlContext),
        dwFlags,
        pbElement,
        pcbElement
        );
}

//+-------------------------------------------------------------------------
//  Delete the specified CTL from the store.
//
//  All subsequent gets for the CTL will fail. However,
//  memory allocated for the CTL isn't freed until all of its contexts
//  have also been freed.
//
//  The pCtlContext is obtained from a get or duplicate.
//
//  NOTE: the pCtlContext is always CertFreeCTLContext'ed by
//  this function, even for an error.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertDeleteCTLFromStore(
    IN PCCTL_CONTEXT pCtlContext
    )
{
    assert(NULL == pCtlContext || (CERT_STORE_CTL_CONTEXT - 1) ==
        ToContextElement(pCtlContext)->dwContextType);
    return DeleteContextElement(ToContextElement(pCtlContext));
}

//+-------------------------------------------------------------------------
//  Duplicate a CTL context
//--------------------------------------------------------------------------
PCCTL_CONTEXT
WINAPI
CertDuplicateCTLContext(
    IN PCCTL_CONTEXT pCtlContext
    )
{
    if (pCtlContext)
        AddRefContextElement(ToContextElement(pCtlContext));
    return pCtlContext;
}


//+-------------------------------------------------------------------------
//  Create a CTL context from the encoded CTL. The created
//  context isn't put in a store.
//
//  Makes a copy of the encoded CTL in the created context.
//
//  If unable to decode and create the CTL context, NULL is returned.
//  Otherwise, a pointer to a read only CTL_CONTEXT is returned.
//  CTL_CONTEXT must be freed by calling CertFreeCTLContext.
//  CertDuplicateCTLContext can be called to make a duplicate.
//
//  CertSetCTLContextProperty and CertGetCTLContextProperty can be called
//  to store properties for the CTL.
//--------------------------------------------------------------------------
PCCTL_CONTEXT
WINAPI
CertCreateCTLContext(
    IN DWORD dwMsgAndCertEncodingType,
    IN const BYTE *pbCtlEncoded,
    IN DWORD cbCtlEncoded
    )
{
    PCCTL_CONTEXT pCtlContext;

    CertAddEncodedCTLToStore(
        NULL,                   // hCertStore
        dwMsgAndCertEncodingType,
        pbCtlEncoded,
        cbCtlEncoded,
        CERT_STORE_ADD_ALWAYS,
        &pCtlContext
        );
    return pCtlContext;
}


//+-------------------------------------------------------------------------
//  Free a CTL context
//
//  There needs to be a corresponding free for each context obtained by a
//  get, duplicate or create.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertFreeCTLContext(
    IN PCCTL_CONTEXT pCtlContext
    )
{
    ReleaseContextElement(ToContextElement(pCtlContext));
    return TRUE;
}

//+-------------------------------------------------------------------------
//  Set the property for the specified CTL context.
//
//  Same Property Ids and semantics as CertSetCertificateContextProperty.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertSetCTLContextProperty(
    IN PCCTL_CONTEXT pCtlContext,
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN const void *pvData
    )
{
    return SetProperty(
        ToContextElement(pCtlContext),
        dwPropId,
        dwFlags,
        pvData
        );
}

//+-------------------------------------------------------------------------
//  Get the property for the specified CTL context.
//
//  Same Property Ids and semantics as CertGetCertificateContextProperty.
//
//  CERT_SHA1_HASH_PROP_ID or CERT_MD5_HASH_PROP_ID is the predefined
//  property of most interest.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertGetCTLContextProperty(
    IN PCCTL_CONTEXT pCtlContext,
    IN DWORD dwPropId,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    )
{
    return GetProperty(
        ToContextElement(pCtlContext),
        dwPropId,
        pvData,
        pcbData
        );
}

//+-------------------------------------------------------------------------
//  Enumerate the properties for the specified CTL context.
//--------------------------------------------------------------------------
DWORD
WINAPI
CertEnumCTLContextProperties(
    IN PCCTL_CONTEXT pCtlContext,
    IN DWORD dwPropId
    )
{
    return EnumProperties(
        ToContextElement(pCtlContext),
        dwPropId
        );
}


//+-------------------------------------------------------------------------
//  Enumerate the CTL contexts in the store.
//
//  If a CTL isn't found, NULL is returned.
//  Otherwise, a pointer to a read only CTL_CONTEXT is returned. CTL_CONTEXT
//  must be freed by calling CertFreeCTLContext or is freed when passed as the
//  pPrevCtlContext on a subsequent call. CertDuplicateCTLContext
//  can be called to make a duplicate.
//
//  pPrevCtlContext MUST BE NULL to enumerate the first
//  CTL in the store. Successive CTLs are enumerated by setting
//  pPrevCtlContext to the CTL_CONTEXT returned by a previous call.
//
//  NOTE: a NON-NULL pPrevCtlContext is always CertFreeCTLContext'ed by
//  this function, even for an error.
//--------------------------------------------------------------------------
PCCTL_CONTEXT
WINAPI
CertEnumCTLsInStore(
    IN HCERTSTORE hCertStore,
    IN PCCTL_CONTEXT pPrevCtlContext
    )
{
    return ToCtlContext(CheckAutoResyncAndFindElementInStore(
        (PCERT_STORE) hCertStore,
        CERT_STORE_CTL_CONTEXT - 1,
        &FindAnyInfo,
        ToContextElement(pPrevCtlContext)
        ));
}

STATIC BOOL CompareAlgorithmIdentifier(
    IN DWORD dwEncodingType,
    IN PCRYPT_ALGORITHM_IDENTIFIER pAlg1,
    IN PCRYPT_ALGORITHM_IDENTIFIER pAlg2
    )
{
    BOOL fResult = FALSE;
    if (NULL == pAlg1->pszObjId) {
        if (NULL == pAlg2->pszObjId)
            // Both are NULL
            fResult = TRUE;
        // else
        //  One of the OIDs is NULL
    } else if (pAlg2->pszObjId) {
        if (0 == strcmp(pAlg1->pszObjId, pAlg2->pszObjId)) {
            DWORD cb1 = pAlg1->Parameters.cbData;
            BYTE *pb1 = pAlg1->Parameters.pbData;
            DWORD cb2 = pAlg2->Parameters.cbData;
            BYTE *pb2 = pAlg2->Parameters.pbData;

            if (X509_ASN_ENCODING == GET_CERT_ENCODING_TYPE(dwEncodingType)) {
                // Check for NULL parameters: {0x05, 0x00}
                if (2 == cb1 && 0x05 == pb1[0] && 0x00 == pb1[1])
                    cb1 = 0;
                if (2 == cb2 && 0x05 == pb2[0] && 0x00 == pb2[1])
                    cb2 = 0;
            }
            if (cb1 == cb2) {
                if (0 == cb1 || 0 == memcmp(pb1, pb2, cb1))
                    fResult = TRUE;
            }
        }
    }
    // else
    //  One of the OIDs is NULL
    return fResult;
}

//+-------------------------------------------------------------------------
//  Called by qsort. Compare's the CTL entry's SubjectIdentifier.
//
//  The elements being sorted are pointers to the CTL entries. Not the
//  CTL entries.
//--------------------------------------------------------------------------
STATIC int __cdecl CompareCtlEntry(
    IN const void *pelem1,
    IN const void *pelem2
    )
{
    PCTL_ENTRY p1 = *((PCTL_ENTRY *) pelem1);
    PCTL_ENTRY p2 = *((PCTL_ENTRY *) pelem2);

    DWORD cb1 = p1->SubjectIdentifier.cbData;
    DWORD cb2 = p2->SubjectIdentifier.cbData;

    if (cb1 == cb2) {
        if (0 == cb1)
            return 0;
        else
            return memcmp(p1->SubjectIdentifier.pbData,
                p2->SubjectIdentifier.pbData, cb1);
    } else if (cb1 < cb2)
        return -1;
    else
        return 1;
}

//+-------------------------------------------------------------------------
//  Called by bsearch. Compare's the key's SubjectIdentifier with the CTL
//  entry's SubjectIdentifier.
//
//  The elements being searched are pointers to the CTL entries. Not the
//  CTL entries.
//--------------------------------------------------------------------------
STATIC int __cdecl CompareCtlEntrySubjectIdentifier(
    IN const void *pkey,
    IN const void *pvalue
    )
{
    PCRYPT_DATA_BLOB pSubjectIdentifier = (PCRYPT_DATA_BLOB) pkey;
    PCTL_ENTRY pCtlEntry = *((PCTL_ENTRY *) pvalue);

    DWORD cb1 = pSubjectIdentifier->cbData;
    DWORD cb2 = pCtlEntry->SubjectIdentifier.cbData;

    if (cb1 == cb2) {
        if (0 == cb1)
            return 0;
        else
            return memcmp(pSubjectIdentifier->pbData,
                pCtlEntry->SubjectIdentifier.pbData, cb1);
    } else if (cb1 < cb2)
        return -1;
    else
        return 1;
}

//+-------------------------------------------------------------------------
//  Attempt to find the specified subject in the CTL.
//
//  For CTL_CERT_SUBJECT_TYPE, pvSubject points to a CERT_CONTEXT. The CTL's
//  SubjectAlgorithm is examined to determine the representation of the
//  subject's identity. Initially, only SHA1 or MD5 hash will be supported.
//  The appropriate hash property is obtained from the CERT_CONTEXT.
//
//  For CTL_ANY_SUBJECT_TYPE, pvSubject points to the CTL_ANY_SUBJECT_INFO
//  structure which contains the SubjectAlgorithm to be matched in the CTL
//  and the SubjectIdentifer to be matched in one of the CTL entries.
//
//  The cetificate's hash or the CTL_ANY_SUBJECT_INFO's SubjectIdentifier
//  is used as the key in searching the subject entries. A binary
//  memory comparison is done between the key and the entry's SubjectIdentifer.
//
//  dwEncodingType isn't used for either of the above SubjectTypes.
//--------------------------------------------------------------------------
PCTL_ENTRY
WINAPI
CertFindSubjectInCTL(
    IN DWORD dwEncodingType,
    IN DWORD dwSubjectType,
    IN void *pvSubject,
    IN PCCTL_CONTEXT pCtlContext,
    IN DWORD dwFlags
    )
{
    PCTL_ENTRY *ppSubjectEntry;
    PCTL_ENTRY pSubjectEntry;
    PCTL_INFO pInfo = pCtlContext->pCtlInfo;

    PCONTEXT_ELEMENT pCacheEle;
    PCERT_STORE pCacheStore;

    BYTE rgbHash[MAX_HASH_LEN];
    CRYPT_DATA_BLOB Key;
    PCTL_ENTRY *ppSortedEntry;
    DWORD cEntry;

    // Get Key to be used in bsearch
    switch (dwSubjectType) {
        case CTL_CERT_SUBJECT_TYPE:
            {
                DWORD Algid;
                DWORD dwPropId;

                if (NULL == pInfo->SubjectAlgorithm.pszObjId)
                    goto NoSubjectAlgorithm;
                Algid = CertOIDToAlgId(pInfo->SubjectAlgorithm.pszObjId);
                switch (Algid) {
                    case CALG_SHA1:
                        dwPropId = CERT_SHA1_HASH_PROP_ID;
                        break;
                    case CALG_MD5:
                        dwPropId = CERT_MD5_HASH_PROP_ID;
                        break;
                    default:
                        goto UnknownAlgid;
                }

                Key.cbData = MAX_HASH_LEN;
                if (!CertGetCertificateContextProperty(
                        (PCCERT_CONTEXT) pvSubject,
                        dwPropId,
                        rgbHash,
                        &Key.cbData) || 0 == Key.cbData)
                    goto GetHashError;
                Key.pbData = rgbHash;
            }
            break;
        case CTL_ANY_SUBJECT_TYPE:
            {
                PCTL_ANY_SUBJECT_INFO pAnyInfo =
                    (PCTL_ANY_SUBJECT_INFO) pvSubject;
                if (pAnyInfo->SubjectAlgorithm.pszObjId &&
                        !CompareAlgorithmIdentifier(
                            (pCtlContext->dwMsgAndCertEncodingType >> 16) &
                                CERT_ENCODING_TYPE_MASK,
                            &pAnyInfo->SubjectAlgorithm,
                            &pInfo->SubjectAlgorithm))
                    goto NotFoundError;

                Key = pAnyInfo->SubjectIdentifier;
            }
            break;
        default:
            goto InvalidSubjectType;
    }


    // Get qsorted pointers to the Subject Entries
    if (0 == (cEntry = pInfo->cCTLEntry))
        goto NoEntryError;

    if (NULL == (pCacheEle = GetCacheElement(ToContextElement(pCtlContext))))
        goto NoCacheElementError;
    pCacheStore = pCacheEle->pStore;

    LockStore(pCacheStore);
    if (NULL == (ppSortedEntry =
            ToCtlContextSuffix(pCacheEle)->ppSortedEntry)) {
        if (ppSortedEntry = (PCTL_ENTRY *) PkiNonzeroAlloc(
                cEntry * sizeof(PCTL_ENTRY))) {
            // Initialize the array of entry pointers
            DWORD c = cEntry;
            PCTL_ENTRY p = pInfo->rgCTLEntry;
            PCTL_ENTRY *pp = ppSortedEntry;

            for ( ; c > 0; c--, p++, pp++)
                *pp = p;

            // Now sort the subject entry pointers
            qsort(ppSortedEntry, cEntry, sizeof(PCTL_ENTRY), CompareCtlEntry);

            ToCtlContextSuffix(pCacheEle)->ppSortedEntry = ppSortedEntry;
        }
    }
    UnlockStore(pCacheStore);
    if (NULL == ppSortedEntry)
        goto OutOfMemory;

    // Search the sorted subject entry pointers
    if (NULL == (ppSubjectEntry = (PCTL_ENTRY *) bsearch(&Key,
            ppSortedEntry, cEntry, sizeof(PCTL_ENTRY),
            CompareCtlEntrySubjectIdentifier)))
        goto NotFoundError;
    pSubjectEntry = *ppSubjectEntry;

CommonReturn:
    return pSubjectEntry;

NotFoundError:
    SetLastError((DWORD) CRYPT_E_NOT_FOUND);
ErrorReturn:
    pSubjectEntry = NULL;
    goto CommonReturn;

SET_ERROR(NoSubjectAlgorithm, CRYPT_E_NOT_FOUND)
SET_ERROR(UnknownAlgid, NTE_BAD_ALGID)
SET_ERROR(NoEntryError, CRYPT_E_NOT_FOUND)
TRACE_ERROR(NoCacheElementError)
TRACE_ERROR(GetHashError)
SET_ERROR(InvalidSubjectType, E_INVALIDARG)
TRACE_ERROR(OutOfMemory)
}


//+-------------------------------------------------------------------------
//  Find the first or next CTL context in the store.
//
//  The CTL is found according to the dwFindType and its pvFindPara.
//  See below for a list of the find types and its parameters.
//
//  Currently dwFindFlags isn't used and must be set to 0.
//
//  Usage of dwMsgAndCertEncodingType depends on the dwFindType.
//
//  If the first or next CTL isn't found, NULL is returned.
//  Otherwise, a pointer to a read only CTL_CONTEXT is returned. CTL_CONTEXT
//  must be freed by calling CertFreeCTLContext or is freed when passed as the
//  pPrevCtlContext on a subsequent call. CertDuplicateCTLContext
//  can be called to make a duplicate.
//
//  pPrevCtlContext MUST BE NULL on the first
//  call to find the CTL. To find the next CTL, the
//  pPrevCtlContext is set to the CTL_CONTEXT returned by a previous call.
//
//  NOTE: a NON-NULL pPrevCtlContext is always CertFreeCTLContext'ed by
//  this function, even for an error.
//--------------------------------------------------------------------------
PCCTL_CONTEXT
WINAPI
CertFindCTLInStore(
    IN HCERTSTORE hCertStore,
    IN DWORD dwMsgAndCertEncodingType,
    IN DWORD dwFindFlags,
    IN DWORD dwFindType,
    IN const void *pvFindPara,
    IN PCCTL_CONTEXT pPrevCtlContext
    )
{
    CERT_STORE_PROV_FIND_INFO FindInfo;

    FindInfo.cbSize = sizeof(FindInfo);
    FindInfo.dwMsgAndCertEncodingType = dwMsgAndCertEncodingType;
    FindInfo.dwFindFlags = dwFindFlags;
    FindInfo.dwFindType = dwFindType;
    FindInfo.pvFindPara = pvFindPara;

    return ToCtlContext(CheckAutoResyncAndFindElementInStore(
        (PCERT_STORE) hCertStore,
        CERT_STORE_CTL_CONTEXT - 1,
        &FindInfo,
        ToContextElement(pPrevCtlContext)
        ));
}

#endif // CAPI_INCLUDE_CTL


//+=========================================================================
//  CERT_CONTEXT Functions
//==========================================================================

// pbCertEncoded has already been allocated
STATIC PCONTEXT_ELEMENT CreateCertElement(
    IN PCERT_STORE pStore,
    IN DWORD dwCertEncodingType,
    IN BYTE *pbCertEncoded,
    IN DWORD cbCertEncoded
    )
{
    PCONTEXT_ELEMENT pEle = NULL;
    PCERT_CONTEXT pCert;
    PCERT_INFO pInfo = NULL;


    if (0 == GET_CERT_ENCODING_TYPE(dwCertEncodingType)) {
        SetLastError((DWORD) E_INVALIDARG);
        goto ErrorReturn;
    }

    cbCertEncoded = AdjustEncodedLength(
        dwCertEncodingType, pbCertEncoded, cbCertEncoded);

    if (NULL == (pInfo = (PCERT_INFO) AllocAndDecodeObject(
            dwCertEncodingType,
            X509_CERT_TO_BE_SIGNED,
            pbCertEncoded,
            cbCertEncoded))) goto ErrorReturn;

    // Allocate and initialize the cert element structure
    pEle = (PCONTEXT_ELEMENT) PkiZeroAlloc(sizeof(CONTEXT_ELEMENT) +
        sizeof(CERT_CONTEXT));
    if (pEle == NULL) goto ErrorReturn;

    pEle->dwElementType = ELEMENT_TYPE_CACHE;
    pEle->dwContextType = CERT_STORE_CERTIFICATE_CONTEXT - 1;
    pEle->lRefCnt = 1;
    pEle->pEle = pEle;
    pEle->pStore = pStore;
    pEle->pProvStore = pStore;

    pCert = (PCERT_CONTEXT) ToCertContext(pEle);
    pCert->dwCertEncodingType =
        dwCertEncodingType & CERT_ENCODING_TYPE_MASK;
    pCert->pbCertEncoded = pbCertEncoded;
    pCert->cbCertEncoded = cbCertEncoded;
    pCert->pCertInfo = pInfo;
    pCert->hCertStore = (HCERTSTORE) pStore;

CommonReturn:
    return pEle;
ErrorReturn:
    if (pEle) {
        PkiFree(pEle);
        pEle = NULL;
    }
    PkiFree(pInfo);
    goto CommonReturn;
}

STATIC void FreeCertElement(IN PCONTEXT_ELEMENT pEle)
{
    PCCERT_CONTEXT pCert = ToCertContext(pEle);
    PkiFree(pCert->pbCertEncoded);
    PkiFree(pCert->pCertInfo);
    PkiFree(pEle);
}

STATIC BOOL CompareCertHash(
    IN PCCERT_CONTEXT pCert,
    IN DWORD dwPropId,
    IN PCRYPT_HASH_BLOB pHash
    )
{
    BYTE rgbHash[MAX_HASH_LEN];
    DWORD cbHash = MAX_HASH_LEN;
    CertGetCertificateContextProperty(
        pCert,
        dwPropId,
        rgbHash,
        &cbHash
        );
    if (cbHash == pHash->cbData &&
            memcmp(rgbHash, pHash->pbData, cbHash) == 0)
        return TRUE;
    else
        return FALSE;
}

STATIC BOOL CompareNameStrW(
    IN DWORD dwCertEncodingType,
    IN PCERT_NAME_BLOB pName,
    IN LPCWSTR pwszFind
    )
{
    BOOL fResult = FALSE;
    DWORD cwszFind;
    LPWSTR pwszName = NULL;
    DWORD cwszName;

    if (pwszFind == NULL || *pwszFind == L'\0')
        return TRUE;

    cwszName = CertNameToStrW(
        dwCertEncodingType,
        pName,
        CERT_SIMPLE_NAME_STR,
        NULL,                   // pwsz
        0                       // cwsz
        );
    if (pwszName = (LPWSTR) PkiNonzeroAlloc(cwszName * sizeof(WCHAR))) {
        cwszName = CertNameToStrW(
            dwCertEncodingType,
            pName,
            CERT_SIMPLE_NAME_STR,
            pwszName,
            cwszName) - 1;
        cwszFind = wcslen(pwszFind);

        // Start at end of the certificate's name and slide one character
        // to the left until a match or reach the beginning of the
        // certificate name.
        for ( ; cwszName >= cwszFind; cwszName--) {
            pwszName[cwszName] = L'\0';
            if (_wcsicmp(pwszFind, &pwszName[cwszName - cwszFind]) == 0) {
                fResult = TRUE;
                break;
            }
        }

        PkiFree(pwszName);
    }
    return fResult;
}

STATIC BOOL CompareNameStrA(
    IN DWORD dwCertEncodingType,
    IN PCERT_NAME_BLOB pName,
    IN LPCSTR pszFind
    )
{
    BOOL fResult = FALSE;
    DWORD cszFind;
    LPSTR pszName = NULL;
    DWORD cszName;

    if (pszFind == NULL || *pszFind == '\0')
        return TRUE;

    cszName = CertNameToStrA(
        dwCertEncodingType,
        pName,
        CERT_SIMPLE_NAME_STR,
        NULL,                   // psz
        0                       // csz
        );
    if (pszName = (LPSTR) PkiNonzeroAlloc(cszName)) {
        cszName = CertNameToStrA(
            dwCertEncodingType,
            pName,
            CERT_SIMPLE_NAME_STR,
            pszName,
            cszName) - 1;
        cszFind = strlen(pszFind);

        // Start at end of the certificate's name and slide one character
        // to the left until a match or reach the beginning of the
        // certificate name.
        for ( ; cszName >= cszFind; cszName--) {
            pszName[cszName] = '\0';
            if (_stricmp(pszFind, &pszName[cszName - cszFind]) == 0) {
                fResult = TRUE;
                break;
            }
        }

        PkiFree(pszName);
    }
    return fResult;
}

#ifdef CAPI_INCLUDE_CTL
STATIC BOOL CompareCtlUsageIdentifiers(
    IN PCTL_USAGE pPara,
    IN DWORD cUsage,
    IN PCTL_USAGE pUsage,
    IN BOOL fOrUsage
    )
{
    if (pPara && pPara->cUsageIdentifier) {
        DWORD cId1 = pPara->cUsageIdentifier;
        LPSTR *ppszId1 = pPara->rgpszUsageIdentifier;
        for ( ; cId1 > 0; cId1--, ppszId1++) {
            DWORD i;
            for (i = 0; i < cUsage; i++) {
                DWORD cId2 = pUsage[i].cUsageIdentifier;
                LPSTR *ppszId2 = pUsage[i].rgpszUsageIdentifier;
                for ( ; cId2 > 0; cId2--, ppszId2++) {
                    if (0 == strcmp(*ppszId1, *ppszId2)) {
                        if (fOrUsage)
                            return TRUE;
                        break;
                    }
                }
                if (cId2 > 0)
                    break;
            }
            if (i == cUsage && !fOrUsage)
                return FALSE;
        }

        if (fOrUsage)
            // For the "OR" option we're here without any match
            return FALSE;
        // else
        //  For the "AND" option we have matched all the specified
        //  identifiers
    }
    return TRUE;
}

STATIC BOOL CompareCertUsage(
    IN PCCERT_CONTEXT pCert,
    IN DWORD dwFindFlags,
    IN PCTL_USAGE pPara
    )
{
    BOOL fResult;
    PCERT_INFO pInfo = pCert->pCertInfo;
    PCERT_EXTENSION pExt;       // not allocated
    DWORD cbData;

    PCTL_USAGE pExtUsage = NULL;
    PCTL_USAGE pPropUsage = NULL;
    BYTE *pbPropData = NULL;

    CTL_USAGE rgUsage[2];   // Ext and/or Prop
    DWORD cUsage = 0;

    if (CERT_FIND_VALID_CTL_USAGE_FLAG & dwFindFlags)
        return IFC_IsEndCertValidForUsages(
            pCert,
            pPara,
            0 != (dwFindFlags & CERT_FIND_OR_CTL_USAGE_FLAG));

    if (0 == (CERT_FIND_PROP_ONLY_CTL_USAGE_FLAG & dwFindFlags)) {
        // Is there an Enhanced Key Usage Extension ??
        if (pExt = CertFindExtension(
                szOID_ENHANCED_KEY_USAGE,
                pInfo->cExtension,
                pInfo->rgExtension
                )) {
            if (pExtUsage = (PCTL_USAGE) AllocAndDecodeObject(
                    pCert->dwCertEncodingType,
                    X509_ENHANCED_KEY_USAGE,
                    pExt->Value.pbData,
                    pExt->Value.cbData))
                rgUsage[cUsage++] = *pExtUsage;
        }
    }

    if (0 == (CERT_FIND_EXT_ONLY_CTL_USAGE_FLAG & dwFindFlags)) {
        // Is there an Enhanced Key Usage (CTL Usage) property ??
        if (CertGetCertificateContextProperty(
                pCert,
                CERT_CTL_USAGE_PROP_ID,
                NULL,                       // pvData
                &cbData) && cbData) {
            if (pbPropData = (BYTE *) PkiNonzeroAlloc(cbData)) {
                if (CertGetCertificateContextProperty(
                        pCert,
                        CERT_CTL_USAGE_PROP_ID,
                        pbPropData,
                        &cbData)) {
                    if (pPropUsage = (PCTL_USAGE) AllocAndDecodeObject(
                            pCert->dwCertEncodingType,
                            X509_ENHANCED_KEY_USAGE,
                            pbPropData,
                            cbData))
                        rgUsage[cUsage++] = *pPropUsage;
                }
            }
        }
    }

    if (cUsage > 0) {
        if (dwFindFlags & CERT_FIND_NO_CTL_USAGE_FLAG)
            fResult = FALSE;
        else
            fResult = CompareCtlUsageIdentifiers(pPara, cUsage, rgUsage,
                0 != (dwFindFlags & CERT_FIND_OR_CTL_USAGE_FLAG));
    } else if (dwFindFlags & (CERT_FIND_OPTIONAL_CTL_USAGE_FLAG |
            CERT_FIND_NO_CTL_USAGE_FLAG))
        fResult = TRUE;
    else
        fResult = FALSE;

    PkiFree(pExtUsage);
    PkiFree(pPropUsage);
    PkiFree(pbPropData);

    return fResult;
}
#endif	// CAPI_INCLUDE_CTL

STATIC BOOL IsSameCert(
    IN PCCERT_CONTEXT pCert,
    IN PCCERT_CONTEXT pNew
    )
{
    BYTE rgbCertHash[SHA1_HASH_LEN];
    DWORD cbCertHash = SHA1_HASH_LEN;
    BYTE rgbNewHash[SHA1_HASH_LEN];
    DWORD cbNewHash = SHA1_HASH_LEN;

    CertGetCertificateContextProperty(
        pCert,
        CERT_SHA1_HASH_PROP_ID,
        rgbCertHash,
        &cbCertHash
        );

    CertGetCertificateContextProperty(
        pNew,
        CERT_SHA1_HASH_PROP_ID,
        rgbNewHash,
        &cbNewHash
        );

    if (SHA1_HASH_LEN == cbCertHash && SHA1_HASH_LEN == cbNewHash &&
            0 == memcmp(rgbCertHash, rgbNewHash, SHA1_HASH_LEN))
        return TRUE;
    else
        return FALSE;
}

STATIC BOOL CompareCertElement(
    IN PCONTEXT_ELEMENT pEle,
    IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
    IN BOOL fArchived
    )
{
    PCCERT_CONTEXT pCert = ToCertContext(pEle);
    DWORD dwCmp = (pFindInfo->dwFindType >> CERT_COMPARE_SHIFT) &
        CERT_COMPARE_MASK;
    const void *pvFindPara = pFindInfo->pvFindPara;

    if (fArchived) {
        switch (dwCmp) {
            case CERT_COMPARE_SHA1_HASH:
            case CERT_COMPARE_MD5_HASH:
            case CERT_COMPARE_SIGNATURE_HASH:
            case CERT_COMPARE_SUBJECT_CERT:
#ifdef CMS_PKCS7
            case CERT_COMPARE_CERT_ID:
#endif  // CMS_PKCS7
                break;
            default:
                return FALSE;
        }
    }

    switch (dwCmp) {
        case CERT_COMPARE_ANY:
            return TRUE;
            break;

        case CERT_COMPARE_SHA1_HASH:
        case CERT_COMPARE_MD5_HASH:
        case CERT_COMPARE_SIGNATURE_HASH:
        case CERT_COMPARE_KEY_IDENTIFIER:
            {
                DWORD dwPropId;
                switch (dwCmp) {
                    case CERT_COMPARE_SHA1_HASH:
                        dwPropId = CERT_SHA1_HASH_PROP_ID;
                        break;
                    case CERT_COMPARE_SIGNATURE_HASH:
                        dwPropId = CERT_SIGNATURE_HASH_PROP_ID;
                        break;
                    case CERT_COMPARE_KEY_IDENTIFIER:
                        dwPropId = CERT_KEY_IDENTIFIER_PROP_ID;
                        break;
                    case CERT_COMPARE_MD5_HASH:
                    default:
                        dwPropId = CERT_MD5_HASH_PROP_ID;
                }
                return CompareCertHash(pCert, dwPropId,
                    (PCRYPT_HASH_BLOB) pvFindPara);
            }
            break;

        case CERT_COMPARE_NAME:
            {
                PCERT_NAME_BLOB pName;
                DWORD dwInfo = pFindInfo->dwFindType & 0xFF;
                DWORD dwCertEncodingType =
                    pFindInfo->dwMsgAndCertEncodingType &
                        CERT_ENCODING_TYPE_MASK;

                if (dwInfo == CERT_INFO_SUBJECT_FLAG)
                    pName = &pCert->pCertInfo->Subject;
                else if (dwInfo == CERT_INFO_ISSUER_FLAG)
                    pName = &pCert->pCertInfo->Issuer;
                else goto BadParameter;

                return dwCertEncodingType == pCert->dwCertEncodingType &&
                        CertCompareCertificateName(dwCertEncodingType,
                            pName, (PCERT_NAME_BLOB) pvFindPara);
            }
            break;

        case CERT_COMPARE_ATTR:
            {
                PCERT_NAME_BLOB pName;
                DWORD dwInfo = pFindInfo->dwFindType & 0xFF;
                DWORD dwCertEncodingType =
                    pFindInfo->dwMsgAndCertEncodingType &
                        CERT_ENCODING_TYPE_MASK;

                if (dwInfo == CERT_INFO_SUBJECT_FLAG)
                    pName = &pCert->pCertInfo->Subject;
                else if (dwInfo == CERT_INFO_ISSUER_FLAG)
                    pName = &pCert->pCertInfo->Issuer;
                else goto BadParameter;

                return dwCertEncodingType == pCert->dwCertEncodingType &&
                        CertIsRDNAttrsInCertificateName(dwCertEncodingType,
                            pFindInfo->dwFindFlags, pName,
                        (PCERT_RDN) pvFindPara);
            }
            break;

        case CERT_COMPARE_PROPERTY:
            {
                DWORD dwPropId = *((DWORD *) pvFindPara);
                DWORD cbData = 0;
                return CertGetCertificateContextProperty(
                        pCert,
                        dwPropId,
                        NULL,       //pvData
                        &cbData);
            }
            break;

        case CERT_COMPARE_PUBLIC_KEY:
            {
                return CertComparePublicKeyInfo(
                        pCert->dwCertEncodingType,
                        &pCert->pCertInfo->SubjectPublicKeyInfo,
                        (PCERT_PUBLIC_KEY_INFO) pvFindPara);
            }
            break;

        case CERT_COMPARE_NAME_STR_A:
        case CERT_COMPARE_NAME_STR_W:
            {
                PCERT_NAME_BLOB pName;
                DWORD dwInfo = pFindInfo->dwFindType & 0xFF;
                DWORD dwCertEncodingType =
                    pFindInfo->dwMsgAndCertEncodingType &
                        CERT_ENCODING_TYPE_MASK;

                if (dwInfo == CERT_INFO_SUBJECT_FLAG)
                    pName = &pCert->pCertInfo->Subject;
                else if (dwInfo == CERT_INFO_ISSUER_FLAG)
                    pName = &pCert->pCertInfo->Issuer;
                else goto BadParameter;

                if (dwCertEncodingType == pCert->dwCertEncodingType) {
                    if (dwCmp == CERT_COMPARE_NAME_STR_W)
                        return CompareNameStrW(dwCertEncodingType,
                                pName, (LPCWSTR) pvFindPara);
                    else
                        return CompareNameStrA(dwCertEncodingType,
                                pName, (LPCSTR) pvFindPara);
                } else
                    return FALSE;
            }
            break;

        case CERT_COMPARE_KEY_SPEC:
            {
                DWORD dwKeySpec;
                DWORD cbData = sizeof(dwKeySpec);

                return CertGetCertificateContextProperty(
                            pCert,
                            CERT_KEY_SPEC_PROP_ID,
                            &dwKeySpec,
                            &cbData) &&
                        dwKeySpec == *((DWORD *) pvFindPara);
            }
            break;

#ifdef CAPI_INCLUDE_CTL
        case CERT_COMPARE_CTL_USAGE:
            return CompareCertUsage(pCert, pFindInfo->dwFindFlags,
                (PCTL_USAGE) pvFindPara);
            break;
#endif
        case CERT_COMPARE_SUBJECT_CERT:
            {
                DWORD dwCertEncodingType =
                    pFindInfo->dwMsgAndCertEncodingType &
                        CERT_ENCODING_TYPE_MASK;
                PCERT_INFO pCertId = (PCERT_INFO) pvFindPara;

                return dwCertEncodingType == pCert->dwCertEncodingType &&
                    CertCompareCertificate(
                        dwCertEncodingType,
                        pCertId,
                        pCert->pCertInfo);
            }
            break;

        case CERT_COMPARE_ISSUER_OF:
            {
                PCCERT_CONTEXT pSubject =
                    (PCCERT_CONTEXT) pvFindPara;
                return pSubject->dwCertEncodingType ==
                        pCert->dwCertEncodingType &&
                    CertCompareCertificateName(
                        pSubject->dwCertEncodingType,
                        &pSubject->pCertInfo->Issuer,
                        &pCert->pCertInfo->Subject);
            }
            break;

        case CERT_COMPARE_EXISTING:
            return IsSameCert((PCCERT_CONTEXT) pvFindPara, pCert);
            break;

#ifdef CMS_PKCS7
        case CERT_COMPARE_CERT_ID:
            {
                PCERT_ID pCertId = (PCERT_ID) pvFindPara;
                switch (pCertId->dwIdChoice) {
                    case CERT_ID_ISSUER_SERIAL_NUMBER:
                        {
                            PCRYPT_INTEGER_BLOB pCertSerialNumber =
                                &pCert->pCertInfo->SerialNumber;
                            PCERT_NAME_BLOB pCertIssuer =
                                &pCert->pCertInfo->Issuer;

                            PCRYPT_INTEGER_BLOB pParaSerialNumber =
                                &pCertId->IssuerSerialNumber.SerialNumber;
                            PCERT_NAME_BLOB pParaIssuer =
                                &pCertId->IssuerSerialNumber.Issuer;

                            if (CertCompareIntegerBlob(pCertSerialNumber,
                                    pParaSerialNumber)
                                        &&
                                pCertIssuer->cbData == pParaIssuer->cbData
                                        &&
                                memcmp(pCertIssuer->pbData,
                                    pParaIssuer->pbData,
                                        pCertIssuer->cbData) == 0)
                                return TRUE;
                            else
                                return FALSE;
                        }
                        break;
                    case CERT_ID_KEY_IDENTIFIER:
                        return CompareCertHash(pCert,
                            CERT_KEY_IDENTIFIER_PROP_ID,
                            &pCertId->KeyId
                            );
                        break;
                    case CERT_ID_SHA1_HASH:
                        return CompareCertHash(pCert,
                            CERT_SHA1_HASH_PROP_ID,
                            &pCertId->HashId
                            );
                        break;
                    default:
                        goto BadParameter;
                }
            }
            break;
#endif  // CMS_PKCS7

        default:
            goto BadParameter;
    }

BadParameter:
    SetLastError((DWORD) E_INVALIDARG);
    return FALSE;
}

STATIC BOOL IsNewerCertElement(
    IN PCONTEXT_ELEMENT pNewEle,
    IN PCONTEXT_ELEMENT pExistingEle
    )
{
    PCCERT_CONTEXT pNewCert = ToCertContext(pNewEle);
    PCCERT_CONTEXT pExistingCert = ToCertContext(pExistingEle);

    // CompareFileTime returns +1 if first time > second time
    return (0 < CompareFileTime(
        &pNewCert->pCertInfo->NotBefore,
        &pExistingCert->pCertInfo->NotBefore
        ));
}

#ifdef CAPI_INCLUDE_CRL
//+=========================================================================
//  CRL_CONTEXT Functions
//==========================================================================

// pbCrlEncoded has already been allocated
STATIC PCONTEXT_ELEMENT CreateCrlElement(
    IN PCERT_STORE pStore,
    IN DWORD dwCertEncodingType,
    IN BYTE *pbCrlEncoded,
    IN DWORD cbCrlEncoded
    )
{
    PCONTEXT_ELEMENT pEle = NULL;
    PCRL_CONTEXT pCrl;
    PCRL_CONTEXT_SUFFIX pCrlSuffix;
    PCRL_INFO pInfo = NULL;

    if (0 == GET_CERT_ENCODING_TYPE(dwCertEncodingType)) {
        SetLastError((DWORD) E_INVALIDARG);
        goto ErrorReturn;
    }

    cbCrlEncoded = AdjustEncodedLength(
        dwCertEncodingType, pbCrlEncoded, cbCrlEncoded);

    if (NULL == (pInfo = (PCRL_INFO) AllocAndDecodeObject(
            dwCertEncodingType,
            X509_CERT_CRL_TO_BE_SIGNED,
            pbCrlEncoded,
            cbCrlEncoded))) goto ErrorReturn;

    // Allocate and initialize the CRL element structure
    pEle = (PCONTEXT_ELEMENT) PkiZeroAlloc(sizeof(CONTEXT_ELEMENT) +
        sizeof(CRL_CONTEXT) + sizeof(CRL_CONTEXT_SUFFIX));
    if (pEle == NULL) goto ErrorReturn;

    pEle->dwElementType = ELEMENT_TYPE_CACHE;
    pEle->dwContextType = CERT_STORE_CRL_CONTEXT - 1;
    pEle->lRefCnt = 1;
    pEle->pEle = pEle;
    pEle->pStore = pStore;
    pEle->pProvStore = pStore;

    pCrl = (PCRL_CONTEXT) ToCrlContext(pEle);
    pCrl->dwCertEncodingType =
        dwCertEncodingType & CERT_ENCODING_TYPE_MASK;
    pCrl->pbCrlEncoded = pbCrlEncoded;
    pCrl->cbCrlEncoded = cbCrlEncoded;
    pCrl->pCrlInfo = pInfo;
    pCrl->hCertStore = (HCERTSTORE) pStore;

    pCrlSuffix = ToCrlContextSuffix(pEle);
    pCrlSuffix->ppSortedEntry = NULL;

CommonReturn:
    return pEle;

ErrorReturn:
    if (pEle) {
        PkiFree(pEle);
        pEle = NULL;
    }
    PkiFree(pInfo);
    goto CommonReturn;
}

STATIC void FreeCrlElement(IN PCONTEXT_ELEMENT pEle)
{
    PCCRL_CONTEXT pCrl = ToCrlContext(pEle);
    PCRL_CONTEXT_SUFFIX pCrlSuffix = ToCrlContextSuffix(pEle);
    PkiFree(pCrl->pbCrlEncoded);
    PkiFree(pCrl->pCrlInfo);
    PkiFree(pCrlSuffix->ppSortedEntry);
    PkiFree(pEle);
}

STATIC BOOL CompareCrlElement(
    IN PCONTEXT_ELEMENT pEle,
    IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
    IN BOOL fArchived
    )
{
    PCCRL_CONTEXT pCrl = ToCrlContext(pEle);
    DWORD dwFindType = pFindInfo->dwFindType;
    const void *pvFindPara = pFindInfo->pvFindPara;

    if (fArchived)
        return FALSE;

    switch (dwFindType) {
        case CRL_FIND_ANY:
            return TRUE;
            break;

        case CRL_FIND_ISSUED_BY:
            {
                PCCERT_CONTEXT pIssuer = (PCCERT_CONTEXT) pvFindPara;
                return (NULL == pIssuer) || (
                    pIssuer->dwCertEncodingType == pCrl->dwCertEncodingType &&
                    CertCompareCertificateName(
                        pIssuer->dwCertEncodingType,
                        &pCrl->pCrlInfo->Issuer,
                        &pIssuer->pCertInfo->Subject));
            }
            break;

        case CRL_FIND_EXISTING:
            {
                PCCRL_CONTEXT pNew = (PCCRL_CONTEXT) pvFindPara;
                return pNew->dwCertEncodingType == pCrl->dwCertEncodingType &&
                    CertCompareCertificateName(
                        pNew->dwCertEncodingType,
                        &pCrl->pCrlInfo->Issuer,
                        &pNew->pCrlInfo->Issuer);
            }
            break;

        default:
            goto BadParameter;
    }

BadParameter:
    SetLastError((DWORD) E_INVALIDARG);
    return FALSE;
}

STATIC BOOL IsNewerCrlElement(
    IN PCONTEXT_ELEMENT pNewEle,
    IN PCONTEXT_ELEMENT pExistingEle
    )
{
    PCCRL_CONTEXT pNewCrl = ToCrlContext(pNewEle);
    PCCRL_CONTEXT pExistingCrl = ToCrlContext(pExistingEle);

    // CompareFileTime returns +1 if first time > second time
    return (0 < CompareFileTime(
        &pNewCrl->pCrlInfo->ThisUpdate,
        &pExistingCrl->pCrlInfo->ThisUpdate
        ));
}
#endif // CAPI_INCLUDE_CRL

#ifdef CAPI_INCLUDE_CTL
//+=========================================================================
//  CTL_CONTEXT Functions
//==========================================================================

//+-------------------------------------------------------------------------
//  If both msg and cert encoding types are present, or neither are present,
//  return without any changes. Otherwise, set the missing encoding type
//  with the encoding type that is present.
//--------------------------------------------------------------------------
STATIC DWORD GetCtlEncodingType(IN DWORD dwMsgAndCertEncodingType)
{
    if (0 == dwMsgAndCertEncodingType)
        return 0;
    else if (0 == (dwMsgAndCertEncodingType & CMSG_ENCODING_TYPE_MASK))
        return dwMsgAndCertEncodingType |
            ((dwMsgAndCertEncodingType << 16) & CMSG_ENCODING_TYPE_MASK);
    else if (0 == (dwMsgAndCertEncodingType & CERT_ENCODING_TYPE_MASK))
        return dwMsgAndCertEncodingType |
            ((dwMsgAndCertEncodingType >> 16) & CERT_ENCODING_TYPE_MASK)