al descriptor if found, otherwise NULL

--*/
{
    ULONG i, j, hit;

    hit = 0;
    for (i = 0; i < ResList->Count; i++) {
        for (j = 0; j < ResList->List[i].PartialResourceList.Count; j++) {
            if (ResList->List[i].PartialResourceList.PartialDescriptors[j].Type == Type) {
                if (hit == *Count) {
                    (*Count)++;
                    return &ResList->List[i].PartialResourceList.PartialDescriptors[j];
                } else {
                    hit++;
                }
            }
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\port\ops.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

  ops.c

Abstract:

    video port stub routines for memory and io.

Author:

    Andre Vachon (andreva) 22-Feb-1997

Environment:

    kernel mode only

Notes:

    This module is a driver which implements OS dependant functions on the
    behalf of the video drivers

Revision History:

--*/

#include "videoprt.h"

#pragma alloc_text(PAGE,VideoPortGetAssociatedDeviceExtension)
#pragma alloc_text(PAGE,VideoPortAcquireDeviceLock)
#pragma alloc_text(PAGE,VideoPortReleaseDeviceLock)
#pragma alloc_text(PAGE,VideoPortGetRomImage)
#pragma alloc_text(PAGE,VpGetBusInterface)
#pragma alloc_text(PAGE,VideoPortGetVgaStatus)
#pragma alloc_text(PAGE,pVideoPortGetVgaStatusPci)

//
//ULONG
//VideoPortCompareMemory (
//    PVOID Source1,
//    PVOID Source2,
//    ULONG Length
//    )
//Forwarded to RtlCompareMemory(Source1,Source2,Length);
//


VP_STATUS
VideoPortDisableInterrupt(
    IN PVOID HwDeviceExtension
    )

/*++

Routine Description:

    VideoPortDisableInterrupt allows a miniport driver to disable interrupts
    from its adapter. This means that the interrupts coming from the device
    will be ignored by the operating system and therefore not forwarded to
    the driver.

    A call to this function is valid only if the interrupt is defined, in
    other words, if the appropriate data was provided at initialization
    time to set up the interrupt.  Interrupts will remain disabled until
    they are reenabled using the VideoPortEnableInterrupt function.

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

Return Value:

    NO_ERROR if the function completes successfully.

    ERROR_INVALID_FUNCTION if the interrupt cannot be disabled because it
      was not set up at initialization.

--*/

{

    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    //
    // Only perform this operation if the interurpt is actually connected.
    //

    if (fdoExtension->InterruptObject) {

        HalDisableSystemInterrupt(fdoExtension->InterruptVector,
                                  fdoExtension->InterruptIrql);

        fdoExtension->InterruptsEnabled = FALSE;

        return NO_ERROR;

    } else {

        return ERROR_INVALID_FUNCTION;

    }

} // VideoPortDisableInterrupt()


VP_STATUS
VideoPortEnableInterrupt(
    IN PVOID HwDeviceExtension
    )

/*++

Routine Description:

    VideoPortEnableInterrupt allows a miniport driver to enable interrupts
    from its adapter.  A call to this function is valid only if the
    interrupt is defined, in other words, if the appropriate data was
    provided at initialization time to set up the interrupt.

    This function is used to re-enable interrupts if they have been disabled
    using VideoPortDisableInterrupt.

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

Return Value:

    NO_ERROR if the function completes successfully.

    ERROR_INVALID_FUNCTION if the interrupt cannot be disabled because it
        was not set up at initialization.


--*/

{

    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    //
    // Only perform this operation if the interurpt is actually connected.
    //

    if (fdoExtension->InterruptObject) {

        fdoExtension->InterruptsEnabled = TRUE;

        HalEnableSystemInterrupt(fdoExtension->InterruptVector,
                                 fdoExtension->InterruptIrql,
                                 fdoExtension->InterruptMode);

        return NO_ERROR;

    } else {

        return ERROR_INVALID_FUNCTION;

    }

} // VideoPortEnableInterrupt()

PVOID
VideoPortGetRomImage(
    IN PVOID HwDeviceExtension,
    IN PVOID Unused1,
    IN ULONG Unused2,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine allows a miniport driver to get a copy of its devices
    ROM.  This function returns the pointer to a buffer containing the
    devices ROM.

Arguments;

    HwDeviceExtension - Points to the miniport driver's device extension.

    Unused1 - Reserved for future use.  Must be NULL.  (Buffer)

    Unused2 - Reserved for future use.  Must be zero.  (Offset)

    Length - Number of bytes to return.

--*/

{
    return NULL;
}


ULONG
VideoPortGetBusData(
    PVOID HwDeviceExtension,
    IN BUS_DATA_TYPE BusDataType,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    //
    // Issue a warning telling the miniport they should not read everything
    // out of the driver config space otherwise it causes some device like
    // NCR SCSIs to crash.
    //

#if DBG
    if ((BusDataType == PCIConfiguration) &&
        (Length >= sizeof(PCI_COMMON_CONFIG)))
    {
        pVideoDebugPrint((0, "A miniport must only call VideoPortGetBusData with PCI_COMMON_HDR_LENGTH\n"));
        DbgBreakPoint();
    }
#endif

    if ((fdoExtension->Flags & LEGACY_DRIVER) ||
        (BusDataType != PCIConfiguration)) {
        
#if defined(NO_LEGACY_DRIVERS)
        pVideoDebugPrint((0, "VideoPortGetBusData: fdoExtension->Flags & LEGACY_DRIVER not supported for 64-bits.\n"));
        
        return 0;
        
#else    
        return HalGetBusDataByOffset(BusDataType,
                                     fdoExtension->SystemIoBusNumber,
                                     SlotNumber,
                                     Buffer,
                                     Offset,
                                     Length);        
#endif // NO_LEGACY_DRIVERS

    } else {

        if (fdoExtension->ValidBusInterface) {
            Length = fdoExtension->BusInterface.GetBusData(
                         fdoExtension->BusInterface.Context,
                         PCI_WHICHSPACE_CONFIG,
                         Buffer,
                         Offset,
                         Length);

            return Length;
        } else {
            return 0;
        }
    }

} // end VideoPortGetBusData()


//
//UCHAR
//VideoPortGetCurrentIrql(
//    )
//Forwarded to KeGetCurrentIrql();
//


//
//VOID
//VideoPortMoveMemory(
//    IN PVOID Destination,
//    IN PVOID Source,
//    IN ULONG Length
//    )
//
//Forwarded to RtlMoveMemory(Destination,Source,Length);
//


//
// ALL the functions to read ports and registers are forwarded on free
// builds on x86 and ALPHA to the appropriate kernel function.
// This saves time and memory
//

#if (DBG || (!defined(_X86_) && !defined(_ALPHA_)))

UCHAR
VideoPortReadPortUchar(
    IN PUCHAR Port
    )

/*++

Routine Description:

    VideoPortReadPortUchar reads a byte from the specified port address.
    It requires a logical port address obtained from VideoPortGetDeviceBase.

Arguments:

    Port - Specifies the port address.

Return Value:

    This function returns the byte read from the specified port address.

--*/

{

    UCHAR temp;

    IS_ACCESS_RANGES_DEFINED()

    temp = READ_PORT_UCHAR(Port);

    pVideoDebugPrint((3,"VideoPortReadPortUchar %x = %x\n", Port, temp));

    return(temp);

} // VideoPortReadPortUchar()

USHORT
VideoPortReadPortUshort(
    IN PUSHORT Port
    )

/*++

Routine Description:

    VideoPortReadPortUshort reads a word from the specified port address.
    It requires a logical port address obtained from VideoPortGetDeviceBase.

Arguments:

    Port - Specifies the port address.


Return Value:

    This function returns the word read from the specified port address.

--*/

{

    USHORT temp;

    IS_ACCESS_RANGES_DEFINED()

    temp = READ_PORT_USHORT(Port);

    pVideoDebugPrint((3,"VideoPortReadPortUshort %x = %x\n", Port, temp));

    return(temp);

} // VideoPortReadPortUshort()

ULONG
VideoPortReadPortUlong(
    IN PULONG Port
    )

/*++

Routine Description:

    VideoPortReadPortUlong reads a double word from the specified port
    address.  It requires a logical port address obtained from
    VideoPortGetDeviceBase.

Arguments:

    Port - Specifies the port address.

Return Value:

    This function returns the double word read from the specified port address.

--*/

{

    ULONG temp;

    IS_ACCESS_RANGES_DEFINED()

    temp = READ_PORT_ULONG(Port);

    pVideoDebugPrint((3,"VideoPortReadPortUlong %x = %x\n", Port, temp));

    return(temp);

} // VideoPortReadPortUlong()

VOID
VideoPortReadPortBufferUchar(
    IN PUCHAR Port,
    IN PUCHAR Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    VideoPortReadPortBufferUchar reads a number of bytes from a single port
    into a buffer.  It requires a logical port address obtained from
    VideoPortGetDeviceBase.

Arguments:

    Port - Specifies the port address.

    Buffer - Points to an array of UCHAR values into which the values are
        stored.

    Count - Specifes the number of bytes to be read into the buffer.

Return Value:

    None.

--*/

{
    pVideoDebugPrint((3,"VideoPortReadPortBufferUchar %x\n", Port));

    IS_ACCESS_RANGES_DEFINED()

    READ_PORT_BUFFER_UCHAR(Port, Buffer, Count);

} // VideoPortReadPortBufferUchar()

VOID
VideoPortReadPortBufferUshort(
    IN PUSHORT Port,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    VideoPortReadPortBufferUshort reads a number of words from a single port
    into a buffer.  It requires a logical port address obtained from
    VideoPortGetDeviceBase.

Arguments:

    Port - Specifies the port address.

    Buffer - Points to an array of words into which the values are stored.

    Count - Specifies the number of words to be read into the buffer.

Return Value:

    None.

--*/

{
    pVideoDebugPrint((3,"VideoPortReadPortBufferUshort %x\n", Port));

    IS_ACCESS_RANGES_DEFINED()

    READ_PORT_BUFFER_USHORT(Port, Buffer, Count);

} // VideoPortReadPortBufferUshort()

VOID
VideoPortReadPortBufferUlong(
    IN PULONG Port,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    VideoPortReadPortBufferUlong reads a number of double words from a
    single port into a buffer.  It requires a logical port address obtained
    from VideoPortGetDeviceBase.

Arguments:

    Port - Specifies the port address.

    Buffer - Points to an array of double words into which the values are
        stored.

    Count - Specifies the number of double words to be read into the buffer.

Return Value:

    None.

--*/

{

    pVideoDebugPrint((3,"VideoPortReadPortBufferUlong %x\n", Port));

    IS_ACCESS_RANGES_DEFINED()

    READ_PORT_BUFFER_ULONG(Port, Buffer, Count);

} // VideoPortReadPortBufferUlong()

UCHAR
VideoPortReadRegisterUchar(
    IN PUCHAR Register
    )

/*++

Routine Description:

    VideoPortReadRegisterUchar reads a byte from the specified register
    address.  It requires a logical port address obtained from
    VideoPortGetDeviceBase.

Arguments:

    Register - Specifies the register address.

Return Value:

    This function returns the byte read from the specified register address.

--*/

{

    UCHAR temp;

    IS_ACCESS_RANGES_DEFINED()

    temp = READ_REGISTER_UCHAR(Register);

    pVideoDebugPrint((3,"VideoPortReadRegisterUchar %x = %x\n", Register, temp));

    return(temp);

} // VideoPortReadRegisterUchar()

USHORT
VideoPortReadRegisterUshort(
    IN PUSHORT Register
    )

/*++

Routine Description:

    VideoPortReadRegisterUshort reads a word from the specified register
    address.  It requires a logical port address obtained from
    VideoPortGetDeviceBase.

Arguments:

    Register - Specifies the register address.

Return Value:

    This function returns the word read from the specified register address.

--*/

{

    USHORT temp;

    IS_ACCESS_RANGES_DEFINED()

    temp = READ_REGISTER_USHORT(Register);

    pVideoDebugPrint((3,"VideoPortReadRegisterUshort %x = %x\n", Register, temp));

    return(temp);

} // VideoPortReadRegisterUshort()

ULONG
VideoPortReadRegisterUlong(
    IN PULONG Register
    )

/*++

Routine Description:

    VideoPortReadRegisterUlong reads a double word from the specified
    register address.  It requires a logical port address obtained from
    VideoPortGetDeviceBase.

Arguments:

    Register - Specifies the register address.

Return Value:

    This function returns the double word read from the specified register
    address.

--*/

{

    ULONG temp;

    IS_ACCESS_RANGES_DEFINED()

    temp = READ_REGISTER_ULONG(Register);

    pVideoDebugPrint((3,"VideoPortReadRegisterUlong %x = %x\n", Register, temp));

    return(temp);

} // VideoPortReadRegisterUlong()

VOID
VideoPortReadRegisterBufferUchar(
    IN PUCHAR Register,
    IN PUCHAR Buffer,
    IN ULONG  Count
    )

/*++

Routine Description:

    Read a buffer of unsigned bytes from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    IS_ACCESS_RANGES_DEFINED()

    READ_REGISTER_BUFFER_UCHAR(Register, Buffer, Count);

}

VOID
VideoPortReadRegisterBufferUshort(
    IN PUSHORT Register,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Read a buffer of unsigned shorts from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    IS_ACCESS_RANGES_DEFINED()

    READ_REGISTER_BUFFER_USHORT(Register, Buffer, Count);

}

VOID
VideoPortReadRegisterBufferUlong(
    IN PULONG Register,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Read a buffer of unsigned longs from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    IS_ACCESS_RANGES_DEFINED()

    READ_REGISTER_BUFFER_ULONG(Register, Buffer, Count);

}

#endif // (DBG || (!defined(_X86_) && !defined(_ALPHA_)))


ULONG
VideoPortSetBusData(
    PVOID HwDeviceExtension,
    IN BUS_DATA_TYPE BusDataType,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )

{

    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    if ((fdoExtension->Flags & LEGACY_DRIVER) ||
        (BusDataType != PCIConfiguration)) {

#if defined(NO_LEGACY_DRIVERS)
    pVideoDebugPrint((0, "VideoPortGetBusData: fdoExtension->Flags & LEGACY_DRIVER not supported for 64-bits.\n"));

    return 0;

#else

        return HalSetBusDataByOffset(BusDataType,
                                     fdoExtension->SystemIoBusNumber,
                                     SlotNumber,
                                     Buffer,
                                     Offset,
                                     Length);
#endif // NO_LEGACY_DRIVERS

    } else {

        if (fdoExtension->ValidBusInterface) {
            Length = fdoExtension->BusInterface.SetBusData(
                         fdoExtension->BusInterface.Context,
                         PCI_WHICHSPACE_CONFIG,
                         Buffer,
                         Offset,
                         Length);

            return Length;
        } else {
            return 0;
        }
    }

} // end VideoPortSetBusData()


//
//VOID
//VideoPortStallExecution(
//    IN ULONG Microseconds
//    )
//
//Forwarded to KeStallExecutionProcessor(Microseconds);
//



//
// ALL the functions to write ports and registers are forwarded on free
// builds on x86 to the appropriate kernel function.
// This saves time and memory
//

#if (DBG || (!defined(_X86_) && !defined(_ALPHA_)))

VOID
VideoPortWritePortUchar(
    IN PUCHAR Port,
    IN UCHAR Value
    )

/*++

Routine Description:

    VideoPortWritePortUchar writes a byte to the specified port address.  It
    requires a logical port address obtained from VideoPortGetDeviceBase.

Arguments:

    Port - Specifies the port address.

    Value - Specifies a byte to be written to the port.

Return Value:

    None.

--*/

{
    pVideoDebugPrint((3,"VideoPortWritePortUchar %x %x\n", Port, Value));

    IS_ACCESS_RANGES_DEFINED()

    WRITE_PORT_UCHAR(Port, Value);

} // VideoPortWritePortUchar()

VOID
VideoPortWritePortUshort(
    IN PUSHORT Port,
    IN USHORT Value
    )

/*++

Routine Description:

    VideoPortWritePortUshort writes a word to the specified port address.  It
    requires a logical port address obtained from VideoPortGetDeviceBase.

Arguments:

    Port - Specifies the port address.

    Value - Specifies a word to be written to the port.

Return Value:

    None.

--*/

{
    pVideoDebugPrint((3,"VideoPortWritePortUhort %x %x\n", Port, Value));

    IS_ACCESS_RANGES_DEFINED()

    WRITE_PORT_USHORT(Port, Value);

} // VideoPortWritePortUshort()

VOID
VideoPortWritePortUlong(
    IN PULONG Port,
    IN ULONG Value
    )

/*++

Routine Description:

    VideoPortWritePortUlong writes a double word to the specified port address.
    It requires a logical port address obtained from VideoPortGetDeviceBase.

Arguments:

    Port - Specifies the port address.

    Value - Specifies a double word to be written to the port.

Return Value:

    None.

--*/

{

    pVideoDebugPrint((3,"VideoPortWritePortUlong %x %x\n", Port, Value));

    IS_ACCESS_RANGES_DEFINED()

    WRITE_PORT_ULONG(Port, Value);

} // VideoPortWritePortUlong()

VOID
VideoPortWritePortBufferUchar(
    IN PUCHAR Port,
    IN PUCHAR Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    VideoPortWritePortBufferUchar writes a number of bytes to a
    specific port.  It requires a logical port address obtained from
    VideoPortGetDeviceBase.

Arguments:

    Port - Specifies the port address.

    Buffer - Points to an array of bytes to be written.

    Count - Specifies the number of bytes to be written to the buffer.

Return Value:

    None.

--*/

{

    pVideoDebugPrint((3,"VideoPortWritePortBufferUchar  %x \n", Port));

    IS_ACCESS_RANGES_DEFINED()

    WRITE_PORT_BUFFER_UCHAR(Port, Buffer, Count);

} // VideoPortWritePortBufferUchar()

VOID
VideoPortWritePortBufferUshort(
    IN PUSHORT Port,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    VideoPortWritePortBufferUshort writes a number of words to a
    specific port.  It requires a logical port address obtained from
    VideoPortGetDeviceBase.

Arguments:

    Port - Specifies the port address.

    Buffer - Points to an array of words to be written.

    Count - Specifies the number of words to be written to the buffer.

Return Value:

    None.

--*/

{

    pVideoDebugPrint((3,"VideoPortWritePortBufferUshort  %x \n", Port));

    IS_ACCESS_RANGES_DEFINED()

    WRITE_PORT_BUFFER_USHORT(Port, Buffer, Count);

} // VideoPortWritePortBufferUshort()

VOID
VideoPortWritePortBufferUlong(
    IN PULONG Port,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    VideoPortWritePortBufferUlong writes a number of double words to a
    specific port.  It requires a logical port address obtained from
    VideoPortGetDeviceBase.

Arguments:

    Port - Specifies the port address.

    Buffer - Points to an array of double word to be written.

    Count - Specifies the number of double words to be written to the buffer.
Return Value:

    None.

--*/

{
    pVideoDebugPrint((3,"VideoPortWriteBufferUlong  %x \n", Port));

    IS_ACCESS_RANGES_DEFINED()

    WRITE_PORT_BUFFER_ULONG(Port, Buffer, Count);

} // VideoPortWritePortBufferUlong()

VOID
VideoPortWriteRegisterUchar(
    IN PUCHAR Register,
    IN UCHAR Value
    )

/*++

Routine Description:

    VideoPortWriteRegisterUchar writes a byte to the specified
    register address.  It requires a logical port address obtained
    from VideoPortGetDeviceBase.

Arguments:

    Register - Specifies the register address.

    Value - Specifies a byte to be written to the register.

Return Value:

    None.

--*/

{

    pVideoDebugPrint((3,"VideoPortWritePortRegisterUchar  %x \n", Register));

    IS_ACCESS_RANGES_DEFINED()

    WRITE_REGISTER_UCHAR(Register, Value);

} // VideoPortWriteRegisterUchar()

VOID
VideoPortWriteRegisterUshort(
    IN PUSHORT Register,
    IN USHORT Value
    )

/*++

Routine Description:

    VideoPortWriteRegisterUshort writes a word to the specified
    register address.  It requires a logical port address obtained
    from VideoPortGetDeviceBase.

Arguments:

    Register - Specifies the register address.

    Value - Specifies a word to be written to the register.

Return Value:

    None.

--*/

{

    pVideoDebugPrint((3,"VideoPortWritePortRegisterUshort  %x \n", Register));

    IS_ACCESS_RANGES_DEFINED()

    WRITE_REGISTER_USHORT(Register, Value);

} // VideoPortWriteRegisterUshort()

VOID
VideoPortWriteRegisterUlong(
    IN PULONG Register,
    IN ULONG Value
    )

/*++

Routine Description:

    VideoPortWriteRegisterUlong writes a double word to the
    specified register address.  It requires a logical port
    address obtained from VideoPortGetDeviceBase.

Arguments:

    Register - Specifies the register address.

    Value - Specifies a double word to be written to the register.

Return Value:

    None.

--*/

{

    pVideoDebugPrint((3,"VideoPortWritePortRegisterUlong  %x \n", Register));

    IS_ACCESS_RANGES_DEFINED()

    WRITE_REGISTER_ULONG(Register, Value);

} // VideoPortWriteRegisterUlong()


VOID
VideoPortWriteRegisterBufferUchar(
    IN PUCHAR Register,
    IN PUCHAR Buffer,
    IN ULONG  Count
    )

/*++

Routine Description:

    Write a buffer of unsigned bytes from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    IS_ACCESS_RANGES_DEFINED()

    WRITE_REGISTER_BUFFER_UCHAR(Register, Buffer, Count);

}

VOID
VideoPortWriteRegisterBufferUshort(
    IN PUSHORT Register,
    IN PUSHORT Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Write a buffer of unsigned shorts from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    IS_ACCESS_RANGES_DEFINED()

    WRITE_REGISTER_BUFFER_USHORT(Register, Buffer, Count);

}

VOID
VideoPortWriteRegisterBufferUlong(
    IN PULONG Register,
    IN PULONG Buffer,
    IN ULONG Count
    )

/*++

Routine Description:

    Write a buffer of unsigned longs from the specified register address.

Arguments:

    Register - Supplies a pointer to the port address.
    Buffer - Supplies a pointer to the data buffer area.
    Count - The count of items to move.

Return Value:

    None

--*/

{

    IS_ACCESS_RANGES_DEFINED()

    WRITE_REGISTER_BUFFER_ULONG(Register, Buffer, Count);

}

#endif // (DBG || (!defined(_X86_) && !defined(_ALPHA_)))

//
//VOID
//VideoPortZeroMemory(
//    IN PVOID Destination,
//    IN ULONG Length
//    )
//
//Forwarded to RtlZeroMemory(Destination,Length);
//

PVOID
VideoPortGetAssociatedDeviceExtension(
    IN PVOID DeviceObject
    )

/*++

Routine Description:

    This routine will return the HwDeviceExtension for the parent of the
    given device object.

Arguments:

    DeviceObject - The child device object (PDO).

Notes:

    This function is useful if you want to get the parent device extension
    for a child device object.  For example this is useful with I2C.

--*/

{
    PFDO_EXTENSION DeviceExtension;

    DeviceExtension = (PFDO_EXTENSION)((PDEVICE_OBJECT)DeviceObject)->DeviceExtension;

    return (PVOID) DeviceExtension->HwDeviceExtension;
}

VOID
VideoPortAcquireDeviceLock(
    IN PVOID HwDeviceExtension
    )

/*++

Routine Description:

    This routine acquires the per device lock maintained by the videoprt.

Arguments:

    HwDeviceExtension - Pointer to the hardware device extension.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    ACQUIRE_DEVICE_LOCK(fdoExtension);
}

VOID
VideoPortReleaseDeviceLock(
    IN PVOID HwDeviceExtension
    )

/*++

Routine Description:

    This routine releases the per device lock maintained by the videoprt.

Arguments:

    HwDeviceExtension - Pointer to the hardware device extension.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    RELEASE_DEVICE_LOCK(fdoExtension);
}

PVOID
VpGetProcAddress(
    IN PVOID HwDeviceExtension,
    IN PUCHAR FunctionName
    )

/*++

Routine Description:

    This routine allows a video miniport to get access to VideoPort
    functions without linking to them directly.  This will allow an NT 5.0
    miniport to take advantage of NT 5.0 features while running on NT 5.0,
    but still retain the ability to load on NT 4.0.

Arguments:

    HwDeviceExtension - Pointer to the hardware device extension.

    FunctionName - pointer to a zero terminated ascii string which contains
        the function name we are looking for.

Returns:

    Pointer to the given function if it exists.
    NULL otherwise.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);
    PPROC_ADDRESS ProcAddress = VideoPortEntryPoints;

    //
    // Since the list of exported functions is small, and this routine
    // will not be called often we can get away with a linear search.
    //

    while (ProcAddress->FunctionName) {

        if (strcmp(ProcAddress->FunctionName, FunctionName) == 0) {
            return ProcAddress->FunctionAddress;
        }

        ProcAddress++;
    }

    return NULL;
}

NTSTATUS
VpGetBusInterface(
    PFDO_EXTENSION FdoExtension
    )

/*++

Routine Description:

    Send a QueryInterface Irp to our parent to retrieve
    the BUS_INTERFACE_STANDARD.

Returns:

    NT_STATUS code

--*/

{
    KEVENT             Event;
    PIRP               QueryIrp = NULL;
    IO_STATUS_BLOCK    IoStatusBlock;
    PIO_STACK_LOCATION NextStack;
    NTSTATUS           Status;

    KeInitializeEvent(&Event, SynchronizationEvent, FALSE);

    QueryIrp = IoBuildSynchronousFsdRequest(IRP_MJ_FLUSH_BUFFERS,
                                            FdoExtension->AttachedDeviceObject,
                                            NULL,
                                            0,
                                            NULL,
                                            &Event,
                                            &IoStatusBlock);

    if (QueryIrp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    QueryIrp->IoStatus.Status = IoStatusBlock.Status = STATUS_NOT_SUPPORTED;

    NextStack = IoGetNextIrpStackLocation(QueryIrp);

    //
    // Set up for a QueryInterface Irp.
    //

    NextStack->MajorFunction = IRP_MJ_PNP;
    NextStack->MinorFunction = IRP_MN_QUERY_INTERFACE;

    NextStack->Parameters.QueryInterface.InterfaceType = &GUID_BUS_INTERFACE_STANDARD;
    NextStack->Parameters.QueryInterface.Size = sizeof(BUS_INTERFACE_STANDARD);
    NextStack->Parameters.QueryInterface.Version = 1;
    NextStack->Parameters.QueryInterface.Interface = (PINTERFACE) &FdoExtension->BusInterface;
    NextStack->Parameters.QueryInterface.InterfaceSpecificData = NULL;

    FdoExtension->BusInterface.Size = sizeof(BUS_INTERFACE_STANDARD);
    FdoExtension->BusInterface.Version = 1;

    Status = IoCallDriver(FdoExtension->AttachedDeviceObject, QueryIrp);

    if (Status == STATUS_PENDING) {
        KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
        Status = IoStatusBlock.Status;
    }

    return Status;
}

//
// ALL the functions to perform interlocked operations are forwarded on free
// builds on x86 and ALPHA to the appropriate kernel function.
// This saves time and memory
//

#if !defined(_X86_)

LONG
FASTCALL
VideoPortInterlockedExchange(
    IN OUT PLONG Target,
    IN LONG Value
    )

{
    return InterlockedExchange(Target, Value);
}

LONG
FASTCALL
VideoPortInterlockedIncrement(
    IN PLONG Addend
    )

{
    return InterlockedIncrement(Addend);
}

LONG
FASTCALL
VideoPortInterlockedDecrement(
    IN PLONG Addend
    )

{
    return InterlockedDecrement(Addend);
}

#endif // !defined(_X86_)

VP_STATUS
VideoPortGetVgaStatus(
    PVOID HwDeviceExtension,
    OUT PULONG VgaStatus
    )

/*++

Routine Description:

    VideoPortGetVgaStatus detect if the calling device is decoding
    Vga IO address

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension
    VgaStatus         - Points to the the result

Return Value:

    NO_ERROR if the function completes successfully.

    ERROR_INVALID_FUNCTION if it is a non-PCI device

--*/
{

    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    //
    // We can not handle legacy devices
    //

    if (fdoExtension->AdapterInterfaceType != PCIBus) { 

        *VgaStatus = 0;

        return ERROR_INVALID_FUNCTION;
    }
    else {

        *VgaStatus = pVideoPortGetVgaStatusPci( HwDeviceExtension );
        return (NO_ERROR);
   
    }
}

#define VGA_STATUS_REGISTER1 0x3DA

ULONG
pVideoPortGetVgaStatusPci(
    PVOID HwDeviceExtension
    )

{

    USHORT Command;
    PCI_COMMON_CONFIG ConfigSpace; 
    PHYSICAL_ADDRESS PhysicalAddress;
    PUCHAR BaseReg;
    ULONG VgaEnable;

    //
    // assume VGA is disabled
    //

    VgaEnable = 0;

    //
    // Get the PCI config for this device
    //

    VideoPortGetBusData( HwDeviceExtension,
                         PCIConfiguration,
                         0,
                         &ConfigSpace,
                         0,
                         PCI_COMMON_HDR_LENGTH);


    if( !(ConfigSpace.Command & PCI_ENABLE_IO_SPACE) ) {

        return VgaEnable;

    }

    if (((ConfigSpace.BaseClass == PCI_CLASS_PRE_20) &&
         (ConfigSpace.SubClass  == PCI_SUBCLASS_PRE_20_VGA)) ||
        ((ConfigSpace.BaseClass == PCI_CLASS_DISPLAY_CTLR) &&
         (ConfigSpace.SubClass  == PCI_SUBCLASS_VID_VGA_CTLR))) {


        //
        // Map the VGA registers we are going to use.
        //

        PhysicalAddress.HighPart = 0;
        PhysicalAddress.LowPart  = VGA_STATUS_REGISTER1;

        BaseReg = VideoPortGetDeviceBase(HwDeviceExtension,
                                         PhysicalAddress,
                                         1,
                                         VIDEO_MEMORY_SPACE_IO);

        if (BaseReg) {

            //
            // If we got here the PCI config space for our device indicates
            // we are the VGA, and we were able to map the VGA resources.
            //

            VgaEnable = DEVICE_VGA_ENABLED;

            VideoPortFreeDeviceBase(HwDeviceExtension, BaseReg);
        }
    }

    return VgaEnable;
}

VOID
pVideoPortDpcDispatcher(
    IN PKDPC Dpc,
    IN PVOID HwDeviceExtension,
    IN PMINIPORT_DPC_ROUTINE DpcRoutine,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine handles DPCs and forwards them to the miniport callback
    routine.

Arguments:

    Dpc - The DPC which is executing.

    HwDeviceExtension - The HwDeviceExtension for the device which scheduled
        the DPC.

    DpcRoutine - The callback in the miniport which needs to be called.

    Context - The miniport supplied context.

Returns:

    None.

--*/

{
    DpcRoutine(HwDeviceExtension, Context);
}

BOOLEAN
VideoPortQueueDpc(
    IN PVOID HwDeviceExtension,
    IN PMINIPORT_DPC_ROUTINE CallbackRoutine,
    IN PVOID Context
    )

/*++

Routine Description:

    Allows a miniport driver to queue a DPC.

Arguments:

    HwDeviceExtension - The HwDeviceExtension for the miniport.

    CallbackRoutine - The entry point within the miniport to call when the DPC
        is scheduled.

    Context - A miniport supplies context which will be passed to the
        CallbackRoutine.

Returns:

    TRUE if successful,
    FALSE otherwise.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    return KeInsertQueueDpc(&fdoExtension->Dpc, CallbackRoutine, Context);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\port\registry.c ===
/*++

Copyright (c) 1992-1999  Microsoft Corporation

Module Name:

    registry.c

Abstract:

    Registry support for the video port driver.

Author:

    Andre Vachon (andreva) 01-Mar-1992

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "videoprt.h"


//
// Local routines.
//

BOOLEAN
CheckIoEnabled(
    PVOID HwDeviceExtension,
    ULONG NumAccessRanges,
    PVIDEO_ACCESS_RANGE AccessRanges
    );

ULONG
GetCmResourceListSize(
    PCM_RESOURCE_LIST CmResourceList
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,VpGetFlags)
#pragma alloc_text(PAGE,VideoPortGetAccessRanges)
#pragma alloc_text(PAGE,VideoPortVerifyAccessRanges)
#pragma alloc_text(PAGE,CheckIoEnabled)
#pragma alloc_text(PAGE,VpAppendToRequirementsList)
#pragma alloc_text(PAGE,VpIsLegacyAccessRange)
#pragma alloc_text(PAGE,GetCmResourceListSize)
#pragma alloc_text(PAGE,VpRemoveFromResourceList)
#pragma alloc_text(PAGE,VpIsVgaResource)
#endif

NTSTATUS
VpGetFlags(
    PUNICODE_STRING RegistryPath,
    PVIDEO_HW_INITIALIZATION_DATA HwInitializationData,
    PULONG Flags
    )

/*++

Routine Description:

    Checks for the existance of the PnP key/value in the device's
    registry path.

Return Value:

    TRUE if the flag exists, FALSE otherwise.

--*/

{
    PWSTR    Path;
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
    ULONG    pnpEnabled = 0;
    ULONG    legacyDetect = 0;
    ULONG    defaultValue = 0;
    ULONG    bootDriver = 0;
    ULONG    reportDevice = 0;
    PWSTR    Table[] = {L"\\Vga", L"\\VgaSave", NULL};
    PWSTR    SubStr, *Item = Table;
    ULONG    Len;

    *Flags = 0;

    Path = ExAllocatePoolWithTag(PagedPool,
                                 RegistryPath->Length + sizeof(UNICODE_NULL),
                                 POOL_TAG);

    if (Path)
    {
        RtlCopyMemory(Path,
                      RegistryPath->Buffer,
                      RegistryPath->Length);

        *(Path + (RegistryPath->Length / sizeof(UNICODE_NULL))) = UNICODE_NULL;

        pVideoDebugPrint((1, "PnP path: %ws\n", Path));

        legacyDetect = FALSE;
        reportDevice = FALSE;

        //
        // If the PnP Entry points are present, then we will treat this
        // driver as a PnP driver.
        //

        if ( (HwInitializationData->HwInitDataSize >=
              FIELD_OFFSET(VIDEO_HW_INITIALIZATION_DATA, HwQueryInterface)) &&
             (HwInitializationData->HwSetPowerState != NULL)                &&
             (HwInitializationData->HwGetPowerState != NULL)                &&
             (HwInitializationData->HwGetVideoChildDescriptor != NULL) )
        {
            pVideoDebugPrint((1, "videoprt: The miniport is a PnP miniport."));

            pnpEnabled = TRUE;
        }

        //
        // REPORT_DEVICE is only valid if PNP_ENABLED is true.
        //
        // We don't want to report a device to the PnP system if
        // we don't have a PnP driver.
        //

        if (!pnpEnabled)
        {
            reportDevice = 0;
        }

        *Flags = (pnpEnabled   ? PNP_ENABLED   : 0) |
                 (legacyDetect ? LEGACY_DETECT : 0) |
                 (reportDevice ? REPORT_DEVICE : 0);

        //
        // Free the memory we allocated above.
        //

        ExFreePool(Path);


        //
        // Determine if the current miniport is the VGA miniport.
        //

        while (*Item) {

            Len = wcslen(*Item);

            SubStr = RegistryPath->Buffer + (RegistryPath->Length / 2) - Len;

            if (!_wcsnicmp(SubStr, *Item, Len)) {

                pVideoDebugPrint((1, "This IS the vga miniport\n"));
                *Flags |= VGA_DRIVER;
                break;
            }

            Item++;
        }

        pVideoDebugPrint((1, "Flags = %d\n", *Flags));

        ntStatus = STATUS_SUCCESS;
    }

    return ntStatus;
}


VIDEOPORT_API
VP_STATUS
VideoPortGetAccessRanges(
    PVOID HwDeviceExtension,
    ULONG NumRequestedResources,
    PIO_RESOURCE_DESCRIPTOR RequestedResources OPTIONAL,
    ULONG NumAccessRanges,
    PVIDEO_ACCESS_RANGE AccessRanges,
    PVOID VendorId,
    PVOID DeviceId,
    PULONG Slot
    )

/*++

Routine Description:

    Walk the appropriate bus to get device information.
    Search for the appropriate device ID.
    Appropriate resources will be returned and automatically stored in the
    resourcemap.

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

    NumRequestedResources - Number of entries in the RequestedResources array.

    RequestedResources - Optional pointer to an array ofRequestedResources
        the miniport driver wants to access.

    NumAccessRanges - Maximum number of access ranges that can be returned
        by the function.

    AccessRanges - Array of access ranges that will be returned to the driver.

    VendorId - Pointer to the vendor ID. On PCI, this is a pointer to a 16 bit
        word.

    DeviceId - Pointer to the Device ID. On PCI, this is a pointer to a 16 bit
        word.

    Slot - Pointer to the starting slot number for this search.

Return Value:

    ERROR_MORE_DATA if the AccessRange structure is not large enough for the
       PCI config info.
    ERROR_DEV_NOT_EXIST is the card is not found.

    NO_ERROR if the function succeded.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    UNICODE_STRING unicodeString;
    ULONG i;
    ULONG j;

    PCM_RESOURCE_LIST cmResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR cmResourceDescriptor;


    VP_STATUS status;
    UCHAR bShare;

    PPCI_SLOT_NUMBER slotData = (PPCI_SLOT_NUMBER)Slot;

    //
    // This is the miniport drivers slot. Allocate the
    // resources.
    //

    // Hack Add extra R so the Device0 key does not get created as volatile
    // a screw up the subsequent driver install.

    *(LPWSTR) (((PUCHAR)fdoExtension->DriverRegistryPath) +
               fdoExtension->DriverRegistryPathLength) = L'R';

    RtlInitUnicodeString(&unicodeString, fdoExtension->DriverRegistryPath);

    //
    // Assert drivers do set those parameters properly
    //

#if DBG

    if ((NumRequestedResources == 0) != (RequestedResources == NULL)) {

        pVideoDebugPrint((0, "VideoPortGetDeviceResources: Parameters for requested resource are inconsistent\n"));

    }

#endif

    //
    // An empty requested resource list means we want to automatic behavoir.
    // Just call the HAL to get all the information
    //

    if (NumRequestedResources == 0) {

        //
        // If a PnP driver is requesting resources, then return what the
        // system passed in to us.
        //

        cmResourceList = fdoExtension->AllocatedResources;

        //
        // Return the slot number to the device.
        //

        if (Slot) {
            *Slot = fdoExtension->SlotNumber;
        }

        if (cmResourceList) {
#if DBG
            DumpResourceList(cmResourceList);
#endif
            status = NO_ERROR;

        } else {

            //
            // The system should always pass us resources.
            //

            ASSERT(FALSE);
            status = ERROR_INVALID_PARAMETER;
        }

    } else {

        PIO_RESOURCE_REQUIREMENTS_LIST requestedResources;
        ULONG requestedResourceSize;
        NTSTATUS ntStatus;

        status = NO_ERROR;

        //
        // The caller has specified some resources.
        // Lets call IoAssignResources with that and see what comes back.
        //

        requestedResourceSize = sizeof(IO_RESOURCE_REQUIREMENTS_LIST) +
                                   ((NumRequestedResources - 1) *
                                   sizeof(IO_RESOURCE_DESCRIPTOR));

        requestedResources = ExAllocatePoolWithTag(PagedPool,
                                                   requestedResourceSize,
                                                   POOL_TAG);

        if (requestedResources) {

            RtlZeroMemory(requestedResources, requestedResourceSize);

            requestedResources->ListSize = requestedResourceSize;
            requestedResources->InterfaceType = fdoExtension->AdapterInterfaceType;
            requestedResources->BusNumber = fdoExtension->SystemIoBusNumber;
            requestedResources->SlotNumber = slotData->u.bits.DeviceNumber;
            requestedResources->AlternativeLists = 1;

            requestedResources->List[0].Version  = 1;
            requestedResources->List[0].Revision = 1;
            requestedResources->List[0].Count    = NumRequestedResources;

            RtlMoveMemory(&(requestedResources->List[0].Descriptors[0]),
                          RequestedResources,
                          NumRequestedResources * sizeof(IO_RESOURCE_DESCRIPTOR));

            ntStatus = IoAssignResources(&unicodeString,
                                         &VideoClassName,
                                         fdoExtension->FunctionalDeviceObject->DriverObject,
                                         fdoExtension->FunctionalDeviceObject,
                                         requestedResources,
                                         &cmResourceList);

            ExFreePool(requestedResources);

            if (!NT_SUCCESS(ntStatus)) {

                status = ERROR_INVALID_PARAMETER;

            }

        } else {

            status = ERROR_NOT_ENOUGH_MEMORY;

        }

    }

    if (status == NO_ERROR) {

        VIDEO_ACCESS_RANGE TempRange;

        //
        // We now have a valid cmResourceList.
        // Lets translate it back to access ranges so the driver
        // only has to deal with one type of list.
        //

        //
        // NOTE: The resources have already been reported at this point in
        // time.
        //

        //
        // Walk resource list to update configuration information.
        //

        for (i = 0, j = 0;
             (i < cmResourceList->List->PartialResourceList.Count) &&
                 (status == NO_ERROR);
             i++) {

            //
            // Get resource descriptor.
            //

            cmResourceDescriptor =
                &cmResourceList->List->PartialResourceList.PartialDescriptors[i];

            //
            // Get the share disposition
            //

            if (cmResourceDescriptor->ShareDisposition == CmResourceShareShared) {

                bShare = 1;

            } else {

                bShare = 0;

            }

            switch (cmResourceDescriptor->Type) {

            case CmResourceTypePort:
            case CmResourceTypeMemory:

                //
                // common part
                //

                TempRange.RangeLength =
                    cmResourceDescriptor->u.Memory.Length;
                TempRange.RangeStart =
                    cmResourceDescriptor->u.Memory.Start;
                TempRange.RangeVisible = 0;
                TempRange.RangeShareable = bShare;
                TempRange.RangePassive = 0;

                //
                // separate part
                //

                if (cmResourceDescriptor->Type == CmResourceTypePort) {
                    TempRange.RangeInIoSpace = 1;
                } else {
                    TempRange.RangeInIoSpace = 0;
                }

                //
                // See if we need to return the resource to the driver.
                //

                if (!VpIsLegacyAccessRange(fdoExtension, &TempRange)) {

                    if (j == NumAccessRanges) {

                        status = ERROR_MORE_DATA;
                        break;

                    } else {

                        //
                        // Only modify the AccessRange array if we are writing
                        // valid data.
                        //

                        AccessRanges[j] = TempRange;
                        j++;
                    }

                }

                break;

            case CmResourceTypeInterrupt:

                fdoExtension->MiniportConfigInfo->BusInterruptVector =
                    cmResourceDescriptor->u.Interrupt.Vector;
                fdoExtension->MiniportConfigInfo->BusInterruptLevel =
                    cmResourceDescriptor->u.Interrupt.Level;
                fdoExtension->MiniportConfigInfo->InterruptShareable =
                    bShare;

                break;

            case CmResourceTypeDma:

                fdoExtension->MiniportConfigInfo->DmaChannel =
                    cmResourceDescriptor->u.Dma.Channel;
                fdoExtension->MiniportConfigInfo->DmaPort =
                    cmResourceDescriptor->u.Dma.Port;
                fdoExtension->MiniportConfigInfo->DmaShareable =
                    bShare;

                break;

            default:

                pVideoDebugPrint((1, "VideoPortGetAccessRanges: Unknown descriptor type %x\n",
                                 cmResourceDescriptor->Type ));

                break;

            }

        }
    }

    // Hack remove extra R

    *(LPWSTR) (((PUCHAR)fdoExtension->DriverRegistryPath) +
               fdoExtension->DriverRegistryPathLength) = UNICODE_NULL;


#if DBG

    if (status == NO_ERROR)
    {
        //
        // Indicates resources have been mapped properly
        //

        InterlockedIncrement(&VPResourcesReported);
    }

#endif

    return status;

} // VideoPortGetDeviceResources()

BOOLEAN
VpIsVgaResource(
    PVIDEO_ACCESS_RANGE AccessRange
    )

/*++

Routine Description:

    Indicates whether the given access range is a vga access range.

Arguments:

    AccessRange - The access range to examine.

Returns:

    TRUE if it is a VGA access range,
    FALSE otherwise.

Notes:

    This routine does not take into account the length of the access range.

--*/

{
    if (AccessRange->RangeInIoSpace) {

        ULONGLONG Port = AccessRange->RangeStart.QuadPart;

        if (((Port >= 0x3b0) && (Port <= 0x3bb)) ||
            ((Port >= 0x3c0) && (Port <= 0x3df))) {

            return TRUE;

        }

    } else {

        if (AccessRange->RangeStart.QuadPart == 0xa0000) {
            return TRUE;
        }
    }

    return FALSE;
}

NTSTATUS
VpAppendToRequirementsList(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST *RequirementList,
    IN ULONG NumAccessRanges,
    IN PVIDEO_ACCESS_RANGE AccessRanges
    )

/*++

Routine Description:

    Builds a IoResourceRequirementsList for a given set of access ranges.

Arguments:

    ResourceList - Pointer to location of the requirments list.  Modified
        on completion to point to a new requirements list.

    NumAccessRanges - Number of access ranges in list.

    AccessRanges - List of resources.


Returns:

    STATUS_SUCCESS if successful, otherwise a status code.

Notes:

    This function free's the memory used by the original resource list,
    and allocates a new buffer for the appended resources list.

--*/

{
    PIO_RESOURCE_REQUIREMENTS_LIST OriginalRequirementList = *RequirementList;
    PIO_RESOURCE_DESCRIPTOR pioDescript;
    ULONG RequirementListSize;
    ULONG OriginalListSize;
    ULONG RequirementCount;
    ULONG i;

    RequirementCount = OriginalRequirementList->List[0].Count;
    OriginalListSize = OriginalRequirementList->ListSize;

    RequirementListSize = OriginalListSize +
                              NumAccessRanges * sizeof(IO_RESOURCE_DESCRIPTOR);

    *RequirementList =
        (PIO_RESOURCE_REQUIREMENTS_LIST) ExAllocatePool(PagedPool,
                                                        RequirementListSize);

    //
    // Return NULL if the structure could not be allocated.
    // Otherwise, fill it out.
    //

    if (*RequirementList == NULL) {

        *RequirementList = OriginalRequirementList;
        return STATUS_INSUFFICIENT_RESOURCES;

    } else {

        //
        // Copy the original resource list into the new one.
        //

        memcpy(*RequirementList, OriginalRequirementList, OriginalListSize);

        //
        // Free the original list
        //

        ExFreePool(OriginalRequirementList);

        //
        // Point to first free entry in requirements list
        //

        pioDescript =
            &((*RequirementList)->List[0].Descriptors[(*RequirementList)->List[0].Count]);

        //
        // For each entry in the access range, fill in an entry in the
        // resource list
        //

        for (i = 0; i < NumAccessRanges; i++) {

            //
            // We will never claim 0xC0000.
            //

            if ((AccessRanges->RangeStart.LowPart == 0xC0000) &&
                (AccessRanges->RangeInIoSpace == FALSE))
            {
                AccessRanges++;
                continue;
            }

            if (AccessRanges->RangeLength == 0) {

                AccessRanges++;
                continue;
            }

            //
            // Watch to see if the VGA resources get added to the
            // requirements list.  If so set a flag so that we know
            // we don't need to reclaim VGA resources in FindAdapter.
            //

            if (VpIsVgaResource(AccessRanges)) {
                DeviceOwningVga = DeviceObject;
            }

            if (AccessRanges->RangeInIoSpace) {
                pioDescript->Type = CmResourceTypePort;
                pioDescript->Flags = CM_RESOURCE_PORT_IO;

                //
                // Disable 10_BIT_DECODE.  This is causing problems for the
                // PnP folks.  If someone has bad hardware, we'll just
                // require them to report all the passive port explicitly.
                //
                //if (VpIsVgaResource(AccessRanges)) {
                //
                //    pioDescript->Flags |= CM_RESOURCE_PORT_10_BIT_DECODE;
                //}

            } else {

                pioDescript->Type = CmResourceTypeMemory;
                pioDescript->Flags = CM_RESOURCE_MEMORY_READ_WRITE;
            }

            if (AccessRanges->RangePassive & VIDEO_RANGE_PASSIVE_DECODE) {
                pioDescript->Flags |= CM_RESOURCE_PORT_PASSIVE_DECODE;
            }

            if (AccessRanges->RangePassive & VIDEO_RANGE_10_BIT_DECODE) {
                pioDescript->Flags |= CM_RESOURCE_PORT_10_BIT_DECODE;
            }

            pioDescript->ShareDisposition =
                    (AccessRanges->RangeShareable ?
                        CmResourceShareShared :
                        CmResourceShareDeviceExclusive);

            pioDescript->Option = IO_RESOURCE_PREFERRED;
            pioDescript->u.Memory.MinimumAddress = AccessRanges->RangeStart;
            pioDescript->u.Memory.MaximumAddress.QuadPart =
                                                   AccessRanges->RangeStart.QuadPart +
                                                   AccessRanges->RangeLength - 1;
            pioDescript->u.Memory.Alignment = 1;
            pioDescript->u.Memory.Length = AccessRanges->RangeLength;

            pioDescript++;
            AccessRanges++;
            RequirementCount++;
        }

        //
        // Update number of elements in list.
        //

        (*RequirementList)->List[0].Count = RequirementCount;
        (*RequirementList)->ListSize = RequirementListSize;
    }

    return STATUS_SUCCESS;
}



VP_STATUS
VideoPortVerifyAccessRanges(
    PVOID HwDeviceExtension,
    ULONG NumAccessRanges,
    PVIDEO_ACCESS_RANGE AccessRanges
    )

/*++

Routine Description:

    VideoPortVerifyAccessRanges


Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

    NumAccessRanges - Number of entries in the AccessRanges array.

    AccessRanges - Pointer to an array of AccessRanges the miniport driver
        wants to access.

Return Value:

    ERROR_INVALID_PARAMETER in an error occured
    NO_ERROR if the call completed successfully

Environment:

    This routine cannot be called from a miniport routine synchronized with
    VideoPortSynchronizeRoutine or from an ISR.

--*/

{
    NTSTATUS status;
    BOOLEAN conflict;
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    //
    // If the device is not enabled then we won't allow the miniport
    // to claim resources for it.
    //

    if (!CheckIoEnabled(
            HwDeviceExtension,
            NumAccessRanges,
            AccessRanges)) {

        return ERROR_INVALID_PARAMETER;
    }

    //
    // All resources not passed in during the START_DEVICE irp should
    // be claimed on the FDO.  We will strip out the PDO resources
    // in pVideoPortReportResourceList if the miniport driver tries
    // to verify ranges acquired through VideoPortGetAccessRanges.
    //

    status = STATUS_SUCCESS;
    conflict = FALSE;

    if ((NT_SUCCESS(status)) && (!conflict)) {

#if DBG

        //
        // Indicates resources have been mapped properly
        //

        InterlockedIncrement(&VPResourcesReported);

#endif

        //
        // Track the resources owned by the VGA driver.
        //

        if (fdoExtension->Flags & VGA_DRIVER) {

            if (VgaAccessRanges != AccessRanges) {

                ULONG Size = NumAccessRanges * sizeof(VIDEO_ACCESS_RANGE);

                if (VgaAccessRanges) {
                    ExFreePool(VgaAccessRanges);
                    VgaAccessRanges = NULL;
                    NumVgaAccessRanges = 0;
                }

                if (NumAccessRanges) {
                    VgaAccessRanges = ExAllocatePoolWithTag(PagedPool, Size, POOL_TAG);

                    if (VgaAccessRanges) {
                        memcpy(VgaAccessRanges, AccessRanges, Size);
                        NumVgaAccessRanges = NumAccessRanges;
                    }
                }
            }
        }

        return NO_ERROR;

    } else {

        return ERROR_INVALID_PARAMETER;

    }

} // end VideoPortVerifyAccessRanges()

BOOLEAN
CheckIoEnabled(
    PVOID HwDeviceExtension,
    ULONG NumAccessRanges,
    PVIDEO_ACCESS_RANGE AccessRanges
    )

/*++

Routine Description:

    This routine ensures that IO is actually enabled if claiming
    IO ranges.

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

    NumAccessRanges - Number of entries in the AccessRanges array.

    AccessRanges - Pointer to an array of AccessRanges the miniport driver
        wants to access.

Return Value:

    TRUE if our IO access checks pass,
    FALSE otherwise.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    if (fdoExtension->AdapterInterfaceType == PCIBus) {

        //
        // Check to see if there are any IO ranges in the
        // list or resources.
        //

        ULONG i;
        USHORT Command;

        //
        // Get the PCI Command register for this device.
        //

        VideoPortGetBusData(
            HwDeviceExtension,
            PCIConfiguration,
            0,
            &Command,
            FIELD_OFFSET(PCI_COMMON_CONFIG, Command),
            sizeof(USHORT));

        for (i=0; i<NumAccessRanges; i++) {

            if (AccessRanges[i].RangeInIoSpace) {

                if (!(Command & PCI_ENABLE_IO_SPACE))
                    return FALSE;

            } else {

                if (!(Command & PCI_ENABLE_MEMORY_SPACE))
                    return FALSE;
            }
        }

        return TRUE;

    } else {

        //
        // Non-pci devices will always decode IO operations.
        //

        return TRUE;
    }
}

BOOLEAN
VpIsLegacyAccessRange(
    PFDO_EXTENSION fdoExtension,
    PVIDEO_ACCESS_RANGE AccessRange
    )

/*++

Routine Description:

    This return determines whether a given access range is
    included in the list of legacy access ranges.

Arguments:

    fdoExtension - The FDO extension for the device using the access range.

    AccessRange - The access range to look for in the resource list.

Returns:

    TRUE if the given access range is included in the list of reported
    legacy resources, FALSE otherwise.

--*/

{
    ULONG i;
    PVIDEO_ACCESS_RANGE CurrResource;

    if (fdoExtension->HwLegacyResourceList) {

        CurrResource = fdoExtension->HwLegacyResourceList;

        for (i=0; i<fdoExtension->HwLegacyResourceCount; i++) {

            if ((CurrResource->RangeStart.QuadPart ==
                 AccessRange->RangeStart.QuadPart) &&
                (CurrResource->RangeLength == AccessRange->RangeLength)) {

                return TRUE;
            }

            CurrResource++;
        }
    }

    return FALSE;
}

ULONG
GetCmResourceListSize(
    PCM_RESOURCE_LIST CmResourceList
    )

/*++

Routine Description:

    Get the size in bytes of a CmResourceList.

Arguments:

    CmResourceList - The list for which to get the size.

Returns:

    Size in bytes of the CmResourceList.

--*/

{
    PCM_FULL_RESOURCE_DESCRIPTOR    pcmFull;
    PCM_PARTIAL_RESOURCE_LIST       pcmPartial;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pcmDescript;
    ULONG i, j;

    pcmFull = &(CmResourceList->List[0]);
    for (i=0; i<CmResourceList->Count; i++) {

        pcmPartial = &(pcmFull->PartialResourceList);
        pcmDescript = &(pcmPartial->PartialDescriptors[0]);
        pcmDescript += pcmPartial->Count;
        pcmFull = (PCM_FULL_RESOURCE_DESCRIPTOR) pcmDescript;
    }

    return (ULONG)(((ULONG_PTR)pcmFull) - ((ULONG_PTR)CmResourceList));
}

PCM_RESOURCE_LIST
VpRemoveFromResourceList(
    PCM_RESOURCE_LIST OriginalList,
    ULONG NumAccessRanges,
    PVIDEO_ACCESS_RANGE AccessRanges
    )

/*++

Routine Description:

    Creates a new CmResourceList with the given access ranges
    removed.

Arguments:

    OriginalList - The original CmResourceList to operate on.

    NumAccessRanges - The number of entries in the remove list.

    AccessRanges - The list of ranges which should be removed from
        the list.

Returns:

    A pointer to the new CmResourceList.

Notes:

    The caller is responsible for freeing the memory returned by this
    function.

--*/

{
    PCM_RESOURCE_LIST FilteredList;
    ULONG Size = GetCmResourceListSize(OriginalList);
    ULONG remainingLength;
    ULONG ResourcesRemoved;

    FilteredList = ExAllocatePoolWithTag(PagedPool, Size, POOL_TAG);

    if (FilteredList) {

        ULONG i, j, k;
        PCM_FULL_RESOURCE_DESCRIPTOR    pcmFull;
        PCM_PARTIAL_RESOURCE_LIST       pcmPartial;
        PCM_PARTIAL_RESOURCE_DESCRIPTOR pcmDescript;

        //
        // Make a copy of the original list.
        //

        memcpy(FilteredList, OriginalList, Size);
        remainingLength = Size - sizeof(CM_RESOURCE_LIST);

        pcmFull = &(FilteredList->List[0]);
        for (i=0; i<FilteredList->Count; i++) {

            pcmPartial = &(pcmFull->PartialResourceList);
            pcmDescript = &(pcmPartial->PartialDescriptors[0]);

            ResourcesRemoved = 0;

            for (j=0; j<pcmPartial->Count; j++) {

                //
                // See if the current resource is in our legacy list.
                //

                for (k=0; k<NumAccessRanges; k++) {

                    if ((pcmDescript->u.Memory.Start.LowPart ==
                         AccessRanges[k].RangeStart.LowPart) &&
                        (AccessRanges[k].RangeStart.LowPart != 0xC0000)) {

                        //
                        // Remove the resource.
                        //

                        memmove(pcmDescript,
                                pcmDescript + 1,
                                remainingLength);

                        pcmDescript--;
                        ResourcesRemoved++;

                        break;
                    }
                }

                remainingLength -= sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);
                pcmDescript++;
            }

            //
            // Update the resource count in the partial resource list
            //

            pcmPartial->Count -= ResourcesRemoved;
            if (pcmPartial->Count == 0) {
                FilteredList->Count--;
            }

            remainingLength -= sizeof(CM_PARTIAL_RESOURCE_LIST);
            pcmFull = (PCM_FULL_RESOURCE_DESCRIPTOR) pcmDescript;
        }

    } else {

        //
        // Make sure we always return a list.
        //

        ASSERT(FALSE);
        FilteredList = OriginalList;
    }

    return FilteredList;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\port\videoprt.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

  videoprt.c

Abstract:

    This is the NT Video port driver.

Author:

    Andre Vachon (andreva) 18-Dec-1991

Environment:

    kernel mode only

Notes:

    This module is a driver which implements OS dependant functions on the
    behalf of the video drivers

Revision History:

--*/

#define INITGUID

#include "videoprt.h"

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(PAGE,pVideoPortCreateDeviceName)
#pragma alloc_text(PAGE,pVideoPortDispatch)
#pragma alloc_text(PAGE,VideoPortFreeDeviceBase)
#pragma alloc_text(PAGE,pVideoPortFreeDeviceBase)
#pragma alloc_text(PAGE,pVideoPortGetDeviceBase)
#pragma alloc_text(PAGE,VideoPortGetDeviceBase)
#pragma alloc_text(PAGE,pVideoPortGetRegistryCallback)
#pragma alloc_text(PAGE,VideoPortGetRegistryParameters)
#pragma alloc_text(PAGE,pVPInit)
#pragma alloc_text(PAGE,VpAddDevice)
#pragma alloc_text(PAGE,VpCreateDevice)
#pragma alloc_text(PAGE,VideoPortInitialize)
#pragma alloc_text(PAGE,VideoPortFindAdapter2)
#pragma alloc_text(PAGE,VideoPortFindAdapter)
#pragma alloc_text(PAGE,pVideoPortMapToNtStatus)
#pragma alloc_text(PAGE,pVideoPortMapUserPhysicalMem)
#pragma alloc_text(PAGE,VideoPortMapMemory)
#pragma alloc_text(PAGE,VideoPortAllocateBuffer)
#pragma alloc_text(PAGE,VideoPortReleaseBuffer)
#pragma alloc_text(PAGE,VideoPortScanRom)
#pragma alloc_text(PAGE,VideoPortSetRegistryParameters)
#pragma alloc_text(PAGE,VideoPortUnmapMemory)
#pragma alloc_text(PAGE,VpEnableDisplay)
#pragma alloc_text(PAGE,VpWin32kCallout)
#pragma alloc_text(PAGE,VpAllowFindAdapter)
#if DBG
#pragma alloc_text(PAGE,BuildRequirements)
#pragma alloc_text(PAGE,DumpRequirements)
#pragma alloc_text(PAGE,DumpResourceList)
#pragma alloc_text(PAGE,DumpHwInitData)
#pragma alloc_text(PAGE,DumpUnicodeString)
#endif
#pragma alloc_text(PAGE,VideoPortQueryServices)
#pragma alloc_text(PAGE,VpInterfaceDefaultReference)
#pragma alloc_text(PAGE,VpInterfaceDefaultDereference)
#endif



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    Temporary entry point needed to initialize the video port driver.

Arguments:

    DriverObject - Pointer to the driver object created by the system.

Return Value:

   STATUS_SUCCESS

--*/

{
    UNREFERENCED_PARAMETER(DriverObject);
    ASSERT(0);

    //
    //
    //
    //     WARNING !!!
    //
    //     This function is never called because we are loaded as a DLL by other video drivers !
    //
    //
    //
    //
    //

    //
    // We always return STATUS_SUCCESS because otherwise no video miniport
    // driver will be able to call us.
    //

    return STATUS_SUCCESS;

} // end DriverEntry()



NTSTATUS
pVideoPortCreateDeviceName(
    PWSTR           DeviceString,
    ULONG           DeviceNumber,
    PUNICODE_STRING UnicodeString,
    PWCHAR          UnicodeBuffer
    )

/*++

Routine Description:

    Helper function that does string manipulation to create a device name

--*/

{
    WCHAR          ntNumberBuffer[STRING_LENGTH];
    UNICODE_STRING ntNumberUnicodeString;

    //
    // Create the name buffer
    //

    UnicodeString->Buffer = UnicodeBuffer;
    UnicodeString->Length = 0;
    UnicodeString->MaximumLength = STRING_LENGTH;

    //
    // Create the miniport driver object name.
    //

    ntNumberUnicodeString.Buffer = ntNumberBuffer;
    ntNumberUnicodeString.Length = 0;
    ntNumberUnicodeString.MaximumLength = STRING_LENGTH;

    if (NT_SUCCESS(RtlIntegerToUnicodeString(DeviceNumber,
                                             10,
                                             &ntNumberUnicodeString))) {

        if (NT_SUCCESS(RtlAppendUnicodeToString(UnicodeString,
                                                DeviceString))) {

            if (NT_SUCCESS(RtlAppendUnicodeStringToString(UnicodeString,
                                                          &ntNumberUnicodeString))) {

                UnicodeString->MaximumLength = (USHORT)
                    (UnicodeString->Length + sizeof(UNICODE_NULL));

                return STATUS_SUCCESS;
            }
        }
    }

    return STATUS_INSUFFICIENT_RESOURCES;

} // pVideoPortCreateDeviceName()




VOID
VideoPortDebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    This routine allows the miniport drivers (as well as the port driver) to
    display error messages to the debug port when running in the debug
    environment.

    When running a non-debugged system, all references to this call are
    eliminated by the compiler.

Arguments:

    DebugPrintLevel - Debug print level between 0 and 3, with 3 being the
        most verbose.

Return Value:

    None.

--*/

{
    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= VideoDebugLevel) {

        char buffer[256];

        vsprintf(buffer, DebugMessage, ap);

        DbgPrint(buffer);
    }

    va_end(ap);

} // VideoPortDebugPrint()

VOID
VpEnableDisplay(
    BOOLEAN bState
    )

/*++

Routine Description:

    This routine enables/disables the current display so that we can execut
    the drivers FindAdapter code.

Arugments:

    bState - Should the display be enabled or disabled

Returns:

    none
--*/

{
    if (!InbvCheckDisplayOwnership()) {

        VIDEO_WIN32K_CALLBACKS_PARAMS calloutParams;

        //
        // The system is up and running.  Notify GDI to enable/disable
        // the current display.
        //

        calloutParams.CalloutType = VideoFindAdapterCallout;
        calloutParams.Param       = bState;

        VpWin32kCallout(&calloutParams);

    } else {

        //
        // The boot driver is still in control.  Modify the state of the
        // boot driver.
        //

        InbvEnableBootDriver(bState);
    }
}

VOID
VpWin32kCallout(
    PVIDEO_WIN32K_CALLBACKS_PARAMS calloutParams
    )

/*++

Routine Description:

    This routine makes a callout into win32k.  It attaches to csrss
    to guarantee that win32k is in the address space on hydra machines.

Arguments:

    calloutParams - a pointer to the callout struture.

Returns:

    none.

--*/

{

    if (Win32kCallout) {

        (*Win32kCallout)(calloutParams);
    }
}

BOOLEAN
VpAllowFindAdapter(
    PFDO_EXTENSION fdoExtension
    )

/*++

Routine Description:

    Determine if we allow this device to be used if part of a multi-function
    board.

Arguments;

    fdoExtension - The device extenstion for the object in question.

Returns:

    TRUE if the device is allowed as part of a multi-function board.
    FALSE otherwise.

--*/

{
    BOOLEAN bRet = TRUE;

    if ((fdoExtension->AdapterInterfaceType == PCIBus) &&
        ((fdoExtension->Flags & PNP_ENABLED) == PNP_ENABLED)) {

        PCI_COMMON_CONFIG ConfigSpace;

        if (PCI_COMMON_HDR_LENGTH ==
            VideoPortGetBusData(fdoExtension->HwDeviceExtension,
                                PCIConfiguration,
                                0,
                                &ConfigSpace,
                                0,
                                PCI_COMMON_HDR_LENGTH)) {


            if (PCI_MULTIFUNCTION_DEVICE(&ConfigSpace)) {

                bRet = FALSE;
            }
        }
    }

    return bRet;
}

NTSTATUS
pVideoPortDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the main dispatch routine for the video port driver.
    It accepts an I/O Request Packet, transforms it to a video Request
    Packet, and forwards it to the appropriate miniport dispatch routine.
    Upon returning, it completes the request and return the appropriate
    status value.

Arguments:

    DeviceObject - Pointer to the device object of the miniport driver to
        which the request must be sent.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value os the status of the operation.

--*/

{

    PFDO_EXTENSION fdoExtension;
    PIO_STACK_LOCATION irpStack;
    PVOID ioBuffer;
    ULONG inputBufferLength;
    ULONG outputBufferLength;
    PSTATUS_BLOCK statusBlock;
    NTSTATUS finalStatus = -1 ;
    ULONG ioControlCode;
    VIDEO_REQUEST_PACKET vrp;

    //
    // Get pointer to the port driver's device extension.
    //

    fdoExtension = DeviceObject->DeviceExtension;

    //
    // Get a pointer to the current location in the Irp. This is where
    // the function codes and parameters are located.
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Get the pointer to the status buffer.
    // Assume SUCCESS for now.
    //

    statusBlock = (PSTATUS_BLOCK) &Irp->IoStatus;

    //
    // Synchronize execution of the dispatch routine by acquiring the device
    // event object. This ensures all request are serialized.
    // The synchronization must be done explicitly because the functions
    // executed in the dispatch routine use system services that cannot
    // be executed in the start I/O routine.
    //
    // The synchronization is done on the miniport's event so as not to
    // block commands coming in for another device.
    //

    pVideoDebugPrint((3, "pVideoPortDispatch(), wait for Sync Event, line %d\n", __LINE__));

    ACQUIRE_DEVICE_LOCK(fdoExtension);

    ASSERT(irpStack->MajorFunction != IRP_MJ_PNP);
    ASSERT(irpStack->MajorFunction != IRP_MJ_POWER);

    //
    // Case on the function being requested.
    // If the function is operating specific, intercept the operation and
    // perform directly. Otherwise, pass it on to the appropriate miniport.
    //

    switch (irpStack->MajorFunction) {

    //
    // Called by the display driver *or a user-mode application*
    // to get exclusive access to the device.
    // This access is given by the I/O system (based on a bit set during the
    // IoCreateDevice() call).
    //

    case IRP_MJ_CREATE:

        pVideoDebugPrint((2, "VideoPort - CREATE\n"));

        //
        // Don't let an old driver start during the upgrade
        //

        if (fdoExtension->Flags & UPGRADE_FAIL_START)
        {
            statusBlock->Status = STATUS_ACCESS_DENIED;
            break;
        }

        //
        // Special hack to succeed on Attach, but not do anything ...
        // That way on the close caused by the attach we will not actually
        // close the device and screw the HAL.
        //

        if (irpStack->Parameters.Create.SecurityContext->DesiredAccess ==
            FILE_READ_ATTRIBUTES) {

            statusBlock->Information = FILE_OPEN;
            statusBlock->Status = STATUS_SUCCESS;

            fdoExtension->bAttachInProgress = TRUE;

            break;

        }

        //
        // Only allow our device to be opened once!
        //

        if (fdoExtension->DeviceOpened) {

            pVideoDebugPrint((0, "Only one create allowed on this device.\n"));
            statusBlock->Status = STATUS_ACCESS_DENIED;
            break;
        }

        //
        // Mark the device as opened so we will fail future opens.
        //

        fdoExtension->DeviceOpened = TRUE;

        //
        // Tell the kernel we are now taking ownership the display.
        //

        InbvNotifyDisplayOwnershipLost(pVideoPortResetDisplay);

        //
        // Now perform basic initialization to allow the Windows display
        // driver to set up the device appropriately.
        //

        statusBlock->Information = FILE_OPEN;

        //
        // We will need to attach to the CSR process to do an int 10.
        // Save the value of that process so we can do an attach later on.
        //

        if ((fdoExtension->Flags & FINDADAPTER_SUCCEEDED) == 0) {

            statusBlock->Status = STATUS_DEVICE_CONFIGURATION_ERROR;
            pVideoDebugPrint((0, "VideoPortDispatch: START_DEVICE did not succeed\n"));

        } else if ((fdoExtension->HwInitStatus == HwInitNotCalled) &&
                   (fdoExtension->HwInitialize(fdoExtension->HwDeviceExtension) == FALSE))
        {
            statusBlock->Status = STATUS_DEVICE_CONFIGURATION_ERROR;
            fdoExtension->HwInitStatus = HwInitFailed;

            pVideoDebugPrint((0, "VideoPortDispatch: HwInitialize failed\n"));

        } else if (fdoExtension->HwInitStatus == HwInitFailed) {

            statusBlock->Status = STATUS_DEVICE_CONFIGURATION_ERROR;

        } else {

            fdoExtension->HwInitStatus = HwInitSucceeded;

            statusBlock->Status = STATUS_SUCCESS;
        }

        //
        // We don't want GDI to use any drivers other than display
        // or boot drivers during upgrade setup.
        //

        if (fdoExtension->Flags & UPGRADE_FAIL_HWINIT) {

            statusBlock->Status = STATUS_ACCESS_DENIED;
        }

        break;

    //
    // Called when the display driver wishes to give up it's handle to the
    // device.
    //

    case IRP_MJ_CLOSE:

        pVideoDebugPrint((2, "Videoprt - CLOSE\n"));

        //
        // Special hack to succeed on Attach, but not do anything ...
        // That way on the close caused by the attach we will not actually
        // close the device and screw the HAL.
        //

        if (fdoExtension->bAttachInProgress == TRUE) {

            fdoExtension->bAttachInProgress = FALSE;
            statusBlock->Status = STATUS_SUCCESS;

            break;

        }

        //
        // Allow the device to be opend again.
        //

        fdoExtension->DeviceOpened = FALSE;


        vrp.IoControlCode      = IOCTL_VIDEO_RESET_DEVICE;
        vrp.StatusBlock        = statusBlock;
        vrp.InputBuffer        = NULL;
        vrp.InputBufferLength  = 0;
        vrp.OutputBuffer       = NULL;
        vrp.OutputBufferLength = 0;

        //
        // Send the request to the miniport.
        //

        fdoExtension->HwStartIO(fdoExtension->HwDeviceExtension, &vrp);

        //
        // Override error from the miniport and return success.
        //

        statusBlock->Status = STATUS_SUCCESS;

        break;

    //
    // Device Controls are specific functions for the driver.
    // First check for calls that must be intercepted and hidden from the
    // miniport driver. These calls are hidden for simplicity.
    // The other control functions are passed down to the miniport after
    // the request structure has been filled out properly.
    //

    case IRP_MJ_DEVICE_CONTROL:

        //
        // Get the pointer to the input/output buffer and it's length
        //

        ioBuffer           = Irp->AssociatedIrp.SystemBuffer;
        inputBufferLength  = irpStack->Parameters.DeviceIoControl.InputBufferLength;
        outputBufferLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;
        ioControlCode      = irpStack->Parameters.DeviceIoControl.IoControlCode;

        if (ioControlCode == IOCTL_VIDEO_INIT_WIN32K_CALLBACKS) {

            pVideoDebugPrint((2, "VideoPort - IOCTL_VIDEO_INIT_WIN32K_CALLBACKS\n"));

            fdoExtension->PhysDisp = ((PVIDEO_WIN32K_CALLBACKS)(ioBuffer))->PhysDisp;

            Win32kCallout = ((PVIDEO_WIN32K_CALLBACKS)(ioBuffer))->Callout;

            ((PVIDEO_WIN32K_CALLBACKS)ioBuffer)->bACPI             = FALSE;
            ((PVIDEO_WIN32K_CALLBACKS)ioBuffer)->pPhysDeviceObject = fdoExtension->PhysicalDeviceObject;

            statusBlock->Status = STATUS_SUCCESS;
            statusBlock->Information = sizeof(VIDEO_WIN32K_CALLBACKS);

        } else if (ioControlCode == IOCTL_VIDEO_IS_VGA_DEVICE) {

            pVideoDebugPrint((2, "VideoPort - IOCTL_VIDEO_IS_VGA_DEVICE\n"));

            *((PBOOLEAN)(ioBuffer)) = (BOOLEAN)(DeviceObject == DeviceOwningVga);

            statusBlock->Status = STATUS_SUCCESS;
            statusBlock->Information = sizeof(BOOLEAN);

        } else {

            //
            // All other request need to be passed to the miniport driver.
            //

            statusBlock->Status = STATUS_SUCCESS;

            switch (ioControlCode) {

#if _X86_
            case IOCTL_VIDEO_SAVE_HARDWARE_STATE:

                pVideoDebugPrint((2, "VideoPort - SaveHardwareState\n"));

                //
                // allocate the memory required by the miniport driver so it can
                // save its state to be returned to the caller.
                //

                if (fdoExtension->HardwareStateSize == 0) {

                    statusBlock->Status = STATUS_NOT_IMPLEMENTED;
                    break;

                }

                ((PVIDEO_HARDWARE_STATE)(ioBuffer))->StateLength =
                    fdoExtension->HardwareStateSize;

                statusBlock->Status =
                    ZwAllocateVirtualMemory(NtCurrentProcess(),
                                            (PVOID *) &(((PVIDEO_HARDWARE_STATE)(ioBuffer))->StateHeader),
                                            0L,
                                            &((PVIDEO_HARDWARE_STATE)(ioBuffer))->StateLength,
                                            MEM_COMMIT,
                                            PAGE_READWRITE);

                break;
#endif

            case IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES:

                pVideoDebugPrint((2, "VideoPort - QueryAccessRanges\n"));

                break;

            //
            // The default case is when the port driver does not handle the
            // request. We must then call the miniport driver.
            //

            default:

                break;


            } // switch (ioControlCode)


            //
            // All above cases call the miniport driver.
            //
            // only process it if no errors happened in the port driver
            // processing.
            //

            if (NT_SUCCESS(statusBlock->Status)) {

                pVideoDebugPrint((2, "VideoPort - default function %x\n", ioControlCode));

                vrp.IoControlCode      = ioControlCode;
                vrp.StatusBlock        = statusBlock;
                vrp.InputBuffer        = ioBuffer;
                vrp.InputBufferLength  = inputBufferLength;
                vrp.OutputBuffer       = ioBuffer;
                vrp.OutputBufferLength = outputBufferLength;

                //
                // Send the request to the miniport.
                //

                fdoExtension->HwStartIO(fdoExtension->HwDeviceExtension,
                                        &vrp);

                if (statusBlock->Status != NO_ERROR) {

                    //
                    // Make sure we don't tell the IO system to copy data
                    // on a real error.
                    //

                    if (statusBlock->Status != ERROR_MORE_DATA) {

                        ASSERT(statusBlock->Information == 0);
                        statusBlock->Information = 0;

                    }

                    pVideoPortMapToNtStatus(statusBlock);
                }
            }

        } // if (ioControlCode == ...

        break;

    //
    // Other major entry points in the dispatch routine are not supported.
    //

    default:

        statusBlock->Status = STATUS_SUCCESS;

        break;

    } // switch (irpStack->MajorFunction)

    //
    // save the final status so we can return it after the IRP is completed.
    //

    if (finalStatus == -1) {
        finalStatus = statusBlock->Status;
    }

    pVideoDebugPrint((3, "pVideoPortDispatch(), set Sync Event, line %d\n", __LINE__));

    RELEASE_DEVICE_LOCK(fdoExtension);

    if (finalStatus == STATUS_PENDING) {
        pVideoDebugPrint((1, "VideoPrt: Pending in pVideoPortDispatch.\n")) ;
        return STATUS_PENDING ;
    }

    pVideoDebugPrint((3, "Dispatch: calling IoCompleteRequest with Irp %x\n", Irp));

    IoCompleteRequest(Irp,
                      IO_VIDEO_INCREMENT);

    //
    // We never have pending operation so always return the status code.
    //

    pVideoDebugPrint((2, "VideoPort:  final IOCTL status: %08lx\n",
                     finalStatus));

    return finalStatus;

} // pVideoPortDispatch()


VOID
VideoPortFreeDeviceBase(
    IN PVOID HwDeviceExtension,
    IN PVOID MappedAddress
    )

/*++

Routine Description:

    VideoPortFreeDeviceBase frees a block of I/O addresses or memory space
    previously mapped into the system address space by calling
    VideoPortGetDeviceBase.

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

    MappedAddress - Specifies the base address of the block to be freed. This
        value must be the same as the value returned by VideoPortGetDeviceBase.

Return Value:

    None.

Environment:

    This routine cannot be called from a miniport routine synchronized with
    VideoPortSynchronizeRoutine or from an ISR.

--*/

{
    pVideoPortFreeDeviceBase(HwDeviceExtension, MappedAddress);
    return;
}


PVOID
pVideoPortFreeDeviceBase(
    IN PVOID HwDeviceExtension,
    IN PVOID MappedAddress
    )
{
    PMAPPED_ADDRESS nextMappedAddress;
    PMAPPED_ADDRESS lastMappedAddress;
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    pVideoDebugPrint((2, "VPFreeDeviceBase at mapped address is %08lx\n",
                    MappedAddress));

    lastMappedAddress = NULL;
    nextMappedAddress = fdoExtension->MappedAddressList;

    while (nextMappedAddress) {

        if (nextMappedAddress->MappedAddress == MappedAddress) {

            //
            // Count up how much memory a miniport driver is really taking
            //

            if (nextMappedAddress->bNeedsUnmapping) {

                fdoExtension->MemoryPTEUsage -=
                    COMPUTE_PAGES_SPANNED(nextMappedAddress->MappedAddress,
                                          nextMappedAddress->NumberOfUchars);

            }

            //
            // BUGBUG use reference count temporarily since ATI maps too
            // large a buffer to do two maps of it.
            //

            if (!(--nextMappedAddress->RefCount)) {

                //
                // Unmap address, if necessary.
                //

                if (nextMappedAddress->bNeedsUnmapping) {

                    MmUnmapIoSpace(nextMappedAddress->MappedAddress,
                                   nextMappedAddress->NumberOfUchars);
                }

                //
                // Remove mapped address from list.
                //

                if (lastMappedAddress == NULL) {

                    fdoExtension->MappedAddressList =
                    nextMappedAddress->NextMappedAddress;

                } else {

                    lastMappedAddress->NextMappedAddress =
                    nextMappedAddress->NextMappedAddress;

                }

                ExFreePool(nextMappedAddress);

            }

            //
            // We just return the value to show that the call succeeded.
            //

            return (nextMappedAddress);

        } else {

            lastMappedAddress = nextMappedAddress;
            nextMappedAddress = nextMappedAddress->NextMappedAddress;

        }
    }

    return NULL;

} // end VideoPortFreeDeviceBase()


PVOID
VideoPortGetDeviceBase(
    IN PVOID HwDeviceExtension,
    IN PHYSICAL_ADDRESS IoAddress,
    IN ULONG NumberOfUchars,
    IN UCHAR InIoSpace
    )

/*++

Routine Description:

    VideoPortGetDeviceBase maps a memory or I/O address range into the
    system (kernel) address space.  Access to this mapped address space
    must follow these rules:

        If the input value for InIoSpace is 1 (the address IS in I/O space),
        the returned logical address should be used in conjunction with
        VideoPort[Read/Write]Port[Uchar/Ushort/Ulong] functions.
                             ^^^^

        If the input value for InIoSpace is 0 (the address IS NOT in I/O
        space), the returned logical address should be used in conjunction
        with VideoPort[Read/Write]Register[Uchar/Ushort/Ulong] functions.
                                  ^^^^^^^^

    Note that VideoPortFreeDeviceBase is used to unmap a previously mapped
    range from the system address space.

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

    IoAddress - Specifies the base physical address of the range to be
        mapped in the system address space.

    NumberOfUchars - Specifies the number of bytes, starting at the base
        address, to map in system space. The driver must not access
        addresses outside this range.

    InIoSpace - Specifies that the address is in the I/O space if 1.
        Otherwise, the address is assumed to be in memory space.

Return Value:

    This function returns a base address suitable for use by the hardware
    access functions. VideoPortGetDeviceBase may be called several times
    by the miniport driver.

Environment:

    This routine cannot be called from a miniport routine synchronized with
    VideoPortSynchronizeRoutine or from an ISR.

--*/

{
    //
    // We specify large page as FALSE for the default since the miniport could
    // be using the address at raise IRQL in an ISR.
    //

    return pVideoPortGetDeviceBase(HwDeviceExtension,
                                   IoAddress,
                                   NumberOfUchars,
                                   InIoSpace,
                                   FALSE);

}

PVOID
pVideoPortGetDeviceBase(
    IN PVOID HwDeviceExtension,
    IN PHYSICAL_ADDRESS IoAddress,
    IN ULONG NumberOfUchars,
    IN UCHAR InIoSpace,
    IN BOOLEAN bLargePage
    )
{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);
    PHYSICAL_ADDRESS cardAddress = IoAddress;
    PVOID mappedAddress = NULL;
    PMAPPED_ADDRESS newMappedAddress;
    BOOLEAN bMapped;

    ULONG addressSpace;
    ULONG p6Caching = FALSE;

    pVideoDebugPrint((2, "VPGetDeviceBase reqested %08lx mem type. address is %08lx %08lx, length of %08lx\n",
                     InIoSpace, IoAddress.HighPart, IoAddress.LowPart, NumberOfUchars));

    //
    // Properly configure the flags for translation
    //

    addressSpace = InIoSpace & 0xFF;

#if defined(_X86_)

    //
    // On X86, determine if we will want to map the memory with the
    // special caching flag.
    //

    p6Caching = addressSpace & VIDEO_MEMORY_SPACE_P6CACHE;

#endif

    addressSpace &= ~VIDEO_MEMORY_SPACE_P6CACHE;

#if !defined(_ALPHA_)

    //
    // On non-alpha, this does'nt mean anything
    //

    addressSpace &= ~VIDEO_MEMORY_SPACE_DENSE;

#endif

    if (addressSpace & VIDEO_MEMORY_SPACE_USER_MODE) {
        ASSERT(FALSE);
        return NULL;
    }

    if ((((cardAddress.QuadPart >= 0x000C0000) && (cardAddress.QuadPart < 0x000C8000)) &&
         (InIoSpace == 0) &&
         (VpC0000Compatible == 2)) ||
        HalTranslateBusAddress(fdoExtension->AdapterInterfaceType,
                               fdoExtension->SystemIoBusNumber,
                               IoAddress,
                               &addressSpace,
                               &cardAddress)) {

        //
        // Use reference counting for addresses to support broken ATI !
        // Return the previously mapped address if we find the same physical
        // address.
        //

        PMAPPED_ADDRESS nextMappedAddress;

        pVideoDebugPrint((2, "VPGetDeviceBase requested %08lx mem type. physical address is %08lx %08lx, length of %08lx\n",
                         addressSpace, cardAddress.HighPart, cardAddress.LowPart, NumberOfUchars));

        nextMappedAddress = fdoExtension->MappedAddressList;

        while (nextMappedAddress) {

            if ((nextMappedAddress->InIoSpace == InIoSpace) &&
                (nextMappedAddress->NumberOfUchars == NumberOfUchars) &&
                (nextMappedAddress->PhysicalAddress.QuadPart == cardAddress.QuadPart)) {


                pVideoDebugPrint((2, "VPGetDeviceBase : refCount hit on address %08lx \n",
                                  nextMappedAddress->PhysicalAddress.LowPart));

                nextMappedAddress->RefCount++;

                //
                // Count up how much memory a miniport driver is really taking
                //

                if (nextMappedAddress->bNeedsUnmapping) {

                    fdoExtension->MemoryPTEUsage +=
                        COMPUTE_PAGES_SPANNED(nextMappedAddress->MappedAddress,
                                              nextMappedAddress->NumberOfUchars);

                }

                return (nextMappedAddress->MappedAddress);

            } else {

                nextMappedAddress = nextMappedAddress->NextMappedAddress;

            }
        }

        //
        // If the address is in IO space, don't do anything.
        // If the address is in memory space, map it and save the information.
        //

        if (addressSpace & VIDEO_MEMORY_SPACE_IO) {

            mappedAddress = (PVOID) cardAddress.QuadPart;
            bMapped = FALSE;

        } else {

            //
            // Map the device base address into the virtual address space
            //
            // NOTE: This routine is order dependant, and changing flags like
            // bLargePage will affect the caching of address we do earlier
            // on in this routine.
            //

            if (p6Caching && EnableUSWC) {

                mappedAddress = MmMapIoSpace(cardAddress,
                                             NumberOfUchars,
                                             MmFrameBufferCached);

                if (mappedAddress == NULL) {

                    mappedAddress = MmMapIoSpace(cardAddress,
                                                 NumberOfUchars,
                                                 FALSE);
                }

            } else {

                mappedAddress = MmMapIoSpace(cardAddress,
                                             NumberOfUchars,
                                             FALSE);
            }

            if (mappedAddress == NULL) {

                //
                // A failiure occured
                // BUGBUG we should log an error here !
                //

                pVideoDebugPrint((0, "VideoPort: MmMapIoSpace FAILED !!!\n"));

                return NULL;
            }

            bMapped = TRUE;

            fdoExtension->MemoryPTEUsage +=
                COMPUTE_PAGES_SPANNED(mappedAddress,
                                      NumberOfUchars);



        }

        //
        // Allocate memory to store mapped address for unmap.
        //

        newMappedAddress = ExAllocatePoolWithTag(NonPagedPool,
                                                 sizeof(MAPPED_ADDRESS),
                                                 'trpV');

        //
        // Save the reference if we can allocate memory for it. If we can
        // not, just don't save it ... it's not a big deal.
        //

        if (newMappedAddress) {

            //
            // Store mapped address information.
            //

            newMappedAddress->PhysicalAddress = cardAddress;
            newMappedAddress->RefCount = 1;
            newMappedAddress->MappedAddress = mappedAddress;
            newMappedAddress->NumberOfUchars = NumberOfUchars;
            newMappedAddress->InIoSpace = InIoSpace;
            newMappedAddress->bNeedsUnmapping = bMapped;
            newMappedAddress->bLargePageRequest = bLargePage;

            //
            // Link current list to new entry.
            //

            newMappedAddress->NextMappedAddress =
                fdoExtension->MappedAddressList;

            //
            // Point anchor at new list.
            //

            fdoExtension->MappedAddressList = newMappedAddress;

        }

    } else {

        pVideoDebugPrint((1, "HalTranslateBusAddress failed !!\n"));

    }

    pVideoDebugPrint((2, "VPGetDeviceBase mapped virtual address is %08lx\n",
                    mappedAddress));

    return mappedAddress;

} // end VideoPortGetDeviceBase()


NTSTATUS
pVideoPortGetRegistryCallback(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
)

/*++

Routine Description:

    This routine gets information from the system hive, user-specified
    registry (as opposed to the information gathered by ntdetect.

Arguments:


    ValueName - Pointer to a unicode String containing the name of the data
        value being searched for.

    ValueType - Type of the data value.

    ValueData - Pointer to a buffer containing the information to be written
        out to the registry.

    ValueLength - Size of the data being written to the registry.

    Context - Specifies a context parameter passed to the callback routine.

    EntryContext - Specifies a second context parameter passed with the
        request.

Return Value:

    STATUS_SUCCESS

Environment:

    This routine cannot be called from a miniport routine synchronized with
    VideoPortSynchronizeRoutine or from an ISR.

--*/

{
    PVP_QUERY_DEVICE queryDevice = Context;
    UNICODE_STRING unicodeString;
    OBJECT_ATTRIBUTES objectAttributes;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    HANDLE fileHandle = NULL;
    IO_STATUS_BLOCK ioStatusBlock;
    FILE_STANDARD_INFORMATION fileStandardInfo;
    PVOID fileBuffer = NULL;
    LARGE_INTEGER byteOffset;

    //
    // If the parameter was a file to be opened, perform the operation
    // here. Otherwise just return the data.
    //

    if (queryDevice->DeviceDataType == VP_GET_REGISTRY_FILE) {

        //
        // For the name of the file to be valid, we must first append
        // \DosDevices in front of it.
        //

        RtlInitUnicodeString(&unicodeString,
                             ValueData);

        InitializeObjectAttributes(&objectAttributes,
                                   &unicodeString,
                                   OBJ_CASE_INSENSITIVE,
                                   (HANDLE) NULL,
                                   (PSECURITY_DESCRIPTOR) NULL);

        ntStatus = ZwOpenFile(&fileHandle,
                              FILE_GENERIC_READ | SYNCHRONIZE,
                              &objectAttributes,
                              &ioStatusBlock,
                              0,
                              FILE_SYNCHRONOUS_IO_ALERT);

        if (!NT_SUCCESS(ntStatus)) {

            pVideoDebugPrint((1, "VideoPortGetRegistryParameters: Could not open file\n"));
            goto EndRegistryCallback;

        }

        ntStatus = ZwQueryInformationFile(fileHandle,
                                          &ioStatusBlock,
                                          &fileStandardInfo,
                                          sizeof(FILE_STANDARD_INFORMATION),
                                          FileStandardInformation);

        if (!NT_SUCCESS(ntStatus)) {

            pVideoDebugPrint((1, "VideoPortGetRegistryParameters: Could not get size of file\n"));
            goto EndRegistryCallback;

        }

        if (fileStandardInfo.EndOfFile.HighPart) {

            //
            // If file is too big, do not try to go further.
            //

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto EndRegistryCallback;

        }

        ValueLength = fileStandardInfo.EndOfFile.LowPart;

        fileBuffer = ExAllocatePoolWithTag(PagedPool,
                                           ValueLength,
                                           POOL_TAG);

        if (!fileBuffer) {

            pVideoDebugPrint((1, "VideoPortGetRegistryParameters: Could not allocate buffer to read file\n"));
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;

            goto EndRegistryCallback;

        }

        ValueData = fileBuffer;

        //
        // Read the entire file for the beginning.
        //

        byteOffset.QuadPart = 0;

        ntStatus = ZwReadFile(fileHandle,
                              NULL,
                              NULL,
                              NULL,
                              &ioStatusBlock,
                              ValueData,
                              ValueLength,
                              &byteOffset,
                              NULL);

        if (!NT_SUCCESS(ntStatus)) {

            pVideoDebugPrint((1, "VideoPortGetRegistryParameters: Could not read file\n"));
            goto EndRegistryCallback;

        }

    }

    //
    // Call the miniport with the appropriate information.
    //

    queryDevice->MiniportStatus = ((PMINIPORT_GET_REGISTRY_ROUTINE)
               queryDevice->CallbackRoutine) (queryDevice->MiniportHwDeviceExtension,
                                              queryDevice->MiniportContext,
                                              ValueName,
                                              ValueData,
                                              ValueLength);

EndRegistryCallback:

    if (fileHandle) {

        ZwClose(fileHandle);

    }

    if (fileBuffer) {

        ExFreePool(fileBuffer);

    }

    return ntStatus;

} // end pVideoPortGetRegistryCallback()



VP_STATUS
VideoPortGetRegistryParameters(
    PVOID HwDeviceExtension,
    PWSTR ParameterName,
    UCHAR IsParameterFileName,
    PMINIPORT_GET_REGISTRY_ROUTINE CallbackRoutine,
    PVOID Context
    )

/*++

Routine Description:

    VideoPortGetRegistryParameters retrieves information from the
    CurrentControlSet in the registry.  The function automatically searches
    for the specified parameter name under the \Devicexxx key for the
    current driver.

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

    ParameterName - Points to a Unicode string that contains the name of the
        data value being searched for in the registry.

    IsParameterFileName - If 1, the data retrieved from the requested
        parameter name is treated as a file name.  The contents of the file are
        returned, instead of the parameter itself.

    CallbackRoutine - Points to a function that should be called back with
        the requested information.

    Context - Specifies a context parameter passed to the callback routine.

Return Value:

    This function returns the final status of the operation.

Environment:

    This routine cannot be called from a miniport routine synchronized with
    VideoPortSynchronizeRoutine or from an ISR.

--*/

{

    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);
    RTL_QUERY_REGISTRY_TABLE queryTable[2];
    NTSTATUS ntStatus;
    VP_QUERY_DEVICE queryDevice;

    queryDevice.MiniportHwDeviceExtension = HwDeviceExtension;
    queryDevice.DeviceDataType = IsParameterFileName ? VP_GET_REGISTRY_FILE : VP_GET_REGISTRY_DATA;
    queryDevice.CallbackRoutine = CallbackRoutine;
    queryDevice.MiniportStatus = NO_ERROR;
    queryDevice.MiniportContext = Context;

    //
    // BUGBUG
    // Can be simplified now since we don't have to go down a directory.
    // It can be just one call.
    //

    queryTable[0].QueryRoutine = pVideoPortGetRegistryCallback;
    queryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    queryTable[0].Name = ParameterName;
    queryTable[0].EntryContext = NULL;
    queryTable[0].DefaultType = REG_NONE;
    queryTable[0].DefaultData = 0;
    queryTable[0].DefaultLength = 0;

    queryTable[1].QueryRoutine = NULL;
    queryTable[1].Flags = 0;
    queryTable[1].Name = NULL;
    queryTable[1].EntryContext = NULL;
    queryTable[1].DefaultType = REG_NONE;
    queryTable[1].DefaultData = 0;
    queryTable[1].DefaultLength = 0;

    ntStatus = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                      fdoExtension->DriverRegistryPath,
                                      queryTable,
                                      &queryDevice,
                                      NULL);

    if (!NT_SUCCESS(ntStatus)) {

        queryDevice.MiniportStatus = ERROR_INVALID_PARAMETER;

    }

    return queryDevice.MiniportStatus;

} // end VideoPortGetRegistryParameters()


VOID
pVPInit(
    VOID
    )

/*++

Routine Description:

    First time initialization of the video port.

    Normally, this is the stuff we should put in the DriverEntry routine.
    However, the video port is being loaded as a DLL, and the DriverEntry
    is never called.  It would just be too much work to add it back to the hive
    and setup.

    This little routine works just as well.

--*/

{

    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS ntStatus;
    HANDLE physicalMemoryHandle = NULL;

    HAL_DISPLAY_BIOS_INFORMATION HalBiosInfo;
    ULONG HalBiosInfoLen = sizeof(ULONG);

    SYSTEM_BASIC_INFORMATION basicInfo;

#if defined(_X86_)

    //
    // Check for USWC disabling
    //

    EnableUSWC = TRUE;

#else

    EnableUSWC = FALSE;

#endif

    //
    // Determine if we have a VGA compatible machine
    //

    ntStatus = STATUS_SUCCESS;
    HalBiosInfo = HalDisplayInt10Bios;

    if (NT_SUCCESS(ntStatus)) {

        if (HalBiosInfo == HalDisplayInt10Bios) {

            VpC0000Compatible = 2;

        } else {

            // == HalDisplayEmulatedBios,
            // == HalDisplayNoBios

            VpC0000Compatible = 0;
        }

    } else {

        //
        // In case of an error in the API call, we just assume it's an old HAL
        // and use the old behaviour of the video port which is to assume
        // there is a BIOS at C000
        //

        VpC0000Compatible = 1;
    }


    //
    // Lets open the physical memory section just once, for all drivers.
    //

    //
    // Get a pointer to physical memory so we can map the
    // video frame buffer (and possibly video registers) into
    // the caller's address space whenever he needs it.
    //
    // - Create the name
    // - Initialize the data to find the object
    // - Open a handle to the oject and check the status
    // - Get a pointer to the object
    // - Free the handle
    //

    RtlInitUnicodeString(&UnicodeString,
                         L"\\Device\\PhysicalMemory");

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               (HANDLE) NULL,
                               (PSECURITY_DESCRIPTOR) NULL);

    ntStatus = ZwOpenSection(&physicalMemoryHandle,
                             SECTION_ALL_ACCESS,
                             &ObjectAttributes);

    if (NT_SUCCESS(ntStatus)) {

        ntStatus = ObReferenceObjectByHandle(physicalMemoryHandle,
                                             SECTION_ALL_ACCESS,
                                             (POBJECT_TYPE) NULL,
                                             KernelMode,
                                             &PhysicalMemorySection,
                                             (POBJECT_HANDLE_INFORMATION) NULL);

        if (!NT_SUCCESS(ntStatus)) {

            pVideoDebugPrint((1, "pVPInit: Could not reference physical memory\n"));
            ASSERT(PhysicalMemorySection == NULL);

        }

        ZwClose(physicalMemoryHandle);
    }

    VpSystemMemorySize = 0;

    ntStatus = ZwQuerySystemInformation(SystemBasicInformation,
                                        &basicInfo,
                                        sizeof(basicInfo),
                                        NULL);

    if (NT_SUCCESS(ntStatus)) {

        VpSystemMemorySize
            = (ULONGLONG)basicInfo.NumberOfPhysicalPages * (ULONGLONG)basicInfo.PageSize;
    }
}


VP_STATUS
VpRegistryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    )

{
    if (ValueLength && ValueData) {

        *((PULONG)Context) = *((PULONG)ValueData);

        return NO_ERROR;

    } else {

        return ERROR_INVALID_PARAMETER;
    }
}

NTSTATUS
VpAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
)
{
    NTSTATUS            ntStatus;
    PDEVICE_OBJECT      functionalDeviceObject;
    PDEVICE_OBJECT      attachedTo;
    PFDO_EXTENSION      fdoExtension;
    ULONG               extensionAllocationSize;
    PVIDEO_PORT_DRIVER_EXTENSION DriverObjectExtension;
    PVIDEO_HW_INITIALIZATION_DATA HwInitializationData;

    pVideoDebugPrint((1, "VpAddDevice\n"));

    DriverObjectExtension = (PVIDEO_PORT_DRIVER_EXTENSION)
                      IoGetDriverObjectExtension(DriverObject,
                                                 DriverObject);

    HwInitializationData = &DriverObjectExtension->HwInitData;

    extensionAllocationSize = HwInitializationData->HwDeviceExtensionSize +
                                  sizeof(FDO_EXTENSION);

    ntStatus = VpCreateDevice(DriverObject,
                              extensionAllocationSize,
                              &functionalDeviceObject);

    if (NT_SUCCESS(ntStatus)) {

        VideoDeviceNumber++;

        fdoExtension = (PFDO_EXTENSION)functionalDeviceObject->DeviceExtension;

        //
        // Set any deviceExtension fields here that are PnP specific
        //

        fdoExtension->PhysicalDeviceObject = PhysicalDeviceObject;

        //
        // Since the pnp system is notifying us of our device, this is
        // not a legacy device.
        //

        fdoExtension->Flags = PNP_ENABLED;

        //
        // Now attach to the PDO we were given.
        //

        attachedTo = IoAttachDeviceToDeviceStack(functionalDeviceObject,
                                                 PhysicalDeviceObject);

        if (attachedTo == NULL) {

            ASSERT(attachedTo != NULL);

            //
            // Couldn't attach.  Delete the FDO.
            //

            // BUGBUG
            //IoDeleteDevice(functionalDeviceObject);
            //return STATUS_NO_SUCH_DEVICE;
        }

        fdoExtension->AttachedDeviceObject = attachedTo;

        //
        // Set the power management flag indicating that device mapping
        // has not been done yet.
        //

        fdoExtension->IsMappingReady = FALSE ;

        //
        // Clear DO_DEVICE_INITIALIZING flag.
        //

        functionalDeviceObject->Flags |= DO_BUFFERED_IO | DO_POWER_PAGABLE;
        functionalDeviceObject->Flags &= ~(DO_DEVICE_INITIALIZING | DO_POWER_INRUSH);

        //
        // Save the function pointers to the new 5.0 miniport driver callbacks.
        //

        if (HwInitializationData->HwInitDataSize >
            FIELD_OFFSET(VIDEO_HW_INITIALIZATION_DATA, HwQueryInterface)) {

            fdoExtension->HwSetPowerState  = HwInitializationData->HwSetPowerState;
            fdoExtension->HwGetPowerState  = HwInitializationData->HwGetPowerState;
            fdoExtension->HwQueryInterface = HwInitializationData->HwQueryInterface;
        }
    }

    pVideoDebugPrint((1, "*\n* VpAddDevice returned: 0x%x\n*\n", ntStatus));

    return ntStatus;
}


NTSTATUS
VpCreateDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN ULONG DeviceExtensionSize,
    OUT PDEVICE_OBJECT *FunctionalDeviceObject
)
{
    WCHAR deviceNameBuffer[STRING_LENGTH];
    UNICODE_STRING deviceNameUnicodeString;
    DEVICE_OBJECT fdo;
    NTSTATUS ntStatus;
    PFDO_EXTENSION fdoExtension;

    ntStatus = pVideoPortCreateDeviceName(L"\\Device\\Video",
                                          VideoDeviceNumber,
                                          &deviceNameUnicodeString,
                                          deviceNameBuffer);

    //
    // Create a device object to represent the Video Adapter.
    //

    if (NT_SUCCESS(ntStatus)) {

        ntStatus = IoCreateDevice(DriverObject,
                                  DeviceExtensionSize,
                                  &deviceNameUnicodeString,
                                  FILE_DEVICE_VIDEO,
                                  0,
                                  TRUE,
                                  FunctionalDeviceObject);

        if (NT_SUCCESS(ntStatus)) {

            (*FunctionalDeviceObject)->DeviceType = FILE_DEVICE_VIDEO;
            fdoExtension = (*FunctionalDeviceObject)->DeviceExtension;

            //
            // Set any deviceExtension fields here
            //

            fdoExtension->DeviceNumber = VideoDeviceNumber;
            fdoExtension->FunctionalDeviceObject = *FunctionalDeviceObject;

            KeInitializeMutex(&fdoExtension->SyncMutex,
                              0);

#if DBG
            fdoExtension->AllocationHead = (PALLOC_ENTRY) NULL;
            ExInitializePagedLookasideList(&fdoExtension->AllocationList,
                                           NULL,
                                           NULL,
                                           0,
                                           sizeof(ALLOC_ENTRY),
                                           'LdiV',
                                           0);
#endif

        }
    }

    return ntStatus;
}

ULONG
VideoPortInitialize(
    IN PVOID Argument1,  // DriverObject
    IN PVOID Argument2,  // RegistryPath
    IN PVIDEO_HW_INITIALIZATION_DATA HwInitializationData,
    IN PVOID HwContext
    )
{
    PDRIVER_OBJECT driverObject = Argument1;
    NTSTATUS ntStatus;
    PUNICODE_STRING   registryPath = (PUNICODE_STRING) Argument2;
    ULONG PnpFlags;

    if (VPFirstTime)
    {
        VPFirstTime = FALSE;
        pVPInit();
    }

    //
    // Check if the size of the pointer, or the size of the data passed in
    // are OK.
    //

    ASSERT(HwInitializationData != NULL);

    if (HwInitializationData->HwInitDataSize >
        sizeof(VIDEO_HW_INITIALIZATION_DATA) ) {

        pVideoDebugPrint((0, "VideoPortInitialize: Invalid initialization data size\n"));
        return ((ULONG) STATUS_REVISION_MISMATCH);

    }

    //
    // Check that each required entry is not NULL.
    //

    if ((!HwInitializationData->HwFindAdapter) ||
        (!HwInitializationData->HwInitialize) ||
        (!HwInitializationData->HwStartIO)) {

        pVideoDebugPrint((1, "VideoPortInitialize: miniport missing required entry\n"));
        return ((ULONG)STATUS_REVISION_MISMATCH);

    }

    //
    // Set up the device driver entry points.
    //

    driverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = pVideoPortDispatch;
    driverObject->MajorFunction[IRP_MJ_CREATE]         = pVideoPortDispatch;
    driverObject->MajorFunction[IRP_MJ_CLOSE]          = pVideoPortDispatch;

    //
    // Check that the device extension size is reasonable.
    //

#if DBG
    if (HwInitializationData->HwDeviceExtensionSize > 0x4000) {
        pVideoDebugPrint((0, "Warning: Device Extension is stored in non-paged pool\n"
                             "         Do you need a 0x%x byte device extension?\n",
                             HwInitializationData->HwDeviceExtensionSize));
    }
#endif

    //
    // Check the registry for PnP Flags.  Currently we recongnize the
    // following values:
    //
    // PnPEnabled -   If this value is set with a non-zero value, we
    //                will treat behave like a PnP driver.
    //
    // LegacyDetect - If this value is non-zero, we will report
    //                a non-pci device to the system via
    //                IoReportDetectedDevice.
    //
    // If we don't get the flags, we don't know how to run this driver.
    // return failure
    //

    if (!(NT_SUCCESS(VpGetFlags(registryPath,
                                HwInitializationData,
                                &PnpFlags))))
    {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // PnP drivers have new rules.
    //

    if (PnpFlags & PNP_ENABLED)
    {
        pVideoDebugPrint((1, "videoprt : VideoPortInitialize with PNP_ENABLED\n"));

        //
        // We also can't be plug and play compatible if the driver passes
        // info in HwContext.  This is because we can't store this.
        //

        if ((PnpFlags & VGA_DRIVER) ||
            (HwContext != NULL))
        {
            pVideoDebugPrint((0, "videoprt : This video driver can not be PnP !\n"));
            ASSERT(FALSE);
            return STATUS_INVALID_PARAMETER;
        }

    } else {

        //
        // Only allow a non-pnp driver to install before win32k has started.
        //

        if (!InbvCheckDisplayOwnership()) {

            pVideoDebugPrint((0, "We can't dynamically start a non PnP device.\n"));
#if defined STATUS_REBOOT_REQUIRED
            return STATUS_REBOOT_REQUIRED;
#else
            return STATUS_INVALID_PARAMETER;
#endif
        }
    }

    //
    // Never do legacy detection of PnP drivers on the PCI Bus.
    //

    if (HwInitializationData->AdapterInterfaceType == PCIBus) {

        pVideoDebugPrint((1, "videoprt : VideoPortInitialize on PCI Bus\n"));

        if ( (PnpFlags & PNP_ENABLED) &&
             ((PnpFlags & LEGACY_DETECT) ||
              (PnpFlags & REPORT_DEVICE)) ) {

            pVideoDebugPrint((0, "videoprt : Trying to detect PnP driver on PCI - fail\n"));
            return STATUS_INVALID_PARAMETER;
        }
    }


    //
    // Set this information for all PnP Drivers
    //
    // Special !!! - we cannot do this in the LEGACY_DETECT because the system
    // will think we failed to load and return a failure code.
    //

    if ( (PnpFlags & PNP_ENABLED) &&
         (!(PnpFlags & LEGACY_DETECT)) )
    {
        PVIDEO_PORT_DRIVER_EXTENSION DriverObjectExtension;

        pVideoDebugPrint((1, "videoprt : We have a PnP Device.\n"));

        //
        // Fill in the new PnP entry points.
        //

        driverObject->DriverExtension->AddDevice  = VpAddDevice;
        driverObject->MajorFunction[IRP_MJ_PNP]   = pVideoPortPnpDispatch;

        //
        // we'll do findadapter during the START_DEVICE irp
        //
        // Store away arguments, so we can retrieve them when we need them.
        //
        // Try to create a DriverObjectExtension
        //

        if (DriverObjectExtension = (PVIDEO_PORT_DRIVER_EXTENSION)
                      IoGetDriverObjectExtension(driverObject,
                                                 driverObject))
        {
            DriverObjectExtension->HwInitData = *HwInitializationData;
            ntStatus = STATUS_SUCCESS;
        }
        else if (NT_SUCCESS(IoAllocateDriverObjectExtension(
                                driverObject,
                                driverObject,
                                sizeof(VIDEO_PORT_DRIVER_EXTENSION),
                                &DriverObjectExtension)))
        {

            DriverObjectExtension->RegistryPath = *registryPath;
            DriverObjectExtension->RegistryPath.MaximumLength += sizeof(WCHAR);
            DriverObjectExtension->RegistryPath.Buffer =
                ExAllocatePoolWithTag(PagedPool,
                                      DriverObjectExtension->RegistryPath.MaximumLength,
                                      'trpV');

            ASSERT(DriverObjectExtension->RegistryPath.Buffer);

            RtlCopyUnicodeString(&(DriverObjectExtension->RegistryPath),
                                 registryPath);

            DriverObjectExtension->HwInitData = *HwInitializationData;
            ntStatus = STATUS_SUCCESS;
        }
        else
        {
            //
            // Something went wrong.  We should have a
            // DriverObjectExtension by now.
            //

            pVideoDebugPrint((0, "IoAllocateDriverExtensionObject failed!\n"));
            pVideoDebugPrint((0, "for registry path %ws!\n", registryPath->Buffer));

            ASSERT(FALSE);

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }

    }


    //
    // If we are doing legacy detection or reporting, create the FDO
    // right now ...
    //

    if ((!(PnpFlags & PNP_ENABLED))  ||
         (PnpFlags & LEGACY_DETECT)  ||
         (PnpFlags & VGA_DRIVER)     ||
         (PnpFlags & REPORT_DEVICE)  ||
         (HwContext != NULL)) {

        ntStatus = STATUS_NO_SUCH_DEVICE;
    }

    return ntStatus;
}


NTSTATUS
VideoPortFindAdapter(
    IN PDRIVER_OBJECT DriverObject,
    IN PVOID Argument2,
    IN PVIDEO_HW_INITIALIZATION_DATA HwInitializationData,
    IN PVOID HwContext,
    PDEVICE_OBJECT DeviceObject,
    PUCHAR nextMiniport
    )
{
    NTSTATUS status;
    PFDO_EXTENSION fdoExtension = DeviceObject->DeviceExtension;

    status = VideoPortFindAdapter2(DriverObject,
                                   Argument2,
                                   HwInitializationData,
                                   HwContext,
                                   DeviceObject,
                                   nextMiniport);

    if (NT_SUCCESS(status))
    {
        //
        // Mark this object as supporting buffered I/O so that the I/O system
        // will only supply simple buffers in IRPs.
        //
        // Set and clear the two power fields to ensure we only get called
        // as passive level to do power management operations.
        //
        // Finally, tell the system we are done with Device Initialization
        //

        DeviceObject->Flags |= DO_BUFFERED_IO | DO_POWER_PAGABLE;
        DeviceObject->Flags &= ~(DO_DEVICE_INITIALIZING | DO_POWER_INRUSH);

        fdoExtension->Flags |= FINDADAPTER_SUCCEEDED;
    }

    return status;
}


NTSTATUS
VideoPortFindAdapter2(
    IN PDRIVER_OBJECT DriverObject,
    IN PVOID Argument2,
    IN PVIDEO_HW_INITIALIZATION_DATA HwInitializationData,
    IN PVOID HwContext,
    PDEVICE_OBJECT DeviceObject,
    PUCHAR nextMiniport
    )

{
    WCHAR deviceNameBuffer[STRING_LENGTH];
    POBJECT_NAME_INFORMATION deviceName;
    ULONG strLength;

    NTSTATUS ntStatus;
    WCHAR deviceSubpathBuffer[STRING_LENGTH];
    UNICODE_STRING deviceSubpathUnicodeString;
    WCHAR deviceLinkBuffer[STRING_LENGTH];
    UNICODE_STRING deviceLinkUnicodeString;
    KAFFINITY affinity;

    PVIDEO_PORT_CONFIG_INFO miniportConfigInfo = NULL;
    PDEVICE_OBJECT deviceObject;
    PFDO_EXTENSION fdoExtension;
    VP_STATUS findAdapterStatus = ERROR_DEV_NOT_EXIST;
    ULONG driverKeySize;
    PWSTR driverKeyName = NULL;
    BOOLEAN symbolicLinkCreated = FALSE;

    PDEVICE_OBJECT pdo;

    ntStatus = STATUS_NO_SUCH_DEVICE;

    deviceObject = DeviceObject;
    fdoExtension = deviceObject->DeviceExtension;

    pdo = fdoExtension->PhysicalDeviceObject;

    deviceName = (POBJECT_NAME_INFORMATION) deviceNameBuffer;

    ObQueryNameString(deviceObject,
                      deviceName,
                      STRING_LENGTH * sizeof(WCHAR),
                      &strLength);

    //
    // Allocate the buffer in which the miniport driver will store all the
    // configuration information.
    //

    miniportConfigInfo = (PVIDEO_PORT_CONFIG_INFO)
                             ExAllocatePoolWithTag(PagedPool,
                                                   sizeof(VIDEO_PORT_CONFIG_INFO),
                                                   POOL_TAG);

    if (miniportConfigInfo == NULL) {

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto EndOfInitialization;
    }

    RtlZeroMemory((PVOID) miniportConfigInfo,
                  sizeof(VIDEO_PORT_CONFIG_INFO));

    miniportConfigInfo->Length = sizeof(VIDEO_PORT_CONFIG_INFO);

    //
    // Put in the BusType specified within the HW_INITIALIZATION_DATA
    // structure by the miniport and the bus number inthe miniport config info.
    //

    miniportConfigInfo->SystemIoBusNumber = fdoExtension->SystemIoBusNumber;
    miniportConfigInfo->AdapterInterfaceType = fdoExtension->AdapterInterfaceType;

    //
    // Initialize the pointer to VpGetProcAddress.
    //

    miniportConfigInfo->VideoPortGetProcAddress = VpGetProcAddress;

    //
    // Initialize the type of interrupt based on the bus type.
    //

    switch (miniportConfigInfo->AdapterInterfaceType) {

    case Internal:
    case MicroChannel:
    case PCIBus:

        miniportConfigInfo->InterruptMode = LevelSensitive;
        break;

    default:

        miniportConfigInfo->InterruptMode = Latched;
        break;

    }

    //
    // Set up device extension pointers and sizes
    //

    fdoExtension->HwDeviceExtension = (PVOID)(fdoExtension + 1);
    fdoExtension->HwDeviceExtensionSize =
        HwInitializationData->HwDeviceExtensionSize;
    fdoExtension->MiniportConfigInfo = miniportConfigInfo;

    //
    // Save the dependent driver routines in the device extension.
    //

    fdoExtension->HwFindAdapter = HwInitializationData->HwFindAdapter;
    fdoExtension->HwInitialize = HwInitializationData->HwInitialize;
    fdoExtension->HwInterrupt = HwInitializationData->HwInterrupt;
    fdoExtension->HwStartIO = HwInitializationData->HwStartIO;

    if (HwInitializationData->HwInitDataSize >
        FIELD_OFFSET(VIDEO_HW_INITIALIZATION_DATA, HwLegacyResourceCount)) {

        fdoExtension->HwLegacyResourceList = HwInitializationData->HwLegacyResourceList;
        fdoExtension->HwLegacyResourceCount = HwInitializationData->HwLegacyResourceCount;
    }

    if (HwInitializationData->HwInitDataSize >
        FIELD_OFFSET(VIDEO_HW_INITIALIZATION_DATA, AllowEarlyEnumeration)) {

        fdoExtension->AllowEarlyEnumeration = HwInitializationData->AllowEarlyEnumeration;
    }

    //
    // Create the name we will be storing in the \DeviceMap.
    // This name is a PWSTR, not a unicode string
    // This is the name of the driver with an appended device number
    //

    if (!NT_SUCCESS(pVideoPortCreateDeviceName(L"\\Device",
                                               HwInitializationData->StartingDeviceNumber,
                                               &deviceSubpathUnicodeString,
                                               deviceSubpathBuffer))) {

        pVideoDebugPrint((1, "VideoPortInitialize: Could not create device subpath number\n"));
        goto EndOfInitialization;

    }

    fdoExtension->DriverRegistryPathLength =
        ((PUNICODE_STRING)Argument2)->Length +
        deviceSubpathUnicodeString.Length;

    driverKeySize = fdoExtension->DriverRegistryPathLength +
                    2 * sizeof(UNICODE_NULL);

    if ( (driverKeyName = (PWSTR) ExAllocatePoolWithTag(PagedPool,
                                                        driverKeySize,
                                                        POOL_TAG) ) == NULL) {

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto EndOfInitialization;
    }

    RtlMoveMemory(driverKeyName,
                  ((PUNICODE_STRING)Argument2)->Buffer,
                  ((PUNICODE_STRING)Argument2)->Length);

    RtlMoveMemory((PWSTR)( (ULONG_PTR)driverKeyName +
                           ((PUNICODE_STRING)Argument2)->Length ),
                  deviceSubpathBuffer,
                  deviceSubpathUnicodeString.Length);

    //
    // Put two NULLs at the end so we can play around with the string later.
    //

    *((PWSTR) ((ULONG_PTR)driverKeyName +
        fdoExtension->DriverRegistryPathLength)) = UNICODE_NULL;
    *((PWSTR) ((ULONG_PTR)driverKeyName +
        (fdoExtension->DriverRegistryPathLength + sizeof(UNICODE_NULL)))) =
                                                      UNICODE_NULL;

    //
    // There is a bug in Lotus Screen Cam where it will only work if our
    // reg path is \REGISTRY\Machine\System not \REGISTRY\MACHINE\SYSTEM.
    // so replace the appropriate strings.
    //

    if (wcsstr(driverKeyName, L"MACHINE")) {
        wcsncpy(wcsstr(driverKeyName, L"MACHINE"), L"Machine", sizeof("Machine")-1);
    }

    if (wcsstr(driverKeyName, L"SYSTEM")) {
        wcsncpy(wcsstr(driverKeyName, L"SYSTEM"), L"System", sizeof("System")-1);
    }

    //
    // Store the path name of the location of the driver in the registry.
    //

    fdoExtension->DriverRegistryPath = driverKeyName;
    miniportConfigInfo->DriverRegistryPath = driverKeyName;

    //
    // Let the driver know how much system memory is present.
    //

    miniportConfigInfo->SystemMemorySize = VpSystemMemorySize;

    //
    // Turn on the debug level based on the miniport driver entry
    //

    VideoPortGetRegistryParameters(fdoExtension->HwDeviceExtension,
                                   L"VideoDebugLevel",
                                   FALSE,
                                   VpRegistryCallback,
                                   &VideoDebugLevel);

    //
    // Obtain the override value for memory allocation from the registry
    // if present. Otherwise, go with the default.
    //

#if DBG
    //
    // Turn on the debug level based on the miniport driver entry
    //

    fdoExtension->FreeAllocation = MAXIMUM_MEM_LIMIT_K * 1024 ;
    fdoExtension->AllocationHead = (PALLOC_ENTRY) NULL ;

    //
    // Set up the default maximum allocation.  This will change
    // if there is a value in the registry.
    //

    fdoExtension->FreeAllocation = MAXIMUM_MEM_LIMIT_K * 1024 ;

    VideoPortGetRegistryParameters(fdoExtension->HwDeviceExtension,
                                   L"MaxAllocationLimit",
                                   FALSE,
                                   VpRegistryCallback,
                                   &(fdoExtension->FreeAllocation));

#endif

    if (VpAllowFindAdapter(fdoExtension)) {

        //
        // Notify the boot driver that we will be accessing the display
        // hardware.
        //

        VpEnableDisplay(FALSE);

#if DBG
        //
        // Mark the resources as not reported so we can detect if a miniport
        // uses an access range before reporting it.
        //

        InterlockedExchange(&VPResourcesReported, FALSE);

        //
        // The driver doesn't have to aquire resources if it claimed
        // them during DriverEntry.
        //

        if (fdoExtension->HwLegacyResourceCount) {
            InterlockedIncrement(&VPResourcesReported);
        }
#endif

        findAdapterStatus =
            fdoExtension->HwFindAdapter(fdoExtension->HwDeviceExtension,
                                        HwContext,
                                        NULL, // BUGBUG What is this string?
                                        miniportConfigInfo,
                                        nextMiniport);

#if DBG
        //
        // By now, the resources should have been claimed.
        //

        InterlockedIncrement(&VPResourcesReported);
#endif

        VpEnableDisplay(TRUE);
    }

    //
    // If the adapter is not found, display an error.
    //

    if (findAdapterStatus != NO_ERROR) {

        pVideoDebugPrint((1, "VideoPortFindAdapter: Find adapter failed\n"));

        ntStatus = STATUS_UNSUCCESSFUL;
        goto EndOfInitialization;

    }

    //
    // Store the required information in the device extension for later use.
    //

    fdoExtension->VdmPhysicalVideoMemoryAddress =
        miniportConfigInfo->VdmPhysicalVideoMemoryAddress;

    fdoExtension->VdmPhysicalVideoMemoryLength =
        miniportConfigInfo->VdmPhysicalVideoMemoryLength;

    fdoExtension->HardwareStateSize =
        miniportConfigInfo->HardwareStateSize;

    //
    // If the device supplies an interrupt service routine, we must
    // set up all the structures to support interrupts. Otherwise,
    // they can be ignored.
    //

    if (fdoExtension->HwInterrupt &&
        ((miniportConfigInfo->BusInterruptLevel != 0) ||
         (miniportConfigInfo->BusInterruptVector != 0)) ) {

        affinity = fdoExtension->InterruptAffinity;

        fdoExtension->InterruptMode = miniportConfigInfo->InterruptMode;

        fdoExtension->InterruptsEnabled = TRUE;

        ntStatus = IoConnectInterrupt(&fdoExtension->InterruptObject,
                                      (PKSERVICE_ROUTINE) pVideoPortInterrupt,
                                      deviceObject,
                                      NULL,
                                      fdoExtension->InterruptVector,
                                      fdoExtension->InterruptIrql,
                                      fdoExtension->InterruptIrql,
                                      fdoExtension->InterruptMode,
                                      (BOOLEAN) ((miniportConfigInfo->InterruptMode ==
                                          LevelSensitive) ? TRUE : FALSE),
                                      affinity,
                                      FALSE);

        if (!NT_SUCCESS(ntStatus)) {

            pVideoDebugPrint((0, "VideoPortInitialize: Can't connect interrupt\n"));
            goto EndOfInitialization;
        }

    } else {

        fdoExtension->HwInterrupt = NULL;

    }

    //
    // Initialize DPC Support
    //

    KeInitializeDpc(&fdoExtension->Dpc,
                    pVideoPortDpcDispatcher,
                    fdoExtension->HwDeviceExtension);

    //
    // New, Optional.
    // Setup the timer if it is specified by a driver.
    //

    if (HwInitializationData->HwInitDataSize >
        FIELD_OFFSET(VIDEO_HW_INITIALIZATION_DATA, HwTimer)){

        fdoExtension->HwTimer = HwInitializationData->HwTimer;

        if (fdoExtension->HwTimer) {
            ntStatus = IoInitializeTimer(deviceObject,
                                         pVideoPortHwTimer,
                                         NULL);

            //
            // If we fail forget about the timer !
            //

            if (!NT_SUCCESS(ntStatus)) {

                ASSERT(FALSE);
                fdoExtension->HwTimer = NULL;

            }
        }
    }

    //
    // New, Optional.
    // Reset Hw function.
    //

    if (HwInitializationData->HwInitDataSize >
        FIELD_OFFSET(VIDEO_HW_INITIALIZATION_DATA, HwResetHw)) {

        ULONG iReset;

        for (iReset=0; iReset<6; iReset++) {

            if (HwResetHw[iReset].ResetFunction == NULL) {

                HwResetHw[iReset].ResetFunction = HwInitializationData->HwResetHw;
                HwResetHw[iReset].HwDeviceExtension = fdoExtension->HwDeviceExtension;

                break;
            }
        }
    }

    //
    // NOTE:
    //
    // We only want to reinitialize the device once the Boot sequence has
    // been completed and the HAL does not need to access the device again.
    // So the initialization entry point will be called when the device is
    // opened.
    //


    if (!NT_SUCCESS(pVideoPortCreateDeviceName(L"\\DosDevices\\DISPLAY",
                                               fdoExtension->DeviceNumber + 1,
                                               &deviceLinkUnicodeString,
                                               deviceLinkBuffer))) {

        pVideoDebugPrint((1, "VideoPortInitialize: Could not create device subpath number\n"));
        goto EndOfInitialization;

    }

    ntStatus = IoCreateSymbolicLink(&deviceLinkUnicodeString,
                                    &deviceName->Name);


    if (!NT_SUCCESS(ntStatus)) {

        pVideoDebugPrint((0, "VideoPortInitialize: SymbolicLink Creation failed\n"));
        goto EndOfInitialization;

    }

    symbolicLinkCreated = TRUE;

    //
    // Save the function pointers to the new 5.0 miniport driver callbacks.
    //

    if (HwInitializationData->HwInitDataSize >
        FIELD_OFFSET(VIDEO_HW_INITIALIZATION_DATA, HwQueryInterface)) {

        fdoExtension->HwSetPowerState  = HwInitializationData->HwSetPowerState;
        fdoExtension->HwGetPowerState  = HwInitializationData->HwGetPowerState;
        fdoExtension->HwQueryInterface = HwInitializationData->HwQueryInterface;
    }

    if (HwInitializationData->HwInitDataSize >
        FIELD_OFFSET(VIDEO_HW_INITIALIZATION_DATA, HwChildDeviceExtensionSize)) {

        fdoExtension->HwChildDeviceExtensionSize =
            HwInitializationData->HwChildDeviceExtensionSize;
    }


EndOfInitialization:

    //
    // If we are doing detection, then don't save all of these objects.
    // We just want to see if the driver would load or not
    //

    if ( (fdoExtension->Flags & LEGACY_DETECT) ||
         (!NT_SUCCESS(ntStatus)) )
    {
        //
        // Free the miniport config info buffer.
        //

        if (miniportConfigInfo) {
            ExFreePool(miniportConfigInfo);
        }

        //
        // These are the things we want to delete if they were created and
        // the initialization *FAILED* at a later time.
        //

        if (fdoExtension->InterruptObject) {
            IoDisconnectInterrupt(fdoExtension->InterruptObject);
        }

        if (driverKeyName) {
            ExFreePool(driverKeyName);
        }

        fdoExtension->DriverRegistryPath = NULL;

        if (symbolicLinkCreated) {
            IoDeleteSymbolicLink(&deviceLinkUnicodeString);
        }

        //
        // Free up any memory mapped in by the miniport using
        // VideoPort GetDeviceBase.
        //

        while (fdoExtension->MappedAddressList != NULL)
        {
            pVideoDebugPrint((0, "VideoPortInitialize: unfreed address %08lx, physical %08lx, size %08lx\n",
                                 fdoExtension->MappedAddressList->MappedAddress,
                                 fdoExtension->MappedAddressList->PhysicalAddress.LowPart,
                                 fdoExtension->MappedAddressList->NumberOfUchars));

            pVideoDebugPrint((0, "VideoPortInitialize: unfreed refcount %d, unmapping %d\n\n",
                                 fdoExtension->MappedAddressList->RefCount,
                                 fdoExtension->MappedAddressList->bNeedsUnmapping));

            VideoPortFreeDeviceBase(fdoExtension->HwDeviceExtension,
                                    fdoExtension->MappedAddressList->MappedAddress);
        }

        //
        // Remove any HwResetHw function we may have added for this device.
        //

        if (HwInitializationData->HwInitDataSize >
            FIELD_OFFSET(VIDEO_HW_INITIALIZATION_DATA, HwResetHw)) {

            ULONG iReset;

            for (iReset=0; iReset<6; iReset++) {

                if (HwResetHw[iReset].HwDeviceExtension ==
                    fdoExtension->HwDeviceExtension) {

                    HwResetHw[iReset].ResetFunction = NULL;
                    break;
                }
            }
        }

    } else {

        HwInitializationData->StartingDeviceNumber++;

    }

#if DBG
    if ((!NT_SUCCESS(ntStatus)) || (findAdapterStatus != NO_ERROR)) {
      if (fdoExtension->AllocationHead != NULL) {
        pVideoDebugPrint((0, "VIDEOPRT: CANNOT DELETE DEVICE WITH")) ;
        pVideoDebugPrint((0, "          OUTSTANDING ALLOCATIONS."));
        ASSERT(FALSE);
      }
      ExDeletePagedLookasideList (&fdoExtension->AllocationList);
    }
#endif

    return ntStatus;
}


BOOLEAN
pVideoPortInterrupt(
    IN PKINTERRUPT Interrupt,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This function is the main interrupt service routine. If finds which
    miniport driver the interrupt was for and forwards it.

Arguments:

    Interrupt -

    DeviceObject -

Return Value:

    Returns TRUE if the interrupt was expected.

--*/

{
    PFDO_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    BOOLEAN bRet;

    UNREFERENCED_PARAMETER(Interrupt);

    //
    // If there is no interrupt routine, fail the assertion
    //

    ASSERT (fdoExtension->HwInterrupt);

#if DBG
    InterlockedIncrement(&VPResourcesReported);
#endif

    if (fdoExtension->InterruptsEnabled) {
        bRet = fdoExtension->HwInterrupt(fdoExtension->HwDeviceExtension);
    } else {
        bRet = FALSE;  // this device did not handle the interrupt
    }

#if DBG
    InterlockedDecrement(&VPResourcesReported);
#endif

    return bRet;

} // pVideoPortInterrupt()


VOID
VideoPortLogError(
    IN PVOID HwDeviceExtension,
    IN PVIDEO_REQUEST_PACKET Vrp OPTIONAL,
    IN VP_STATUS ErrorCode,
    IN ULONG UniqueId
    )

/*++

Routine Description:

    This routine saves the error log information so it can be processed at
    any IRQL.

Arguments:

    HwDeviceExtension - Supplies the HBA miniport driver's adapter data storage.

    Vrp - Supplies an optional pointer to a video request packet if there is
        one.

    ErrorCode - Supplies an error code indicating the type of error.

    UniqueId - Supplies a unique identifier for the error.

Return Value:

    None.

--*/

{
} // end VideoPortLogError()


VOID
pVideoPortMapToNtStatus(
    IN PSTATUS_BLOCK StatusBlock
    )

/*++

Routine Description:

    This function maps a Win32 error code to an NT error code, making sure
    the inverse translation will map back to the original status code.

Arguments:

    StatusBlock - Pointer to the status block

Return Value:

    None.

--*/

{
    PNTSTATUS status = &StatusBlock->Status;

    switch (*status) {

    case ERROR_INVALID_FUNCTION:
        *status = STATUS_NOT_IMPLEMENTED;
        break;

    case ERROR_NOT_ENOUGH_MEMORY:
        *status = STATUS_INSUFFICIENT_RESOURCES;
        break;

    case ERROR_INVALID_PARAMETER:
        *status = STATUS_INVALID_PARAMETER;
        break;

    case ERROR_INSUFFICIENT_BUFFER:
        *status = STATUS_BUFFER_TOO_SMALL;

        //
        // Make sure we zero out the information block if we get an
        // insufficient buffer.
        //

        StatusBlock->Information = 0;
        break;

    case ERROR_MORE_DATA:
        *status = STATUS_BUFFER_OVERFLOW;
        break;

    case ERROR_DEV_NOT_EXIST:
        *status = STATUS_DEVICE_DOES_NOT_EXIST;
        break;

    case ERROR_IO_PENDING:
        ASSERT(FALSE);
        // Fall through.

    case NO_ERROR:
        *status = STATUS_SUCCESS;
        break;

    default:

        pVideoDebugPrint((0, "Invalid return value from HwStartIo!\n"));
        ASSERT(FALSE);

        //
        // Since the driver did not see fit to follow the
        // rules about returning correct error codes. Videoprt will do it for
        // them.
        //

        *status = STATUS_UNSUCCESSFUL;

        break;

    }

    return;

} // end pVideoPortMapToNtStatus()


NTSTATUS
pVideoPortMapUserPhysicalMem(
    IN PFDO_EXTENSION FdoExtension,
    IN HANDLE ProcessHandle OPTIONAL,
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN OUT PULONG Length,
    IN OUT PULONG InIoSpace,
    IN OUT PVOID *VirtualAddress
    )

/*++

Routine Description:

    This function maps a view of a block of physical memory into a process'
    virtual address space.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    ProcessHandle - Optional handle to the process into which the memory must
        be mapped.

    PhysicalAddress - Offset from the beginning of physical memory, in bytes.

    Length - Pointer to a variable that will receive that actual size in
        bytes of the view. The length is rounded to a page boundary. THe
        length may not be zero.

    InIoSpace - Specifies if the address is in the IO space if TRUE; otherwise,
        the address is assumed to be in memory space.

    VirtualAddress - Pointer to a variable that will receive the base
        address of the view. If the initial value is not NULL, then the view
        will be allocated starting at teh specified virtual address rounded
        down to the next 64kb addess boundary.

Return Value:

    STATUS_UNSUCCESSFUL if the length was zero.
    STATUS_SUCCESS otherwise.

Environment:

    This routine cannot be called from a miniport routine synchronized with
    VideoPortSynchronizeRoutine or from an ISR.

--*/

{
    NTSTATUS ntStatus;
    HANDLE physicalMemoryHandle;
    PHYSICAL_ADDRESS physicalAddressBase;
    PHYSICAL_ADDRESS physicalAddressEnd;
    PHYSICAL_ADDRESS viewBase;
    PHYSICAL_ADDRESS mappedLength;
    HANDLE processHandle;
    BOOLEAN translateBaseAddress;
    BOOLEAN translateEndAddress;
    ULONG inIoSpace2;
    ULONG inIoSpace1;
    ULONG MapViewFlags;

    //
    // Check for a length of zero. If it is, the entire physical memory
    // would be mapped into the process' address space. An error is returned
    // in this case.
    //

    if (!*Length) {

        return STATUS_INVALID_PARAMETER_4;

    }

    if (!(*InIoSpace & VIDEO_MEMORY_SPACE_USER_MODE)) {

        return STATUS_INVALID_PARAMETER_5;

    }

    //
    // Get a handle to the physical memory section using our pointer.
    // If this fails, return.
    //

    ntStatus = ObOpenObjectByPointer(PhysicalMemorySection,
                                     0L,
                                     (PACCESS_STATE) NULL,
                                     SECTION_ALL_ACCESS,
                                     (POBJECT_TYPE) NULL,
                                     KernelMode,
                                     &physicalMemoryHandle);

    if (!NT_SUCCESS(ntStatus)) {

        return ntStatus;

    }

#ifdef _ALPHA_

    //
    // All flags are necessary for translation on ALPHA, except the P6 FLAG
    //

    inIoSpace1 = *InIoSpace & ~VIDEO_MEMORY_SPACE_P6CACHE;
    inIoSpace2 = *InIoSpace & ~VIDEO_MEMORY_SPACE_P6CACHE;

#else

    //
    // No flags are used in translation on non-alpha
    //

    inIoSpace1 = *InIoSpace & VIDEO_MEMORY_SPACE_IO;
    inIoSpace2 = *InIoSpace & VIDEO_MEMORY_SPACE_IO;

#endif

    //
    // Initialize the physical addresses that will be translated
    //

    physicalAddressEnd.QuadPart = PhysicalAddress.QuadPart + (*Length - 1);

    //
    // Translate the physical addresses.
    //

    translateBaseAddress =
        HalTranslateBusAddress(FdoExtension->AdapterInterfaceType,
                               FdoExtension->SystemIoBusNumber,
                               PhysicalAddress,
                               &inIoSpace1,
                               &physicalAddressBase);

    translateEndAddress =
        HalTranslateBusAddress(FdoExtension->AdapterInterfaceType,
                               FdoExtension->SystemIoBusNumber,
                               physicalAddressEnd,
                               &inIoSpace2,
                               &physicalAddressEnd);

    if ( !(translateBaseAddress && translateEndAddress) ) {

        ZwClose(physicalMemoryHandle);

        return STATUS_DEVICE_CONFIGURATION_ERROR;

    }

    ASSERT(inIoSpace1 == inIoSpace2);

    //
    // Calcualte the length of the memory to be mapped
    //

    mappedLength.QuadPart = physicalAddressEnd.QuadPart -
                            physicalAddressBase.QuadPart + 1;

    pVideoDebugPrint((3, "mapped Length = %x\n", mappedLength));

#ifndef _ALPHA_

    //
    // On all systems except ALPHA the mapped length should be the same as
    // the translated length.
    //

    ASSERT (((ULONG_PTR)mappedLength.QuadPart) == *Length);

#endif

    //
    // If the mappedlength is zero, somthing very weird happened in the HAL
    // since the Length was checked against zero.
    //

    ASSERT (mappedLength.QuadPart != 0);

    //
    // If the address is in io space, just return the address, otherwise
    // go through the mapping mechanism
    //

    if ( (*InIoSpace) & (ULONG)0x01 ) {

        (ULONG_PTR) *VirtualAddress = (ULONG_PTR) physicalAddressBase.QuadPart;

    } else {


        //
        // If no process handle was passed, get the handle to the current
        // process.
        //

        if (ProcessHandle) {

            processHandle = ProcessHandle;

        } else {

            processHandle = NtCurrentProcess();

        }

        //
        // initialize view base that will receive the physical mapped
        // address after the MapViewOfSection call.
        //

        viewBase = physicalAddressBase;

        //
        // Map the section
        //

        //
        // BUGBUG - what to do with already cached memory ???
        //

        if ((*InIoSpace) & VIDEO_MEMORY_SPACE_P6CACHE) {
            MapViewFlags = PAGE_READWRITE | PAGE_WRITECOMBINE;
        } else {
            MapViewFlags = PAGE_READWRITE | PAGE_NOCACHE;
        }

        ntStatus = ZwMapViewOfSection(physicalMemoryHandle,
                                      processHandle,
                                      VirtualAddress,
                                      0L,
                                      (ULONG_PTR) mappedLength.QuadPart,
                                      &viewBase,
                                      (PULONG_PTR) (&(mappedLength.QuadPart)),
                                      ViewUnmap,
                                      0,
                                      MapViewFlags);

        //
        // Close the handle since we only keep the pointer reference to the
        // section.
        //

        ZwClose(physicalMemoryHandle);

        //
        // Mapping the section above rounded the physical address down to the
        // nearest 64 K boundary. Now return a virtual address that sits where
        // we wnat by adding in the offset from the beginning of the section.
        //


        (ULONG_PTR) *VirtualAddress += (ULONG_PTR) (physicalAddressBase.QuadPart -
                                                  viewBase.QuadPart);
    }

#ifdef _ALPHA_

    //
    // Return the proper set of modified flags.
    //

    *InIoSpace = inIoSpace1 | *InIoSpace & VIDEO_MEMORY_SPACE_P6CACHE;

#else

    //
    // Restore all the other FLAGS
    // BUGBUG P6 flag may be affected !!
    //

    *InIoSpace = inIoSpace1 | *InIoSpace & ~VIDEO_MEMORY_SPACE_IO;

#endif

    *Length = mappedLength.LowPart;

    return ntStatus;

} // end pVideoPortMapUserPhysicalMem()

VP_STATUS
VideoPortAllocateBuffer(
    IN PVOID HwDeviceExtension,
    IN ULONG Size,
    OUT PVOID *Buffer
    )
{
    //
    // This routine attempts to allocate a paged pool buffer on behalf of a given
    // video miniport driver.
    //

    PFDO_EXTENSION fdoExtension = GET_FDO_EXT (HwDeviceExtension) ;
    PALLOC_ENTRY allocEntry, currentEntry ;

#if DBG
    if ((fdoExtension->FreeAllocation - (LONG)Size) < 0) {
        *Buffer = NULL ;
        pVideoDebugPrint ((0, "VIDEOPRT: Failing excessive allocation.\n"));
        return ERROR_INSUFFICIENT_BUFFER ;
    }
#endif

    *Buffer = ExAllocatePoolWithTag (PagedPool, Size, 'RdiV');
    if (*Buffer == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY ;
    }

#if DBG
    fdoExtension->FreeAllocation -= Size ;
    allocEntry = ExAllocateFromPagedLookasideList (&fdoExtension->AllocationList);
    allocEntry->Address = *Buffer ;
    allocEntry->Size = Size;
    allocEntry->Next = fdoExtension->AllocationHead ;
    fdoExtension->AllocationHead = allocEntry ;
#endif

    return NO_ERROR ;
}

VOID
VideoPortReleaseBuffer(
    IN PVOID HwDeviceExtension,
    IN PVOID Buffer
    )
{
  //
  // This routine releases a buffer allocated for a miniport driver by
  // VideoPortReleaseBuffer.
  //

#if DBG
    PALLOC_ENTRY currentEntry, prevEntry ;
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT (HwDeviceExtension) ;
    ASSERT (fdoExtension->AllocationHead != NULL) ;

    prevEntry = NULL ;
    currentEntry = fdoExtension->AllocationHead ;
    while (currentEntry->Address != Buffer) {
        prevEntry = currentEntry ;
        currentEntry = currentEntry->Next ;
        if (currentEntry == NULL) {
            pVideoDebugPrint ((0, "VIDEOPRT: Freeing memory not allocated!\n"));
            ASSERT (FALSE) ;
        }
    }

    if (prevEntry != NULL) {
        prevEntry->Next = currentEntry->Next ;
    } else {
        fdoExtension->AllocationHead = currentEntry->Next ;
    }
    fdoExtension->FreeAllocation += currentEntry->Size ;

    ExFreeToPagedLookasideList (&(fdoExtension->AllocationList),
                                currentEntry) ;
#endif

    ExFreePool (Buffer) ;
}


VP_STATUS
VideoPortMapMemory(
    PVOID HwDeviceExtension,
    PHYSICAL_ADDRESS PhysicalAddress,
    PULONG Length,
    PULONG InIoSpace,
    PVOID *VirtualAddress
    )

/*++

Routine Description:

    VideoPortMapMemory allows the miniport driver to map a section of
    physical memory (either memory or registers) into the calling process'
    address space (eventhough we are in kernel mode, this function is
    executed within the same context as the user-mode process that initiated
    the call).

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

    PhysicalAddress - Specifies the physical address to be mapped.

    Length - Points to the number of bytes of physical memory to be mapped.
        This argument returns the actual amount of memory mapped.

    InIoSpace - Points to a variable that is 1 if the address is in I/O
        space.  Otherwise, the address is assumed to be in memory space.

    VirtualAddress - A pointer to a location containing:

        on input: An optional handle to the process in which the memory must
            be mapped. 0 must be used to map the memory for the display
            driver (in the context of the windows server process).

        on output:  The return value is the virtual address at which the
            physical address has been mapped.

Return Value:

    VideoPortMapMemory returns the status of the operation.

Environment:

    This routine cannot be called from a miniport routine synchronized with
    VideoPortSynchronizeRoutine or from an ISR.

--*/

{

    NTSTATUS ntStatus;
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);
    HANDLE processHandle;

    //
    // Check for valid pointers.
    //

    if (!(ARGUMENT_PRESENT(Length)) ||
        !(ARGUMENT_PRESENT(InIoSpace)) ||
        !(ARGUMENT_PRESENT(VirtualAddress)) ) {

        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;

    }

    //
    // Let's handle the special memory types here.
    //
    // NOTE
    // Large pages is automatic - the caller need not specify this attribute
    // since it does not affect the device.

    //
    // Save the process handle and zero out the Virtual address field
    //

    if (*VirtualAddress == NULL) {

        if (*InIoSpace & VIDEO_MEMORY_SPACE_USER_MODE)
        {
            ASSERT(FALSE);
            return ERROR_INVALID_PARAMETER;
        }

        pVideoDebugPrint((3, "VideoPortMapMemory: Map Physical Address %08lx\n",
                         PhysicalAddress));

        ntStatus = STATUS_SUCCESS;

        //
        // We specify TRUE for large pages since we know the addrses will only
        // be used in the context of the display driver, at normal IRQL.
        //

        *VirtualAddress = pVideoPortGetDeviceBase(HwDeviceExtension,
                                                  PhysicalAddress,
                                                  *Length,
                                                  (UCHAR) (*InIoSpace),
                                                  TRUE);

        //
        // Zero can only be success if the driver is calling to MAP
        // address 0.  Otherwise, it is an error.
        // BUGBUG - is this really robust.
        //

        if (*VirtualAddress == NULL) {

            //
            // Only on X86 can the logical address also be 0.
            //

#if defined (_X86_) || defined (_ALPHA_) || defined(_IA64_)
            if (PhysicalAddress.QuadPart != 0)
#endif
                ntStatus = STATUS_INVALID_PARAMETER;
        }

    } else {

        if (!(*InIoSpace & VIDEO_MEMORY_SPACE_USER_MODE))
        {
            //
            // We can not assert since this is an existing path and old
            // drivers will not have this flag set.
            //
            // ASSERT(FALSE);
            // return ERROR_INVALID_PARAMETER;
            //

            *InIoSpace |= VIDEO_MEMORY_SPACE_USER_MODE;
        }

        processHandle = (HANDLE) *VirtualAddress;
        *VirtualAddress = NULL;

        pVideoDebugPrint((3, "VideoPortMapMemory: Map Physical Address %08lx\n",
                         PhysicalAddress));

        ntStatus = pVideoPortMapUserPhysicalMem(fdoExtension,
                                                processHandle,
                                                PhysicalAddress,
                                                Length,
                                                InIoSpace,
                                                VirtualAddress);

    }

    if (!NT_SUCCESS(ntStatus)) {

        *VirtualAddress = NULL;

        pVideoDebugPrint((0, "VideoPortMapMemory failed with NtStatus = %08lx\n",
                         ntStatus));
        ASSERT(FALSE);

        return ERROR_INVALID_PARAMETER;

    } else {

        pVideoDebugPrint((3, "VideoPortMapMemory succeded with Virtual Address = %08lx\n",
                         *VirtualAddress));

        return NO_ERROR;

    }

} // end VideoPortMapMemory()



VOID
pVideoPortPowerCompletionIoctl(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )

/*++

Routine Description:

    Completion routine that is called when one of our power irps has been
    comeplted.  This allows us to fill out the status code for the request.

Arguments:

    DeviceObject  - Pointer to the device object

    MinorFunction - Minor function of the IRP

    PowerState    - Power state that was set

    Context       - Context paramter

    IoStatus      - Status block for that IRP

Return Value:

    VOID

Environment:

--*/

{
    PPOWER_BLOCK powerContext = (PPOWER_BLOCK) Context;

    if (powerContext->FinalFlag == TRUE) {
        powerContext->Irp->IoStatus.Status = IoStatus->Status;
        IoCompleteRequest (powerContext->Irp, IO_VIDEO_INCREMENT);
    }

    ExFreePool(Context);

    return;
}




BOOLEAN
pVideoPortResetDisplay(
    IN ULONG Columns,
    IN ULONG Rows
    )

/*++

Routine Description:

    Callback for the HAL that calls the miniport driver.

Arguments:

    Columns - The number of columns of the video mode.

    Rows - The number of rows for the video mode.

Return Value:

    We always return FALSE so the HAL will always reste the mode afterwards.

Environment:
                        mep videoprt.cod
    Non-paged only.
    Used in BugCheck and soft-reset calls.

--*/

{

    ULONG iReset;
    BOOLEAN bRetVal = FALSE;

    for (iReset=0;
         (iReset < 6) && (HwResetHw[iReset].HwDeviceExtension);
         iReset++) {

        PFDO_EXTENSION fdoExtension =
            GET_FDO_EXT(HwResetHw[iReset].HwDeviceExtension);

        if (HwResetHw[iReset].ResetFunction &&
            fdoExtension->HwInitStatus == HwInitSucceeded) {

            bRetVal &= HwResetHw[iReset].ResetFunction(HwResetHw[iReset].HwDeviceExtension,
                                                       Columns,
                                                       Rows);
        }
    }

    return bRetVal;

} // end pVideoPortResetDisplay()



BOOLEAN
VideoPortScanRom(
    PVOID HwDeviceExtension,
    PUCHAR RomBase,
    ULONG RomLength,
    PUCHAR String
    )

/*++

Routine Description:

    Does a case *SENSITIVE* search for a string in the ROM.

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

    RomBase - Base address at which the search should start.

    RomLength - Size, in bytes, of the ROM area in which to perform the
        search.

    String - String to search for

Return Value:

    Returns TRUE if the string was found.
    Returns FALSE if it was not found.

Environment:

    This routine cannot be called from a miniport routine synchronized with
    VideoPortSynchronizeRoutine or from an ISR.

--*/

{
    ULONG stringLength, length;
    ULONG_PTR startOffset;
    PUCHAR string1, string2;
    BOOLEAN match;

    UNREFERENCED_PARAMETER(HwDeviceExtension);

    stringLength = strlen(String);

    for (startOffset = 0;
         startOffset < RomLength - stringLength + 1;
         startOffset++) {

        length = stringLength;
        string1 = RomBase + startOffset;
        string2 = String;
        match = TRUE;

        IS_ACCESS_RANGES_DEFINED()

        while (length--) {

            if (READ_REGISTER_UCHAR(string1++) - (*string2++)) {

                match = FALSE;
                break;

            }
        }

        if (match) {

            return TRUE;
        }
    }

    return FALSE;

} // end VideoPortScanRom()



VP_STATUS
VideoPortSetRegistryParameters(
    PVOID HwDeviceExtension,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    )

/*++

Routine Description:

    VideoPortSetRegistryParameters writes information to the CurrentControlSet
    in the registry.  The function automatically searches for or creates the
    specified parameter name under the parameter key of the current driver.

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

    ValueName - Points to a Unicode string that contains the name of the
        data value being written in the registry.

    ValueData - Points to a buffer containing the information to be written
        to the registry.

    ValueLength - Specifies the size of the data being written to the registry.

Return Value:

    This function returns the final status of the operation.

Environment:

    This routine cannot be called from a miniport routine synchronized with
    VideoPortSynchronizeRoutine or from an ISR.

--*/

{
    NTSTATUS ntStatus;
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    //
    // Don't let people store as DefaultSettings anymore ...
    // Must still work for older drivers through.
    //

    if (wcsncmp(ValueName,
                L"DefaultSettings.",
                sizeof(L"DefaultSettings.")) == 0) {

        ASSERT(FALSE);

        //
        // check for NT 5.0
        //

        if (fdoExtension->HwGetPowerState) {

            return ERROR_INVALID_PARAMETER;
        }
    }

    //
    // BUGBUG What happens for files ... ?
    //

    ntStatus = RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                     fdoExtension->DriverRegistryPath,
                                     ValueName,
                                     REG_BINARY,
                                     ValueData,
                                     ValueLength);

    if (!NT_SUCCESS(ntStatus)) {

        return ERROR_INVALID_PARAMETER;

    } else {

        return NO_ERROR;

    }

} // end VideoPortSetRegistryParamaters()



VOID
pVideoPortHwTimer(
    IN PDEVICE_OBJECT DeviceObject,
    PVOID Context
    )

/*++

Routine Description:

    This function is the main entry point for the timer routine that we then
    forward to the miniport driver.

Arguments:

    DeviceObject -

    Context - Not needed

Return Value:

    None.

--*/

{
    PFDO_EXTENSION fdoExtension = DeviceObject->DeviceExtension;

    UNREFERENCED_PARAMETER(Context);

#if DBG
    InterlockedIncrement(&VPResourcesReported);
#endif

    fdoExtension->HwTimer(fdoExtension->HwDeviceExtension);

#if DBG
    InterlockedDecrement(&VPResourcesReported);
#endif

    return;

} // pVideoPortInterrupt()



VOID
VideoPortStartTimer(
    PVOID HwDeviceExtension
    )

/*++

Routine Description:

    Enables the timer specified in the HW_INITIALIZATION_DATA structure
    passed to the video port driver at init time.

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

Return Value:

    None

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    if (fdoExtension->HwTimer == NULL) {

        ASSERT(fdoExtension->HwTimer != NULL);

    } else {

        IoStartTimer(fdoExtension->FunctionalDeviceObject);

    }

    return;
}



VOID
VideoPortStopTimer(
    PVOID HwDeviceExtension
    )

/*++

Routine Description:

    Disables the timer specified in the HW_INITIALIZATION_DATA structure
    passed to the video port driver at init time.

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

Return Value:

    None

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    if (fdoExtension->HwTimer == NULL) {

        ASSERT(fdoExtension->HwTimer != NULL);

    } else {

        IoStopTimer(fdoExtension->FunctionalDeviceObject);

    }

    return;
}



BOOLEAN
VideoPortSynchronizeExecution(
    PVOID HwDeviceExtension,
    VIDEO_SYNCHRONIZE_PRIORITY Priority,
    PMINIPORT_SYNCHRONIZE_ROUTINE SynchronizeRoutine,
    PVOID Context
    )

/*++

    Stub so we can allow the miniports to link directly

--*/

{
    return pVideoPortSynchronizeExecution(HwDeviceExtension,
                                          Priority,
                                          SynchronizeRoutine,
                                          Context);
} // end VideoPortSynchronizeExecution()

BOOLEAN
pVideoPortSynchronizeExecution(
    PVOID HwDeviceExtension,
    VIDEO_SYNCHRONIZE_PRIORITY Priority,
    PMINIPORT_SYNCHRONIZE_ROUTINE SynchronizeRoutine,
    PVOID Context
    )

/*++

Routine Description:

    VideoPortSynchronizeExecution synchronizes the execution of a miniport
    driver function in the following manner:

        - If Priority is equal to VpLowPriority, the current thread is
          raised to the highest non-interrupt-masking priority.  In
          other words, the current thread can only be pre-empted by an ISR.

        - If Priority is equal to VpMediumPriority and there is an
          ISR associated with the video device, then the function specified
          by SynchronizeRoutine is synchronized with the ISR.

          If no ISR is connected, synchronization is made at VpHighPriority
          level.

        - If Priority is equal to VpHighPriority, the current IRQL is
          raised to HIGH_LEVEL, which effectively masks out ALL interrupts
          in the system. This should be done sparingly and for very short
          periods -- it will completely freeze up the entire system.

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

    Priority - Specifies the type of priority at which the SynchronizeRoutine
        must be executed (found in VIDEO_SYNCHRONIZE_PRIORITY).

    SynchronizeRoutine - Points to the miniport driver function to be
        synchronized.

    Context - Specifies a context parameter to be passed to the miniport's
        SynchronizeRoutine.

Return Value:

    This function returns TRUE if the operation is successful.  Otherwise, it
    returns FALSE.

--*/

{
    BOOLEAN status;
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);
    KIRQL oldIrql;

    //
    // Switch on which type of priority.
    //

    switch (Priority) {

    case VpMediumPriority:

        //
        // This is synchronized with the interrupt object
        //

        if (fdoExtension->InterruptObject) {

            status = KeSynchronizeExecution(fdoExtension->InterruptObject,
                                            (PKSYNCHRONIZE_ROUTINE)
                                            SynchronizeRoutine,
                                            Context);

            ASSERT (status == TRUE);

            return status;
        }

        //
        // Fall through for Medium Priority
        //

    case VpLowPriority:

        //
        // Just normal level
        //

        status = SynchronizeRoutine(Context);

        return status;

    case VpHighPriority:

        //
        // This is like cli\sti where we mask out everything.
        //

        //
        // Get the current IRQL to catch re-entrant routines into synchronize.
        //

        oldIrql = KeGetCurrentIrql();

        if (oldIrql < POWER_LEVEL - 1) {

            KeRaiseIrql(POWER_LEVEL, &oldIrql);

        }

        status = SynchronizeRoutine(Context);

        if (oldIrql < POWER_LEVEL - 1) {

            KeLowerIrql(oldIrql);

        }

        return status;

        break;

    default:

        return FALSE;

    }
}



VP_STATUS
VideoPortUnmapMemory(
    PVOID HwDeviceExtension,
    PVOID VirtualAddress,
    HANDLE ProcessHandle
    )

/*++

Routine Description:

    VideoPortUnmapMemory allows the miniport driver to unmap a physical
    address range previously mapped into the calling process' address space
    using the VideoPortMapMemory function.

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

    VirtualAddress - Points to the virtual address to unmap from the
        address space of the caller.

    // InIoSpace - Specifies whether the address is in I/O space (1) or memory
    //     space (0).

    ProcessHandle - Handle to the process from which memory must be unmapped.

Return Value:

    This function returns a status code of NO_ERROR if the operation succeeds.
    It returns ERROR_INVALID_PARAMETER if an error occurs.

Environment:

    This routine cannot be called from a miniport routine synchronized with
    VideoPortSynchronizeRoutine or from an ISR.

--*/

{
    NTSTATUS ntstatus;
    VP_STATUS vpStatus = NO_ERROR;
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    //
    // Backwards compatibility to when the ProcessHandle was actually
    // ULONG InIoSpace.
    //

    if (((ULONG_PTR)(ProcessHandle)) == 1) {

        pVideoDebugPrint((0,"\n\n*** VideoPortUnmapMemory - interface change *** Must pass in process handle\n\n"));
        DbgBreakPoint();

        return NO_ERROR;

    }

    if (((ULONG_PTR)(ProcessHandle)) == 0) {

        //
        // If the process handle is zero, it means it was mapped by the display
        // driver and is therefore in kernel mode address space.
        //

        if (!pVideoPortFreeDeviceBase(HwDeviceExtension, VirtualAddress)) {

            ASSERT(FALSE);

            vpStatus = ERROR_INVALID_PARAMETER;

        }

    } else {

        //
        // A process handle is passed in.
        // This ms it was mapped for use by an application (DCI \ DirectDraw).
        //

#ifdef _ALPHA_
        //
        // On Alpha, VirtualAddress may not be a true VA if this was
        // a sparse memory or IO space.   Transform the QVA to a VA,
        // if necessary.
        //

        VirtualAddress = HalDereferenceQva(VirtualAddress,
                                           fdoExtension->AdapterInterfaceType,
                                           fdoExtension->SystemIoBusNumber);

#endif

        ntstatus = ZwUnmapViewOfSection ( ProcessHandle,
            (PVOID) ( ((ULONG_PTR)VirtualAddress) & (~(PAGE_SIZE - 1)) ) );

        if ( (!NT_SUCCESS(ntstatus)) &&
             (ntstatus != STATUS_PROCESS_IS_TERMINATING) ) {

            ASSERT(FALSE);

            vpStatus = ERROR_INVALID_PARAMETER;

        }
    }

    return NO_ERROR;

} // end VideoPortUnmapMemory()


/////////////////////////////////////////////////////////
//
//  Video port/miniport interface for ENG_EVENTs
//
//  All Events are created or mapped by display driver. If the miniport wants
//  them, the display driver must convey them to the miniport and the miniport
//  must treat them as type VIDEO_PORT_EVENT, which must be the same as
//  ENG_EVENT from winddi.h. Because KEVENTs cannot be set from ISRs, the
//  mechanism provided for SetEvent queues a DPC, which actually sets the
//  event.
//
//

//
// PRIVATE structure. NOTE: this must be same as for ENG/GDI.
//
//
//typedef struct _VIDEO_PORT_EVENT {
//  PKEVENT pKEvent;
//  ULONG   fFlags;
//  } VIDEO_PORT_EVENT, *PVIDEO_PORT_EVENT;
//
//

VOID
pVideoPortSetEvent(
    PVIDEO_PORT_EVENT   pVPEvent
    )
/*++

Routine Description:


Arguments:

    pVPEvent - a PVIDEO_PORT_EVENT

Return Value:

    None.

    Note: this is called via a dpc queued via VideoSetEvent(). It's possible
    that this routine executes after the associated KEVENT is no longer valid
    (either the display driver deleted it or it's DriverObject is being
    deleted via EngUnmapEvent. In either case, the containing VIDEO_PORT_EVENT
    has been marked as both "invalid" and "in a dpc". In this case, we free it,
    possibly ObDereferencing it if it's mapped.

--*/
{
    if ((pVPEvent->pKEvent) &&
        (!(pVPEvent->fFlags & ENG_EVENT_FLAG_IS_INVALID))) {

        pVideoDebugPrint((2, "Set the event at %xin VP DPC\n", pVPEvent));
        KeSetEvent(pVPEvent->pKEvent, 0, FALSE);
        pVPEvent->fFlags &= ~ENG_EVENT_FLAG_IN_DPC;

    } else {

        //
        //  If this is marked as invalid, then the GDI Engine is trying to
        //  delete it. The delete routine in gre will wait until it's the
        //  ENG_EVENT_FLAG_IN_DPC bit is cleared.
        //

        if (pVPEvent->fFlags & ENG_EVENT_FLAG_IS_INVALID) {

            pVPEvent->fFlags &= ~ENG_EVENT_FLAG_IN_DPC;

        } else {

            pVideoDebugPrint((0, "Bad PEVENT\n"));
        }
    }

}

#if DBG

PIO_RESOURCE_REQUIREMENTS_LIST
BuildRequirements(
    PCM_RESOURCE_LIST pcmResourceList
    )
{
    ULONG i;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pcmDescript;

    PIO_RESOURCE_REQUIREMENTS_LIST Requirements;
    PIO_RESOURCE_DESCRIPTOR pioDescript;

    ULONG RequirementsListSize;
    ULONG RequirementCount;

    pVideoDebugPrint((1, "Building Requirements List...\n"));

    RequirementCount = pcmResourceList->List[0].PartialResourceList.Count;

    RequirementsListSize = sizeof(IO_RESOURCE_REQUIREMENTS_LIST) +
                              ((RequirementCount - 1) *
                              sizeof(IO_RESOURCE_DESCRIPTOR));

    Requirements = (PIO_RESOURCE_REQUIREMENTS_LIST) ExAllocatePool(
                                                        PagedPool,
                                                        RequirementsListSize);

    Requirements->ListSize         = RequirementsListSize;
    Requirements->InterfaceType    = pcmResourceList->List[0].InterfaceType;
    Requirements->BusNumber        = pcmResourceList->List[0].BusNumber;
    Requirements->SlotNumber       = -1; // ???
    Requirements->AlternativeLists = 0; // ???

    Requirements->List[0].Version  = pcmResourceList->List[0].PartialResourceList.Version;
    Requirements->List[0].Revision = pcmResourceList->List[0].PartialResourceList.Revision;
    Requirements->List[0].Count    = RequirementCount;

    pcmDescript = &(pcmResourceList->List[0].PartialResourceList.PartialDescriptors[0]);
    pioDescript = &(Requirements->List[0].Descriptors[0]);

    for (i=0; i<RequirementCount; i++) {

        pioDescript->Option = IO_RESOURCE_PREFERRED;
        pioDescript->Type   = pcmDescript->Type;
        pioDescript->ShareDisposition = pcmDescript->ShareDisposition;
        pioDescript->Flags  = pcmDescript->Flags;

        switch (pcmDescript->Type) {
        case CmResourceTypePort:
            pioDescript->u.Port.Length = pcmDescript->u.Port.Length;
            pioDescript->u.Port.Alignment = 1;
            pioDescript->u.Port.MinimumAddress =
            pioDescript->u.Port.MaximumAddress = pcmDescript->u.Port.Start;
            break;

        case CmResourceTypeMemory:
            pioDescript->u.Memory.Length = pcmDescript->u.Memory.Length;
            pioDescript->u.Memory.Alignment = 1;
            pioDescript->u.Memory.MinimumAddress =
            pioDescript->u.Memory.MaximumAddress = pcmDescript->u.Memory.Start;
            break;

        default:

            //
            // We don't have to handle the other stuff, because we only
            // want to report Ports and Memory to the system.
            //

            break;
        }

        pioDescript++;
        pcmDescript++;
    }

    return Requirements;
}

VOID
DumpRequirements(
    PIO_RESOURCE_REQUIREMENTS_LIST Requirements
    )
{
    ULONG i;

    PIO_RESOURCE_DESCRIPTOR pioDescript;

    ULONG RequirementsListSize;
    ULONG RequirementCount = Requirements->List[0].Count;

    char *Table[] = { "Internal",
                      "Isa",
                      "Eisa",
                      "MicroChannel",
                      "TurboChannel",
                      "PCIBus",
                      "VMEBus",
                      "NuBus",
                      "PCMCIABus",
                      "CBus",
                      "MPIBus",
                      "MPSABus",
                      "ProcessorInternal",
                      "InternalPowerBus",
                      "PNPISABus",
                      "MaximumInterfaceType"
                    };

    pVideoDebugPrint((1, "ListSize:         0x%x\n"
                         "InterfaceType:    %s\n"
                         "BusNumber:        0x%x\n"
                         "SlotNumber:       0x%x\n"
                         "AlternativeLists: 0x%x\n",
                         Requirements->ListSize,
                         Table[Requirements->InterfaceType],
                         Requirements->BusNumber,
                         Requirements->SlotNumber,
                         Requirements->AlternativeLists));

    pVideoDebugPrint((1, "List[0].Version:  0x%x\n"
                         "List[0].Revision: 0x%x\n"
                         "List[0].Count:    0x%x\n",
                         Requirements->List[0].Version,
                         Requirements->List[0].Revision,
                         Requirements->List[0].Count));

    pioDescript = &(Requirements->List[0].Descriptors[0]);

    for (i=0; i<RequirementCount; i++) {

        pVideoDebugPrint((1, "\n"
                             "Option:           0x%x\n"
                             "Type:             0x%x\n"
                             "ShareDisposition: 0x%x\n"
                             "Flags:            0x%x\n",
                             pioDescript->Option,
                             pioDescript->Type,
                             pioDescript->ShareDisposition,
                             pioDescript->Flags));

        switch (pioDescript->Type) {
        case CmResourceTypePort:

            pVideoDebugPrint((1, "\nPort...\n"
                                 "\tLength:         0x%x\n"
                                 "\tAlignment:      0x%x\n"
                                 "\tMinimumAddress: 0x%x\n"
                                 "\tMaximumAddress: 0x%x\n",
                                 pioDescript->u.Port.Length,
                                 pioDescript->u.Port.Alignment,
                                 pioDescript->u.Port.MinimumAddress,
                                 pioDescript->u.Port.MaximumAddress));

            break;

        case CmResourceTypeMemory:

            pVideoDebugPrint((1, "\nMemory...\n"
                                 "\tLength:         0x%x\n"
                                 "\tAlignment:      0x%x\n"
                                 "\tMinimumAddress: 0x%x\n"
                                 "\tMaximumAddress: 0x%x\n",
                                 pioDescript->u.Memory.Length,
                                 pioDescript->u.Memory.Alignment,
                                 pioDescript->u.Memory.MinimumAddress,
                                 pioDescript->u.Memory.MaximumAddress));
            break;

        case CmResourceTypeInterrupt:

            pVideoDebugPrint((1, "\nInterrupt...\n"
                                 "\tMinimum Vector: 0x%x\n"
                                 "\tMaximum Vector: 0x%x\n",
                                 pioDescript->u.Interrupt.MinimumVector,
                                 pioDescript->u.Interrupt.MaximumVector));

            break;

        default:

            //
            // We don't have to handle the other stuff, because we only
            // want to report Ports and Memory to the system.
            //

            break;
        }

        pioDescript++;
    }

    return;
}

VOID
DumpResourceList(
    PCM_RESOURCE_LIST pcmResourceList)
{
    ULONG i, j;
    PCM_FULL_RESOURCE_DESCRIPTOR    pcmFull;
    PCM_PARTIAL_RESOURCE_LIST       pcmPartial;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pcmDescript;

    pVideoDebugPrint((1, "...StartResourceList...\n"));

    pcmFull = &(pcmResourceList->List[0]);
    for (i=0; i<pcmResourceList->Count; i++) {

        pVideoDebugPrint((1, "List[%d]\n", i));

        pVideoDebugPrint((1, "InterfaceType = 0x%x\n", pcmFull->InterfaceType));
        pVideoDebugPrint((1, "BusNumber = 0x%x\n", pcmFull->BusNumber));

        pcmPartial = &(pcmFull->PartialResourceList);

        pVideoDebugPrint((1, "Version = 0x%x\n", pcmPartial->Version));
        pVideoDebugPrint((1, "Revision = 0x%x\n", pcmPartial->Revision));

        pcmDescript = &(pcmPartial->PartialDescriptors[0]);

        for (j=0; j<pcmPartial->Count; j++) {

            switch (pcmDescript->Type) {
            case CmResourceTypePort:
                pVideoDebugPrint((1, "Port: 0x%x Length: 0x%x\n",
                                  pcmDescript->u.Port.Start.LowPart,
                                  pcmDescript->u.Port.Length));

                break;

            case CmResourceTypeInterrupt:
                pVideoDebugPrint((1, "Interrupt: 0x%x Level: 0x%x\n",
                                  pcmDescript->u.Interrupt.Vector,
                                  pcmDescript->u.Interrupt.Level));
                break;

            case CmResourceTypeMemory:
                pVideoDebugPrint((1, "Start: 0x%x Length: 0x%x\n",
                                  pcmDescript->u.Memory.Start.LowPart,
                                  pcmDescript->u.Memory.Length));
                break;

            case CmResourceTypeDma:
                pVideoDebugPrint((1, "Dma Channel: 0x%x Port: 0x%x\n",
                                  pcmDescript->u.Dma.Channel,
                                  pcmDescript->u.Dma.Port));
                break;
            }

            pcmDescript++;
        }

        pcmFull = (PCM_FULL_RESOURCE_DESCRIPTOR) pcmDescript;
    }

    pVideoDebugPrint((1, "...EndResourceList...\n"));
}

VOID
DumpHwInitData(
    IN PVIDEO_HW_INITIALIZATION_DATA p
    )

/*++

Routine Description:

    Dump enough of the HwInitData to visually see if it is valid.

Arguments:

    Pointer to HwInitializationData

Return Value:

    none

--*/


{
    pVideoDebugPrint((0, "HwInitializationData...\n"));

    pVideoDebugPrint((0, "  HwInitDataSize: 0x%x\n", p->HwInitDataSize));


    pVideoDebugPrint((0, "  AdapterInterfaceType: %s\n",
                         BusType[p->AdapterInterfaceType]));

    pVideoDebugPrint((0, "  HwDeviceExtensionSize: 0x%x\n",
                         p->HwDeviceExtensionSize));

    pVideoDebugPrint((0, "  StartingDeviceNumber: 0x%x\n",
                         p->StartingDeviceNumber));

    pVideoDebugPrint((0, "  HwStartIO: 0x%x\n",
                         p->HwStartIO));

}

VOID
DumpUnicodeString(
    IN PUNICODE_STRING p
    )
{
    PUSHORT pus = p->Buffer;
    UCHAR buffer[256];       // the string better not be longer than 255 chars!
    PUCHAR puc = buffer;
    ULONG i;

    for (i = 0; i < p->Length; i++) {

        *puc++ = (UCHAR) *pus++;

    }

    *puc = 0;  // null terminate the string

    pVideoDebugPrint((0, "UNICODE STRING: %s\n", buffer));
}

#endif

VIDEOPORT_API
VP_STATUS
VideoPortQueryServices(
    IN PVOID pHwDeviceExtension,
    IN VIDEO_PORT_SERVICES servicesType,
    IN OUT PINTERFACE pInterface
    )

/*++

Routine Description:

    This routine exposes interfaces to services supported by the videoprt.

Arguments:

    pHwDeviceExtension - Points to per-adapter device extension.
    servicesType       - Requested services type.
    pInterface         - Points to services interface structure.

Returns:

    NO_ERROR   - Valid interface in the pInterface.
    Error code - Unsupported / unavailable services.

--*/

{
    VP_STATUS vpStatus;

    PAGED_CODE();
    ASSERT(NULL != pHwDeviceExtension);
    ASSERT(NULL != pInterface);
    ASSERT(IS_HW_DEVICE_EXTENSION(pHwDeviceExtension) == TRUE);

    if (VideoPortServicesAGP == servicesType)
    {
        PVIDEO_PORT_AGP_INTERFACE pAgpInterface = (PVIDEO_PORT_AGP_INTERFACE)pInterface;

        if ((pAgpInterface->Size != sizeof (VIDEO_PORT_AGP_INTERFACE)) ||
            (pAgpInterface->Version != 1))
        {
            pVideoDebugPrint((0, "VIDEOPRT!VideoPortQueryServices: Unsupported interface version\n"));
            ASSERT(FALSE);
            vpStatus = ERROR_INVALID_PARAMETER;
        }
        else
        {
            pAgpInterface->Context              = pHwDeviceExtension;
            pAgpInterface->InterfaceReference   = VpInterfaceDefaultReference;
            pAgpInterface->InterfaceDereference = VpInterfaceDefaultDereference;

            if (VideoPortGetAgpServices(pHwDeviceExtension,
                (PVIDEO_PORT_AGP_SERVICES)&(pAgpInterface->AgpReservePhysical)) == TRUE)
            {
                vpStatus = NO_ERROR;
            }
            else
            {
                vpStatus = ERROR_DEV_NOT_EXIST;
            }
        }
    }
    else if (VideoPortServicesI2C == servicesType)
    {
        PVIDEO_PORT_I2C_INTERFACE pI2CInterface = (PVIDEO_PORT_I2C_INTERFACE)pInterface;

        if ((pI2CInterface->Size != sizeof (VIDEO_PORT_I2C_INTERFACE)) ||
            (pI2CInterface->Version != 1))
        {
            pVideoDebugPrint((0, "VIDEOPRT!VideoPortQueryServices: Unsupported interface version\n"));
            ASSERT(FALSE);
            vpStatus = ERROR_INVALID_PARAMETER;
        }
        else
        {
            pI2CInterface->Context              = pHwDeviceExtension;
            pI2CInterface->InterfaceReference   = VpInterfaceDefaultReference;
            pI2CInterface->InterfaceDereference = VpInterfaceDefaultDereference;
            pI2CInterface->I2CStart             = I2CStart;
            pI2CInterface->I2CStop              = I2CStop;
            pI2CInterface->I2CWrite             = I2CWrite;
            pI2CInterface->I2CRead              = I2CRead;

            vpStatus = NO_ERROR;
        }
    }
    else
    {
        pVideoDebugPrint((0, "VIDEOPRT!VideoPortQueryServices: Unsupported service type\n"));
        ASSERT(FALSE);
        vpStatus = ERROR_INVALID_PARAMETER;
    }

    return vpStatus;
}   // VideoPortQueryServices()

VOID
VpInterfaceDefaultReference(
    IN PVOID pContext
    )

/*++

Routine Description:

    This routine is default callback for interfaces exposed from the videoprt.
    Should be called by the client before it starts using an interface.

Arguments:

    pContext - Context returned by the VideoPortQueryServices() in the
               pInterface->Context field.

--*/

{
    PAGED_CODE();
}   // VpInterfaceDefaultReference()

VOID
VpInterfaceDefaultDereference(
    IN PVOID pContext
    )

/*++

Routine Description:

    This routine is default callback for interfaces exposed from the videoprt.
    Should be called by the client when it stops using an interface.

Arguments:

    pContext - Context returned by the VideoPortQueryServices() in the
               pInterface->Context field.

--*/

{
    PAGED_CODE();
}   // VpInterfaceDefaultDereference()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\port\videoprt.h ===
/*++

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    videoprt.h

Abstract:

    This module contains the structure definitions private to the video port
    driver.

Author:

    Andre Vachon (andreva) 02-Dec-1991

Notes:

Revision History:

--*/

#ifndef __VIDEOPRT_H__
#define __VIDEOPRT_H__

#define _NTDRIVER_

#ifndef FAR
#define FAR
#endif

#include "dderror.h"
#include "ntos.h"
#include "pci.h"
#include "wdmguid.h"
#include "stdarg.h"
#include "stdio.h"
#include "zwapi.h"
#include "ntiologc.h"

#include "ntddvdeo.h"
#include "video.h"
#include "ntagp.h"
#include "agp.h"
#include "inbv.h"


//
//  Forward declare some basic driver objects.
//

typedef struct _FDO_EXTENSION       *PFDO_EXTENSION;
typedef struct _CHILD_PDO_EXTENSION *PCHILD_PDO_EXTENSION;


//
// Debugging Macro
//
//
// When an IO routine is called, we want to make sure the miniport
// in question has reported its IO ports.
// VPResourceReported is TRUE when a miniport has called VideoPort-
// VerifyAccessRanges.
// It is set to FALSE as a default, and set back to FALSE when finishing
// an iteration in the loop of VideoPortInitialize (which will reset
// the default when we exit the loop also).
//
// This flag will also be set to TRUE by the VREATE entry point so that
// the IO functions always work after init.
//

#if DBG

#undef VideoDebugPrint
#define pVideoDebugPrint(arg) VideoPortDebugPrint arg

#define IS_ACCESS_RANGES_DEFINED()                                         \
    {                                                                      \
        if (!VPResourcesReported) {                                        \
                                                                           \
            pVideoDebugPrint((0, "The miniport driver is trying to access" \
                                 " IO ports or memory location before the" \
                                 " ACCESS_RANGES have been reported to"    \
                                 " the port driver with the"               \
                                 " VideoPortVerifyAccessRanges(). Please"  \
                                 " fix the miniport driver\n"));           \
                                                                           \
            DbgBreakPoint();                                               \
                                                                           \
        }                                                                  \
    }

#else

#define pVideoDebugPrint(arg)
#define IS_ACCESS_RANGES_DEFINED()

#endif

//
// Useful registry buffer length.
//

#define STRING_LENGTH 60

//
// Queue link for mapped addresses stored for unmapping
//

typedef struct _MAPPED_ADDRESS {
    struct _MAPPED_ADDRESS *NextMappedAddress;
    PVOID MappedAddress;
    PHYSICAL_ADDRESS PhysicalAddress;
    ULONG NumberOfUchars;
    ULONG RefCount;
    UCHAR InIoSpace;
    BOOLEAN bNeedsUnmapping;
    BOOLEAN bLargePageRequest;
} MAPPED_ADDRESS, *PMAPPED_ADDRESS;

//
// BusDataRegistry variables
//

typedef struct _VP_QUERY_DEVICE {
    PVOID MiniportHwDeviceExtension;
    PVOID CallbackRoutine;
    PVOID MiniportContext;
    VP_STATUS MiniportStatus;
    ULONG DeviceDataType;
} VP_QUERY_DEVICE, *PVP_QUERY_DEVICE;


//
// Definition of the data passed in for the VideoPortGetRegistryParameters
// function for the DeviceDataType.
//

#define VP_GET_REGISTRY_DATA 0
#define VP_GET_REGISTRY_FILE 1

typedef struct _VIDEO_PORT_DRIVER_EXTENSION {

    UNICODE_STRING RegistryPath;
    VIDEO_HW_INITIALIZATION_DATA HwInitData;

} VIDEO_PORT_DRIVER_EXTENSION, *PVIDEO_PORT_DRIVER_EXTENSION;


//
// PnP Detection flags
//

#define PNP_ENABLED           0x001
#define LEGACY_DETECT         0x002
#define VGA_DRIVER            0x004
#define LEGACY_DRIVER         0x008
#define REPORT_DEVICE         0x020
#define UPGRADE_FAIL_START    0x040
#define FINDADAPTER_SUCCEEDED 0x080
#define UPGRADE_FAIL_HWINIT   0x100
#define VGA_DETECT            0x200


//
// ResetHW Structure
//

typedef struct _VP_RESET_HW {
    PVIDEO_HW_RESET_HW ResetFunction;
    PVOID HwDeviceExtension;
} VP_RESET_HW, *PVP_RESET_HW;


//
// AGP Support
//

#define POOL_TAG 0x72745076 // 'vPrt'

typedef struct _AGP_ALLOCATION
{
    PHYSICAL_ADDRESS PhysicalAddress;
    PVOID VirtualAddress;
    ULONG Pages;
    PMDL Mdl;
    struct _AGP_ALLOCATION *Next;
} AGP_ALLOCATION, *PAGP_ALLOCATION;


//
// Private EVENT support for miniport.
//

//
//  This flag indicates that the enveloping VIDEO_PORT_EVENT has a PKEVENT
//  field filled in by ObReferenceObjectByHandle(). It cannot be waited on
//  at all. Must be consistent with that in pw32kevt.h in gre.
//

#define ENG_EVENT_FLAG_IS_MAPPED_USER       0x1

//
//  This flag indicates that the enveloping VIDEO_PORT_EVENT is about to be
//  deleted and that the display driver callback is ongoing. Must be consistent
//  with that in pw32kevt.h in gre.
//

#define ENG_EVENT_FLAG_IS_INVALID           0x2

//
//  This flag indicates that the enveloping VIDEO_PORT_EVENT is in a DPC.
//  It signals the GDI Engine not to delete the VIDEO_POR_EVENT. It signals
//  the VideoPortSetEventDPC to set it then free it. Must be consistent with
//  that in pw32kevt.h in gre.
//

#define ENG_EVENT_FLAG_IN_DPC               0x4


typedef struct _VIDEO_PORT_EVENT {
    PVOID   pKEvent;
    volatile ULONG fFlags;
} VIDEO_PORT_EVENT, *PVIDEO_PORT_EVENT;


#define EDID_BUFFER_SIZE 256


typedef enum _HW_INIT_STATUS
{
    HwInitNotCalled,  // HwInitialize has not yet been called
    HwInitSucceeded,  // HwInitialize has been called and succeeded
    HwInitFailed      // HwInitialize has been called and failed
} HW_INIT_STATUS, *PHW_INIT_STATUS;


#define  GET_FDO_EXT(p) (((PFDO_EXTENSION)(p)) - 1)

//
// Define HW_DEVICE_EXTENSION verification macro.
//

#define IS_HW_DEVICE_EXTENSION(p) (GET_FDO_EXT(p)->HwDeviceExtension == (p))

typedef struct _ALLOC_ENTRY {
  PVOID Address;
  ULONG Size;
  struct _ALLOC_ENTRY *Next;
} *PALLOC_ENTRY, ALLOC_ENTRY;

//
// Device Extension for the FUNCTIONAL Driver Object (FDO)
//

typedef struct _FDO_EXTENSION {

    //
    // Location of the miniport device extension.
    //

    PVOID HwDeviceExtension;

    //
    // Power management mappings.
    //

    DEVICE_POWER_STATE DeviceMapping[PowerSystemMaximum] ;
    BOOLEAN IsMappingReady ;

    //
    // Event object for pVideoPortDispatch synchronization.
    //

    KMUTEX                   SyncMutex;

    //
    // Track whether the device has been opened.
    //

    BOOLEAN                  DeviceOpened;

    ////////////////////////////////////////////////////////////////////////////
    //
    //  END common header.
    //
    ////////////////////////////////////////////////////////////////////////////

    //
    // Adapter device objects
    //

    PDEVICE_OBJECT FunctionalDeviceObject;
    PDEVICE_OBJECT PhysicalDeviceObject;
    PDEVICE_OBJECT AttachedDeviceObject;

    //
    // Pointer to the miniport config info so that the port driver
    // can modify it when the miniport is asking for configuration information.
    //

    PVIDEO_PORT_CONFIG_INFO MiniportConfigInfo;

    //
    // Miniport exports
    //

    PVIDEO_HW_FIND_ADAPTER         HwFindAdapter;
    PVIDEO_HW_INITIALIZE           HwInitialize;
    PVIDEO_HW_INTERRUPT            HwInterrupt;
    PVIDEO_HW_START_IO             HwStartIO;
    PVIDEO_HW_TIMER                HwTimer;
    PVIDEO_HW_POWER_SET            HwSetPowerState;
    PVIDEO_HW_POWER_GET            HwGetPowerState;
    PVIDEO_HW_QUERY_INTERFACE      HwQueryInterface;
    PVIDEO_HW_CHILD_CALLBACK       HwChildCallback;

    //
    // Legacy resources used by the driver and reported to Plug and Play
    // via FILTER_RESOURCE_REQUIREMENTS.
    //

    PVIDEO_ACCESS_RANGE HwLegacyResourceList;
    ULONG               HwLegacyResourceCount;

    //
    // Linked list of all memory mapped io space (done through MmMapIoSpace)
    // requested by the miniport driver.
    // This list is kept so we can free up those ressources if the driver
    // fails to load or if it is unloaded at a later time.
    //

    PMAPPED_ADDRESS MappedAddressList;

    //
    // Interrupt object
    //

    PKINTERRUPT InterruptObject;

    //
    // Interrupt vector, irql and mode
    //

    ULONG InterruptVector;
    KIRQL InterruptIrql;
    ULONG InterruptAffinity;
    KINTERRUPT_MODE InterruptMode;
    BOOLEAN InterruptsEnabled;

    //
    // Information about the BUS on which the adapteris located
    //

    INTERFACE_TYPE AdapterInterfaceType;
    ULONG SystemIoBusNumber;

    //
    // Size of the miniport device extensions.
    //

    ULONG HwDeviceExtensionSize;
    ULONG HwChildDeviceExtensionSize;

    //
    // Determines the size required to save the video hardware state
    //

    ULONG HardwareStateSize;

    //
    // Pointer to the path name indicating the path to the drivers node in
    // the registry's current control set
    //

    PWSTR DriverRegistryPath;
    ULONG DriverRegistryPathLength;

    //
    // Total memory usage of PTEs by a miniport driver.
    // This is used to track if the miniport is mapping too much memory
    //

    ULONG MemoryPTEUsage;

    //
    // Pointer to the video request packet;
    //

    PVIDEO_REQUEST_PACKET Vrp;

    //
    // Determines if the port driver is currently handling an attach caused by
    // a video filter drivers.
    //

    BOOLEAN bAttachInProgress;

    //
    // Has the drivers HwInitialize routine been called.
    //

    HW_INIT_STATUS HwInitStatus;

    //
    // VDM and int10 support
    //

    PHYSICAL_ADDRESS VdmPhysicalVideoMemoryAddress;
    ULONG VdmPhysicalVideoMemoryLength;

    //
    // Memory allocation values
    //

#if DBG
    LONG           FreeAllocation;
    PALLOC_ENTRY   AllocationHead;
    PAGED_LOOKASIDE_LIST AllocationList;
#endif

    //
    // DPC Support
    //

    KDPC Dpc;

    ////////////////////////////////////////////////////////////////////////////
    //
    // Plug and Play Support
    //
    ////////////////////////////////////////////////////////////////////////////

    PCM_RESOURCE_LIST ResourceList;
    PCM_RESOURCE_LIST AllocatedResources;   // bus driver list

    PCM_RESOURCE_LIST RawResources;         // complete list
    PCM_RESOURCE_LIST TranslatedResources;  // translated complete list

    ULONG             DeviceNumber;
    ULONG             SlotNumber;

    //
    // Indicates whether we can enumerate children right away, or if
    // we need to wait for HwInitialize to be called first.
    //

    BOOLEAN AllowEarlyEnumeration;

    //
    // Interface for communication with our bus driver.
    //

    BOOLEAN ValidBusInterface;
    BUS_INTERFACE_STANDARD BusInterface;

    //
    // Flags that indicate type of driver (VGA, PNP, etc)
    //

    ULONG             Flags;

    //
    // AGP Support
    //

    AGP_BUS_INTERFACE_STANDARD     AgpInterface;

    //
    // Callout support - Phydisp of the device in GDI
    //

    PVOID             PhysDisp;

} FDO_EXTENSION, *PFDO_EXTENSION;

#define MAXIMUM_MEM_LIMIT_K  64

//
// AGP Data Structures
//

typedef struct _REGION {
    ULONG Length;
    ULONG NumDwords;
    ULONG BitField[1];
} REGION, *PREGION;

typedef struct _RESERVATION_LIST RESERVATION_LIST, *PRESERVATION_LIST;
typedef struct _RESERVATION_LIST
{
    ULONG Offset;
    ULONG Pages;
    ULONG RefCount;
    BOOLEAN Reserved;
    PRESERVATION_LIST Next;
};

typedef struct _PHYSICAL_RESERVE_CONTEXT
{
    ULONG Pages;
    ULONG Caching;
    PVOID MapHandle;
    PHYSICAL_ADDRESS PhysicalAddress;
    PREGION Region;
} PHYSICAL_RESERVE_CONTEXT, *PPHYSICAL_RESERVE_CONTEXT;

typedef struct _VIRTUAL_RESERVE_CONTEXT
{
    HANDLE ProcessHandle;
    PEPROCESS Process;
    PVOID VirtualAddress;
    PPHYSICAL_RESERVE_CONTEXT PhysicalReserveContext;
    PRESERVATION_LIST ReservationList;
    PREGION Region;
} VIRTUAL_RESERVE_CONTEXT, *PVIRTUAL_RESERVE_CONTEXT;

typedef struct _DEVICE_ADDRESS DEVICE_ADDRESS, *PDEVICE_ADDRESS;
typedef struct _DEVICE_ADDRESS
{
    ULONG BusNumber;
    ULONG Slot;
    PDEVICE_ADDRESS Next;
};

//
// Support for GetProcAddress
//

typedef struct _PROC_ADDRESS
{
    PUCHAR FunctionName;
    PVOID  FunctionAddress;
} PROC_ADDRESS, *PPROC_ADDRESS;

#define PROC(x) #x, x

//
// Power Request Context Block
//

typedef struct tagPOWER_BLOCK
{
    PKEVENT     Event;
    union {
        NTSTATUS    Status;
        ULONG       FinalFlag;
    } ;
    PIRP        Irp ;
} POWER_BLOCK, *PPOWER_BLOCK;

//
// Global Data
//


#if DBG
extern ULONG VPResourcesReported;
extern CHAR *BusType[];
#endif

extern BOOLEAN VPFirstTime;
extern PVIDEO_WIN32K_CALLOUT Win32kCallout;
extern BOOLEAN EnableUSWC;
extern ULONG VideoDebugLevel;
extern ULONG VideoDeviceNumber;
extern PWSTR VideoClassString;
extern UNICODE_STRING VideoClassName;
extern VP_RESET_HW HwResetHw[];
extern PVOID PhysicalMemorySection;
extern ULONG VpC0000Compatible;
extern PVOID VgaHwDeviceExtension;
extern PDEVICE_OBJECT VgaCompatibleDevice;
extern PVIDEO_ACCESS_RANGE VgaAccessRanges;
extern ULONG NumVgaAccessRanges;
extern PDEVICE_OBJECT DeviceOwningVga;
extern PROC_ADDRESS VideoPortEntryPoints[];
extern VIDEO_ACCESS_RANGE VgaLegacyResources[];
extern ULONGLONG VpSystemMemorySize;



typedef
BOOLEAN
(*PSYNCHRONIZE_ROUTINE) (
    PKINTERRUPT             pInterrupt,
    PKSYNCHRONIZE_ROUTINE   pkSyncronizeRoutine,
    PVOID                   pSynchContext
    );

//
// Number of legacy vga resources
//

#define NUM_VGA_LEGACY_RESOURCES 3

//
// These macros are used to protect threads which will enter the
// miniport.  We need to guarantee that only one thread enters
// the miniport at a time.
//

#define ACQUIRE_DEVICE_LOCK(DeviceExtension)           \
    KeWaitForSingleObject(&DeviceExtension->SyncMutex, \
                          Executive,                   \
                          KernelMode,                  \
                          FALSE,                       \
                          (PTIME)NULL);

#define RELEASE_DEVICE_LOCK(DeviceExtension)           \
    KeReleaseMutex(&DeviceExtension->SyncMutex,        \
                   FALSE);

//
// Define macros to stall execution for given number of milli or micro seconds.
// Single call to KeStallExecutionProcessor() can be done for 100us max.
//

#define DELAY_MILLISECONDS(n)                           \
{                                                       \
    ULONG ulCount;                                      \
    ULONG ulTotal = 10 * (n);                           \
                                                        \
    for (ulCount = 0; ulCount < (n); ulCount++)         \
        KeStallExecutionProcessor(100);                 \
}

#define DELAY_MICROSECONDS(n)                           \
{                                                       \
    ULONG ulCount = (n);                                \
                                                        \
    while (ulCount > 0)                                 \
    {                                                   \
        if (ulCount >= 100)                             \
        {                                               \
            KeStallExecutionProcessor(100);             \
            ulCount -= 100;                             \
        }                                               \
        else                                            \
        {                                               \
            KeStallExecutionProcessor(ulCount);         \
            ulCount = 0;                                \
        }                                               \
    }                                                   \
}

//
// Private function declarations
//

//
// ddc.c
//

BOOLEAN
DDCReadEdidSegment(
    IN PVOID pHwDeviceExtension,
    IN PI2C_CALLBACKS pI2CCallbacks,
    IN OUT PUCHAR pucEdidBuffer,
    IN ULONG ulEdidBufferSize,
    IN UCHAR ucEdidSegment,
    IN UCHAR ucEdidOffset,
    IN UCHAR ucSetOffsetAddress,
    IN UCHAR ucReadAddress,
    IN BOOLEAN bEnhancedDDC
    );

//
// agp.c
//

BOOLEAN
VpQueryAgpInterface(
    PFDO_EXTENSION DeviceExtension
    );

//
// edid.c
//

BOOLEAN
pVideoPortIsValidEDID(
    PVOID Edid
    );


VOID
pVideoPortGetEDIDId(
    PVOID  pEdid,
    PWCHAR pwChar
    );

PVOID
pVideoPortGetMonitordescription(
    PVOID pEdid
    );

//
// i2c.c
//

BOOLEAN
I2CStart(
    IN PVOID pHwDeviceExtension,
    IN PI2C_CALLBACKS pI2CCallbacks
    );

BOOLEAN
I2CStop(
    IN PVOID pHwDeviceExtension,
    IN PI2C_CALLBACKS pI2CCallbacks
    );

BOOLEAN
I2CWrite(
    IN PVOID pHwDeviceExtension,
    IN PI2C_CALLBACKS pI2CCallbacks,
    IN PUCHAR pucBuffer,
    IN ULONG ulLength
    );

BOOLEAN
I2CRead(
    IN PVOID pHwDeviceExtension,
    IN PI2C_CALLBACKS pI2CCallbacks,
    OUT PUCHAR pucBuffer,
    IN ULONG ulLength
    );

BOOLEAN
I2CWriteByte(
    IN PVOID pHwDeviceExtension,
    IN PI2C_CALLBACKS pI2CCallbacks,
    IN UCHAR ucByte
    );

BOOLEAN
I2CReadByte(
    IN PVOID pHwDeviceExtension,
    IN PI2C_CALLBACKS pI2CCallbacks,
    OUT PUCHAR pucByte,
    IN BOOLEAN bMore
    );

BOOLEAN
I2CWaitForClockLineHigh(
    IN PVOID pHwDeviceExtension,
    IN PI2C_CALLBACKS pI2CCallbacks
    );

//
// pnp.c
//

NTSTATUS
pVideoPortSendIrpToLowerDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
pVideoPortPnpDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

//
// registry.c
//

NTSTATUS
VpGetFlags(
    IN PUNICODE_STRING RegistryPath,
    PVIDEO_HW_INITIALIZATION_DATA HwInitializationData,
    PULONG Flags
    );

NTSTATUS
VpSetEventCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    );

//
// videoprt.c
//

NTSTATUS
pVideoPortCreateDeviceName(
    PWSTR           DeviceString,
    ULONG           DeviceNumber,
    PUNICODE_STRING UnicodeString,
    PWCHAR          UnicodeBuffer
    );

VOID
pVideoPortDebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    );

NTSTATUS
pVideoPortDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

PVOID
pVideoPortFreeDeviceBase(
    IN PVOID HwDeviceExtension,
    IN PVOID MappedAddress
    );

PVOID
pVideoPortGetDeviceBase(
    IN PVOID HwDeviceExtension,
    IN PHYSICAL_ADDRESS IoAddress,
    IN ULONG NumberOfUchars,
    IN UCHAR InIoSpace,
    IN BOOLEAN bLargePage
    );

NTSTATUS
pVideoPortGetRegistryCallback(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

VOID
pVPInit(
    VOID
    );

NTSTATUS
VpCreateDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN ULONG DeviceExtensionSize,
    OUT PDEVICE_OBJECT *DeviceObject
    );

NTSTATUS
VideoPortFindAdapter(
    IN PDRIVER_OBJECT DriverObject,
    IN PVOID Argument2,
    IN PVIDEO_HW_INITIALIZATION_DATA HwInitializationData,
    IN PVOID HwContext,
    PDEVICE_OBJECT DeviceObject,
    PUCHAR nextMiniport
    );

NTSTATUS
VideoPortFindAdapter2(
    IN PDRIVER_OBJECT DriverObject,
    IN PVOID Argument2,
    IN PVIDEO_HW_INITIALIZATION_DATA HwInitializationData,
    IN PVOID HwContext,
    PDEVICE_OBJECT DeviceObject,
    PUCHAR nextMiniport
    );

NTSTATUS
VpAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

VP_STATUS
VpRegistryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

NTSTATUS
VpGetBusInterface(
    PFDO_EXTENSION FdoExtension
    );

PVOID
VpGetProcAddress(
    IN PVOID HwDeviceExtension,
    IN PUCHAR FunctionName
    );

BOOLEAN
pVideoPortInterrupt(
    IN PKINTERRUPT Interrupt,
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
pVideoPortMapToNtStatus(
    IN PSTATUS_BLOCK StatusBlock
    );

NTSTATUS
pVideoPortMapUserPhysicalMem(
    IN PFDO_EXTENSION FdoExtension,
    IN HANDLE ProcessHandle OPTIONAL,
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN OUT PULONG Length,
    IN OUT PULONG InIoSpace,
    IN OUT PVOID *VirtualAddress
    );

BOOLEAN
pVideoPortSynchronizeExecution(
    PVOID HwDeviceExtension,
    VIDEO_SYNCHRONIZE_PRIORITY Priority,
    PMINIPORT_SYNCHRONIZE_ROUTINE SynchronizeRoutine,
    PVOID Context
    );

VOID
pVideoPortHwTimer(
    IN PDEVICE_OBJECT DeviceObject,
    PVOID Context
    );

BOOLEAN
pVideoPortResetDisplay(
    IN ULONG Columns,
    IN ULONG Rows
    );

PHYSICAL_ADDRESS
AgpReservePhysical(
    IN PVOID Context,
    IN ULONG Pages,
    IN ULONG Caching,
    OUT PVOID *PhysicalReserveContext
    );

VOID
AgpReleasePhysical(
    PVOID Context,
    PVOID PhysicalReserveContext
    );

BOOLEAN
AgpCommitPhysical(
    PVOID Context,
    PVOID PhysicalReserveContext,
    ULONG Pages,
    ULONG Offset
    );

VOID
AgpFreePhysical(
    IN PVOID Context,
    IN PVOID PhysicalReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    );

PVOID
AgpReserveVirtual(
    IN PVOID Context,
    IN HANDLE ProcessHandle,
    IN PVOID PhysicalReserveContext,
    OUT PVOID *VirtualReserveContext
    );

VOID
AgpReleaseVirtual(
    IN PVOID Context,
    IN PVOID VirtualReserveContext
    );

PVOID
AgpCommitVirtual(
    IN PVOID Context,
    IN PVOID VirtualReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    );

VOID
AgpFreeVirtual(
    IN PVOID Context,
    IN PVOID VirtualReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    );

BOOLEAN
CreateBitField(
    ULONG Length,
    PREGION *Region
    );

VOID
ModifyRegion(
    PREGION Region,
    ULONG Offset,
    ULONG Length,
    BOOLEAN Set
    );

BOOLEAN
FindFirstRun(
    PREGION Region,
    PULONG Offset,
    PULONG Length
    );

NTSTATUS
VpAppendToRequirementsList(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST *RequirementsList,
    IN ULONG NumAccessRanges,
    IN PVIDEO_ACCESS_RANGE AccessRanges
    );

BOOLEAN
VpIsLegacyAccessRange(
    PFDO_EXTENSION fdoExtension,
    PVIDEO_ACCESS_RANGE AccessRange
    );

PCM_RESOURCE_LIST
VpRemoveFromResourceList(
    PCM_RESOURCE_LIST OriginalList,
    ULONG NumAccessRanges,
    PVIDEO_ACCESS_RANGE AccessRanges
    );

VOID
VpEnableDisplay(
    BOOLEAN bState
    );

VOID
VpWin32kCallout(
    PVIDEO_WIN32K_CALLBACKS_PARAMS calloutParams
    );

BOOLEAN
VpAllowFindAdapter(
    PFDO_EXTENSION fdoExtension
    );

ULONG
GetCmResourceListSize(
    PCM_RESOURCE_LIST CmResourceList
    );

VOID
pVideoPortDpcDispatcher(
    IN PKDPC Dpc,
    IN PVOID HwDeviceExtension,
    IN PMINIPORT_DPC_ROUTINE DpcRoutine,
    IN PVOID Context
    );

#if DBG
VOID
DumpRequirements(
    PIO_RESOURCE_REQUIREMENTS_LIST Requirements
    );

VOID
DumpResourceList(
    PCM_RESOURCE_LIST pcmResourceList
    );

PIO_RESOURCE_REQUIREMENTS_LIST
BuildRequirements(
    PCM_RESOURCE_LIST pcmResourceList
    );

VOID
DumpHwInitData(
    IN PVIDEO_HW_INITIALIZATION_DATA p
    );

VOID
DumpUnicodeString(
    IN PUNICODE_STRING p
    );
#endif

PCM_PARTIAL_RESOURCE_DESCRIPTOR
RtlUnpackPartialDesc(
    IN UCHAR Type,
    IN PCM_RESOURCE_LIST ResList,
    IN OUT PULONG Count
    );

ULONG
pVideoPortGetVgaStatusPci(
    PVOID HwDeviceExtension
    );

BOOLEAN
VpIsVgaResource(
    PVIDEO_ACCESS_RANGE AccessRange
    );

VOID
VpInterfaceDefaultReference(
    IN PVOID pContext
    );

VOID
VpInterfaceDefaultDereference(
    IN PVOID pContext
    );

#endif // ifndef __VIDEOPRT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\port\i2c.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    i2c.c

Abstract:

    This is the NT Video port I2C helper code.

Author:

    Michael Maciesowicz (mmacie) 03-Sept-1999

Environment:

    kernel mode only

Notes:

--*/

#include "videoprt.h"

//
// Make it easy to change debug verbosity.
//

#define DEBUG_I2C               1

//
// Define constants used by I2C.
//

#define I2C_START_RETRIES       10
#define I2C_SCL_READ_RETRIES    10
#define I2C_DELAY()             DELAY_MICROSECONDS(5)

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, I2CStart)
#pragma alloc_text (PAGE, I2CStop)
#pragma alloc_text (PAGE, I2CWrite)
#pragma alloc_text (PAGE, I2CRead)
#pragma alloc_text (PAGE, I2CWriteByte)
#pragma alloc_text (PAGE, I2CReadByte)
#pragma alloc_text (PAGE, I2CWaitForClockLineHigh)
#endif  // ALLOC_PRAGMA

//
// Routines exported via VideoPortQueryServices().
//

BOOLEAN
I2CStart(
    IN PVOID pHwDeviceExtension,
    IN PI2C_CALLBACKS pI2CCallbacks
    )

/*++

Routine Description:

    This routine starts I2C communication.

Arguments:

    pHwDeviceExtension - Points to per-adapter device extension.
    pI2CCallbacks      - I2C hardware specific functions.

Returns:

    TRUE  - Start OK.
    FALSE - Start failed.

--*/

{
    ULONG ulRetry;

    PAGED_CODE();
    ASSERT(NULL != pHwDeviceExtension);
    ASSERT(NULL != pI2CCallbacks);
    ASSERT(NULL != pI2CCallbacks->WriteClockLine);
    ASSERT(NULL != pI2CCallbacks->WriteDataLine);
    ASSERT(NULL != pI2CCallbacks->ReadClockLine);
    ASSERT(NULL != pI2CCallbacks->ReadDataLine);
    ASSERT(IS_HW_DEVICE_EXTENSION(pHwDeviceExtension) == TRUE);

    //
    // The I2C communications start signal is a SDA high->low while the SCL is high.
    //

    for (ulRetry = 0; ulRetry <= I2C_START_RETRIES; ulRetry++)
    {
        pI2CCallbacks->WriteDataLine(pHwDeviceExtension, 1);           // Set SDA high
        I2C_DELAY();
        if (pI2CCallbacks->ReadDataLine(pHwDeviceExtension) == FALSE)  // SDA didn't take - ulRetry
            continue;
        pI2CCallbacks->WriteClockLine(pHwDeviceExtension, 1);          // Set SCL high
        I2C_DELAY();
        if (I2CWaitForClockLineHigh(pHwDeviceExtension, pI2CCallbacks) == FALSE)
        {
            pVideoDebugPrint((DEBUG_I2C, "VIDEOPRT!I2CStart: SCL didn't take\n"));
            break;
        }
        pI2CCallbacks->WriteDataLine(pHwDeviceExtension, 0);           // Set SDA low
        I2C_DELAY();
        pI2CCallbacks->WriteClockLine(pHwDeviceExtension, 0);          // Set SCL low
        I2C_DELAY();
        return TRUE;
    }

    pVideoDebugPrint((DEBUG_I2C, "VIDEOPRT!I2CStart: Failed\n"));
    return FALSE;
}   // I2CStart()

BOOLEAN
I2CStop(
    IN PVOID pHwDeviceExtension,
    IN PI2C_CALLBACKS pI2CCallbacks
    )

/*++

Routine Description:

    This routine stops I2C communication.

Arguments:

    pHwDeviceExtension - Points to per-adapter device extension.
    pI2CCallbacks      - I2C hardware specific functions.

Returns:

    TRUE  - Stop OK.
    FALSE - Stop failed.

--*/

{
    PAGED_CODE();
    ASSERT(NULL != pHwDeviceExtension);
    ASSERT(NULL != pI2CCallbacks);
    ASSERT(NULL != pI2CCallbacks->WriteClockLine);
    ASSERT(NULL != pI2CCallbacks->WriteDataLine);
    ASSERT(NULL != pI2CCallbacks->ReadClockLine);
    ASSERT(NULL != pI2CCallbacks->ReadDataLine);
    ASSERT(IS_HW_DEVICE_EXTENSION(pHwDeviceExtension) == TRUE);

    //
    // The I2C communications stop signal is a SDA low->high while the SCL is high.
    //

    pI2CCallbacks->WriteDataLine(pHwDeviceExtension, 0);               // Set SDA low
    I2C_DELAY();
    pI2CCallbacks->WriteClockLine(pHwDeviceExtension, 1);              // Set SCL high
    I2C_DELAY();
    if (I2CWaitForClockLineHigh(pHwDeviceExtension, pI2CCallbacks) == FALSE)
    {
        pVideoDebugPrint((DEBUG_I2C, "VIDEOPRT!I2CStop: SCL didn't take\n"));
        return FALSE;
    }
    pI2CCallbacks->WriteDataLine(pHwDeviceExtension, 1);               // Set SDA high
    I2C_DELAY();
    if (pI2CCallbacks->ReadDataLine(pHwDeviceExtension) != 1)
    {
        pVideoDebugPrint((DEBUG_I2C, "VIDEOPRT!I2CStop: SDA didn't take\n"));
        return FALSE;
    }

    return TRUE;
}   // I2CStop()

BOOLEAN
I2CWrite(
    IN PVOID pHwDeviceExtension,
    IN PI2C_CALLBACKS pI2CCallbacks,
    IN PUCHAR pucBuffer,
    IN ULONG ulLength
    )

/*++

Routine Description:

    This routine writes data over the I2C channel.

Arguments:

    pHwDeviceExtension - Points to per-adapter device extension.
    pI2CCallbacks      - I2C hardware specific functions.
    pucBuffer          - Points to data to be written.
    ulLength           - Number of bytes to write.

Returns:

    TRUE  - Write OK.
    FALSE - Write failed.

--*/

{
    ULONG ulCount;

    PAGED_CODE();
    ASSERT(NULL != pHwDeviceExtension);
    ASSERT(NULL != pI2CCallbacks);
    ASSERT(NULL != pucBuffer);
    ASSERT(NULL != pI2CCallbacks->WriteClockLine);
    ASSERT(NULL != pI2CCallbacks->WriteDataLine);
    ASSERT(NULL != pI2CCallbacks->ReadClockLine);
    ASSERT(NULL != pI2CCallbacks->ReadDataLine);
    ASSERT(IS_HW_DEVICE_EXTENSION(pHwDeviceExtension) == TRUE);

    for (ulCount = 0; ulCount < ulLength; ulCount++)
    {
        if (I2CWriteByte(pHwDeviceExtension, pI2CCallbacks, pucBuffer[ulCount]) == FALSE)
        {
            return FALSE;
        }
    }

    return TRUE;
}   // I2CWrite()

BOOLEAN
I2CRead(
    IN PVOID pHwDeviceExtension,
    IN PI2C_CALLBACKS pI2CCallbacks,
    OUT PUCHAR pucBuffer,
    IN ULONG ulLength
    )

/*++

Routine Description:

    This routine reads data over the I2C channel.

Arguments:

    pHwDeviceExtension - Points to per-adapter device extension.
    pI2CCallbacks      - I2C hardware specific functions.
    pucBuffer          - Points to storage for data.
    ulLength           - Number of bytes to read.

Returns:

    TRUE  - Read OK.
    FALSE - Read failed.

--*/

{
    ULONG ulCount;

    PAGED_CODE();
    ASSERT(NULL != pHwDeviceExtension);
    ASSERT(NULL != pI2CCallbacks);
    ASSERT(NULL != pucBuffer);
    ASSERT(NULL != pI2CCallbacks->WriteClockLine);
    ASSERT(NULL != pI2CCallbacks->WriteDataLine);
    ASSERT(NULL != pI2CCallbacks->ReadClockLine);
    ASSERT(NULL != pI2CCallbacks->ReadDataLine);
    ASSERT(IS_HW_DEVICE_EXTENSION(pHwDeviceExtension) == TRUE);

    //
    // On all but the last byte, we must send an ACK in order to ensure that the sending device will
    // send subsequent data bytes. On the last byte, we must send a NAK so that it will shut up.
    //

    for (ulCount = 0; ulCount < ulLength; ulCount++)
    {
        if (ulLength - 1 == ulCount)
        {
            if (I2CReadByte(pHwDeviceExtension, pI2CCallbacks, pucBuffer + ulCount, FALSE) == FALSE)  // Last byte
            {
                return FALSE;
            }
        }
        else
        {
            if (I2CReadByte(pHwDeviceExtension, pI2CCallbacks, pucBuffer + ulCount, TRUE) == FALSE)
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}   // I2CRead()

//
// Local routines.
//

BOOLEAN
I2CWriteByte(
    IN PVOID pHwDeviceExtension,
    IN PI2C_CALLBACKS pI2CCallbacks,
    IN UCHAR ucByte
    )

/*++

Routine Description:

    This routine writes byte over the I2C channel.

Arguments:

    pHwDeviceExtension - Points to per-adapter device extension.
    pI2CCallbacks      - I2C hardware specific functions.
    ucByte             - Byte to write.

Returns:

    TRUE  - Write OK.
    FALSE - Write failed.

--*/

{
    LONG lShift;
    UCHAR ucAck;

    PAGED_CODE();
    ASSERT(NULL != pHwDeviceExtension);
    ASSERT(NULL != pI2CCallbacks);

    //
    // Bits are transmitted serially starting with the MSB.
    //

    for (lShift = 7; lShift >= 0; lShift--)
    {
        //
        // Transmitt data bit.
        //

        pI2CCallbacks->WriteDataLine(pHwDeviceExtension, (UCHAR)((ucByte >> lShift) & 0x01));  // Set SDA
        I2C_DELAY();

        //
        // After each data bit we must send high->low SCL pulse.
        //

        pI2CCallbacks->WriteClockLine(pHwDeviceExtension, 1);       // Set SCL high
        I2C_DELAY();
        if (I2CWaitForClockLineHigh(pHwDeviceExtension, pI2CCallbacks) == FALSE)
        {
            pVideoDebugPrint((DEBUG_I2C, "VIDEOPRT!I2CWriteByte: SCL didn't take\n"));
            return FALSE;
        }
        pI2CCallbacks->WriteClockLine(pHwDeviceExtension, 0);       // Set SCL low
        I2C_DELAY();
    }

    //
    // The monitor sends ACK by preventing the SDA from going high after the clock pulse we use
    // to send our last data bit. If the SDA goes high after this bit, it is a NAK from the monitor.
    //

    pI2CCallbacks->WriteDataLine(pHwDeviceExtension, 1);            // Set SDA high
    I2C_DELAY();
    pI2CCallbacks->WriteClockLine(pHwDeviceExtension, 1);           // Set SCL high
    I2C_DELAY();
    if (I2CWaitForClockLineHigh(pHwDeviceExtension, pI2CCallbacks) == FALSE)
    {
        pVideoDebugPrint((DEBUG_I2C, "VIDEOPRT!I2CWriteByte: SCL didn't take - ACK failed\n"));
        return FALSE;
    }
    ucAck = pI2CCallbacks->ReadDataLine(pHwDeviceExtension);        // Read ACK bit
    pI2CCallbacks->WriteClockLine(pHwDeviceExtension, 0);           // Set SCL low
    I2C_DELAY();

    if (1 == ucAck)                                                 // NAK from the monitor
    {
        pVideoDebugPrint((DEBUG_I2C, "VIDEOPRT!I2CWriteByte: NAK received\n"));
        return FALSE;
    }

    return TRUE;
}   // I2CWriteByte()

BOOLEAN
I2CReadByte(
    IN PVOID pHwDeviceExtension,
    IN PI2C_CALLBACKS pI2CCallbacks,
    OUT PUCHAR pucByte,
    IN BOOLEAN bMore
    )

/*++

Routine Description:

    This routine reads byte over the I2C channel.

Arguments:

    pHwDeviceExtension - Points to per-adapter device extension.
    pI2CCallbacks      - I2C hardware specific functions.
    pucBuffer          - Points to storage for data.
    bMore              - TRUE if we want to continue reading, FALSE otherwise.

Returns:

    TRUE  - Read OK.
    FALSE - Read failed.

--*/

{
    LONG lShift;

    PAGED_CODE();
    ASSERT(NULL != pHwDeviceExtension);
    ASSERT(NULL != pI2CCallbacks);
    ASSERT(NULL != pucByte);

    *pucByte = 0;

    //
    // The data bits are read from MSB to LSB. A data bit is read while the SCL is high.
    //

    for (lShift = 7; lShift >= 0; lShift--)
    {
        pI2CCallbacks->WriteClockLine(pHwDeviceExtension, 1);       // Set SCL high
        I2C_DELAY();
        if (I2CWaitForClockLineHigh(pHwDeviceExtension, pI2CCallbacks) == FALSE)
        {
            pVideoDebugPrint((DEBUG_I2C, "ATIRAGE.SYS!I2CReadByte: SCL didn't take\n"));
            return FALSE;
        }
        *pucByte |= pI2CCallbacks->ReadDataLine(pHwDeviceExtension) << lShift;  // Read SDA
        pI2CCallbacks->WriteClockLine(pHwDeviceExtension, 0);       // Set SCL low
        I2C_DELAY();
    }

    //
    // Send the acknowledge bit. SDA low = ACK, SDA high = NAK.
    //

    if (TRUE == bMore)
    {
        pI2CCallbacks->WriteDataLine(pHwDeviceExtension, 0);        // Set SDA low - ACK
    }
    else
    {
        pI2CCallbacks->WriteDataLine(pHwDeviceExtension, 1);        // Set SDA high - NAK
    }
    I2C_DELAY();

    //
    // Send a SCL high->low pulse, then release the SDA by setting it high.
    //

    pI2CCallbacks->WriteClockLine(pHwDeviceExtension, 1);           // Set SCL high
    I2C_DELAY();
    if (I2CWaitForClockLineHigh(pHwDeviceExtension, pI2CCallbacks) == FALSE)
    {
        pVideoDebugPrint((DEBUG_I2C, "ATIRAGE.SYS!I2CReadByte: SCL didn't take - ACK failed\n"));
        return FALSE;
    }
    pI2CCallbacks->WriteClockLine(pHwDeviceExtension, 0);           // Set SCL low
    I2C_DELAY();
    pI2CCallbacks->WriteDataLine(pHwDeviceExtension, 1);            // Set SDA high
    I2C_DELAY();

    return TRUE;
}   // I2CReadByte()

BOOLEAN
I2CWaitForClockLineHigh(
    IN PVOID pHwDeviceExtension,
    IN PI2C_CALLBACKS pI2CCallbacks
    )

/*++

Routine Description:

    This routine waits till SCL goes high
    (SCL low period can be stretched by slow devices).

Arguments:

    pHwDeviceExtension - Points to per-adapter device extension.
    pI2CCallbacks      - I2C hardware specific functions.

Returns:

    TRUE  - OK - SCL high.
    FALSE - SCL didn't take.

--*/

{
    ULONG ulCount;

    PAGED_CODE();
    ASSERT(NULL != pHwDeviceExtension);
    ASSERT(NULL != pI2CCallbacks);

    for (ulCount = 0; ulCount < I2C_SCL_READ_RETRIES; ulCount++)
    {
        if (pI2CCallbacks->ReadClockLine(pHwDeviceExtension) == TRUE)
            return TRUE;

        I2C_DELAY();
    }

    return FALSE;
}   // I2CWaitForClockLineHigh()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\port\vpdata.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

  vpdata.c

Abstract:

    Global data module for the video port

Author:

    Andre Vachon (andreva) 12-Jul-1997

Environment:

    kernel mode only

Notes:

    This module is a driver which implements OS dependant functions on the
    behalf of the video drivers

Revision History:

--*/

#include "videoprt.h"

//
//
// Data that is NOT pageable
//
//

//
// Globals to support HwResetHw function
//

VP_RESET_HW HwResetHw[6];

//
// We check for resources reported in read/write functions which
// can be called at raised irql.
//

#if DBG
ULONG VPResourcesReported = TRUE;
#endif

//
// Debug Level for output routine (not pageable because VideoDebugPrint
// can be called at raised irql.
//

ULONG VideoDebugLevel = 0;

//
//
// Data that IS pageable
//
//

#if defined(ALLOC_PRAGMA)
#pragma data_seg("PAGE_DATA")
#endif


//
// Used to do first time initialization of the video port.
//

BOOLEAN VPFirstTime = TRUE;

//
// Callbacks to win32k
//

PVIDEO_WIN32K_CALLOUT Win32kCallout = NULL;

//
// Disable USWC is case the machine does not work properly with it.
//

BOOLEAN EnableUSWC = TRUE;

//
// Count to determine the number of video devices
//

ULONG VideoDeviceNumber = 0;

//
// Registry Class in which all video information is stored.
//

PWSTR VideoClassString = L"VIDEO";
UNICODE_STRING VideoClassName = {10,12,L"VIDEO"};

//
// Pointer to physical memory. It is created during driver initialization
// and is only closed when the driver is closed.
//

PVOID PhysicalMemorySection = NULL;

//
// Variable to determine if there is a ROM at physical address C0000 on which
// we can do the int 10
//

ULONG VpC0000Compatible = 0;

//
// HwDeviceExtension of the VGA miniport driver, if it is loaded.
//

PVOID VgaHwDeviceExtension = NULL;

//
// Pointer to the device object for the device that owns the VGA ports
//

PDEVICE_OBJECT VgaCompatibleDevice = NULL;

//
// Store the amount of physical memory in the machine.
//

ULONGLONG VpSystemMemorySize;

//
// This structure describes to which ports access is required.
//

#define MEM_VGA               0xA0000
#define MEM_VGA_SIZE          0x20000
#define VGA_BASE_IO_PORT      0x000003B0
#define VGA_START_BREAK_PORT  0x000003BB
#define VGA_END_BREAK_PORT    0x000003C0
#define VGA_MAX_IO_PORT       0x000003DF


PVIDEO_ACCESS_RANGE VgaAccessRanges = NULL;
ULONG               NumVgaAccessRanges = 0;
PDEVICE_OBJECT      DeviceOwningVga = NULL;


VIDEO_ACCESS_RANGE VgaLegacyResources[NUM_VGA_LEGACY_RESOURCES] = {
{
    VGA_BASE_IO_PORT, 0x00000000,
    VGA_START_BREAK_PORT - VGA_BASE_IO_PORT+ 1,
    1,
    1,
    1
},
{
    VGA_END_BREAK_PORT, 0x00000000,
    VGA_MAX_IO_PORT - VGA_END_BREAK_PORT + 1,
    1,
    1,
    1
},
{
    MEM_VGA, 0x00000000,
    MEM_VGA_SIZE,
    0,
    1,
    1
}
};

#if DBG

CHAR *BusType[] = { "Internal",
                    "Isa",
                    "Eisa",
                    "MicroChannel",
                    "TurboChannel",
                    "PCIBus",
                    "VMEBus",
                    "NuBus",
                    "PCMCIABus",
                    "CBus",
                    "MPIBus",
                    "MPSABus",
                    "ProcessorInternal",
                    "InternalPowerBus",
                    "PNPISABus",
                    "MaximumInterfaceType"
                };
#endif

PROC_ADDRESS VideoPortEntryPoints[] =
{
    PROC(VideoPortDDCMonitorHelper),
    PROC(VideoPortGetAgpServices),
    PROC(VideoPortGetRomImage),
    PROC(VideoPortGetAssociatedDeviceExtension),
    PROC(VideoPortAcquireDeviceLock),
    PROC(VideoPortReleaseDeviceLock),
    PROC(VideoPortAllocateBuffer),
    PROC(VideoPortReleaseBuffer),
#if defined(_X86_)
    "VideoPortInterlockedIncrement", InterlockedIncrement,
    "VideoPortInterlockedDecrement", InterlockedDecrement,
    "VideoPortInterlockedExchange", InterlockedExchange,
#else
    PROC(VideoPortInterlockedIncrement),
    PROC(VideoPortInterlockedDecrement),
    PROC(VideoPortInterlockedExchange),
#endif
    PROC(VideoPortGetVgaStatus),
    PROC(VideoPortQueueDpc),
    PROC(VideoPortQueryServices),
    {NULL, NULL}
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\port\i386\porti386.c ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation

Module Name:

    porti386.c

Abstract:

    This is the x86 specific part of the video port driver.

Author:

    Andre Vachon (andreva) 10-Jan-1991

Environment:

    kernel mode only

Notes:

    This module is a driver which implements OS dependant functions on the
    behalf of the video drivers

Revision History:

--*/

#include "videoprt.h"
#include "vdm.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,VideoPortInt10)
#pragma alloc_text(PAGE,VideoPortSetTrappedEmulatorPorts)
#endif


VP_STATUS
VideoPortInt10(
    PVOID HwDeviceExtension,
    PVIDEO_X86_BIOS_ARGUMENTS BiosArguments
    )

/*++

Routine Description:

    This function allows a miniport driver to call the kernel to perform
    an int10 operation.
    This will execute natively the BIOS ROM code on the device.

    THIS FUNCTION IS FOR X86 ONLY.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    BiosArguments - Pointer to a structure containing the value of the
        basic x86 registers that should be set before calling the BIOS routine.
        0 should be used for unused registers.

Return Value:


Restrictions:

    Device uses IO ports ONLY.


--*/

{

    return ERROR_NOT_ENOUGH_MEMORY;

} // end VideoPortInt10()

VP_STATUS
VideoPortSetTrappedEmulatorPorts(
    PVOID HwDeviceExtension,
    ULONG NumAccessRanges,
    PVIDEO_ACCESS_RANGE AccessRange
    )

/*++

    VideoPortSetTrappedEmulatorPorts (x86 machines only) allows a miniport
    driver to dynamically change the list of I/O ports that are trapped when
    a VDM is running in full-screen mode. The default set of ports being
    trapped by the miniport driver is defined to be all ports in the
    EMULATOR_ACCESS_ENTRY structure of the miniport driver.
    I/O ports not listed in the EMULATOR_ACCESS_ENTRY structure are
    unavailable to the MS-DOS application.  Accessing those ports causes a
    trap to occur in the system, and the I/O operation to be reflected to a
    user-mode virtual device driver.

    The ports listed in the specified VIDEO_ACCESS_RANGE structure will be
    enabled in the I/O Permission Mask (IOPM) associated with the MS-DOS
    application.  This will enable the MS-DOS application to access those I/O
    ports directly, without having the IO instruction trap and be passed down
    to the miniport trap handling functions (for example EmulatorAccessEntry
    functions) for validation.  However, the subset of critical IO ports must
    always remain trapped for robustness.

    All MS-DOS applications use the same IOPM, and therefore the same set of
    enabled/disabled I/O ports.  Thus, on each switch of application, the
    set of trapped I/O ports is reinitialized to be the default set of ports
    (all ports in the EMULATOR_ACCESS_ENTRY structure).

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

    NumAccessRanges - Specifies the number of entries in the VIDEO_ACCESS_RANGE
        structure specified in AccessRange.

    AccessRange - Points to an array of access ranges (VIDEO_ACCESS_RANGE)
        defining the ports that can be untrapped and accessed directly by
        the MS-DOS application.

Return Value:

    This function returns the final status of the operation.

Environment:

    This routine cannot be called from a miniport routine synchronized with
    VideoPortSynchronizeRoutine or from an ISR.

--*/

{

    return NO_ERROR;

} // end VideoPortSetTrappedEmulatorPorts()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\portx\agp.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    agp.c

Abstract:

    This is the agp portion of the video port driver.

Author:

    Erick Smith (ericks) Oct. 1997

Environment:

    kernel mode only

Revision History:

--*/

#include "videoprt.h"

#if 0 // NUGOOP

extern ULONG VideoDebugLevel;

#if DBG

#define pVideoDebugPrint(arg) VideoPortDebugPrint arg

#else

#define pVideoDebugPrint(arg)

#endif

//
// Device extension aliases.
//

typedef PVIDEO_DEVICE_EXTENSION PFDO_EXTENSION;
#define GET_FDO_EXT VIDEO_GET_VIDEO_DEVICE_EXTENSION

//
// AGP Data Structures
//

#define POOL_TAG 0x72745076 // 'vPrt'

typedef struct _AGP_ALLOCATION
{
    PHYSICAL_ADDRESS PhysicalAddress;
    PVOID VirtualAddress;
    ULONG Pages;
    PMDL Mdl;
    struct _AGP_ALLOCATION *Next;
} AGP_ALLOCATION, *PAGP_ALLOCATION;

typedef struct _REGION {
    ULONG Length;
    ULONG NumDwords;
    ULONG BitField[1];
} REGION, *PREGION;

typedef struct _RESERVATION_LIST RESERVATION_LIST, *PRESERVATION_LIST;
typedef struct _RESERVATION_LIST
{
    ULONG Offset;
    ULONG Pages;
    ULONG RefCount;
    BOOLEAN Reserved;
    PRESERVATION_LIST Next;
};

typedef struct _PHYSICAL_RESERVE_CONTEXT
{
    ULONG Pages;
    ULONG Caching;
    PVOID MapHandle;
    PHYSICAL_ADDRESS PhysicalAddress;
    PREGION Region;
} PHYSICAL_RESERVE_CONTEXT, *PPHYSICAL_RESERVE_CONTEXT;

typedef struct _VIRTUAL_RESERVE_CONTEXT
{
    HANDLE ProcessHandle;
    PEPROCESS Process;
    PVOID VirtualAddress;
    PPHYSICAL_RESERVE_CONTEXT PhysicalReserveContext;
    PRESERVATION_LIST ReservationList;
    PREGION Region;
} VIRTUAL_RESERVE_CONTEXT, *PVIRTUAL_RESERVE_CONTEXT;

PVOID
AddRangeToReservedRegion(
    IN PVIRTUAL_RESERVE_CONTEXT VirtualContext,
    IN ULONG Pages,
    IN ULONG Offset
    );

VOID
RemoveRangeFromReservedRegion(
    IN PVIRTUAL_RESERVE_CONTEXT VirtualContext,
    IN ULONG Pages,
    IN ULONG Offset
    );

VOID
AgpFreePhysical(
    IN PVOID Context,
    IN PVOID PhysicalReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    );

VOID
AgpFreeVirtual(
    IN PVOID Context,
    IN PVOID VirtualReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    );

VOID
DumpBitField(
    PREGION Region
    )
{
    ULONG i;
    ULONG Index = 0;
    ULONG Mask = 1;

    for (i=0; i<Region->Length; i++) {
        if (Mask & Region->BitField[Index]) {
            pVideoDebugPrint((1, "1"));
        } else {
            pVideoDebugPrint((1, "0"));
        }
        Mask <<= 1;
        if (Mask == 0) {
            Index++;
            Mask = 1;
        }
    }
    pVideoDebugPrint((1, "\n"));
}

BOOLEAN
CreateBitField(
    ULONG Length,
    PREGION *Region
    )

/*++

Routine Description:

    This routine creates and initializes a bitfield.

Arguments:

    Length - Number of items to track.

    Region - Location in which to store the pointer to the REGION handle.

Returns:

    TRUE - the the bitfield was created successfully, 
    FALSE - otherwise.

--*/

{
    ULONG NumDwords = (Length + 31) / 32;
    BOOLEAN bRet = FALSE;
    PREGION Buffer;

    Buffer = (PREGION) ExAllocatePoolWithTag(PagedPool, sizeof(REGION) + (NumDwords - 1) * sizeof(ULONG), POOL_TAG);

    if (Buffer) {

        Buffer->Length = Length;
        Buffer->NumDwords = NumDwords;
        memset(&Buffer->BitField[0], 0, NumDwords * 4);

        bRet = TRUE;
    }

    *Region = Buffer;
    return bRet;
}

VOID
ModifyRegion(
    PREGION Region,
    ULONG Offset,
    ULONG Length,
    BOOLEAN Set
    )

/*++

Routine Description:

    Sets 'Length' bits starting at position 'Offset' in the bitfield.

Arguments:

    Region - Pointer to the region to modify.

    Offset - Offset into the bitfield at which to start.

    Length - Number of bits to set.

    Set - TRUE if you want to set the region, FALSE to clear it.


--*/

{
    ULONG Index = Offset / 32;
    ULONG Count = ((Offset + Length - 1) / 32) - Index;
    ULONG lMask = ~((1 << (Offset & 31)) - 1);
    ULONG rMask = ((1 << ((Offset + Length - 1) & 31)) * 2) - 1;
    PULONG ptr = &Region->BitField[Index];

    ASSERT(Length != 0);

    if (Count == 0) {

        //
        // Only one DWORD is modified, so combine left and right masks.
        //

        lMask &= rMask;
    }

    if (Set) {

        *ptr++ |= lMask;

        while (Count > 1) {
            *ptr++ |= 0xFFFFFFFF;
            Count--;
        }

        if (Count) {
            *ptr |= rMask;
        }

    } else {

        *ptr++ &= ~lMask;

        while (Count > 1) {
            *ptr++ &= 0;
            Count--;
        }

        if (Count) {
            *ptr++ &= ~rMask;
        }
    }

#if DBG
    pVideoDebugPrint((1, "Current BitField for Region: 0x%x\n", Region));
    DumpBitField(Region);
#endif
}

BOOLEAN
FindFirstRun(
    PREGION Region,
    PULONG Offset,
    PULONG Length
    )

/*++

Routine Description:

    This routine finds the first run of bits in a bitfield.

Arguments:

    Region - Pointer to the region to operate on.

    Offset - Pointer to a ULONG to hold the offset of the run.

    Length - Pointer to a ULONG to hold the length of a run.

Returns:

    TRUE if a run was detected,
    FALSE otherwise.

--*/

{
    PULONG ptr = Region->BitField;
    ULONG Index = 0;
    ULONG BitMask;
    ULONG lsb;
    ULONG Count;
    ULONG ptrVal;

    while ((Index < Region->NumDwords) && (*ptr == 0)) {
        ptr++;
        Index++;
    }

    if (Index == Region->NumDwords) {
        return FALSE;
    }

    //
    // Find least significant bit
    //

    lsb = 0;
    ptrVal = *ptr;
    BitMask = 1;

    while ((ptrVal & BitMask) == 0) {
        BitMask <<= 1;
        lsb++;
    }

    *Offset = (Index * 32) + lsb;

    //
    // Determine the run length
    //

    Count = 0;

    while (Index < Region->NumDwords) {
        if (ptrVal & BitMask) {
            BitMask <<= 1;
            Count++;

            if (BitMask == 0) {
                BitMask = 0x1;
                Index++;
                ptrVal = *++ptr;
                while ((ptrVal == 0xFFFFFFFF) && (Index < Region->NumDwords)) {
                    Index++;
                    Count += 32;
                    ptrVal = *ptr++;
                }
            }

        } else {
            break;
        }
    }

    *Length = Count;
    return TRUE;
}

PHYSICAL_ADDRESS
AgpReservePhysical(
    IN PVOID Context,
    IN ULONG Pages,
    IN ULONG Caching,
    OUT PVOID *PhysicalReserveContext
    )

/*++

Routine Description:

    Reserves a range of physical addresses for AGP.

Arguments:

    Context - The Agp Context

    Pages - Number of pages to reserve

    Caching - Specifies the type of caching to use

    PhysicalReserveContext - Location to store our reservation context.

Returns:

    The base of the physical address range reserved.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(Context);
    PHYSICAL_ADDRESS PhysicalAddress = {0,0};
    NTSTATUS status;
    PPHYSICAL_RESERVE_CONTEXT ReserveContext;
    PVOID MapHandle;

    pVideoDebugPrint((1, "AGP: Reserving 0x%x Pages of Address Space\n", Pages));

    ReserveContext = ExAllocatePoolWithTag(PagedPool,
                                           sizeof(PHYSICAL_RESERVE_CONTEXT),
                                           POOL_TAG);

    if (ReserveContext) {

        if (CreateBitField(Pages, &ReserveContext->Region)) {

            status = fdoExtension->AgpInterface.ReserveMemory(
                         fdoExtension->AgpInterface.AgpContext,
                         Pages,
                         Caching ? MmWriteCombined : MmNonCached,
                         &MapHandle,
                         &PhysicalAddress);

            if (NT_SUCCESS(status)) {

                ReserveContext->Pages = Pages;
                ReserveContext->Caching = Caching;
                ReserveContext->MapHandle = MapHandle;
                ReserveContext->PhysicalAddress = PhysicalAddress;

            } else {

                ExFreePool(ReserveContext->Region);
                goto FailureCase;
            }

        } else {

            goto FailureCase;
        }
    }

    *PhysicalReserveContext = ReserveContext;
    return PhysicalAddress;

FailureCase:

    PhysicalAddress.QuadPart = 0;
    ExFreePool(ReserveContext);
    *PhysicalReserveContext = NULL;

    return PhysicalAddress;
}

VOID
AgpReleasePhysical(
    PVOID Context,
    PVOID PhysicalReserveContext
    )

/*++

Routine Description:

    Reserves a range of reserved physical address.

Arguments:

    Context - The Agp Context

    PhysicalReserveContext - The reservation context.

Returns:

    none.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(Context);
    PPHYSICAL_RESERVE_CONTEXT ReserveContext;
    ULONG Pages;
    ULONG Offset;

    ReserveContext = (PPHYSICAL_RESERVE_CONTEXT) PhysicalReserveContext;

    pVideoDebugPrint((1, "AGP: Releasing 0x%x Pages of Address Space\n", ReserveContext->Pages));

    //
    // Make sure all pages have been freed
    //

    while (FindFirstRun(ReserveContext->Region, &Offset, &Pages)) {
        AgpFreePhysical(Context, PhysicalReserveContext, Pages, Offset);
    }

    fdoExtension->AgpInterface.ReleaseMemory(fdoExtension->AgpInterface.AgpContext,
                                             ReserveContext->MapHandle);

    ExFreePool(ReserveContext->Region);
    ExFreePool(ReserveContext);
}

BOOLEAN
AgpCommitPhysical(
    PVOID Context,
    PVOID PhysicalReserveContext,
    ULONG Pages,
    ULONG Offset
    )

/*++

Routine Description:

    Reserves a range of physical addresses for AGP.

Arguments:

    Context - The Agp Context

    PhysicalReserveContext - The reservation context.

    Pages - Number of pages to commit.

    Offset - The offset into the reserved region at which to commit the pages.

Returns:

    TRUE if successful,
    FALSE otherwise.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(Context);
    PHYSICAL_ADDRESS MemoryBase = {0,0};
    PPHYSICAL_RESERVE_CONTEXT ReserveContext;
    NTSTATUS status;

    ReserveContext = (PPHYSICAL_RESERVE_CONTEXT) PhysicalReserveContext;

    status =
        fdoExtension->AgpInterface.CommitMemory(fdoExtension->AgpInterface.AgpContext,
                                                ReserveContext->MapHandle,
                                                Pages,
                                                Offset,
                                                NULL,
                                                &MemoryBase);

    if (NT_SUCCESS(status)) {

        ModifyRegion(ReserveContext->Region, Offset, Pages, TRUE);
        return TRUE;

    } else {

        return FALSE;
    }
}

VOID
AgpFreePhysical(
    IN PVOID Context,
    IN PVOID PhysicalReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    )

/*++

Routine Description:

    Reserves a range of physical addresses for AGP.

Arguments:

    Context - The Agp Context

    PhysicalReserveContext - The reservation context.

    Pages - Number of pages to release.

    Offset - The offset into the reserved region at which to release the pages.

Returns:

    none.

Notes:

    At the moment you must free the exact same offset/size as you commited.
    (ie. You can commit 10 pages at offset 2 and then free 5 pages at offset 4).

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(Context);
    PPHYSICAL_RESERVE_CONTEXT ReserveContext;

    ReserveContext = (PPHYSICAL_RESERVE_CONTEXT) PhysicalReserveContext;

    fdoExtension->AgpInterface.FreeMemory(fdoExtension->AgpInterface.AgpContext,
                                          ReserveContext->MapHandle,
                                          Pages,
                                          Offset);

    ModifyRegion(ReserveContext->Region, Offset, Pages, FALSE);
}


PVOID
AgpReserveVirtual(
    IN PVOID Context,
    IN HANDLE ProcessHandle,
    IN PVOID PhysicalReserveContext,
    OUT PVOID *VirtualReserveContext
    )

/*++

Routine Description:

    Reserves a range of virtual addresses for AGP.

Arguments:

    Context - The Agp Context

    ProcessHandle - The handle of the process in which to reserve the
        virtual address range.

    PhysicalReserveContext - The physical reservation context to assoctiate
        with the given virtual reservation.

    VirtualReserveContext - The location in which to store the virtual
        reserve context.

Returns:

    The base of the virtual address range reserved.

Notes:

    You can't reserve a range of kernel address space, but if you want to
    commit into kernel space you still need a reservation handle.  Pass in
    NULL for the process handle in this case.

    For the moment, we'll commit the entire region when the do a reservation
    in kernel space.  Then Commit and Free will be no-ops.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(Context);
    ULONG Protect = PAGE_READWRITE;
    PVIRTUAL_RESERVE_CONTEXT ReserveContext;
    PPHYSICAL_RESERVE_CONTEXT PhysicalContext;
    SIZE_T Length;
    PVOID VirtualAddress = NULL;
    PEPROCESS Process = NULL;

    PhysicalContext = (PPHYSICAL_RESERVE_CONTEXT) PhysicalReserveContext;
    Length = PhysicalContext->Pages * PAGE_SIZE;

    ReserveContext = ExAllocatePoolWithTag(PagedPool,
                                           sizeof(VIRTUAL_RESERVE_CONTEXT),
                                           POOL_TAG);

    if (ReserveContext) {

        if (CreateBitField(PhysicalContext->Pages, &ReserveContext->Region)) {

            //
            // BUGBUG: Fix this routine for kernel mode reservation!
            //

            if (!PhysicalContext->Caching) {
                Protect |= PAGE_NOCACHE;
            }

            //
            // Make sure we have the real process handle.
            //

            if (ProcessHandle == NtCurrentProcess()) {
                Process = PsGetCurrentProcess();
            }

            ReserveContext->ProcessHandle = ProcessHandle;
            ReserveContext->Process = Process;
            ReserveContext->PhysicalReserveContext =
                (PPHYSICAL_RESERVE_CONTEXT) PhysicalReserveContext;
            ReserveContext->ReservationList = NULL;

            if (ProcessHandle) {

                VirtualAddress =
                    AddRangeToReservedRegion(ReserveContext,
                                             PhysicalContext->Pages,
                                             0);

                ASSERT(VirtualAddress != NULL);

            } else {

                //
                // BUGBUG: Find a better way to reserve in kernel space.
                //
                // For a kernel reservation, go ahead and commit the
                // entire range.
                //

                if (fdoExtension->AgpInterface.Capabilities &
                    AGP_CAPABILITIES_MAP_PHYSICAL)
                {
                    //
                    // CPU can access AGP memory through AGP aperature.
                    //

                    VirtualAddress =
                        MmMapIoSpace(PhysicalContext->PhysicalAddress.LowPart,
                                     PhysicalContext->Pages * PAGE_SIZE,
                                     PhysicalContext->Caching ? MmFrameBufferCached : 0);
                    //
                    // Not all systems support USWC, so if we attempted to map USWC
                    // and failed, try again with just non-cached.
                    //
                    if ((VirtualAddress == NULL) &&
                        (PhysicalContext->Caching)) {
                        VirtualAddress = MmMapIoSpace(PhysicalContext->PhysicalAddress.LowPart,
                                                      PhysicalContext->Pages * PAGE_SIZE,
                                                      MmNonCached);
                    }

                } else {

                    PMDL Mdl;

                    //
                    // Get the MDL for the range we are trying to map.
                    //

                    Mdl = MmCreateMdl(NULL, NULL, PhysicalContext->Pages * PAGE_SIZE);

                    if (Mdl) {

                        fdoExtension->AgpInterface.GetMappedPages(
                                         fdoExtension->AgpInterface.AgpContext,
                                         PhysicalContext->MapHandle,
                                         PhysicalContext->Pages,
                                         0,
                                         Mdl);

                        //
                        // We must use the CPU's virtual memory mechanism to
                        // make the non-contiguous MDL look contiguous.
                        //

                        VirtualAddress =
                            MmMapLockedPagesSpecifyCache(
                                Mdl,
                                PhysicalContext->Caching ? MmCached : MmNonCached);

                        ExFreePool(Mdl);
                    }
                }
            }

            ReserveContext->VirtualAddress = VirtualAddress;

        } else {

            pVideoDebugPrint((1, "Couldn't create bit field.\n"));
            ExFreePool(ReserveContext);
            ReserveContext = NULL;
        }

    } else {

        pVideoDebugPrint((1, "AgpReserveVirtual: Out of memory.\n"));
    }

    *VirtualReserveContext = ReserveContext;
    return VirtualAddress;
}

VOID
AgpReleaseVirtual(
    IN PVOID Context,
    IN PVOID VirtualReserveContext
    )

/*++

Routine Description:

    Releases a range of reserved virtual addresses.

Arguments:

    Context - The Agp Context

    VirtualReserveContext - The reservation context.

Returns:

    none.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(Context);
    PVIRTUAL_RESERVE_CONTEXT VirtualContext;
    PPHYSICAL_RESERVE_CONTEXT PhysicalContext;
    ULONG Offset;
    ULONG Pages;

    VirtualContext = (PVIRTUAL_RESERVE_CONTEXT) VirtualReserveContext;
    PhysicalContext = VirtualContext->PhysicalReserveContext;

    if (VirtualContext->ProcessHandle) {

        //
        // Make sure all pages have been freed
        //

        while (FindFirstRun(VirtualContext->Region, &Offset, &Pages)) {
            AgpFreeVirtual(Context, VirtualReserveContext, Pages, Offset);
        }

        if (VirtualContext->VirtualAddress) {

            ASSERT(VirtualContext->ReservationList->Next == NULL);

            RemoveRangeFromReservedRegion(VirtualContext,
                                          VirtualContext->ReservationList->Pages,
                                          VirtualContext->ReservationList->Offset);

            if (VirtualContext->ReservationList) {

                ExFreePool(VirtualContext->ReservationList);
                VirtualContext->ReservationList = NULL;
            }
        }

        ExFreePool(VirtualContext->Region);
        ExFreePool(VirtualContext);

    } else {

        //
        // This was kernel virtual memory, so release the memory we
        // committed at reserve time.
        //

        if (fdoExtension->AgpInterface.Capabilities &
            AGP_CAPABILITIES_MAP_PHYSICAL)
        {
            MmUnmapIoSpace(VirtualContext->VirtualAddress,
                           PhysicalContext->Pages * PAGE_SIZE);

        } else {

            PMDL Mdl;

            //
            // Get the MDL for the range we are trying to map.
            //

            Mdl = MmCreateMdl(NULL, NULL, PhysicalContext->Pages * PAGE_SIZE);

            if (Mdl) {

                fdoExtension->AgpInterface.GetMappedPages(
                                fdoExtension->AgpInterface.AgpContext,
                                PhysicalContext->MapHandle,
                                PhysicalContext->Pages,
                                0,
                                Mdl);

                MmUnmapLockedPages(
                    VirtualContext->VirtualAddress,
                    Mdl);

                ExFreePool(Mdl);

            } else {

                //
                // We couldn't free the memory because we couldn't allocate
                // memory for the MDL.  We can free a small chunk at a time
                // by using a MDL on the stack.
                //

                ASSERT(FALSE);
            }
        }
    }
}

PVOID
AddRangeToReservedRegion(
    IN PVIRTUAL_RESERVE_CONTEXT VirtualContext,
    IN ULONG Pages,
    IN ULONG Offset
    )

/*++

Routine Description:

    Adds a range to a reserved region of virtual address space.

Arguments:

    VirtualContext - The context of the virtual reservation.

    Pages - Length of the region to release.

    Offset - Offset into region at which to start releasing pages.

Returns:

    none.

--*/

{
    PULONG VirtualAddress = NULL;
    SIZE_T Length;
    ULONG Protect = PAGE_READWRITE;
    NTSTATUS Status;
    PRESERVATION_LIST Curr, Prev = NULL;

    pVideoDebugPrint((1, "AddPagesToReservedRange\n"));
    pVideoDebugPrint((1, "  Pages = 0x%x\n  Offset = 0x%x\n", Pages, Offset));

    //
    // Adjust Pages and Offset such that will always deal with 64K chunks.
    //

    Pages = Pages + (Offset & 0xf); // grow pages due to decrease offset
    Offset = Offset & ~0xf;         // shrink offset to make it multiple of 16
    Pages = (Pages + 0xf) & ~0xf;   // grow pages to make it multiple of 16

    pVideoDebugPrint((1, "  Pages = 0x%x\n  Offset = 0x%x\n", Pages, Offset));

    if (VirtualContext->ReservationList) {

        //
        // We are making the assumption that if range is added, and we
        // already have a reservation list, that we had removed a region
        // because we mapped it, and now we are adding it back.  So we
        // should be able to scan for a region, and just set the
        // reserved bit to TRUE.  We can then concatinate with existing
        // right or left regions.
        //

        Curr = VirtualContext->ReservationList;

        while (Curr) {

            if (Curr->Offset == Offset)
                break;

            Prev = Curr;
            Curr = Curr->Next;
        }

        pVideoDebugPrint((1, "Region to Reserve:\n"
                             "  Offset: 0x%x\n"
                             "  Pages: 0x%x\n",
                             Curr->Offset,
                             Curr->Pages));

        //
        // If the region is already reserved, simply return.
        //

        if (Curr->Reserved == TRUE) {
            pVideoDebugPrint((1, "Region is already reserved!\n"));
            return NULL;
        }

        //
        // If there is still an allocation in this region, then return.
        //

        if (--Curr->RefCount) {
            pVideoDebugPrint((1, "Region is still in use.\n"));
            return NULL;
        }

        pVideoDebugPrint((1, "Marking region as reserved.\n"));

        Curr->Reserved = TRUE;

        //
        // See if we can concatinate with the left or right region.
        //

        if (Prev && (Prev->Reserved)) {

            //
            // Release the region which we are concatinating with.
            //

            VirtualAddress = (PULONG)((ULONG_PTR)VirtualContext->VirtualAddress + Prev->Offset * PAGE_SIZE);
            Length = Prev->Pages * PAGE_SIZE;

            if (!VirtualContext->PhysicalReserveContext->Caching) {
                Protect |= PAGE_NOCACHE;
            }

            pVideoDebugPrint((1, "Freeing reserved region of length 0x%x at address 0x%p\n",
                                 (ULONG)Length, VirtualAddress));

            if (!NT_SUCCESS(NtFreeVirtualMemory(VirtualContext->ProcessHandle,
                                                &VirtualAddress,
                                                &Length,
                                                MEM_RELEASE)))
            {
                ASSERT(FALSE);
            }

            pVideoDebugPrint((1, "Concatenating with previous range.\n"));

            Prev->Pages += Curr->Pages;
            Prev->Next = Curr->Next;

            ExFreePool(Curr);

            Curr = Prev;
        }

        if (Curr->Next && (Curr->Next->Reserved)) {

            PRESERVATION_LIST Next = Curr->Next;

            //
            // Release the region which we are concatinating with.
            //

            VirtualAddress = (PULONG)((ULONG_PTR)VirtualContext->VirtualAddress + Next->Offset * PAGE_SIZE);
            Length = Next->Pages * PAGE_SIZE;

            if (!VirtualContext->PhysicalReserveContext->Caching) {
                Protect |= PAGE_NOCACHE;
            }

            pVideoDebugPrint((1, "Freeing reserved region of length 0x%x at address 0x%p\n",
                                 (ULONG)Length, VirtualAddress));

            if (!NT_SUCCESS(NtFreeVirtualMemory(VirtualContext->ProcessHandle,
                                                &VirtualAddress,
                                                &Length,
                                                MEM_RELEASE)))
            {
                ASSERT(FALSE);
            }

            pVideoDebugPrint((1, "Concatenating with next range.\n"));

            Curr->Pages += Next->Pages;
            Curr->Next = Next->Next;

            ExFreePool(Next);
        }

        pVideoDebugPrint((1, "Expanded Region:\n"
                             "  Offset: 0x%x\n"
                             "  Pages: 0x%x\n",
                             Curr->Offset,
                             Curr->Pages));

        VirtualAddress = (PULONG)((ULONG_PTR)VirtualContext->VirtualAddress + Curr->Offset * PAGE_SIZE);

    } else {

        //
        // Indicate we don't care where we reserve from.
        //

        VirtualAddress = NULL;

        Curr = ExAllocatePoolWithTag(PagedPool,
                                     sizeof(RESERVATION_LIST),
                                     POOL_TAG);

        if (Curr) {

            Curr->Offset   = Offset;
            Curr->Pages    = Pages;
            Curr->RefCount = 0;
            Curr->Reserved = TRUE;
            Curr->Next     = NULL;

            VirtualContext->ReservationList = Curr;

        } else {

            return NULL;
        }
    }

    Length = Curr->Pages * PAGE_SIZE;

    if (!VirtualContext->PhysicalReserveContext->Caching) {
        Protect |= PAGE_NOCACHE;
    }

    pVideoDebugPrint((1, "Reserving 0x%x bytes at virtual address 0x%p\n",
                         (ULONG)Length, VirtualAddress));

    Status = NtAllocateVirtualMemory(VirtualContext->ProcessHandle,
                                            &VirtualAddress,
                                            0,
                                            &Length,
                                            MEM_RESERVE,
                                            Protect);

    if (!NT_SUCCESS(Status)) {

        pVideoDebugPrint((1, "Status = 0x%x\n", Status));
        ASSERT(FALSE);
        return NULL;
    }

    return VirtualAddress;
}

VOID
RemoveRangeFromReservedRegion(
    IN PVIRTUAL_RESERVE_CONTEXT VirtualContext,
    IN ULONG Pages,
    IN ULONG Offset
    )

/*++

Routine Description:

    Release a sub range of a reserved region of virtual address space.

Arguments:

    VirtualContext - The context of the virtual reservation.

    Pages - Length of the region to release.

    Offset - Offset into region at which to start releasing pages.

Returns:

    none.

--*/

{
    PRESERVATION_LIST ReservationList, Curr, Prev = NULL;
    PULONG VirtualAddress = NULL;
    SIZE_T Length;
    ULONG Protect = PAGE_READWRITE;
    ULONG_PTR Address;

    pVideoDebugPrint((1, "RemovePagesFromReservedRange\n"));
    pVideoDebugPrint((1, "  Pages = 0x%x\n  Offset = 0x%x\n", Pages, Offset));

    //
    // Adjust Pages and Offset such that will always deal with 64K chunks.
    //

    Pages = Pages + (Offset & 0xf); // grow pages due to decrease offset
    Offset = Offset & ~0xf;         // shrink offset to make it multiple of 16
    Pages = (Pages + 0xf) & ~0xf;   // grow pages to make it multiple of 16

    pVideoDebugPrint((1, "  Pages = 0x%x\n  Offset = 0x%x\n", Pages, Offset));

    ASSERT(VirtualContext->ReservationList != NULL);

    Curr = VirtualContext->ReservationList;

    while (Curr) {

        if ((Curr->Offset <= Offset) &&
            ((Curr->Offset + Curr->Pages) > Offset)) {

            break;
        }

        Prev = Curr;
        Curr = Curr->Next;
    }

    pVideoDebugPrint((1, "Range to fill into:\n"
                         "  Offset: 0x%x\n"
                         "  Pages: 0x%x\n",
                         Curr->Offset,
                         Curr->Pages));


    ASSERT(Curr != NULL);

    //
    // If the region is already free, simply return.
    //

    if (Curr->Reserved == FALSE) {
        Curr->RefCount++;
        return;
    }

    //
    // Release the region which we are mapping into.
    //

    VirtualAddress = (PULONG)((ULONG_PTR)VirtualContext->VirtualAddress + Curr->Offset * PAGE_SIZE);
    Length = Curr->Pages * PAGE_SIZE;

    if (!VirtualContext->PhysicalReserveContext->Caching) {
        Protect |= PAGE_NOCACHE;
    }

    pVideoDebugPrint((1, "Freeing reserved region of length 0x%x at address 0x%p\n",
                         (ULONG)Length, VirtualAddress));

    if (!NT_SUCCESS(NtFreeVirtualMemory(VirtualContext->ProcessHandle,
                                        &VirtualAddress,
                                        &Length,
                                        MEM_RELEASE)))
    {
        ASSERT(FALSE);
    }

    //
    // Mark the region as not reserved.
    //

    Curr->Reserved = FALSE;
    Curr->RefCount++;

    //
    // Now see if we have sub regions to re-reserve.
    //

    if (Curr->Offset < Offset) {

        //
        // There will be a left over region prior to Curr.
        //

        ReservationList = ExAllocatePoolWithTag(PagedPool,
                                                sizeof(RESERVATION_LIST),
                                                POOL_TAG);

        if (ReservationList) {

            ReservationList->Offset = Curr->Offset;
            ReservationList->Pages = Offset - Curr->Offset;
            ReservationList->RefCount = 0;
            ReservationList->Next = Curr;
            ReservationList->Reserved = TRUE;

            Curr->Pages -= Offset - Curr->Offset;
            Curr->Offset = Offset;

        } else {

            return;
        }

        if (Prev) {
            Prev->Next = ReservationList;
        } else {
            VirtualContext->ReservationList = ReservationList;
        }

        pVideoDebugPrint((1, "Creating 'left' subregion\n"
                             "  Offset: 0x%x\n"
                             "  Pages:  0x%x\n",
                             ReservationList->Offset,
                             ReservationList->Pages));

        //
        // Calculate the virtual address and length of the memory to reserve.
        // Note that NtAllocateVirtualMemory always rounds to a 64K boundary,
        // so we'll have to round up to prevent it from rounding down.
        //

        Address = ((ULONG_PTR)VirtualContext->VirtualAddress + ReservationList->Offset * PAGE_SIZE);
        VirtualAddress = (PULONG)Address;

        Length = ReservationList->Pages * PAGE_SIZE;

        pVideoDebugPrint((1, "Reserving memory range of length 0x%x at location 0x%p\n",
                             (ULONG)Length, VirtualAddress));

        if (!NT_SUCCESS(NtAllocateVirtualMemory(VirtualContext->ProcessHandle,
                                                &VirtualAddress,
                                                0,
                                                &Length,
                                                MEM_RESERVE,
                                                Protect)))
        {
            ASSERT(FALSE);
        }
    }

    if (Curr->Pages > Pages) {

        //
        // There will be a left over region after Curr.
        //

        ReservationList = ExAllocatePoolWithTag(PagedPool,
                                                sizeof(RESERVATION_LIST),
                                                POOL_TAG);

        if (ReservationList) {

            ReservationList->Offset = Curr->Offset + Pages;
            ReservationList->Pages = Curr->Pages - Pages;
            ReservationList->RefCount = 0;
            ReservationList->Reserved = TRUE;

            Curr->Pages = Pages;

        } else {

            //
            // BUGBUG:
            //
            // If we return here then we have to adjacent blocks
            // which are both reserved.  This will not cause a
            // problem, but it will never be cleaned up.
            //

            return;
        }

        pVideoDebugPrint((1, "Creating 'right' subregion\n"
                             "  Offset: 0x%x\n"
                             "  Pages:  0x%x\n",
                             ReservationList->Offset,
                             ReservationList->Pages));


        ReservationList->Next = Curr->Next;
        Curr->Next = ReservationList;

        VirtualAddress = (PULONG)((ULONG_PTR)VirtualContext->VirtualAddress + ReservationList->Offset * PAGE_SIZE);
        Length = ReservationList->Pages * PAGE_SIZE;

        pVideoDebugPrint((1, "Reserving memory range of length 0x%x at location 0x%p\n",
                             (ULONG)Length, VirtualAddress));

        if (!NT_SUCCESS(NtAllocateVirtualMemory(VirtualContext->ProcessHandle,
                                                &VirtualAddress,
                                                0,
                                                &Length,
                                                MEM_RESERVE,
                                                Protect)))
        {
            ASSERT(FALSE);
        }
    }

    return;
}

PVOID
AgpCommitVirtual(
    IN PVOID Context,
    IN PVOID VirtualReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    )

/*++

Routine Description:

    Reserves a range of physical addresses for AGP.

Arguments:

    Context - The Agp Context

    VirtualReserveContext - The reservation context.

    Pages - Number of pages to commit.

    Offset - The offset into the reserved region at which to commit the pages.

Returns:

    The virtual address for the base of the commited pages.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(Context);
    PVIRTUAL_RESERVE_CONTEXT VirtualContext;
    PPHYSICAL_RESERVE_CONTEXT PhysicalContext;
    PHYSICAL_ADDRESS PhysicalAddress;
    PVOID VirtualAddress = NULL;
    PVOID PhysicalMemorySection = NULL;
    HANDLE PhysicalMemoryHandle;
    NTSTATUS ntStatus;
    BOOLEAN bUserMode;

    VirtualContext = (PVIRTUAL_RESERVE_CONTEXT) VirtualReserveContext;
    PhysicalContext = VirtualContext->PhysicalReserveContext;

    PhysicalAddress = PhysicalContext->PhysicalAddress;
    PhysicalAddress.LowPart += Offset * PAGE_SIZE;

    bUserMode = (BOOLEAN)(VirtualContext->ProcessHandle != NULL);

    if (bUserMode) {

        //
        // First release the VA range we are going to map into.
        //

        RemoveRangeFromReservedRegion(VirtualContext,
                                      Pages,
                                      Offset);

        if (fdoExtension->AgpInterface.Capabilities &
            AGP_CAPABILITIES_MAP_PHYSICAL)
        {
            //
            // CPU can access AGP memory through AGP aperature.
            //

            ASSERT(FALSE);

            //
            // Get a handle to the physical memory section using our pointer.
            // If this fails, return.
            //

            ntStatus =
                ObOpenObjectByPointer(
                    PhysicalMemorySection,
                    (POBJECT_TYPE) NULL,
                    &PhysicalMemoryHandle);

            //
            // If successful, map the memory.
            //

            if (NT_SUCCESS(ntStatus)) {

                SIZE_T Length = Pages * PAGE_SIZE;
                ULONG Protect = PAGE_READWRITE;

                VirtualAddress = ((PUCHAR)VirtualContext->VirtualAddress + Offset * PAGE_SIZE);

                if (!PhysicalContext->Caching) {
                    Protect |= PAGE_NOCACHE;
                }

                ntStatus =
                    NtMapViewOfSection(
                        PhysicalMemoryHandle,
                        VirtualContext->ProcessHandle,
                        &VirtualAddress,
                        0,
                        Pages * PAGE_SIZE,
                        &PhysicalAddress,
                        &Length,
                        ViewUnmap,
                        0,
                        Protect);

                pVideoDebugPrint((1, "ntStatus = 0x%x\n", ntStatus));

                NtClose(PhysicalMemoryHandle);

            }

        } else {

            PMDL Mdl;

            //
            // Get the MDL for the range we are trying to map.
            //

            Mdl = MmCreateMdl(NULL, NULL, Pages * PAGE_SIZE);

            if (Mdl) {

                fdoExtension->AgpInterface.GetMappedPages(
                                 fdoExtension->AgpInterface.AgpContext,
                                 PhysicalContext->MapHandle,
                                 Pages,
                                 Offset,
                                 Mdl);

                //
                // We must use the CPU's virtual memory mechanism to
                // make the non-contiguous MDL look contiguous.
                //

                VirtualAddress =
                    MmMapLockedPagesSpecifyCache(
                        Mdl,
                        PhysicalContext->Caching ? MmCached : MmNonCached);

                ExFreePool(Mdl);
            }
        }

        if (VirtualAddress) {
            ModifyRegion(VirtualContext->Region, Offset, Pages, TRUE);
        }

    } else {

        //
        // Kernel mode commit.  Do nothing.
        //

        VirtualAddress = ((PUCHAR)VirtualContext->VirtualAddress + Offset * PAGE_SIZE);
    }

    return VirtualAddress;
}

VOID
AgpFreeVirtual(
    IN PVOID Context,
    IN PVOID VirtualReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    )

/*++

Routine Description:

    Frees a range of virtual addresses.

Arguments:

    Context - The Agp Context

    VirtualReserveContext - The reservation context.

    Pages - Number of pages to release.

    Offset - The offset into the reserved region at which to release the pages.

Returns:

    none.

Notes:

    At the moment you must free the exact same offset/size as you commited.
    (ie. You can commit 10 pages at offset 2 and then free 5 pages at offset 4).

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(Context);
    PVIRTUAL_RESERVE_CONTEXT VirtualContext;
    PPHYSICAL_RESERVE_CONTEXT PhysicalContext;
    PVOID VirtualAddress;

    VirtualContext = (PVIRTUAL_RESERVE_CONTEXT) VirtualReserveContext;
    PhysicalContext = VirtualContext->PhysicalReserveContext;

    VirtualAddress = (PUCHAR)((ULONG_PTR)VirtualContext->VirtualAddress + Offset * PAGE_SIZE);

    //
    // Make sure we are in the correct process context.
    //

    if (VirtualContext->ProcessHandle != NULL) {

        if (fdoExtension->AgpInterface.Capabilities &
            AGP_CAPABILITIES_MAP_PHYSICAL)
        {
            if (VirtualAddress <= MM_HIGHEST_USER_ADDRESS) {

                NtUnmapViewOfSection(
                    VirtualContext->ProcessHandle,
                    VirtualAddress);

            } else {

                MmUnmapIoSpace(VirtualAddress,
                               Pages * PAGE_SIZE);
            }

        } else {

            PMDL Mdl;

            //
            // Get the MDL for the range we are trying to map.
            //

            Mdl = MmCreateMdl(NULL, NULL, Pages * PAGE_SIZE);

            if (Mdl) {

                fdoExtension->AgpInterface.GetMappedPages(
                                fdoExtension->AgpInterface.AgpContext,
                                PhysicalContext->MapHandle,
                                Pages,
                                Offset,
                                Mdl);

                MmUnmapLockedPages(
                    VirtualAddress,
                    Mdl);

                ExFreePool(Mdl);

            } else {

                //
                // We couldn't free the memory because we couldn't allocate
                // memory for the MDL.  We can free a small chunk at a time
                // by using a MDL on the stack.
                //

                ASSERT(FALSE);
            }
        }

        if (VirtualAddress <= MM_HIGHEST_USER_ADDRESS) {

            AddRangeToReservedRegion(VirtualContext,
                                     Pages,
                                     Offset);
        }

        ModifyRegion(VirtualContext->Region, Offset, Pages, FALSE);

    } else {

        //
        // Kernel Space Free - do nothing.
        //
    }
}

BOOLEAN
VideoPortGetAgpServices(
    IN PVOID HwDeviceExtension,
    OUT PVIDEO_PORT_AGP_SERVICES AgpServices
    )
{
    NTSTATUS status;
    SYSTEM_BASIC_INFORMATION BasicInformation;

    //
    // Figure out how much physical memory is in the system.
    //

    status = NtQuerySystemInformation(SystemBasicInformation, &BasicInformation,
        sizeof(SYSTEM_BASIC_INFORMATION), NULL);

    if (!NT_SUCCESS(status)) {
        return FALSE;
    }

    //
    // Fill in the AGP services table.
    //

    AgpServices->AgpReservePhysical = AgpReservePhysical;
    AgpServices->AgpCommitPhysical = AgpCommitPhysical;
    AgpServices->AgpFreePhysical = AgpFreePhysical;
    AgpServices->AgpReleasePhysical = AgpReleasePhysical;
    AgpServices->AgpReserveVirtual = AgpReserveVirtual;
    AgpServices->AgpCommitVirtual = AgpCommitVirtual;
    AgpServices->AgpFreeVirtual = AgpFreeVirtual;
    AgpServices->AgpReleaseVirtual = AgpReleaseVirtual;
    AgpServices->AllocationLimit =
        (BasicInformation.NumberOfPhysicalPages << PAGE_SHIFT) / 8;

    return TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\portx\agpuma.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    agpuma.c

Abstract:

    This module maps all physical memory into the AGP address space.  It is
    used by the XBOX to simulate UMA.

--*/

#if 1 // NUGOOP

// Nasty path, but there are only two files that need to make kernel calls.
#include <ntos.h>
#include <pci.h>
#include <ntddvdeo.h>
#include <ntagp.h>
#include <stdio.h>

#if defined(DBG)

    #define RIP(msg)            \
        {                       \
            DbgPrint msg;     \
            DbgPrint("\n");   \
            _asm { int 3 };     \
        }

#else

    #define RIP(msg) {}

#endif

static BOOLEAN s_fInitialized;

//
// Define the location of the GART aperture control registers
//

#define AGP440_TARGET_DEVICE_NUMBER             0
#define AGP440_TARGET_FUNCTION_NUMBER           0

// Defines what mode we're using.  If the hardware doesn't support this then
// we'll RIP.
//
#define AGP_APERTURE_SIZE       0x30
#define AGP_APERTURE_BYTES      (64*1024*1024)
#define AGP_APERTURE_BASE       0xF8000000

//
// The GART registers on the 440 live in the host-PCI bridge.
// This is unfortunate, since the AGP driver attaches to the PCI-PCI (AGP)
// bridge. So we have to get to the host-PCI bridge config space
// and this is only possible because we KNOW this is bus 0, slot 0.
//
#define AGP_440_GART_BUS_ID     0
#define AGP_440_GART_SLOT_ID    0

#define AGP_440LX_IDENTIFIER    0x71808086
#define AGP_440BX_IDENTIFIER    0x71908086

#define APBASE_OFFSET  0x10             // Aperture Base Address
#define APSIZE_OFFSET  0xB4             // Aperture Size Register
#define PACCFG_OFFSET  0x50             // PAC Configuration Register
#define AGPCTRL_OFFSET 0xB0             // AGP Control Register
#define ATTBASE_OFFSET 0xB8             // Aperture Translation Table Base

#define Read440Config(_buf_,_offset_,_size_)                \
{                                                           \
    ULONG _len_;                                            \
    _len_ = HalGetBusDataByOffset(PCIConfiguration,         \
                                  AGP_440_GART_BUS_ID,      \
                                  AGP_440_GART_SLOT_ID,     \
                                  (_buf_),                  \
                                  (_offset_),               \
                                  (_size_));                \
    ASSERT(_len_ == (_size_));                              \
}

#define Write440Config(_buf_,_offset_,_size_)               \
{                                                           \
    ULONG _len_;                                            \
    _len_ = HalSetBusDataByOffset(PCIConfiguration,         \
                                  AGP_440_GART_BUS_ID,      \
                                  AGP_440_GART_SLOT_ID,     \
                                  (_buf_),                  \
                                  (_offset_),               \
                                  (_size_));                \
    ASSERT(_len_ == (_size_));                              \
}

//
// Conversions from APSIZE encoding to MB
//
// 0x3F (b 11 1111) =   4MB
// 0x3E (b 11 1110) =   8MB
// 0x3C (b 11 1100) =  16MB
// 0x38 (b 11 1000) =  32MB
// 0x30 (b 11 0000) =  64MB
// 0x20 (b 10 0000) = 128MB
// 0x00 (b 00 0000) = 256MB

#define AP_SIZE_4MB     0x3F
#define AP_SIZE_8MB     0x3E
#define AP_SIZE_16MB    0x3C
#define AP_SIZE_32MB    0x38
#define AP_SIZE_64MB    0x30
#define AP_SIZE_128MB   0x20
#define AP_SIZE_256MB   0x00

#define AP_SIZE_COUNT 7
#define AP_MIN_SIZE (4 * 1024 * 1024)
#define AP_MAX_SIZE (256 * 1024 * 1024)

//
// Define the GART table entry.
//
typedef struct _GART_ENTRY_HW 
{
    ULONG Valid     :  1;
    ULONG Reserved  : 11;
    ULONG Page      : 20;
} GART_ENTRY_HW, *PGART_ENTRY_HW;


//
// GART Entry states are defined so that all software-only states
// have the Valid bit clear.
//
#define GART_ENTRY_VALID        1           //  001
#define GART_ENTRY_FREE         0           //  000

#define GART_ENTRY_WC           2           //  010
#define GART_ENTRY_UC           4           //  100

#define GART_ENTRY_RESERVED_WC  GART_ENTRY_WC
#define GART_ENTRY_RESERVED_UC  GART_ENTRY_UC

#define GART_ENTRY_VALID_WC     (GART_ENTRY_VALID)
#define GART_ENTRY_VALID_UC     (GART_ENTRY_VALID)


typedef struct _GART_ENTRY_SW 
{
    ULONG State     : 3;
    ULONG Reserved  : 29;
} GART_ENTRY_SW, *PGART_ENTRY_SW;

typedef struct _GART_PTE 
{
    union 
    {
        GART_ENTRY_HW Hard;
        ULONG      AsUlong;
        GART_ENTRY_SW Soft;
    };
} GART_PTE, *PGART_PTE;

//
// Define the layout of the hardware registers
//
typedef struct _AGPCTRL 
{
    ULONG Reserved1     : 7;
    ULONG GTLB_Enable   : 1;
    ULONG Reserved2     : 24;
} AGPCTRL, *PAGPCTRL;

typedef struct _PACCFG 
{
    USHORT Reserved1    : 9;
    USHORT GlobalEnable : 1;
    USHORT PCIEnable    : 1;
    USHORT Reserved2    : 5;
} PACCFG, *PPACCFG;


//
// Define the 440-specific extension
//
typedef struct _AGP440_EXTENSION 
{
    BOOLEAN             GlobalEnable;
    BOOLEAN             PCIEnable;
    PHYSICAL_ADDRESS    ApertureStart;
    ULONG               ApertureLength;
    PGART_PTE           GartCached;
    PGART_PTE           Gart;
    ULONG               GartLength;
    PHYSICAL_ADDRESS    GartPhysical;
} AGP440_EXTENSION, *PAGP440_EXTENSION;

//
// The highest memory address supported by AGP
//

#define MAX_MEM(_num_) _num_ = 1; \
                       _num_ = _num_*1024*1024*1024*4 - 1

typedef struct _AGP_RANGE 
{
    PHYSICAL_ADDRESS MemoryBase;
    ULONG NumberOfPages;
    MEMORY_CACHING_TYPE Type;
    PVOID Context;
    ULONG CommittedPages;
} AGP_RANGE, *PAGP_RANGE;


//
// The PCI_COMMON_CONFIG includes the 192 bytes of device specific
// data.  The following structure is used to get only the first 64
// bytes which is all we care about most of the time anyway.  We cast
// to PCI_COMMON_CONFIG to get at the actual fields.
//

typedef struct 
{
    ULONG Reserved[PCI_COMMON_HDR_LENGTH/sizeof(ULONG)];
} PCI_COMMON_HEADER, *PPCI_COMMON_HEADER;

typedef struct _BUS_SLOT_ID 
{
    ULONG BusId;
    ULONG SlotId;
} BUS_SLOT_ID, *PBUS_SLOT_ID;

typedef
NTSTATUS
(*PAGP_GETSET_CONFIG_SPACE)(
    IN PVOID Context,
    IN BOOLEAN Read,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

//============================================================================
// AGP Code
//============================================================================


NTSTATUS
ApGetSetDeviceBusData(
    IN PVOID Context,
    IN BOOLEAN Read,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    Reads or writes PCI config space for the specified device.

Arguments:

    Read - if TRUE, this is a READ IRP
           if FALSE, this is a WRITE IRP

    Buffer - Returns the PCI config data

    Offset - Supplies the offset into the PCI config data where the read should begin

    Length - Supplies the number of bytes to be read

Return Value:

    NTSTATUS

--*/

{
    PCI_SLOT_NUMBER SlotNumber;
    ULONG Transferred;

    SlotNumber.u.AsULONG = 0;
    SlotNumber.u.bits.DeviceNumber = AGP440_TARGET_DEVICE_NUMBER;
    SlotNumber.u.bits.FunctionNumber = AGP440_TARGET_FUNCTION_NUMBER;

    if (Read) {
        Transferred = HalGetBusDataByOffset(PCIConfiguration,
                                            1,
                                            SlotNumber.u.AsULONG,
                                            Buffer,
                                            Offset,
                                            Length);
    } else {
        Transferred = HalSetBusDataByOffset(PCIConfiguration,
                                            1,
                                            SlotNumber.u.AsULONG,
                                            Buffer,
                                            Offset,
                                            Length);

    }

    if (Transferred == Length) {
        return(STATUS_SUCCESS);
    } else {
        return(STATUS_UNSUCCESSFUL);
    }
}


NTSTATUS
ApGetSetBusData(
    IN PBUS_SLOT_ID BusSlotId,
    IN BOOLEAN Read,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    Calls HalGet/SetBusData for the specified PCI bus/slot ID.

Arguments:

    BusSlotId - Supplies the bus and slot ID.

    Read - if TRUE, this is a GetBusData
           if FALSE, this is a SetBusData

    Buffer - Returns the PCI config data

    Offset - Supplies the offset into the PCI config data where the read should begin

    Length - Supplies the number of bytes to be read

Return Value:

    NTSTATUS

--*/

{
    ULONG Transferred;

    if (Read) {
        Transferred = HalGetBusDataByOffset(PCIConfiguration,
                                            BusSlotId->BusId,
                                            BusSlotId->SlotId,
                                            Buffer,
                                            Offset,
                                            Length);
    } else {
        Transferred = HalSetBusDataByOffset(PCIConfiguration,
                                            BusSlotId->BusId,
                                            BusSlotId->SlotId,
                                            Buffer,
                                            Offset,
                                            Length);

    }
    if (Transferred == Length) {
        return(STATUS_SUCCESS);
    } else {
        return(STATUS_UNSUCCESSFUL);
    }
}


NTSTATUS
ApFindAgpCapability(
    IN PAGP_GETSET_CONFIG_SPACE pConfigFn,
    IN PVOID Context,
    OUT PPCI_AGP_CAPABILITY Capability,
    OUT UCHAR *pOffset
    )
/*++

Routine Description:

    Finds the capability offset for the specified device and
    reads in the header.

Arguments:

    pConfigFn - Supplies the function to call for accessing config space
        on the appropriate device.

    Context - Supplies the context to pass to pConfigFn

    Capabilities - Returns the AGP Capabilities common header

    pOffset - Returns the offset into config space.

Return Value:

    NTSTATUS

--*/

{
    PCI_COMMON_HEADER Header;
    PPCI_COMMON_CONFIG PciConfig = (PPCI_COMMON_CONFIG)&Header;
    NTSTATUS Status;
    UCHAR CapabilityOffset;

    //
    // Read the PCI common header to get the capabilities pointer
    //
    Status = (pConfigFn)(Context,
                         TRUE,
                         PciConfig,
                         0,
                         sizeof(PCI_COMMON_HEADER));
    if (!NT_SUCCESS(Status)) {
        RIP(("ApFindAgpCapability - read PCI Config space failed %08lx",
                Status));

        return(Status);
    }

    //
    // Check the Status register to see if this device supports capability lists.
    // If not, it is not an AGP-compliant device.
    //
    if ((PciConfig->Status & PCI_STATUS_CAPABILITIES_LIST) == 0) {
        RIP(("ApFindAgpCapability - Does not support Capabilities list, not an AGP device"));
        return(STATUS_NOT_IMPLEMENTED);
    }

    //
    // The device supports capability lists, find the AGP capabilities
    //
    if ((PciConfig->HeaderType & (~PCI_MULTIFUNCTION)) == PCI_BRIDGE_TYPE) {
        CapabilityOffset = PciConfig->u.type1.CapabilitiesPtr;
    } else {
        ASSERT((PciConfig->HeaderType & (~PCI_MULTIFUNCTION)) == PCI_DEVICE_TYPE);
        CapabilityOffset = PciConfig->u.type0.CapabilitiesPtr;
    }
    while (CapabilityOffset != 0) {

        //
        // Read the Capability at this offset
        //
        Status = (pConfigFn)(Context,
                             TRUE,
                             Capability,
                             CapabilityOffset,
                             sizeof(PCI_CAPABILITIES_HEADER));
        if (!NT_SUCCESS(Status)) {
            RIP(("ApFindAgpCapability - read PCI Capability at offset %x failed %08lx",
                    CapabilityOffset,
                    Status));
            return(Status);
        }
        if (Capability->Header.CapabilityID == PCI_CAPABILITY_ID_AGP) {
            //
            // Found the AGP Capability
            //
            break;
        } else {
            //
            // This is some other Capability, keep looking for the AGP Capability
            //
            CapabilityOffset = Capability->Header.Next;
        }
    }
    if (CapabilityOffset == 0) {
        //
        // No AGP capability was found
        //
        RIP(("ApFindAgpCapability - Does have an AGP Capability entry, not an AGP device"));
        return(STATUS_NOT_IMPLEMENTED);
    }

    *pOffset = CapabilityOffset;
    return(STATUS_SUCCESS);
}


NTSTATUS
AgpLibGetAgpCapability(
    IN PAGP_GETSET_CONFIG_SPACE pConfigFn,
    IN PVOID Context,
    OUT PPCI_AGP_CAPABILITY Capability
    )
/*++

Routine Description:

    This routine finds and retrieves the AGP capabilities in the
    PCI config space of the AGP master (graphics card).

Arguments:

    pConfigFn - Supplies the function to call for accessing config space
        on the appropriate device.

    Context - Supplies the context to pass to pConfigFn

    Capabilities - Returns the current AGP Capabilities

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS Status;
    UCHAR CapabilityOffset;

    Status = ApFindAgpCapability(pConfigFn,
                                 Context,
                                 Capability,
                                 &CapabilityOffset);
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    //
    // Read the rest of the AGP capability
    //
    Status = (pConfigFn)(Context,
                         TRUE,
                         &Capability->Header + 1,
                         CapabilityOffset + sizeof(PCI_CAPABILITIES_HEADER),
                         sizeof(PCI_AGP_CAPABILITY) - sizeof(PCI_CAPABILITIES_HEADER));
    if (!NT_SUCCESS(Status)) {
        RIP(("AgpLibGetAgpCapability - read AGP Capability at offset %xfailed %08lx",
            CapabilityOffset,
            Status));

        return(Status);
    }

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpLibGetMasterCapability(
    OUT PPCI_AGP_CAPABILITY Capability
    )
/*++

Routine Description:

    Retrieves the AGP capability for the AGP master (graphics card)

Arguments:

    AgpExtension - Supplies the AGP extension

    Capability - Returns the AGP capability

Return Value:

    NTSTATUS

--*/

{
    return(AgpLibGetAgpCapability(ApGetSetDeviceBusData,
                                  NULL,
                                  Capability));
}


NTSTATUS
AgpLibGetPciDeviceCapability(
    IN ULONG BusId,
    IN ULONG SlotId,
    OUT PPCI_AGP_CAPABILITY Capability
    )
/*++

Routine Description:

    Retrieves the AGP capability for the specified PCI slot.

    Caller is responsible for figuring out what the correct
    Bus/Slot ID is. These are just passed right to HalGetBusData.

Arguments:

    BusId - supplies the bus id

    SlotId - Supplies the slot id

    Capability - Returns the AGP capability

Return Value:

    NTSTATUS

--*/

{
    BUS_SLOT_ID BusSlotId;

    BusSlotId.BusId = BusId;
    BusSlotId.SlotId = SlotId;

    return(AgpLibGetAgpCapability(ApGetSetBusData,
                                  &BusSlotId,
                                  Capability));
}


NTSTATUS
AgpLibSetAgpCapability(
    IN PAGP_GETSET_CONFIG_SPACE pConfigFn,
    IN PVOID Context,
    OUT PPCI_AGP_CAPABILITY Capability
    )
/*++

Routine Description:

    This routine finds and retrieves the AGP capabilities in the
    PCI config space of the AGP master (graphics card).

Arguments:

    pConfigFn - Supplies the function to call for accessing config space
        on the appropriate device.

    Context - Supplies the context to pass to pConfigFn

    Capabilities - Returns the current AGP Capabilities

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS Status;
    UCHAR CapabilityOffset;

    Status = ApFindAgpCapability(pConfigFn,
                                 Context,
                                 Capability,
                                 &CapabilityOffset);
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    //
    // Now that we know the offset, write the supplied command register
    //
    Status = (pConfigFn)(Context,
                         FALSE,
                         &Capability->AGPCommand,
                         CapabilityOffset + FIELD_OFFSET(PCI_AGP_CAPABILITY, AGPCommand),
                         sizeof(Capability->AGPCommand));
    if (!NT_SUCCESS(Status)) {
        RIP(("AgpLibSetAgpCapability - Set AGP command at offset %x failed %08lx",
            CapabilityOffset,
            Status));
        return(Status);
    }

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpLibSetMasterCapability(
    OUT PPCI_AGP_CAPABILITY Capability
    )
/*++

Routine Description:

    Sets the AGP capability for the AGP master (graphics card)

Arguments:

    AgpExtension - Supplies the AGP extension

    Capability - Returns the AGP capability

Return Value:

    NTSTATUS

--*/

{
    return(AgpLibSetAgpCapability(ApGetSetDeviceBusData,
                                  NULL,
                                  Capability));
}


NTSTATUS
AgpLibSetPciDeviceCapability(
    IN ULONG BusId,
    IN ULONG SlotId,
    OUT PPCI_AGP_CAPABILITY Capability
    )
/*++

Routine Description:

    Sets the AGP capability for the specified PCI slot.

    Caller is responsible for figuring out what the correct
    Bus/Slot ID is. These are just passed right to HalSetBusData.

Arguments:

    BusId - supplies the bus id

    SlotId - Supplies the slot id

    Capability - Returns the AGP capability

Return Value:

    NTSTATUS

--*/

{
    BUS_SLOT_ID BusSlotId;

    BusSlotId.BusId = BusId;
    BusSlotId.SlotId = SlotId;

    return(AgpLibSetAgpCapability(ApGetSetBusData,
                                  &BusSlotId,
                                  Capability));
}


NTSTATUS
AgpEnable()
/*++

Routine Description:

    Enable AGP for both the system and the video card.

Arguments:

    None.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS Status;
    PCI_AGP_CAPABILITY MasterCap;
    PCI_AGP_CAPABILITY TargetCap;
    ULONG DataRate;

#if DBG
    PCI_AGP_CAPABILITY CurrentCap;
#endif

    //
    // Get the master and target AGP capabilities
    //
    Status = AgpLibGetMasterCapability(&MasterCap);
    if (!NT_SUCCESS(Status)) {
        RIP(("AgpVerifyCapabilities - AgpLibGetMasterCapability failed %08lx", Status));
        return Status;
    }

    //
    // Some broken cards (Matrox Millenium II "AGP") report no valid
    // supported transfer rates. These are not really AGP cards. They
    // have an AGP Capabilities structure that reports no capabilities.
    //
    if (MasterCap.AGPStatus.Rate == 0) {
        RIP(("AgpVerifyCapabilities - AgpLibGetMasterCapability returned no valid transfer rate"));
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    Status = AgpLibGetPciDeviceCapability(0,0,&TargetCap);
    if (!NT_SUCCESS(Status)) {
        RIP(("AgpVerifyCapabilities   - AgpLibGetPciDeviceCapability failed %08lx", Status));
        return Status;
    }

    //
    // Check the data rate.
    //
    DataRate = TargetCap.AGPStatus.Rate & MasterCap.AGPStatus.Rate;

    if (!(DataRate & PCI_AGP_RATE_4X))
    {
        RIP(("AgpVerifyCapabilities   - Mainboard/graphic card does not support 4x AGP."));
    }

    // 
    // The current graphics card does not support sideband addressing.  Note if 
    // this changes.
    //
    if (TargetCap.AGPStatus.SideBandAddressing & MasterCap.AGPStatus.SideBandAddressing)
    {
        RIP(("AgpVerifyCapabilities   - Sideband addressing is now available."));
    }

    // 
    // The current mainboard does not support fast write.  Note if this changes.
    //

    if (TargetCap.AGPStatus.FastWrite & MasterCap.AGPStatus.FastWrite)
    {
        RIP(("AgpVerifyCapabilities   - Fast write is now available."));
    }

    //
    // Enable the Target first.
    //
    TargetCap.AGPCommand.Rate = PCI_AGP_RATE_4X;
    TargetCap.AGPCommand.AGPEnable = 1;
    TargetCap.AGPCommand.SBAEnable = 0;
    TargetCap.AGPCommand.FastWriteEnable = 0;
    TargetCap.AGPCommand.FourGBEnable = 0;  
    Status = AgpLibSetPciDeviceCapability(0, 0, &TargetCap);

    if (!NT_SUCCESS(Status)) {
        RIP(("InitializeAGPUMA - AgpLibSetPciDeviceCapability %08lx for target failed %08lx",
                &TargetCap,
                Status));
        return Status;
    }

    //
    // Now enable the Master
    //
    MasterCap.AGPCommand.Rate = PCI_AGP_RATE_4X;
    MasterCap.AGPCommand.AGPEnable = 1;
    MasterCap.AGPCommand.SBAEnable = 0;
    MasterCap.AGPCommand.FastWriteEnable = 0;
    MasterCap.AGPCommand.FourGBEnable = 0;  
    MasterCap.AGPCommand.RequestQueueDepth = TargetCap.AGPStatus.RequestQueueDepthMaximum;
    Status = AgpLibSetMasterCapability(&MasterCap);
    if (!NT_SUCCESS(Status)) {
        RIP(("InitializeAGPUMA - AgpLibSetMasterCapability %08lx failed %08lx",
                &MasterCap,
                Status));
        return Status;
    }

#if DBG

    //
    // Read them back, see if it worked
    //
    Status = AgpLibGetMasterCapability(&CurrentCap);
    ASSERT(NT_SUCCESS(Status));

    //
    // If the target request queue depth is greater than the master will
    // allow, it will be trimmed.   Loosen the assert to not require an
    // exact match.
    //
    ASSERT(CurrentCap.AGPCommand.RequestQueueDepth <= MasterCap.AGPCommand.RequestQueueDepth);
    CurrentCap.AGPCommand.RequestQueueDepth = MasterCap.AGPCommand.RequestQueueDepth;
    ASSERT(RtlEqualMemory(&CurrentCap.AGPCommand, &MasterCap.AGPCommand, sizeof(CurrentCap.AGPCommand)));

    Status = AgpLibGetPciDeviceCapability(0,0,&CurrentCap);
    ASSERT(NT_SUCCESS(Status));
    ASSERT(RtlEqualMemory(&CurrentCap.AGPCommand, &TargetCap.AGPCommand, sizeof(CurrentCap.AGPCommand)));

#endif

    return STATUS_SUCCESS;
}

//============================================================================
// GART code
//============================================================================


NTSTATUS
AgpCreateAndEnableGART()
/*++

Routine Description:

    Create a GART large enough to hold all of physical memory, map
    the memory and enable it.

Arguments:

    None.

Return Value:

    NTSTATUS

--*/
{

    ULONG GartLength;
    PGART_PTE Gart;
    ULONG_PTR GartPhysical;
    PACCFG PACConfig;
    AGPCTRL AgpCtrl;
    ULONG i;

#if DBG

    ULONG ApBase;
    UCHAR ApSize;

#endif DBG

#if DBG

    //
    // Verity the current APBASE and APSIZE settings
    //

    Read440Config(&ApBase, APBASE_OFFSET, sizeof(ApBase));
    Read440Config(&ApSize, APSIZE_OFFSET, sizeof(ApSize));

    if (ApSize != AP_SIZE_64MB)
    {
        RIP(("AgpCreateAndEnableGART - Bad aperture size."));
    }

    if ((ApBase & PCI_ADDRESS_MEMORY_ADDRESS_MASK) != AGP_APERTURE_BASE)
    {
        RIP(("AgpCreateAndEnableGART - Bad Aperature base."));
    }

#endif DBG

    //
    // Try and get a chunk of contiguous memory big enough to map the
    // entire aperture.
    //
    GartLength = BYTES_TO_PAGES(AGP_APERTURE_BYTES) * sizeof(GART_PTE);

    Gart = MmAllocateContiguousMemorySpecifyCache(GartLength, 0, MAXULONG_PTR, 0, MmNonCached);
    if (Gart == NULL) {
        RIP(("Agp440CreateGart - MmAllocateContiguousMemory %lx failed\n",
            GartLength));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // We successfully allocated a contiguous chunk of memory.
    // It should be page aligned already.
    //
    ASSERT(((ULONG_PTR)Gart & (PAGE_SIZE-1)) == 0);

    //
    // Get the physical address.
    //
    GartPhysical = MmGetPhysicalAddress(Gart);

    //
    // Initialize all the PTEs
    //
    for (i = 0; i < GartLength/sizeof(GART_PTE); i++) {
        Gart[i].Hard.Valid = 1;
        Gart[i].Hard.Page = i;
    }

    //
    // Update the configuration
    //
    Write440Config(&GartPhysical, ATTBASE_OFFSET, sizeof(GartPhysical));

    // 
    // Enable the GTLB
    //
    Read440Config(&AgpCtrl, AGPCTRL_OFFSET, sizeof(AgpCtrl));
    AgpCtrl.GTLB_Enable = 1;
    Write440Config(&AgpCtrl, AGPCTRL_OFFSET, sizeof(AgpCtrl));

    //
    // Enable the GART arpeture.
    //
    Read440Config(&PACConfig, PACCFG_OFFSET, sizeof(PACConfig));
    PACConfig.GlobalEnable = 1;
    Write440Config(&PACConfig, PACCFG_OFFSET, sizeof(PACConfig));

    return STATUS_SUCCESS;
}

//============================================================================
// Main entrypoint
//============================================================================


BOOLEAN
AgpUmaEnable()

/*++

Routine Description:

    Entrypoint for master initialization. This is called after target initialization
    and should be used to initialize the AGP capabilities of both master and target.

    This is also called when the master transitions into the D0 state.

Return Value:

    S_OK

--*/

{
    NTSTATUS Status;

    if (!s_fInitialized)
    {
        //
        // Enable the devices.
        //
        Status = AgpEnable();
        if (!NT_SUCCESS(Status)) {
            return FALSE;
        }

        Status = AgpCreateAndEnableGART();
        if (!NT_SUCCESS(Status)) {
            return FALSE;
        }
    }

    s_fInitialized = TRUE;

    return TRUE;
}

#endif 1
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\portx\gart.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    gart.c

Abstract:

    Routines for querying and setting the Intel 440xx GART aperture

Author:

    John Vert (jvert) 10/30/1997

Revision History:

--*/

#include "videoprt.h"

#if 0 // NUGOOP

//
// Local function prototypes
//
NTSTATUS
Agp440CreateGart(
    IN PAGP440_EXTENSION AgpContext,
    IN ULONG MinimumPages
    );

PGART_PTE
Agp440FindRangeInGart(
    IN PGART_PTE StartPte,
    IN PGART_PTE EndPte,
    IN ULONG Length,
    IN BOOLEAN SearchBackward,
    IN ULONG SearchState
    );

VOID
Agp440SetGTLB_Enable(
    IN PAGP440_EXTENSION AgpContext,
    IN BOOLEAN Enable
    );

#define Agp440EnableTB(_x_) Agp440SetGTLB_Enable((_x_), TRUE)
#define Agp440DisableTB(_x_) Agp440SetGTLB_Enable((_x_), FALSE)


NTSTATUS
AgpQueryAperture(
    IN PAGP440_EXTENSION AgpContext,
    OUT PHYSICAL_ADDRESS *CurrentBase,
    OUT ULONG *CurrentSizeInPages,
    OUT OPTIONAL PIO_RESOURCE_LIST *pApertureRequirements
    )
/*++

Routine Description:

    Queries the current size of the GART aperture. Optionally returns
    the possible GART settings.

Arguments:

    AgpContext - Supplies the AGP context.

    CurrentBase - Returns the current physical address of the GART.

    CurrentSizeInPages - Returns the current GART size.

    ApertureRequirements - if present, returns the possible GART settings

Return Value:

    NTSTATUS

--*/

{
    ULONG ApBase;
    UCHAR ApSize;
    PIO_RESOURCE_LIST Requirements;
    ULONG i;
    ULONG Length;

    PAGED_CODE();
    //
    // Get the current APBASE and APSIZE settings
    //
    Read440Config(&ApBase, APBASE_OFFSET, sizeof(ApBase));
    Read440Config(&ApSize, APSIZE_OFFSET, sizeof(ApSize));

    ASSERT(ApBase != 0);
    CurrentBase->QuadPart = ApBase & PCI_ADDRESS_MEMORY_ADDRESS_MASK;

    //
    // Convert APSIZE into the actual size of the aperture
    //
    switch (ApSize) {
        case AP_SIZE_4MB:
            *CurrentSizeInPages = 4 * (1024*1024 / PAGE_SIZE);
            break;
        case AP_SIZE_8MB:
            *CurrentSizeInPages = 8 * (1024*1024 / PAGE_SIZE);
            break;
        case AP_SIZE_16MB:
            *CurrentSizeInPages = 16 * (1024*1024 / PAGE_SIZE);
            break;
        case AP_SIZE_32MB:
            *CurrentSizeInPages = 32 * (1024*1024 / PAGE_SIZE);
            break;
        case AP_SIZE_64MB:
            *CurrentSizeInPages = 64 * (1024*1024 / PAGE_SIZE);
            break;
        case AP_SIZE_128MB:
            *CurrentSizeInPages = 128 * (1024*1024 / PAGE_SIZE);
            break;
        case AP_SIZE_256MB:
            *CurrentSizeInPages = 256 * (1024*1024 / PAGE_SIZE);
            break;

        default:
            AGPLOG(AGP_CRITICAL,
                   ("AGP440 - AgpQueryAperture - Unexpected value %x for ApSize!\n",
                    ApSize));
            ASSERT(FALSE);
            AgpContext->ApertureStart.QuadPart = 0;
            AgpContext->ApertureLength = 0;
            return(STATUS_UNSUCCESSFUL);
    }

    //
    // Remember the current aperture settings
    //
    AgpContext->ApertureStart.QuadPart = CurrentBase->QuadPart;
    AgpContext->ApertureLength = *CurrentSizeInPages * PAGE_SIZE;

    if (pApertureRequirements != NULL) {
        //
        // 440 supports 7 different aperture sizes, all must be 
        // naturally aligned. Start with the largest aperture and 
        // work downwards so that we get the biggest possible aperture.
        //
        Requirements = ExAllocatePoolWithTag(PagedPool,
                                             sizeof(IO_RESOURCE_LIST) + (AP_SIZE_COUNT-1)*sizeof(IO_RESOURCE_DESCRIPTOR),
                                             'RpgA');
        if (Requirements == NULL) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
        Requirements->Version = Requirements->Revision = 1;
        Requirements->Count = AP_SIZE_COUNT;
        Length = AP_MAX_SIZE;
        for (i=0; i<AP_SIZE_COUNT; i++) {
            Requirements->Descriptors[i].Option = IO_RESOURCE_ALTERNATIVE;
            Requirements->Descriptors[i].Type = CmResourceTypeMemory;
            Requirements->Descriptors[i].ShareDisposition = CmResourceShareDeviceExclusive;
            Requirements->Descriptors[i].Flags = CM_RESOURCE_MEMORY_READ_WRITE | CM_RESOURCE_MEMORY_PREFETCHABLE;

            Requirements->Descriptors[i].u.Memory.Length = Length;
            Requirements->Descriptors[i].u.Memory.Alignment = Length;
            Requirements->Descriptors[i].u.Memory.MinimumAddress.QuadPart = 0;
            Requirements->Descriptors[i].u.Memory.MaximumAddress.QuadPart = (ULONG)-1;

            Length = Length/2;
        }
        *pApertureRequirements = Requirements;


    }
    return(STATUS_SUCCESS);
}


NTSTATUS
AgpSetAperture(
    IN PAGP440_EXTENSION AgpContext,
    IN PHYSICAL_ADDRESS NewBase,
    IN ULONG NewSizeInPages
    )
/*++

Routine Description:

    Sets the GART aperture to the supplied settings

Arguments:

    AgpContext - Supplies the AGP context

    NewBase - Supplies the new physical memory base for the GART.

    NewSizeInPages - Supplies the new size for the GART

Return Value:

    NTSTATUS

--*/

{
    PACCFG PACConfig;
    UCHAR ApSize;
    ULONG ApBase;

    //
    // Figure out the new APSIZE setting, make sure it is valid.
    //
    switch (NewSizeInPages) {
        case 4 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_4MB;
            break;
        case 8 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_8MB;
            break;
        case 16 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_16MB;
            break;
        case 32 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_32MB;
            break;
        case 64 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_64MB;
            break;
        case 128 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_128MB;
            break;
        case 256 * 1024 * 1024 / PAGE_SIZE:
            ApSize = AP_SIZE_256MB;
            break;
        default:
            AGPLOG(AGP_CRITICAL,
                   ("AgpSetAperture - invalid GART size of %lx pages specified, aperture at %I64X.\n",
                    NewSizeInPages,
                    NewBase.QuadPart));
            ASSERT(FALSE);
            return(STATUS_INVALID_PARAMETER);
    }

    //
    // Make sure the supplied size is aligned on the appropriate boundary.
    //
    ASSERT(NewBase.HighPart == 0);
    ASSERT((NewBase.QuadPart & ((NewSizeInPages * PAGE_SIZE) - 1)) == 0);
    if ((NewBase.QuadPart & ((NewSizeInPages * PAGE_SIZE) - 1)) != 0 ) {
        AGPLOG(AGP_CRITICAL,
               ("AgpSetAperture - invalid base %I64X specified for GART aperture of %lx pages\n",
               NewBase.QuadPart,
               NewSizeInPages));
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Need to reset the hardware to match the supplied settings
    //
    // If the aperture is enabled, disable it, write the new settings, then reenable the aperture
    //
    Read440Config(&PACConfig, PACCFG_OFFSET, sizeof(PACConfig));
    PACConfig.GlobalEnable = 0;
    Write440Config(&PACConfig, PACCFG_OFFSET, sizeof(PACConfig));

    //
    // Write APSIZE first, as this will enable the correct bits in APBASE that need to
    // be written next.
    //
    Write440Config(&ApSize, APSIZE_OFFSET, sizeof(ApSize));

    //
    // Now we can update APBASE
    //
    ApBase = NewBase.LowPart & PCI_ADDRESS_MEMORY_ADDRESS_MASK;
    Write440Config(&ApBase, APBASE_OFFSET, sizeof(ApBase));

#if DBG
    //
    // Read back what we wrote, make sure it worked
    //
    {
        ULONG DbgBase;
        UCHAR DbgSize;

        Read440Config(&DbgSize, APSIZE_OFFSET, sizeof(ApSize));
        Read440Config(&DbgBase, APBASE_OFFSET, sizeof(ApBase));
        ASSERT(DbgSize == ApSize);
        ASSERT((DbgBase & PCI_ADDRESS_MEMORY_ADDRESS_MASK) == ApBase);
    }
#endif

    //
    // Now enable the aperture if it was enabled before
    //
    if (AgpContext->GlobalEnable) {
        Read440Config(&PACConfig, PACCFG_OFFSET, sizeof(PACConfig));
        ASSERT(PACConfig.GlobalEnable == 0);
        PACConfig.GlobalEnable = 1;
        Write440Config(&PACConfig, PACCFG_OFFSET, sizeof(PACConfig));
    }

    //
    // Update our extension to reflect the new GART setting
    //
    AgpContext->ApertureStart = NewBase;
    AgpContext->ApertureLength = NewSizeInPages * PAGE_SIZE;

    //
    // Enable the TB in case we are resuming from S3 or S4
    //
    Agp440EnableTB(AgpContext);

    //
    // If the GART has been allocated, rewrite the ATTBASE
    //
    if (AgpContext->Gart != NULL) {
        Write440Config(&AgpContext->GartPhysical.LowPart,
                       ATTBASE_OFFSET,
                       sizeof(AgpContext->GartPhysical.LowPart));
    }

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpReserveMemory(
    IN PAGP440_EXTENSION AgpContext,
    IN OUT AGP_RANGE *Range
    )
/*++

Routine Description:

    Reserves a range of memory in the GART.

Arguments:

    AgpContext - Supplies the AGP Context

    Range - Supplies the AGP_RANGE structure. AGPLIB
        will have filled in NumberOfPages and Type. This
        routine will fill in MemoryBase and Context.

Return Value:

    NTSTATUS

--*/

{
    ULONG Index;
    ULONG NewState;
    NTSTATUS Status;
    PGART_PTE FoundRange;
    BOOLEAN Backwards;

    PAGED_CODE();

    ASSERT((Range->Type == MmNonCached) || (Range->Type == MmWriteCombined));
    ASSERT(Range->NumberOfPages <= (AgpContext->ApertureLength / PAGE_SIZE));

    //
    // If we have not allocated our GART yet, now is the time to do so
    //
    if (AgpContext->Gart == NULL) {
        ASSERT(AgpContext->GartLength == 0);
        Status = Agp440CreateGart(AgpContext,Range->NumberOfPages);
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("Agp440CreateGart failed %08lx to create GART of size %lx\n",
                    Status,
                    AgpContext->ApertureLength));
            return(Status);
        }
    }
    ASSERT(AgpContext->GartLength != 0);

    //
    // Now that we have a GART, try and find enough contiguous entries to satisfy
    // the request. Requests for uncached memory will scan from high addresses to
    // low addresses. Requests for write-combined memory will scan from low addresses
    // to high addresses. We will use a first-fit algorithm to try and keep the allocations
    // packed and contiguous.
    //
    Backwards = (BOOLEAN)((Range->Type == MmNonCached) ? TRUE : FALSE);
    FoundRange = Agp440FindRangeInGart(&AgpContext->Gart[0],
                                       &AgpContext->Gart[(AgpContext->GartLength / sizeof(GART_PTE)) - 1],
                                       Range->NumberOfPages,
                                       Backwards,
                                       GART_ENTRY_FREE);

    if (FoundRange == NULL) {
        //
        // A big enough chunk was not found.
        //
        AGPLOG(AGP_CRITICAL,
               ("AgpReserveMemory - Could not find %d contiguous free pages of type %d in GART at %08lx\n",
                Range->NumberOfPages,
                Range->Type,
                AgpContext->Gart));

// @@BEGIN_DDKSPLIT
        //
        // BUGBUG John Vert (jvert) 11/4/1997
        //  This is the point where we should try and grow the GART
        //
// @@END_DDKSPLIT

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    AGPLOG(AGP_NOISE,
           ("AgpReserveMemory - reserved %d pages at GART PTE %08lx\n",
            Range->NumberOfPages,
            FoundRange));

    //
    // Set these pages to reserved
    //
    if (Range->Type == MmNonCached) {
        NewState = GART_ENTRY_RESERVED_UC;
    } else {
        NewState = GART_ENTRY_RESERVED_WC;
    }

    for (Index = 0;Index < Range->NumberOfPages; Index++) {
        ASSERT(FoundRange[Index].Soft.State == GART_ENTRY_FREE);
        FoundRange[Index].AsUlong = 0;
        FoundRange[Index].Soft.State = NewState;
    }

    Range->MemoryBase.QuadPart = AgpContext->ApertureStart.QuadPart + (FoundRange - &AgpContext->Gart[0]) * PAGE_SIZE;
    Range->Context = FoundRange;

    ASSERT(Range->MemoryBase.HighPart == 0);
    AGPLOG(AGP_NOISE,
           ("AgpReserveMemory - reserved memory handle %lx at PA %08lx\n",
            FoundRange,
            Range->MemoryBase.LowPart));

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpReleaseMemory(
    IN PAGP440_EXTENSION AgpContext,
    IN PAGP_RANGE Range
    )
/*++

Routine Description:

    Releases memory previously reserved with AgpReserveMemory

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the range to be released.

Return Value:

    NTSTATUS

--*/

{
    PGART_PTE Pte;

    PAGED_CODE();

    //
    // Go through and free all the PTEs. None of these should still
    // be valid at this point.
    //
    for (Pte = Range->Context;
         Pte < (PGART_PTE)Range->Context + Range->NumberOfPages;
         Pte++) {
        if (Range->Type == MmNonCached) {
            ASSERT(Pte->Soft.State == GART_ENTRY_RESERVED_UC);
        } else {
            ASSERT(Pte->Soft.State == GART_ENTRY_RESERVED_WC);
        }
        Pte->Soft.State = GART_ENTRY_FREE;
    }

    Range->MemoryBase.QuadPart = 0;
    return(STATUS_SUCCESS);
}


NTSTATUS
Agp440CreateGart(
    IN PAGP440_EXTENSION AgpContext,
    IN ULONG MinimumPages
    )
/*++

Routine Description:

    Allocates and initializes an empty GART. The current implementation
    attempts to allocate the entire GART on the first reserve.

Arguments:

    AgpContext - Supplies the AGP context

    MinimumPages - Supplies the minimum size (in pages) of the GART to be
        created.

Return Value:

    NTSTATUS

--*/

{
    PGART_PTE GartCached;
    PGART_PTE Gart;
    ULONG GartLength;
    PHYSICAL_ADDRESS HighestAcceptable;
    PHYSICAL_ADDRESS GartPhysical;
    ULONG i;

    PAGED_CODE();

    //
    // Try and get a chunk of contiguous memory big enough to map the
    // entire aperture.
    //
    GartLength = BYTES_TO_PAGES(AgpContext->ApertureLength) * sizeof(GART_PTE);

// @@BEGIN_DDKSPLIT
    //
    // BUGBUG John Vert (jvert) 11/5/1997
    //   This is a crock. We really need to use AllocateCommonBuffer here to
    //   get a non-cached contiguous range. Unfortunately, AllocateCommonBuffer
    //   does not actually allocate the memory non-cached. Until this is fixed,
    //   we have this hack-o-rama:
    //      MmAllocateContiguousMemory
    //      MmGetPhysicalAddress
    //      MmMapIoSpace
    //
// @@END_DDKSPLIT

    GartCached = MmAllocateContiguousMemory(GartLength);
    if (GartCached == NULL) {
        AGPLOG(AGP_CRITICAL,
               ("Agp440CreateGart - MmAllocateContiguousMemory %lx failed\n",
                GartLength));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    //
    // We successfully allocated a contiguous chunk of memory.
    // It should be page aligned already.
    //
    ASSERT(((ULONG_PTR)GartCached & (PAGE_SIZE-1)) == 0);

    //
    // Get the physical address.
    //
    GartPhysical.QuadPart = MmGetPhysicalAddress(GartCached);
    AGPLOG(AGP_NOISE,
           ("Agp440CreateGart - GART of length %lx created at VA %08lx, PA %08lx\n",
            GartLength,
            GartCached,
            GartPhysical.LowPart));
    ASSERT(GartPhysical.HighPart == 0);
    ASSERT((GartPhysical.LowPart & (PAGE_SIZE-1)) == 0);

    //
    // Now we need to map this again to get a noncached pointer
    //
    Gart = MmMapIoSpace(GartPhysical.LowPart,
                        GartLength,
                        MmNonCached);
    if (Gart == NULL) {
        AGPLOG(AGP_CRITICAL,
               ("Agp440CreateGart - couldn't map GART at %08lx non-cached\n",
                GartCached));
    }

    //
    // Initialize all the PTEs to free
    //
    for (i=0; i<GartLength/sizeof(GART_PTE); i++) {
        Gart[i].Soft.State = GART_ENTRY_FREE;
    }


    Write440Config(&GartPhysical.LowPart, ATTBASE_OFFSET, sizeof(GartPhysical.LowPart));

    //
    // Update our extension to reflect the current state.
    //
    AgpContext->GartCached = GartCached;
    AgpContext->Gart = Gart;
    AgpContext->GartLength = GartLength;
    AgpContext->GartPhysical = GartPhysical;

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpMapMemory(
    IN PAGP440_EXTENSION AgpContext,
    IN PAGP_RANGE Range,
    IN PMDL Mdl,
    IN ULONG OffsetInPages,
    OUT PHYSICAL_ADDRESS *MemoryBase
    )
/*++

Routine Description:

    Maps physical memory into the GART somewhere in the specified range.

Arguments:

    AgpContext - Supplies the AGP context

    Range - Supplies the AGP range that the memory should be mapped into

    Mdl - Supplies the MDL describing the physical pages to be mapped

    OffsetInPages - Supplies the offset into the reserved range where the 
        mapping should begin.

    MemoryBase - Returns the physical memory in the aperture where the pages
        were mapped.

Return Value:

    NTSTATUS

--*/

{
    ULONG PageCount;
    PGART_PTE Pte;
    PGART_PTE StartPte;
    ULONG Index;
    ULONG TargetState;
    PPFN_NUMBER Page;
    GART_PTE NewPte;
    PACCFG PACConfig;

    PAGED_CODE();

    ASSERT(Mdl->Next == NULL);

    StartPte = Range->Context;
    PageCount = BYTES_TO_PAGES(Mdl->ByteCount);
    ASSERT(PageCount <= Range->NumberOfPages);
    ASSERT(OffsetInPages <= Range->NumberOfPages);
    ASSERT(PageCount + OffsetInPages <= Range->NumberOfPages);
    ASSERT(PageCount > 0);

    TargetState = (Range->Type == MmNonCached) ? GART_ENTRY_RESERVED_UC : GART_ENTRY_RESERVED_WC;

    Pte = StartPte + OffsetInPages;

    //
    // We have a suitable range, now fill it in with the supplied MDL.
    //
    ASSERT(Pte >= StartPte);
    ASSERT(Pte + PageCount <= StartPte + Range->NumberOfPages);
    NewPte.AsUlong = 0;
    NewPte.Soft.State = (Range->Type == MmNonCached) ? GART_ENTRY_VALID_UC :
                                                       GART_ENTRY_VALID_WC;
    Page = (PPFN_NUMBER)(Mdl + 1);

    //
    // Disable the TB as per the 440 spec. This is probably unnecessary
    // as there should be no valid entries in this range, and there should
    // be no invalid entries still in the TB. So flushing the TB seems
    // a little gratuitous but that's what the 440 spec says to do.
    //
    Agp440DisableTB(AgpContext);

    for (Index = 0; Index < PageCount; Index++) {
        ASSERT(Pte[Index].Soft.State == TargetState);

        NewPte.Hard.Page = (ULONG)(*Page++);
        Pte[Index].AsUlong = NewPte.AsUlong;
        ASSERT(Pte[Index].Hard.Valid == 1);
    }

    //
    // We have filled in all the PTEs. Read back the last one we wrote
    // in order to flush the write buffers.
    //
    NewPte.AsUlong = *(volatile ULONG *)&Pte[PageCount-1].AsUlong;

    //
    // Re-enable the TB
    //
    Agp440EnableTB(AgpContext);

    //
    // If we have not yet gotten around to enabling the GART aperture, do it now.
    //
    if (!AgpContext->GlobalEnable) {
        AGPLOG(AGP_NOISE,
               ("AgpMapMemory - Enabling global aperture access\n"));

        Read440Config(&PACConfig, PACCFG_OFFSET, sizeof(PACConfig));
        PACConfig.GlobalEnable = 1;
        Write440Config(&PACConfig, PACCFG_OFFSET, sizeof(PACConfig));

        AgpContext->GlobalEnable = TRUE;
    }

    MemoryBase->QuadPart = Range->MemoryBase.QuadPart + (Pte - StartPte) * PAGE_SIZE;

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpUnMapMemory(
    IN PAGP440_EXTENSION AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages
    )
/*++

Routine Description:

    Unmaps previously mapped memory in the GART.

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the AGP range that the memory should be freed from

    NumberOfPages - Supplies the number of pages in the range to be freed.

    OffsetInPages - Supplies the offset into the range where the freeing should begin.

Return Value:

    NTSTATUS

--*/

{
    ULONG i;
    PGART_PTE Pte;
    PGART_PTE LastChanged=NULL;
    PGART_PTE StartPte;
    ULONG NewState;

    PAGED_CODE();

    ASSERT(OffsetInPages + NumberOfPages <= AgpRange->NumberOfPages);

    StartPte = AgpRange->Context;
    Pte = &StartPte[OffsetInPages];

    if (AgpRange->Type == MmNonCached) {
        NewState = GART_ENTRY_RESERVED_UC;
    } else {
        NewState = GART_ENTRY_RESERVED_WC;
    }

    //
    // Disable the TB to flush it
    //
    Agp440DisableTB(AgpContext);
    for (i=0; i<NumberOfPages; i++) {
        if (Pte[i].Hard.Valid) {
            Pte[i].Soft.State = NewState;
            LastChanged = Pte;
        } else {
            //
            // This page is not mapped, just skip it.
            //
            AGPLOG(AGP_NOISE,
                   ("AgpUnMapMemory - PTE %08lx (%08lx) at offset %d not mapped\n",
                    &Pte[i],
                    Pte[i].AsUlong,
                    i));
            ASSERT(Pte[i].Soft.State == NewState);
        }
    }

    //
    // We have invalidated all the PTEs. Read back the last one we wrote
    // in order to flush the write buffers.
    //
    if (LastChanged != NULL) {
        ULONG Temp;
        Temp = *(volatile ULONG *)(&LastChanged->AsUlong);
    }

    //
    // Reenable the TB
    //
    Agp440EnableTB(AgpContext);

    return(STATUS_SUCCESS);
}


PGART_PTE
Agp440FindRangeInGart(
    IN PGART_PTE StartPte,
    IN PGART_PTE EndPte,
    IN ULONG Length,
    IN BOOLEAN SearchBackward,
    IN ULONG SearchState
    )
/*++

Routine Description:

    Finds a contiguous range in the GART. This routine can
    search either from the beginning of the GART forwards or
    the end of the GART backwards.

Arguments:

    StartIndex - Supplies the first GART pte to search

    EndPte - Supplies the last GART to search (inclusive)

    Length - Supplies the number of contiguous free entries
        to search for.

    SearchBackward - TRUE indicates that the search should begin
        at EndPte and search backwards. FALSE indicates that the
        search should begin at StartPte and search forwards

    SearchState - Supplies the PTE state to look for.

Return Value:

    Pointer to the first PTE in the GART if a suitable range
    is found.

    NULL if no suitable range exists.

--*/

{
    PGART_PTE Current;
    PGART_PTE Last;
    LONG Delta;
    ULONG Found;

    PAGED_CODE();

    ASSERT(EndPte >= StartPte);
    ASSERT(Length <= (ULONG)(EndPte - StartPte + 1));
    ASSERT(Length != 0);

    if (SearchBackward) {
        Current = EndPte;
        Last = StartPte-1;
        Delta = -1;
    } else {
        Current = StartPte;
        Last = EndPte+1;
        Delta = 1;
    }

    Found = 0;
    while (Current != Last) {
        if (Current->Soft.State == SearchState) {
            if (++Found == Length) {
                //
                // A suitable range was found, return it
                //
                if (SearchBackward) {
                    return(Current);
                } else {
                    return(Current - Length + 1);
                }
            }
        } else {
            Found = 0;
        }
        Current += Delta;
    }

    //
    // A suitable range was not found.
    //
    return(NULL);
}


VOID
Agp440SetGTLB_Enable(
    IN PAGP440_EXTENSION AgpContext,
    IN BOOLEAN Enable
    )
/*++

Routine Description:

    Enables or disables the GTLB by setting or clearing the GTLB_Enable bit
    in the AGPCTRL register

Arguments:

    AgpContext - Supplies the AGP context

    Enable - TRUE, GTLB_Enable is set to 1
             FALSE, GTLB_Enable is set to 0

Return Value:

    None

--*/

{
    AGPCTRL AgpCtrl;

    Read440Config(&AgpCtrl, AGPCTRL_OFFSET, sizeof(AgpCtrl));

    if (Enable) {
        AgpCtrl.GTLB_Enable = 1;
    } else {
        AgpCtrl.GTLB_Enable = 0;
    }
    Write440Config(&AgpCtrl, AGPCTRL_OFFSET, sizeof(AgpCtrl));
}


VOID
AgpFindFreeRun(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT ULONG *FreePages,
    OUT ULONG *FreeOffset
    )
/*++

Routine Description:

    Finds the first contiguous run of free pages in the specified
    part of the reserved range.

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the AGP range

    NumberOfPages - Supplies the size of the region to be searched for free pages

    OffsetInPages - Supplies the start of the region to be searched for free pages

    FreePages - Returns the length of the first contiguous run of free pages

    FreeOffset - Returns the start of the first contiguous run of free pages

Return Value:

    None. FreePages == 0 if there are no free pages in the specified range.

--*/

{
    PGART_PTE Pte;
    ULONG i;
    
    Pte = (PGART_PTE)(AgpRange->Context) + OffsetInPages;

    //
    // Find the first free PTE
    //
    for (i=0; i<NumberOfPages; i++) {
        if (Pte[i].Hard.Valid == 0) {
            //
            // Found a free PTE, count the contiguous ones.
            //
            *FreeOffset = i + OffsetInPages;
            *FreePages = 0;
            while ((i<NumberOfPages) && (Pte[i].Hard.Valid == 0)) {
                *FreePages += 1;
                ++i;
            }
            return;
        }
    }

    //
    // No free PTEs in the specified range
    //
    *FreePages = 0;
    return;

}


VOID
AgpGetMappedPages(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT PMDL Mdl
    )
/*++

Routine Description:

    Returns the list of physical pages mapped into the specified 
    range in the GART.

Arguments:

    AgpContext - Supplies the AGP context

    AgpRange - Supplies the AGP range

    NumberOfPages - Supplies the number of pages to be returned

    OffsetInPages - Supplies the start of the region 

    Mdl - Returns the list of physical pages mapped in the specified range.

Return Value:

    None

--*/

{
    PGART_PTE Pte;
    ULONG i;
    PULONG Pages;

    ASSERT(NumberOfPages * PAGE_SIZE == Mdl->ByteCount);

    Pages = (PULONG)(Mdl + 1);
    Pte = (PGART_PTE)(AgpRange->Context) + OffsetInPages;

    for (i=0; i<NumberOfPages; i++) {
        ASSERT(Pte[i].Hard.Valid == 1);
        Pages[i] = Pte[i].Hard.Page;
    }
    return;
}

typedef struct _BUS_SLOT_ID {
    ULONG BusId;
    ULONG SlotId;
} BUS_SLOT_ID, *PBUS_SLOT_ID;

typedef
NTSTATUS
(*PAGP_GETSET_CONFIG_SPACE)(
    IN PVOID Context,
    IN BOOLEAN Read,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );


NTSTATUS
ApGetSetDeviceBusData(
    IN PVOID Context,
    IN BOOLEAN Read,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    Reads or writes PCI config space for the specified device.

Arguments:

    Read - if TRUE, this is a READ IRP
           if FALSE, this is a WRITE IRP

    Buffer - Returns the PCI config data

    Offset - Supplies the offset into the PCI config data where the read should begin

    Length - Supplies the number of bytes to be read

Return Value:

    NTSTATUS

--*/

{
    PCI_SLOT_NUMBER SlotNumber;
    ULONG Transferred;

    SlotNumber.u.AsULONG = 0;
    SlotNumber.u.bits.DeviceNumber = AGP440_TARGET_DEVICE_NUMBER;
    SlotNumber.u.bits.FunctionNumber = AGP440_TARGET_FUNCTION_NUMBER;

    if (Read) {
        Transferred = HalGetBusDataByOffset(PCIConfiguration,
                                            1,
                                            SlotNumber.u.AsULONG,
                                            Buffer,
                                            Offset,
                                            Length);
    } else {
        Transferred = HalSetBusDataByOffset(PCIConfiguration,
                                            1,
                                            SlotNumber.u.AsULONG,
                                            Buffer,
                                            Offset,
                                            Length);

    }

    if (Transferred == Length) {
        return(STATUS_SUCCESS);
    } else {
        return(STATUS_UNSUCCESSFUL);
    }
}


NTSTATUS
ApGetSetBusData(
    IN PBUS_SLOT_ID BusSlotId,
    IN BOOLEAN Read,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    Calls HalGet/SetBusData for the specified PCI bus/slot ID.

Arguments:

    BusSlotId - Supplies the bus and slot ID.

    Read - if TRUE, this is a GetBusData
           if FALSE, this is a SetBusData

    Buffer - Returns the PCI config data

    Offset - Supplies the offset into the PCI config data where the read should begin

    Length - Supplies the number of bytes to be read

Return Value:

    NTSTATUS

--*/

{
    ULONG Transferred;

    if (Read) {
        Transferred = HalGetBusDataByOffset(PCIConfiguration,
                                            BusSlotId->BusId,
                                            BusSlotId->SlotId,
                                            Buffer,
                                            Offset,
                                            Length);
    } else {
        Transferred = HalSetBusDataByOffset(PCIConfiguration,
                                            BusSlotId->BusId,
                                            BusSlotId->SlotId,
                                            Buffer,
                                            Offset,
                                            Length);

    }
    if (Transferred == Length) {
        return(STATUS_SUCCESS);
    } else {
        return(STATUS_UNSUCCESSFUL);
    }
}


NTSTATUS
ApFindAgpCapability(
    IN PAGP_GETSET_CONFIG_SPACE pConfigFn,
    IN PVOID Context,
    OUT PPCI_AGP_CAPABILITY Capability,
    OUT UCHAR *pOffset
    )
/*++

Routine Description:

    Finds the capability offset for the specified device and
    reads in the header.

Arguments:

    pConfigFn - Supplies the function to call for accessing config space
        on the appropriate device.

    Context - Supplies the context to pass to pConfigFn

    Capabilities - Returns the AGP Capabilities common header

    pOffset - Returns the offset into config space.

Return Value:

    NTSTATUS

--*/

{
    PCI_COMMON_HEADER Header;
    PPCI_COMMON_CONFIG PciConfig = (PPCI_COMMON_CONFIG)&Header;
    NTSTATUS Status;
    UCHAR CapabilityOffset;

    //
    // Read the PCI common header to get the capabilities pointer
    //
    Status = (pConfigFn)(Context,
                         TRUE,
                         PciConfig,
                         0,
                         sizeof(PCI_COMMON_HEADER));
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AgpLibGetAgpCapability - read PCI Config space for Context %08lx failed %08lx\n",
                Context,
                Status));
        return(Status);
    }

    //
    // Check the Status register to see if this device supports capability lists.
    // If not, it is not an AGP-compliant device.
    //
    if ((PciConfig->Status & PCI_STATUS_CAPABILITIES_LIST) == 0) {
        AGPLOG(AGP_CRITICAL,
               ("AgpLibGetAgpCapability - Context %08lx does not support Capabilities list, not an AGP device\n",
                Context));
        return(STATUS_NOT_IMPLEMENTED);
    }

    //
    // The device supports capability lists, find the AGP capabilities
    //
    if ((PciConfig->HeaderType & (~PCI_MULTIFUNCTION)) == PCI_BRIDGE_TYPE) {
        CapabilityOffset = PciConfig->u.type1.CapabilitiesPtr;
    } else {
        ASSERT((PciConfig->HeaderType & (~PCI_MULTIFUNCTION)) == PCI_DEVICE_TYPE);
        CapabilityOffset = PciConfig->u.type0.CapabilitiesPtr;
    }
    while (CapabilityOffset != 0) {

        //
        // Read the Capability at this offset
        //
        Status = (pConfigFn)(Context,
                             TRUE,
                             Capability,
                             CapabilityOffset,
                             sizeof(PCI_CAPABILITIES_HEADER));
        if (!NT_SUCCESS(Status)) {
            AGPLOG(AGP_CRITICAL,
                   ("AgpLibGetAgpCapability - read PCI Capability at offset %x for Context %08lx failed %08lx\n",
                    CapabilityOffset,
                    Context,
                    Status));
            return(Status);
        }
        if (Capability->Header.CapabilityID == PCI_CAPABILITY_ID_AGP) {
            //
            // Found the AGP Capability
            //
            break;
        } else {
            //
            // This is some other Capability, keep looking for the AGP Capability
            //
            CapabilityOffset = Capability->Header.Next;
        }
    }
    if (CapabilityOffset == 0) {
        //
        // No AGP capability was found
        //
        AGPLOG(AGP_CRITICAL,
               ("AgpLibGetAgpCapability - Context %08lx does have an AGP Capability entry, not an AGP device\n",
                Context));
        return(STATUS_NOT_IMPLEMENTED);
    }

    AGPLOG(AGP_NOISE,
           ("AgpLibGetAgpCapability - Context %08lx has AGP Capability at offset %x\n",
            Context,
            CapabilityOffset));

    *pOffset = CapabilityOffset;
    return(STATUS_SUCCESS);
}


NTSTATUS
AgpLibGetAgpCapability(
    IN PAGP_GETSET_CONFIG_SPACE pConfigFn,
    IN PVOID Context,
    OUT PPCI_AGP_CAPABILITY Capability
    )
/*++

Routine Description:

    This routine finds and retrieves the AGP capabilities in the
    PCI config space of the AGP master (graphics card).

Arguments:

    pConfigFn - Supplies the function to call for accessing config space
        on the appropriate device.

    Context - Supplies the context to pass to pConfigFn

    Capabilities - Returns the current AGP Capabilities

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS Status;
    UCHAR CapabilityOffset;

    Status = ApFindAgpCapability(pConfigFn,
                                 Context,
                                 Capability,
                                 &CapabilityOffset);
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    //
    // Read the rest of the AGP capability
    //
    Status = (pConfigFn)(Context,
                         TRUE,
                         &Capability->Header + 1,
                         CapabilityOffset + sizeof(PCI_CAPABILITIES_HEADER),
                         sizeof(PCI_AGP_CAPABILITY) - sizeof(PCI_CAPABILITIES_HEADER));
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AgpLibGetAgpCapability - read AGP Capability at offset %x for Context %08lx failed %08lx\n",
                CapabilityOffset,
                Context,
                Status));
        return(Status);
    }

    AGPLOG(AGP_NOISE,
           ("AGP CAPABILITY: version %d.%d\n",Capability->Major, Capability->Minor));
    AGPLOG(AGP_NOISE,
           ("\tSTATUS  - Rate: %x  SBA: %x  RQ: %02x\n",
           Capability->AGPStatus.Rate,
           Capability->AGPStatus.SideBandAddressing,
           Capability->AGPStatus.RequestQueueDepthMaximum));
    AGPLOG(AGP_NOISE,
           ("\tCOMMAND - Rate: %x  SBA: %x  RQ: %02x  AGPEnable: %x\n",
           Capability->AGPCommand.Rate,
           Capability->AGPCommand.SBAEnable,
           Capability->AGPCommand.RequestQueueDepth,
           Capability->AGPCommand.AGPEnable));

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpLibGetMasterCapability(
    IN PVOID AgpExtension,
    OUT PPCI_AGP_CAPABILITY Capability
    )
/*++

Routine Description:

    Retrieves the AGP capability for the AGP master (graphics card)

Arguments:

    AgpExtension - Supplies the AGP extension

    Capability - Returns the AGP capability

Return Value:

    NTSTATUS

--*/

{
    return(AgpLibGetAgpCapability(ApGetSetDeviceBusData,
                                  NULL,
                                  Capability));
}


NTSTATUS
AgpLibGetPciDeviceCapability(
    IN ULONG BusId,
    IN ULONG SlotId,
    OUT PPCI_AGP_CAPABILITY Capability
    )
/*++

Routine Description:

    Retrieves the AGP capability for the specified PCI slot.

    Caller is responsible for figuring out what the correct
    Bus/Slot ID is. These are just passed right to HalGetBusData.

Arguments:

    BusId - supplies the bus id

    SlotId - Supplies the slot id

    Capability - Returns the AGP capability

Return Value:

    NTSTATUS

--*/

{
    BUS_SLOT_ID BusSlotId;

    BusSlotId.BusId = BusId;
    BusSlotId.SlotId = SlotId;

    return(AgpLibGetAgpCapability(ApGetSetBusData,
                                  &BusSlotId,
                                  Capability));
}


NTSTATUS
AgpLibSetAgpCapability(
    IN PAGP_GETSET_CONFIG_SPACE pConfigFn,
    IN PVOID Context,
    OUT PPCI_AGP_CAPABILITY Capability
    )
/*++

Routine Description:

    This routine finds and retrieves the AGP capabilities in the
    PCI config space of the AGP master (graphics card).

Arguments:

    pConfigFn - Supplies the function to call for accessing config space
        on the appropriate device.

    Context - Supplies the context to pass to pConfigFn

    Capabilities - Returns the current AGP Capabilities

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS Status;
    UCHAR CapabilityOffset;

    Status = ApFindAgpCapability(pConfigFn,
                                 Context,
                                 Capability,
                                 &CapabilityOffset);
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    //
    // Now that we know the offset, write the supplied command register
    //
    Status = (pConfigFn)(Context,
                         FALSE,
                         &Capability->AGPCommand,
                         CapabilityOffset + FIELD_OFFSET(PCI_AGP_CAPABILITY, AGPCommand),
                         sizeof(Capability->AGPCommand));
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AgpLibSetAgpCapability - Set AGP command at offset %x for Context %08lx failed %08lx\n",
                CapabilityOffset,
                Context,
                Status));
        return(Status);
    }

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpLibSetMasterCapability(
    IN PVOID AgpExtension,
    OUT PPCI_AGP_CAPABILITY Capability
    )
/*++

Routine Description:

    Sets the AGP capability for the AGP master (graphics card)

Arguments:

    AgpExtension - Supplies the AGP extension

    Capability - Returns the AGP capability

Return Value:

    NTSTATUS

--*/

{
    return(AgpLibSetAgpCapability(ApGetSetDeviceBusData,
                                  NULL,
                                  Capability));
}


NTSTATUS
AgpLibSetPciDeviceCapability(
    IN ULONG BusId,
    IN ULONG SlotId,
    OUT PPCI_AGP_CAPABILITY Capability
    )
/*++

Routine Description:

    Sets the AGP capability for the specified PCI slot.

    Caller is responsible for figuring out what the correct
    Bus/Slot ID is. These are just passed right to HalSetBusData.

Arguments:

    BusId - supplies the bus id

    SlotId - Supplies the slot id

    Capability - Returns the AGP capability

Return Value:

    NTSTATUS

--*/

{
    BUS_SLOT_ID BusSlotId;

    BusSlotId.BusId = BusId;
    BusSlotId.SlotId = SlotId;

    return(AgpLibSetAgpCapability(ApGetSetBusData,
                                  &BusSlotId,
                                  Capability));
}


NTSTATUS
AgpInitializeTarget(
    IN PVOID AgpExtension
    )
/*++

Routine Description:

    Entrypoint for target initialization. This is called first.

Arguments:

    AgpExtension - Supplies the AGP extension

Return Value:

    NTSTATUS

--*/

{
    PAGP440_EXTENSION Extension = AgpExtension;

    //
    // Initialize our chipset-specific extension
    //
    Extension->ApertureStart.QuadPart = 0;
    Extension->ApertureLength = 0;
    Extension->Gart = NULL;
    Extension->GartLength = 0;
    Extension->GlobalEnable = FALSE;
    Extension->PCIEnable = FALSE;
    Extension->GartPhysical.QuadPart = 0;

    return(STATUS_SUCCESS);
}


NTSTATUS
AgpInitializeMaster(
    IN  PVOID AgpExtension,
    OUT ULONG *AgpCapabilities
    )
/*++

Routine Description:

    Entrypoint for master initialization. This is called after target initialization
    and should be used to initialize the AGP capabilities of both master and target.

    This is also called when the master transitions into the D0 state.

Arguments:

    AgpExtension - Supplies the AGP extension

    AgpCapabilities - Returns the capabilities of this AGP device.

Return Value:

    STATUS_SUCCESS

--*/

{
    NTSTATUS Status;
    PCI_AGP_CAPABILITY MasterCap;
    PCI_AGP_CAPABILITY TargetCap;
    ULONG SBAEnable;
    ULONG DataRate;
    ULONG FastWrite;
#if DBG
    PCI_AGP_CAPABILITY CurrentCap;
#endif

    //
    // Indicate that we can map memory through the GART aperture
    //
    *AgpCapabilities = AGP_CAPABILITIES_MAP_PHYSICAL;

    //
    // Get the master and target AGP capabilities
    //
    Status = AgpLibGetMasterCapability(AgpExtension, &MasterCap);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AGP440InitializeDevice - AgpLibGetMasterCapability failed %08lx\n"));
        return(Status);
    }

    //
    // Some broken cards (Matrox Millenium II "AGP") report no valid
    // supported transfer rates. These are not really AGP cards. They
    // have an AGP Capabilities structure that reports no capabilities.
    //
    if (MasterCap.AGPStatus.Rate == 0) {
        AGPLOG(AGP_CRITICAL,
               ("AGP440InitializeDevice - AgpLibGetMasterCapability returned no valid transfer rate\n"));
        return(STATUS_INVALID_DEVICE_REQUEST);
    }

    Status = AgpLibGetPciDeviceCapability(0,0,&TargetCap);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AGP440InitializeDevice - AgpLibGetPciDeviceCapability failed %08lx\n"));
        return(Status);
    }

    //
    // Determine the greatest common denominator for data rate.
    //
    DataRate = TargetCap.AGPStatus.Rate & MasterCap.AGPStatus.Rate;

    ASSERT(DataRate != 0);

    //
    // Select the highest common rate.
    //
    if (DataRate & PCI_AGP_RATE_4X) {
        DataRate = PCI_AGP_RATE_4X;
    } else if (DataRate & PCI_AGP_RATE_2X) {
        DataRate = PCI_AGP_RATE_2X;
    } else if (DataRate & PCI_AGP_RATE_1X) {
        DataRate = PCI_AGP_RATE_1X;
    }

    //
    // Enable SBA if both master and target support it.
    //
    SBAEnable = (TargetCap.AGPStatus.SideBandAddressing & MasterCap.AGPStatus.SideBandAddressing);

    //
    // Enable FastWrite if both master and target support it.
    //
    FastWrite = (TargetCap.AGPStatus.FastWrite & MasterCap.AGPStatus.FastWrite);

    //
    // Enable the Target first.
    //
    TargetCap.AGPCommand.Rate = DataRate;
    TargetCap.AGPCommand.AGPEnable = 1;
    TargetCap.AGPCommand.SBAEnable = SBAEnable;
    TargetCap.AGPCommand.FastWriteEnable = FastWrite;
    TargetCap.AGPCommand.FourGBEnable = 0;  
    Status = AgpLibSetPciDeviceCapability(0, 0, &TargetCap);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AGP440InitializeDevice - AgpLibSetPciDeviceCapability %08lx for target failed %08lx\n",
                &TargetCap,
                Status));
        return(Status);
    }

    //
    // Now enable the Master
    //
    MasterCap.AGPCommand.Rate = DataRate;
    MasterCap.AGPCommand.AGPEnable = 1;
    MasterCap.AGPCommand.SBAEnable = SBAEnable;
    MasterCap.AGPCommand.FastWriteEnable = FastWrite;
    MasterCap.AGPCommand.FourGBEnable = 0;  
    MasterCap.AGPCommand.RequestQueueDepth = TargetCap.AGPStatus.RequestQueueDepthMaximum;
    Status = AgpLibSetMasterCapability(AgpExtension, &MasterCap);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AGP440InitializeDevice - AgpLibSetMasterCapability %08lx failed %08lx\n",
                &MasterCap,
                Status));
    }

#if DBG
    //
    // Read them back, see if it worked
    //
    Status = AgpLibGetMasterCapability(AgpExtension, &CurrentCap);
    ASSERT(NT_SUCCESS(Status));

    //
    // If the target request queue depth is greater than the master will
    // allow, it will be trimmed.   Loosen the assert to not require an
    // exact match.
    //
    ASSERT(CurrentCap.AGPCommand.RequestQueueDepth <= MasterCap.AGPCommand.RequestQueueDepth);
    CurrentCap.AGPCommand.RequestQueueDepth = MasterCap.AGPCommand.RequestQueueDepth;
    ASSERT(RtlEqualMemory(&CurrentCap.AGPCommand, &MasterCap.AGPCommand, sizeof(CurrentCap.AGPCommand)));

    Status = AgpLibGetPciDeviceCapability(0,0,&CurrentCap);
    ASSERT(NT_SUCCESS(Status));
    ASSERT(RtlEqualMemory(&CurrentCap.AGPCommand, &TargetCap.AGPCommand, sizeof(CurrentCap.AGPCommand)));

#endif

    return(Status);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\portx\videoprt.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    videoprt.h

Abstract:

    This module contains the private data structures and procedure prototypes
    for the video port driver.

--*/

#ifndef _VIDEOPRT_
#define _VIDEOPRT_

#include <ntos.h>
#include <pci.h>
#include <ntddvdeo.h>
#include <video.h>
#include <dderror.h>
#include <ntagp.h>
#include <stdio.h>
#include "agp440.h"

//
// DBG sensitive DbgPrint wrapper.
//

#if DBG
#define VideoDbgPrint(x)                        DbgPrint x
#else
#define VideoDbgPrint(x)
#endif

//
// Bit flag macros.
//

#define VideoIsFlagSet(flagset, flag)           (((flagset) & (flag)) != 0)
#define VideoIsFlagClear(flagset, flag)         (((flagset) & (flag)) == 0)
#define VideoIsBitSet(flagset, bit)             VideoIsFlagSet((flagset), (1 << (bit)))
#define VideoIsBitClear(flagset, bit)           VideoIsFlagClear((flagset), (1 << (bit)))

//
// Structure to track the size of memory mappings.
//

typedef struct _VIDEO_MAPPED_ADDRESS {
    PVOID MappedAddress;
    ULONG NumberOfUchars;
} VIDEO_MAPPED_ADDRESS, *PVIDEO_MAPPED_ADDRESS;

#define NUMBER_OF_VIDEO_MAPPED_ADDRESSES        8

//
// Video device extension data.
//

typedef struct _VIDEO_DEVICE_EXTENSION {
    PVIDEO_HW_FIND_ADAPTER HwFindAdapter;
    PVIDEO_HW_INITIALIZE HwInitialize;
    PVIDEO_HW_INTERRUPT HwInterrupt;
    PVIDEO_HW_START_IO HwStartIO;
    PVIDEO_HW_RESET_HW HwResetHw;
    PVIDEO_HW_TIMER HwTimer;
    ULONG BaseAddresses[PCI_TYPE0_ADDRESSES];
    VIDEO_MAPPED_ADDRESS MappedAddresses[NUMBER_OF_VIDEO_MAPPED_ADDRESSES];
    PKINTERRUPT InterruptObject;
    KDPC Dpc;
    BOOLEAN DeviceOpened;
    BOOLEAN InterruptsEnabled;
    KMUTEX SyncMutex;
    AGP_BUS_INTERFACE_STANDARD AgpInterface;
    FAST_MUTEX AgpInterfaceLock;
    AGP440_EXTENSION Agp440Extension;
} VIDEO_DEVICE_EXTENSION, *PVIDEO_DEVICE_EXTENSION;

//
// Macros to convert between the VIDEO_DEVICE_EXTENSION structure and the
// miniport's hardware extension.
//

#define VIDEO_GET_VIDEO_DEVICE_EXTENSION(hwe) \
    (((PVIDEO_DEVICE_EXTENSION)(hwe)) - 1)

#define VIDEO_GET_HW_DEVICE_EXTENSION(vde) \
    ((PVOID)(((PVIDEO_DEVICE_EXTENSION)(vde)) + 1))

//
// Define the slot configuration for the video adapter attached to an AGP440.
//

#define AGP440_TARGET_DEVICE_NUMBER             0
#define AGP440_TARGET_FUNCTION_NUMBER           0

//
// These macros are used to protect threads which will enter the
// miniport.  We need to guarantee that only one thread enters
// the miniport at a time.
//

#define ACQUIRE_DEVICE_LOCK(DeviceExtension)           \
    KeWaitForSingleObject(&DeviceExtension->SyncMutex, \
                          Executive,                   \
                          KernelMode,                  \
                          FALSE,                       \
                          (PTIME)NULL);

#define RELEASE_DEVICE_LOCK(DeviceExtension)           \
    KeReleaseMutex(&DeviceExtension->SyncMutex,        \
                   FALSE);

#endif // VIDEOPRT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\portx\agp440.h ===
//
// Always turned on for now
//
#if DEVL

#define AGP_ALWAYS   0
#define AGP_CRITICAL 1
#define AGP_WARNING  2
#define AGP_IRPTRACE 3
#define AGP_NOISE    4

extern ULONG AgpLogLevel;
extern ULONG AgpStopLevel;
#define AGPLOG(_level_,_x_) if ((_level_) <= AgpLogLevel) DbgPrint _x_; \
                            if ((_level_) <= AgpStopLevel) { DbgBreakPoint();}

#else

#define AGPLOG(_level_,_x_)

#endif

//
// Define the location of the GART aperture control registers
//

//
// The GART registers on the 440 live in the host-PCI bridge.
// This is unfortunate, since the AGP driver attaches to the PCI-PCI (AGP)
// bridge. So we have to get to the host-PCI bridge config space
// and this is only possible because we KNOW this is bus 0, slot 0.
//
#define AGP_440_GART_BUS_ID     0
#define AGP_440_GART_SLOT_ID    0

#define AGP_440LX_IDENTIFIER    0x71808086
#define AGP_440BX_IDENTIFIER    0x71908086

#define APBASE_OFFSET  0x10             // Aperture Base Address
#define APSIZE_OFFSET  0xB4             // Aperture Size Register
#define PACCFG_OFFSET  0x50             // PAC Configuration Register
#define AGPCTRL_OFFSET 0xB0             // AGP Control Register
#define ATTBASE_OFFSET 0xB8             // Aperture Translation Table Base

#define Read440Config(_buf_,_offset_,_size_)                \
{                                                           \
    ULONG _len_;                                            \
    _len_ = HalGetBusDataByOffset(PCIConfiguration,         \
                                  AGP_440_GART_BUS_ID,      \
                                  AGP_440_GART_SLOT_ID,     \
                                  (_buf_),                  \
                                  (_offset_),               \
                                  (_size_));                \
    ASSERT(_len_ == (_size_));                              \
}

#define Write440Config(_buf_,_offset_,_size_)               \
{                                                           \
    ULONG _len_;                                            \
    _len_ = HalSetBusDataByOffset(PCIConfiguration,         \
                                  AGP_440_GART_BUS_ID,      \
                                  AGP_440_GART_SLOT_ID,     \
                                  (_buf_),                  \
                                  (_offset_),               \
                                  (_size_));                \
    ASSERT(_len_ == (_size_));                              \
}

//
// Conversions from APSIZE encoding to MB
//
// 0x3F (b 11 1111) =   4MB
// 0x3E (b 11 1110) =   8MB
// 0x3C (b 11 1100) =  16MB
// 0x38 (b 11 1000) =  32MB
// 0x30 (b 11 0000) =  64MB
// 0x20 (b 10 0000) = 128MB
// 0x00 (b 00 0000) = 256MB

#define AP_SIZE_4MB     0x3F
#define AP_SIZE_8MB     0x3E
#define AP_SIZE_16MB    0x3C
#define AP_SIZE_32MB    0x38
#define AP_SIZE_64MB    0x30
#define AP_SIZE_128MB   0x20
#define AP_SIZE_256MB   0x00

#define AP_SIZE_COUNT 7
#define AP_MIN_SIZE (4 * 1024 * 1024)
#define AP_MAX_SIZE (256 * 1024 * 1024)

//
// Define the GART table entry.
//
typedef struct _GART_ENTRY_HW {
    ULONG Valid     :  1;
    ULONG Reserved  : 11;
    ULONG Page      : 20;
} GART_ENTRY_HW, *PGART_ENTRY_HW;


//
// GART Entry states are defined so that all software-only states
// have the Valid bit clear.
//
#define GART_ENTRY_VALID        1           //  001
#define GART_ENTRY_FREE         0           //  000

#define GART_ENTRY_WC           2           //  010
#define GART_ENTRY_UC           4           //  100

#define GART_ENTRY_RESERVED_WC  GART_ENTRY_WC
#define GART_ENTRY_RESERVED_UC  GART_ENTRY_UC

#define GART_ENTRY_VALID_WC     (GART_ENTRY_VALID)
#define GART_ENTRY_VALID_UC     (GART_ENTRY_VALID)


typedef struct _GART_ENTRY_SW {
    ULONG State     : 3;
    ULONG Reserved  : 29;
} GART_ENTRY_SW, *PGART_ENTRY_SW;

typedef struct _GART_PTE {
    union {
        GART_ENTRY_HW Hard;
        ULONG      AsUlong;
        GART_ENTRY_SW Soft;
    };
} GART_PTE, *PGART_PTE;

//
// Define the layout of the hardware registers
//
typedef struct _AGPCTRL {
    ULONG Reserved1     : 7;
    ULONG GTLB_Enable   : 1;
    ULONG Reserved2     : 24;
} AGPCTRL, *PAGPCTRL;

typedef struct _PACCFG {
    USHORT Reserved1    : 9;
    USHORT GlobalEnable : 1;
    USHORT PCIEnable    : 1;
    USHORT Reserved2    : 5;
} PACCFG, *PPACCFG;


//
// Define the 440-specific extension
//
typedef struct _AGP440_EXTENSION {
    BOOLEAN             GlobalEnable;
    BOOLEAN             PCIEnable;
    PHYSICAL_ADDRESS    ApertureStart;
    ULONG               ApertureLength;
    PGART_PTE           GartCached;
    PGART_PTE           Gart;
    ULONG               GartLength;
    PHYSICAL_ADDRESS    GartPhysical;
} AGP440_EXTENSION, *PAGP440_EXTENSION;

//
// The highest memory address supported by AGP
//

#define MAX_MEM(_num_) _num_ = 1; \
                       _num_ = _num_*1024*1024*1024*4 - 1

typedef struct _AGP_RANGE {
    PHYSICAL_ADDRESS MemoryBase;
    ULONG NumberOfPages;
    MEMORY_CACHING_TYPE Type;
    PVOID Context;
    ULONG CommittedPages;
} AGP_RANGE, *PAGP_RANGE;

NTSTATUS
AgpInitializeTarget(
    IN PVOID AgpExtension
    );

NTSTATUS
AgpInitializeMaster(
    IN  PVOID AgpExtension,
    OUT ULONG *AgpCapabilities
    );

NTSTATUS
AgpQueryAperture(
    IN PVOID AgpContext,
    OUT PHYSICAL_ADDRESS *CurrentBase,
    OUT ULONG *CurrentSizeInPages,
    OUT OPTIONAL PIO_RESOURCE_LIST *ApertureRequirements
    );

NTSTATUS
AgpSetAperture(
    IN PVOID AgpContext,
    IN PHYSICAL_ADDRESS NewBase,
    OUT ULONG NewSizeInPages
    );

NTSTATUS
AgpReserveMemory(
    IN PVOID AgpContext,
    IN OUT AGP_RANGE *AgpRange
    );

NTSTATUS
AgpReleaseMemory(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange
    );

VOID
AgpFindFreeRun(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT ULONG *FreePages,
    OUT ULONG *FreeOffset
    );

VOID
AgpGetMappedPages(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT PMDL Mdl
    );

NTSTATUS
AgpMapMemory(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN PMDL Mdl,
    IN ULONG OffsetInPages,
    OUT PHYSICAL_ADDRESS *MemoryBase
    );

NTSTATUS
AgpUnMapMemory(
    IN PVOID AgpContext,
    IN PAGP_RANGE AgpRange,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages
    );

typedef
VOID
(*PAGP_FLUSH_PAGES)(
    IN PVOID AgpContext,
    IN PMDL Mdl
    );

extern PAGP_FLUSH_PAGES AgpFlushPages;

VOID
AgpInterfaceReference(
    IN struct _VIDEO_DEVICE_EXTENSION * Extension
    );

VOID
AgpInterfaceDereference(
    IN struct _VIDEO_DEVICE_EXTENSION * Extension
    );

NTSTATUS
AgpInterfaceReserveMemory(
    IN struct _VIDEO_DEVICE_EXTENSION * Extension,
    IN ULONG NumberOfPages,
    IN MEMORY_CACHING_TYPE MemoryType,
    OUT PVOID *MapHandle,
    OUT OPTIONAL PHYSICAL_ADDRESS *PhysicalAddress
    );

NTSTATUS
AgpInterfaceReleaseMemory(
    IN struct _VIDEO_DEVICE_EXTENSION * Extension,
    IN PVOID MapHandle
    );

NTSTATUS
AgpInterfaceCommitMemory(
    IN struct _VIDEO_DEVICE_EXTENSION * Extension,
    IN PVOID MapHandle,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    IN OUT PMDL Mdl OPTIONAL,
    OUT PHYSICAL_ADDRESS *MemoryBase
    );

NTSTATUS
AgpInterfaceFreeMemory(
    IN struct _VIDEO_DEVICE_EXTENSION * Extension,
    IN PVOID MapHandle,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages
    );

NTSTATUS
AgpInterfaceGetMappedPages(
    IN struct _VIDEO_DEVICE_EXTENSION * Extension,
    IN PVOID MapHandle,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT PMDL Mdl
    );

#define GET_AGP_CONTEXT_FROM_MASTER(_masterext_) (&(_masterext_)->Agp440Extension)

PMDL
AgpLibAllocatePhysicalMemory(
    IN PVOID AgpContext,
    IN ULONG TotalBytes);

//
// Locking macros
//
#define LOCK_MUTEX(_fm_) ExAcquireFastMutex(_fm_); \
                         ASSERT((_fm_)->Count == 0)

#define UNLOCK_MUTEX(_fm_) ASSERT((_fm_)->Count == 0);  \
                           ExReleaseFastMutex(_fm_)

#define LOCK_MASTER(_masterext_) LOCK_MUTEX(&(_masterext_)->AgpInterfaceLock)

#define UNLOCK_MASTER(_masterext_) UNLOCK_MUTEX(&(_masterext_)->AgpInterfaceLock)

//
// The PCI_COMMON_CONFIG includes the 192 bytes of device specific
// data.  The following structure is used to get only the first 64
// bytes which is all we care about most of the time anyway.  We cast
// to PCI_COMMON_CONFIG to get at the actual fields.
//

typedef struct {
    ULONG Reserved[PCI_COMMON_HDR_LENGTH/sizeof(ULONG)];
} PCI_COMMON_HEADER, *PPCI_COMMON_HEADER;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\portx\intrface.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    intrface.c

Abstract:

    Routines for implementing the AGP_BUS_INTERFACE_STANDARD interface

Author:

    John Vert (jvert) 10/26/1997

Revision History:

   Elliot Shmukler (elliots) 3/24/1999 - Added support for "favored" memory
                                          ranges for AGP physical memory allocation,
                                          fixed some bugs.

--*/

#if 0 // NUGOOP

#define INITGUID 1
#include "videoprt.h"

ULONG AgpStopLevel;
ULONG AgpLogLevel;
PAGP_FLUSH_PAGES AgpFlushPages = NULL;  // not implemented

VOID
AgpLibFlushDcacheMdl(
    PMDL Mdl
    );

VOID
AgpInterfaceReference(
    IN PVIDEO_DEVICE_EXTENSION Extension
    )
/*++

Routine Description:

    References an interface. Currently a NOP.

Arguments:

    Extension - Supplies the device extension

Return Value:

    None

--*/

{
}


VOID
AgpInterfaceDereference(
    IN PVIDEO_DEVICE_EXTENSION Extension
    )
/*++

Routine Description:

    Dereferences an interface. Currently a NOP.

Arguments:

    Extension - Supplies the device extension

Return Value:

    None

--*/

{
}


NTSTATUS
AgpInterfaceReserveMemory(
    IN PVIDEO_DEVICE_EXTENSION Extension,
    IN ULONG NumberOfPages,
    IN MEMORY_CACHING_TYPE MemoryType,
    OUT PVOID *MapHandle,
    OUT OPTIONAL PHYSICAL_ADDRESS *PhysicalAddress
    )
/*++

Routine Description:

    Reserves memory in the specified aperture

Arguments:

    Extension - Supplies the device extension where physical address space should be reserved.

    NumberOfPages - Supplies the number of pages to reserve.

    MemoryType - Supplies the memory caching type.

    MapHandle - Returns the mapping handle to be used on subsequent calls.

    PhysicalAddress - If present, returns the physical address in the aperture of the reserved 
            space

Return Value:

    NTSTATUS

--*/

{
    PVOID AgpContext;
    NTSTATUS Status;
    PAGP_RANGE Range;

    PAGED_CODE();                              

    AgpContext = GET_AGP_CONTEXT_FROM_MASTER(Extension);

    Range = ExAllocatePoolWithTag(PagedPool,
                                  sizeof(AGP_RANGE),
                                  'RpgA');
    if (Range == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    Range->CommittedPages = 0;
    Range->NumberOfPages = NumberOfPages;
    Range->Type = MemoryType;

    LOCK_MASTER(Extension);
    Status = AgpReserveMemory(AgpContext,
                              Range);
    UNLOCK_MASTER(Extension);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AgpInterfaceReserveMemory - reservation of %x pages of type %d failed %08lx\n",
                NumberOfPages,
                MemoryType,
                Status));
    } else {
        AGPLOG(AGP_NOISE,
               ("AgpInterfaceReserveMemory - reserved %x pages of type %d at %I64X\n",
                NumberOfPages,
                MemoryType,
                Range->MemoryBase.QuadPart));
    }

    *MapHandle = Range;
    if (ARGUMENT_PRESENT(PhysicalAddress)) {
        *PhysicalAddress = Range->MemoryBase;
    }
    return(Status);
}


NTSTATUS
AgpInterfaceReleaseMemory(
    IN PVIDEO_DEVICE_EXTENSION Extension,
    IN PVOID MapHandle
    )
/*++

Routine Description:

    Releases memory in the specified aperture that was previously reserved by
    AgpInterfaceReserveMemory

Arguments:

    Extension - Supplies the device extension where physical address space should be reserved.

    MapHandle - Supplies the mapping handle returned from AgpInterfaceReserveMemory

Return Value:

    NTSTATUS

--*/

{
    PAGP_RANGE Range;
    PVOID AgpContext;
    NTSTATUS Status;

    PAGED_CODE();

    AgpContext = GET_AGP_CONTEXT_FROM_MASTER(Extension);
    Range = (PAGP_RANGE)MapHandle;

    LOCK_MASTER(Extension);
    //
    // Make sure the range is empty
    //
    ASSERT(Range->CommittedPages == 0);
    if (Range->CommittedPages != 0) {
        AGPLOG(AGP_CRITICAL,
               ("AgpInterfaceReleaseMemory - Invalid attempt to release non-empty range %08lx\n",
                Range));
        UNLOCK_MASTER(Extension);
        return(STATUS_INVALID_PARAMETER);
    }

    AGPLOG(AGP_NOISE,
           ("AgpInterfaceReleaseMemory - releasing range %08lx, %lx pages at %08lx\n",
            Range,
            Range->NumberOfPages,
            Range->MemoryBase.QuadPart));
    Status = AgpReleaseMemory(AgpContext,
                              Range);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AgpInterfaceReleaseMemory - release failed %08lx\n",
                Status));
    }
    UNLOCK_MASTER(Extension);
    ExFreePool(Range);
    return(Status);
}


NTSTATUS
AgpInterfaceCommitMemory(
    IN PVIDEO_DEVICE_EXTENSION Extension,
    IN PVOID MapHandle,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    IN OUT PMDL Mdl OPTIONAL,
    OUT PHYSICAL_ADDRESS *MemoryBase
    )
/*++

Routine Description:

    Commits memory into the specified aperture that was previously reserved by
    AgpInterfaceReserveMemory

Arguments:

    Extension - Supplies the device extension where physical address space should
        be committed.

    MapHandle - Supplies the mapping handle returned from AgpInterfaceReserveMemory

    NumberOfPages - Supplies the number of pages to be committed.

    OffsetInPages - Supplies the offset, in pages, into the aperture reserved by
        AgpInterfaceReserveMemory

    Mdl - Returns the MDL describing the pages of memory committed.

    MemoryBase - Returns the physical memory address of the committed memory.

Return Value:

    NTSTATUS

--*/

{
    PAGP_RANGE Range = (PAGP_RANGE)MapHandle;
    PMDL NewMdl;
    PVOID AgpContext;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG RunLength, RunOffset;
    ULONG CurrentLength, CurrentOffset;
    PMDL FirstMdl=NULL;

    PAGED_CODE();

    AgpContext = GET_AGP_CONTEXT_FROM_MASTER(Extension);

    ASSERT(NumberOfPages <= Range->NumberOfPages);
    ASSERT(NumberOfPages > 0);
    ASSERT((Mdl == NULL) || (Mdl->ByteCount == PAGE_SIZE * NumberOfPages));

    CurrentLength = NumberOfPages;
    CurrentOffset = OffsetInPages;

    LOCK_MASTER(Extension);
    do {

        //
        // Find the first free run in the supplied range.
        //
        AgpFindFreeRun(AgpContext,
                       Range,
                       CurrentLength,
                       CurrentOffset,
                       &RunLength,
                       &RunOffset);

        if (RunLength > 0) {
            ASSERT(RunLength <= CurrentLength);
            ASSERT(RunOffset >= CurrentOffset);
            ASSERT(RunOffset < CurrentOffset + CurrentLength);
            ASSERT(RunOffset + RunLength <= CurrentOffset + CurrentLength);

            //
            // Compute the next offset and length
            //
            CurrentLength -= (RunOffset - CurrentOffset) + RunLength;
            CurrentOffset = RunOffset + RunLength;

            //
            // Get an MDL from memory management big enough to map the 
            // requested range.
            //

            NewMdl = AgpLibAllocatePhysicalMemory(AgpContext, RunLength * PAGE_SIZE);

            //
            // This can fail in two ways, either no memory is available at all (NewMdl == NULL)
            // or some pages were available, but not enough. (NewMdl->ByteCount < Length)
            //
            if (NewMdl == NULL) {
                AGPLOG(AGP_CRITICAL,
                       ("AgpInterfaceReserveMemory - Couldn't allocate pages for %lx bytes\n",
                        RunLength));
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            } else if (BYTES_TO_PAGES(NewMdl->ByteCount) < RunLength) {
                AGPLOG(AGP_CRITICAL,
                       ("AgpInterfaceCommitMemory - Only allocated enough pages for %lx of %lx bytes\n",
                        NewMdl->ByteCount,
                        RunLength));
                Status = STATUS_INSUFFICIENT_RESOURCES;
                MmFreePagesFromMdl(NewMdl);
                break;
            }

            //
            // Now that we have our MDL, we can map this into the specified
            // range.
            //
            if (AgpFlushPages != NULL) {
                (AgpFlushPages)(AgpContext, NewMdl);
            } else {
                AgpLibFlushDcacheMdl(NewMdl);
            }
            Status = AgpMapMemory(AgpContext,
                                  Range,
                                  NewMdl,
                                  RunOffset,
                                  MemoryBase);
            if (!NT_SUCCESS(Status)) {
                AGPLOG(AGP_CRITICAL,
                       ("AgpInterfaceCommitMemory - AgpMapMemory for Mdl %08lx in range %08lx failed %08lx\n",
                        NewMdl,
                        Range,
                        Status));
                MmFreePagesFromMdl(NewMdl);
                break;
            }
            Range->CommittedPages += RunLength;

            //
            // Add this MDL to our list of allocated MDLs for cleanup
            // If we need to cleanup, we will also need to know the page offset
            // so that we can unmap the memory. Stash that value in the ByteOffset
            // field of the MDL (ByteOffset is always 0 for our MDLs)
            //
            NewMdl->ByteOffset = RunOffset;
            NewMdl->Next = FirstMdl;
            FirstMdl = NewMdl;
        }

    } while (RunLength > 0);

    //
    // Cleanup the MDLs. If the allocation failed, we need to
    // unmap them and free the pages and the MDL itself. If the
    // operation completed successfully, we just need to free the
    // MDL.
    //
    while (FirstMdl) {
        NewMdl = FirstMdl;
        FirstMdl = NewMdl->Next;
        if (!NT_SUCCESS(Status)) {

            //
            // Unmap the memory that was mapped. The ByteOffset field
            // of the MDL is overloaded here to store the offset in pages
            // into the range.
            //
            AgpUnMapMemory(AgpContext,
                           Range,
                           NewMdl->ByteCount / PAGE_SIZE,
                           NewMdl->ByteOffset);
            NewMdl->ByteOffset = 0;
            Range->CommittedPages -= NewMdl->ByteCount / PAGE_SIZE;
            MmFreePagesFromMdl(NewMdl);
        }
        ExFreePool(NewMdl);
    }

    if (NT_SUCCESS(Status)) {

        if (Mdl) {
            //
            // Get the MDL that describes the entire mapped range.
            //
            AgpGetMappedPages(AgpContext,
                              Range,
                              NumberOfPages,
                              OffsetInPages,
                              Mdl);
        }

        MemoryBase->QuadPart = Range->MemoryBase.QuadPart + OffsetInPages * PAGE_SIZE;
    }

    UNLOCK_MASTER(Extension);
    return(Status);
}


NTSTATUS
AgpInterfaceFreeMemory(
    IN PVIDEO_DEVICE_EXTENSION Extension,
    IN PVOID MapHandle,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages
    )
/*++

Routine Description:

    Frees memory previously committed by AgpInterfaceCommitMemory

Arguments:

    Extension - Supplies the device extension where physical address space should
        be freed.

    MapHandle - Supplies the mapping handle returned from AgpInterfaceReserveMemory

    NumberOfPages - Supplies the number of pages to be freed.

    OffsetInPages - Supplies the start of the range to be freed.

Return Value:

    NTSTATUS

--*/

{
    PAGP_RANGE Range = (PAGP_RANGE)MapHandle;
    PVOID AgpContext;
    NTSTATUS Status;
    PMDL FreeMdl;

    PAGED_CODE();

    AgpContext = GET_AGP_CONTEXT_FROM_MASTER(Extension);

    ASSERT(OffsetInPages < Range->NumberOfPages);
    ASSERT(OffsetInPages + NumberOfPages <= Range->NumberOfPages);
    //
    // Make sure the supplied address is within the reserved range
    //
    if ((OffsetInPages >= Range->NumberOfPages) ||
        (OffsetInPages + NumberOfPages > Range->NumberOfPages)) {
        AGPLOG(AGP_WARNING,
               ("AgpInterfaceFreeMemory - Invalid free of %x pages at offset %x from range %I64X (%x pages)\n",
                NumberOfPages,
                OffsetInPages,
                Range->MemoryBase.QuadPart,
                Range->NumberOfPages));
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Allocate an MDL big enough to contain the pages to be unmapped.
    //
    FreeMdl = MmCreateMdl(NULL, 0, NumberOfPages * PAGE_SIZE);
    if (FreeMdl == NULL) {

// @@BEGIN_DDKSPLIT
        //
        // This is kind of a sticky situation. We can't allocate the memory that we need to free up
        // some memory! I guess we could have a small MDL on our stack and free things that way.
        // BUGBUG John Vert (jvert) 11/11/1997
        //   implement this
        //
// @@END_DDKSPLIT

        ASSERT(FreeMdl != NULL);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    LOCK_MASTER(Extension);

    //
    // Get the MDL that describes the entire mapped range
    //
    AgpGetMappedPages(AgpContext, 
                      Range,
                      NumberOfPages,
                      OffsetInPages,
                      FreeMdl);
    //
    // Unmap the memory
    //
    Status = AgpUnMapMemory(AgpContext,
                            Range,
                            NumberOfPages,
                            OffsetInPages);
    UNLOCK_MASTER(Extension);
    if (!NT_SUCCESS(Status)) {
        AGPLOG(AGP_CRITICAL,
               ("AgpInterfaceFreeMemory - UnMapMemory for %x pages at %I64X failed %08lx\n",
                NumberOfPages,
                Range->MemoryBase.QuadPart + OffsetInPages * PAGE_SIZE,
                Status));
    } else {
        //
        // Free the pages
        //
        MmFreePagesFromMdl(FreeMdl);
        ASSERT(Range->CommittedPages >= NumberOfPages);
        Range->CommittedPages -= NumberOfPages;
    }

    //
    // Free the MDL we allocated.
    //
    ExFreePool(FreeMdl);
    return(Status);
}

NTSTATUS
AgpInterfaceGetMappedPages(
    IN PVIDEO_DEVICE_EXTENSION Extension,
    IN PVOID MapHandle,
    IN ULONG NumberOfPages,
    IN ULONG OffsetInPages,
    OUT PMDL Mdl
    )
/*++

Routine Description:

    Returns the list of physical pages mapped backing the specified range.

Arguments:

    Extension - Supplies the device extension where physical address space should
        be freed.

    MapHandle - Supplies the mapping handle returned from AgpInterfaceReserveMemory

    NumberOfPages - Supplies the number of pages to be returned

    OffsetInPages - Supplies the start of the rangion

Return Value:

    NTSTATUS

--*/

{
    PAGP_RANGE Range = (PAGP_RANGE)MapHandle;
    PVOID AgpContext;

    PAGED_CODE();

    AgpContext = GET_AGP_CONTEXT_FROM_MASTER(Extension);

    ASSERT(NumberOfPages <= Range->NumberOfPages);
    ASSERT(NumberOfPages > 0);
    ASSERT(OffsetInPages < Range->NumberOfPages);
    ASSERT(OffsetInPages + NumberOfPages <= Range->NumberOfPages);
    ASSERT(Mdl->ByteCount == PAGE_SIZE * NumberOfPages);

    //
    // Make sure the supplied address is within the reserved range
    //
    if ((OffsetInPages >= Range->NumberOfPages) ||
        (OffsetInPages + NumberOfPages > Range->NumberOfPages)) {
        AGPLOG(AGP_WARNING,
               ("AgpInterfaceGetMappedPages - Invalid 'get' of %x pages at offset %x from range %I64X (%x pages)\n",
                NumberOfPages,
                OffsetInPages,
                Range->MemoryBase.QuadPart,
                Range->NumberOfPages));
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Get the MDL that describes the entire mapped range
    //
    LOCK_MASTER(Extension);

    AgpGetMappedPages(AgpContext, 
                      Range,
                      NumberOfPages,
                      OffsetInPages,
                      Mdl);

    UNLOCK_MASTER(Extension);
    return(STATUS_SUCCESS);
}


PMDL
AgpLibAllocatePhysicalMemory(IN PVOID AgpContext, IN ULONG TotalBytes)
/*++

Routine Description:

    Allocates a set of physical memory pages for use by the AGP driver.
    
    This routine uses MmAllocatePagesForMdl to attempt to allocate
    as many of the pages as possible within favored AGP memory
    ranges (if any).

Arguments:

    AgpContext   - The AgpContext

    TotalBytes   - The total amount of bytes to allocate.

Return Value:

    An MDL that describes the allocated physical pages or NULL
    if this function is unsuccessful.

    NOTE: Just like MmAllocatePagesForMdl, this function can return
    an MDL that describes an allocation smaller than TotalBytes in size.

--*/
{
   PAGED_CODE();

   AGPLOG(AGP_NOISE, ("AGPLIB: Attempting to allocate memory = %u pages.\n",
            BYTES_TO_PAGES(TotalBytes)));

   return MmAllocatePagesForMdl(0,
                                MAXULONG_PTR,
                                TotalBytes);
}


PVOID
AgpLibAllocateMappedPhysicalMemory(IN PVOID AgpContext, IN ULONG TotalBytes)
/*++

Routine Description:

    Same as AgpLibAllocatePhysicalMemory, except this function will
    also map the allocated memory to a virtual address.

Arguments:

    Same as AgpLibAllocatePhysicalMemory.

Return Value:

    A virtual address of the allocated memory or NULL if unsuccessful.

--*/
{
   PMDL Mdl;
   PVOID Ret;

   PAGED_CODE();
   
   AGPLOG(AGP_NOISE, 
          ("AGPLIB: Attempting to allocate mapped memory = %u.\n", TotalBytes));

   //
   // Call the real memory allocator.
   //

   Mdl = AgpLibAllocatePhysicalMemory(AgpContext, TotalBytes);

   // Two possible failures

   // 1. MDL is NULL. No memory could be allocated.

   if (Mdl == NULL) {

      AGPLOG(AGP_WARNING, ("AGPMAP: Could not allocate anything.\n"));

      return NULL;
   }

   // 2. MDL has some pages allocated but not enough.

   if (Mdl->ByteCount < TotalBytes) {

      AGPLOG(AGP_WARNING, ("AGPMAP: Could not allocate enough.\n"));

      MmFreePagesFromMdl(Mdl);
      ExFreePool(Mdl);
      return NULL;
   }

   // Ok. Our allocation succeeded. Map it to a virtual address.

   // Step 1: Map the locked Pages. (will return NULL if failed)

   Mdl->MdlFlags |= MDL_PAGES_LOCKED;
   Ret = MmMapLockedPagesSpecifyCache (Mdl, MmNonCached);

   // Don't need the Mdl anymore, whether we succeeded or failed.

   ExFreePool(Mdl);

   if (Ret == NULL) {
      AGPLOG(AGP_WARNING, ("AGPMAP: Could not map.\n"));
   }

   return Ret;
}

#if defined (_X86_)
#define FLUSH_DCACHE(Mdl) __asm{ wbinvd }
#else
#define FLUSH_DCACHE(Mdl)   \
            AGPLOG(AGP_CRITICAL,    \
                   ("AgpLibFlushDcacheMdl - NEED TO IMPLEMENT DCACHE FLUSH FOR THIS ARCHITECTURE!!\n"))
#endif


VOID
AgpLibFlushDcacheMdl(
    PMDL Mdl
    )
/*++

Routine Description:

    Flushes the specified MDL from the D-caches of all processors
    in the system.

    Current algorithm is to set the current thread's affinity to each
    processor in turn and flush the dcache. This could be made a lot
    more efficient if this turns out to be a hot codepath

Arguments:

    Mdl - Supplies the MDL to be flushed.

Return Value:

    None.

--*/

{
    FLUSH_DCACHE(Mdl);
}

#endif 0
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\dll\dllp.h ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    dllp.h

Abstract:

    Precompiled header.

--*/

#ifndef _DLLP_
#define _DLLP_

#include "xapip.h"
#include <xboxp.h>
#include <stdio.h>
#include <scsi.h>
#include <ntddcdrm.h>
#include <ntddcdvd.h>
#include <ntdddisk.h>
#include <ntddscsi.h>
#include <dvdx2.h>

#include "xapiver.h"

#endif // _DLLP_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\portx\videoprt.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    videoprt.c

Abstract:

    This module implements a lightweight implementation of a video port driver.

--*/

#include "videoprt.h"

#if 1 // NUGOOP

extern BOOLEAN AgpUmaEnable();

#endif

PVIDEO_DEVICE_EXTENSION VideoGlobalDeviceExtension = NULL;

VOID
DriverEntry(
    IN PDRIVER_OBJECT DriverObject
    )
{
    //
    // We're actually an export library, not a real driver, so the DriverEntry
    // will never be called.  The routine only exists to satisfy the build
    // process.
    //

    ASSERT(FALSE);
}

ULONG VideoDebugLevel = 0;

VOID
VideoPortDebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    This routine allows the miniport drivers (as well as the port driver) to
    display error messages to the debug port when running in the debug
    environment.

    When running a non-debugged system, all references to this call are
    eliminated by the compiler.

Arguments:

    DebugPrintLevel - Debug print level between 0 and 3, with 3 being the
        most verbose.

Return Value:

    None.

--*/

{
    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= VideoDebugLevel) {

        char buffer[256];

        vsprintf(buffer, DebugMessage, ap);

        DbgPrint(buffer);
    }

    va_end(ap);

} // VideoPortDebugPrint()

#if DBG

#define pVideoDebugPrint(arg) VideoPortDebugPrint arg

#else

#define pVideoDebugPrint(arg)

#endif

VOID
pVideoPortMapToNtStatus(
    IN PSTATUS_BLOCK StatusBlock
    )

/*++

Routine Description:

    This function maps a Win32 error code to an NT error code, making sure
    the inverse translation will map back to the original status code.

Arguments:

    StatusBlock - Pointer to the status block

Return Value:

    None.

--*/

{
    PNTSTATUS status = &StatusBlock->Status;

    switch (*status) {

    case ERROR_INVALID_FUNCTION:
        *status = STATUS_NOT_IMPLEMENTED;
        break;

    case ERROR_NOT_ENOUGH_MEMORY:
        *status = STATUS_INSUFFICIENT_RESOURCES;
        break;

    case ERROR_INVALID_PARAMETER:
        *status = STATUS_INVALID_PARAMETER;
        break;

    case ERROR_INSUFFICIENT_BUFFER:
        *status = STATUS_BUFFER_TOO_SMALL;

        //
        // Make sure we zero out the information block if we get an
        // insufficient buffer.
        //

        StatusBlock->Information = 0;
        break;

    case ERROR_MORE_DATA:
        *status = STATUS_BUFFER_OVERFLOW;
        break;

    case ERROR_DEV_NOT_EXIST:
        *status = STATUS_DEVICE_DOES_NOT_EXIST;
        break;

    case ERROR_IO_PENDING:
        ASSERT(FALSE);
        // Fall through.

    case NO_ERROR:
        *status = STATUS_SUCCESS;
        break;

    default:

        ASSERT(FALSE);

        //
        // Since the driver did not see fit to follow the
        // rules about returning correct error codes. Videoprt will do it for
        // them.
        //

        *status = STATUS_UNSUCCESSFUL;

        break;

    }

    return;

} // end pVideoPortMapToNtStatus()

VOID
pVideoPortDpcDispatcher(
    IN PKDPC Dpc,
    IN PVOID HwDeviceExtension,
    IN PVOID DpcRoutine,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine handles DPCs and forwards them to the miniport callback
    routine.

Arguments:

    Dpc - The DPC which is executing.

    HwDeviceExtension - The HwDeviceExtension for the device which scheduled
        the DPC.

    DpcRoutine - The callback in the miniport which needs to be called.

    Context - The miniport supplied context.

Returns:

    None.

--*/

{
    ((PMINIPORT_DPC_ROUTINE)(ULONG_PTR)DpcRoutine)(HwDeviceExtension, Context);
}

BOOLEAN
pVideoPortSynchronizeExecution(
    PVOID HwDeviceExtension,
    VIDEO_SYNCHRONIZE_PRIORITY Priority,
    PMINIPORT_SYNCHRONIZE_ROUTINE SynchronizeRoutine,
    PVOID Context
    )

/*++

Routine Description:

    VideoPortSynchronizeExecution synchronizes the execution of a miniport
    driver function in the following manner:

        - If Priority is equal to VpLowPriority, the current thread is
          raised to the highest non-interrupt-masking priority.  In
          other words, the current thread can only be pre-empted by an ISR.

        - If Priority is equal to VpMediumPriority and there is an
          ISR associated with the video device, then the function specified
          by SynchronizeRoutine is synchronized with the ISR.

          If no ISR is connected, synchronization is made at VpHighPriority
          level.

        - If Priority is equal to VpHighPriority, the current IRQL is
          raised to HIGH_LEVEL, which effectively masks out ALL interrupts
          in the system. This should be done sparingly and for very short
          periods -- it will completely freeze up the entire system.

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

    Priority - Specifies the type of priority at which the SynchronizeRoutine
        must be executed (found in VIDEO_SYNCHRONIZE_PRIORITY).

    SynchronizeRoutine - Points to the miniport driver function to be
        synchronized.

    Context - Specifies a context parameter to be passed to the miniport's
        SynchronizeRoutine.

Return Value:

    This function returns TRUE if the operation is successful.  Otherwise, it
    returns FALSE.

--*/

{
    BOOLEAN status;
    PVIDEO_DEVICE_EXTENSION VideoDeviceExtension;
    KIRQL oldIrql;

    VideoDeviceExtension = VIDEO_GET_VIDEO_DEVICE_EXTENSION(HwDeviceExtension);

    //
    // Switch on which type of priority.
    //

    switch (Priority) {

    case VpMediumPriority:

        //
        // This is synchronized with the interrupt object
        //

        if (VideoDeviceExtension->InterruptObject) {

            status = KeSynchronizeExecution(VideoDeviceExtension->InterruptObject,
                                            (PKSYNCHRONIZE_ROUTINE)
                                            SynchronizeRoutine,
                                            Context);

            ASSERT (status == TRUE);

            return status;
        }

        //
        // Fall through for Medium Priority
        //

    case VpLowPriority:

        //
        // Just normal level
        //

        status = SynchronizeRoutine(Context);

        return status;

    case VpHighPriority:

        //
        // This is like cli\sti where we mask out everything.
        //

        //
        // Get the current IRQL to catch re-entrant routines into synchronize.
        //

        oldIrql = KeGetCurrentIrql();

        if (oldIrql < POWER_LEVEL - 1) {

            KeRaiseIrql(POWER_LEVEL, &oldIrql);

        }

        status = SynchronizeRoutine(Context);

        if (oldIrql < POWER_LEVEL - 1) {

            KeLowerIrql(oldIrql);

        }

        return status;

        break;

    default:

        return FALSE;

    }
}

BOOLEAN
VideoPortResetDisplay(
    IN ULONG Columns,
    IN ULONG Rows
    )
{
    PVOID HwDeviceExtension;

    if (VideoGlobalDeviceExtension == NULL ||
        VideoGlobalDeviceExtension->HwResetHw == NULL) {
        return FALSE;
    }

    HwDeviceExtension = VIDEO_GET_HW_DEVICE_EXTENSION(VideoGlobalDeviceExtension);

    return VideoGlobalDeviceExtension->HwResetHw(HwDeviceExtension, Columns, Rows);
}

BOOLEAN
VideoPortInterrupt(
    IN PKINTERRUPT InterruptObject,
    IN PVOID ServiceContext
    )
{
    BOOLEAN Handled;
    PVIDEO_DEVICE_EXTENSION VideoDeviceExtension;
    PVOID HwDeviceExtension;

    VideoDeviceExtension = (PVIDEO_DEVICE_EXTENSION)ServiceContext;
    HwDeviceExtension = VIDEO_GET_HW_DEVICE_EXTENSION(VideoDeviceExtension);

    if (VideoDeviceExtension->InterruptsEnabled) {
        Handled = VideoDeviceExtension->HwInterrupt(HwDeviceExtension);
    } else {
        Handled = FALSE;
    }

    return Handled;
}

NTSTATUS
VideoPortCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    NTSTATUS status;
    PVIDEO_DEVICE_EXTENSION VideoDeviceExtension;
    PVOID HwDeviceExtension;

    VideoDeviceExtension = (PVIDEO_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
    HwDeviceExtension = VIDEO_GET_HW_DEVICE_EXTENSION(VideoDeviceExtension);

    if (!VideoDeviceExtension->DeviceOpened) {

        //
        // Invoke the miniport's HwInitialize routine.
        //

        if (VideoDeviceExtension->HwInitialize(HwDeviceExtension)) {

            VideoDeviceExtension->DeviceOpened = TRUE;

            status = STATUS_SUCCESS;

        } else {
            status = STATUS_DEVICE_CONFIGURATION_ERROR;
        }

    } else {
        status = STATUS_ACCESS_DENIED;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
VideoPortDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    NTSTATUS status;
    PIO_STACK_LOCATION IrpSp;
    PVIDEO_DEVICE_EXTENSION VideoDeviceExtension;
    PVOID HwDeviceExtension;
    PSTATUS_BLOCK StatusBlock;
    VIDEO_REQUEST_PACKET vrp;

    VideoDeviceExtension = (PVIDEO_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
    HwDeviceExtension = VIDEO_GET_HW_DEVICE_EXTENSION(VideoDeviceExtension);

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    StatusBlock = (PSTATUS_BLOCK)&Irp->IoStatus;

    vrp.IoControlCode = IrpSp->Parameters.DeviceIoControl.IoControlCode;
    vrp.StatusBlock = StatusBlock;
    vrp.InputBuffer = IrpSp->Parameters.DeviceIoControl.InputBuffer;
    vrp.InputBufferLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
    vrp.OutputBuffer = Irp->UserBuffer;
    vrp.OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    ACQUIRE_DEVICE_LOCK(VideoDeviceExtension);

    VideoDeviceExtension->HwStartIO(HwDeviceExtension, &vrp);

    RELEASE_DEVICE_LOCK(VideoDeviceExtension);

    if (StatusBlock->Status != NO_ERROR) {
        pVideoPortMapToNtStatus(StatusBlock);
    }

    status = Irp->IoStatus.Status;

    if (status == STATUS_PENDING) {
        return STATUS_PENDING;
    }

    IoCompleteRequest(Irp, IO_VIDEO_INCREMENT);

    return status;
}

NTSTATUS
VideoPortClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PVIDEO_DEVICE_EXTENSION VideoDeviceExtension;
    PVOID HwDeviceExtension;
    PSTATUS_BLOCK StatusBlock;
    VIDEO_REQUEST_PACKET vrp;

    VideoDeviceExtension = (PVIDEO_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
    HwDeviceExtension = VIDEO_GET_HW_DEVICE_EXTENSION(VideoDeviceExtension);

    StatusBlock = (PSTATUS_BLOCK)&Irp->IoStatus;

    vrp.IoControlCode = IOCTL_VIDEO_RESET_DEVICE;
    vrp.StatusBlock = StatusBlock;
    vrp.InputBuffer = NULL;
    vrp.InputBufferLength = 0;
    vrp.OutputBuffer = NULL;
    vrp.OutputBufferLength = 0;

    VideoDeviceExtension->HwStartIO(HwDeviceExtension, &vrp);

    VideoDeviceExtension->DeviceOpened = FALSE;

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_VIDEO_INCREMENT);

    return STATUS_SUCCESS;
}

ULONG
VideoPortInitialize(
    IN PVOID Argument1,
    IN PVOID Argument2,
    IN PVIDEO_HW_INITIALIZATION_DATA HwInitializationData,
    IN PVOID HwContext
    )
{
    NTSTATUS status;
    PDRIVER_OBJECT DriverObject;
    SYSTEM_BASIC_INFORMATION BasicInformation;
    PCI_SLOT_NUMBER SlotNumber;
    PCI_COMMON_CONFIG Configuration;
    OBJECT_STRING ObjectName;
    PDEVICE_OBJECT DeviceObject;
    PVIDEO_DEVICE_EXTENSION VideoDeviceExtension;
    PVOID HwDeviceExtension;
    PHYSICAL_ADDRESS ApertureBase;
    ULONG ApertureSizeInPages;
    VP_STATUS vpstatus;
    VIDEO_PORT_CONFIG_INFO ConfigInfo;
    UCHAR Again;
    ULONG InterruptVector;
    KIRQL InterruptIrql;

    DriverObject = (PDRIVER_OBJECT)Argument1;

    //
    // Fill in the driver object's dispatch routines.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE] = VideoPortCreate;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = VideoPortDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = VideoPortClose;

    //
    // Figure out how much physical memory is in the system.
    //

    status = NtQuerySystemInformation(SystemBasicInformation, &BasicInformation,
        sizeof(SYSTEM_BASIC_INFORMATION), NULL);

    if (!NT_SUCCESS(status)) {
        return (ULONG)status;
    }

    //
    // Read the PCI configuration data for the adapter attached to the AGP440
    // bus.
    //

    SlotNumber.u.AsULONG = 0;
    SlotNumber.u.bits.DeviceNumber = AGP440_TARGET_DEVICE_NUMBER;
    SlotNumber.u.bits.FunctionNumber = AGP440_TARGET_FUNCTION_NUMBER;

    if (HalGetBusData(PCIConfiguration, 1, SlotNumber.u.AsULONG, &Configuration,
        sizeof(PCI_COMMON_CONFIG)) != sizeof(PCI_COMMON_CONFIG)) {
        return (ULONG)STATUS_DEVICE_DOES_NOT_EXIST;
    }

    //
    // Verify that this looks something like an NVidia display controller and
    // that the configuration is in the state that we expect.
    //

    ASSERT(Configuration.BaseClass == PCI_CLASS_DISPLAY_CTLR);
    ASSERT(Configuration.VendorID == 0x10DE);
    ASSERT(VideoIsFlagSet(Configuration.Command, PCI_ENABLE_IO_SPACE));
    ASSERT(VideoIsFlagSet(Configuration.Command, PCI_ENABLE_BUS_MASTER));

    //
    // Create the device object.
    //

    RtlInitObjectString(&ObjectName, OTEXT("\\Device\\Video0"));

    status = IoCreateDevice(DriverObject, sizeof(VIDEO_DEVICE_EXTENSION) +
        HwInitializationData->HwDeviceExtensionSize, &ObjectName,
        FILE_DEVICE_VIDEO, FILE_DEVICE_SECURE_OPEN, TRUE, &DeviceObject);

    if (!NT_SUCCESS(status)) {
        return (ULONG)status;
    }

    //
    // Initialize the device extension.
    //

    VideoDeviceExtension = (PVIDEO_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
    HwDeviceExtension = VIDEO_GET_HW_DEVICE_EXTENSION(VideoDeviceExtension);

    RtlZeroMemory(VideoDeviceExtension, sizeof(VIDEO_DEVICE_EXTENSION) +
        HwInitializationData->HwDeviceExtensionSize);

    VideoDeviceExtension->HwFindAdapter = HwInitializationData->HwFindAdapter;
    VideoDeviceExtension->HwInitialize = HwInitializationData->HwInitialize;
    VideoDeviceExtension->HwInterrupt = HwInitializationData->HwInterrupt;
    VideoDeviceExtension->HwStartIO = HwInitializationData->HwStartIO;
    VideoDeviceExtension->HwResetHw = HwInitializationData->HwResetHw;
    VideoDeviceExtension->HwTimer = HwInitializationData->HwTimer;

    RtlCopyMemory(VideoDeviceExtension->BaseAddresses, Configuration.u.type0.BaseAddresses,
        sizeof(ULONG) * PCI_TYPE0_ADDRESSES);

#if 0 // NUGOOP

    VideoDeviceExtension->AgpInterface.Size = sizeof(AGP_BUS_INTERFACE_STANDARD);
    VideoDeviceExtension->AgpInterface.Version = AGP_INTERFACE_VERSION;
    VideoDeviceExtension->AgpInterface.AgpContext = VideoDeviceExtension;
    VideoDeviceExtension->AgpInterface.InterfaceReference = AgpInterfaceReference;
    VideoDeviceExtension->AgpInterface.InterfaceDereference = AgpInterfaceDereference;
    VideoDeviceExtension->AgpInterface.ReserveMemory = AgpInterfaceReserveMemory;
    VideoDeviceExtension->AgpInterface.ReleaseMemory = AgpInterfaceReleaseMemory;
    VideoDeviceExtension->AgpInterface.CommitMemory = AgpInterfaceCommitMemory;
    VideoDeviceExtension->AgpInterface.FreeMemory = AgpInterfaceFreeMemory;
    VideoDeviceExtension->AgpInterface.GetMappedPages = AgpInterfaceGetMappedPages;

    ExInitializeFastMutex(&(VideoDeviceExtension->AgpInterfaceLock));

#endif 0

    KeInitializeDpc(&VideoDeviceExtension->Dpc, pVideoPortDpcDispatcher,
        HwDeviceExtension);

    KeInitializeMutex(&VideoDeviceExtension->SyncMutex, 0);

#if 1 // NUGOOP

    if (!AgpUmaEnable())
    {
        IoDeleteDevice(DeviceObject);
        return (ULONG)STATUS_UNSUCCESSFUL;
    }

#else 

    //
    // Initialize the AGP440.
    //

    status = AgpInitializeTarget(&VideoDeviceExtension->Agp440Extension);

    if (!NT_SUCCESS(status)) {
        IoDeleteDevice(DeviceObject);
        return (ULONG)status;
    }

    status = AgpInitializeMaster(&VideoDeviceExtension->Agp440Extension,
        &(VideoDeviceExtension->AgpInterface.Capabilities));

    if (!NT_SUCCESS(status)) {
        IoDeleteDevice(DeviceObject);
        return (ULONG)status;
    }

    //
    // Query the current AGP aperture and immediately write it back out to the
    // hardware.  This is done to ensure that the AGP440 extension has all of
    // its fields set up properly.
    //

    status = AgpQueryAperture(&VideoDeviceExtension->Agp440Extension,
        &ApertureBase, &ApertureSizeInPages, NULL);

    if (!NT_SUCCESS(status)) {
        IoDeleteDevice(DeviceObject);
        return (ULONG)status;
    }

    status = AgpSetAperture(&VideoDeviceExtension->Agp440Extension, ApertureBase,
        ApertureSizeInPages);

    if (!NT_SUCCESS(status)) {
        IoDeleteDevice(DeviceObject);
        return (ULONG)status;
    }

#endif

    //
    // Invoke the miniport's HwFindAdapter routine.
    //

    RtlZeroMemory(&ConfigInfo, sizeof(VIDEO_PORT_CONFIG_INFO));

    ConfigInfo.Length = sizeof(VIDEO_PORT_CONFIG_INFO);
    ConfigInfo.BusInterruptLevel = 0xFF;
    ConfigInfo.BusInterruptVector = 0xFF;
    ConfigInfo.SystemMemorySize = /*(ULONGLONG)*/BasicInformation.NumberOfPhysicalPages << PAGE_SHIFT;

    vpstatus = VideoDeviceExtension->HwFindAdapter(HwDeviceExtension, NULL,
        NULL, &ConfigInfo, &Again);

    if (vpstatus != NO_ERROR) {
        IoDeleteDevice(DeviceObject);
        return (ULONG)STATUS_DEVICE_DOES_NOT_EXIST;
    }

    //
    // Connect to the device's interrupt.
    //

    if (VideoDeviceExtension->HwInterrupt != NULL) {

        VideoDeviceExtension->InterruptsEnabled = TRUE;

        InterruptVector = HalGetInterruptVector(PCIBus, 0,
            Configuration.u.type0.InterruptLine, Configuration.u.type0.InterruptLine,
            &InterruptIrql);

        status = IoConnectInterrupt(&(VideoDeviceExtension->InterruptObject),
            VideoPortInterrupt, VideoDeviceExtension, InterruptVector,
            InterruptIrql, InterruptIrql, LevelSensitive, TRUE);

        if (!NT_SUCCESS(status)) {
            IoDeleteDevice(DeviceObject);
            return (ULONG)status;
        }
    }

    //
    // Initialize the timer if the miniport requests one.  If this fails, then
    // ignore the error.  This is the same as the old videoprt.sys.
    //

#if 0
    if (VideoDeviceExtension->HwTimer != NULL) {
        IoInitializeTimer(DeviceObject, pVideoPortHwTimer, NULL);
    }
#endif

    //
    // There are some callbacks that don't pass a context parameter, so we need
    // to do this hack of storing our device extension in a global location.
    //

    ASSERT(VideoGlobalDeviceExtension == NULL);
    VideoGlobalDeviceExtension = VideoDeviceExtension;

    //
    // The device has finished initializing and is ready to accept requests.
    //

    DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    return (ULONG)STATUS_SUCCESS;
}

PVOID
VideoPortGetAssociatedDeviceExtension(
    IN PVOID DeviceObject
    )
{
    PVIDEO_DEVICE_EXTENSION VideoDeviceExtension;

    VideoDeviceExtension =
        (PVIDEO_DEVICE_EXTENSION)((PDEVICE_OBJECT)DeviceObject)->DeviceExtension;

    return VIDEO_GET_HW_DEVICE_EXTENSION(VideoDeviceExtension);
}

ULONG
VideoPortGetBusData(
    PVOID HwDeviceExtension,
    IN BUS_DATA_TYPE BusDataType,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
{
    ASSERT(BusDataType == PCIConfiguration);

    return HalGetBusDataByOffset(PCIConfiguration, 1, SlotNumber, Buffer,
        Offset, Length);
}

ULONG
VideoPortSetBusData(
    PVOID HwDeviceExtension,
    IN BUS_DATA_TYPE BusDataType,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
{
    ASSERT(BusDataType == PCIConfiguration);

    return HalSetBusDataByOffset(PCIConfiguration, 1, SlotNumber, Buffer,
        Offset, Length);
}

VP_STATUS
VideoPortGetAccessRanges(
    PVOID HwDeviceExtension,
    ULONG NumRequestedResources,
    PIO_RESOURCE_DESCRIPTOR RequestedResources OPTIONAL,
    ULONG NumAccessRanges,
    PVIDEO_ACCESS_RANGE AccessRanges,
    PVOID VendorId,
    PVOID DeviceId,
    PULONG Slot
    )
{
    PVIDEO_DEVICE_EXTENSION VideoDeviceExtension;
    ULONG Index;
    PCI_SLOT_NUMBER SlotNumber;

    VideoDeviceExtension = VIDEO_GET_VIDEO_DEVICE_EXTENSION(HwDeviceExtension);

    RtlZeroMemory(AccessRanges, sizeof(VIDEO_ACCESS_RANGE) * NumAccessRanges);

    if (NumAccessRanges > PCI_TYPE0_ADDRESSES) {
        NumAccessRanges = PCI_TYPE0_ADDRESSES;
    }

    for (Index = 0; Index < NumAccessRanges; Index++) {

        //
        // NVidia uses only addresses in the memory space, so don't bother to
        // handle port space.
        //

        ASSERT(VideoIsFlagClear(VideoDeviceExtension->BaseAddresses[Index],
            PCI_ADDRESS_IO_SPACE));

        //
        // NVidia only cares about seeing the base address, so don't bother
        // computing the length of the PCI BAR or any of the other attributes in
        // the VIDEO_ACCESS_RANGE.
        //

        AccessRanges[Index].RangeStart.QuadPart =
            (ULONGLONG)VideoDeviceExtension->BaseAddresses[Index] & PCI_ADDRESS_MEMORY_ADDRESS_MASK;
    }

    //
    // Fill in the PCI slot number for the display adapter.
    //

    SlotNumber.u.AsULONG = 0;
    SlotNumber.u.bits.DeviceNumber = AGP440_TARGET_DEVICE_NUMBER;
    SlotNumber.u.bits.FunctionNumber = AGP440_TARGET_FUNCTION_NUMBER;

    *Slot = SlotNumber.u.AsULONG;

    return NO_ERROR;
}

VP_STATUS
VideoPortGetRegistryParameters(
    PVOID HwDeviceExtension,
    PWSTR ParameterName,
    UCHAR IsParameterFileName,
    PMINIPORT_GET_REGISTRY_ROUTINE CallbackRoutine,
    PVOID Context
    )
{
    ASSERT(!IsParameterFileName);

//    VideoDbgPrint(("VideoPortGetRegistryParameters(%ws)\n", ParameterName));

    return ERROR_INVALID_PARAMETER;
}

VP_STATUS
VideoPortSetRegistryParameters(
    PVOID HwDeviceExtension,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    )
{
//    VideoDbgPrint(("VideoPortSetRegistryParameters(%ws)\n", ValueName));

    return NO_ERROR;
}

BOOLEAN
VideoPortDDCMonitorHelper(
    IN PVOID pHwDeviceExtension,
    IN PVOID pDDCControl,
    IN OUT PUCHAR pucEdidBuffer,
    IN ULONG ulEdidBufferSize
    )
{
    //
    // The NVidia driver only tries to call this if we ask to enumerate the
    // devices attached to it (as in the monitor).  We won't do that, so don't
    // bother to implement this.
    //

    return FALSE;
}

BOOLEAN
VideoPortSynchronizeExecution(
    PVOID HwDeviceExtension,
    VIDEO_SYNCHRONIZE_PRIORITY Priority,
    PMINIPORT_SYNCHRONIZE_ROUTINE SynchronizeRoutine,
    PVOID Context
    )
{
    return pVideoPortSynchronizeExecution(HwDeviceExtension, Priority,
        SynchronizeRoutine, Context);
}

PVOID
VideoPortGetDeviceBase(
    IN PVOID HwDeviceExtension,
    IN PHYSICAL_ADDRESS IoAddress,
    IN ULONG NumberOfUchars,
    IN UCHAR InIoSpace
    )
{
    PVIDEO_DEVICE_EXTENSION VideoDeviceExtension;
    MEMORY_CACHING_TYPE CacheType;
    PVOID MappedAddress;
    ULONG Index;

    VideoDeviceExtension = VIDEO_GET_VIDEO_DEVICE_EXTENSION(HwDeviceExtension);

    if ((InIoSpace & VIDEO_MEMORY_SPACE_P6CACHE) != 0) {
        CacheType = MmWriteCombined;
    } else {
        CacheType = MmNonCached;
    }

    MappedAddress = MmMapIoSpace(IoAddress.LowPart, NumberOfUchars, CacheType);

    if (MappedAddress == NULL) {
        return NULL;
    }

    //
    // MmUnmapIoSpace requires the size of the mapping and the miniport doesn't
    // pass that to VideoPortFreeDeviceBase, so we need to store the size in the
    // device extension.
    //

    for (Index = 0; Index < NUMBER_OF_VIDEO_MAPPED_ADDRESSES; Index++) {

        if (VideoDeviceExtension->MappedAddresses[Index].MappedAddress == NULL) {

            VideoDeviceExtension->MappedAddresses[Index].MappedAddress = MappedAddress;
            VideoDeviceExtension->MappedAddresses[Index].NumberOfUchars = NumberOfUchars;
            break;
        }
    }

    //
    // If we can't find a free slot for the entry, give up and let the mapping
    // leak.
    //

    ASSERT(Index < NUMBER_OF_VIDEO_MAPPED_ADDRESSES);

    return MappedAddress;
}

VOID
VideoPortFreeDeviceBase(
    IN PVOID HwDeviceExtension,
    IN PVOID MappedAddress
    )
{
    PVIDEO_DEVICE_EXTENSION VideoDeviceExtension;
    ULONG Index;

    VideoDeviceExtension = VIDEO_GET_VIDEO_DEVICE_EXTENSION(HwDeviceExtension);

    for (Index = 0; Index < NUMBER_OF_VIDEO_MAPPED_ADDRESSES; Index++) {

        if (VideoDeviceExtension->MappedAddresses[Index].MappedAddress == MappedAddress) {

            MmUnmapIoSpace(MappedAddress,
                VideoDeviceExtension->MappedAddresses[Index].NumberOfUchars);

            VideoDeviceExtension->MappedAddresses[Index].MappedAddress = NULL;
            break;
        }
    }

    ASSERT(Index < NUMBER_OF_VIDEO_MAPPED_ADDRESSES);
}

VP_STATUS
VideoPortAllocateBuffer(
    IN PVOID HwDeviceExtension,
    IN ULONG Size,
    OUT PVOID *Buffer
    )
{
    ASSERT(Size != 0);

    *Buffer = ExAllocatePoolWithTag(PagedPool, Size, 'xdiV');

    return (*Buffer != NULL) ? NO_ERROR : ERROR_NOT_ENOUGH_MEMORY;
}

VOID
VideoPortReleaseBuffer(
    IN PVOID HwDeviceExtension,
    IN PVOID Buffer
    )
{
    if (Buffer != NULL) {
        ExFreePool(Buffer);
    }
}

VP_STATUS
VideoPortMapMemory(
    PVOID HwDeviceExtension,
    PHYSICAL_ADDRESS PhysicalAddress,
    PULONG Length,
    PULONG InIoSpace,
    PVOID *VirtualAddress
    )
{
    *VirtualAddress = VideoPortGetDeviceBase(HwDeviceExtension, PhysicalAddress,
        *Length, (UCHAR)*InIoSpace);

    return (*VirtualAddress != NULL) ? NO_ERROR : ERROR_NOT_ENOUGH_MEMORY;
}

VP_STATUS
VideoPortUnmapMemory(
    PVOID HwDeviceExtension,
    PVOID VirtualAddress,
    HANDLE ProcessHandle
    )
{
    VideoPortFreeDeviceBase(HwDeviceExtension, VirtualAddress);

    return NO_ERROR;
}

BOOLEAN
VideoPortQueueDpc(
    IN PVOID HwDeviceExtension,
    IN PMINIPORT_DPC_ROUTINE CallbackRoutine,
    IN PVOID Context
    )
{
    PVIDEO_DEVICE_EXTENSION VideoDeviceExtension;

    VideoDeviceExtension = VIDEO_GET_VIDEO_DEVICE_EXTENSION(HwDeviceExtension);

    return KeInsertQueueDpc(&VideoDeviceExtension->Dpc,
        (PVOID)(ULONG_PTR)CallbackRoutine, (PVOID)Context);
}

VP_STATUS
VideoPortInt10(
    PVOID HwDeviceExtension,
    PVIDEO_X86_BIOS_ARGUMENTS BiosArguments
    )
{
    return ERROR_NOT_ENOUGH_MEMORY;
}

VP_STATUS
VideoPortSetTrappedEmulatorPorts(
    PVOID HwDeviceExtension,
    ULONG NumAccessRanges,
    PVIDEO_ACCESS_RANGE AccessRange
    )
{
    return NO_ERROR;
}


VIDEOPORT_API
VOID
VideoPortStartTimer(
    PVOID HwDeviceExtension
    )
{
    //
    // The NVIDIA driver tries to call this only for cursors.  Since
    // we're not using cursors (yet), it's safe to fail this.
    //
}

VIDEOPORT_API
VOID
VideoPortStopTimer(
    PVOID HwDeviceExtension
    )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\dll\makefile.inc ===
# obj\$(TARGET_DIRECTORY)\xapi.def: xapi.src
#     $(TARGET_CPP) /EP $(CDEFINES) xapi.src > obj\$(TARGET_DIRECTORY)\xapi.def

$(XDK_LIB_PATH)\$(TARGETNAME).lib: $(SDK_LIB_PATH)\$(TARGETNAME).lib
    copy $** $@

# $(XDK_LIB_PATH)\$(TARGETNAME)lib$(D).lib: $(SDK_LIB_PATH)\$(TARGETNAME)lib$(D).lib
#     copy $** $@

xapiw0.c : xapi0.c

xapiwin0.c : xapi0.c

xapiwwin0.c : xapi0.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\dll\xapi0dat.c ===
/*
 *
 * xapi0dat.c
 *
 * Xapi initializers
 *
 */

#include "dllp.h"

typedef void (__cdecl *PVFV)(void);
typedef int (__cdecl *PIFV)(void);

#pragma data_seg(".CRT$XCA")
PVFV __xc_a[] = { NULL };

#pragma data_seg(".CRT$XCZ")
PVFV __xc_z[] = { NULL };

#pragma data_seg(".CRT$XIA")
PIFV __xi_a[] = { NULL };

#pragma data_seg(".CRT$XIZ")
PIFV __xi_z[] = { NULL };

#pragma data_seg(".CRT$RIA")
PIFV __xri_a[] = { NULL };

#pragma data_seg(".CRT$RIZ")
PIFV __xri_z[] = { NULL };

#ifdef _DEBUG
#pragma data_seg(".CRT$RII15")
extern int __cdecl _RTC_Initialize(void);
void *__rtc_init = _RTC_Initialize;
#endif


#pragma data_seg()

PVFV _FPinit;

#pragma comment(linker, "/merge:.CRT=.data")

static void _initterm(PVFV *a, PVFV *z)
{
	for(; a < z; ++a)
		if(*a != NULL && *a != (PVFV)-1)
			(**a)();
}

static void _initterm_e(PIFV *a, PIFV *z)
{
	for(; a < z; ++a) {
		if(*a != NULL && *a != (PIFV)-1)
			if(0 != (**a)()) {
                RIP("Runtime initialization failed!");
            }
    }
}

void _cinit(void)
{
	/* Init floating point */
	if(_FPinit)
		(*_FPinit)();

	/* Do the initializers */
	_initterm_e(__xi_a, __xi_z);

	/* Now do the constructors */
	_initterm(__xc_a, __xc_z);
}

void _rtinit(void)
{
	/* Do the CRT initializers */
	_initterm_e(__xri_a, __xri_z);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\dll\xapiinit.c ===
/*++

Copyright (c) 1999-2002  Microsoft Corporation

Module Name:

    init.c

Abstract:

    Initialization code for the win32 api equivalents in kernel mode for xbox

--*/

#include "dllp.h"
#include <xboxverp.h>

#define DASHBOARD_TITLE_ID   0xFFFE0000

#define ARRAYSIZE(a) (sizeof(a) / sizeof(a[0]))

#include "xmeta.h"

COBJECT_STRING DDrive      = CONSTANT_OBJECT_STRING( OTEXT("\\??\\D:") );
COBJECT_STRING CdDevice    = CONSTANT_OBJECT_STRING( OTEXT("\\Device\\CdRom0") );
COBJECT_STRING MainVol     = CONSTANT_OBJECT_STRING( OTEXT("\\Device\\Harddisk0\\partition1\\") );
COBJECT_STRING TDrive      = CONSTANT_OBJECT_STRING( OTEXT("\\??\\T:") );
COBJECT_STRING TitleData   = CONSTANT_OBJECT_STRING( OTEXT("\\Device\\Harddisk0\\partition1\\TDATA") );
COBJECT_STRING UDrive      = CONSTANT_OBJECT_STRING( OTEXT("\\??\\U:") );
COBJECT_STRING UserData    = CONSTANT_OBJECT_STRING( OTEXT("\\Device\\Harddisk0\\partition1\\UDATA") );

NTSTATUS
XapiValidateDiskPartition(
    POBJECT_STRING PartitionName
    )
{
    return XapiValidateDiskPartitionEx(PartitionName, 16384);
}

NTSTATUS
XapiValidateDiskPartitionEx(
    POBJECT_STRING PartitionName,
    ULONG BytesPerCluster
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_FS_SIZE_INFORMATION SizeInfo;

    InitializeObjectAttributes(
        &Obja,
        PartitionName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Open the partition
    //

    Status = NtOpenFile(
                &Handle,
                (ACCESS_MASK)FILE_LIST_DIRECTORY | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE | FILE_OPEN_FOR_FREE_SPACE_QUERY
                );

    if (NT_SUCCESS(Status))
    {
        //
        // Determine the size parameters of the volume.
        //

        Status = NtQueryVolumeInformationFile(
                    Handle,
                    &IoStatusBlock,
                    &SizeInfo,
                    sizeof(SizeInfo),
                    FileFsSizeInformation
                    );

        NtClose(Handle);

        if (NT_SUCCESS(Status))
        {
            if (SizeInfo.BytesPerSector * SizeInfo.SectorsPerAllocationUnit !=
                BytesPerCluster)
            {
                Status = STATUS_UNRECOGNIZED_VOLUME;
            }
        }
    }

    return Status;
}

NTSTATUS
XapiCopySectionToFile(
    HANDLE SectionHandle,
    PSTR pszPathBuffer,
    UINT cchPathBuffer,
    PCSTR pcszFileName
    )
{
    OBJECT_STRING MetaFilePathString;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    HANDLE MetaHandle;
    int nPathLen;

    ASSERT((INVALID_HANDLE_VALUE != SectionHandle) && pszPathBuffer && pcszFileName);

    nPathLen = ocslen(pszPathBuffer);

    lstrcpynO(&(pszPathBuffer[nPathLen]),
              pcszFileName,
              cchPathBuffer - nPathLen);

    RtlInitObjectString(&MetaFilePathString, pszPathBuffer);

    InitializeObjectAttributes(
        &Obja,
        &MetaFilePathString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtCreateFile(&MetaHandle,
                          SYNCHRONIZE | GENERIC_WRITE,
                          &Obja,
                          &IoStatusBlock,
                          NULL,
                          FILE_ATTRIBUTE_SYSTEM,
                          FILE_SHARE_READ,
                          FILE_OPEN_IF,
                          FILE_WRITE_THROUGH | FILE_SYNCHRONOUS_IO_NONALERT
                          );

    pszPathBuffer[nPathLen] = OBJECT_NULL;

    if (NT_SUCCESS(Status))
    {
        FILE_NETWORK_OPEN_INFORMATION NetworkInfo;

        Status = NtQueryInformationFile(
                    MetaHandle,
                    &IoStatusBlock,
                    &NetworkInfo,
                    sizeof(NetworkInfo),
                    FileNetworkOpenInformation
                    );

        if (NT_SUCCESS(Status))
        {
            //
            // Only write if this is an empty file (first creation or first time
            // after an invalid, failed creation)
            //

            if (0 == NetworkInfo.EndOfFile.QuadPart)
            {
                PBYTE pbSection;

                //
                // Attempt to load the title info section
                //

                pbSection = XLoadSectionByHandle(SectionHandle);

                if (pbSection)
                {
                    Status = NtWriteFile(MetaHandle,
                                         NULL,
                                         NULL,
                                         NULL,
                                         &IoStatusBlock,
                                         pbSection,
                                         XGetSectionSize(SectionHandle),
                                         NULL
                                         );

                    if (!NT_SUCCESS(Status))
                    {
                        XDBGWRN("XAPI", "XapiCopySectionToFile() failed to write to file");
                    }

                    //
                    // Unload the title info section (we're done with it)
                    //

                    XFreeSectionByHandle(SectionHandle);
                }
            }
        }
        else
        {
            XDBGERR("XAPI", "XapiCopySectionToFile() failed to get meta file size");
        }

        NtClose(MetaHandle);
    }
    else if (STATUS_OBJECT_NAME_COLLISION == Status)
    {
        //
        // If the meta data image file already exists, we should continue
        // as if everything is fine (no need to rewrite this data)
        //

        Status = STATUS_SUCCESS;
    }

    return Status;
}


NTSTATUS
XapiMapLetterToDirectory(
    PCOBJECT_STRING pcDriveString,
    PCOBJECT_STRING pcPathString,
    PCOSTR pcszTitleId,
    BOOL fCreateDirectory,
    LPCWSTR pcszTitleName,
    BOOL fUpdateTimestamp
    )
{
    NTSTATUS Status;
    OCHAR szPathTemp[MAX_PATH];
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_STRING PerTitlePathString;
    HANDLE DirHandle;

    ASSERT(pcDriveString && pcPathString && pcszTitleId);

    InitializeObjectAttributes(
        &Obja,
        (POBJECT_STRING) pcPathString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );


    //
    //  The parent of the subirectory may not already exist
    //  so we open it first with 'FILE_OPEN_IF' to create it,
    //  just in case.  This mainly occurs when running
    //  recovery.
    //

    Status = NtCreateFile(
                &DirHandle,
                FILE_LIST_DIRECTORY | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_OPEN_IF,
                FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                );

    if (NT_SUCCESS(Status))
    {
        NtClose(DirHandle);
    }
    else if (STATUS_NOT_A_DIRECTORY == Status)
    {
        //
        //  XMountAlternateTitle when called on an MU passes a volume (not the
        //  volume's root directory) for pcDriveString.  So the above call will
        //  fail with STATUS_NOT_A_DIRECTORY.  This is OK though, so we change
        //  to success and continue.  Note that if we remove FILE_DIRECTORY_FILE
        //  from the above NtCreateFile, then recovery creates a file named UDATA
        //  instead of a directory and promptly crashes.
        //
        Status = STATUS_SUCCESS;
    }
    else
    {
        XDBGWRN("XAPI",
                "XapiMapLetterToDirectory(): NtCreateFile() \"%Z\" failed with 0x%08x",
                pcPathString,
                Status);
    }

    if (NT_SUCCESS(Status))
    {
        ASSERT(ocslen(pcszTitleId) < CCHMAX_HEX_DWORD);
        ASSERT(pcPathString->Length < (sizeof(szPathTemp) - (CCHMAX_HEX_DWORD * sizeof(OCHAR))));
        ocscpy(szPathTemp, pcPathString->Buffer);
        //
        //  Usually, pcDriveString usually does not have a '\\' on the end, the exception
        //  is on mounting MU's.  So here we check for '\\' and only append if necessary.
        //
        if(szPathTemp[(pcPathString->Length / sizeof(OCHAR))-1] != OTEXT('\\'))
        {
            szPathTemp[pcPathString->Length / sizeof(OCHAR)] = OTEXT('\\');
        } else
        {
            pcPathString->Length--;
        }
        ocscpy(&(szPathTemp[(pcPathString->Length + sizeof(OCHAR)) / sizeof(OCHAR)]), pcszTitleId);

        RtlInitObjectString(&PerTitlePathString, szPathTemp);

        InitializeObjectAttributes(
            &Obja,
            &PerTitlePathString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

        Status = NtCreateFile(
                    &DirHandle,
                    FILE_LIST_DIRECTORY | SYNCHRONIZE | FILE_GENERIC_WRITE,
                    &Obja,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    fCreateDirectory ? FILE_OPEN_IF : FILE_OPEN,
                    FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                    );

        if (NT_SUCCESS(Status))
        {
            if (fUpdateTimestamp)
            {
                FILE_BASIC_INFORMATION BasicInfo;

                //
                // Zero all the time values we can set.
                //

                RtlZeroMemory(&BasicInfo, sizeof(BasicInfo));

                //
                // Set the last write times
                //

                KeQuerySystemTime(&BasicInfo.LastWriteTime);

                NtSetInformationFile(
                            DirHandle,
                            &IoStatusBlock,
                            &BasicInfo,
                            sizeof(BasicInfo),
                            FileBasicInformation
                            );
            }

            //
            // Only attempt to write meta data if non-null titlename and pubname strings were passed in
            // (these are not passed in if we're mounting another title's drive)
            //

            if (pcszTitleName)
            {
                HANDLE TitleInfoSection;
                HANDLE TitleImageSection;
                HANDLE SaveImageSection;

                TitleInfoSection = XGetSectionHandle("$$XTINFO");
                TitleImageSection = XGetSectionHandle("$$XTIMAGE");
                SaveImageSection = XGetSectionHandle("$$XSIMAGE");

                if ((INVALID_HANDLE_VALUE != TitleInfoSection) ||
                    (L'\0' != *pcszTitleName))
                {
                    //
                    // Create TITLEMETA.XBX file underneath the save game directory and
                    // write metadata information there
                    //

                    OBJECT_STRING MetaFilePathString;
                    HANDLE MetaHandle;
                    int nPathLen = ocslen(szPathTemp);

                    lstrcpynO(&(szPathTemp[nPathLen]),
                              g_cszTitleMetaFileName,
                              ARRAYSIZE(szPathTemp) - nPathLen);

                    RtlInitObjectString(&MetaFilePathString, szPathTemp);

                    InitializeObjectAttributes(
                        &Obja,
                        &MetaFilePathString,
                        OBJ_CASE_INSENSITIVE,
                        NULL,
                        NULL
                        );

                    Status = NtCreateFile(&MetaHandle,
                                          SYNCHRONIZE | GENERIC_WRITE,
                                          &Obja,
                                          &IoStatusBlock,
                                          NULL,
                                          FILE_ATTRIBUTE_SYSTEM,
                                          FILE_SHARE_READ,
                                          FILE_OPEN_IF,
                                          FILE_WRITE_THROUGH | FILE_SYNCHRONOUS_IO_NONALERT
                                          );

                    szPathTemp[nPathLen] = OBJECT_NULL;

                    if (NT_SUCCESS(Status))
                    {
                        FILE_NETWORK_OPEN_INFORMATION NetworkInfo;

                        Status = NtQueryInformationFile(
                                    MetaHandle,
                                    &IoStatusBlock,
                                    &NetworkInfo,
                                    sizeof(NetworkInfo),
                                    FileNetworkOpenInformation
                                    );

                        if (NT_SUCCESS(Status))
                        {
                            //
                            // Only write if this is an empty file (first creation or first time
                            // after an invalid, failed creation)
                            //

                            if (0 == NetworkInfo.EndOfFile.QuadPart)
                            {
                                PVOID pvTitleInfo = NULL;

                                //
                                // Attempt to load the title info section
                                //

                                if (INVALID_HANDLE_VALUE != TitleInfoSection)
                                {
                                    pvTitleInfo = XLoadSectionByHandle(TitleInfoSection);
                                }

                                if (pvTitleInfo)
                                {
                                    //
                                    // Write TITLEMETA.XBX as a copy of the title info section
                                    //

                                    Status = NtWriteFile(MetaHandle,
                                                         NULL,
                                                         NULL,
                                                         NULL,
                                                         &IoStatusBlock,
                                                         pvTitleInfo,
                                                         XGetSectionSize(TitleInfoSection),
                                                         NULL
                                                         );

                                    if (!NT_SUCCESS(Status))
                                    {
                                        XDBGWRN("XAPI", "XapiMapLetterToDirectory() failed to write title info file");
                                    }

                                    XFreeSectionByHandle(TitleInfoSection);
                                }
                                else
                                {
                                    //
                                    // Write TITLEMETA.XBX with the title name value from the cert
                                    //

                                    //
                                    // szBuffer size is: 1 signature WCHAR plus one line of metadata
                                    //

                                    WCHAR szBuffer[1 + MAX_METADATA_LINE];
                                    DWORD dwSize;

                                    dwSize = _snwprintf(szBuffer,
                                                        ARRAYSIZE(szBuffer),
                                                        L"%lc%ls%lc%ls%ls",
                                                        g_chUnicodeSignature,
                                                        g_cszTitleNameTag,
                                                        g_chEqual,
                                                        pcszTitleName,
                                                        g_cszCRLF);
                                    dwSize *= sizeof(WCHAR);

                                    Status = NtWriteFile(MetaHandle,
                                                         NULL,
                                                         NULL,
                                                         NULL,
                                                         &IoStatusBlock,
                                                         szBuffer,
                                                         dwSize,
                                                         NULL
                                                         );

                                    if (!NT_SUCCESS(Status))
                                    {
                                        XDBGWRN("XAPI", "XapiMapLetterToDirectory() failed to write title info file");
                                    }
                                }
                            }
                        }
                        else
                        {
                            XDBGERR("XAPI", "XapiMapLetterToDirectory() failed to get meta file size");
                        }

                        NtClose(MetaHandle);
                    }
                    else if (STATUS_OBJECT_NAME_COLLISION == Status)
                    {
                        //
                        // If the meta data file already exists, we should continue
                        // as if everything is fine (no need to rewrite this data)
                        //

                        Status = STATUS_SUCCESS;
                    }
                }

                if (NT_SUCCESS(Status) && (INVALID_HANDLE_VALUE != TitleImageSection))
                {
                    Status = XapiCopySectionToFile(TitleImageSection,
                                                   szPathTemp,
                                                   ARRAYSIZE(szPathTemp),
                                                   g_cszTitleImageFileName);
                }

                if (NT_SUCCESS(Status) && (INVALID_HANDLE_VALUE != SaveImageSection))
                {
                    Status = XapiCopySectionToFile(SaveImageSection,
                                                   szPathTemp,
                                                   ARRAYSIZE(szPathTemp),
                                                   g_cszSaveImageFileName);
                }
            }

            NtClose(DirHandle);
        }
        else if (fCreateDirectory)
        {
            XDBGWRN("XAPI",
                    "XapiMapLetterToDirectory(): NtCreateFile() \"%s\" failed with 0x%08x",
                    szPathTemp,
                    Status);
        }
    }

    if (NT_SUCCESS(Status))
    {
        Status = IoCreateSymbolicLink((POBJECT_STRING) pcDriveString, &PerTitlePathString);

        if (!NT_SUCCESS(Status))
        {
            XDBGERR("XAPI",
                    "XapiMapLetterToDirectory(): IoCreateSymbolicLink() failed \"%Z\"->\"%Z\"",
                    pcDriveString,
                    pcPathString);
        }
    }

    return Status;
}

NTSTATUS
XapiSetupPerTitleDriveLetters(
    DWORD dwTitleId,
    LPCWSTR pcszTitleName
    )
{
    NTSTATUS Status;
    OCHAR szTitleId[CCHMAX_HEX_DWORD];

    DwordToStringO(dwTitleId, szTitleId);

    Status = XapiMapLetterToDirectory(&TDrive,
                                      &TitleData,
                                      szTitleId,
                                      TRUE,
                                      NULL,
                                      FALSE);

    if (NT_SUCCESS(Status))
    {
        Status = XapiMapLetterToDirectory(&UDrive,
                                          &UserData,
                                          szTitleId,
                                          TRUE,
                                          pcszTitleName,
                                          FALSE);
    }

    return Status;
}

VOID
XapiBootToDash(
    DWORD dwReason,
    DWORD dwParameter1,
    DWORD dwParameter2
    )
{
    if (DASHBOARD_TITLE_ID != XeImageHeader()->Certificate->TitleID)
    {
        LD_LAUNCH_DASHBOARD LaunchDash;

        ZeroMemory(&LaunchDash, sizeof(LD_LAUNCH_DASHBOARD));

        LaunchDash.dwReason = dwReason;
        LaunchDash.dwContext = 0;
        LaunchDash.dwParameter1 = dwParameter1;
        LaunchDash.dwParameter2 = dwParameter2;

        XLaunchNewImage(NULL, (PLAUNCH_DATA) &LaunchDash);
    }
    else
    {
        //
        // Display Universal Error Message
        //

        HalReturnToFirmware(HalFatalErrorRebootRoutine);
    }
}

//
// Macros to swap the byte order of a USHORT or ULONG at compile time.
//

#define XapiConstantUshortByteSwap(ushort) \
    ((((USHORT)ushort) >> 8) + ((((USHORT)ushort) & 0x00FF) << 8))

#define XapiConstantUlongByteSwap(ulong) \
    ((((ULONG)ulong) >> 24) + ((((ULONG)ulong) & 0x00FF0000) >> 8) + \
    ((((ULONG)ulong) & 0x0000FF00) << 8) + ((((ULONG)ulong) & 0x000000FF) << 24))


NTSTATUS
XapiVerifyMediaInDrive(
    VOID
    )
/*++

Routine Description:

    Verifies that the DVD drive has in fact authenticated X2 media.

Arguments:

    None.

Return Value:

    None.

--*/

{
    NTSTATUS status;
    SCSI_PASS_THROUGH_DIRECT PassThrough;
    PCDB Cdb = (PCDB)&PassThrough.Cdb;
    DVDX2_AUTHENTICATION Authentication;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    IO_STATUS_BLOCK IoStatusBlock;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    InitializeObjectAttributes(
        &Obja,
        (POBJECT_STRING) &CdDevice,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Open the CD/DVD device
    //

    status = NtOpenFile(
                &Handle,
                (ACCESS_MASK) GENERIC_READ | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ,
                FILE_SYNCHRONOUS_IO_NONALERT
                );

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Prepare the SCSI pass through structure.
    //

    RtlZeroMemory(&PassThrough, sizeof(SCSI_PASS_THROUGH_DIRECT));

    PassThrough.Length = sizeof(SCSI_PASS_THROUGH_DIRECT);

    //
    // Request the authentication page from the DVD-X2 drive.
    //

    PassThrough.DataIn = SCSI_IOCTL_DATA_IN;
    PassThrough.DataBuffer = &Authentication;
    PassThrough.DataTransferLength = sizeof(DVDX2_AUTHENTICATION);

    RtlZeroMemory(Cdb, sizeof(CDB));

    Cdb->MODE_SENSE10.OperationCode = SCSIOP_MODE_SENSE10;
    Cdb->MODE_SENSE10.PageCode = DVDX2_MODE_PAGE_AUTHENTICATION;
    *((PUSHORT)&Cdb->MODE_SENSE10.AllocationLength) =
        (USHORT)XapiConstantUshortByteSwap(sizeof(DVDX2_AUTHENTICATION));

    RtlZeroMemory(&Authentication, sizeof(DVDX2_AUTHENTICATION));

    status = NtDeviceIoControlFile(Handle,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &IoStatusBlock,
                                   IOCTL_SCSI_PASS_THROUGH_DIRECT,
                                   &PassThrough,
                                   sizeof(SCSI_PASS_THROUGH_DIRECT),
                                   NULL,
                                   0);

    NtClose(Handle);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Check if the DVD-X2 drive thinks that this is a valid CDF header.
    //

    if (Authentication.AuthenticationPage.CDFValid != DVDX2_CDF_VALID) {
        return STATUS_UNRECOGNIZED_MEDIA;
    }

    //
    // Check if the DVD-X2 drive already thinks that we're authenticated.
    //

    if ((Authentication.AuthenticationPage.PartitionArea != 0) &&
        (Authentication.AuthenticationPage.Authentication != 0)) {
        return STATUS_SUCCESS;
    }

    //
    // The DVD-X2 drive does not think that we're authenticated.
    //

    return STATUS_UNSUCCESSFUL;
}


VOID
XapiInitProcess(
    VOID
    )
/*++

Routine Description:

    Initializes the Xapi process, loads the title and starts its first thread.

Arguments:

    None.

Return Value:

    None.

--*/
{
    HANDLE ThreadHandle;
    /* ULONG_PTR EntryPoint; */
    ULONG ProcessHeapFlags;
    RTL_HEAP_PARAMETERS HeapParameters;
    HANDLE hthread;
    USHORT CharIndex;
    DWORD dwReason = XLD_LAUNCH_DASHBOARD_MAIN_MENU;
    DWORD dwParameter1;
    DWORD dwParameter2 = 0;
    NTSTATUS status;

    // Initialize the auto-power-down feature.
    XapiInitAutoPowerDown();

    RtlZeroMemory( &HeapParameters, sizeof( HeapParameters ) );
    ProcessHeapFlags = HEAP_GROWABLE | HEAP_CLASS_0;
    HeapParameters.Length = sizeof( HeapParameters );

    // Note: there are some more parameters in the image that normal Win32 apps use to
    // modify ProcessHeapFlags and HeapParameters. Here, we just use the heap reserve/commit
    // sizes specified
    XapiProcessHeap = RtlCreateHeap(ProcessHeapFlags,
                                    NULL,
                                    XeImageHeader()->SizeOfHeapReserve,
                                    XeImageHeader()->SizeOfHeapCommit,
                                    NULL,
                                    &HeapParameters);

    if (XapiProcessHeap == NULL)
    {
        dwReason = XLD_LAUNCH_DASHBOARD_ERROR;
        dwParameter1 = XLD_ERROR_INVALID_XBE;
        goto handle_error;
    }

    if ((XeImageHeader()->Certificate->AllowedMediaTypes & XBEIMAGE_MEDIA_TYPE_MEDIA_MASK)
        == XBEIMAGE_MEDIA_TYPE_DVD_X2)
    {
        //
        // This title is only allowed to run on X2 media - double check that the drive
        // has mounted X2 media:
        //

        if (!NT_SUCCESS(XapiVerifyMediaInDrive()))
        {
            //
            // Don't display a dash error message - we want to avoid showing an
            // inapplicable errorduring race conditions where valid media was ejected
            // while this code was verifying the media
            //

            XapiBootToDash(XLD_LAUNCH_DASHBOARD_MAIN_MENU, 0, 0);
            return;
        }
    }

    if (!(XeImageHeader()->InitFlags & XINIT_NO_SETUP_HARD_DISK))
    {
        // Get the hard disk ready
        if (!NT_SUCCESS(XapiValidateDiskPartition((POBJECT_STRING) &MainVol)))
        {
            dwReason = XLD_LAUNCH_DASHBOARD_ERROR;
            dwParameter1 = XLD_ERROR_INVALID_HARD_DISK;
            goto handle_error;
        }
    }

    // Give the DVD/CD drive a drive letter
    if (!NT_SUCCESS(status = IoCreateSymbolicLink((POBJECT_STRING) &DDrive,
                                                  (POBJECT_STRING) &CdDevice)))
    {
        XDBGWRN("XAPI",
                "The D: drive is not assigned to the CD/DVD device - error 0x%08x",
                status);

        //
        // Devkits will tend to already have the D: drive assigned, so we'll ignore
        // this error, but reboot to the dash in all other cases...
        //

        if (STATUS_OBJECT_NAME_COLLISION != status)
        {
            dwReason = XLD_LAUNCH_DASHBOARD_ERROR;
            dwParameter1 = XLD_ERROR_INVALID_XBE;
            goto handle_error;
        }
    }

    if ((!(XeImageHeader()->InitFlags & XINIT_NO_SETUP_HARD_DISK)) &&
        (!(XeImageHeader()->InitFlags & XINIT_DONT_MODIFY_HARD_DISK)))
    {
        // After we've initialized everything, start the process
        if (!NT_SUCCESS(status = XapiSetupPerTitleDriveLetters(
                XeImageHeader()->Certificate->TitleID,
                XeImageHeader()->Certificate->TitleName)))
        {
            XDBGWRN("XAPI", "Could not set up per-title drive letters");

            if (STATUS_DISK_FULL == status)
            {
                dwReason = XLD_LAUNCH_DASHBOARD_MEMORY;
                dwParameter1 = (DWORD) 'T'; // drive letter
                dwParameter2 = 16; // blocks needed
            }
            else
            {
                dwReason = XLD_LAUNCH_DASHBOARD_ERROR;
                dwParameter1 = XLD_ERROR_INVALID_HARD_DISK;
            }
            goto handle_error;
        }
    }

    if ((!(XeImageHeader()->InitFlags & XINIT_NO_SETUP_HARD_DISK)) &&
        (XeImageHeader()->InitFlags & XINIT_MOUNT_UTILITY_DRIVE))
    {
        if (!XMountUtilityDrive(XeImageHeader()->InitFlags & XINIT_FORMAT_UTILITY_DRIVE))
        {
            XapiBootToDash(XLD_LAUNCH_DASHBOARD_ERROR,
                           XLD_ERROR_INVALID_HARD_DISK,
                           0);
        }
    }

    //
    // Check to see if parental control settings should prevent this title from
    // running on this box
    //

    if (XeImageHeader()->Certificate->GameRatings < XGetParentalControlSetting())
    {
        XDBGWRN("XAPI", "The box's parental control setting prohibits this title from starting");
        XDBGWRN("XAPI", "Go to the Xbox dashboard to change the box's parental control setting");

        dwReason = XLD_LAUNCH_DASHBOARD_ERROR;
        dwParameter1 = XLD_ERROR_XBE_PARENTAL_CONTROL;
        dwParameter2 = XeImageHeader()->Certificate->GameRatings;
        goto handle_error;
    }

    XDBGTRC("XAPI", "InitProcess: SizeOfStack=%d", XeImageHeader()->SizeOfStackCommit);

handle_error:
    if (XLD_LAUNCH_DASHBOARD_MAIN_MENU != dwReason)
    {
        XapiBootToDash(dwReason,
                       dwParameter1,
                       dwParameter2);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\dll\i386\xapiatls.asm ===
page	,132
    title	atlssup - TLS support object
;***
;atlssup.asm - Thread Local Storage support object (defines [_]_tls_array)
;
;	Copyright (c) 1993-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	Defines the symbol [_]_tls_array which is the offset into the
;	TEB (thread environment block) of the thread local storage pointer.
;
;Revision History:
;	03-19-93  SKS	Initial version (from ChuckM)
;	03-22-93  SKS	One less leading underscore with new include file 
;	10-06-94  SKS	Added header file comment
;
;*******************************************************************************

.xlist
%   .model small, C
.list

; This symbol is being defined in the C language model
; and will have an extra underscore character prepended.

		public	_tls_array 
_tls_array 	equ	04h	  ; TIB.StackBase

end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\dll\xapitls.c ===
/*
 *
 * xapitls.c
 *
 * Xapi TLS data
 *
 */

#include "dllp.h"

ULONG _tls_index = 0;

/* Special symbols to mark start and end of Thread Local Storage area. */

#pragma data_seg(".tls")

char _tls_start = 0;

#pragma data_seg(".tls$ZZZ")

char _tls_end = 0;

/*
 * Mark the .tls section as discardable so that IMAGEBLD throws the
 * section (non-zero Thread Local Storage data is moved to a different
 * location in the image).
 */

#pragma comment(linker, "/SECTION:.tls,D")

#pragma data_seg(".rdata$T")

const IMAGE_TLS_DIRECTORY _tls_used =
{
        (ULONG)(ULONG_PTR) &_tls_start, // start of tls data
        (ULONG)(ULONG_PTR) &_tls_end,   // end of tls data
        (ULONG)(ULONG_PTR) &_tls_index, // address of tls_index
        (ULONG)(ULONG_PTR) NULL,        // pointer to call back array
        (ULONG) 0,                      // size of tls zero fill
        (ULONG) 0                       // characteristics
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\inc\xapiver.h ===
#include <xboxverp.h>

#pragma comment(linker, "/include:_XboxKrnlBuildNumber")

#pragma data_seg(".XBLD$A")
#ifdef XAPILIBP

#if DBG
#pragma comment(linker, "/include:_XapiBuildNumberPD")
__declspec(selectany) USHORT XapiBuildNumberPD[8] = { 'AX', 'IP', 'BL', 'DP',
    VER_PRODUCTVERSION | 0x8000
#else  // DBG
#pragma comment(linker, "/include:_XapiBuildNumberP")
__declspec(selectany) USHORT XapiBuildNumberP[8] = { 'AX', 'IP', 'BL', 'P',
    VER_PRODUCTVERSION
#endif // DBG

#else  // XAPILIBP

#if DBG
#pragma comment(linker, "/include:_XapiBuildNumberD")
__declspec(selectany) USHORT XapiBuildNumberD[8] = { 'AX', 'IP', 'IL', 'DB',
    VER_PRODUCTVERSION | 0x8000
#else  // DBG
#pragma comment(linker, "/include:_XapiBuildNumber")
__declspec(selectany) USHORT XapiBuildNumber[8] = { 'AX', 'IP', 'IL', 'B',
    VER_PRODUCTVERSION | 0x4000
#endif // DBG

#endif // XAPILIBP
};
#pragma comment(linker, "/SECTION:.XBLD,D")
#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\dll\xapi0.c ===
#include "dllp.h"
#include <xcrypt.h>
#include "dm.h"

extern ULONG XapiTlsSize;

void _cinit(void);
void _rtinit(void);

int __cdecl main(int argc, ...);

DWORD WINAPI mainXapiStartup(
    LPVOID lpvParameter
    )
/*++

Routine Description:

    Starting point for the app's first thread

Arguments:

    lpvParameter - Unused.

Return Value:

    Returns the exit code of the app, it turns into the exit code of the thread.

--*/
{
    XapiInitProcess();

    {
        /* Tell the debugger where some of our data is*/
        PDMXAPI pdmxapi;
        pdmxapi = DmGetCurrentXapi();
        if(pdmxapi) {
            extern __declspec(thread) DWORD XapiLastErrorCode;
            pdmxapi->LastErrorTlsOff = (ULONG_PTR)&XapiLastErrorCode -
                (ULONG_PTR)KeGetCurrentThread()->TlsData;
            pdmxapi->XapiStarted = TRUE;
        }
    }

    _rtinit();
    _cinit();

    main(
           0, // argc
           NULL, // argv
           NULL // envp
         );

    RIP("Main thread should not return.");

    XapiBootToDash(XLD_LAUNCH_DASHBOARD_ERROR, XLD_ERROR_INVALID_XBE, 0);

    return STATUS_SUCCESS;
}

VOID __cdecl mainCRTStartup(
    VOID
    )
/*++

Routine Description:

    Entrypoint for xapi.dll, initializes api + crt components, launches the
	app

Arguments:

    None.

Return Value:

    None.

--*/
{
    HANDLE hThread;
    PUCHAR EndOfHeaders;
    PXBEIMAGE_CERTIFICATE Certificate;
    ULONG MaxSizeOfCertificate;

    /* Verify that the XBE certificate is wholly contained within the signed
     * XBE headers (the kernel only validated the first
     * XBEIMAGE_CERTIFICATE_BASE_SIZEOF bytes.  If it's too big, we truncate
     * the SizeOfCertificate */
    EndOfHeaders = (PUCHAR)XeImageHeader() + XeImageHeader()->SizeOfHeaders;
    Certificate = XeImageHeader()->Certificate;
    MaxSizeOfCertificate = EndOfHeaders - (PUCHAR)Certificate;
    if(MaxSizeOfCertificate < Certificate->SizeOfCertificate)
        Certificate->SizeOfCertificate = MaxSizeOfCertificate;

    /* Set the TLS index, if we have TLS */
    XapiTlsSize = (_tls_used.EndAddressOfRawData -
        _tls_used.StartAddressOfRawData) + _tls_used.SizeOfZeroFill;
    /* The base of the TLS section must be 16-byte aligned.  We know
     * that fs:StackBase is 16-byte aligned, ensuring that TlsSize is
     * 16-byte aligned is sufficient */
    XapiTlsSize = (XapiTlsSize + 15) & ~15;
    /* Add four bytes for the index pointer */
    XapiTlsSize += 4;
    *(PULONG)(_tls_used.AddressOfIndex) = (int)XapiTlsSize / -4;

    // Create the app's primary thread
    hThread = CreateThread(
                            NULL,
                            0,
                            mainXapiStartup,
                            NULL,
                            0,
                            NULL
                          );

    if (NULL == hThread)
    {
        XapiBootToDash(XLD_LAUNCH_DASHBOARD_ERROR, XLD_ERROR_INVALID_XBE, 0);
    }

    CloseHandle(hThread);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\inc\xfiber.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    xfiber.h

Abstract:

    This module defines fiber structures

--*/

#ifndef _XFIBER_H
#define _XFIBER_H

//
// Structure to hold the per fiber instance data.
//

typedef struct _XFIBER {
    PVOID FiberData;
    PVOID StackBase;
    PVOID StackLimit;
    PVOID KernelStack;
} XFIBER, *PXFIBER;

#endif // _XFIBER_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\inc\xapip.h ===
/*++

Copyright (c) 1999-2002  Microsoft Corporation

Module Name:

    xapip.h

Abstract:

    Contains common precompiled headers for kernel-mode
    Win32-equivalents for xbox

--*/

#ifndef _XAPIP_
#define _XAPIP_

//  Disable DECLSPEC_IMPORT decoration of locally implemented APIs.
#define _KERNEL32_
#define _USER32_
#define _GDI32_
#define _WINMM_

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus
#include "ntos.h"
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>
#ifdef __cplusplus
}
#endif // __cplusplus
#include <xtl.h>
#include <xdbg.h>
#include <xapidrv.h>
#include <ldr.h>
#include <xbeimage.h>

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

extern const IMAGE_TLS_DIRECTORY _tls_used;
extern ULONG _tls_index;

//
// Default process heap handle.
//

extern HANDLE XapiProcessHeap;

//
// General critical section used to guard XAPI data structures.
//

extern RTL_CRITICAL_SECTION XapiProcessLock;

#define XapiAcquireProcessLock() RtlEnterCriticalSection(&XapiProcessLock)
#define XapiReleaseProcessLock() RtlLeaveCriticalSection(&XapiProcessLock)

typedef struct _X_CACHE_DB_ENTRY
{
    DWORD    dwTitleId;
    ULONG    nCacheIndex;
    BOOL     fUsed;
} X_CACHE_DB_ENTRY, *PX_CACHE_DB_ENTRY;


FORCEINLINE BOOL XapiIsXapiThread()
{
    return (KeGetCurrentIrql() < DISPATCH_LEVEL &&
        KeGetCurrentThread()->TlsData != NULL);
}

//
// Prototypes
//

VOID
XapiInitProcess(
    VOID
    );

VOID
XapiBootToDash(
    DWORD dwReason,
    DWORD dwParameter1,
    DWORD dwParameter2
    );

BOOL
WINAPI
XapiFormatFATVolume(
    IN POBJECT_STRING pcVolume
    );

BOOL
WINAPI
XapiFormatFATVolumeEx(
    IN POBJECT_STRING pcVolume,
    IN ULONG BytesPerCluster
    );

NTSTATUS
XapiGetCachePartitions(
    IN PX_CACHE_DB_ENTRY pCacheEntriesBuffer,
    IN UINT cbBufferSize,
    OUT PDWORD pdwNumCacheEntries
    );

VOID
XapiDeleteCachePartition(
    IN DWORD dwTitleId
    );

NTSTATUS
XapiValidateDiskPartition(
    POBJECT_STRING PartitionName
    );

NTSTATUS
XapiValidateDiskPartitionEx(
    POBJECT_STRING PartitionName,
    ULONG BytesPerCluster
    );

NTSTATUS
XapiMapLetterToDirectory(
    PCOBJECT_STRING pcDriveString,
    PCOBJECT_STRING pcPathString,
    PCOSTR pcszTitleId,
    BOOL fCreateDirectory,
    LPCWSTR pcszTitleName,
    BOOL fUpdateTimestamp
    );

BOOL
XapiDeleteValueInMetaFile(
    HANDLE hMetaFile,
    LPCWSTR pszTag
    );

void
XapiInitAutoPowerDown();

#define CONSTANT_OBJECT_STRING(s)   { sizeof( s ) - sizeof( OCHAR ), sizeof( s ), s }

#define DwordToStringO(dword, dwordstr) \
{ \
    soprintf(dwordstr, OTEXT("%08lx"), dword); \
}

#define CCHMAX_HEX_DWORD 9


//
//  Exported by MU driver
//  used only by XAPI.
//
NTSTATUS
MU_CreateDeviceObject(
    IN  ULONG            Port,
    IN  ULONG            Slot,
    IN  POBJECT_STRING  DeviceName
    );

VOID
MU_CloseDeviceObject(
    IN  ULONG  Port,
    IN  ULONG  Slot
    );

PDEVICE_OBJECT
MU_GetExistingDeviceObject(
    IN  ULONG  Port,
    IN  ULONG  Slot
    );

#ifdef DBG
extern ULONG MU_MaxUserDevices;
#endif

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _XAPIP_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\charconv.c ===
#include "basedll.h"

LPSTR
WINAPI
CharUpperA(
    LPSTR psz
    )
{
    if (HIWORD(psz))
    {
        LPSTR pszCur = psz;
        while (*pszCur)
        {
            *pszCur = RtlUpperChar(*pszCur);
            pszCur++;
        }
        return psz;
    }
    else
    {
        return (LPSTR)RtlUpperChar((CHAR)psz);
    }
}

LPSTR
WINAPI
CharLowerA(
    LPSTR psz
    )
{
    if (HIWORD(psz))
    {
        LPSTR pszCur = psz;
        while (*pszCur)
        {
            *pszCur = RtlLowerChar(*pszCur);
            pszCur++;
        }
        return psz;
    }
    else
    {
        return (LPSTR)RtlLowerChar((CHAR)psz);
    }
}

LPWSTR
WINAPI
CharUpperW(
    LPWSTR psz
    )
{
    if (HIWORD(psz))
    {
        LPWSTR pszCur = psz;
        while (*pszCur)
        {
            *pszCur = RtlUpcaseUnicodeChar(*pszCur);
            pszCur++;
        }
        return psz;
    }
    else
    {
        return (LPWSTR)RtlUpcaseUnicodeChar((WCHAR)psz);
    }
}

LPWSTR
WINAPI
CharLowerW(
    LPWSTR psz
    )
{
    if (HIWORD(psz))
    {
        LPWSTR pszCur = psz;
        while (*pszCur)
        {
            *pszCur = RtlDowncaseUnicodeChar(*pszCur);
            pszCur++;
        }
        return psz;
    }
    else
    {
        return (LPWSTR)RtlDowncaseUnicodeChar((WCHAR)psz);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\basedll.h ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    basedll.h

Abstract:

    This module contains private function prototypes
    and types for the 32-bit windows base APIs.

--*/

#ifndef _BASEP_
#define _BASEP_

#include "xapip.h"
#include "winbasep.h"
#include "xfiber.h"
#include <xcrypt.h>
#include <stdio.h>
#include <wchar.h>
#include "xapiver.h"

UCHAR
FASTCALL
RtlFindFirstSetRightMember(
    IN ULONG Set
    );

POBJECT_ATTRIBUTES
XapiFormatObjectAttributes(
    OUT POBJECT_ATTRIBUTES ObjectAttributes,
    OUT POBJECT_STRING ObjectName,
    IN PCOSTR lpName
    );

PLARGE_INTEGER
XapiFormatTimeOut(
    PLARGE_INTEGER TimeOut,
    DWORD Milliseconds
    );

ULONG
XapiSetLastNTError(
    NTSTATUS Status
    );

NTSTATUS
XapiNukeDirectoryFromHandle(
    HANDLE hDirectory,
    PFILE_DIRECTORY_INFORMATION DirectoryInfo
    );

NTSTATUS
XapiNukeDirectory(
    PCOSTR pszPath
    );

DWORD 
XapiNukeEmptySubdirs(
    IN PCOSTR  pszDrivePath,
    IN PCOSTR  pszPreserveDir OPTIONAL,
    IN BOOLEAN fNukeFiles
    );


#define ARRAYSIZE(a) (sizeof(a) / sizeof(a[0]))

extern const OBJECT_STRING XapiHardDisk;

typedef struct _FINDGAME_HANDLE
{
    DWORD dwSignature;
    HANDLE hFindFile;
    int cchRootDir;
    OCHAR szRootDir[MAX_PATH];
} FINDGAME_HANDLE, *PFINDGAME_HANDLE;

#define NUM_NICK_ENTRIES            50

typedef struct _X_NICK_DB_ENTRY
{
    DWORD    dwTitleID;
    WCHAR    szNickname[MAX_NICKNAME];
} X_NICK_DB_ENTRY, *PX_NICK_DB_ENTRY;

typedef struct _FINDNICKNAME_HANDLE
{
    DWORD           dwSignature;
    UINT            uCurIndex;
    BOOL            fThisTitleOnly;
    X_NICK_DB_ENTRY Nicknames[NUM_NICK_ENTRIES];
} FINDNICKNAME_HANDLE, *PFINDNICKNAME_HANDLE;

typedef struct _FINDCONTENT_HANDLE
{
    DWORD dwSignature;
    HANDLE hFindFile;
    DWORD dwFlagFilter;
    int cchRootDir;
    CHAR szRootDir[MAX_PATH];
} FINDCONTENT_HANDLE, *PFINDCONTENT_HANDLE;

typedef struct _XAPI_MU_INFO
{
    OCHAR   DriveWithAltDriveMapped;
    ULONG   MountedDrives;
} XAPI_MU_INFO, *PXAPI_MU_INFO;
extern XAPI_MU_INFO XapiMuInfo;

typedef struct _SNDTRK_ENUMSTATE {

    DWORD Signature;
    UINT Index;
    UINT MaxIndex;
    HANDLE DbHandle;

} SNDTRK_ENUMSTATE, *PSNDTRK_ENUMSTATE;


#define FH_SIG_SAVEGAME 0x53425645
#define FH_SIG_NICKNAME 0x4E49434B
#define FH_SIG_CONTENT 0x434F4E54
#define FH_SIG_SOUNDTRACK 0xBE4BEA00

#define HD_TDATA_DRIVE     OTEXT('T')
#define HD_UDATA_DRIVE     OTEXT('U')
#define HD_ALT_TDATA_DRIVE OTEXT('W')
#define HD_ALT_UDATA_DRIVE OTEXT('X')

#define MU_PORT_MIN     XDEVICE_PORT0
#define MU_PORT_MAX     (XDEVICE_PORT0 + XGetPortCount() - 1)

#define MU_SLOT_MIN     XDEVICE_TOP_SLOT
#define MU_SLOT_MAX     XDEVICE_BOTTOM_SLOT
#define MU_SLOTS        2
#define MU_SLOT_FACTOR  (XDEVICE_BOTTOM_SLOT - XDEVICE_TOP_SLOT)

#define MU_FIRST_DRIVE  OTEXT('F')
#define MU_LAST_DRIVE   (OTEXT('F') + (MU_PORT_MAX * MU_SLOTS) + (MU_SLOTS - 1))

#define MU_DRIVE_LETTER_FROM_PORT_SLOT(p, s) \
            ((OCHAR) (MU_FIRST_DRIVE + ((MU_SLOTS) * ((p) - MU_PORT_MIN)) + ((s / MU_SLOT_FACTOR))))

#define MU_PORT_FROM_DRIVE_LETTER(d) \
            (MU_PORT_MIN + (((d) - MU_FIRST_DRIVE) / MU_SLOTS))

#define MU_SLOT_FROM_DRIVE_LETTER(d) \
            ((MU_SLOT_MIN + (((d) - MU_FIRST_DRIVE) % MU_SLOTS)) * MU_SLOT_FACTOR)

#define MU_SET_MOUNTED(d) (XapiMuInfo.MountedDrives |= (1 << ((d) - MU_FIRST_DRIVE)))
#define MU_CLEAR_MOUNTED(d) (XapiMuInfo.MountedDrives &= ~(1 << ((d) - MU_FIRST_DRIVE)))
#define MU_IS_MOUNTED(d) (XapiMuInfo.MountedDrives&(1 << ((d) - MU_FIRST_DRIVE)))


#endif // _BASEP_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\cancelio.c ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    cancelio.c

Abstract:

    This module implements the Win32 CancelIo service.

--*/

#include "basedll.h"
#pragma hdrstop
#include <idexchan.h>

VOID
XapiDpcForCancelIo(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
{
    PLIST_ENTRY CancelListHead;
    PLIST_ENTRY NextListEntry;
    PIRP Irp;

    CancelListHead = (PLIST_ENTRY)DeferredContext;

    //
    // Run through the list of IRPs to be canceled.
    //

    NextListEntry = CancelListHead->Flink;

    while (NextListEntry != CancelListHead) {

        Irp = CONTAINING_RECORD(NextListEntry, IRP, Tail.Overlay.DeviceQueueEntry.DeviceListEntry);
        NextListEntry = NextListEntry->Flink;

        Irp->IoStatus.Status = STATUS_CANCELLED;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }
}

BOOL
WINAPI
CancelIo(
    HANDLE hFile
    )
/*++

Routine Description:

    This routine cancels all of the outstanding I/O for the specified handle
    for the specified file.

Arguments:

    hFile - Supplies the handle to the file whose pending I/O is to be
        canceled.

Return Value:

    TRUE -- The operation was successful.

    FALSE -- The operation failed.  Extended error status is available using
        GetLastError.

--*/
{
    LIST_ENTRY CancelListHead;
    NTSTATUS status;
    PFILE_OBJECT FileObject;
    KIRQL OldIrql;
    PLIST_ENTRY NextListEntry;
    PIRP Irp;
    KDPC WorkerDpc;

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    InitializeListHead(&CancelListHead);

    //
    // Reference the file object.
    //

    status = ObReferenceObjectByHandle(hFile, IoFileObjectType,
        (PVOID*)&FileObject);

    if (!NT_SUCCESS(status)) {
        XapiSetLastNTError(status);
        return FALSE;
    }

    //
    // Scan through the IDEX device queue for any pending IRPs that originated
    // from the supplied file object.  Synchronize with the IDEX channel
    // dispatcher by raising to DPC level.
    //

    OldIrql = KeRaiseIrqlToDpcLevel();

    NextListEntry = IdexChannelObject->DeviceQueue.DeviceListHead.Flink;

    while (NextListEntry != &IdexChannelObject->DeviceQueue.DeviceListHead) {

        Irp = CONTAINING_RECORD(NextListEntry, IRP, Tail.Overlay.DeviceQueueEntry.DeviceListEntry);
        NextListEntry = NextListEntry->Flink;

        if ((Irp->Tail.Overlay.OriginalFileObject == FileObject) &&
            ((Irp->Flags & IRP_NO_CANCELIO) == 0)) {
            RemoveEntryList(&Irp->Tail.Overlay.DeviceQueueEntry.DeviceListEntry);
            InsertTailList(&CancelListHead, &Irp->Tail.Overlay.DeviceQueueEntry.DeviceListEntry);
        }
    }

    KeLowerIrql(OldIrql);

    //
    // If there are any IRPs that need to be canceled, then do so from a worker
    // DPC.  This is done for two reasons.  First, for packets marked as "must
    // complete" using IoMarkIrpMustComplete, IoCompleteRequest must be called
    // at DPC level.  Second, if the number of "must complete" packets reach
    // zero and a shutdown request is pending, then the kernel routine
    // HalMustCompletePacketsFinished expects to be called from a DPC stack, not
    // an arbitrary thread stack.
    //

    if (!IsListEmpty(&CancelListHead)) {
        KeInitializeDpc(&WorkerDpc, XapiDpcForCancelIo, &CancelListHead);
        KeInsertQueueDpc(&WorkerDpc, NULL, NULL);
    }

    //
    // Dereference the file object.
    //

    ObDereferenceObject(FileObject);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\compstr.c ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     compstr.c
// Contents: This module implements xCompareString functionality.  Note that xCompareString differs
//           from the Win32 CompareString in that it does not take a locale identifier (unnecessary
//           since Xbox only has one locale.
//
// Author:   Jeff Simon (jeffsim) 16-May-2001
//
// UNDONE:   * Verify CompareStringW vs CompareStringA functionality
//           * How do Kanji and the kanas fit into g_rgdwLoc? Or handled algorithmically?
//           * What is Kanji, hira, kata, ascii sort order?
//           * Move defines to private header file to share them with compstra.c
//
// Copyright Microsoft Corporation
// 
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

#include "basedll.h"
#include "winnls.h"
#include <assert.h>
#pragma hdrstop


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Externally defined variables
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// Conversion table.  This will be filled in algorithmically by InitLocTable at startup.
// UNDONE-ERR: Currently only big enough to hold the 256 ASCII chars.  Not sure how to handle
//             Kanji and the kanas -- will I add them to the table, or handle them algorithmically?
extern DWORD g_rgdwLoc[256];

extern void InitLocTable();

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Internal Defines - specific to this file
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// Sort order (lower letters are sorted before upper letters; symbols are sorted before numbers...)
// UNDONE-ERR: Just guessing on the sort order of the non-ascii chars (kanji and kanas).  Guessing
//             that the sort order (first->last) would be "ascii", "kata", "hira", "kanji".
#define COMP_INVALID    0x80000000
#define COMP_KANJI      0x00800000
#define COMP_HIRAGANA   0x00400000
#define COMP_KATAKANA   0x00200000
#define COMP_ULETTER    0x00100000
#define COMP_LLETTER    0x00080000
#define COMP_NUMBER     0x00040000
#define COMP_SYMBOL     0x00020000
#define COMP_WORDSORT   0x00010000

// NEXTCHAR -- Simple define for skipping to the next character in the main CompareString loop
#define NEXTCHAR(x) {  pstr##x++; cch##x--;  }

// SYM_*    -- Defines for handling wordsort special symbols
#define SYM_NONE   0                // No special symbol encountered
#define SYM_1      1                // special symbol already encountered in pstr1
#define SYM_2      2                // special symbol already encountered in pstr2
#define SYM_BOTH   SYM_1 | SYM_2    // special symbol already encountered in both pstr1 and pstr2
#define SYM_1FIRST 4                // pstr1 had the first special symbol encountered
#define SYM_2FIRST 8                // pstr2 had the first special symbol encountered


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Functions
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function:  xCompareStringA/xCompareStringW
// Purpose:   Xbox-specific version of the CompareString function.  Compares two strings using the
//            global Xbox locale.  Differs from the Win32 version of CompareString in that we don't
//            need to have a locale specified.
// Arguments: dwCmpFlags        -- Comparison-style options
//            pstr1             -- First string to compare
//            cch1              -- Number of characters in first string to examine (-1 for 'all')
//            pstr2             -- First string to compare
//            cch2              -- Number of characters in first string to examine (-1 for 'all')
// Return:    CSTR_LESS_THAN    if pstr1 sorts BEFORE pstr2 (ie  CompareString("a","b") )
//            CSTR_EQUAL        if pstr1 EQUALS pstr2       (ie  CompareString("a","a") )
//            CSTR_GREATER_THAN if pstr1 sorts AFTER pstr2  (ie  CompareString("b","a") )
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#ifdef COMPSTRA
int xCompareStringA(DWORD dwCmpFlags, LPCSTR pstr1, int cch1, LPCSTR pstr2, int cch2)
#else
int xCompareStringW(DWORD dwCmpFlags, LPCWSTR pstr1, int cch1, LPCWSTR pstr2, int cch2)
#endif
{
    // w1, w2, dw1, dw2 -- Temp variables
    WORD  w1, w2;
    DWORD dw1, dw2;
    
    // nSymFound        -- Track which string(s) had special symbols, and which came first.
    int nSymFound = SYM_NONE;

    // Avoid repetitive flag masking in the while loop by doing it once here...
    BOOL fWordSort      = !(dwCmpFlags & SORT_STRINGSORT);
    BOOL fIgnoreCase    = dwCmpFlags & NORM_IGNORECASE;
    BOOL fIgnoreSymbols = dwCmpFlags & NORM_IGNORESYMBOLS;

    // s_rgnSymLookup   -- Optimization to remove comparisons from the case where both strings are
    //                     the same length and have word-sort symbols in them
    static int s_rgnSymLookup[] = {CSTR_EQUAL, 0,0,0,0, CSTR_GREATER_THAN, 0, CSTR_LESS_THAN, 0,0,
                                   CSTR_LESS_THAN, CSTR_GREATER_THAN};
    
    // Verify parameters
    if (pstr1 == NULL || pstr2 == NULL || cch1 < -1 || cch2 < -1) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    }
    // UNDONE-WARN: I'm not sure if we actually need to handle NORM_IGNORENONSPACE.  If I read MSDN
    //              correctly, we can ignore it, but I need to verify this.

    // UNDONE-ERR: Remove following asserts and handle appropriately
    // assert(!(dwCmpFlags & NORM_IGNOREKANATYPE));    // not handled
    // assert(!(dwCmpFlags & NORM_IGNOREWIDTH));       // not handled


    // Loop until one of the limits is reached (or we return from inside the while loop).
    while (cch1 != 0 && cch2 != 0) {
        // Check if we've reached the end of either string.
        if (*pstr1 == '\0' && *pstr2 == '\0') return s_rgnSymLookup[nSymFound];
        if (*pstr1 == '\0')                   return CSTR_LESS_THAN;
        if (*pstr2 == '\0')                   return CSTR_GREATER_THAN;

        // Both strings still have characters -- do locale-specific comparison of next character
        
        // w1, w2   -- Track the character codes
        // UNDONE-ERR: Need to figure out how I'm going to handle the table for >256 and then
        //             modify these lines appropriately.
#if 1   // def COMPSTRA
        w1 = (WORD)((BYTE)*pstr1);
        w2 = (WORD)((BYTE)*pstr2);
#else
        w1 = (WORD)(*pstr1);
        w2 = (WORD)(*pstr2);
#endif

        // dw1, dw2 -- Track character code or'ed in with bucket describing the 'type' of the char.
        dw1 = g_rgdwLoc[w1];
        dw2 = g_rgdwLoc[w2];

        // UNDONE-OPT: Could pull wordsort check outside of the loop to remove an if per iteration.
        //             Same with fIgnoreSymbols, etc.  However, that particular optimization
        //             (#including a file with particular defines) obfuscates the code quite a bit.

        // Word sort -- some chars are special cased; if we hit one, then skip the character,
        // but track which string(s) have the chars, and which had the first special char in case
        // the strings otherwise match. (ie, correct ordering: "ab-cd", "abce", "a-bce", "ab-ce")
        if (fWordSort) {
            if (dw1 & COMP_WORDSORT) {
                // If both are special symbols, then skip them.  Also need to track if they're
                // different symbols (ie "'" in one string and "-" in the other)
                if (dw2 & COMP_WORDSORT) {
                    if (dw1 < dw2)      nSymFound = SYM_BOTH | SYM_1FIRST;
                    else if (dw1 > dw2) nSymFound = SYM_BOTH | SYM_2FIRST;
                    NEXTCHAR(1); NEXTCHAR(2);
                    continue;
                } else {
                    if (nSymFound == SYM_NONE) nSymFound = SYM_1FIRST;
                    nSymFound |= SYM_1;
                    NEXTCHAR(1);
                    continue;
                }
            }
            if (dw2 & COMP_WORDSORT) {
                if (nSymFound == SYM_NONE) nSymFound = SYM_2FIRST;
                nSymFound |= SYM_2;
                NEXTCHAR(2);
                continue;
            }

            // If here, then neither of the current characters were special symbols.  Continue
            // processing them...
        }
        
        if (fIgnoreSymbols) {
            if (dw1 & COMP_SYMBOL) {
                NEXTCHAR(1);
                continue;
            }
            if (dw2 & COMP_SYMBOL) {
                NEXTCHAR(2);
                continue;
            }
        }

        if (fIgnoreCase) {
            // Handle case-insensitivity.  (+32 converts from upper to lower in our table)
            if (dw1 & COMP_ULETTER)  dw1 = COMP_LLETTER | w1 + 32;
            if (dw2 & COMP_ULETTER)  dw2 = COMP_LLETTER | w2 + 32;
        }

        if (dw1 < dw2) return CSTR_LESS_THAN;
        if (dw1 > dw2) return CSTR_GREATER_THAN;

        // Strings Matched.  Move on to the next character
        NEXTCHAR(1); NEXTCHAR(2);
    }
    
    // If here, then we passed the limit on one of the strings, and both strings are equal so far.
    
    // Check if we hit both limits
    if (cch1 == 0 && cch2 == 0) {
        // If we're in a wordsort search, then we need to take the special symbol state into account.
        // (If we're in a stringsort search, then nSymFound == 0, so we'll return CSTR_EQUAL).
        return s_rgnSymLookup[nSymFound];
    }
    
    // If here, then we hit just one limit, and that string comes second...
    return (cch1 == 0) ? CSTR_GREATER_THAN : CSTR_LESS_THAN;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\compstra.c ===
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File:     compstra.c
// Contents: CompareStringA functionality.  Contains CompareString table initilization functions
//           and includes the C file that has the actual CompareString function definition (we set
//           a define so that the 'A' functionality gets compiled rather than 'W').
// Author:	 Jeff Simon (jeffsim) 16-May-2001
//
// Copyright Microsoft Corporation
// 
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++ INCLUDE FILES +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

#include "basedll.h"
#pragma hdrstop


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Internal Defines - specific to this file
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// Sort order (lower letters are sorted before upper letters; symbols are sorted before numbers, ...)
// UNDONE-ERR: Just guessing on the sort order of the non-ascii chars (kanji and kanas).  Guessing
//             that the sort order (first->last) would be "ascii", "kata", "hira", "kanji".
#define COMP_INVALID    0x80000000
#define COMP_KANJI      0x00800000
#define COMP_HIRAGANA   0x00400000
#define COMP_KATAKANA   0x00200000
#define COMP_ULETTER    0x00100000
#define COMP_LLETTER    0x00080000
#define COMP_NUMBER     0x00040000
#define COMP_SYMBOL     0x00020000
#define COMP_WORDSORT   0x00010000


// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Global variables
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// Conversion table.  This will be filled in algorithmically by InitLocTable at startup.
// UNDONE-ERR: Currently only big enough to hold the 256 ASCII chars.  Not sure how to handle
//             Kanji and the kanas -- will I add them to the table, or handle them algorithmically?
DWORD g_rgdwLoc[256] = {
    COMP_INVALID |   0, COMP_INVALID |   1, COMP_INVALID |   2, COMP_INVALID |   3, // 
    COMP_INVALID |   4, COMP_INVALID |   5, COMP_INVALID |   6, COMP_INVALID |   7, // 
    COMP_INVALID |   8, COMP_INVALID |   9, COMP_INVALID |  10, COMP_INVALID |  11, // 
    COMP_INVALID |  12, COMP_INVALID |  13, COMP_INVALID |  14, COMP_INVALID |  15, // 
    COMP_INVALID |  16, COMP_INVALID |  17, COMP_INVALID |  18, COMP_INVALID |  19, // 
    COMP_INVALID |  20, COMP_INVALID |  21, COMP_INVALID |  22, COMP_INVALID |  23, // 
    COMP_INVALID |  24, COMP_INVALID |  25, COMP_INVALID |  26, COMP_INVALID |  27, // 
    COMP_INVALID |  28, COMP_INVALID |  29, COMP_INVALID |  30, COMP_INVALID |  31, // 

    COMP_SYMBOL  |  32, COMP_SYMBOL  |  33, COMP_SYMBOL  |  34, COMP_SYMBOL  |  35, //  !"#
    COMP_SYMBOL  |  36, COMP_SYMBOL  |  37, COMP_SYMBOL  |  38, COMP_SYMBOL  |  39, // $%&'
    COMP_SYMBOL  |  40, COMP_SYMBOL  |  41, COMP_SYMBOL  |  42, COMP_SYMBOL  |  43, // ()*+
    COMP_SYMBOL  |  44, COMP_SYMBOL  |  45, COMP_SYMBOL  |  45, COMP_SYMBOL  |  47, // ,-./
    COMP_NUMBER  |  48, COMP_NUMBER  |  49, COMP_NUMBER  |  50, COMP_NUMBER  |  51, // 0123
    COMP_NUMBER  |  52, COMP_NUMBER  |  53, COMP_NUMBER  |  54, COMP_NUMBER  |  55, // 4567
    COMP_NUMBER  |  56, COMP_NUMBER  |  57, COMP_SYMBOL  |  58, COMP_SYMBOL  |  59, // 89:;
    COMP_SYMBOL  |  60, COMP_SYMBOL  |  61, COMP_SYMBOL  |  62, COMP_SYMBOL  |  63, // <=>?
    COMP_SYMBOL  |  64, COMP_ULETTER |  65, COMP_ULETTER |  66, COMP_ULETTER |  67, // @ABC
	
    COMP_ULETTER |  68, COMP_ULETTER |  69, COMP_ULETTER |  70, COMP_ULETTER |  71, // DEFG
    COMP_ULETTER |  72, COMP_ULETTER |  73, COMP_ULETTER |  74, COMP_ULETTER |  75, // HIJK
    COMP_ULETTER |  76, COMP_ULETTER |  77, COMP_ULETTER |  78, COMP_ULETTER |  79, // LMNO
    COMP_ULETTER |  80, COMP_ULETTER |  81, COMP_ULETTER |  82, COMP_ULETTER |  83, // PQRS
    COMP_ULETTER |  84, COMP_ULETTER |  85, COMP_ULETTER |  86, COMP_ULETTER |  87, // TUVW
    COMP_ULETTER |  88, COMP_ULETTER |  89, COMP_ULETTER |  90, COMP_SYMBOL  |  91, // XYZ[
    COMP_SYMBOL  |  92, COMP_SYMBOL  |  93, COMP_SYMBOL  |  94, COMP_SYMBOL  |  95, // \]^_
    COMP_SYMBOL  |  96, COMP_LLETTER |  97, COMP_LLETTER |  98, COMP_LLETTER |  99, // `abc

    COMP_LLETTER | 100, COMP_LLETTER | 101, COMP_LLETTER | 102, COMP_LLETTER | 103, // defg
    COMP_LLETTER | 104, COMP_LLETTER | 105, COMP_LLETTER | 106, COMP_LLETTER | 107, // hijk
    COMP_LLETTER | 108, COMP_LLETTER | 109, COMP_LLETTER | 110, COMP_LLETTER | 111, // lmno
    COMP_LLETTER | 112, COMP_LLETTER | 113, COMP_LLETTER | 114, COMP_LLETTER | 115, // pqrs
    COMP_LLETTER | 116, COMP_LLETTER | 117, COMP_LLETTER | 118, COMP_LLETTER | 119, // tuvw
    COMP_LLETTER | 120, COMP_LLETTER | 121, COMP_LLETTER | 122, COMP_SYMBOL  | 123, // xyz{
    COMP_SYMBOL  | 124, COMP_SYMBOL  | 125, COMP_SYMBOL  | 126, COMP_INVALID | 127, // |}~
    COMP_INVALID | 128, COMP_INVALID | 129, COMP_INVALID | 130, COMP_INVALID | 131, // 

    COMP_INVALID | 132, COMP_INVALID | 133, COMP_INVALID | 134, COMP_INVALID | 135, // 
    COMP_INVALID | 136, COMP_INVALID | 137, COMP_INVALID | 138, COMP_INVALID | 139, // 
    COMP_INVALID | 140, COMP_INVALID | 141, COMP_INVALID | 142, COMP_INVALID | 143, // 
    COMP_INVALID | 144, COMP_INVALID | 145, COMP_INVALID | 145, COMP_INVALID | 147, // 
    COMP_INVALID | 148, COMP_INVALID | 149, COMP_INVALID | 150, COMP_INVALID | 151, // 
    COMP_INVALID | 152, COMP_INVALID | 153, COMP_INVALID | 154, COMP_INVALID | 155, // 
    COMP_INVALID | 156, COMP_INVALID | 157, COMP_INVALID | 158, COMP_INVALID | 159, // 
    COMP_INVALID | 160, COMP_SYMBOL  | 161, COMP_SYMBOL  | 162, COMP_SYMBOL  | 163, //  
    COMP_SYMBOL  | 164, COMP_SYMBOL  | 165, COMP_SYMBOL  | 166, COMP_SYMBOL  | 167, // 
	
    COMP_SYMBOL  | 168, COMP_SYMBOL  | 169, COMP_SYMBOL  | 170, COMP_SYMBOL  | 171, // 
    COMP_SYMBOL  | 172, COMP_SYMBOL  | 173, COMP_SYMBOL  | 174, COMP_SYMBOL  | 175, // 
    COMP_SYMBOL  | 176, COMP_SYMBOL  | 177, COMP_SYMBOL  | 178, COMP_SYMBOL  | 179, // 
    COMP_SYMBOL  | 180, COMP_SYMBOL  | 181, COMP_SYMBOL  | 182, COMP_SYMBOL  | 183, // 
    COMP_SYMBOL  | 184, COMP_SYMBOL  | 185, COMP_SYMBOL  | 186, COMP_SYMBOL  | 187, // 
    COMP_SYMBOL  | 188, COMP_SYMBOL  | 189, COMP_SYMBOL  | 190, COMP_SYMBOL  | 191, // 
    COMP_ULETTER | 192, COMP_ULETTER | 193, COMP_ULETTER | 194, COMP_ULETTER | 195, // 
    COMP_ULETTER | 196, COMP_ULETTER | 197, COMP_ULETTER | 198, COMP_ULETTER | 199, // 

    COMP_ULETTER | 200, COMP_ULETTER | 201, COMP_ULETTER | 202, COMP_ULETTER | 203, // 
    COMP_ULETTER | 204, COMP_ULETTER | 205, COMP_ULETTER | 206, COMP_ULETTER | 207, // 
    COMP_ULETTER | 208, COMP_ULETTER | 209, COMP_ULETTER | 210, COMP_ULETTER | 211, // 
    COMP_ULETTER | 212, COMP_ULETTER | 213, COMP_ULETTER | 214, COMP_SYMBOL  | 215, // 
    COMP_ULETTER | 216, COMP_ULETTER | 217, COMP_ULETTER | 218, COMP_ULETTER | 219, // 
    COMP_ULETTER | 220, COMP_ULETTER | 221, COMP_ULETTER | 222, COMP_ULETTER | 223, // 
    COMP_LLETTER | 224, COMP_LLETTER | 225, COMP_LLETTER | 226, COMP_LLETTER | 227, // 
    COMP_LLETTER | 228, COMP_LLETTER | 229, COMP_LLETTER | 230, COMP_LLETTER | 231, // 

    COMP_LLETTER | 232, COMP_LLETTER | 233, COMP_LLETTER | 234, COMP_LLETTER | 235, // 
    COMP_LLETTER | 236, COMP_LLETTER | 237, COMP_LLETTER | 238, COMP_LLETTER | 239, // 
    COMP_LLETTER | 240, COMP_LLETTER | 241, COMP_LLETTER | 242, COMP_LLETTER | 243, // 
    COMP_LLETTER | 244, COMP_LLETTER | 245, COMP_LLETTER | 245, COMP_SYMBOL  | 247, // 
    COMP_LLETTER | 248, COMP_LLETTER | 249, COMP_LLETTER | 250, COMP_LLETTER | 251, // 
    COMP_LLETTER | 252, COMP_LLETTER | 253, COMP_LLETTER | 254, COMP_LLETTER | 255, // 
};

// Now include the C file that actually defines CompareStringA.  Define 'COMPSTRA' first so that
// the file knows that we want CompareStringA, and not CompareStringW
#define COMPSTRA
#include "compstr.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\datetime.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    datetime.c

Abstract:

    This module implements Win32 time of day functions

Author:

    Mark Lucovsky (markl) 08-Oct-1990

Revision History:

--*/

#include "basedll.h"
#include <xboxp.h>
#include "xconfig.h"

VOID XapipGetTimeZoneBias(LARGE_INTEGER* bias);

#ifndef XAPILIBP

BOOLEAN
RtlpCutoverTimeToSystemTime(
    PSYSTEMTIME CutoverTime,
    PLARGE_INTEGER SystemTime,
    PLARGE_INTEGER CurrentSystemTime,
    BOOLEAN ThisYear
    )
{
    SYSTEMTIME stCurrentSystemTime;

    //
    // Get the current system time
    //

    FileTimeToSystemTime((PFILETIME) CurrentSystemTime, &stCurrentSystemTime);

    //
    // check for absolute time field. If the year is specified,
    // the the time is an abosulte time
    //

    if ( CutoverTime->wYear ) {

        //
        // Convert this to a time value and make sure it
        // is greater than the current system time
        //

        if ( !SystemTimeToFileTime(CutoverTime,(PFILETIME) SystemTime) ) {
            return FALSE;
            }

        if (SystemTime->QuadPart < CurrentSystemTime->QuadPart) {
            return FALSE;
            }
        return TRUE;
        }
    else {

        TIME_FIELDS WorkingTimeField;
        TIME_FIELDS ScratchTimeField;
        LARGE_INTEGER ScratchTime;
        CSHORT BestWeekdayDate;
        CSHORT WorkingWeekdayNumber;
        CSHORT TargetWeekdayNumber;
        CSHORT TargetYear;
        CSHORT TargetMonth;
        CSHORT TargetWeekday;     // range [0..6] == [Sunday..Saturday]
        BOOLEAN MonthMatches;
        //
        // The time is an day in the month style time
        //
        // the convention is the Day is 1-5 specifying 1st, 2nd... Last
        // day within the month. The day is WeekDay.
        //

        //
        // Compute the target month and year
        //

        TargetWeekdayNumber = CutoverTime->wDay;
        if ( TargetWeekdayNumber > 5 || TargetWeekdayNumber == 0 ) {
            return FALSE;
            }
        TargetWeekday = CutoverTime->wDayOfWeek;
        TargetMonth = CutoverTime->wMonth;
        MonthMatches = FALSE;
        if ( !ThisYear ) {
            if ( TargetMonth < stCurrentSystemTime.wMonth ) {
                TargetYear = stCurrentSystemTime.wYear + 1;
                }
            else if ( TargetMonth > stCurrentSystemTime.wMonth ) {
                TargetYear = stCurrentSystemTime.wYear;
                }
            else {
                TargetYear = stCurrentSystemTime.wYear;
                MonthMatches = TRUE;
                }
            }
        else {
            TargetYear = stCurrentSystemTime.wYear;
            }
try_next_year:
        BestWeekdayDate = 0;

        WorkingTimeField.Year = TargetYear;
        WorkingTimeField.Month = TargetMonth;
        WorkingTimeField.Day = 1;
        WorkingTimeField.Hour = CutoverTime->wHour;
        WorkingTimeField.Minute = CutoverTime->wMinute;
        WorkingTimeField.Second = CutoverTime->wSecond;
        WorkingTimeField.Milliseconds = CutoverTime->wMilliseconds;
        WorkingTimeField.Weekday = 0;

        //
        // Convert to time and then back to time fields so we can determine
        // the weekday of day 1 on the month
        //

        if ( !RtlTimeFieldsToTime(&WorkingTimeField,&ScratchTime) ) {
            return FALSE;
            }
        RtlTimeToTimeFields(&ScratchTime,&ScratchTimeField);

        //
        // Compute bias to target weekday
        //
        if ( ScratchTimeField.Weekday > TargetWeekday ) {
            WorkingTimeField.Day += (7-(ScratchTimeField.Weekday - TargetWeekday));
            }
        else if ( ScratchTimeField.Weekday < TargetWeekday ) {
            WorkingTimeField.Day += (TargetWeekday - ScratchTimeField.Weekday);
            }

        //
        // We are now at the first weekday that matches our target weekday
        //

        BestWeekdayDate = WorkingTimeField.Day;
        WorkingWeekdayNumber = 1;

        //
        // Keep going one week at a time until we either pass the
        // target weekday, or we match exactly
        //

        while ( WorkingWeekdayNumber < TargetWeekdayNumber ) {
            WorkingTimeField.Day += 7;
            if ( !RtlTimeFieldsToTime(&WorkingTimeField,&ScratchTime) ) {
                break;
                }
            RtlTimeToTimeFields(&ScratchTime,&ScratchTimeField);
            WorkingWeekdayNumber++;
            BestWeekdayDate = ScratchTimeField.Day;
            }
        WorkingTimeField.Day = BestWeekdayDate;

        //
        // If the months match, and the date is less than the current
        // date, then be have to go to next year.
        //

        if ( !RtlTimeFieldsToTime(&WorkingTimeField,&ScratchTime) ) {
            return FALSE;
            }
        if ( MonthMatches ) {
            if ( WorkingTimeField.Day < stCurrentSystemTime.wDay ) {
                MonthMatches = FALSE;
                TargetYear++;
                goto try_next_year;
                }
            if ( WorkingTimeField.Day == stCurrentSystemTime.wDay ) {

                if (ScratchTime.QuadPart < CurrentSystemTime->QuadPart) {
                    MonthMatches = FALSE;
                    TargetYear++;
                    goto try_next_year;
                    }
                }
            }
        *SystemTime = ScratchTime;

        return TRUE;
        }
}

__inline VOID
XboxTimeZoneDateToSystemTime(
    const XBOX_TIMEZONE_DATE* tzdate,
    SYSTEMTIME* systime
    )
{
    memset(systime, 0, sizeof(*systime));
    systime->wMonth = tzdate->Month;
    systime->wDay = tzdate->Day;
    systime->wDayOfWeek = tzdate->DayOfWeek;
    systime->wHour = tzdate->Hour;
}

DWORD
WINAPI
XapipQueryTimeZoneInformation(
    OUT PTIME_ZONE_INFORMATION TimeZoneInformation,
    OUT PBOOL pfUseDST
    )
{
    ULONG ulType;
    DWORD dwRet;
    UCHAR buf[EEPROM_TOTAL_MEMORY_SIZE];
    XBOX_USER_SETTINGS* config;

    dwRet = XQueryValue(XC_MAX_OS, &ulType, buf, sizeof(buf), NULL);
    if (dwRet != ERROR_SUCCESS)
        return dwRet;

    config = (XBOX_USER_SETTINGS*) buf;
    TimeZoneInformation->Bias = config->TimeZoneBias;
    
    ASSERT(ARRAYSIZE(TimeZoneInformation->StandardName) >= (XC_TZNAMELEN + 1));
    XboxTimeZoneNameToWstr(config->TimeZoneStdName, TimeZoneInformation->StandardName);
    XboxTimeZoneNameToWstr(config->TimeZoneDltName, TimeZoneInformation->DaylightName);

    XboxTimeZoneDateToSystemTime(&config->TimeZoneStdDate, &TimeZoneInformation->StandardDate);
    XboxTimeZoneDateToSystemTime(&config->TimeZoneDltDate, &TimeZoneInformation->DaylightDate);

    TimeZoneInformation->StandardBias = config->TimeZoneStdBias;
    TimeZoneInformation->DaylightBias = config->TimeZoneDltBias;

    if (pfUseDST)
    {
        *pfUseDST = !(config->MiscFlags & XC_MISC_FLAG_DONT_USE_DST);
    }
    
    return ERROR_SUCCESS;
}

BOOL
WINAPI
XapipUseDaylightSavingTime()
{
    ULONG type, size;
    DWORD flags;

    return XQueryValue(XC_MISC_FLAGS, &type, &flags, sizeof(flags), &size) != ERROR_SUCCESS ||
           !(flags & XC_MISC_FLAG_DONT_USE_DST);
}

VOID XapipGetTimeZoneBias(LARGE_INTEGER* bias)
{
    TIME_ZONE_INFORMATION tzinfo;
    LONG tzbias;
    
    switch (GetTimeZoneInformation(&tzinfo)) {
    case TIME_ZONE_ID_UNKNOWN:
        tzbias = tzinfo.Bias;
        break;
    case TIME_ZONE_ID_STANDARD:
        tzbias = tzinfo.Bias + tzinfo.StandardBias;
        break;
    case TIME_ZONE_ID_DAYLIGHT:
        tzbias = tzinfo.Bias + tzinfo.DaylightBias;
        break;
    default:
        tzbias = 0;
        break;
    }

    bias->QuadPart = Int32x32To64(tzbias * 60, 10000000);
}

VOID
WINAPI
GetLocalTime(
    LPSYSTEMTIME lpLocalTime
    )

/*++

Routine Description:

    The current local system date and time can be returned using
    GetLocalTime.

Arguments:

    lpLocalTime - Returns the current system date and time:

        SYSTEMTIME Structure:

        WORD wYear - Returns the current year.

        WORD wMonth - Returns the current month with January equal to 1.

        WORD wDayOfWeek - Returns the current day of the week where
            0=Sunday, 1=Monday...

        WORD wDay - Returns the current day of the month.

        WORD wHour - Returns the current hour.

        WORD wMinute - Returns the current minute within the hour.

        WORD wSecond - Returns the current second within the minute.

        WORD wMilliseconds - Returns the current millisecond within the
            second.

Return Value:

    None.

--*/

{
    LARGE_INTEGER LocalTime;
    LARGE_INTEGER SystemTime;
    LARGE_INTEGER Bias;
    TIME_FIELDS TimeFields;

    KeQuerySystemTime(&SystemTime);

    XapipGetTimeZoneBias(&Bias);
    LocalTime.QuadPart = SystemTime.QuadPart - Bias.QuadPart;

    RtlTimeToTimeFields(&LocalTime,&TimeFields);

    lpLocalTime->wYear         = TimeFields.Year        ;
    lpLocalTime->wMonth        = TimeFields.Month       ;
    lpLocalTime->wDayOfWeek    = TimeFields.Weekday     ;
    lpLocalTime->wDay          = TimeFields.Day         ;
    lpLocalTime->wHour         = TimeFields.Hour        ;
    lpLocalTime->wMinute       = TimeFields.Minute      ;
    lpLocalTime->wSecond       = TimeFields.Second      ;
    lpLocalTime->wMilliseconds = TimeFields.Milliseconds;
}

VOID
WINAPI
GetSystemTime(
    LPSYSTEMTIME lpSystemTime
    )

/*++

Routine Description:

    The current system date and time (UTC based) can be returned using
    GetSystemTime.

Arguments:

    lpSystemTime - Returns the current system date and time:

        SYSTEMTIME Structure:

        WORD wYear - Returns the current year.

        WORD wMonth - Returns the current month with January equal to 1.

        WORD wDayOfWeek - Returns the current day of the week where
            0=Sunday, 1=Monday...

        WORD wDay - Returns the current day of the month.

        WORD wHour - Returns the current hour.

        WORD wMinute - Returns the current minute within the hour.

        WORD wSecond - Returns the current second within the minute.

        WORD wMilliseconds - Returns the current millisecond within the
            second.

Return Value:

    None.

--*/

{
    LARGE_INTEGER SystemTime;
    TIME_FIELDS TimeFields;

    KeQuerySystemTime(&SystemTime);

    RtlTimeToTimeFields(&SystemTime,&TimeFields);

    lpSystemTime->wYear         = TimeFields.Year        ;
    lpSystemTime->wMonth        = TimeFields.Month       ;
    lpSystemTime->wDayOfWeek    = TimeFields.Weekday     ;
    lpSystemTime->wDay          = TimeFields.Day         ;
    lpSystemTime->wHour         = TimeFields.Hour        ;
    lpSystemTime->wMinute       = TimeFields.Minute      ;
    lpSystemTime->wSecond       = TimeFields.Second      ;
    lpSystemTime->wMilliseconds = TimeFields.Milliseconds;
}


DWORD
GetTickCount(
    VOID
    )

/*++

Routine Description:

    Win32 systems implement a free-running millisecond counter.  The
    value of this counter can be read using GetTickCount.

Arguments:

    None.

Return Value:

    This function returns the number of milliseconds that have elapsed
    since the system was started. If the system has been running for
    a long time, it is possible that the count will repeat. The value of
    the counter is accurate within 55 milliseconds.

--*/

{
    return (DWORD)NtGetTickCount();
}

BOOL
APIENTRY
FileTimeToSystemTime(
    CONST FILETIME *lpFileTime,
    LPSYSTEMTIME lpSystemTime
    )

/*++

Routine Description:

    This functions converts a 64-bit file time value to a time in system
    time format.

Arguments:

    lpFileTime - Supplies the 64-bit file time to convert to the system
        date and time format.

    lpSystemTime - Returns the converted value of the 64-bit file time.

Return Value:

    TRUE - The 64-bit file time was successfully converted.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    LARGE_INTEGER FileTime;
    TIME_FIELDS TimeFields;

    FileTime.LowPart = lpFileTime->dwLowDateTime;
    FileTime.HighPart = lpFileTime->dwHighDateTime;

#if DBG
    if (FileTime.QuadPart < 0)
    {
        RIP("FileTimeToSystemTime() invalid parameter (lpFileTime)");
    }
#endif // DBG

    RtlTimeToTimeFields(&FileTime, &TimeFields);

    lpSystemTime->wYear         = TimeFields.Year        ;
    lpSystemTime->wMonth        = TimeFields.Month       ;
    lpSystemTime->wDay          = TimeFields.Day         ;
    lpSystemTime->wDayOfWeek    = TimeFields.Weekday     ;
    lpSystemTime->wHour         = TimeFields.Hour        ;
    lpSystemTime->wMinute       = TimeFields.Minute      ;
    lpSystemTime->wSecond       = TimeFields.Second      ;
    lpSystemTime->wMilliseconds = TimeFields.Milliseconds;

    return TRUE;
}


BOOL
APIENTRY
SystemTimeToFileTime(
    CONST SYSTEMTIME *lpSystemTime,
    LPFILETIME lpFileTime
    )

/*++

Routine Description:

    This functions converts a system time value into a 64-bit file time.

Arguments:

    lpSystemTime - Supplies the time that is to be converted into
        the 64-bit file time format.  The wDayOfWeek field is ignored.

    lpFileTime - Returns the 64-bit file time representation of
        lpSystemTime.

Return Value:

    TRUE - The time was successfully converted.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    TIME_FIELDS TimeFields;
    LARGE_INTEGER FileTime;

    TimeFields.Year         = lpSystemTime->wYear        ;
    TimeFields.Month        = lpSystemTime->wMonth       ;
    TimeFields.Day          = lpSystemTime->wDay         ;
    TimeFields.Hour         = lpSystemTime->wHour        ;
    TimeFields.Minute       = lpSystemTime->wMinute      ;
    TimeFields.Second       = lpSystemTime->wSecond      ;
    TimeFields.Milliseconds = lpSystemTime->wMilliseconds;

    if ( !RtlTimeFieldsToTime(&TimeFields,&FileTime)) {
        XapiSetLastNTError(STATUS_INVALID_PARAMETER);
        return FALSE;
        }
    else {
        lpFileTime->dwLowDateTime = FileTime.LowPart;
        lpFileTime->dwHighDateTime = FileTime.HighPart;
        return TRUE;
        }
}

BOOL
WINAPI
FileTimeToLocalFileTime(
    CONST FILETIME *lpFileTime,
    LPFILETIME lpLocalFileTime
    )

/*++

Routine Description:

    This functions converts a UTC based file time to a local file time.

Arguments:

    lpFileTime - Supplies the UTC based file time that is to be
        converted into a local file time

    lpLocalFileTime - Returns the 64-bit local file time representation of
        lpFileTime.

Return Value:

    TRUE - The time was successfully converted.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/
{
    LARGE_INTEGER FileTime;
    LARGE_INTEGER LocalFileTime;
    LARGE_INTEGER Bias;

    XapipGetTimeZoneBias(&Bias);

    FileTime.LowPart = lpFileTime->dwLowDateTime;
    FileTime.HighPart = lpFileTime->dwHighDateTime;

    LocalFileTime.QuadPart = FileTime.QuadPart - Bias.QuadPart;

    lpLocalFileTime->dwLowDateTime = LocalFileTime.LowPart;
    lpLocalFileTime->dwHighDateTime = LocalFileTime.HighPart;

    return TRUE;
}

BOOL
WINAPI
LocalFileTimeToFileTime(
    CONST FILETIME *lpLocalFileTime,
    LPFILETIME lpFileTime
    )

/*++

Routine Description:

    This functions converts a local file time to a UTC based file time.

Arguments:

    lpLocalFileTime - Supplies the local file time that is to be
        converted into a UTC based file time

    lpFileTime - Returns the 64-bit UTC based file time representation of
        lpLocalFileTime.

Return Value:

    TRUE - The time was successfully converted.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/
{
    LARGE_INTEGER FileTime;
    LARGE_INTEGER LocalFileTime;
    LARGE_INTEGER Bias;

    XapipGetTimeZoneBias(&Bias);

    LocalFileTime.LowPart = lpLocalFileTime->dwLowDateTime;
    LocalFileTime.HighPart = lpLocalFileTime->dwHighDateTime;

    FileTime.QuadPart = LocalFileTime.QuadPart + Bias.QuadPart;

    lpFileTime->dwLowDateTime = FileTime.LowPart;
    lpFileTime->dwHighDateTime = FileTime.HighPart;

    return TRUE;
}

LONG
APIENTRY
CompareFileTime(
    CONST FILETIME *lpFileTime1,
    CONST FILETIME *lpFileTime2
    )

/*++

Routine Description:

    This function compares two 64-bit file times.

Arguments:

    lpFileTime1 - pointer to a 64-bit file time.

    lpFileTime2 - pointer to a 64-bit file time.

Return Value:

    -1 - *lpFileTime1 <  *lpFileTime2

     0 - *lpFileTime1 == *lpFileTime2

    +1 - *lpFileTime1 >  *lpFileTime2

--*/

{
    ULARGE_INTEGER FileTime1;
    ULARGE_INTEGER FileTime2;

    FileTime1.LowPart = lpFileTime1->dwLowDateTime;
    FileTime1.HighPart = lpFileTime1->dwHighDateTime;
    FileTime2.LowPart = lpFileTime2->dwLowDateTime;
    FileTime2.HighPart = lpFileTime2->dwHighDateTime;
    if (FileTime1.QuadPart < FileTime2.QuadPart) {
        return( -1 );
        }
    else
    if (FileTime1.QuadPart > FileTime2.QuadPart) {
        return( 1 );
        }
    else {
        return( 0 );
        }
}

DWORD
WINAPI
GetTimeZoneInformation(
    LPTIME_ZONE_INFORMATION lpTimeZoneInformation
    )

/*++

Routine Description:

    This function allows an application to get the current timezone
    parameters These parameters control the Universal time to Local time
    translations.

    All UTC time to Local time translations are based on the following
    formula:

        UTC = LocalTime + Bias

    The return value of this function is the systems best guess of
    the current time zone parameters. This is one of:

        - Unknown

        - Standard Time

        - Daylight Savings Time

    If SetTimeZoneInformation was called without the transition date
    information, Unknown is returned, but the currect bias is used for
    local time translation.  Otherwise, the system will correctly pick
    either daylight savings time or standard time.

    The information returned by this API is identical to the information
    stored in the last successful call to SetTimeZoneInformation.  The
    exception is the Bias field returns the current Bias value in

Arguments:

    lpTimeZoneInformation - Supplies the address of the time zone
        information structure.

Return Value:

    TIME_ZONE_ID_UNKNOWN - The system can not determine the current
        timezone.  This is usually due to a previous call to
        SetTimeZoneInformation where only the Bias was supplied and no
        transition dates were supplied.

    TIME_ZONE_ID_STANDARD - The system is operating in the range covered
        by StandardDate.

    TIME_ZONE_ID_DAYLIGHT - The system is operating in the range covered
        by DaylightDate.

    0xffffffff - The operation failed.  Extended error status is
        available using GetLastError.

--*/
{
    DWORD dwStatus;
    DWORD dwRet = TIME_ZONE_ID_UNKNOWN;
    BOOL fUseDST;
    LARGE_INTEGER StandardTime, DaylightTime, CurrentUniversalTime;
    LARGE_INTEGER TimeZoneBias;
    LARGE_INTEGER NewTimeZoneBias;
    LARGE_INTEGER LocalCustomBias;
    LARGE_INTEGER UtcStandardTime;
    LARGE_INTEGER UtcDaylightTime;
    //
    // get the timezone data from the system
    //

    dwStatus = XapipQueryTimeZoneInformation(lpTimeZoneInformation, &fUseDST);
    if (ERROR_SUCCESS != dwStatus)
    {
        SetLastError(dwStatus);
        return 0xffffffff;
    }

    if (!fUseDST)
    {
        //
        // If we're not using daylight saving time, clear all fields related to
        // daylight savings time
        //
        
        lpTimeZoneInformation->StandardBias = 0;
        RtlZeroMemory(&(lpTimeZoneInformation->StandardDate),
                      sizeof(lpTimeZoneInformation->StandardDate));
        
        lpTimeZoneInformation->DaylightBias = 0;
        RtlZeroMemory(&(lpTimeZoneInformation->DaylightDate),
                      sizeof(lpTimeZoneInformation->DaylightDate));
        RtlZeroMemory(lpTimeZoneInformation->DaylightName,
                      sizeof(lpTimeZoneInformation->DaylightName));
    }

    KeQuerySystemTime(&CurrentUniversalTime);

    //
    // Check to see if we have timezone cutover information and if so,
    // compute the cutover dates and compute what our current bias is
    //

    if (lpTimeZoneInformation->StandardDate.wMonth &&
        lpTimeZoneInformation->DaylightDate.wMonth &&
        RtlpCutoverTimeToSystemTime(
                &(lpTimeZoneInformation->StandardDate),
                &StandardTime,
                &CurrentUniversalTime,
                TRUE) &&
        RtlpCutoverTimeToSystemTime(
                &(lpTimeZoneInformation->DaylightDate),
                &DaylightTime,
                &CurrentUniversalTime,
                TRUE))
    {
        //
        // Get the new timezone bias
        //

        NewTimeZoneBias.QuadPart = Int32x32To64(lpTimeZoneInformation->Bias*60, 10000000);
    
        //
        // Convert standard time and daylight time to utc
        //

        LocalCustomBias.QuadPart = Int32x32To64(lpTimeZoneInformation->StandardBias*60, 10000000);
        TimeZoneBias.QuadPart = NewTimeZoneBias.QuadPart + LocalCustomBias.QuadPart;
        UtcDaylightTime.QuadPart = DaylightTime.QuadPart + TimeZoneBias.QuadPart;

        LocalCustomBias.QuadPart = Int32x32To64(lpTimeZoneInformation->DaylightBias*60, 10000000);
        TimeZoneBias.QuadPart = NewTimeZoneBias.QuadPart + LocalCustomBias.QuadPart;
        UtcStandardTime.QuadPart = StandardTime.QuadPart + TimeZoneBias.QuadPart;
        
        //
        // If daylight < standard, then time >= daylight and
        // less than standard is daylight
        //

        if (UtcDaylightTime.QuadPart < UtcStandardTime.QuadPart)
        {
            //
            // If today is >= DaylightTime and < StandardTime, then
            // We are in daylight savings time
            //

            if ( (CurrentUniversalTime.QuadPart >= UtcDaylightTime.QuadPart) &&
                 (CurrentUniversalTime.QuadPart < UtcStandardTime.QuadPart) )
            {
                dwRet = TIME_ZONE_ID_DAYLIGHT;
            }
            else
            {
                dwRet = TIME_ZONE_ID_STANDARD;
            }
        }
        else
        {
            //
            // If today is >= StandardTime and < DaylightTime, then
            // We are in standard time
            //

            if ( (CurrentUniversalTime.QuadPart >= UtcStandardTime.QuadPart) &&
                 (CurrentUniversalTime.QuadPart < UtcDaylightTime.QuadPart) )
            {
                dwRet = TIME_ZONE_ID_STANDARD;
            }
            else
            {
                dwRet = TIME_ZONE_ID_DAYLIGHT;
            }
        }
    }

    return dwRet;
}

#else  // ! XAPILIBP

__inline VOID
SystemTimeToXboxTimeZoneDate(
    const SYSTEMTIME* systime,
    XBOX_TIMEZONE_DATE* tzdate
    )
{
    ASSERT(systime->wYear == 0);
    tzdate->Month = (BYTE) systime->wMonth;
    tzdate->Day = (BYTE) systime->wDay;
    tzdate->DayOfWeek = (BYTE) systime->wDayOfWeek;
    tzdate->Hour = (BYTE) systime->wHour;
}

DWORD
WINAPI
XapipSetTimeZoneInformation(
    IN PTIME_ZONE_INFORMATION TimeZoneInformation
    )
{
    ULONG ulType, ulSize;
    DWORD dwRet;
    CHAR buf[EEPROM_TOTAL_MEMORY_SIZE];
    XBOX_USER_SETTINGS* config;

    dwRet = XQueryValue(XC_MAX_OS, &ulType, buf, sizeof(buf), &ulSize);
    if (dwRet != ERROR_SUCCESS)
        return dwRet;

    config = (XBOX_USER_SETTINGS*) buf;
    config->TimeZoneBias = TimeZoneInformation->Bias;

    WstrToXboxTimeZoneName(TimeZoneInformation->StandardName, config->TimeZoneStdName);
    WstrToXboxTimeZoneName(TimeZoneInformation->DaylightName, config->TimeZoneDltName);

    SystemTimeToXboxTimeZoneDate(&TimeZoneInformation->StandardDate, &config->TimeZoneStdDate);
    SystemTimeToXboxTimeZoneDate(&TimeZoneInformation->DaylightDate, &config->TimeZoneDltDate);

    config->TimeZoneStdBias = TimeZoneInformation->StandardBias;
    config->TimeZoneDltBias = TimeZoneInformation->DaylightBias;

    return XSetValue(XC_MAX_OS, REG_BINARY, buf, ulSize);
}


BOOL
WINAPI
XapiSetSystemTime(
    CONST SYSTEMTIME *lpSystemTime
    )

/*++

Routine Description:

    The current UTC based system date and time can be set using
    SetSystemTime.

Arguments:

    lpSystemTime - Supplies the date and time to set. The wDayOfWeek field
        is ignored.

Return Value:

    TRUE - The current system date and time was set.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    LARGE_INTEGER SystemTime;
    TIME_FIELDS TimeFields;
    BOOLEAN ReturnValue;
    PVOID State;
    NTSTATUS Status;

    ReturnValue = TRUE;

    TimeFields.Year         = lpSystemTime->wYear        ;
    TimeFields.Month        = lpSystemTime->wMonth       ;
    TimeFields.Day          = lpSystemTime->wDay         ;
    TimeFields.Hour         = lpSystemTime->wHour        ;
    TimeFields.Minute       = lpSystemTime->wMinute      ;
    TimeFields.Second       = lpSystemTime->wSecond      ;
    TimeFields.Milliseconds = lpSystemTime->wMilliseconds;

    if ( !RtlTimeFieldsToTime(&TimeFields,&SystemTime) ) {
        Status = STATUS_INVALID_PARAMETER;
        ReturnValue = FALSE;
        }
    else {
        NtSetSystemTime(&SystemTime,NULL);
        }

    if ( !ReturnValue ) {
        XapiSetLastNTError(Status);
        }

    return ReturnValue;
}

BOOL
WINAPI
XapiSetLocalTime(
    CONST SYSTEMTIME *lpLocalTime
    )

/*++

Routine Description:

    The current local system date and time can be set using
    SetLocalTime.

Arguments:

    lpSystemTime - Supplies the date and time to set. The wDayOfWeek field
        is ignored.

Return Value:

    TRUE - The current system date and time was set.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    LARGE_INTEGER SystemTime;
    LARGE_INTEGER LocalTime;
    TIME_FIELDS TimeFields;
    BOOLEAN ReturnValue;
    PVOID State;
    NTSTATUS Status;
    LARGE_INTEGER Bias;

    XapipGetTimeZoneBias(&Bias);
    ReturnValue = TRUE;

    TimeFields.Year         = lpLocalTime->wYear        ;
    TimeFields.Month        = lpLocalTime->wMonth       ;
    TimeFields.Day          = lpLocalTime->wDay         ;
    TimeFields.Hour         = lpLocalTime->wHour        ;
    TimeFields.Minute       = lpLocalTime->wMinute      ;
    TimeFields.Second       = lpLocalTime->wSecond      ;
    TimeFields.Milliseconds = lpLocalTime->wMilliseconds;

    if ( !RtlTimeFieldsToTime(&TimeFields,&LocalTime) ) {
        Status = STATUS_INVALID_PARAMETER;
        ReturnValue = FALSE;
        }
    else {

        SystemTime.QuadPart = LocalTime.QuadPart + Bias.QuadPart;
        NtSetSystemTime(&SystemTime,NULL);
        }

    if ( !ReturnValue ) {
        XapiSetLastNTError(Status);
        }

    return ReturnValue;
}

#endif // ! XAPILIBP


// xbox doesn't allow you to set the time (at least, for now)
#if 0
BOOL
WINAPI
SetTimeZoneInformation(
    CONST TIME_ZONE_INFORMATION *lpTimeZoneInformation
    )

/*++

Routine Description:

    This function allows an application to set timezone parameters into
    their system.  These parameters control the Universal time to Local
    time translations.

    All UTC time to Local time translations are based on the following
    formula:

        UTC = LocalTime + Bias

    This API allows the caller to program the current time zone bias,
    and optionally set up the system to automatically sense daylight
    savings time and standard time transitions.

    The timezone bias information is controlled by the
    TIME_ZONE_INFORMATION structure.

    Bias - Supplies the current bias in minutes for local time
        translation on this machine where LocalTime + Bias = UTC.  This
        is a required filed of this structure.

    StandardName - Supplies an optional abbreviation string associated
        with standard time on this system.  This string is uniterpreted
        and is supplied and used only by callers of this API and of
        GetTimeZoneInformation.

    StandardDate - Supplies an optional date and time (UTC) that
        describes the transition into standard time.  A value of 0 in
        the wMonth field tells the system that StandardDate is not
        specified.  If this field is specified, then DaylightDate must
        also be specified.  Additionally, local time translations done
        during the StandardTime range will be done relative to the
        supplied StandardBias value (added to Bias).

        This field supports two date formats. Absolute form specifies and
        exact date and time when standard time begins. In this form, the
        wYear, wMonth, wDay, wHour, wMinute, wSecond, and wMilliseconds
        of the SYSTEMTIME structure are used to specify an exact date.

        Day-in-month time is specified by setting wYear to 0, setting
        wDayOfWeek to an appropriate weekday, and using wDay in the
        range of 1-5 to select the correct day in the month.  Using this
        notation, the first sunday in april may be specified as can be
        the last thursday in october (5 is equal to "the last").

    StandardBias - Supplies an optional bias value to be used during
        local time translations that occur during Standard Time. This
        field is ignored if StandardDate is not supplied.
         This bias value
        is added to the Bias field to form the Bias used during standard
        time. In most time zones, the value of this field is zero.

    DaylightName - Supplies an optional abbreviation string associated
        with daylight savings time on this system.  This string is
        uniterpreted and is supplied and used only by callers of this
        API and of GetTimeZoneInformation.

    DaylightDate - Supplies an optional date and time (UTC) that
        describes the transition into daylight savings time.  A value of
        0 in the wMonth field tells the system that DaylightDate is not
        specified.  If this field is specified, then StandardDate must
        also be specified.  Additionally, local time translations done
        during the DaylightTime range will be done relative to the
        supplied DaylightBias value (added to Bias). The same dat formats
        supported by StandardDate are supported ib DaylightDate.

    DaylightBias - Supplies an optional bias value to be used during
        local time translations that occur during Daylight Savings Time.
        This field is ignored if DaylightDate is not supplied.  This
        bias value is added to the Bias field to form the Bias used
        during daylight time.  In most time zones, the value of this
        field is -60.

Arguments:

    lpTimeZoneInformation - Supplies the address of the time zone
        information structure.

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/
{
    RTL_TIME_ZONE_INFORMATION tzi;
    NTSTATUS Status;

    tzi.Bias            = lpTimeZoneInformation->Bias;
    tzi.StandardBias    = lpTimeZoneInformation->StandardBias;
    tzi.DaylightBias    = lpTimeZoneInformation->DaylightBias;

    RtlMoveMemory(&tzi.StandardName,&lpTimeZoneInformation->StandardName,sizeof(tzi.StandardName));
    RtlMoveMemory(&tzi.DaylightName,&lpTimeZoneInformation->DaylightName,sizeof(tzi.DaylightName));

    tzi.StandardStart.Year         = lpTimeZoneInformation->StandardDate.wYear        ;
    tzi.StandardStart.Month        = lpTimeZoneInformation->StandardDate.wMonth       ;
    tzi.StandardStart.Weekday      = lpTimeZoneInformation->StandardDate.wDayOfWeek   ;
    tzi.StandardStart.Day          = lpTimeZoneInformation->StandardDate.wDay         ;
    tzi.StandardStart.Hour         = lpTimeZoneInformation->StandardDate.wHour        ;
    tzi.StandardStart.Minute       = lpTimeZoneInformation->StandardDate.wMinute      ;
    tzi.StandardStart.Second       = lpTimeZoneInformation->StandardDate.wSecond      ;
    tzi.StandardStart.Milliseconds = lpTimeZoneInformation->StandardDate.wMilliseconds;

    tzi.DaylightStart.Year         = lpTimeZoneInformation->DaylightDate.wYear        ;
    tzi.DaylightStart.Month        = lpTimeZoneInformation->DaylightDate.wMonth       ;
    tzi.DaylightStart.Weekday      = lpTimeZoneInformation->DaylightDate.wDayOfWeek   ;
    tzi.DaylightStart.Day          = lpTimeZoneInformation->DaylightDate.wDay         ;
    tzi.DaylightStart.Hour         = lpTimeZoneInformation->DaylightDate.wHour        ;
    tzi.DaylightStart.Minute       = lpTimeZoneInformation->DaylightDate.wMinute      ;
    tzi.DaylightStart.Second       = lpTimeZoneInformation->DaylightDate.wSecond      ;
    tzi.DaylightStart.Milliseconds = lpTimeZoneInformation->DaylightDate.wMilliseconds;

    Status = RtlSetTimeZoneInformation( &tzi );
    if (!NT_SUCCESS( Status )) {
        XapiSetLastNTError(Status);
        return FALSE;
        }
    //
    // Refresh the system's concept of time
    //

    NtSetSystemTime(NULL,NULL);

    return TRUE;
}
#endif // 0

// xbox does not support these:
#if 0

BOOL
WINAPI
GetSystemTimeAdjustment(
    PDWORD lpTimeAdjustment,
    PDWORD lpTimeIncrement,
    PBOOL  lpTimeAdjustmentDisabled
    )

/*++

Routine Description:

    This function is used to support algorithms that want to synchronize
    the time of day (reported via GetSystemTime and GetLocalTime) with
    another time source using a programmed clock adjustment over a
    period of time.

    To facilitate this, the system computes the time of day by adding a
    value to a time of day counter at a periodic interval.  This API
    allows the caller to obtain the periodic interval (clock interrupt
    rate), and the amount added to the time of day with each interrupt.

    A boolean value is also returned which indicates whether or not this
    time adjustment algorithm is even being used.  A value of TRUE
    indicates that adjustment is not being used.  If this is the case,
    the system may attempt to keep the time of day clock in sync using
    its own internal mechanisms.  This may cause time of day to
    periodicly "jump" to the "correct time".


Arguments:

    lpTimeAdjustment - Returns the number of 100ns units added to the
        time of day counter at each clock interrupt.

    lpTimeIncrement - Returns the clock interrupt rate in 100ns units.

    lpTimeAdjustmentDisabled - Returns an indicator which specifies
        whether or not time adjustment is inabled.  A value of TRUE
        indicates that periodic adjustment is disabled
        (*lpTimeAdjustment == *lpTimeIncrement), AND that the system is
        free to serialize time of day using any mechanism it wants.
        This may cause periodic time jumps as the system serializes time
        of day to the "correct time".  A value of false indicates that
        programmed time adjustment is being used to serialize the time
        of day, and that the system will not interfere with this scheme
        and will not attempt to synchronize time of day on its own.

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation failed.  Use GetLastError to obtain detailed
        error information.

--*/
{
    NTSTATUS Status;
    SYSTEM_QUERY_TIME_ADJUST_INFORMATION TimeAdjust;
    BOOL b;
    Status = NtQuerySystemInformation(
                SystemTimeAdjustmentInformation,
                &TimeAdjust,
                sizeof(TimeAdjust),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        b = FALSE;
        }
    else {
        *lpTimeAdjustment = TimeAdjust.TimeAdjustment;
        *lpTimeIncrement = TimeAdjust.TimeIncrement;
        *lpTimeAdjustmentDisabled = TimeAdjust.Enable;
        b = TRUE;
        }

    return b;
}

BOOL
WINAPI
SetSystemTimeAdjustment(
    DWORD dwTimeAdjustment,
    BOOL  bTimeAdjustmentDisabled
    )

/*++

Routine Description:

    This function is used to tell the system the parameters it should
    use to periodicaly synchronize time of day with some other source.

    This API supports two modes of operation.

    In the first mode, bTimeAdjustmentDisabled is set to FALSE.  At each
    clock interrupt, the value of dwTimeAdjustment is added to the time
    of day.  The clock interrupt rate may be obtained using
    GetSystemTimeAdjustment, and looking at the returned value of
    lpTimeIncrement.

    In the second mode, bTimeAdjustmentDisabled is set to TRUE.  At each
    clock interrupt, the clock interrupt rate is added to the time of
    day.  The system may also periodically refresh the time of day using
    other internal algorithms.  These may produce "jumps" in time.

    The application must have system-time privilege (the
    SE_SYSTEMTIME_NAME privilege) for this function to succeed.  This
    privilege is disabled by default.  Use the AdjustTokenPrivileges
    function to enable the privilege and again to disable it after the
    time adjustment has been set.

Arguments:

    dwTimeAdjustment - Supplies the value (in 100ns units) that is to be
        added to the time of day at each clock interrupt.

    bTimeAdjustmentDisabled - Supplies a flag which specifies the time
        adjustment mode that the system is to use.  A value of TRUE
        indicates the the system should synchronize time of day using
        its own internal mechanisms.  When this is the case, the value
        of dwTimeAdjustment is ignored.  A value of FALSE indicates that
        the application is in control, and that the value specified by
        dwTimeAdjustment is to be added to the time of day at each clock
        interrupt.

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation failed.  Use GetLastError to obtain detailed
        error information.

--*/

{
    NTSTATUS Status;
    SYSTEM_SET_TIME_ADJUST_INFORMATION TimeAdjust;
    BOOL b;

    b = TRUE;
    TimeAdjust.TimeAdjustment = dwTimeAdjustment;
    TimeAdjust.Enable = (BOOLEAN)bTimeAdjustmentDisabled;
    Status = NtSetSystemInformation(
                SystemTimeAdjustmentInformation,
                &TimeAdjust,
                sizeof(TimeAdjust)
                );
    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        b = FALSE;
        }

    return b;
}

BOOL
WINAPI
SystemTimeToTzSpecificLocalTime(
    LPTIME_ZONE_INFORMATION lpTimeZoneInformation,
    LPSYSTEMTIME lpUniversalTime,
    LPSYSTEMTIME lpLocalTime
    )
{

    TIME_ZONE_INFORMATION TziData;
    LPTIME_ZONE_INFORMATION Tzi;
    RTL_TIME_ZONE_INFORMATION tzi;
    LARGE_INTEGER TimeZoneBias;
    LARGE_INTEGER NewTimeZoneBias;
    LARGE_INTEGER LocalCustomBias;
    LARGE_INTEGER StandardTime;
    LARGE_INTEGER DaylightTime;
    LARGE_INTEGER UtcStandardTime;
    LARGE_INTEGER UtcDaylightTime;
    LARGE_INTEGER CurrentUniversalTime;
    LARGE_INTEGER ComputedLocalTime;
    ULONG CurrentTimeZoneId = 0xffffffff;

    //
    // Get the timezone information into a useful format
    //
    if ( !ARGUMENT_PRESENT(lpTimeZoneInformation) ) {

        //
        // Convert universal time to local time using current timezone info
        //
        if (GetTimeZoneInformation(&TziData) == TIME_ZONE_ID_INVALID) {
            return FALSE;
            }
        Tzi = &TziData;
        }
    else {
        Tzi = lpTimeZoneInformation;
        }

    tzi.Bias            = Tzi->Bias;
    tzi.StandardBias    = Tzi->StandardBias;
    tzi.DaylightBias    = Tzi->DaylightBias;

    RtlMoveMemory(&tzi.StandardName,&Tzi->StandardName,sizeof(tzi.StandardName));
    RtlMoveMemory(&tzi.DaylightName,&Tzi->DaylightName,sizeof(tzi.DaylightName));

    tzi.StandardStart.Year         = Tzi->StandardDate.wYear        ;
    tzi.StandardStart.Month        = Tzi->StandardDate.wMonth       ;
    tzi.StandardStart.Weekday      = Tzi->StandardDate.wDayOfWeek   ;
    tzi.StandardStart.Day          = Tzi->StandardDate.wDay         ;
    tzi.StandardStart.Hour         = Tzi->StandardDate.wHour        ;
    tzi.StandardStart.Minute       = Tzi->StandardDate.wMinute      ;
    tzi.StandardStart.Second       = Tzi->StandardDate.wSecond      ;
    tzi.StandardStart.Milliseconds = Tzi->StandardDate.wMilliseconds;

    tzi.DaylightStart.Year         = Tzi->DaylightDate.wYear        ;
    tzi.DaylightStart.Month        = Tzi->DaylightDate.wMonth       ;
    tzi.DaylightStart.Weekday      = Tzi->DaylightDate.wDayOfWeek   ;
    tzi.DaylightStart.Day          = Tzi->DaylightDate.wDay         ;
    tzi.DaylightStart.Hour         = Tzi->DaylightDate.wHour        ;
    tzi.DaylightStart.Minute       = Tzi->DaylightDate.wMinute      ;
    tzi.DaylightStart.Second       = Tzi->DaylightDate.wSecond      ;
    tzi.DaylightStart.Milliseconds = Tzi->DaylightDate.wMilliseconds;

    //
    // convert the input universal time to NT style time
    //
    if ( !SystemTimeToFileTime(lpUniversalTime,(LPFILETIME)&CurrentUniversalTime) ) {
        return FALSE;
        }

    //
    // Get the new timezone bias
    //

    NewTimeZoneBias.QuadPart = Int32x32To64(tzi.Bias*60, 10000000);

    //
    // Now see if we have stored cutover times
    //

    if ( tzi.StandardStart.Month && tzi.DaylightStart.Month ) {

        //
        // We have timezone cutover information. Compute the
        // cutover dates and compute what our current bias
        // is
        //

        if ( !RtlpCutoverTimeToSystemTime(
                &tzi.StandardStart,
                &StandardTime,
                &CurrentUniversalTime,
                TRUE
                ) ) {
            XapiSetLastNTError(STATUS_INVALID_PARAMETER);
            return FALSE;
            }

        if ( !RtlpCutoverTimeToSystemTime(
                &tzi.DaylightStart,
                &DaylightTime,
                &CurrentUniversalTime,
                TRUE
                ) ) {
            XapiSetLastNTError(STATUS_INVALID_PARAMETER);
            return FALSE;
            }

        //
        // Convert standard time and daylight time to utc
        //

        LocalCustomBias.QuadPart = Int32x32To64(tzi.StandardBias*60, 10000000);
        TimeZoneBias.QuadPart = NewTimeZoneBias.QuadPart + LocalCustomBias.QuadPart;
        UtcDaylightTime.QuadPart = DaylightTime.QuadPart + TimeZoneBias.QuadPart;

        LocalCustomBias.QuadPart = Int32x32To64(tzi.DaylightBias*60, 10000000);
        TimeZoneBias.QuadPart = NewTimeZoneBias.QuadPart + LocalCustomBias.QuadPart;
        UtcStandardTime.QuadPart = StandardTime.QuadPart + TimeZoneBias.QuadPart;

        //
        // If daylight < standard, then time >= daylight and
        // less than standard is daylight
        //

        if ( UtcDaylightTime.QuadPart < UtcStandardTime.QuadPart ) {

            //
            // If today is >= DaylightTime and < StandardTime, then
            // We are in daylight savings time
            //

            if ( (CurrentUniversalTime.QuadPart >= UtcDaylightTime.QuadPart) &&
                 (CurrentUniversalTime.QuadPart < UtcStandardTime.QuadPart) ) {

                CurrentTimeZoneId = TIME_ZONE_ID_DAYLIGHT;
                }
            else {
                CurrentTimeZoneId = TIME_ZONE_ID_STANDARD;
                }
            }
        else {

            //
            // If today is >= StandardTime and < DaylightTime, then
            // We are in standard time
            //

            if ( (CurrentUniversalTime.QuadPart >= UtcStandardTime.QuadPart ) &&
                 (CurrentUniversalTime.QuadPart < UtcDaylightTime.QuadPart ) ) {

                CurrentTimeZoneId = TIME_ZONE_ID_STANDARD;
                }
            else {
                CurrentTimeZoneId = TIME_ZONE_ID_DAYLIGHT;
                }
            }

        //
        // At this point, we know our current timezone and the
        // Universal time of the next cutover.
        //

        LocalCustomBias.QuadPart = Int32x32To64(
                            CurrentTimeZoneId == TIME_ZONE_ID_DAYLIGHT ?
                                tzi.DaylightBias*60 :
                                tzi.StandardBias*60,                // Bias in seconds
                            10000000
                            );

        TimeZoneBias.QuadPart = NewTimeZoneBias.QuadPart + LocalCustomBias.QuadPart;

        }
    else {
        TimeZoneBias = NewTimeZoneBias;
        }

    ComputedLocalTime.QuadPart = CurrentUniversalTime.QuadPart - TimeZoneBias.QuadPart;

    if ( !FileTimeToSystemTime((LPFILETIME)&ComputedLocalTime,lpLocalTime) ) {
        return FALSE;
        }

    return TRUE;
}

#endif // 0
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\inc\xmeta.h ===
#pragma once

static const OCHAR g_cszSaveMetaFileName[] = OTEXT("\\SaveMeta.xbx");
static const int   g_cchSaveMetaFileName   = ARRAYSIZE(g_cszSaveMetaFileName) - 1;

static const OCHAR g_cszTitleMetaFileName[] = OTEXT("\\TitleMeta.xbx");
static const int   g_cchTitleMetaFileName   = ARRAYSIZE(g_cszTitleMetaFileName) - 1;

static const OCHAR g_cszTitleImageFileName[] = OTEXT("\\TitleImage.xbx");
static const int   g_cchTitleImageFileName   = ARRAYSIZE(g_cszTitleImageFileName) - 1;

static const OCHAR g_cszSaveImageFileName[] = OTEXT("\\SaveImage.xbx");
static const int   g_cchSaveImageFileName   = ARRAYSIZE(g_cszSaveImageFileName) - 1;

static const OCHAR g_cszContentMetaFileName[] = OTEXT("\\ContentMeta.xbx");
static const int   g_cchContentMetaFileName   = ARRAYSIZE(g_cszContentMetaFileName) - 1;

static const WCHAR g_cszNameTag[] = L"Name";
#define g_cchNameTag (ARRAYSIZE(g_cszNameTag) - 1)

static const WCHAR g_cszTitleNameTag[] = L"TitleName";
#define g_cchTitleNameTag (ARRAYSIZE(g_cszTitleNameTag) - 1)

static const OCHAR g_cszStar[] = OTEXT("*");
static const int   g_cchStar   = ARRAYSIZE(g_cszStar) - 1;

static const OCHAR g_cszContentSearch[] = OTEXT("$C\\*");
static const int   g_cchContentSearch   = ARRAYSIZE(g_cszContentSearch) - 1;

static const OCHAR g_cszContentDir[] = OTEXT("$C\\");
static const int   g_cchContentDir   = ARRAYSIZE(g_cszContentDir) - 1;

static const WCHAR g_cszCRLF[] = L"\r\n";
#define g_cchCRLF (ARRAYSIZE(g_cszCRLF) - 1)

static const WCHAR g_cszNoCopyTrue[] = L"NoCopy=1\r\n";
#define g_cchNoCopyTrue (ARRAYSIZE(g_cszNoCopyTrue) - 1)

static const WCHAR g_chEqual = L'=';
static const WCHAR g_chUnicodeSignature = 0xfeff;

#define MAX_TAGNAME       g_cchTitleNameTag
#define MAX_VALUENAME     MAX_GAMENAME
#define MAX_METADATA_LINE (MAX_TAGNAME + 1 + MAX_VALUENAME + g_cchCRLF + 1)

#define CONTENT_DIR_NAME_LENGTH     (8 + 1 + 8) // 00000000.00000000 (does not include null terminator)
#define CONTENT_DIR_DELIMETER       '.'
#define CONTENT_DIR_DELIMETER_INDEX 8
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\debugver.c ===
#include "basedll.h"
#include "xboxverp.h"
#pragma hdrstop

#ifdef _DEBUG

DWORD
WINAPI
XDebugGetSystemVersion(
    PSTR pszVersionString,
    UINT cchVersionString
    )
{
    RIP_ON_NOT_TRUE("XDebugGetSystemVersion()", (pszVersionString != NULL));

    _snprintf(pszVersionString,
              cchVersionString,
              "%d.%02d.%d.%02d",
              XboxKrnlVersion->Major,
              XboxKrnlVersion->Minor,
              XboxKrnlVersion->Build,
              (XboxKrnlVersion->Qfe & 0x7FFF));

    return (XboxKrnlVersion->Qfe & 0x8000) ? XVER_DEVKIT : XVER_RETAIL;
}

DWORD
WINAPI
XDebugGetXTLVersion(
    PSTR pszVersionString,
    UINT cchVersionString
    )
{
    RIP_ON_NOT_TRUE("XDebugGetXTLVersion()", (pszVersionString != NULL));

    _snprintf(pszVersionString,
              cchVersionString,
              "%d.%02d.%d.%02d",
              XeImageHeader()->XapiLibraryVersion->MajorVersion,
              XeImageHeader()->XapiLibraryVersion->MinorVersion,
              XeImageHeader()->XapiLibraryVersion->BuildVersion,
              XeImageHeader()->XapiLibraryVersion->QFEVersion);

    return XeImageHeader()->XapiLibraryVersion->DebugBuild ? XVER_DEVKIT : XVER_RETAIL;
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\dir.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    dir.c

Abstract:

    This module implements Win32 Directory functions.

Author:

    Mark Lucovsky (markl) 26-Sep-1990

Revision History:

--*/

#include "basedll.h"

BOOL
APIENTRY
CreateDirectory(
    PCOSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )

/*++

Routine Description:

    A directory can be created using CreateDirectory.

    This API causes a directory with the specified pathname to be
    created.  If the underlying file system supports security on files
    and directories, then the SecurityDescriptor argument is applied to
    the new directory.

    This call is similar to DOS (int 21h, function 39h) and OS/2's
    DosCreateDir.

Arguments:

    lpPathName - Supplies the pathname of the directory to be created.

    lpSecurityAttributes - Ignored on xbox.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    OBJECT_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;

    RtlInitObjectString(&FileName, lpPathName);

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        ObDosDevicesDirectory(),
        NULL
        );

    Status = NtCreateFile(
                &Handle,
                FILE_LIST_DIRECTORY | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_CREATE,
                FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                );

    if ( NT_SUCCESS(Status) ) {
        NtClose(Handle);
        return TRUE;
        }
    else {
        XapiSetLastNTError(Status);
        return FALSE;
        }
}

BOOL
APIENTRY
RemoveDirectory(
    PCOSTR lpPathName
    )

/*++

Routine Description:

    An existing directory can be removed using RemoveDirectory.

    This API causes a directory with the specified pathname to be
    deleted.  The directory must be empty before this call can succeed.

    This call is similar to DOS (int 21h, function 3Ah) and OS/2's
    DosDeleteDir.

Arguments:

    lpPathName - Supplies the pathname of the directory to be removed.
        The path must specify an empty directory to which the caller has
        delete access.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    OBJECT_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_DISPOSITION_INFORMATION Disposition;

    RtlInitObjectString(&FileName, lpPathName);

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        ObDosDevicesDirectory(),
        NULL
        );

    //
    // Open the directory for delete access.
    //

    Status = NtOpenFile(
                 &Handle,
                 DELETE | SYNCHRONIZE,
                 &Obja,
                 &IoStatusBlock,
                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                 FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                 );

    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        return FALSE;
        }

    //
    // Delete the file
    //
#undef DeleteFile
    Disposition.DeleteFile = TRUE;

    Status = NtSetInformationFile(
                Handle,
                &IoStatusBlock,
                &Disposition,
                sizeof(Disposition),
                FileDispositionInformation
                );

    NtClose(Handle);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        XapiSetLastNTError(Status);
        return FALSE;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\error.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    error.c

Abstract:

    This module contains the Win32 error APIs.

--*/

#include "basedll.h"

//
// Per thread last error code.
//
__declspec(thread) DWORD XapiLastErrorCode = 0;

ULONG
XapiSetLastNTError(
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This API sets the "last error value" and the "last error string"
    based on the value of Status. For status codes that don't have
    a corresponding error string, the string is set to null.

Arguments:

    Status - Supplies the status value to store as the last error value.

Return Value:

    The corresponding Win32 error code that was stored in the
    "last error value" thread variable.

--*/

{
    ULONG dwErrorCode;

    dwErrorCode = RtlNtStatusToDosError( Status );
    SetLastError( dwErrorCode );
    return( dwErrorCode );
}

#ifndef BUILD_FOR_XBDM

DWORD
WINAPI
GetLastError(
    VOID
    )

/*++

Routine Description:

    This function returns the most recent error code set by a Win32 API
    call.  Applications should call this function immediately after a
    Win32 API call returns a failure indications (e.g.  FALSE, NULL or
    -1) to determine the cause of the failure.

    The last error code value is a per thread field, so that multiple
    threads do not overwrite each other's last error code value.

Arguments:

    None.

Return Value:

    The return value is the most recent error code as set by a Win32 API
    call.

--*/

{
    if (!XapiIsXapiThread())
    {
        XDBGERR("XAPI", "GetLastError() called on non-XAPI thread");
    }
    return XapiLastErrorCode;
}

VOID
WINAPI
SetLastError(
    DWORD dwErrCode
    )

/*++

Routine Description:

    This function set the most recent error code and error string in per
    thread storage.  Win32 API functions call this function whenever
    they return a failure indication (e.g.  FALSE, NULL or -1).
    This function
    is not called by Win32 API function calls that are successful, so
    that if three Win32 API function calls are made, and the first one
    fails and the second two succeed, the error code and string stored
    by the first one are still available after the second two succeed.

    Applications can retrieve the values saved by this function using
    GetLastError.  The use of this function is optional, as an
    application need only call if it is interested in knowing the
    specific reason for an API function failure.

    The last error code value is kept in thread local storage so that
    multiple threads do not overwrite each other's values.

Arguments:

    dwErrCode - Specifies the error code to store in per thread storage
        for the current thread.

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/

{
    if (!XapiIsXapiThread())
    {
        XDBGERR("XAPI", "SetLastError() called on non-XAPI thread");
    }
    XapiLastErrorCode = (ULONG)dwErrCode;
}

HANDLE
WINAPI
CreateIoCompletionPort(
    HANDLE FileHandle,
    HANDLE ExistingCompletionPort,
    ULONG_PTR CompletionKey,
    DWORD NumberOfConcurrentThreads
    )

/*++

Routine Description:

    This function creates an I/O completion port.  Completion ports
    provide another mechanism that can be used to to recive I/O
    completion notification.

    Completion ports act as a queue.  The Win32 I/O system can be
    instructed to queue I/O completion notification packets to
    completion ports.  This API provides this mechanism.  If a file
    handle is created for overlapped I/O completion
    (FILE_FLAG_OVERLAPPED) , a completion port can be associated with
    the file handle.  When I/O operations are done on a file handle that
    has an associated completion port, the I/O system will queue a
    completion packet when the I/O operation completes.  The
    GetQueuedCompletionStatus is used to pick up these queued I/O
    completion packets.

    This API can be used to create a completion port and associate it
    with a file.  If you supply a completion port, it can be used to
    associate the specified file with the specified completion port.

Arguments:

    FileHandle - Supplies a handle to a file opened for overlapped I/O
        completion.  This file is associated with either the specified
        completion port, or a new completion port is created, and the
        file is associated with that port.  Once associated with a
        completion port, the file handle may not be used in ReadFileEx
        or WriteFileEx operations.  It is not advisable to share an
        associated file handle through either handle inheritence or
        through DuplicateHandle.  I/O operations done on these
        duplicates will also generate a completion notification.

    ExistingCompletionPort - If this parameter is specified, it supplies
        an existing completion port that is to be associated with the
        specified file handle.  Otherwise, a new completion port is
        created and associated with the specified file handle.

    CompletionKey - Supplies a per-file completion key that is part of
        every I/O completion packet for this file.

    NumberOfConcurrentThreads - This is the number of threads that are
        alowed to be concurrently active and can be used to avoid
        spurious context switches, e.g., context switches that would
        occur simply because of quantum end.  Up to the number of
        threads specified are allowed to execute concurrently.  If one
        of the threads enters a wait state, then another thread is
        allowed to procede.  There may be times when more then the
        specified number of threads are active, but this will be quickly
        throttled.  A value of 0 tells the system to allow the same
        number of threads as there are processors to run.

Return Value:

    Not NULL - Returns the completion port handle associated with the file.

    NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    NTSTATUS Status;
    HANDLE Port;
    IO_STATUS_BLOCK IoSb;
    FILE_COMPLETION_INFORMATION CompletionInfo;

    Port = ExistingCompletionPort;
    if ( !ARGUMENT_PRESENT(ExistingCompletionPort) ) {
        Status = NtCreateIoCompletion (
                    &Port,
                    IO_COMPLETION_ALL_ACCESS,
                    NULL,
                    NumberOfConcurrentThreads
                    );
        if ( !NT_SUCCESS(Status) ) {
            XapiSetLastNTError(Status);
            return NULL;
            }
        }

    if ( FileHandle != INVALID_HANDLE_VALUE ) {
        CompletionInfo.Port = Port;
        CompletionInfo.Key = (PVOID)CompletionKey;

        Status = NtSetInformationFile(
                    FileHandle,
                    &IoSb,
                    &CompletionInfo,
                    sizeof(CompletionInfo),
                    FileCompletionInformation
                    );
        if ( !NT_SUCCESS(Status) ) {
            XapiSetLastNTError(Status);
            if ( !ARGUMENT_PRESENT(ExistingCompletionPort) ) {
                NtClose(Port);
                }
            return NULL;
            }
        }
    else {

        //
        // file handle is INVALID_HANDLE_VALUE. Usually this is
        // used to create a new unassociated completion port.
        //
        // Special case here to see if existing completion port was
        // specified and fail if it is
        //

        if ( ARGUMENT_PRESENT(ExistingCompletionPort) ) {
            Port = NULL;
            XapiSetLastNTError(STATUS_INVALID_PARAMETER);
            }
        }

    return Port;
}

BOOL
WINAPI
PostQueuedCompletionStatus(
    HANDLE CompletionPort,
    DWORD dwNumberOfBytesTransferred,
    ULONG_PTR dwCompletionKey,
    LPOVERLAPPED lpOverlapped
    )

/*++

Routine Description:

    This function allows the caller to post an I/O completion packet to
    a completion port. This packet will satisfy an outstanding call to
    GetQueuedCompletionStatus and will provide that caller with the three values
    normally returned from that call.

Arguments:

    CompletionPort - Supplies a handle to a completion port that the caller wants to
        post a completion packet to.

    dwNumberOfBytesTransferred - Supplies the value that is to be
        returned through the lpNumberOfBytesTransfered parameter of the
        GetQueuedCompletionStatus API.

    dwCompletionKey - Supplies the value that is to be returned through
        the lpCompletionKey parameter of the GetQueuedCompletionStatus
        API.

    lpOverlapped - Supplies the value that is to be returned through the
        lpOverlapped parameter of the GetQueuedCompletionStatus API.

Return Value:

    TRUE - The operation was successful

    FALSE - The operation failed, use GetLastError to get detailed error information

--*/

{
    NTSTATUS Status;
    BOOL rv;

    rv = TRUE;
    Status = NtSetIoCompletion(
                CompletionPort,
                (PVOID)dwCompletionKey,
                (PVOID)lpOverlapped,
                STATUS_SUCCESS,
                dwNumberOfBytesTransferred
                );
    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        rv = FALSE;
        }
    return rv;
}



BOOL
WINAPI
GetQueuedCompletionStatus(
    HANDLE CompletionPort,
    LPDWORD lpNumberOfBytesTransferred,
    PULONG_PTR lpCompletionKey,
    LPOVERLAPPED *lpOverlapped,
    DWORD dwMilliseconds
    )

/*++

Routine Description:

    This function waits for pending I/O operations associated with the
    specified completion port to complete.  Server applications may have
    several threads issuing this call on the same completion port.  As
    I/O operations complete, they are queued to this port.  If threads
    are actively waiting in this call, queued requests complete their
    call.

    This API returns a boolean value.

    A value of TRUE means that a pending I/O completed successfully.
    The the number of bytes transfered during the I/O, the completion
    key that indicates which file the I/O occured on, and the overlapped
    structure address used in the original I/O are all returned.

    A value of FALSE indicates one ow two things:

    If *lpOverlapped is NULL, no I/O operation was dequeued.  This
    typically means that an error occured while processing the
    parameters to this call, or that the CompletionPort handle has been
    closed or is otherwise invalid.  GetLastError() may be used to
    further isolate this.

    If *lpOverlapped is non-NULL, an I/O completion packet was dequeud,
    but the I/O operation resulted in an error.  GetLastError() can be
    used to further isolate the I/O error.  The the number of bytes
    transfered during the I/O, the completion key that indicates which
    file the I/O occured on, and the overlapped structure address used
    in the original I/O are all returned.

Arguments:

    CompletionPort - Supplies a handle to a completion port to wait on.

    lpNumberOfBytesTransferred - Returns the number of bytes transfered during the
        I/O operation whose completion is being reported.

    lpCompletionKey - Returns a completion key value specified during
        CreateIoCompletionPort.  This is a per-file key that can be used
        to tall the caller the file that an I/O operation completed on.

    lpOverlapped - Returns the address of the overlapped structure that
        was specified when the I/O was issued.  The following APIs may
        complete using completion ports.  This ONLY occurs if the file
        handle is associated with with a completion port AND an
        overlapped structure was passed to the API.

        LockFileEx
        WriteFile
        ReadFile
        DeviceIoControl
        WaitCommEvent
        ConnectNamedPipe
        TransactNamedPipe

    dwMilliseconds - Supplies an optional timeout value that specifies
        how long the caller is willing to wait for an I/O completion
        packet.

Return Value:

    TRUE - An I/O operation completed successfully.
        lpNumberOfBytesTransferred, lpCompletionKey, and lpOverlapped
        are all valid.

    FALSE - If lpOverlapped is NULL, the operation failed and no I/O
        completion data is retured.  GetLastError() can be used to
        further isolate the cause of the error (bad parameters, invalid
        completion port handle).  Otherwise, a pending I/O operation
        completed, but it completed with an error.  GetLastError() can
        be used to further isolate the I/O error.
        lpNumberOfBytesTransferred, lpCompletionKey, and lpOverlapped
        are all valid.

--*/

{

    LARGE_INTEGER TimeOut;
    PLARGE_INTEGER pTimeOut;
    IO_STATUS_BLOCK IoSb;
    NTSTATUS Status;
    LPOVERLAPPED LocalOverlapped;
    BOOL rv;


    pTimeOut = XapiFormatTimeOut(&TimeOut,dwMilliseconds);
    Status = NtRemoveIoCompletion(
                CompletionPort,
                (PVOID *)lpCompletionKey,
                (PVOID *)&LocalOverlapped,
                &IoSb,
                pTimeOut
                );

    if ( !NT_SUCCESS(Status) || Status == STATUS_TIMEOUT ) {
        *lpOverlapped = NULL;
        if ( Status == STATUS_TIMEOUT ) {
            SetLastError(WAIT_TIMEOUT);
            }
        else {
            XapiSetLastNTError(Status);
            }
        rv = FALSE;
        }
    else {
        *lpOverlapped = LocalOverlapped;

        *lpNumberOfBytesTransferred = (DWORD)IoSb.Information;

        if ( !NT_SUCCESS(IoSb.Status) ){
            XapiSetLastNTError( IoSb.Status );
            rv = FALSE;
            }
        else {
            rv = TRUE;
            }
        }
    return rv;
}

BOOL
WINAPI
GetOverlappedResult(
    HANDLE hFile,
    LPOVERLAPPED lpOverlapped,
    LPDWORD lpNumberOfBytesTransferred,
    BOOL bWait
    )

/*++

Routine Description:

    The GetOverlappedResult function returns the result of the last
    operation that used lpOverlapped and returned ERROR_IO_PENDING.

Arguments:

    hFile - Supplies the open handle to the file that the overlapped
        structure lpOverlapped was supplied to ReadFile, WriteFile,
        ConnectNamedPipe, WaitNamedPipe or TransactNamedPipe.

    lpOverlapped - Points to an OVERLAPPED structure previously supplied to
        ReadFile, WriteFile, ConnectNamedPipe, WaitNamedPipe or
        TransactNamedPipe.

    lpNumberOfBytesTransferred - Returns the number of bytes transferred
        by the operation.

    bWait -  A boolean value that affects the behavior when the operation
        is still in progress. If TRUE and the operation is still in progress,
        GetOverlappedResult will wait for the operation to complete before
        returning. If FALSE and the operation is incomplete,
        GetOverlappedResult will return FALSE. In this case the extended
        error information available from the GetLastError function will be
        set to ERROR_IO_INCOMPLETE.

Return Value:

    TRUE -- The operation was successful, the pipe is in the
        connected state.

    FALSE -- The operation failed. Extended error status is available using
        GetLastError.

--*/
{
    DWORD WaitReturn;

    //
    // Did caller specify an event to the original operation or was the
    // default (file handle) used?
    //

    if (lpOverlapped->Internal == (DWORD)STATUS_PENDING ) {
        if ( bWait ) {
            WaitReturn = WaitForSingleObject(
                            ( lpOverlapped->hEvent != NULL ) ?
                                lpOverlapped->hEvent : hFile,
                            INFINITE
                            );
            }
        else {
            WaitReturn = WAIT_TIMEOUT;
            }

        if ( WaitReturn == WAIT_TIMEOUT ) {
            //  !bWait and event in not signalled state
            SetLastError( ERROR_IO_INCOMPLETE );
            return FALSE;
            }

        if ( WaitReturn != 0 ) {
             return FALSE;    // WaitForSingleObject calls XapiSetLastError
             }
        }

    *lpNumberOfBytesTransferred = (DWORD)lpOverlapped->InternalHigh;

    if ( NT_SUCCESS((NTSTATUS)lpOverlapped->Internal) ){
        return TRUE;
        }
    else {
        XapiSetLastNTError( (NTSTATUS)lpOverlapped->Internal );
        return FALSE;
        }
}

#endif /// BUILD_FOR_XBDM
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\filefind.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    filefind.c

Abstract:

    This module implements Win32 FindFirst/FindNext

Author:

    Mark Lucovsky (markl) 26-Sep-1990

Revision History:

--*/

#include "basedll.h"

VOID
XapiDirectoryInformationToFindData(
    IN PFILE_DIRECTORY_INFORMATION DirInfo,
    OUT LPWIN32_FIND_DATA lpFindFileData
    )
{
    lpFindFileData->dwFileAttributes = DirInfo->FileAttributes;
    lpFindFileData->ftCreationTime = *(LPFILETIME)&DirInfo->CreationTime;
    lpFindFileData->ftLastAccessTime = *(LPFILETIME)&DirInfo->LastAccessTime;
    lpFindFileData->ftLastWriteTime = *(LPFILETIME)&DirInfo->LastWriteTime;
    lpFindFileData->nFileSizeHigh = DirInfo->EndOfFile.HighPart;
    lpFindFileData->nFileSizeLow = DirInfo->EndOfFile.LowPart;

    RtlCopyMemory(lpFindFileData->cFileName, DirInfo->FileName,
        DirInfo->FileNameLength);
    lpFindFileData->cFileName[DirInfo->FileNameLength / sizeof(OCHAR)] = OBJECT_NULL;

    lpFindFileData->cAlternateFileName[0] = OBJECT_NULL;
}

HANDLE
APIENTRY
FindFirstFile(
    PCOSTR lpFileName,
    LPWIN32_FIND_DATA lpFindFileData
    )

/*++

Routine Description:

    A directory can be searched for the first entry whose name and
    attributes match the specified name using FindFirstFile.

    This API is provided to open a find file handle and return
    information about the first file whose name match the specified
    pattern.  Once established, the find file handle can be used to
    search for other files that match the same pattern.  When the find
    file handle is no longer needed, it should be closed.

    Note that while this interface only returns information for a single
    file, an implementation is free to buffer several matching files
    that can be used to satisfy subsequent calls to FindNextFile.  Also
    not that matches are done by name only.  This API does not do
    attribute based matching.

    This API is similar to DOS (int 21h, function 4Eh), and OS/2's
    DosFindFirst.  For portability reasons, its data structures and
    parameter passing is somewhat different.

Arguments:

    lpFileName - Supplies the file name of the file to find.  The file name
        may contain the DOS wild card characters '*' and '?'.

    lpFindFileData - On a successful find, this parameter returns information
        about the located file:

        WIN32_FIND_DATA Structure:

        DWORD dwFileAttributes - Returns the file attributes of the found
            file.

        FILETIME ftCreationTime - Returns the time that the file was created.
            A value of 0,0 specifies that the file system containing the
            file does not support this time field.

        FILETIME ftLastAccessTime - Returns the time that the file was last
            accessed.  A value of 0,0 specifies that the file system
            containing the file does not support this time field.

        FILETIME ftLastWriteTime - Returns the time that the file was last
            written.  A file systems support this time field.

        DWORD nFileSizeHigh - Returns the high order 32 bits of the
            file's size.

        DWORD nFileSizeLow - Returns the low order 32-bits of the file's
            size in bytes.

        UCHAR cFileName[MAX_PATH] - Returns the null terminated name of
            the file.

Return Value:

    Not -1 - Returns a find first handle
        that can be used in a subsequent call to FindNextFile or FindClose.

    0xffffffff - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    ULONG EndingIndex;
    OBJECT_STRING FileName;
    OBJECT_STRING SearchName;
    IO_STATUS_BLOCK IoStatusBlock;
    struct {
        FILE_DIRECTORY_INFORMATION DirInfo;
        OCHAR FileName[256];
    } FullDirInfo;

    RtlInitObjectString(&FileName, lpFileName);

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        ObDosDevicesDirectory(),
        NULL
        );

    //
    // Strip off the search specification from the file name.
    //

    EndingIndex = (FileName.Length / sizeof(OCHAR));

    while (EndingIndex > 0) {

        if (FileName.Buffer[EndingIndex - 1] == OTEXT('\\')) {
            break;
        }

        EndingIndex--;
    }

    SearchName.Length = (USHORT)(FileName.Length - (EndingIndex * sizeof(OCHAR)));
    SearchName.MaximumLength = SearchName.Length;
    SearchName.Buffer = &FileName.Buffer[EndingIndex];

    FileName.Length = (USHORT)(EndingIndex * sizeof(OCHAR));
    FileName.MaximumLength = FileName.Length;

    //
    // Make sure that we didn't consume the entire string while searching for
    // the search specification and that the search specification is not empty.
    //

    if ((FileName.Length == 0) || (SearchName.Length == 0)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }

    //
    // If the search name is "*.*", then convert it to an empty string so that
    // we end up matching all names, not just those with an extension.
    //

    if (SearchName.Length == sizeof(OCHAR) * 3 &&
        SearchName.Buffer[0] == OTEXT('*') && SearchName.Buffer[1] == OTEXT('.') &&
        SearchName.Buffer[2] == OTEXT('*')) {
        SearchName.Length = 0;
    }

    //
    // Open the directory for list access.
    //

    Status = NtOpenFile(
                 &Handle,
                 FILE_LIST_DIRECTORY | SYNCHRONIZE,
                 &Obja,
                 &IoStatusBlock,
                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                 );

    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        return INVALID_HANDLE_VALUE;
    }

    //
    // Get the first entry from the directory.
    //

    Status = NtQueryDirectoryFile(
                 Handle,
                 NULL,
                 NULL,
                 NULL,
                 &IoStatusBlock,
                 &FullDirInfo,
                 sizeof(FullDirInfo),
                 FileDirectoryInformation,
                 &SearchName,
                 FALSE
                 );

    if ( !NT_SUCCESS(Status) ) {
        NtClose(Handle);
        XapiSetLastNTError(Status);
        return INVALID_HANDLE_VALUE;
    }

    XapiDirectoryInformationToFindData(&FullDirInfo.DirInfo, lpFindFileData);

    return Handle;
}

BOOL
APIENTRY
FindNextFile(
    HANDLE hFindFile,
    LPWIN32_FIND_DATA lpFindFileData
    )

/*++

Routine Description:

    Once a successful call has been made to FindFirstFile, subsequent
    matching files can be located using FindNextFile.

    This API is used to continue a file search from a previous call to
    FindFirstFile.  This API returns successfully with the next file
    that matches the search pattern established in the original
    FindFirstFile call.  If no file match can be found NO_MORE_FILES is
    returned.

    Note that while this interface only returns information for a single
    file, an implementation is free to buffer several matching files
    that can be used to satisfy subsequent calls to FindNextFile.  Also
    not that matches are done by name only.  This API does not do
    attribute based matching.

    This API is similar to DOS (int 21h, function 4Fh), and OS/2's
    DosFindNext.  For portability reasons, its data structures and
    parameter passing is somewhat different.

Arguments:

    hFindFile - Supplies a find file handle returned in a previous call
        to FindFirstFile.

    lpFindFileData - On a successful find, this parameter returns information
        about the located file.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    struct {
        FILE_DIRECTORY_INFORMATION DirInfo;
        OCHAR FileName[256];
    } FullDirInfo;

    Status = NtQueryDirectoryFile(
                 hFindFile,
                 NULL,
                 NULL,
                 NULL,
                 &IoStatusBlock,
                 &FullDirInfo,
                 sizeof(FullDirInfo),
                 FileDirectoryInformation,
                 NULL,
                 FALSE
                 );

    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        return FALSE;
    }

    XapiDirectoryInformationToFindData(&FullDirInfo.DirInfo, lpFindFileData);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\filehops.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    filehops.c

Abstract:

    This module implements Win32 file handle APIs

Author:

    Mark Lucovsky (markl) 25-Sep-1990

Revision History:

--*/

#include "basedll.h"
#pragma hdrstop

BOOL
WINAPI
ReadFile(
    HANDLE hFile,
    LPVOID lpBuffer,
    DWORD nNumberOfBytesToRead,
    LPDWORD lpNumberOfBytesRead,
    LPOVERLAPPED lpOverlapped
    )

/*++

Routine Description:

    Data can be read from a file using ReadFile.

    This API is used to read data from a file.  Data is read from the
    file from the position indicated by the file pointer.  After the
    read completes, the file pointer is adjusted by the number of bytes
    actually read.  A return value of TRUE coupled with a bytes read of
    0 indicates that the file pointer was beyond the current end of the
    file at the time of the read.

Arguments:

    hFile - Supplies an open handle to a file that is to be read.  The
        file handle must have been created with GENERIC_READ access to
        the file.

    lpBuffer - Supplies the address of a buffer to receive the data read
        from the file.

    nNumberOfBytesToRead - Supplies the number of bytes to read from the
        file.

    lpNumberOfBytesRead - Returns the number of bytes read by this call.
        This parameter is always set to 0 before doing any IO or error
        checking.

    lpOverlapped - Optionally points to an OVERLAPPED structure to be used with the
    request. If NULL then the transfer starts at the current file position
    and ReadFile will not return until the operation completes.

    If the handle hFile was created without specifying FILE_FLAG_OVERLAPPED
    the file pointer is moved to the specified offset plus
    lpNumberOfBytesRead before ReadFile returns. ReadFile will wait for the
    request to complete before returning (it will not return
    ERROR_IO_PENDING).

    When FILE_FLAG_OVERLAPPED is specified, ReadFile may return
    ERROR_IO_PENDING to allow the calling function to continue processing
    while the operation completes. The event (or hFile if hEvent is NULL) will
    be set to the signalled state upon completion of the request.

    When the handle is created with FILE_FLAG_OVERLAPPED and lpOverlapped
    is set to NULL, ReadFile will return ERROR_INVALID_PARAMTER because
    the file offset is required.


Return Value:

    TRUE - The operation was successul.

    FALSE - The operation failed.  Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    DWORD InputMode;

    if ( ARGUMENT_PRESENT(lpNumberOfBytesRead) ) {
        *lpNumberOfBytesRead = 0;
        }

    if ( ARGUMENT_PRESENT( lpOverlapped ) ) {
        LARGE_INTEGER Li;

        lpOverlapped->Internal = (DWORD)STATUS_PENDING;
        Li.LowPart = lpOverlapped->Offset;
        Li.HighPart = lpOverlapped->OffsetHigh;
        Status = NtReadFile(
                hFile,
                lpOverlapped->hEvent,
                NULL,
                (ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped,
                (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                lpBuffer,
                nNumberOfBytesToRead,
                &Li
                );


        if ( NT_SUCCESS(Status) && Status != STATUS_PENDING) {
            if ( ARGUMENT_PRESENT(lpNumberOfBytesRead) ) {
                *lpNumberOfBytesRead = (DWORD)lpOverlapped->InternalHigh;
                }
            return TRUE;
            }
        else
        if (Status == STATUS_END_OF_FILE) {
            if ( ARGUMENT_PRESENT(lpNumberOfBytesRead) ) {
                *lpNumberOfBytesRead = 0;
                }
            XapiSetLastNTError(Status);
            return FALSE;
            }
        else {
            XapiSetLastNTError(Status);
            return FALSE;
            }
        }
    else
        {
        Status = NtReadFile(
                hFile,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                lpBuffer,
                nNumberOfBytesToRead,
                NULL
                );

        if ( Status == STATUS_PENDING) {
            // Operation must complete before return & IoStatusBlock destroyed
            Status = NtWaitForSingleObject( hFile, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {
                Status = IoStatusBlock.Status;
                }
            }

        if ( NT_SUCCESS(Status) ) {
            *lpNumberOfBytesRead = (DWORD)IoStatusBlock.Information;
            return TRUE;
            }
        else
        if (Status == STATUS_END_OF_FILE) {
            *lpNumberOfBytesRead = 0;
            return TRUE;
            }
        else {
            if ( NT_WARNING(Status) ) {
                *lpNumberOfBytesRead = (DWORD)IoStatusBlock.Information;
                }
            XapiSetLastNTError(Status);
            return FALSE;
            }
        }
}


BOOL
WINAPI
WriteFile(
    HANDLE hFile,
    LPCVOID lpBuffer,
    DWORD nNumberOfBytesToWrite,
    LPDWORD lpNumberOfBytesWritten,
    LPOVERLAPPED lpOverlapped
    )

/*++

Routine Description:

    Data can be written to a file using WriteFile.

    This API is used to write data to a file.  Data is written to the
    file from the position indicated by the file pointer.  After the
    write completes, the file pointer is adjusted by the number of bytes
    actually written.

    Unlike DOS, a NumberOfBytesToWrite value of zero does not truncate
    or extend the file.  If this function is required, SetEndOfFile
    should be used.

Arguments:

    hFile - Supplies an open handle to a file that is to be written.  The
        file handle must have been created with GENERIC_WRITE access to
        the file.

    lpBuffer - Supplies the address of the data that is to be written to
        the file.

    nNumberOfBytesToWrite - Supplies the number of bytes to write to the
        file. Unlike DOS, a value of zero is interpreted a null write.

    lpNumberOfBytesWritten - Returns the number of bytes written by this
        call. Before doing any work or error processing, the API sets this
        to zero.

    lpOverlapped - Optionally points to an OVERLAPPED structure to be
        used with the request. If NULL then the transfer starts at the
        current file position and WriteFile will not return until the
        operation completes.

        If the handle <hFile> was created without specifying
        FILE_FLAG_OVERLAPPED the file pointer is moved to the specified
        offset plus lpNumberOfBytesWritten before WriteFile returns.
        WriteFile will wait for the request to complete before returning
        (it will not set ERROR_IO_PENDING).

        When FILE_FLAG_OVERLAPPED is specified, WriteFile may return
        ERROR_IO_PENDING to allow the calling function to continue processing
        while the operation completes. The event (or hFile if hEvent is NULL) will
        be set to the signalled state upon completion of the request.

        When the handle is created with FILE_FLAG_OVERLAPPED and lpOverlapped
        is set to NULL, WriteFile will return ERROR_INVALID_PARAMTER because
        the file offset is required.

Return Value:

    TRUE - The operation was a success.

    FALSE - The operation failed.  Extended error status is
        available using GetLastError.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;

    if ( ARGUMENT_PRESENT(lpNumberOfBytesWritten) ) {
        *lpNumberOfBytesWritten = 0;
        }

    if ( ARGUMENT_PRESENT( lpOverlapped ) ) {
        LARGE_INTEGER Li;

        lpOverlapped->Internal = (DWORD)STATUS_PENDING;
        Li.LowPart = lpOverlapped->Offset;
        Li.HighPart = lpOverlapped->OffsetHigh;
        Status = NtWriteFile(
                hFile,
                lpOverlapped->hEvent,
                NULL,
                (ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped,
                (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                (PVOID)lpBuffer,
                nNumberOfBytesToWrite,
                &Li
                );

        if ( !NT_ERROR(Status) && Status != STATUS_PENDING) {
            if ( ARGUMENT_PRESENT(lpNumberOfBytesWritten) ) {
                *lpNumberOfBytesWritten = (DWORD)lpOverlapped->InternalHigh;
                }
            return TRUE;
            }
        else  {
            XapiSetLastNTError(Status);
            return FALSE;
            }
        }
    else {
        Status = NtWriteFile(
                hFile,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                (PVOID)lpBuffer,
                nNumberOfBytesToWrite,
                NULL
                );

        if ( Status == STATUS_PENDING) {
            // Operation must complete before return & IoStatusBlock destroyed
            Status = NtWaitForSingleObject( hFile, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {
                Status = IoStatusBlock.Status;
                }
            }

        if ( NT_SUCCESS(Status)) {
            *lpNumberOfBytesWritten = (DWORD)IoStatusBlock.Information;
            return TRUE;
            }
        else {
            if ( NT_WARNING(Status) ) {
                *lpNumberOfBytesWritten = (DWORD)IoStatusBlock.Information;
                }
            XapiSetLastNTError(Status);
            return FALSE;
            }
        }
}

BOOL
WINAPI
SetEndOfFile(
    HANDLE hFile
    )

/*++

Routine Description:

    The end of file position of an open file can be set to the current
    file pointer using SetEndOfFile.

    This API is used to set the end of file position of a file to the
    same value as the current file pointer.  This has the effect of
    truncating or extending a file.  This functionality is similar to
    DOS (int 21h, function 40H with CX=0).

Arguments:

    hFile - Supplies an open handle to a file that is to be extended or
        truncated.  The file handle must have been created with
        GENERIC_WRITE access to the file.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_POSITION_INFORMATION CurrentPosition;
    FILE_END_OF_FILE_INFORMATION EndOfFile;
    FILE_ALLOCATION_INFORMATION Allocation;

    //
    // Get the current position of the file pointer
    //

    Status = NtQueryInformationFile(
                hFile,
                &IoStatusBlock,
                &CurrentPosition,
                sizeof(CurrentPosition),
                FilePositionInformation
                );
    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        return FALSE;
        }

    //
    // Set the end of file based on the current file position
    //

    EndOfFile.EndOfFile = CurrentPosition.CurrentByteOffset;

    Status = NtSetInformationFile(
                hFile,
                &IoStatusBlock,
                &EndOfFile,
                sizeof(EndOfFile),
                FileEndOfFileInformation
                );
    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        return FALSE;
        }

    //
    // Set the allocation based on the current file size
    //

    Allocation.AllocationSize = CurrentPosition.CurrentByteOffset;

    Status = NtSetInformationFile(
                hFile,
                &IoStatusBlock,
                &Allocation,
                sizeof(Allocation),
                FileAllocationInformation
                );
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        XapiSetLastNTError(Status);
        return FALSE;
        }
}

DWORD
WINAPI
SetFilePointer(
    HANDLE hFile,
    LONG lDistanceToMove,
    PLONG lpDistanceToMoveHigh,
    DWORD dwMoveMethod
    )

/*++

Routine Description:

    An open file's file pointer can be set using SetFilePointer.

    The purpose of this function is to update the current value of a
    file's file pointer.  Care should be taken in multi-threaded
    applications that have multiple threads sharing a file handle with
    each thread updating the file pointer and then doing a read.  This
    sequence should be treated as a critical section of code and should
    be protected using either a critical section object or a mutex
    object.

    This API provides the same functionality as DOS (int 21h, function
    42h) and OS/2's DosSetFilePtr.

Arguments:

    hFile - Supplies an open handle to a file whose file pointer is to be
        moved.  The file handle must have been created with
        GENERIC_READ or GENERIC_WRITE access to the file.

    lDistanceToMove - Supplies the number of bytes to move the file
        pointer.  A positive value moves the pointer forward in the file
        and a negative value moves backwards in the file.

    lpDistanceToMoveHigh - An optional parameter that if specified
        supplies the high order 32-bits of the 64-bit distance to move.
        If the value of this parameter is NULL, this API can only
        operate on files whose maximum size is (2**32)-2.  If this
        parameter is specified, than the maximum file size is (2**64)-2.
        This value also returns the high order 32-bits of the new value
        of the file pointer.  If this value, and the return value
        are 0xffffffff, then an error is indicated.

    dwMoveMethod - Supplies a value that specifies the starting point
        for the file pointer move.

        FILE_BEGIN - The starting point is zero or the beginning of the
            file.  If FILE_BEGIN is specified, then DistanceToMove is
            interpreted as an unsigned location for the new
            file pointer.

        FILE_CURRENT - The current value of the file pointer is used as
            the starting point.

        FILE_END - The current end of file position is used as the
            starting point.


Return Value:

    Not -1 - Returns the low order 32-bits of the new value of the file
        pointer.

    0xffffffff - If the value of lpDistanceToMoveHigh was NULL, then The
        operation failed.  Extended error status is available using
        GetLastError.  Otherwise, this is the low order 32-bits of the
        new value of the file pointer.

--*/

{

    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_POSITION_INFORMATION CurrentPosition;
    FILE_NETWORK_OPEN_INFORMATION NetworkInfo;
    LARGE_INTEGER Large;

    if (ARGUMENT_PRESENT(lpDistanceToMoveHigh)) {
        Large.HighPart = *lpDistanceToMoveHigh;
        Large.LowPart = lDistanceToMove;
        }
    else {
        Large.QuadPart = lDistanceToMove;
        }
    switch (dwMoveMethod) {
        case FILE_BEGIN :
            CurrentPosition.CurrentByteOffset = Large;
                break;

        default:
            RIP("SetFilePointer() - invalid parameter (dwMoveMethod)");
            //
            // Fall through
            //
            
        case FILE_CURRENT :

            //
            // Get the current position of the file pointer
            //

            Status = NtQueryInformationFile(
                        hFile,
                        &IoStatusBlock,
                        &CurrentPosition,
                        sizeof(CurrentPosition),
                        FilePositionInformation
                        );
            if ( !NT_SUCCESS(Status) ) {
                XapiSetLastNTError(Status);
                return (DWORD)-1;
                }
            CurrentPosition.CurrentByteOffset.QuadPart += Large.QuadPart;
            break;

        case FILE_END :
            Status = NtQueryInformationFile(
                        hFile,
                        &IoStatusBlock,
                        &NetworkInfo,
                        sizeof(NetworkInfo),
                        FileNetworkOpenInformation
                        );
            if ( !NT_SUCCESS(Status) ) {
                XapiSetLastNTError(Status);
                return (DWORD)-1;
                }
            CurrentPosition.CurrentByteOffset.QuadPart =
                                NetworkInfo.EndOfFile.QuadPart + Large.QuadPart;
            break;
        }

    //
    // If the resulting file position is negative, or if the app is not
    // prepared for greater than
    // then 32 bits than fail
    //

    if ( CurrentPosition.CurrentByteOffset.QuadPart < 0 ) {
        SetLastError(ERROR_NEGATIVE_SEEK);
        return (DWORD)-1;
        }

    //
    // NOTE: leaving this parameter check in the retail build, because it
    // isn't likely to be hit right away in debug builds - which could hide
    // the problem.
    //
    if ( !ARGUMENT_PRESENT(lpDistanceToMoveHigh) &&
        (CurrentPosition.CurrentByteOffset.HighPart & MAXLONG) ) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (DWORD)-1;
        }

    //
    // Set the current file position
    //

    Status = NtSetInformationFile(
                hFile,
                &IoStatusBlock,
                &CurrentPosition,
                sizeof(CurrentPosition),
                FilePositionInformation
                );
    if ( NT_SUCCESS(Status) ) {
        if (ARGUMENT_PRESENT(lpDistanceToMoveHigh)){
            *lpDistanceToMoveHigh = CurrentPosition.CurrentByteOffset.HighPart;
            }
        if ( CurrentPosition.CurrentByteOffset.LowPart == -1 ) {
            SetLastError(0);
            }
        return CurrentPosition.CurrentByteOffset.LowPart;
        }
    else {
        XapiSetLastNTError(Status);
        if (ARGUMENT_PRESENT(lpDistanceToMoveHigh)){
            *lpDistanceToMoveHigh = -1;
            }
        return (DWORD)-1;
        }
}


BOOL
WINAPI
SetFilePointerEx(
    HANDLE hFile,
    LARGE_INTEGER liDistanceToMove,
    PLARGE_INTEGER lpNewFilePointer,
    DWORD dwMoveMethod
    )

/*++

Routine Description:

    An open file's file pointer can be set using SetFilePointer.

    The purpose of this function is to update the current value of a
    file's file pointer.  Care should be taken in multi-threaded
    applications that have multiple threads sharing a file handle with
    each thread updating the file pointer and then doing a read.  This
    sequence should be treated as a critical section of code and should
    be protected using either a critical section object or a mutex
    object.

    This API provides the same functionality as DOS (int 21h, function
    42h) and OS/2's DosSetFilePtr.

Arguments:

    hFile - Supplies an open handle to a file whose file pointer is to be
        moved.  The file handle must have been created with
        GENERIC_READ or GENERIC_WRITE access to the file.

    liDistanceToMove - Supplies the number of bytes to move the file
        pointer.  A positive value moves the pointer forward in the file
        and a negative value moves backwards in the file.

    lpNewFilePointer - An optional parameter that if specified returns
        the new file pointer

    dwMoveMethod - Supplies a value that specifies the starting point
        for the file pointer move.

        FILE_BEGIN - The starting point is zero or the beginning of the
            file.  If FILE_BEGIN is specified, then DistanceToMove is
            interpreted as an unsigned location for the new
            file pointer.

        FILE_CURRENT - The current value of the file pointer is used as
            the starting point.

        FILE_END - The current end of file position is used as the
            starting point.


Return Value:

    TRUE - The operation was successful

    FALSE - The operation failed. Extended error status is available using
        GetLastError.

--*/

{

    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_POSITION_INFORMATION CurrentPosition;
    FILE_NETWORK_OPEN_INFORMATION NetworkInfo;
    LARGE_INTEGER Large;

    Large = liDistanceToMove;

    switch (dwMoveMethod) {
        case FILE_BEGIN :
            CurrentPosition.CurrentByteOffset = Large;
                break;

        default:
            RIP("SetFilePointerEx() - invalid parameter (dwMoveMethod)");
            //
            // Fall through
            //
            
        case FILE_CURRENT :

            //
            // Get the current position of the file pointer
            //

            Status = NtQueryInformationFile(
                        hFile,
                        &IoStatusBlock,
                        &CurrentPosition,
                        sizeof(CurrentPosition),
                        FilePositionInformation
                        );
            if ( !NT_SUCCESS(Status) ) {
                XapiSetLastNTError(Status);
                return FALSE;
                }
            CurrentPosition.CurrentByteOffset.QuadPart += Large.QuadPart;
            break;

        case FILE_END :
            Status = NtQueryInformationFile(
                        hFile,
                        &IoStatusBlock,
                        &NetworkInfo,
                        sizeof(NetworkInfo),
                        FileNetworkOpenInformation
                        );
            if ( !NT_SUCCESS(Status) ) {
                XapiSetLastNTError(Status);
                return FALSE;
                }
            CurrentPosition.CurrentByteOffset.QuadPart =
                                NetworkInfo.EndOfFile.QuadPart + Large.QuadPart;
            break;
        }

    //
    // If the resulting file position is negative fail
    //

    if ( CurrentPosition.CurrentByteOffset.QuadPart < 0 ) {
        SetLastError(ERROR_NEGATIVE_SEEK);
        return FALSE;
        }

    //
    // Set the current file position
    //

    Status = NtSetInformationFile(
                hFile,
                &IoStatusBlock,
                &CurrentPosition,
                sizeof(CurrentPosition),
                FilePositionInformation
                );
    if ( NT_SUCCESS(Status) ) {
        if (ARGUMENT_PRESENT(lpNewFilePointer)){
            *lpNewFilePointer = CurrentPosition.CurrentByteOffset;
            }
        return TRUE;
        }
    else {
        XapiSetLastNTError(Status);
        return FALSE;
        }
}



BOOL
WINAPI
GetFileInformationByHandle(
    HANDLE hFile,
    LPBY_HANDLE_FILE_INFORMATION lpFileInformation
    )

/*++

Routine Description:


Arguments:

    hFile - Supplies an open handle to a file whose modification date and
        times are to be read.  The file handle must have been created with
        GENERIC_READ access to the file.

    lpCreationTime - An optional parameter that if specified points to
        the location to return the date and time the file was created.
        A returned time of all zero indicates that the file system
        containing the file does not support this time value.


Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    BY_HANDLE_FILE_INFORMATION LocalFileInformation;
    FILE_NETWORK_OPEN_INFORMATION NetworkInfo;
    FILE_INTERNAL_INFORMATION InternalInfo;
    FILE_FS_VOLUME_INFORMATION VolumeInfo;

    Status = NtQueryVolumeInformationFile(
                hFile,
                &IoStatusBlock,
                &VolumeInfo,
                sizeof(VolumeInfo),
                FileFsVolumeInformation
                );
    if ( !NT_ERROR(Status) ) {
        LocalFileInformation.dwVolumeSerialNumber = VolumeInfo.VolumeSerialNumber;
        }
    else {
        XapiSetLastNTError(Status);
        return FALSE;
        }

    Status = NtQueryInformationFile(
                hFile,
                &IoStatusBlock,
                &InternalInfo,
                sizeof(InternalInfo),
                FileInternalInformation
                );
    if ( !NT_ERROR(Status) ) {
        LocalFileInformation.nFileIndexHigh = InternalInfo.IndexNumber.HighPart;
        LocalFileInformation.nFileIndexLow = InternalInfo.IndexNumber.LowPart;
        }
    else {
        XapiSetLastNTError(Status);
        return FALSE;
        }

    Status = NtQueryInformationFile(
                hFile,
                &IoStatusBlock,
                &NetworkInfo,
                sizeof(NetworkInfo),
                FileNetworkOpenInformation
                );

    if ( !NT_ERROR(Status) ) {
        LocalFileInformation.dwFileAttributes = NetworkInfo.FileAttributes;
        LocalFileInformation.ftCreationTime = *(LPFILETIME)&NetworkInfo.CreationTime;
        LocalFileInformation.ftLastAccessTime = *(LPFILETIME)&NetworkInfo.LastAccessTime;
        LocalFileInformation.ftLastWriteTime = *(LPFILETIME)&NetworkInfo.LastWriteTime;
        LocalFileInformation.nFileSizeHigh = NetworkInfo.EndOfFile.HighPart;
        LocalFileInformation.nFileSizeLow = NetworkInfo.EndOfFile.LowPart;
        LocalFileInformation.nNumberOfLinks = 0;
        }
    else {
        XapiSetLastNTError(Status);
        return FALSE;
        }
    *lpFileInformation = LocalFileInformation;
    return TRUE;
}

BOOL
APIENTRY
GetFileTime(
    HANDLE hFile,
    LPFILETIME lpCreationTime,
    LPFILETIME lpLastAccessTime,
    LPFILETIME lpLastWriteTime
    )

/*++

Routine Description:

    The date and time that a file was created, last accessed or last
    modified can be read using GetFileTime.  File time stamps are
    returned as 64-bit values, that represent the number of 100
    nanoseconds since January 1st, 1601.  This date was chosen because
    it is the start of a new quadricentury.  At 100ns resolution 32 bits
    is good for about 429 seconds (or 7 minutes) and a 63-bit integer is
    good for about 29,247 years, or around 10,682,247 days.

    This API provides the same functionality as DOS (int 21h, function
    47H with AL=0), and provides a subset of OS/2's DosQueryFileInfo.

Arguments:

    hFile - Supplies an open handle to a file whose modification date and
        times are to be read.  The file handle must have been created with
        GENERIC_READ access to the file.

    lpCreationTime - An optional parameter that if specified points to
        the location to return the date and time the file was created.
        A returned time of all zero indicates that the file system
        containing the file does not support this time value.

    lpLastAccessTime - An optional parameter that if specified points to
        the location to return the date and time the file was last accessed.
        A returned time of all zero indicates that the file system
        containing the file does not support this time value.

    lpLastWriteTime - An optional parameter that if specified points to
        the location to return the date and time the file was last written.
        A file system must support this time and thus a valid value will
        always be returned for this time value.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_NETWORK_OPEN_INFORMATION NetworkInfo;

    //
    // Get the attributes
    //

    Status = NtQueryInformationFile(
                hFile,
                &IoStatusBlock,
                &NetworkInfo,
                sizeof(NetworkInfo),
                FileNetworkOpenInformation
                );

    if ( NT_SUCCESS(Status) ) {
        if (ARGUMENT_PRESENT( lpCreationTime )) {
            *lpCreationTime = *(LPFILETIME)&NetworkInfo.CreationTime;
            }

        if (ARGUMENT_PRESENT( lpLastAccessTime )) {
            *lpLastAccessTime = *(LPFILETIME)&NetworkInfo.LastAccessTime;
            }

        if (ARGUMENT_PRESENT( lpLastWriteTime )) {
            *lpLastWriteTime = *(LPFILETIME)&NetworkInfo.LastWriteTime;
            }
        return TRUE;
        }
    else {
        XapiSetLastNTError(Status);
        return FALSE;
        }
}

BOOL
WINAPI
SetFileTime(
    HANDLE hFile,
    CONST FILETIME *lpCreationTime,
    CONST FILETIME *lpLastAccessTime,
    CONST FILETIME *lpLastWriteTime
    )

/*++

Routine Description:

    The date and time that a file was created, last accessed or last
    modified can be modified using SetFileTime.  File time stamps are
    returned as 64-bit values, that represent the number of 100
    nanoseconds since January 1st, 1601.  This date was chosen because
    it is the start of a new quadricentury.  At 100ns resolution 32 bits
    is good for about 429 seconds (or 7 minutes) and a 63-bit integer is
    good for about 29,247 years, or around 10,682,247 days.

    This API provides the same functionality as DOS (int 21h, function
    47H with AL=1), and provides a subset of OS/2's DosSetFileInfo.

Arguments:

    hFile - Supplies an open handle to a file whose modification date and
        times are to be written.  The file handle must have been created
        with GENERIC_WRITE access to the file.

    lpCreationTime - An optional parameter, that if specified supplies
        the new creation time for the file.  Some file system's do not
        support this time value, so this parameter may be ignored.

    lpLastAccessTime - An optional parameter, that if specified supplies
        the new last access time for the file.  Some file system's do
        not support this time value, so this parameter may be ignored.

    lpLastWriteTime - An optional parameter, that if specified supplies
        the new last write time for the file.  A file system must support
        this time value.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_BASIC_INFORMATION BasicInfo;

    //
    // Zero all the time values we can set.
    //

    RtlZeroMemory(&BasicInfo,sizeof(BasicInfo));

    //
    // For each time value that is specified, copy it to the I/O system
    // record.
    //
    if (ARGUMENT_PRESENT( lpCreationTime )) {
        BasicInfo.CreationTime.LowPart = lpCreationTime->dwLowDateTime;
        BasicInfo.CreationTime.HighPart = lpCreationTime->dwHighDateTime;
        }

    if (ARGUMENT_PRESENT( lpLastAccessTime )) {
        BasicInfo.LastAccessTime.LowPart = lpLastAccessTime->dwLowDateTime;
        BasicInfo.LastAccessTime.HighPart = lpLastAccessTime->dwHighDateTime;
        }

    if (ARGUMENT_PRESENT( lpLastWriteTime )) {
        BasicInfo.LastWriteTime.LowPart = lpLastWriteTime->dwLowDateTime;
        BasicInfo.LastWriteTime.HighPart = lpLastWriteTime->dwHighDateTime;
        }

    //
    // Set the requested times.
    //

    Status = NtSetInformationFile(
                hFile,
                &IoStatusBlock,
                &BasicInfo,
                sizeof(BasicInfo),
                FileBasicInformation
                );

    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        XapiSetLastNTError(Status);
        return FALSE;
        }
}

BOOL
WINAPI
FlushFileBuffers(
    HANDLE hFile
    )

/*++

Routine Description:

    Buffered data may be flushed out to the file using the
    FlushFileBuffers service.

    The FlushFileBuffers service causes all buffered data to be written
    to the specified file.

Arguments:

    hFile - Supplies an open handle to a file whose buffers are to be
        flushed.  The file handle must have been created with
        GENERIC_WRITE access to the file.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;

    Status = NtFlushBuffersFile(hFile,&IoStatusBlock);

    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        XapiSetLastNTError(Status);
        return FALSE;
        }
}

DWORD
WINAPI
GetFileSize(
    HANDLE hFile,
    LPDWORD lpFileSizeHigh
    )

/*++

Routine Description:

    This function returns the size of the file specified by
    hFile. It is capable of returning 64-bits worth of file size.

    The return value contains the low order 32-bits of the file's size.
    The optional lpFileSizeHigh returns the high order 32-bits of the
    file's size.

Arguments:

    hFile - Supplies an open handle to a file whose size is to be
        returned.  The handle must have been created with either
        GENERIC_READ or GENERIC_WRITE access to the file.

    lpFileSizeHigh - An optional parameter, that if specified, returns
        the high order 64-bits of the file's size.


Return Value:

    Not -1 - Returns the low order 32-bits of the specified file's size.


    0xffffffff - If the value of size of the file cannot be determined,
        or an invalid handle or handle with inappropriate access, or a
        handle to a non-file is specified, this error is returned.  If
        the file's size (low 32-bits) is -1, then this value is
        returned, and GetLastError() will return 0.  Extended error
        status is available using GetLastError.


--*/

{
    BOOL b;
    LARGE_INTEGER Li;

    b = GetFileSizeEx(hFile,&Li);

    if ( b ) {

        if ( ARGUMENT_PRESENT(lpFileSizeHigh) ) {
            *lpFileSizeHigh = (DWORD)Li.HighPart;
            }
        if (Li.LowPart == -1 ) {
            SetLastError(0);
            }
        }
    else {
        Li.LowPart = -1;
        }

    return Li.LowPart;
}

BOOL
WINAPI
GetFileSizeEx(
    HANDLE hFile,
    PLARGE_INTEGER lpFileSize
    )

/*++

Routine Description:

    This function returns the size of the file specified by
    hFile. It is capable of returning 64-bits worth of file size.

Arguments:

    hFile - Supplies an open handle to a file whose size is to be
        returned.  The handle must have been created with either
        GENERIC_READ or GENERIC_WRITE access to the file.

    lpFileSize - Returns the files size


Return Value:

    TRUE - The operation was successful


    FALSE - The operation failed. Extended error
        status is available using GetLastError.


--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_NETWORK_OPEN_INFORMATION NetworkInfo;

    Status = NtQueryInformationFile(
                hFile,
                &IoStatusBlock,
                &NetworkInfo,
                sizeof(NetworkInfo),
                FileNetworkOpenInformation
                );
    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        return FALSE;
        }
    else {
        *lpFileSize = NetworkInfo.EndOfFile;
        return TRUE;
        }
}

BOOL
WINAPI
ReadFileEx(
    HANDLE hFile,
    LPVOID lpBuffer,
    DWORD nNumberOfBytesToRead,
    LPOVERLAPPED lpOverlapped,
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )

/*++

Routine Description:

    Data can be read from a file using ReadFileEx.

    This API reports its completion status asynchronously by calling the
    specified lpCompletionRoutine.

    The caller of this routine uses the lpOverlappedStructure to specify
    the byte offset within the file where the read is to begin from.
    For files that do not support this concept (pipes...), the starting
    file offset is ignored.

    Upon successful completion of this API (return value of TRUE), the
    calling thread has an I/O outstanding.  When the I/O completes, and
    the thread is blocked in an alertable wait, the lpCompletionRoutine
    will be called and the wait will return with a return code of
    WAIT_IO_COMPLETION.  If the I/O completes, but the thread issuing
    the I/O is not in an alertable wait, the call to the completion
    routine is queued until the thread executes an alertable wait.

    If this API fails (by returning FALSE), GetLastError can be used to
    get additional error information.  If this call fails because the
    thread issued a read beyond the end of file, GetLastError will
    return a value of ERROR_HANDLE_EOF.

Arguments:

    hFile - Supplies an open handle to a file that is to be read.  The
        file handle must have been created with GENERIC_READ access to
        the file.  The file must have been created with the
        FILE_FLAG_OVERLAPPED flag.

    lpBuffer - Supplies the address of a buffer to receive the data read
        from the file.

    nNumberOfBytesToRead - Supplies the number of bytes to read from the
        file.

    lpOverlapped - Supplies the address of an OVERLAPPED structure to be
        used with the request.  The caller of this function must specify
        a starting byte offset within the file to start the read from.
        It does this using the Offset and OffsetHigh fields of the
        overlapped structure.  This call does not use or modify the
        hEvent field of the overlapped structure.  The caller may use
        this field for any purpose.  This API does use the Internal and
        InternalHigh fields of the overlapped structure, the thread
        should not manipulate this.  The lpOverlapped structure must
        remain valid for the duration of the I/O.  It is not a good idea
        to make it a local variable and then possibly returning from the
        routine with the I/O that is using this structure still pending.

Return Value:

    TRUE - The operation was successul.  Completion status will be
        propagated to the caller using the completion callback
        mechanism.  Note that this information is only made available to
        the thread that issued the I/O, and only when the I/O completes,
        and the thread is executing in an alertable wait.

    FALSE - The operation failed.  Extended error status is available
        using GetLastError. Note that end of file is treated as a failure
        with an error code of ERROR_HANDLE_EOF.

--*/
{
    NTSTATUS Status;
    LARGE_INTEGER Li;

    Li.LowPart = lpOverlapped->Offset;
    Li.HighPart = lpOverlapped->OffsetHigh;

    Status = NtReadFile(
                hFile,
                NULL,
                NtUserIoApcDispatcher,
                (PVOID) lpCompletionRoutine,
                (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                lpBuffer,
                nNumberOfBytesToRead,
                &Li
                );
    if ( NT_ERROR(Status) ) {
        XapiSetLastNTError(Status);
        return FALSE;
        }
    else {
        return TRUE;
        }
}

BOOL
WINAPI
WriteFileEx(
    HANDLE hFile,
    LPCVOID lpBuffer,
    DWORD nNumberOfBytesToWrite,
    LPOVERLAPPED lpOverlapped,
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )

/*++

Routine Description:

    Data can be written to a file using WriteFileEx.

    This API reports its completion status asynchronously by calling the
    specified lpCompletionRoutine.

    The caller of this routine uses the lpOverlappedStructure to specify
    the byte offset within the file where the write is to begin.
    For files that do not support this concept (pipes...), the starting
    file offset is ignored.

    Upon successful completion of this API (return value of TRUE), the
    calling thread has an I/O outstanding.  When the I/O completes, and
    the thread is blocked in an alertable wait, the lpCompletionRoutine
    will be called and the wait will return with a return code of
    WAIT_IO_COMPLETION.  If the I/O completes, but the thread issuing
    the I/O is not in an alertable wait, the call to the completion
    routine is queued until the thread executes an alertable wait.

    If this API fails (by returning FALSE), GetLastError can be used to
    get additional error information.

    Unlike DOS, a NumberOfBytesToWrite value of zero does not truncate
    or extend the file.  If this function is required, SetEndOfFile
    should be used.

Arguments:

    hFile - Supplies an open handle to a file that is to be written.  The
        file handle must have been created with GENERIC_WRITE access to
        the file.

    lpBuffer - Supplies the address of the data that is to be written to
        the file.

    nNumberOfBytesToWrite - Supplies the number of bytes to write to the
        file. Unlike DOS, a value of zero is interpreted a null write.

    lpOverlapped - Supplies the address of an OVERLAPPED structure to be
        used with the request.  The caller of this function must specify
        a starting byte offset within the file to start the write to.
        It does this using the Offset and OffsetHigh fields of the
        overlapped structure.  This call does not use or modify the
        hEvent field of the overlapped structure.  The caller may use
        this field for any purpose.  This API does use the Internal and
        InternalHigh fields of the overlapped structure, the thread
        should not manipulate this.  The lpOverlapped structure must
        remain valid for the duration of the I/O.  It is not a good idea
        to make it a local variable and then possibly returning from the
        routine with the I/O that is using this structure still pending.

Return Value:

    TRUE - The operation was successul.  Completion status will be
        propagated to the caller using the completion callback
        mechanism.  Note that this information is only made available to
        the thread that issued the I/O, and only when the I/O completes,
        and the thread is executing in an alertable wait.

    FALSE - The operation failed.  Extended error status is available
        using GetLastError. Note that end of file is treated as a failure
        with an error code of ERROR_HANDLE_EOF.

--*/
{
    NTSTATUS Status;
    LARGE_INTEGER Li;

    Li.LowPart = lpOverlapped->Offset;
    Li.HighPart = lpOverlapped->OffsetHigh;

    Status = NtWriteFile(
                hFile,
                NULL,
                NtUserIoApcDispatcher,
                (PVOID) lpCompletionRoutine,
                (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                (LPVOID)lpBuffer,
                nNumberOfBytesToWrite,
                &Li
                );
    if ( NT_ERROR(Status) ) {
        XapiSetLastNTError(Status);
        return FALSE;
        }
    else {
        return TRUE;
        }
}

BOOL
WINAPI
DeviceIoControl(
    HANDLE hDevice,
    DWORD dwIoControlCode,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesReturned,
    LPOVERLAPPED lpOverlapped
    )

/*++

Routine Description:

    An operation on a device may be performed by calling the device driver
    directly using the DeviceIoContrl function.

    The device driver must first be opened to get a valid handle.

Arguments:

    hDevice - Supplies an open handle a device on which the operation is to
        be performed.

    dwIoControlCode - Supplies the control code for the operation. This
        control code determines on which type of device the operation must
        be performed and determines exactly what operation is to be
        performed.

    lpInBuffer - Suplies an optional pointer to an input buffer that contains
        the data required to perform the operation.  Whether or not the
        buffer is actually optional is dependent on the IoControlCode.

    nInBufferSize - Supplies the length of the input buffer in bytes.

    lpOutBuffer - Suplies an optional pointer to an output buffer into which
        the output data will be copied. Whether or not the buffer is actually
        optional is dependent on the IoControlCode.

    nOutBufferSize - Supplies the length of the output buffer in bytes.

    lpBytesReturned - Supplies a pointer to a dword which will receive the
        actual length of the data returned in the output buffer.

    lpOverlapped - An optional parameter that supplies an overlap structure to
        be used with the request. If NULL or the handle was created without
        FILE_FLAG_OVERLAPPED then the DeviceIoControl will not return until
        the operation completes.

        When lpOverlapped is supplied and FILE_FLAG_OVERLAPPED was specified
        when the handle was created, DeviceIoControl may return
        ERROR_IO_PENDING to allow the caller to continue processing while the
        operation completes. The event (or File handle if hEvent == NULL) will
        be set to the not signalled state before ERROR_IO_PENDING is
        returned. The event will be set to the signalled state upon completion
        of the request. GetOverlappedResult is used to determine the result
        when ERROR_IO_PENDING is returned.

Return Value:

    TRUE -- The operation was successful.

    FALSE -- The operation failed. Extended error status is available using
        GetLastError.

--*/
{

    NTSTATUS Status;
    BOOLEAN DevIoCtl;

    if ( dwIoControlCode >> 16 == FILE_DEVICE_FILE_SYSTEM ) {
        DevIoCtl = FALSE;
        }
    else {
        DevIoCtl = TRUE;
        }

    if ( ARGUMENT_PRESENT( lpOverlapped ) ) {
        lpOverlapped->Internal = (DWORD)STATUS_PENDING;

        if ( DevIoCtl ) {

            Status = NtDeviceIoControlFile(
                        hDevice,
                        lpOverlapped->hEvent,
                        NULL,             // APC routine
                        (ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped,
                        (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                        dwIoControlCode,  // IoControlCode
                        lpInBuffer,       // Buffer for data to the FS
                        nInBufferSize,
                        lpOutBuffer,      // OutputBuffer for data from the FS
                        nOutBufferSize    // OutputBuffer Length
                        );
            }
        else {

            Status = NtFsControlFile(
                        hDevice,
                        lpOverlapped->hEvent,
                        NULL,             // APC routine
                        (ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped,
                        (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                        dwIoControlCode,  // IoControlCode
                        lpInBuffer,       // Buffer for data to the FS
                        nInBufferSize,
                        lpOutBuffer,      // OutputBuffer for data from the FS
                        nOutBufferSize    // OutputBuffer Length
                        );

            }

        // handle warning value STATUS_BUFFER_OVERFLOW somewhat correctly
        if ( !NT_ERROR(Status) && ARGUMENT_PRESENT(lpBytesReturned) ) {
            *lpBytesReturned = (DWORD)lpOverlapped->InternalHigh;
            }
        if ( NT_SUCCESS(Status) && Status != STATUS_PENDING) {
            return TRUE;
            }
        else {
            XapiSetLastNTError(Status);
            return FALSE;
            }
        }
    else
        {
        IO_STATUS_BLOCK Iosb;

        if ( DevIoCtl ) {
            Status = NtDeviceIoControlFile(
                        hDevice,
                        NULL,
                        NULL,             // APC routine
                        NULL,             // APC Context
                        &Iosb,
                        dwIoControlCode,  // IoControlCode
                        lpInBuffer,       // Buffer for data to the FS
                        nInBufferSize,
                        lpOutBuffer,      // OutputBuffer for data from the FS
                        nOutBufferSize    // OutputBuffer Length
                        );
            }
        else {
            Status = NtFsControlFile(
                        hDevice,
                        NULL,
                        NULL,             // APC routine
                        NULL,             // APC Context
                        &Iosb,
                        dwIoControlCode,  // IoControlCode
                        lpInBuffer,       // Buffer for data to the FS
                        nInBufferSize,
                        lpOutBuffer,      // OutputBuffer for data from the FS
                        nOutBufferSize    // OutputBuffer Length
                        );
            }

        if ( Status == STATUS_PENDING) {
            // Operation must complete before return & Iosb destroyed
            Status = NtWaitForSingleObject( hDevice, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {
                Status = Iosb.Status;
                }
            }

        if ( NT_SUCCESS(Status) ) {
            *lpBytesReturned = (DWORD)Iosb.Information;
            return TRUE;
            }
        else {
            // handle warning value STATUS_BUFFER_OVERFLOW somewhat correctly
            if ( !NT_ERROR(Status) ) {
                *lpBytesReturned = (DWORD)Iosb.Information;
            }
            XapiSetLastNTError(Status);
            return FALSE;
            }
        }
}

BOOL
WINAPI
ReadFileScatter(
    HANDLE hFile,
    FILE_SEGMENT_ELEMENT aSegementArray[],
    DWORD nNumberOfBytesToRead,
    LPDWORD lpNumberOfBytesRead,
    LPOVERLAPPED lpOverlapped
    )
/*++

Routine Description:

    Data can be read from a file using ReadFileScatter.  The data
    is then scatter to specified buffer segements.

    This API is used to read data from a file.  Data is read from the
    file from the position indicated by the file pointer.  After the
    read completes, the file pointer is adjusted by the number of bytes
    actually read.  A return value of TRUE coupled with a bytes read of
    0 indicates that the file pointer was beyond the current end of the
    file at the time of the read.

Arguments:

    hFile - Supplies an open handle to a file that is to be read.  The
        file handle must have been created with GENERIC_READ access to
        the file.

    aSegementArray - Supplies a pointer an array of virtual segments.
        A virtual segment is a memory buffer where part of the transferred data
        should be placed.  Segments are have a fix size of PAGE_SIZE
        and must be aligned on a PAGE_SIZE boundary.

    nNumberOfBytesToRead - Supplies the number of bytes to read from the file.

    lpNumberOfBytesRead - Returns the number of bytes read by this call.
        This parameter is always set to 0 before doing any IO or error
        checking.

    lpOverlapped - Optionally points to an OVERLAPPED structure to be used with the
    request. If NULL then the transfer starts at the current file position
    and ReadFile will not return until the operation completes.

    If the handle hFile was created without specifying FILE_FLAG_OVERLAPPED
    the file pointer is moved to the specified offset plus
    lpNumberOfBytesRead before ReadFile returns. ReadFile will wait for the
    request to complete before returning (it will not return
    ERROR_IO_PENDING).

    When FILE_FLAG_OVERLAPPED is specified, ReadFile may return
    ERROR_IO_PENDING to allow the calling function to continue processing
    while the operation completes. The event (or hFile if hEvent is NULL) will
    be set to the signalled state upon completion of the request.

    When the handle is created with FILE_FLAG_OVERLAPPED and lpOverlapped
    is set to NULL, ReadFile will return ERROR_INVALID_PARAMTER because
    the file offset is required.

Return Value:

    TRUE - The operation was successul.

    FALSE - The operation failed.  Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;

    if ( ARGUMENT_PRESENT(lpNumberOfBytesRead) ) {
        *lpNumberOfBytesRead = 0;
        }

    if ( ARGUMENT_PRESENT( lpOverlapped ) ) {
        LARGE_INTEGER Li;

        lpOverlapped->Internal = (DWORD)STATUS_PENDING;
        Li.LowPart = lpOverlapped->Offset;
        Li.HighPart = lpOverlapped->OffsetHigh;
        Status = NtReadFileScatter(
                hFile,
                lpOverlapped->hEvent,
                NULL,
                (ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped,
                (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                aSegementArray,
                nNumberOfBytesToRead,
                &Li
                );

        if ( NT_SUCCESS(Status) && Status != STATUS_PENDING) {
            if ( ARGUMENT_PRESENT(lpNumberOfBytesRead) ) {
                *lpNumberOfBytesRead = (DWORD)lpOverlapped->InternalHigh;
                }
            return TRUE;
            }
        else
        if (Status == STATUS_END_OF_FILE) {
            if ( ARGUMENT_PRESENT(lpNumberOfBytesRead) ) {
                *lpNumberOfBytesRead = 0;
                }
            XapiSetLastNTError(Status);
            return FALSE;
            }
        else {
            XapiSetLastNTError(Status);
            return FALSE;
            }
        }
    else
        {
        Status = NtReadFileScatter(
                hFile,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                aSegementArray,
                nNumberOfBytesToRead,
                NULL
                );

        if ( Status == STATUS_PENDING) {
            // Operation must complete before return & IoStatusBlock destroyed
            Status = NtWaitForSingleObject( hFile, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {
                Status = IoStatusBlock.Status;
                }
            }

        if ( NT_SUCCESS(Status) ) {
            *lpNumberOfBytesRead = (DWORD)IoStatusBlock.Information;
            return TRUE;
            }
        else
        if (Status == STATUS_END_OF_FILE) {
            *lpNumberOfBytesRead = 0;
            return TRUE;
            }
        else {
            if ( NT_WARNING(Status) ) {
                *lpNumberOfBytesRead = (DWORD)IoStatusBlock.Information;
                }
            XapiSetLastNTError(Status);
            return FALSE;
            }
        }
}


BOOL
WINAPI
WriteFileGather(
    HANDLE hFile,
    FILE_SEGMENT_ELEMENT aSegementArray[],
    DWORD nNumberOfBytesToWrite,
    LPDWORD lpNumberOfBytesWritten,
    LPOVERLAPPED lpOverlapped
    )

/*++

Routine Description:

    Data can be written to a file using WriteFileGather.  The data can
    be in multple file segement buffers.

    This API is used to write data to a file.  Data is written to the
    file from the position indicated by the file pointer.  After the
    write completes, the file pointer is adjusted by the number of bytes
    actually written.

    Unlike DOS, a NumberOfBytesToWrite value of zero does not truncate
    or extend the file.  If this function is required, SetEndOfFile
    should be used.

Arguments:

    hFile - Supplies an open handle to a file that is to be written.  The
        file handle must have been created with GENERIC_WRITE access to
        the file.

    aSegementArray - Supplies a pointer an array of virtual segments.
        A virtual segment is a memory buffer where part of the transferred data
        should be placed.  Segments are have a fix size of PAGE_SIZE
        and must be aligned on a PAGE_SIZE boundary. The number of
        entries in the array must be equal to nNumberOfBytesToRead /
        PAGE_SIZE.

    nNumberOfBytesToWrite - Supplies the number of bytes to write to the
        file. Unlike DOS, a value of zero is interpreted a null write.

    lpNumberOfBytesWritten - Returns the number of bytes written by this
        call. Before doing any work or error processing, the API sets this
        to zero.

    lpOverlapped - Optionally points to an OVERLAPPED structure to be
        used with the request. If NULL then the transfer starts at the
        current file position and WriteFileGather will not return until the
        operation completes.

        If the handle <hFile> was created without specifying
        FILE_FLAG_OVERLAPPED the file pointer is moved to the specified
        offset plus lpNumberOfBytesWritten before WriteFile returns.
        WriteFile will wait for the request to complete before returning
        (it will not set ERROR_IO_PENDING).

        When FILE_FLAG_OVERLAPPED is specified, WriteFile may return
        ERROR_IO_PENDING to allow the calling function to continue processing
        while the operation completes. The event (or hFile if hEvent is NULL) will
        be set to the signalled state upon completion of the request.

        When the handle is created with FILE_FLAG_OVERLAPPED and lpOverlapped
        is set to NULL, WriteFile will return ERROR_INVALID_PARAMTER because
        the file offset is required.

Return Value:

    TRUE - The operation was a success.

    FALSE - The operation failed.  Extended error status is
        available using GetLastError.

--*/

{

    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;

    if ( ARGUMENT_PRESENT(lpNumberOfBytesWritten) ) {
        *lpNumberOfBytesWritten = 0;
        }

    if ( ARGUMENT_PRESENT( lpOverlapped ) ) {
        LARGE_INTEGER Li;

        lpOverlapped->Internal = (DWORD)STATUS_PENDING;
        Li.LowPart = lpOverlapped->Offset;
        Li.HighPart = lpOverlapped->OffsetHigh;
        Status = NtWriteFileGather(
                hFile,
                lpOverlapped->hEvent,
                NULL,
                (ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped,
                (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                aSegementArray,
                nNumberOfBytesToWrite,
                &Li
                );

        if ( !NT_ERROR(Status) && Status != STATUS_PENDING) {
            if ( ARGUMENT_PRESENT(lpNumberOfBytesWritten) ) {
                *lpNumberOfBytesWritten = (DWORD)lpOverlapped->InternalHigh;
                }
            return TRUE;
            }
        else  {
            XapiSetLastNTError(Status);
            return FALSE;
            }
        }
    else {
        Status = NtWriteFileGather(
                hFile,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                aSegementArray,
                nNumberOfBytesToWrite,
                NULL
                );

        if ( Status == STATUS_PENDING) {
            // Operation must complete before return & IoStatusBlock destroyed
            Status = NtWaitForSingleObject( hFile, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {
                Status = IoStatusBlock.Status;
                }
            }

        if ( NT_SUCCESS(Status)) {
            *lpNumberOfBytesWritten = (DWORD)IoStatusBlock.Information;
            return TRUE;
            }
        else {
            if ( NT_WARNING(Status) ) {
                *lpNumberOfBytesWritten = (DWORD)IoStatusBlock.Information;
                }
            XapiSetLastNTError(Status);
            return FALSE;
            }
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\fiber.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    fiber.c

Abstract:

    This module implements the Win32 fiber services.

--*/

#include "basedll.h"
#pragma hdrstop
#include "dm.h"

//
// Per thread fiber data pointer.
//
__declspec(thread) LPVOID XapiCurrentFiber;

//
// For threads that have been converted to fibers, this per thread structure
// holds its fiber data.
//
__declspec(thread) XFIBER XapiThreadFiberData;

VOID
XapiFiberStartup(
    LPFIBER_START_ROUTINE lpStartAddress
    )
{
    __try {

        lpStartAddress(GetFiberData());

    } __except (UnhandledExceptionFilter(GetExceptionInformation())) {

        //
        // UnhandledExceptionFilter will return either EXCEPTION_CONTINUE_SEARCH,
        // in which case, the exception search will stop since we're the top of
        // the exception stack, or it will return EXCEPTION_CONTINUE_EXECUTION.
        // We'll never execute this handler.
        //

        ASSERT(FALSE);
    }

    RIP("Fiber should not return.");

    KeBugCheck(0);
}

LPVOID
WINAPI
CreateFiber(
    IN DWORD dwStackSize,
    IN LPFIBER_START_ROUTINE lpStartAddress,
    IN LPVOID lpParameter
    )
{
    PVOID StackBase;
    PXFIBER Fiber;
    PULONG_PTR Context;

    //
    // Allocate the stack for the fiber.
    //

    if (dwStackSize == 0) {
        dwStackSize = XeImageHeader()->SizeOfStackCommit;
    }

    if (dwStackSize < KERNEL_STACK_SIZE) {
        dwStackSize = KERNEL_STACK_SIZE;
    }

    dwStackSize = ROUND_TO_PAGES(dwStackSize);

    StackBase = MmCreateKernelStack(dwStackSize, FALSE);

    if (StackBase == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    //
    // Allocate the fiber structure at the top of the fiber stack.
    //

    Fiber = (PXFIBER)StackBase - 1;

    //
    // Initialize the fiber state.
    //

    Fiber->FiberData = lpParameter;
    Fiber->StackBase = StackBase;
    Fiber->StackLimit = (PUCHAR)StackBase - dwStackSize;

    //
    // Initialize the start context for the fiber.  The start context consists
    // of the parameter to XapiFiberStartup, a dummy return address for the
    // 'call' to XapiFiberStartup (we use XapiFiberStartup itself in order to
    // make the kernel debugger happy), a dummy parameter to SwitchToFiber, the
    // return address for SwitchToFiber, and the initial non-volatile context.
    //

    Context = (PULONG_PTR)Fiber - 1;

    *(Context--) = (ULONG_PTR)lpStartAddress;
    *(Context--) = (ULONG_PTR)XapiFiberStartup;
    *(Context--) = 0;
    *(Context--) = (ULONG_PTR)XapiFiberStartup;
    *(Context--) = 0;
    *(Context--) = 0;
    *(Context--) = 0;
    *(Context--) = 0;
    *(Context) = (ULONG_PTR)EXCEPTION_CHAIN_END;

    Fiber->KernelStack = Context;

#if 0
    // Tell the debugger we've created the fiber
    if(KeGetCurrentPrcb()->DebugMonitorData) {
        _asm {
            mov eax, BREAKPOINT_CREATE_FIBER
            mov ecx, Fiber
            mov edx, lpStartAddress
            int 2dh
            int 3
        }
    }
#endif

    return Fiber;
}

VOID
WINAPI
DeleteFiber(
    IN LPVOID lpFiber
    )
{
    PXFIBER Fiber;

    RIP_ON_NOT_TRUE("DeleteFiber()", (lpFiber != NULL));

    Fiber = (PXFIBER)lpFiber;

    //
    // Unlike Win32, we cannot delete the currently executing fiber.  Win32
    // would call ExitThread here, but if we do that, then that doesn't end up
    // freeing the fiber's stack, but ends up killing a thread that called
    // ConvertThreadToFiber.
    //

    if (Fiber->KernelStack == NULL) {
        RIP("DeleteFiber() - Cannot delete an active fiber.");
    }

    //
    // Fibers created from ConvertThreadToFiber use the stack of the calling
    // thread.  We can't delete this fiber without destroying the thread.  We
    // could choose to delete just the fiber structure, but that alters the
    // behavior of the original API too much.
    //

    if (Fiber->StackLimit == NULL) {
        RIP("DeleteFiber() - Cannot delete a fiber from ConvertThreadToFiber.");
    }

#if 0
    // Tell the debugger this fiber is going away
    if(KeGetCurrentPrcb()->DebugMonitorData) {
        _asm {
            mov eax, BREAKPOINT_DELETE_FIBER
            mov ecx, Fiber
            int 2dh
            int 3
        }
    }
#endif

    //
    // Delete the fiber's stack.  The fiber structure is allocated as a part of
    // the stack, so Fiber is not valid after this point.
    //

    MmDeleteKernelStack(Fiber->StackBase, Fiber->StackLimit);
}

LPVOID
WINAPI
ConvertThreadToFiber(
    IN LPVOID lpParameter
    )
{
    PXFIBER Fiber;

    //
    // Check that the current thread isn't already hosting a fiber.
    //

    if (XapiCurrentFiber != NULL) {
        RIP("ConvertThreadToFiber() - Cannot convert a thread to a fiber multiple times.");
    }

    //
    // Initialize the fiber state.
    //

    Fiber = &XapiThreadFiberData;

    Fiber->FiberData = lpParameter;
    Fiber->StackBase = KeGetCurrentThread()->StackBase;
    Fiber->StackLimit = NULL;

#if 0
    // Tell the debugger how to find a fiber
    DmTell(DMTELL_FIBERTLS, (PVOID)((ULONG_PTR)&XapiCurrentFiber -
        (ULONG_PTR)KeGetCurrentThread()->TlsData));

    // Tell the debugger we've created the fiber
    if(KeGetCurrentPrcb()->DebugMonitorData) {
        _asm {
            mov eax, BREAKPOINT_CREATE_FIBER
            mov ecx, Fiber
            xor edx, edx
            int 2dh
            int 3
        }
    }
#endif

    //
    // Make this fiber the current fiber for the thread.
    //

    XapiCurrentFiber = Fiber;

    return Fiber;
}

__declspec(naked)
VOID
WINAPI
#if DBG
XapiSwitchToFiberRetail(
#else
SwitchToFiber(
#endif
    LPVOID lpFiber
    )
{
    __asm {

        //
        // Fetch the offset to the TLS data and the base pointer to the TLS
        // data.
        //

        mov     edx,_tls_index
        mov     ecx,fs:[NT_TIB.StackBase]

        //
        // Load the pointer to the new fiber.
        //

        mov     eax,[esp+4]

        //
        // Save the old fiber's nonvolatile state and exception list.
        //

        push    ebp
        push    esi
        push    edi
        push    ebx
        push    DWORD PTR fs:[NT_TIB.ExceptionList]

        //
        // Load the pointer to the old fiber from XapiCurrentFiber.
        //

        mov     edx,[ecx+edx*4]
        mov     ecx,XapiCurrentFiber[edx]

        //
        // Switch from the old fiber's stack to the new fiber's stack.
        //

        mov     [ecx+XFIBER.KernelStack],esp
        mov     esp,[eax+XFIBER.KernelStack]

#if DBG
        //
        // Null out the kernel stack pointer so that we can use this as a flag
        // in SwitchToFiber to detect a fiber that's already running.
        //

        mov     DWORD PTR [eax+XFIBER.KernelStack], 0
#endif

        //
        // Update XapiCurrentFiber to point at the new fiber.
        //

        mov     XapiCurrentFiber[edx],eax

        //
        // Restore the new fiber's nonvolatile state and exception list.
        //

        pop     DWORD PTR fs:[NT_TIB.ExceptionList]
        pop     ebx
        pop     edi
        pop     esi
        pop     ebp

        ret     4
    }
}

#if DBG

VOID
WINAPI
SwitchToFiber(
    LPVOID lpFiber
    )
{
    PXFIBER Fiber;

    RIP_ON_NOT_TRUE("SwitchToFiber()", (lpFiber != NULL));

    //
    // Check that the current thread has called ConvertThreadToFiber.
    //

    if (XapiCurrentFiber == NULL) {
        RIP("SwitchToFiber() - Thread hasn't called ConvertThreadToFiber().");
    }

    //
    // Check that the fiber isn't already running on another thread.  We'll
    // allow a fiber to switch to itself on the same thread (Win32 documents
    // this as "unpredictable".)
    //

    Fiber = (PXFIBER)lpFiber;

    if ((Fiber->KernelStack == NULL) && (XapiCurrentFiber != Fiber)) {
        RIP("SwitchToFiber() - Fiber is already active on another thread.");
    }

    //
    // Jump to the retail version of this routine.
    //

    XapiSwitchToFiberRetail(lpFiber);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\debug.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This module implements Win32 Debug APIs

--*/

#include "basedll.h"
#include <stdio.h>
#pragma hdrstop

VOID
APIENTRY
OutputDebugStringW(
    LPCWSTR lpOutputString
    )

/*++

Routine Description:

    UNICODE thunk to OutputDebugStringA

--*/

{
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    RtlInitUnicodeString(&UnicodeString,lpOutputString);
    Status = RtlUnicodeStringToAnsiString(&AnsiString,&UnicodeString,TRUE);
    if ( !NT_SUCCESS(Status) ) {
        AnsiString.Buffer = "";
        }
    OutputDebugStringA(AnsiString.Buffer);
    if ( NT_SUCCESS(Status) ) {
        RtlFreeAnsiString(&AnsiString);
        }
}

VOID
APIENTRY
OutputDebugStringA(
    IN LPCSTR lpOutputString
    )

/*++

Routine Description:

    This function allows an application to send a string to its debugger
    for display.  If the application is not being debugged, but the
    system debugger is active, the system debugger displays the string.
    Otherwise, this function has no effect.

Arguments:

    lpOutputString - Supplies the address of the debug string to be sent
        to the debugger.

Return Value:

    None.

--*/

{
    ANSI_STRING ast, *past;

    ast.Buffer = (LPSTR)lpOutputString;
    ast.Length = (USHORT)strlen(ast.Buffer);
    ast.MaximumLength = ast.Length+1;
    _asm {
        lea ecx, ast
        mov eax, BREAKPOINT_PRINT
        int 2dh
        int 3
    }
}

#if DBG

ULONG XDebugOutLevel = XDBG_WARNING;
ULONG XDebugBrkLevel = XDBG_ERROR;

PSTR XDebugLevels[] =
{
    "!!!",
    "ERR",
    "WRN",
    "TRC",
    "ENT",
    "EXT",
};

VOID
XDBGAPI
vXDebugPrint(ULONG Level, PCHAR Module, PCHAR Format, va_list arglist)
{
    CHAR string[MAX_PATH];

    if (Level <= XDebugOutLevel)
    {
        _vsnprintf(string, sizeof(string), Format, arglist);
        DbgPrint("%s[%s]: %s\n", (Level <= XDBG_EXIT) ? XDebugLevels[Level] : "???", Module, string);
        if (Level <= XDebugBrkLevel)
        {
            _asm { int 3 };
        }
    }
}

VOID
XDBGAPIV
XDebugPrint(ULONG Level, PCHAR Module, PCHAR Format, ...)
{
    va_list arglist;
    va_start(arglist, Format);
    vXDebugPrint(Level, Module, Format, arglist);
    va_end(arglist);
}

VOID
XDBGAPIV
XDebugError(PCHAR Module, PCHAR Format, ...)
{
    va_list arglist;
    va_start(arglist, Format);
    vXDebugPrint(XDBG_ERROR, Module, Format, arglist);
    va_end(arglist);
}

VOID
XDBGAPIV
XDebugWarning(PCHAR Module, PCHAR Format, ...)
{
    va_list arglist;
    va_start(arglist, Format);
    vXDebugPrint(XDBG_WARNING, Module, Format, arglist);
    va_end(arglist);
}

VOID
XDBGAPIV
XDebugTrace(PCHAR Module, PCHAR Format, ...)
{
    va_list arglist;
    va_start(arglist, Format);
    vXDebugPrint(XDBG_TRACE, Module, Format, arglist);
    va_end(arglist);
}

VOID
XDBGAPIV
XDebugEntry(PCHAR Module, PCHAR Format, ...)
{
    va_list arglist;
    va_start(arglist, Format);
    vXDebugPrint(XDBG_ENTRY, Module, Format, arglist);
    va_end(arglist);
}

VOID
XDBGAPIV
XDebugExit(PCHAR Module, PCHAR Format, ...)
{
    va_list arglist;
    va_start(arglist, Format);
    vXDebugPrint(XDBG_EXIT, Module, Format, arglist);
    va_end(arglist);
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\filemisc.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    filemisc.c

Abstract:

    Misc file operations for Win32

Author:

    Mark Lucovsky (markl) 26-Sep-1990

Revision History:

--*/

#include <basedll.h>
#include "..\..\fatx\fat.h"

BOOL
APIENTRY
SetFileAttributes(
    PCOSTR lpFileName,
    DWORD dwFileAttributes
    )

/*++

Routine Description:

    The attributes of a file can be set using SetFileAttributes.

    This API provides the same functionality as DOS (int 21h, function
    43H with AL=1), and provides a subset of OS/2's DosSetFileInfo.

Arguments:

    lpFileName - Supplies the file name of the file whose attributes are to
        be set.

    dwFileAttributes - Specifies the file attributes to be set for the
        file.  Any combination of flags is acceptable except that all
        other flags override the normal file attribute,
        FILE_ATTRIBUTE_NORMAL.

        FileAttributes Flags:

        FILE_ATTRIBUTE_NORMAL - A normal file should be created.

        FILE_ATTRIBUTE_READONLY - A read-only file should be created.

        FILE_ATTRIBUTE_HIDDEN - A hidden file should be created.

        FILE_ATTRIBUTE_SYSTEM - A system file should be created.

        FILE_ATTRIBUTE_ARCHIVE - The file should be marked so that it
            will be archived.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    OBJECT_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_BASIC_INFORMATION BasicInfo;

    RtlInitObjectString(&FileName, lpFileName);

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        ObDosDevicesDirectory(),
        NULL
        );

    //
    // Open the file.
    //

    Status = NtOpenFile(
                &Handle,
                (ACCESS_MASK)FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                );

    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        return FALSE;
        }

    //
    // Set the attributes
    //

    RtlZeroMemory(&BasicInfo,sizeof(BasicInfo));
    BasicInfo.FileAttributes = (dwFileAttributes & FILE_ATTRIBUTE_VALID_SET_FLAGS) | FILE_ATTRIBUTE_NORMAL;

    Status = NtSetInformationFile(
                Handle,
                &IoStatusBlock,
                &BasicInfo,
                sizeof(BasicInfo),
                FileBasicInformation
                );

    NtClose(Handle);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        XapiSetLastNTError(Status);
        return FALSE;
        }
}

DWORD
APIENTRY
GetFileAttributes(
    PCOSTR lpFileName
    )

/*++

Routine Description:

    The attributes of a file can be obtained using GetFileAttributes.

    This API provides the same functionality as DOS (int 21h, function
    43H with AL=0), and provides a subset of OS/2's DosQueryFileInfo.

Arguments:

    lpFileName - Supplies the file name of the file whose attributes are to
        be set.

Return Value:

    Not -1 - Returns the attributes of the specified file.  Valid
        returned attributes are:

        FILE_ATTRIBUTE_NORMAL - The file is a normal file.

        FILE_ATTRIBUTE_READONLY - The file is marked read-only.

        FILE_ATTRIBUTE_HIDDEN - The file is marked as hidden.

        FILE_ATTRIBUTE_SYSTEM - The file is marked as a system file.

        FILE_ATTRIBUTE_ARCHIVE - The file is marked for archive.

        FILE_ATTRIBUTE_DIRECTORY - The file is marked as a directory.

        FILE_ATTRIBUTE_VOLUME_LABEL - The file is marked as a volume lable.

    0xffffffff - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    OBJECT_STRING FileName;
    FILE_NETWORK_OPEN_INFORMATION NetworkInfo;

    RtlInitObjectString(&FileName, lpFileName);

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        ObDosDevicesDirectory(),
        NULL
        );

    //
    // Query the information about the file using the path-based NT service.
    //

    Status = NtQueryFullAttributesFile( &Obja, &NetworkInfo );
    if ( NT_SUCCESS(Status) ) {
        return NetworkInfo.FileAttributes;
        }
    else {
        XapiSetLastNTError(Status);
        return (DWORD)-1;
        }
}

BOOL
APIENTRY
GetFileAttributesEx(
    PCOSTR lpFileName,
    GET_FILEEX_INFO_LEVELS fInfoLevelId,
    LPVOID lpFileInformation
    )

/*++

Routine Description:

    The main attributes of a file can be obtained using GetFileAttributesEx.

Arguments:

    lpFileName - Supplies the file name of the file whose attributes are to
        be set.

    fInfoLevelId - Supplies the info level indicating the information to be
        returned about the file.

    lpFileInformation - Supplies a buffer to receive the specified information
        about the file.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.


--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    OBJECT_STRING FileName;
    FILE_NETWORK_OPEN_INFORMATION NetworkInfo;
    LPWIN32_FILE_ATTRIBUTE_DATA AttributeData;

    //
    // Check the parameters.  Note that for now there is only one info level,
    // so there's no special code here to determine what to do.
    //

    RIP_ON_NOT_TRUE("GetFileAttributesEx()",
                    (fInfoLevelId < GetFileExMaxInfoLevel && fInfoLevelId >= GetFileExInfoStandard));

    RtlInitObjectString(&FileName, lpFileName);

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        ObDosDevicesDirectory(),
        NULL
        );

    //
    // Query the information about the file using the path-based NT service.
    //

    Status = NtQueryFullAttributesFile( &Obja, &NetworkInfo );

    if ( NT_SUCCESS(Status) ) {
        AttributeData = (LPWIN32_FILE_ATTRIBUTE_DATA)lpFileInformation;
        AttributeData->dwFileAttributes = NetworkInfo.FileAttributes;
        AttributeData->ftCreationTime = *(PFILETIME)&NetworkInfo.CreationTime;
        AttributeData->ftLastAccessTime = *(PFILETIME)&NetworkInfo.LastAccessTime;
        AttributeData->ftLastWriteTime = *(PFILETIME)&NetworkInfo.LastWriteTime;
        AttributeData->nFileSizeHigh = NetworkInfo.EndOfFile.HighPart;
        AttributeData->nFileSizeLow = (DWORD)NetworkInfo.EndOfFile.LowPart;
        return TRUE;
        }
    else {
        XapiSetLastNTError(Status);
        return FALSE;
        }
}

BOOL
APIENTRY
MoveFile(
    PCOSTR lpExistingFileName,
    PCOSTR lpNewFileName
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    OBJECT_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_RENAME_INFORMATION RenameInfo;

    RtlInitObjectString(&FileName, lpExistingFileName);

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        ObDosDevicesDirectory(),
        NULL
        );

    //
    // Open the existing file for delete access.
    //

    Status = NtOpenFile( &Handle,
                         DELETE | SYNCHRONIZE,
                         &Obja,
                         &IoStatusBlock,
                         FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                         FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                         );

    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        return FALSE;
        }

    //
    // Rename the file.
    //

    RenameInfo.ReplaceIfExists = FALSE;
    RenameInfo.RootDirectory = ObDosDevicesDirectory();

    RtlInitObjectString(&RenameInfo.FileName, lpNewFileName);

    Status = NtSetInformationFile(
                 Handle,
                 &IoStatusBlock,
                 &RenameInfo,
                 sizeof(RenameInfo),
                 FileRenameInformation
                 );

    NtClose(Handle);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        XapiSetLastNTError(Status);
        return FALSE;
        }
}

BOOL
APIENTRY
MoveFileEx(
    PCOSTR lpExistingFileName,
    PCOSTR lpNewFileName,
    DWORD dwFlags
    )

{
    return MoveFileWithProgress(  lpExistingFileName,
                                  lpNewFileName,
                                  (LPPROGRESS_ROUTINE)NULL,
                                  NULL,
                                  dwFlags );
}

BOOL
APIENTRY
MoveFileWithProgress(
    PCOSTR lpExistingFileName,
    PCOSTR lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine OPTIONAL,
    LPVOID lpData OPTIONAL,
    DWORD dwFlags
    )

/*++

Routine Description:

    An existing file can be renamed using MoveFileWithProgressW.

Arguments:

    lpExistingFileName - Supplies the name of an existing file that is to be
        renamed.

    lpNewFileName - Supplies the new name for the existing file.  The new
        name must reside in the same file system/drive as the existing
        file and must not already exist.

    lpProgressRoutine - Supplies a callback routine that is notified.

    lpData - Supplies context data passed to the progress routine.

    dwFlags - Supplies optional flag bits to control the behavior of the
        rename.  The following bits are currently defined:

        MOVEFILE_REPLACE_EXISTING - if the new file name exists, replace
            it by renaming the old file name on top of the new file name.

        MOVEFILE_COPY_ALLOWED - if the new file name is on a different
            volume than the old file name, and causes the rename operation
            to fail, then setting this flag allows the MoveFileEx API
            call to simulate the rename with a call to CopyFile followed
            by a call to DeleteFile to the delete the old file if the
            CopyFile was successful.

        MOVEFILE_WRITE_THROUGH - perform the rename operation in such a
            way that the file has actually been moved on the disk before
            the API returns to the caller.  Note that this flag causes a
            flush at the end of a copy operation (if one were allowed and
            necessary), and has no effect if the rename operation is
            delayed until the next reboot.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    OBJECT_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_RENAME_INFORMATION RenameInfo;
    BOOL b;

    RtlInitObjectString(&FileName, lpExistingFileName);

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        ObDosDevicesDirectory(),
        NULL
        );

    //
    // Open the existing file for delete access.
    //

    Status = NtOpenFile( &Handle,
                         DELETE | SYNCHRONIZE,
                         &Obja,
                         &IoStatusBlock,
                         FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                         FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                         );

    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        return FALSE;
    }

    //
    // Rename the file.
    //

    RenameInfo.ReplaceIfExists = ((dwFlags & MOVEFILE_REPLACE_EXISTING) != 0);
    RenameInfo.RootDirectory = ObDosDevicesDirectory();

    RtlInitObjectString(&RenameInfo.FileName, lpNewFileName);

    Status = NtSetInformationFile(
                 Handle,
                 &IoStatusBlock,
                 &RenameInfo,
                 sizeof(RenameInfo),
                 FileRenameInformation
                 );

    NtClose(Handle);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
    }
    else {

        if ((Status == STATUS_NOT_SAME_DEVICE) &&
            ((dwFlags & MOVEFILE_COPY_ALLOWED) != 0)) {

            b = CopyFileEx(lpExistingFileName,
                           lpNewFileName,
                           lpProgressRoutine,
                           lpData,
                           NULL,
                           (RenameInfo.ReplaceIfExists ? 0 : COPY_FILE_FAIL_IF_EXISTS) |
                               COPY_FILE_OPEN_SOURCE_FOR_WRITE
                           );

            //
            // the copy worked... Delete the source of the rename
            // if it fails, try a set attributes and then a delete
            //

            if (b && !DeleteFile( lpExistingFileName ) ) {

                //
                // If the delete fails, we will return true, but possibly
                // leave the source dangling
                //

                SetFileAttributes(lpExistingFileName,FILE_ATTRIBUTE_NORMAL);
                DeleteFile( lpExistingFileName );
            }

            return b;
        }

        XapiSetLastNTError(Status);
        return FALSE;
    }
}

BOOL
APIENTRY
DeleteFile(
    PCOSTR lpFileName
    )

/*++

    Routine Description:

    An existing file can be deleted using DeleteFile.

    This API provides the same functionality as DOS (int 21h, function 41H)
    and OS/2's DosDelete.

Arguments:

    lpFileName - Supplies the file name of the file to be deleted.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    OBJECT_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_DISPOSITION_INFORMATION Disposition;

    RtlInitObjectString(&FileName, lpFileName);

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        ObDosDevicesDirectory(),
        NULL
        );

    //
    // Open the file for delete access.
    //

    Status = NtOpenFile(
                 &Handle,
                 (ACCESS_MASK)DELETE,
                 &Obja,
                 &IoStatusBlock,
                 FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_NON_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT
                 );

    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        return FALSE;
        }

    //
    // Delete the file
    //
#undef DeleteFile
    Disposition.DeleteFile = TRUE;

    Status = NtSetInformationFile(
                 Handle,
                 &IoStatusBlock,
                 &Disposition,
                 sizeof(Disposition),
                 FileDispositionInformation
                 );

    NtClose(Handle);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        XapiSetLastNTError(Status);
        return FALSE;
        }
}

BOOL
WINAPI
XSetFileCacheSize(
    SIZE_T dwCacheSize
    )
/*++

Routine Description:

    This routine changes the number of bytes allocated to the file system cache.

Arguments:

    dwCacheSize - Supplies the number of bytes that should be allocated to the
        file system cache.  The number of bytes is rounded up to a multiple of
        the page size.

Return Value:

    Status of operation.

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/
{
    NTSTATUS status;
    PFN_COUNT NumberOfCachePages;

    //
    // Carefully compute the number of cache pages if the cache size is near
    // MAXULONG.
    //

    NumberOfCachePages = dwCacheSize >> PAGE_SHIFT;

    if (BYTE_OFFSET(dwCacheSize) != 0) {
        NumberOfCachePages++;
    }

    status = FscSetCacheSize(NumberOfCachePages);

    if (NT_SUCCESS(status)) {
        return TRUE;
    } else {
        XapiSetLastNTError(status);
        return FALSE;
    }
}

SIZE_T
WINAPI
XGetFileCacheSize(
    VOID
    )
/*++

Routine Description:

    This routine returns the number of bytes allocated to the file system cache.

Arguments:

    None.

Return Value:

    Number of bytes currently allocated to the file system cache.

--*/
{
    return FscGetCacheSize() << PAGE_SHIFT;
}



NTSTATUS
XapiGetDirectoryDisplayBlocks(
        HANDLE                      DirHandle,
        DWORD                       *TotalBlocks,
        PFILE_DIRECTORY_INFORMATION DirectoryInfo
        )
/*++
  Routine Description:
    Helper function for XDisplayBlocksFromPath.  Does the recursion of directories.
--*/
{
    NTSTATUS          status;
    IO_STATUS_BLOCK   ioStatusBlock;
    BOOLEAN           fFindFirst = TRUE;
    DWORD             fileCount = 0;
    HANDLE            subdirHandle;
    OBJECT_STRING     subdirName;
    OBJECT_ATTRIBUTES objectAttributes;
    DWORD             directorySize;

    do
    {
       status = NtQueryDirectoryFile(
                        DirHandle,
                        NULL,
                        NULL,
                        NULL,
                        &ioStatusBlock,
                        DirectoryInfo,
                        sizeof(FILE_DIRECTORY_INFORMATION)+sizeof(OCHAR)*254,
                        FileDirectoryInformation,
                        NULL,
                        fFindFirst
                        );

        fFindFirst = FALSE;

        //
        // If we succesfully found a file or directory then we have work to do
        //
        if (NT_SUCCESS(status))
        {
            //
            //  The fileCount and fileNameSizes will go into 
            //  computing the blocks required by this directory.
            //

            fileCount++;
            
            //
            //  If this is a directory we will need to recurse it.
            //
            if(FILE_ATTRIBUTE_DIRECTORY&DirectoryInfo->FileAttributes)
            {
            
                //
                //  Null terminate filename
                //

                DirectoryInfo->FileName[DirectoryInfo->FileNameLength/sizeof(OCHAR)] = OBJECT_NULL;

                //
                //  Create an OBJECT_STRING for the relative path of the directory
                //

                RtlInitObjectString(&subdirName, DirectoryInfo->FileName);

                //
                //  Initialize Obja with Handle of the parent and the relative path.
                //
                InitializeObjectAttributes(
                    &objectAttributes,
                    &subdirName,
                    OBJ_CASE_INSENSITIVE,
                    DirHandle,
                    NULL
                    );

                //
                // Open the directory
                //

                status = NtOpenFile(
                            &subdirHandle,
                            FILE_LIST_DIRECTORY | SYNCHRONIZE,
                            &objectAttributes,
                            &ioStatusBlock,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                            );

                if(NT_SUCCESS(status))
                {
                    status = XapiGetDirectoryDisplayBlocks(subdirHandle, TotalBlocks, DirectoryInfo);
                    NtClose(subdirHandle);
                }
            } else
            {
                 if(DirectoryInfo->EndOfFile.HighPart)
                 {
                    *TotalBlocks = MAX_DISPLAY_BLOCKS;
                    break;
                 } else
                 {
                    DWORD fileBytes, fileBlocks;
                    fileBytes = DirectoryInfo->EndOfFile.LowPart;
                    fileBlocks = (fileBytes/0x4000) + ((fileBytes%0x4000) ? 1 : 0);
                    if(fileBlocks >= MAX_DISPLAY_BLOCKS)
                    {
                        fileBlocks = MAX_DISPLAY_BLOCKS;
                    } else
                    {
                        *TotalBlocks += fileBlocks;
                    }
                 }
            }
            if(*TotalBlocks >= MAX_DISPLAY_BLOCKS)
            {
                *TotalBlocks = MAX_DISPLAY_BLOCKS;
                break;
            }
        }
    } while(NT_SUCCESS(status));

    
    //
    //  How much space the directory itself occupies.
    //  CAVEAT: directory entries don't shrink so 
    //  this calculation could underestimate the size
    //  if many files\or subdirectoires have been deleted.
    //
    directorySize = fileCount*sizeof(DIRENT);
    *TotalBlocks += (directorySize/0x4000);
    *TotalBlocks += (directorySize%0x4000) ? 1 : 0;
    if(*TotalBlocks >= MAX_DISPLAY_BLOCKS)
    {
       *TotalBlocks = MAX_DISPLAY_BLOCKS;
    }

    //
    //  Don't fail if we just found an empty directory
    //  or got to the end of it.
    //

    if(
        (status == STATUS_NO_MORE_FILES) ||
        (status == STATUS_NO_SUCH_FILE)
    ){
        status = STATUS_SUCCESS;
    }

    return status;
}


DWORD
WINAPI
XGetDisplayBlocks(
    PCOSTR lpPathName
    )
/*++

 Routine Description:

    Given a path to a file or directory, recursively computes the number
    of display blocks (bytes on disk\16kbytes) taken up by that file or
    directory and all of its subdirectories and files.

 Arguments:

    On Success:
      

 Return Value:

    On Success: Number of Display Blocks used by the path.  If the total is greater than 50,000,
    then MAX_DISPLAY_BLOCKS is returned.

    On Failure: 0, call GetLastError() for extended error information.

--*/
{
    OBJECT_STRING                 objectName;
    OBJECT_ATTRIBUTES             objectAttributes;
    FILE_NETWORK_OPEN_INFORMATION networkInfo;
    HANDLE                        dirHandle;
    IO_STATUS_BLOCK               ioStatusBlock;
    NTSTATUS                      status;
    DWORD                         totalBlocks;


    //
    //  Open a handle to the path.
    //

    RtlInitObjectString(&objectName, lpPathName);
    InitializeObjectAttributes(&objectAttributes,
                               &objectName,
                               OBJ_CASE_INSENSITIVE,
                               ObDosDevicesDirectory(),
                               NULL
                               );

    status = NtQueryFullAttributesFile(&objectAttributes, &networkInfo);
    
    if(NT_SUCCESS(status))
    {
        if(networkInfo.FileAttributes&FILE_ATTRIBUTE_DIRECTORY)
        {
            totalBlocks = 0;
            
            status = NtOpenFile(
                &dirHandle,
                FILE_LIST_DIRECTORY | SYNCHRONIZE,
                &objectAttributes,
                &ioStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                );

             if(NT_SUCCESS(status))
             {
                struct {FILE_DIRECTORY_INFORMATION DirInfo;OCHAR Names[255];} buffer;
                PFILE_DIRECTORY_INFORMATION directoryInfo = &buffer.DirInfo;
                status = XapiGetDirectoryDisplayBlocks(dirHandle, &totalBlocks, directoryInfo);
                NtClose(dirHandle);
             }
        } else
        {
            if(networkInfo.EndOfFile.HighPart)
            {
                totalBlocks = MAX_DISPLAY_BLOCKS;
            } else
            {
                DWORD fileBytes;
                fileBytes = networkInfo.EndOfFile.LowPart;
                totalBlocks = (fileBytes/0x4000) + ((fileBytes%0x4000) ? 1 : 0);
                if(totalBlocks > MAX_DISPLAY_BLOCKS) totalBlocks = MAX_DISPLAY_BLOCKS;
            }
        }
    }

    //
    //  Set an error on failure.
    //
    if(!NT_SUCCESS(status))
    {
        XapiSetLastNTError(status);
        return 0;
    }
    
    return totalBlocks;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\findcont.c ===
#include "basedll.h"
#include "xmeta.h"
#include <xboxp.h>


BOOL
XapiFindValueInMetaFile(
    HANDLE hMetaFile,
    LPCWSTR pszTag,
    LPWSTR pszValue,
    int cchValue);

BOOL
XapiValidateAndSkipUnicodeSignature(
    HANDLE hMetaFile);

BOOL
XapiFillInContentData(
    PXCONTENT_FIND_DATA pFindContentData,
    DWORD dwFlagFilter,
    PCSTR pszRootDir,
    int cchRootDir)
{
    int nNameLen;
    int iCurIdentity;
    BOOL fRet = FALSE;
    PSTR pszEnd;

    ASSERT(pFindContentData);

    if (0 == (pFindContentData->wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
    {
        XDBGWRN("XAPI", "XFindContent: Unexpected file found in content directory");
        return FALSE;
    }

    nNameLen = strlen(pFindContentData->wfd.cFileName);

    if ((nNameLen != CONTENT_DIR_NAME_LENGTH) ||
        (CONTENT_DIR_DELIMETER != pFindContentData->wfd.cFileName[CONTENT_DIR_DELIMETER_INDEX]))
    {
        XDBGWRN("XAPI", "XFindContent: Unexpected directory found in content directory");
        return FALSE;
    }

    //
    // Temporarily replace delimiter with NULL
    //
    
    pFindContentData->wfd.cFileName[CONTENT_DIR_DELIMETER_INDEX] = '\0';

    //
    // Read the offering id and flags from the directory name
    //

    pFindContentData->dwOfferingId = strtoul(pFindContentData->wfd.cFileName, &pszEnd, 16);

    if (pszEnd != (pFindContentData->wfd.cFileName + (CCHMAX_HEX_DWORD - 1)))
    {
        XDBGWRN("XAPI", "XFindContent: Unexpected directory found in content directory");
        return FALSE;
    }
    
    pFindContentData->dwFlags = strtoul(&(pFindContentData->wfd.cFileName[CONTENT_DIR_DELIMETER_INDEX + 1]),
                                        &pszEnd,
                                        16);

    if (pszEnd != (pFindContentData->wfd.cFileName + (CONTENT_DIR_DELIMETER_INDEX + 1) + (CCHMAX_HEX_DWORD - 1)))
    {
        XDBGWRN("XAPI", "XFindContent: Unexpected directory found in content directory");
        return FALSE;
    }

    //
    // Restore the delimiter
    //
    
    pFindContentData->wfd.cFileName[CONTENT_DIR_DELIMETER_INDEX] = CONTENT_DIR_DELIMETER;

    if ((0 != dwFlagFilter) && (0 == (dwFlagFilter & pFindContentData->dwFlags)))
    {
        //
        // dwFlagFilter is set to ignore this directory, so bail out here
        //

        return FALSE;
    }

    ASSERT(cchRootDir + nNameLen < ARRAYSIZE(pFindContentData->szContentDirectory));

    strcpy(pFindContentData->szContentDirectory, pszRootDir);
    strcpy(&(pFindContentData->szContentDirectory[cchRootDir]),
           pFindContentData->wfd.cFileName);

    //
    // Append a backslash if there is room
    //

    if (cchRootDir + nNameLen < ARRAYSIZE(pFindContentData->szContentDirectory) - 1)
    {
        pFindContentData->szContentDirectory[cchRootDir + nNameLen] = '\\';
        pFindContentData->szContentDirectory[cchRootDir + nNameLen + 1] = '\0';
    }

    //
    // Attempt to open the metadata file
    //

    if (cchRootDir + nNameLen <
        (int) ARRAYSIZE(pFindContentData->szContentDirectory) - g_cchContentMetaFileName)
    {
        HANDLE hMetaFile;

        //
        // Borrow the output buffer temporarily to append the metadata filename
        //

        strcpy(&(pFindContentData->szContentDirectory[cchRootDir + nNameLen]),
               g_cszContentMetaFileName);

        hMetaFile = CreateFile(pFindContentData->szContentDirectory,
                               GENERIC_READ,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL);

        if (INVALID_HANDLE_VALUE != hMetaFile)
        {
            fRet = XapiValidateAndSkipUnicodeSignature(hMetaFile);

            if (fRet)
            {
                fRet = XapiFindValueInMetaFile(hMetaFile,
                                               g_cszNameTag,
                                               pFindContentData->szDisplayName,
                                               ARRAYSIZE(pFindContentData->szDisplayName));
            }

            CloseHandle(hMetaFile);
        }

        //
        // Restore the buffer (truncate to remove the metadata filename)
        //

        pFindContentData->szContentDirectory[cchRootDir + nNameLen + 1] = '\0';
    }

    return fRet;
}

HANDLE
WINAPI
XFindFirstContent(
    IN PCSTR lpRootPathName,
    IN DWORD dwFlagFilter,
    OUT PXCONTENT_FIND_DATA pFindContentData
    )
{
    CHAR szDirName[MAX_PATH];
    int cchRootDir;
    HANDLE hRet;

#if DBG
    if ((NULL == pFindContentData) ||
        (NULL == lpRootPathName) ||
        (OTEXT('\0') == lpRootPathName[0]) ||
        (OTEXT(':')  != lpRootPathName[1]) ||
        (OTEXT('\\') != lpRootPathName[2]) ||
        (OTEXT('\0') != lpRootPathName[3]))
    {
        RIP("XFindFirstContent() invalid parameter");
    }

    {
        //
        // Removing the 0x20 bit will make lower case characters uppercase
        //

        CHAR chDrive = lpRootPathName[0] & (~0x20);

        if ((HD_TDATA_DRIVE != chDrive) &&
            (HD_ALT_TDATA_DRIVE != chDrive))
        {
            RIP("XFindFirstContent() invalid drive letter parameter");
        }
    }
#endif // DBG

    //
    // Create <path>\$C\* in our own buffer
    //

    strcpy(szDirName, lpRootPathName);
    cchRootDir = strlen(szDirName);

    if (cchRootDir > ((int) ARRAYSIZE(szDirName) - 1 - g_cchContentSearch))
    {
        RIP("XFindFirstContent() lpRootPathName parameter too long");
    }

    strcpy(&(szDirName[cchRootDir]), g_cszContentSearch);

    hRet = FindFirstFile(szDirName, (PWIN32_FIND_DATA) pFindContentData);

    //
    // Recreate the <path>\$C without the wildcard string
    //

    ASSERT(g_cchContentDir < g_cchContentSearch);
    strcpy(szDirName, lpRootPathName);
    strcpy(&(szDirName[cchRootDir]), g_cszContentDir);
    cchRootDir += g_cchContentDir;

    if (INVALID_HANDLE_VALUE != hRet)
    {
        if (!XapiFillInContentData(pFindContentData,
                                   dwFlagFilter,
                                   szDirName,
                                   cchRootDir))
        {
            BOOL fFound;

            while (fFound = FindNextFile(hRet, (PWIN32_FIND_DATA) pFindContentData))
            {
                if (XapiFillInContentData(pFindContentData,
                                          dwFlagFilter,
                                          szDirName,
                                          cchRootDir))
                {
                    break;
                }
            }

            if (!fFound)
            {
                //
                // We didn't find a content directory
                //

                FindClose(hRet);
                hRet = INVALID_HANDLE_VALUE;
                SetLastError(ERROR_NO_MORE_FILES);
            }
        }
    }

    if (INVALID_HANDLE_VALUE != hRet)
    {
        PFINDCONTENT_HANDLE pFindContent = LocalAlloc(LMEM_FIXED, sizeof(FINDCONTENT_HANDLE));

        if (NULL != pFindContent)
        {
            pFindContent->dwSignature = FH_SIG_CONTENT;
            pFindContent->dwFlagFilter = dwFlagFilter;
            pFindContent->hFindFile = hRet;
            pFindContent->cchRootDir = cchRootDir;
            lstrcpynA(pFindContent->szRootDir, szDirName, ARRAYSIZE(pFindContent->szRootDir));
            hRet = (HANDLE) pFindContent;
        }
        else
        {
            FindClose(hRet);
            hRet = INVALID_HANDLE_VALUE;
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    return hRet;
}

BOOL
WINAPI
XFindNextContent(
    IN HANDLE hFindContent,
    OUT PXCONTENT_FIND_DATA pFindContentData
    )
{
    BOOL bRet = FALSE;

#if DBG
    if ((NULL == hFindContent) ||
        (INVALID_HANDLE_VALUE == hFindContent) ||
        (FH_SIG_CONTENT != ((PFINDCONTENT_HANDLE) hFindContent)->dwSignature) ||
        (NULL == pFindContentData))
    {
        RIP("XFindNextContent() invalid parameter");
    }
#endif // DBG

    {
        PFINDCONTENT_HANDLE pFindContent = (PFINDCONTENT_HANDLE) hFindContent;

        while (bRet = FindNextFile(pFindContent->hFindFile, (PWIN32_FIND_DATA) pFindContentData))
        {
            if (XapiFillInContentData(pFindContentData,
                                      pFindContent->dwFlagFilter,
                                      pFindContent->szRootDir,
                                      pFindContent->cchRootDir))
            {
                break;
            }
        }
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\format.c ===
/*++

Copyright (c) 2000-2002  Microsoft Corporation

Module Name:

    format.c

Abstract:

    This module implements routines to format a FAT volume.

--*/

#include "basedll.h"
#include "..\..\fatx\fat.h"

BOOL
WINAPI
XapiFormatFATVolume(
    IN POBJECT_STRING VolumePath
    )
{
    return XapiFormatFATVolumeEx(VolumePath, 16384);
}

BOOL
WINAPI
XapiFormatFATVolumeEx(
    IN POBJECT_STRING VolumePath,
    IN ULONG BytesPerCluster
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE VolumeHandle;
    DISK_GEOMETRY DiskGeometry;
    ULONG SectorShift;
    PARTITION_INFORMATION PartitionInformation;
    ULONG StructureAlignment;
    ULONG NumberOfReservedBytes;
    ULONG NumberOfClustersLimit;
    ULONG NumberOfBytesPerFat;
    BOOLEAN Fat16X;
    ULONGLONG NumberOfUnreservedBytes;
    ULONGLONG NumberOfFileAreaBytes;
    PUCHAR Buffer;
    PFAT_VOLUME_METADATA VolumeMetadata;
    LARGE_INTEGER SystemTime;
    LARGE_INTEGER ByteOffset;
    ULONG BytesRemaining;

    //
    // Open the volume for read/write access.
    //

    InitializeObjectAttributes(&ObjectAttributes, VolumePath,
        OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = NtOpenFile(&VolumeHandle, SYNCHRONIZE | FILE_READ_DATA |
        FILE_WRITE_DATA, &ObjectAttributes, &IoStatusBlock, 0,
        FILE_SYNCHRONOUS_IO_ALERT | FILE_NO_INTERMEDIATE_BUFFERING);

    if (!NT_SUCCESS(status)) {
        XapiSetLastNTError(status);
        return FALSE;
    }

    //
    // Obtain the drive geometry for the target device.
    //

    status = NtDeviceIoControlFile(VolumeHandle, NULL, NULL, NULL, &IoStatusBlock,
        IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, &DiskGeometry,
        sizeof(DiskGeometry));

    if (!NT_SUCCESS(status)) {
        NtClose(VolumeHandle);
        XapiSetLastNTError(status);
        return FALSE;
    }

    SectorShift = RtlFindFirstSetRightMember(DiskGeometry.BytesPerSector);

    //
    // Obtain the size of the partition for the target device.
    //

    status = NtDeviceIoControlFile(VolumeHandle, NULL, NULL, NULL, &IoStatusBlock,
        IOCTL_DISK_GET_PARTITION_INFO, NULL, 0, &PartitionInformation,
        sizeof(PartitionInformation));

    if (!NT_SUCCESS(status)) {
        NtClose(VolumeHandle);
        XapiSetLastNTError(status);
        return FALSE;
    }

    //
    // Compute the alignment between the various file system structures.
    // Everything should be page aligned in order to maximum file system cache
    // efficiency.
    //

    StructureAlignment = ROUND_TO_PAGES(DiskGeometry.BytesPerSector);

    if (BytesPerCluster < StructureAlignment) {
        BytesPerCluster = StructureAlignment;
    }

    //
    // Compute the number of reserved bytes for the volume.
    //
    // We only need to reserve enough space for the volume metadata block.
    //

    NumberOfReservedBytes = PAGE_SIZE;

    if (NumberOfReservedBytes < StructureAlignment) {
        NumberOfReservedBytes = StructureAlignment;
    }

    //
    // Verify that the partition has enough space to contain the reserved bytes.
    //

    if ((ULONGLONG)NumberOfReservedBytes >=
        (ULONGLONG)PartitionInformation.PartitionLength.QuadPart) {
        NtClose(VolumeHandle);
        SetLastError(ERROR_DISK_FULL);
        return FALSE;
    }

    //
    // Compute the limit of the number of clusters given the length of the
    // partition (bump up the count by two to account for the two reserved
    // entries in the FAT).  With this limit, decide whether or not we'll
    // use 16-bit or 32-bit FAT entries.
    //
    // Near the limit of the number of bytes per cluster multiplied by
    // FAT_CLUSTER16_AVAILABLE, we could end up using a bigger FAT than we
    // really need, but the math is very simple to understand.
    //

    NumberOfClustersLimit =
        (ULONG)(PartitionInformation.PartitionLength.QuadPart /
        BytesPerCluster) + FAT_RESERVED_FAT_ENTRIES;

    if (NumberOfClustersLimit < FAT_CLUSTER16_RESERVED) {
        NumberOfBytesPerFat = NumberOfClustersLimit * sizeof(USHORT);
        Fat16X = TRUE;
    } else {
        NumberOfBytesPerFat = NumberOfClustersLimit * sizeof(ULONG);
        Fat16X = FALSE;
    }

    NumberOfBytesPerFat = (NumberOfBytesPerFat + (StructureAlignment - 1)) &
        ~(StructureAlignment - 1);

    //
    // Compute the number of bytes that haven't been reserved above.
    //

    NumberOfUnreservedBytes =
        (ULONGLONG)PartitionInformation.PartitionLength.QuadPart -
        NumberOfReservedBytes;

    //
    // Verify that the partition has enough space to contain the FAT.
    //

    if ((ULONGLONG)NumberOfBytesPerFat > NumberOfUnreservedBytes) {
        NtClose(VolumeHandle);
        SetLastError(ERROR_DISK_FULL);
        return FALSE;
    }

    //
    // Verify that the partition has enough space for a single cluster to hold
    // the root directory.
    //

    NumberOfFileAreaBytes = NumberOfUnreservedBytes - NumberOfBytesPerFat;

    if (BytesPerCluster > NumberOfFileAreaBytes) {
        NtClose(VolumeHandle);
        SetLastError(ERROR_DISK_FULL);
        return FALSE;
    }

    //
    // Allocate a buffer to hold the sectors we're writing to the disk.
    //

    Buffer = (PUCHAR) LocalAlloc(LMEM_FIXED, StructureAlignment);

    if (Buffer == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        NtClose(VolumeHandle);
        XapiSetLastNTError(status);
        return FALSE;
    }

    //
    // Prepare the reserved sectors.
    //

    RtlFillMemory(Buffer, StructureAlignment, 0xFF);

    VolumeMetadata = (PFAT_VOLUME_METADATA)Buffer;

    VolumeMetadata->Signature = FAT_VOLUME_SIGNATURE;
    VolumeMetadata->SectorsPerCluster = (UCHAR)(BytesPerCluster >> SectorShift);
    VolumeMetadata->RootDirFirstCluster = 1;
    VolumeMetadata->VolumeName[0] = L'\0';

    //
    // Use the system time for the serial number.
    //

    KeQuerySystemTime(&SystemTime);
    VolumeMetadata->SerialNumber = SystemTime.LowPart;

    //
    // After this point, any failures leaves the volume in an intermediate
    // state.  Jump to DismountAndExit to force a dismount of the volume so that
    // we don't leave a file system device object in a random state.
    //

    //
    // Write out the reserved sectors.
    //

    ByteOffset.QuadPart = 0;
    BytesRemaining = NumberOfReservedBytes;

    do {

        status = NtWriteFile(VolumeHandle, NULL, NULL, NULL, &IoStatusBlock,
            Buffer, StructureAlignment, &ByteOffset);

        if (!NT_SUCCESS(status)) {
            LocalFree(Buffer);
            goto DismountAndExit;
        }

        //
        // Wipe out the reserved bytes for the second and greater passes of this
        // loop.
        //

        RtlZeroMemory(Buffer, StructureAlignment);

        //
        // Advance to the next reserved bytes page.
        //

        ByteOffset.QuadPart += StructureAlignment;
        BytesRemaining -= StructureAlignment;

    } while (BytesRemaining > 0);

    //
    // Prepare and write out the initial FAT sectors.  For the first page of FAT
    // sectors, mark the root directory's cluster as allocated and the end of
    // the file allocation table.
    //

    RtlZeroMemory(Buffer, StructureAlignment);

    ByteOffset.QuadPart = NumberOfReservedBytes;
    BytesRemaining = NumberOfBytesPerFat;

    if (Fat16X) {
        ((PUSHORT)Buffer)[0] = FAT_CLUSTER16_MEDIA;
        ((PUSHORT)Buffer)[1] = FAT_CLUSTER16_LAST;
    } else {
        ((PULONG)Buffer)[0] = FAT_CLUSTER_MEDIA;
        ((PULONG)Buffer)[1] = FAT_CLUSTER_LAST;
    }

    do {

        status = NtWriteFile(VolumeHandle, NULL, NULL, NULL, &IoStatusBlock,
            Buffer, StructureAlignment, &ByteOffset);

        if (!NT_SUCCESS(status)) {
            LocalFree(Buffer);
            goto DismountAndExit;
        }

        //
        // Wipe out the cluster values that we filled out above.
        //

        RtlZeroMemory(Buffer, sizeof(ULONG) * (FAT_RESERVED_FAT_ENTRIES + 1));

        //
        // Advance to the next FAT page.
        //

        ByteOffset.QuadPart += StructureAlignment;
        BytesRemaining -= StructureAlignment;

    } while (BytesRemaining > 0);

    //
    // Write out an empty cluster for the directory.  The byte offset is already
    // set to point at the first allocatable cluster.
    //

    RtlFillMemory(Buffer, StructureAlignment, FAT_DIRENT_NEVER_USED2);

    BytesRemaining = BytesPerCluster;

    do {

        status = NtWriteFile(VolumeHandle, NULL, NULL, NULL, &IoStatusBlock,
            Buffer, StructureAlignment, &ByteOffset);

        if (!NT_SUCCESS(status)) {
            LocalFree(Buffer);
            goto DismountAndExit;
        }

        ByteOffset.QuadPart += StructureAlignment;
        BytesRemaining -= StructureAlignment;

    } while (BytesRemaining > 0);

    LocalFree(Buffer);

    //
    // Dismount the file system so that we get a new file system the next time
    // somebody touches this volume.
    //

DismountAndExit:
    NtFsControlFile(VolumeHandle, NULL, NULL, NULL, &IoStatusBlock,
        FSCTL_DISMOUNT_VOLUME, NULL, 0, NULL, 0);

    NtClose(VolumeHandle);

    if (NT_SUCCESS(status)) {
        return TRUE;
    } else {
        XapiSetLastNTError(status);
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\fileopcr.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    fileopcr.c

Abstract:

    This module implements File open and Create APIs for Win32

Author:

    Mark Lucovsky (markl) 25-Sep-1990

Revision History:

--*/

#include "basedll.h"

#define BASE_COPY_FILE_CHUNK (64*1024)

HANDLE
WINAPI
CreateFile(
    PCOSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )

/*++

Routine Description:

    A file can be created, opened, or truncated, and a handle opened to
    access the new file using CreateFile.

    This API is used to create or open a file and obtain a handle to it
    that allows reading data, writing data, and moving the file pointer.

    This API allows the caller to specify the following creation
    dispositions:

      - Create a new file and fail if the file exists ( CREATE_NEW )

      - Create a new file and succeed if it exists ( CREATE_ALWAYS )

      - Open an existing file ( OPEN_EXISTING )

      - Open and existing file or create it if it does not exist (
        OPEN_ALWAYS )

      - Truncate and existing file ( TRUNCATE_EXISTING )

    If this call is successful, a handle is returned that has
    appropriate access to the specified file.

    If as a result of this call, a file is created,

      - The attributes of the file are determined by the value of the
        FileAttributes parameter or'd with the FILE_ATTRIBUTE_ARCHIVE bit.

      - The length of the file will be set to zero.

    This call is logically equivalent to DOS (int 21h, function 5Bh), or
    DOS (int 21h, function 3Ch) depending on the value of the
    FailIfExists parameter.

Arguments:

    lpFileName - Supplies the file name of the file to open.  Depending on
        the value of the FailIfExists parameter, this name may or may
        not already exist.

    dwDesiredAccess - Supplies the caller's desired access to the file.

        DesiredAccess Flags:

        GENERIC_READ - Read access to the file is requested.  This
            allows data to be read from the file and the file pointer to
            be modified.

        GENERIC_WRITE - Write access to the file is requested.  This
            allows data to be written to the file and the file pointer to
            be modified.

    dwShareMode - Supplies a set of flags that indicates how this file is
        to be shared with other openers of the file.  A value of zero
        for this parameter indicates no sharing of the file, or
        exclusive access to the file is to occur.

        ShareMode Flags:

        FILE_SHARE_READ - Other open operations may be performed on the
            file for read access.

        FILE_SHARE_WRITE - Other open operations may be performed on the
            file for write access.

    lpSecurityAttributes - Ignored on xbox

    dwCreationDisposition - Supplies a creation disposition that
        specifies how this call is to operate.  This parameter must be
        one of the following values.

        dwCreationDisposition Value:

        CREATE_NEW - Create a new file.  If the specified file already
            exists, then fail.  The attributes for the new file are what
            is specified in the dwFlagsAndAttributes parameter or'd with
            FILE_ATTRIBUTE_ARCHIVE.

        CREATE_ALWAYS - Always create the file.  If the file already
            exists, then it is overwritten.  The attributes for the new
            file are what is specified in the dwFlagsAndAttributes
            parameter or'd with FILE_ATTRIBUTE_ARCHIVE.

        OPEN_EXISTING - Open the file, but if it does not exist, then
            fail the call.

        OPEN_ALWAYS - Open the file if it exists.  If it does not exist,
            then create the file using the same rules as if the
            disposition were CREATE_NEW.

        TRUNCATE_EXISTING - Open the file, but if it does not exist,
            then fail the call.  Once opened, the file is truncated such
            that its size is zero bytes.  This disposition requires that
            the caller open the file with at least GENERIC_WRITE access.

    dwFlagsAndAttributes - Specifies flags and attributes for the file.
        The attributes are only used when the file is created (as
        opposed to opened or truncated).  Any combination of attribute
        flags is acceptable except that all other attribute flags
        override the normal file attribute, FILE_ATTRIBUTE_NORMAL.  The
        FILE_ATTRIBUTE_ARCHIVE flag is always implied.

        dwFlagsAndAttributes Flags:

        FILE_ATTRIBUTE_NORMAL - A normal file should be created.

        FILE_ATTRIBUTE_READONLY - A read-only file should be created.

        FILE_ATTRIBUTE_HIDDEN - A hidden file should be created.

        FILE_ATTRIBUTE_SYSTEM - A system file should be created.

        FILE_FLAG_WRITE_THROUGH - Indicates that the system should
            always write through any intermediate cache and go directly
            to the file.  The system may still cache writes, but may not
            lazily flush the writes.

        FILE_FLAG_OVERLAPPED - Indicates that the system should initialize
            the file so that ReadFile and WriteFile operations that may
            take a significant time to complete will return ERROR_IO_PENDING.
            An event will be set to the signalled state when the operation
            completes. When FILE_FLAG_OVERLAPPED is specified the system will
            not maintain the file pointer. The position to read/write from
            is passed to the system as part of the OVERLAPPED structure
            which is an optional parameter to ReadFile and WriteFile.

        FILE_FLAG_NO_BUFFERING - Indicates that the file is to be opened
            with no intermediate buffering or caching done by the
            system.  Reads and writes to the file must be done on sector
            boundries.  Buffer addresses for reads and writes must be
            aligned on at least disk sector boundries in memory.

        FILE_FLAG_RANDOM_ACCESS - Indicates that access to the file may
            be random. The system cache manager may use this to influence
            its caching strategy for this file.

        FILE_FLAG_SEQUENTIAL_SCAN - Indicates that access to the file
            may be sequential.  The system cache manager may use this to
            influence its caching strategy for this file.  The file may
            in fact be accessed randomly, but the cache manager may
            optimize its cacheing policy for sequential access.

        FILE_FLAG_DELETE_ON_CLOSE - Indicates that the file is to be
            automatically deleted when the last handle to it is closed.

        FILE_FLAG_BACKUP_SEMANTICS - Indicates that the file is being opened
            or created for the purposes of either a backup or a restore
            operation.  Thus, the system should make whatever checks are
            appropriate to ensure that the caller is able to override
            whatever security checks have been placed on the file to allow
            this to happen.

    hTemplateFile - Not supported on xbox (used for EA's)

Return Value:

    Not -1 - Returns an open handle to the specified file.  Subsequent
        access to the file is controlled by the DesiredAccess parameter.

    0xffffffff - The operation failed. Extended error status is available
        using GetLastError.

--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    OBJECT_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    ULONG CreateDisposition;
    ULONG CreateFlags;
    BOOL EndsInSlash;

#if DBG
    if ( NULL != hTemplateFile )
    {
        // xbox doesn't support this parameter because we don't support EA's
        RIP("CreateFile() - invalid parameter (hTemplateFile not supported)");
    }
#endif // DBG

    switch ( dwCreationDisposition ) {
        case CREATE_NEW        :
            CreateDisposition = FILE_CREATE;
            break;
        case CREATE_ALWAYS     :
            CreateDisposition = FILE_OVERWRITE_IF;
            break;
        case OPEN_EXISTING     :
            CreateDisposition = FILE_OPEN;
            break;
        case OPEN_ALWAYS       :
            CreateDisposition = FILE_OPEN_IF;
            break;
        case TRUNCATE_EXISTING :
            CreateDisposition = FILE_OVERWRITE;
            if ( !(dwDesiredAccess & GENERIC_WRITE) ) {
                XapiSetLastNTError(STATUS_INVALID_PARAMETER);
                return INVALID_HANDLE_VALUE;
                }
            break;
        default :
            XapiSetLastNTError(STATUS_INVALID_PARAMETER);
            return INVALID_HANDLE_VALUE;
        }

    RtlInitObjectString(&FileName,lpFileName);

    if ( FileName.Length > 1 &&
         lpFileName[(FileName.Length / sizeof(OCHAR))-1] == (OCHAR)'\\' ) {
        EndsInSlash = TRUE;
        }
    else {
        EndsInSlash = FALSE;
        }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        ObDosDevicesDirectory(),
        NULL
        );

    CreateFlags = 0;
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_NO_BUFFERING ? FILE_NO_INTERMEDIATE_BUFFERING : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_WRITE_THROUGH ? FILE_WRITE_THROUGH : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_OVERLAPPED ? 0 : FILE_SYNCHRONOUS_IO_NONALERT );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_SEQUENTIAL_SCAN ? FILE_SEQUENTIAL_ONLY : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_RANDOM_ACCESS ? FILE_RANDOM_ACCESS : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_BACKUP_SEMANTICS ? FILE_OPEN_FOR_BACKUP_INTENT : 0 );

    if ( dwFlagsAndAttributes & FILE_FLAG_DELETE_ON_CLOSE ) {
        CreateFlags |= FILE_DELETE_ON_CLOSE;
        dwDesiredAccess |= DELETE;
        }

    //
    // Backup semantics allow directories to be opened
    //

    if ( !(dwFlagsAndAttributes & FILE_FLAG_BACKUP_SEMANTICS) ) {
        CreateFlags |= FILE_NON_DIRECTORY_FILE;
        }

    Status = NtCreateFile(
                &Handle,
                (ACCESS_MASK)dwDesiredAccess | SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                &Obja,
                &IoStatusBlock,
                NULL,
                dwFlagsAndAttributes & (FILE_ATTRIBUTE_VALID_FLAGS & ~FILE_ATTRIBUTE_DIRECTORY),
                dwShareMode,
                CreateDisposition,
                CreateFlags
                );

    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        if ( Status == STATUS_OBJECT_NAME_COLLISION ) {
            SetLastError(ERROR_FILE_EXISTS);
            }
        else if ( Status == STATUS_FILE_IS_A_DIRECTORY ) {
            if ( EndsInSlash ) {
                SetLastError(ERROR_PATH_NOT_FOUND);
                }
            else {
                SetLastError(ERROR_ACCESS_DENIED);
                }
            }
        return INVALID_HANDLE_VALUE;
        }

    //
    // if NT returns supersede/overwritten, it means that a create_always, openalways
    // found an existing copy of the file. In this case ERROR_ALREADY_EXISTS is returned
    //

    if ( (dwCreationDisposition == CREATE_ALWAYS && IoStatusBlock.Information == FILE_OVERWRITTEN) ||
         (dwCreationDisposition == OPEN_ALWAYS && IoStatusBlock.Information == FILE_OPENED) ){
        SetLastError(ERROR_ALREADY_EXISTS);
        }
    else {
        SetLastError(0);
        }

    return Handle;
}

BOOL
WINAPI
CopyFile(
    PCOSTR lpExistingFileName,
    PCOSTR lpNewFileName,
    BOOL bFailIfExists
    )

/*++

Routine Description:

    A file, its extended attributes, alternate data streams, and any other
    attributes can be copied using CopyFile.

Arguments:

    lpExistingFileName - Supplies the name of an existing file that is to be
        copied.

    lpNewFileName - Supplies the name where a copy of the existing
        files data and attributes are to be stored.

    bFailIfExists - Supplies a flag that indicates how this operation is
        to proceed if the specified new file already exists.  A value of
        TRUE specifies that this call is to fail.  A value of FALSE
        causes the call to the function to succeed whether or not the
        specified new file exists.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    BOOL b;

    b = CopyFileEx(
            lpExistingFileName,
            lpNewFileName,
            (LPPROGRESS_ROUTINE)NULL,
            (LPVOID)NULL,
            (LPBOOL)NULL,
            bFailIfExists ? COPY_FILE_FAIL_IF_EXISTS : 0
            );

    return b;
}

BOOL
CopyFileEx(
    PCOSTR lpExistingFileName,
    PCOSTR lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine OPTIONAL,
    LPVOID lpData OPTIONAL,
    LPBOOL pbCancel OPTIONAL,
    DWORD dwCopyFlags
    )
/*++

Routine Description:

    A file, its extended attributes, alternate data streams, and any other
    attributes can be copied using CopyFileEx.  CopyFileEx also provides
    callbacks and cancellability.

Arguments:

    lpExistingFileName - Supplies the name of an existing file that is to be
        copied.

    lpNewFileName - Supplies the name where a copy of the existing
        files data and attributes are to be stored.

    lpProgressRoutine - Optionally supplies the address of a callback routine
        to be called as the copy operation progresses.

    lpData - Optionally supplies a context to be passed to the progress callback
        routine.

    lpCancel - Optionally supplies the address of a boolean to be set to TRUE
        if the caller would like the copy to abort.

    dwCopyFlags - Specifies flags that modify how the file is to be copied:

        COPY_FILE_FAIL_IF_EXISTS - Indicates that the copy operation should
            fail immediately if the target file already exists.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/
{
    LPVOID CopyBuffer;
    NTSTATUS status;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    OBJECT_STRING PathName;
    HANDLE SourceHandle;
    FILE_NETWORK_OPEN_INFORMATION NetworkInfo;
    HANDLE DestinationHandle;
    LARGE_INTEGER ByteOffset;
    DWORD dwProgress;
    ULONG BytesThisPass;
    FILE_BASIC_INFORMATION BasicInfo;
    FILE_END_OF_FILE_INFORMATION EndOfFileInfo;
    FILE_DISPOSITION_INFORMATION DispositionInfo;

    InitializeObjectAttributes(&ObjectAttributes,
                               &PathName,
                               OBJ_CASE_INSENSITIVE,
                               ObDosDevicesDirectory(),
                               NULL
                               );

    //
    // Allocate a buffer to copy the file stream.
    //

    CopyBuffer = MmAllocateSystemMemory(BASE_COPY_FILE_CHUNK, PAGE_READWRITE);

    if (CopyBuffer == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    //
    // Open the source file.
    //

    RtlInitObjectString(&PathName, lpExistingFileName);

    status = NtOpenFile(&SourceHandle,
                        GENERIC_READ | SYNCHRONIZE,
                        &ObjectAttributes,
                        &IoStatusBlock,
                        FILE_SHARE_READ,
                        FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE
                        );

    if (!NT_SUCCESS(status)) {
        MmFreeSystemMemory(CopyBuffer, BASE_COPY_FILE_CHUNK);
        XapiSetLastNTError(status);
        return FALSE;
    }

    //
    // Get the attributes for the source file.
    //

    status = NtQueryInformationFile(SourceHandle,
                                    &IoStatusBlock,
                                    &NetworkInfo,
                                    sizeof(NetworkInfo),
                                    FileNetworkOpenInformation
                                    );

    if (!NT_SUCCESS(status)) {
        NtClose(SourceHandle);
        MmFreeSystemMemory(CopyBuffer, BASE_COPY_FILE_CHUNK);
        XapiSetLastNTError(status);
        return FALSE;
    }

    //
    // Create the destination file.  The file is created with the attributes of
    // the source file and given an initial file allocation equal to the size of
    // the source file.
    //

    RtlInitObjectString(&PathName, lpNewFileName);

    status = NtCreateFile(&DestinationHandle,
                          GENERIC_WRITE | SYNCHRONIZE,
                          &ObjectAttributes,
                          &IoStatusBlock,
                          &NetworkInfo.EndOfFile,
                          FILE_ATTRIBUTE_NORMAL,
                          0,
                          (dwCopyFlags & COPY_FILE_FAIL_IF_EXISTS) ?
                              FILE_CREATE : FILE_OVERWRITE_IF,
                          FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE | FILE_SEQUENTIAL_ONLY
                          );

    if (!NT_SUCCESS(status)) {
        NtClose(SourceHandle);
        MmFreeSystemMemory(CopyBuffer, BASE_COPY_FILE_CHUNK);
        XapiSetLastNTError(status);
        return FALSE;
    }

    ByteOffset.QuadPart = 0;

    //
    // Invoke the callback to inform it of the start of the copy process.  Note
    // that for simplicity, we treat PROGRESS_STOP or any unknow return value as
    // PROGRESS_CANCEL.
    //

    if (lpProgressRoutine != NULL) {

        dwProgress = lpProgressRoutine(NetworkInfo.EndOfFile,
                                       ByteOffset,
                                       NetworkInfo.EndOfFile,
                                       ByteOffset,
                                       1,
                                       CALLBACK_STREAM_SWITCH,
                                       SourceHandle,
                                       DestinationHandle,
                                       lpData
                                       );

        if (dwProgress == PROGRESS_QUIET) {
            lpProgressRoutine = NULL;
        } else if (dwProgress != PROGRESS_CONTINUE) {
            status = STATUS_REQUEST_ABORTED;
            goto CancelOperation;
        }
    }

    //
    // Set the end of file for the destination file to the size of the source
    // file.
    //

    EndOfFileInfo.EndOfFile = NetworkInfo.EndOfFile;

    status = NtSetInformationFile(DestinationHandle,
                                  &IoStatusBlock,
                                  &EndOfFileInfo,
                                  sizeof(EndOfFileInfo),
                                  FileEndOfFileInformation
                                  );

    if (!NT_SUCCESS(status)) {
        goto CancelOperation;
    }

    //
    // Copy the bytes from the source file to the destination file.
    //

    while (ByteOffset.QuadPart < NetworkInfo.EndOfFile.QuadPart) {

        status = NtReadFile(SourceHandle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            CopyBuffer,
                            BASE_COPY_FILE_CHUNK,
                            &ByteOffset
                            );

        if (!NT_SUCCESS(status)) {
            break;
        }

        BytesThisPass = IoStatusBlock.Information;

        status = NtWriteFile(DestinationHandle,
                             NULL,
                             NULL,
                             NULL,
                             &IoStatusBlock,
                             CopyBuffer,
                             BytesThisPass,
                             &ByteOffset
                             );

        if (!NT_SUCCESS(status)) {
            break;
        }

        ByteOffset.QuadPart += BytesThisPass;

        //
        // Invoke the callback to inform it that another chunk has been copied.
        //

        if (lpProgressRoutine != NULL) {

            dwProgress = lpProgressRoutine(NetworkInfo.EndOfFile,
                                           ByteOffset,
                                           NetworkInfo.EndOfFile,
                                           ByteOffset,
                                           1,
                                           CALLBACK_CHUNK_FINISHED,
                                           SourceHandle,
                                           DestinationHandle,
                                           lpData
                                           );

            if (dwProgress == PROGRESS_QUIET) {
                lpProgressRoutine = NULL;
            } else if (dwProgress != PROGRESS_CONTINUE) {
                status = STATUS_REQUEST_ABORTED;
                break;
            }
        }
    }

    //
    // Apply the time stamps from the source file to the destination file.
    //

    if (NT_SUCCESS(status)) {

        BasicInfo.CreationTime = NetworkInfo.CreationTime;
        BasicInfo.LastAccessTime = NetworkInfo.LastAccessTime;
        BasicInfo.LastWriteTime = NetworkInfo.LastWriteTime;
        BasicInfo.ChangeTime = NetworkInfo.ChangeTime;
        BasicInfo.FileAttributes = NetworkInfo.FileAttributes;

        status = NtSetInformationFile(DestinationHandle,
                                      &IoStatusBlock,
                                      &BasicInfo,
                                      sizeof(BasicInfo),
                                      FileBasicInformation
                                      );
    }

    //
    // If the copy operation failed or a progress callback canceled the
    // operation, then delete the file.
    //

CancelOperation:
    MmFreeSystemMemory(CopyBuffer, BASE_COPY_FILE_CHUNK);
    NtClose(SourceHandle);

    if (!NT_SUCCESS(status)) {

#undef DeleteFile
        DispositionInfo.DeleteFile = TRUE;

        NtSetInformationFile(DestinationHandle,
                             &IoStatusBlock,
                             &DispositionInfo,
                             sizeof(DispositionInfo),
                             FileDispositionInformation
                             );

        XapiSetLastNTError(status);
        NtClose(DestinationHandle);
        return FALSE;
    }

    NtClose(DestinationHandle);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\handle.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    handle.c

Abstract:

    This module implements the Win32 handle management services.

Author:

    Mark Lucovsky (markl) 21-Sep-1990

Revision History:

--*/

#include "basedll.h"

BOOL
CloseHandle(
    HANDLE hObject
    )

/*++

Routine Description:

    An open handle to any object can be closed using CloseHandle.

    This is a generic function and operates on the following object
    types:

        - Process Object

        - Thread Object

        - Mutex Object

        - Event Object

        - Semaphore Object

        - File Object

    Please note that Module Objects are not in this list.

    Closing an open handle to an object causes the handle to become
    invalid and the HandleCount of the associated object to be
    decremented and object retention checks to be performed.  Once the
    last open handle to an object is closed, the object is removed from
    the system.

Arguments:

    hObject - An open handle to an object.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;

    Status = NtClose(hObject);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        XapiSetLastNTError(Status);
        return FALSE;
        }
}


BOOL
DuplicateHandle(
    HANDLE hSourceProcessHandle,
    HANDLE hSourceHandle,
    HANDLE hTargetProcessHandle,
    LPHANDLE lpTargetHandle,
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    DWORD dwOptions
    )

/*++

Routine Description:

    A duplicate handle can be created with the DuplicateHandle function.

    This is a generic function and operates on the following object
    types:

        - Process Object

        - Thread Object

        - Mutex Object

        - Event Object

        - Semaphore Object

        - File Object

    Please note that Module Objects are not in this list.

    This function requires PROCESS_DUP_ACCESS to both the
    SourceProcessHandle and the TargetProcessHandle.  This function is
    used to pass an object handle from one process to another.  Once
    this call is complete, the target process needs to be informed of
    the value of the target handle.  The target process can then operate
    on the object using this handle value.

Arguments:

    hSourceProcessHandle - An open handle to the process that contains the
        handle to be duplicated. The handle must have been created with
        PROCESS_DUP_HANDLE access to the process.

    hSourceHandle - An open handle to any object that is valid in the
        context of the source process.

    hTargetProcessHandle - An open handle to the process that is to
        receive the duplicated handle.  The handle must have been
        created with PROCESS_DUP_HANDLE access to the process.

    lpTargetHandle - A pointer to a variable which receives the new handle
        that points to the same object as SourceHandle does.  This
        handle value is valid in the context of the target process.

    dwDesiredAccess - The access requested to for the new handle.  This
        parameter is ignored if the DUPLICATE_SAME_ACCESS option is
        specified.

    bInheritHandle - Supplies a flag that if TRUE, marks the target
        handle as inheritable.  If this is the case, then the target
        handle will be inherited to new processes each time the target
        process creates a new process using CreateProcess.

    dwOptions - Specifies optional behaviors for the caller.

        Options Flags:

        DUPLICATE_CLOSE_SOURCE - The SourceHandle will be closed by
            this service prior to returning to the caller.  This occurs
            regardless of any error status returned.

        DUPLICATE_SAME_ACCESS - The DesiredAccess parameter is ignored
            and instead the GrantedAccess associated with SourceHandle
            is used as the DesiredAccess when creating the TargetHandle.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;

    Status = NtDuplicateObject(hSourceHandle, lpTargetHandle, dwOptions);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        XapiSetLastNTError(Status);
        return FALSE;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\kthunks.c ===
#include "basedll.h"
#include <stdio.h>


VOID
WINAPI
DebugBreak()
{
    DbgBreakPoint();
}

VOID
WINAPI
GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime)
{
    KeQuerySystemTime((PLARGE_INTEGER) lpSystemTimeAsFileTime);
}

int
WINAPIV
wsprintfW(LPWSTR lpOut, LPCWSTR lpFmt, ...)
{
    va_list arglist;
    int ret;

    va_start(arglist, lpFmt);
    ret = wvsprintfW(lpOut, lpFmt, arglist);

    va_end(arglist);
    return ret;
}

int
WINAPIV
wsprintfA(LPSTR lpOut, LPCSTR lpFmt, ...)
{
    va_list arglist;
    int ret;

    va_start(arglist, lpFmt);
    ret = wvsprintfA(lpOut, lpFmt, arglist);

    va_end(arglist);
    return ret;
}

//
// We need a wrapper for wvsprintf() (as opposed to forwarding it to NTOSKRNL)
// because the calling convention is not the same as vwsprintf()
//

int
WINAPI
wvsprintfW(
    OUT LPWSTR lpOut,
    IN LPCWSTR lpFmt,
    IN va_list arglist)
{
    return vswprintf(lpOut, lpFmt, arglist);
}

int
WINAPI
wvsprintfA(
    OUT LPSTR lpOut,
    IN LPCSTR lpFmt,
    IN va_list arglist)
{
    return vsprintf(lpOut, lpFmt, arglist);
}

ULONG
WINAPIV
DebugPrint(PCHAR Format, ...)
{
    va_list arglist;
    CHAR string[MAX_PATH];
    ULONG ret;

    va_start(arglist, Format);
    ret = _vsnprintf(string, sizeof(string), Format, arglist);
    OutputDebugStringA(string);

    va_end(arglist);
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\lcompata.c ===
#include "basedll.h"
#pragma hdrstop

#define LCOMPATA
#include "lcompat.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\launch.c ===
#include "basedll.h"
#include "xlaunch.h"
#include <xboxp.h>
#include <dm.h>
#include <idexchan.h>

static const OBJECT_STRING g_DDosDevicePrefix =  CONSTANT_OBJECT_STRING(OTEXT("\\??\\D:"));
static const CHAR g_szDVDDevicePrefix[] =        "\\Device\\Cdrom0";
static const int  g_cchDVDDevicePrefix =         ARRAYSIZE(g_szDVDDevicePrefix) - 1;

extern PLAUNCH_DATA_PAGE *LaunchDataPage;

DWORD
WINAPI
XLaunchNewImage(
    LPCSTR lpTitlePath,
    PLAUNCH_DATA pLaunchData
    )
{
    //
    // We require the path is NULL or D:\something
    //

    if ((NULL != lpTitlePath) &&
        ((('D' != lpTitlePath[0]) && ('d' != lpTitlePath[0])) ||
         (':' != lpTitlePath[1]) ||
         ('\\' != lpTitlePath[2])))
    {
        XDBGWRN("XAPI", "XLaunchNewImage() ignoring invalid lpTitlePath (%s)", lpTitlePath);
        return ERROR_INVALID_PARAMETER;
    }

    if (NULL == lpTitlePath)
    {
        //
        // NULL lpTitlePath means reboot to the dashboard - don't preserve D: drive mapping
        //

        return XWriteTitleInfoAndReboot(NULL,
                                        NULL,
                                        (NULL != pLaunchData) ? LDT_LAUNCH_DASHBOARD : LDT_NONE,
                                        XeImageHeader()->Certificate->TitleID,
                                        pLaunchData);
    }
    else
    {
        NTSTATUS Status;
        OBJECT_ATTRIBUTES Obja;
        HANDLE LinkHandle;
        OCHAR szLinkTarget[MAX_PATH * 2];
        OCHAR szDDrivePath[MAX_LAUNCH_PATH];
        OBJECT_STRING LinkTarget;
        int cch;

        szDDrivePath[0] = '\0';

        //
        // If the D: drive is mapped in some unique fashion, preserve that mapping
        // across the reboot
        //

        InitializeObjectAttributes(&Obja,
                                   (POBJECT_STRING) &g_DDosDevicePrefix,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        Status = NtOpenSymbolicLinkObject(&LinkHandle, &Obja);

        if (NT_SUCCESS(Status))
        {
            LinkTarget.Buffer = szLinkTarget;
            LinkTarget.Length = 0;
            LinkTarget.MaximumLength = sizeof(szLinkTarget);

            Status = NtQuerySymbolicLinkObject(LinkHandle, &LinkTarget, NULL);

            NtClose(LinkHandle);
        }

        if (NT_SUCCESS(Status))
        {
            lstrcpynA(szDDrivePath,
                      szLinkTarget,
                      min(ARRAYSIZE(szDDrivePath), (LinkTarget.Length / sizeof(CHAR)) + 1));
        }
        else
        {
            /* Got no path.  The D: drive should always be mapped to something, so
             * we're in trouble if we get here.  Fall back on the DVD device
             * path */
            ASSERT(FALSE);
            strcpy(szDDrivePath, g_szDVDDevicePrefix);
        }

        return XWriteTitleInfoAndReboot(&(lpTitlePath[3]),
                                        szDDrivePath,
                                        (NULL != pLaunchData) ? LDT_TITLE : LDT_NONE,
                                        XeImageHeader()->Certificate->TitleID,
                                        pLaunchData);
    }
}

NTSTATUS
WINAPI
XWriteTitleInfoNoReboot(
    PCOSTR pszLaunchPath,
    PCOSTR pszDDrivePath,
    DWORD dwLaunchDataType,
    DWORD dwTitleId,
    PLAUNCH_DATA pLaunchData
    )
/*
 *
 * This is a private function, called by the reboot API and by the
 * debugger
 *
 */
{
    LARGE_INTEGER ByteOffset;
    PSTR pszOutput;
    int cch;

    if (NULL == *LaunchDataPage)
    {
        *LaunchDataPage = MmAllocateContiguousMemory(PAGE_SIZE);
    }

    if (NULL == *LaunchDataPage)
    {
        return STATUS_NO_MEMORY;
    }

    MmPersistContiguousMemory(*LaunchDataPage, PAGE_SIZE, TRUE);

#ifndef BUILD_FOR_XBDM
    if (NULL == pszDDrivePath)
    {
        pszDDrivePath = g_szDVDDevicePrefix;
    }
#endif

    pszOutput = ((PLAUNCH_DATA_PAGE) *LaunchDataPage)->Header.szLaunchPath;

    ASSERT(PAGE_SIZE == sizeof(LAUNCH_DATA_PAGE));

    RtlZeroMemory(*LaunchDataPage, PAGE_SIZE);

    ((PLAUNCH_DATA_PAGE) *LaunchDataPage)->Header.dwLaunchDataType = dwLaunchDataType;
    ((PLAUNCH_DATA_PAGE) *LaunchDataPage)->Header.dwTitleId = dwTitleId;

    if (dwLaunchDataType != LDT_NONE)
    {
        memcpy(((PLAUNCH_DATA_PAGE) *LaunchDataPage)->LaunchData,
               pLaunchData,
               sizeof(((PLAUNCH_DATA_PAGE) *LaunchDataPage)->LaunchData));
    }

    if (NULL != pszLaunchPath)
    {
#ifdef BUILD_FOR_XBDM
        if(!pszDDrivePath)
            cch = 0;
        else
#endif
        {
        lstrcpynA(pszOutput,
                  pszDDrivePath,
                  ARRAYSIZE(((PLAUNCH_DATA_PAGE) *LaunchDataPage)->Header.szLaunchPath) - 1);
        cch = strlen(pszOutput);
        pszOutput[cch++] = TITLE_PATH_DELIMITER;
        }
        lstrcpynA(&(pszOutput[cch]),
                  pszLaunchPath,
                  ARRAYSIZE(((PLAUNCH_DATA_PAGE) *LaunchDataPage)->Header.szLaunchPath) - (cch));
    }

    return STATUS_SUCCESS;
}

DWORD
WINAPI
XWriteTitleInfoAndReboot(
    LPCSTR pszLaunchPath,
    LPCSTR pszDDrivePath,
    DWORD dwLaunchDataType,
    DWORD dwTitleId,
    PLAUNCH_DATA pLaunchData
    )
{
    NTSTATUS Status = XWriteTitleInfoNoReboot(pszLaunchPath,
                                              pszDDrivePath,
                                              dwLaunchDataType,
                                              dwTitleId,
                                              pLaunchData);

    if (NT_SUCCESS(Status))
    {
        //
        // Notify the debugger that we're about to reboot and then reboot
        //
        DmTell(DMTELL_REBOOT, NULL);

#if DBG
        if (NULL != IdexChannelObject->CurrentIrp)
        {
            XDBGERR("XAPI", "I/O still in progress when XLaunchNewImage was called!");
        }
#endif // DBG

        HalReturnToFirmware(HalQuickRebootRoutine);
    }

    return RtlNtStatusToDosError(Status);
}

DWORD
WINAPI
XGetLaunchInfo(
    OUT PDWORD pdwLaunchDataType,
    OUT PLAUNCH_DATA pLaunchData
    )
{
    RIP_ON_NOT_TRUE("XGetLaunchInfo()", (pdwLaunchDataType != NULL));
    RIP_ON_NOT_TRUE("XGetLaunchInfo()", (pLaunchData != NULL));

    if ((*LaunchDataPage) &&
        (((*LaunchDataPage)->Header.dwLaunchDataType == LDT_FROM_DASHBOARD) ||
         ((*LaunchDataPage)->Header.dwLaunchDataType == LDT_FROM_DEBUGGER_CMDLINE) ||
         ((*LaunchDataPage)->Header.dwTitleId == XeImageHeader()->Certificate->TitleID)))
    {
        PLAUNCH_DATA_PAGE pTemp;

        *pdwLaunchDataType = (*LaunchDataPage)->Header.dwLaunchDataType;
        memcpy(pLaunchData, (*LaunchDataPage)->LaunchData, sizeof(LAUNCH_DATA));

        pTemp = *LaunchDataPage;
        *LaunchDataPage = NULL;
        MmFreeContiguousMemory(pTemp);

        return ERROR_SUCCESS;
    }
    else
    {
        return ERROR_NOT_FOUND;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\lcompat.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    lcompat.c

Abstract:

    This module implements the _l and l compatability functions
    like _lread, lstrlen...

Author:

    Mark Lucovsky (markl) 13-Mar-1991

Revision History:

--*/

#include "basedll.h"
#ifdef _XBOX
#include "winnls.h"
#endif
#pragma hdrstop

#ifdef _XBOX
// Xbox-specific versions of CompareString (differ from Win32 version in that they don't need to
// have a locale specified, since the Xbox only has one locale supported).
extern int xCompareStringA(DWORD dwCmpFlags, LPCSTR psz1, int cch1, LPCSTR psz2, int cch2);
extern int xCompareStringW(DWORD dwCmpFlags, LPCTSTR psz1, int cch1, LPCTSTR psz2, int cch2);
#endif

int
APIENTRY
#ifdef LCOMPATA
lstrcmpA(
    LPCSTR lpString1,
    LPCSTR lpString2
    )
#else  // LCOMPATA
lstrcmpW(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    )
#endif // LCOMPATA
{
    int retval;

#ifdef _XBOX 	// Only one locale on the xbox
#ifdef LCOMPATA
    retval = xCompareStringA(
#else
    retval = xCompareStringW(
#endif
#else
#ifdef LCOMPATA
    retval = CompareStringA( GetThreadLocale(),
#else
    retval = CompareStringW( GetThreadLocale(),
#endif
#endif
                             0,
                             lpString1,
                             -1,
                             lpString2,
                             -1 );
#ifndef _XBOX
    if (retval == 0)
    {
        //
        // The caller is not expecting failure.  Try the system
        // default locale id.
        //
        retval = CompareStringW( GetSystemDefaultLCID(),
                                 0,
                                 lpString1,
                                 -1,
                                 lpString2,
                                 -1 );
    }
#endif
    if (retval == 0)
    {
        if (lpString1 && lpString2)
        {
            //
            // The caller is not expecting failure.  We've never had a
            // failure indicator before.  We'll do a best guess by calling
            // the C runtimes to do a non-locale sensitive compare.
            //
#ifdef LCOMPATA
            return ( strcmp(lpString1, lpString2) );
#else  // LCOMPATA
            return ( wcscmp(lpString1, lpString2) );
#endif // LCOMPATA
        }
        else if (lpString1)
        {
            return (1);
        }
        else if (lpString2)
        {
            return (-1);
        }
        else
        {
            return (0);
        }
    }

    return (retval - 2);
}

int
APIENTRY
#ifdef LCOMPATA
lstrcmpiA(
    LPCSTR lpString1,
    LPCSTR lpString2
    )
#else  // LCOMPATA
lstrcmpiW(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    )
#endif // LCOMPATA
{
    int retval;

#ifdef _XBOX	 // Only one locale on the xbox
#ifdef LCOMPATA
    retval = xCompareStringA(
#else
    retval = xCompareStringW(
#endif
#else
#ifdef LCOMPATA
    retval = CompareStringA( GetThreadLocale(),
#else
    retval = CompareStringW( GetThreadLocale(),
#endif
#endif
                             NORM_IGNORECASE,
                             lpString1,
                             -1,
                             lpString2,
                             -1 );
#ifndef _XBOX
    if (retval == 0)
    {
        //
        // The caller is not expecting failure.  Try the system
        // default locale id.
        //
        retval = CompareStringW( GetSystemDefaultLCID(),
                                 NORM_IGNORECASE,
                                 lpString1,
                                 -1,
                                 lpString2,
                                 -1 );
    }
#endif
    if (retval == 0)
    {
        if (lpString1 && lpString2)
        {
            //
            // The caller is not expecting failure.  We've never had a
            // failure indicator before.  We'll do a best guess by calling
            // the C runtimes to do a non-locale sensitive compare.
            //
#ifdef LCOMPATA
            return ( _stricmp(lpString1, lpString2) );
#else  // LCOMPATA
            return ( _wcsicmp(lpString1, lpString2) );
#endif // LCOMPATA
        }
        else if (lpString1)
        {
            return (1);
        }
        else if (lpString2)
        {
            return (-1);
        }
        else
        {
            return (0);
        }
    }

    return (retval - 2);
}


#ifdef LCOMPATA
LPSTR
APIENTRY
lstrcpyA(
    LPSTR lpString1,
    LPCSTR lpString2
    )
#else  // LCOMPATA
LPWSTR
APIENTRY
lstrcpyW(
    LPWSTR lpString1,
    LPCWSTR lpString2
    )
#endif // LCOMPATA
{
    __try {
#ifdef LCOMPATA
        return strcpy(lpString1, lpString2);
#else  // LCOMPATA
        return wcscpy(lpString1, lpString2);
#endif // LCOMPATA
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        return NULL;
    }
}

#ifdef LCOMPATA
LPSTR
APIENTRY
lstrcpynA(
    LPSTR lpString1,
    LPCSTR lpString2,
    int iMaxLength
    )
#else  // LCOMPATA
LPWSTR
APIENTRY
lstrcpynW(
    LPWSTR lpString1,
    LPCWSTR lpString2,
    int iMaxLength
    )
#endif // LCOMPATA
{
#ifdef LCOMPATA
    LPSTR src,dst;
#else  // LCOMPATA
    LPWSTR src,dst;
#endif // LCOMPATA

    __try {
#ifdef LCOMPATA
        src = (LPSTR)lpString2;
#else  // LCOMPATA
        src = (LPWSTR)lpString2;
#endif // LCOMPATA
        dst = lpString1;

        if ( iMaxLength ) {
            while(iMaxLength && *src){
                *dst++ = *src++;
                iMaxLength--;
                }
            if ( iMaxLength ) {
#ifdef LCOMPATA
                *dst = '\0';
#else  // LCOMPATA
                *dst = L'\0';
#endif // LCOMPATA
                }
            else {
                dst--;
#ifdef LCOMPATA
                *dst = '\0';
#else  // LCOMPATA
                *dst = L'\0';
#endif // LCOMPATA
                }
            }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        return NULL;
    }

    return lpString1;
}

#ifdef LCOMPATA
LPSTR
APIENTRY
lstrcatA(
    LPSTR lpString1,
    LPCSTR lpString2
    )
#else  // LCOMPATA
LPWSTR
APIENTRY
lstrcatW(
    LPWSTR lpString1,
    LPCWSTR lpString2
    )
#endif // LCOMPATA
{
    __try {
#ifdef LCOMPATA
        return strcat(lpString1, lpString2);
#else  // LCOMPATA
        return wcscat(lpString1, lpString2);
#endif // LCOMPATA
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        return NULL;
    }
}

int
APIENTRY
#ifdef LCOMPATA
lstrlenA(
    LPCSTR lpString
    )
#else  // LCOMPATA
lstrlenW(
    LPCWSTR lpString
    )
#endif // LCOMPATA
{
    if (!lpString)
        return 0;
    __try {
#ifdef LCOMPATA
        return strlen(lpString);
#else  // LCOMPATA
        return wcslen(lpString);
#endif // LCOMPATA
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        return 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\makefile.inc ===
..\lcompata.c : ..\lcompat.c

..\compstra.c : ..\compstr.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\perfctr.c ===
/*++

Copyright (c) 1990-2001  Microsoft Corporation

Module Name:

    perfctr.c

Abstract:

    This module contains the Win32 Performance Counter APIs

--*/

#include "basedll.h"

__declspec(naked)
BOOL
WINAPI
QueryPerformanceCounter(
    LARGE_INTEGER *lpPerformanceCount
    )
/*++

    QueryPerformanceCounter -   provides access to a high-resolution
                                counter; frequency of this counter
                                is supplied by QueryPerformanceFrequency

        Inputs:

            lpPerformanceCount  -   a pointer to variable which
                                    will receive the counter

        Outputs:

            lpPerformanceCount  -   the current value of the counter,
                                    or 0 if it is not available

        Returns:

            TRUE if the performance counter is supported by the
            hardware, or FALSE if the performance counter is not
            supported by the hardware.


--*/
{
    __asm {
        mov     ecx, DWORD PTR [esp+4]  // ecx = lpPerformanceCount
        rdtsc
        mov     DWORD PTR [ecx], eax
        mov     DWORD PTR [ecx+4], edx
        xor     eax, eax
        inc     eax                     // return TRUE;
        ret     4
    }
}

BOOL
WINAPI
QueryPerformanceFrequency(
    LARGE_INTEGER *lpFrequency
    )
/*++

    QueryPerformanceFrequency -   provides the frequency of the high-
                                  resolution counter returned by
                                  QueryPerformanceCounter

        Inputs:

            lpFrequency         -   a pointer to variable which
                                    will receive the frequency

        Outputs:

            lpPerformanceCount  -   the frequency of the counter,
                                    or 0 if it is not available

        Returns:

            TRUE if the performance counter is supported by the
            hardware, or FALSE if the performance counter is not
            supported by the hardware.

--*/
{
    lpFrequency->QuadPart = 733333333i64;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\nickname.c ===
#include "basedll.h"

const OBJECT_STRING NickFile = CONSTANT_OBJECT_STRING(OTEXT("\\Device\\Harddisk0\\partition1\\UDATA\\NICKNAME.XBN"));

BOOL
WINAPI
XSetNicknameW(
    IN LPCWSTR lpNickname,
    IN BOOL fPreserveCase)
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK Iosb;
    HANDLE FileHandle;
    X_NICK_DB_ENTRY Nicknames[NUM_NICK_ENTRIES];
    DWORD dwTitleID;

    RIP_ON_NOT_TRUE("XSetNicknameW()", (NULL != lpNickname));
    RIP_ON_NOT_TRUE("XSetNicknameW()", (wcslen(lpNickname) < MAX_NICKNAME));

    if (L'\0' == *lpNickname)
    {
        return FALSE;
    }

    dwTitleID = XeImageHeader()->Certificate->TitleID;

    InitializeObjectAttributes(&Obja, (POBJECT_STRING) &NickFile, OBJ_CASE_INSENSITIVE, NULL, NULL);

    //
    // Attempt to open an existing nickname file
    //

    Status = NtCreateFile(&FileHandle,
                          SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE,
                          &Obja,
                          &Iosb,
                          NULL,
                          FILE_ATTRIBUTE_SYSTEM,
                          FILE_SHARE_READ,
                          FILE_OPEN,
                          FILE_WRITE_THROUGH | FILE_SYNCHRONOUS_IO_NONALERT);

    if (NT_SUCCESS(Status))
    {
        Status = NtReadFile(FileHandle,
                            NULL,
                            NULL,
                            NULL,
                            &Iosb,
                            Nicknames,
                            sizeof(Nicknames),
                            NULL);

        if (NT_SUCCESS(Status) && (sizeof(Nicknames) != (DWORD) Iosb.Information))
        {
            //
            // We didn't read the right number of bytes, so don't do anything with this
            // data (the file will need to be recreated below)
            //
            Status = STATUS_END_OF_FILE;
        }

        if (NT_SUCCESS(Status))
        {
            WCHAR szNewNick[MAX_NICKNAME];
            int i;
            BOOL fNewEntry;

            lstrcpynW(szNewNick, lpNickname, ARRAYSIZE(szNewNick));

            //
            // Look to see if this nickname/titleid combo already exists in the table
            //

            for (i = 0; i < ARRAYSIZE(Nicknames); i++)
            {
                if ((FALSE != (fNewEntry = (L'\0' == Nicknames[i].szNickname[0]))) ||
                    ((dwTitleID == Nicknames[i].dwTitleID) &&
                        (0 == _wcsicmp(lpNickname, Nicknames[i].szNickname))))
                {
                    if (!fNewEntry && !fPreserveCase)
                    {
                        //
                        // The title didn't want us to preserve the case passed in, so
                        // use the name as it was last written instead
                        //

                        lstrcpynW(szNewNick, Nicknames[i].szNickname, ARRAYSIZE(szNewNick));
                    }
                    break;
                }
            }

            if (ARRAYSIZE(Nicknames) == i)
            {
                fNewEntry = TRUE;
            }

            if (!fNewEntry && (0 == i) && (0 == (wcscmp(szNewNick, Nicknames[0].szNickname))))
            {
                //
                // No change - the most recent nickname is exactly the same, so just close the file
                // and return TRUE without rewriting the exact same data.
                //

                NtClose(FileHandle);
                return TRUE;
            }

            if (0 != i)
            {
                //
                // Shift all of the entries further down the table to make room for this entry
                // at the top of the table
                //

                RtlMoveMemory(&(Nicknames[1]),
                              &(Nicknames[0]),
                              sizeof(X_NICK_DB_ENTRY) * min(i, ARRAYSIZE(Nicknames) - 1));
            }

            //
            // Write the new entry at the top of the table
            //

            Nicknames[0].dwTitleID = dwTitleID;
            lstrcpynW(Nicknames[0].szNickname, szNewNick, ARRAYSIZE(Nicknames[0].szNickname));
        }
        else
        {
            NtClose(FileHandle);
        }
    }
    else if (Status != STATUS_OBJECT_NAME_NOT_FOUND)
    {
        //
        // The open failed for an unexpected reason - we don't want to proceed and
        // overwrite a valid nickname file...
        //

        return FALSE;
    }

    if (!NT_SUCCESS(Status))
    {
        //
        // Attempt to create a new nickname file
        //

        Status = NtCreateFile(&FileHandle,
                              SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE,
                              &Obja,
                              &Iosb,
                              NULL,
                              FILE_ATTRIBUTE_SYSTEM,
                              FILE_SHARE_READ,
                              FILE_OVERWRITE_IF,
                              FILE_WRITE_THROUGH | FILE_SYNCHRONOUS_IO_NONALERT);

        if (NT_SUCCESS(Status))
        {
            //
            // Zero out the memory that we're going to write to the file
            //

            RtlZeroMemory(&Nicknames, sizeof(Nicknames));

            //
            // Write the new entry at the top of the table
            //

            Nicknames[0].dwTitleID = dwTitleID;
            lstrcpynW(Nicknames[0].szNickname, lpNickname, ARRAYSIZE(Nicknames[0].szNickname));
        }
    }

    if (NT_SUCCESS(Status))
    {
        //
        // We have a valid FileHandle and Nicknames array at this point.
        // It is time to write it back to disk and close the file..
        //

        LARGE_INTEGER liByteOffset;

        liByteOffset.QuadPart = 0;
        
        Status = NtWriteFile(FileHandle,
                             NULL,
                             NULL,
                             NULL,
                             &Iosb,
                             Nicknames,
                             sizeof(Nicknames),
                             &liByteOffset);

        NtClose(FileHandle);
    }

    return(NT_SUCCESS(Status));
}

BOOL
GetNextNickname(
    PFINDNICKNAME_HANDLE pFindNick,
    LPWSTR lpNickname,
    UINT uSize)
{
    DWORD dwTitleID;

    ASSERT(pFindNick && (FH_SIG_NICKNAME == pFindNick->dwSignature));

    dwTitleID = XeImageHeader()->Certificate->TitleID;

    for (; pFindNick->uCurIndex < ARRAYSIZE(pFindNick->Nicknames); (pFindNick->uCurIndex)++)
    {
        if ((L'\0' != pFindNick->Nicknames[pFindNick->uCurIndex].szNickname[0]) &&
            (wcslen(pFindNick->Nicknames[pFindNick->uCurIndex].szNickname) < uSize) &&
            (!pFindNick->fThisTitleOnly ||
             (dwTitleID == pFindNick->Nicknames[pFindNick->uCurIndex].dwTitleID)))
        {
            BOOL fPrevMatch = FALSE;
#if DBG
            //
            // Always check for previous matches in the debug build
            // (so we can validate that the nickfile doesn't have duplicates with
            // the same title id)
            //
#else  // DBG
            //
            // If we're searching all title's, we need to check for previous matches
            // so that we don't return duplicate names (the same name can appear
            // many times with a different title id each time)
            //
            if (!pFindNick->fThisTitleOnly)
#endif // DBG
            {
                UINT uCompIndex;
                for (uCompIndex = 0; uCompIndex < pFindNick->uCurIndex; uCompIndex++)
                {
                    if (0 == _wcsicmp(pFindNick->Nicknames[pFindNick->uCurIndex].szNickname,
                                      pFindNick->Nicknames[uCompIndex].szNickname))
                    {
                        fPrevMatch = TRUE;
                        break;
                    }
                }
            }

            if (pFindNick->fThisTitleOnly || !fPrevMatch)
            {
#if DBG
                if (pFindNick->fThisTitleOnly && fPrevMatch)
                {
                    XDBGERR("XAPI", "XFindNextNicknameW() found corrupt data (duplicate nicknames)");
                }
#endif // DBG
                wcscpy(lpNickname, pFindNick->Nicknames[pFindNick->uCurIndex].szNickname);
                (pFindNick->uCurIndex)++;
                return TRUE;
            }
        }
    }
    
    return FALSE;    
}

HANDLE
WINAPI
XFindFirstNicknameW(
    IN BOOL fThisTitleOnly,
    OUT LPWSTR lpNickname,
    IN UINT uSize)
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK Iosb;
    HANDLE FileHandle;
    PFINDNICKNAME_HANDLE pFindNick = NULL;
    
    RIP_ON_NOT_TRUE("XFindFirstNicknameW()", (NULL != lpNickname));

    InitializeObjectAttributes(&Obja, (POBJECT_STRING) &NickFile, OBJ_CASE_INSENSITIVE, NULL, NULL);

    //
    // Attempt to open an existing nickname file
    //
    
    Status = NtCreateFile(&FileHandle,
                          SYNCHRONIZE | GENERIC_READ,
                          &Obja,
                          &Iosb,
                          NULL,
                          FILE_ATTRIBUTE_SYSTEM,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          FILE_OPEN,
                          FILE_SYNCHRONOUS_IO_NONALERT);

    if (NT_SUCCESS(Status))
    {
        pFindNick = LocalAlloc(LMEM_FIXED, sizeof(FINDNICKNAME_HANDLE));
        
        if (pFindNick)
        {
            pFindNick->dwSignature = FH_SIG_NICKNAME;
            pFindNick->uCurIndex = 0;
            pFindNick->fThisTitleOnly = fThisTitleOnly;
            
            Status = NtReadFile(FileHandle,
                                NULL,
                                NULL,
                                NULL,
                                &Iosb,
                                pFindNick->Nicknames,
                                sizeof(pFindNick->Nicknames),
                                NULL);

            if (NT_SUCCESS(Status) && (sizeof(pFindNick->Nicknames) != (DWORD) Iosb.Information))
            {
                //
                // We didn't read the right number of bytes, so don't do anything with this
                // data (the file will need to be recreated below)
                //
                Status = STATUS_END_OF_FILE;
            }
        }
        else
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        NtClose(FileHandle);
    }

    if (NT_SUCCESS(Status))
    {
        if (!GetNextNickname(pFindNick, lpNickname, uSize))
        {
            Status = STATUS_UNSUCCESSFUL;
        }
    }

    if (!NT_SUCCESS(Status) && (NULL != pFindNick))
    {
        LocalFree(pFindNick);
        pFindNick = NULL;
    }

    return (HANDLE) (pFindNick ? pFindNick : INVALID_HANDLE_VALUE);
}

BOOL
WINAPI
XFindNextNicknameW(
    IN HANDLE hFindNickname,
    OUT LPWSTR lpNickname,
    IN UINT uSize)
{
    PFINDNICKNAME_HANDLE pFindNick = (PFINDNICKNAME_HANDLE) hFindNickname;

    RIP_ON_NOT_TRUE("XFindNextNicknameW()", (NULL != hFindNickname));
    RIP_ON_NOT_TRUE("XFindNextNicknameW()", (INVALID_HANDLE_VALUE != hFindNickname));
    RIP_ON_NOT_TRUE("XFindNextNicknameW()", (NULL != lpNickname));

#if DBG
    if (FH_SIG_NICKNAME != pFindNick->dwSignature)
    {
        RIP("XFindNextNicknameW() - invalid parameter (hFindNickname)");
    }
#endif // DBG
    
    return GetNextNickname(pFindNick, lpNickname, uSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\pathmisc.c ===
/*++

Copyright (c) 1990-2002  Microsoft Corporation

Module Name:

    pathmisc.c

Abstract:

    Win32 miscellaneous path functions

--*/

#include "basedll.h"
#include <xboxp.h>
#include <xdisk.h>
#include <xconfig.h>
#include "xmeta.h"
#include "..\..\fatx\fat.h"

static const OBJECT_STRING ZDrive      = CONSTANT_OBJECT_STRING( OTEXT("\\??\\Z:") );
static const OCHAR CacheDriveFormat[]  = OTEXT("\\Device\\Harddisk0\\Partition%d\\");
static COBJECT_STRING WDrive           = CONSTANT_OBJECT_STRING( OTEXT("\\??\\W:") );
static COBJECT_STRING XDrive           = CONSTANT_OBJECT_STRING( OTEXT("\\??\\X:") );

#ifdef XAPILIBP

extern XAPI_MU_INFO XapiMuInfo;

#else  // XAPILIBP

XAPI_MU_INFO XapiMuInfo = {0};
#if DBG
BOOL g_fMountedUtilityDrive = FALSE;
#endif // DBG

#endif // XAPILIBP

//
//  Define the FAT32 X-Box cache db sector
//

typedef struct _XBOX_CACHE_DB_SECTOR {
    ULONG SectorBeginSignature;                     // offset = 0x000   0
    ULONG Version;                                  // offset = 0x004   4
    UCHAR Data[496];                                // offset = 0x008   8
    ULONG SectorEndSignature;                       // offset = 0x1fc 508
} XBOX_CACHE_DB_SECTOR, *PXBOX_CACHE_DB_SECTOR;

#define XBOX_HD_SECTOR_SIZE                    512

#define XBOX_CACHE_DB_DATA_SIZE                (sizeof(((PXBOX_CACHE_DB_SECTOR) 0)->Data))

#define XBOX_CACHE_DB_SECTOR_BEGIN_SIGNATURE   0x97315286
#define XBOX_CACHE_DB_SECTOR_END_SIGNATURE     0xAA550000
#define XBOX_CACHE_DB_CUR_VERSION              0x00000002
#define XBOX_CACHE_DB_MAX_ENTRY_COUNT          (XBOX_CACHE_DB_DATA_SIZE / sizeof(X_CACHE_DB_ENTRY))

#ifndef XAPILIBP

WINBASEAPI
BOOL
WINAPI
GetDiskFreeSpaceEx(
    PCOSTR lpDirectoryName,
    PULARGE_INTEGER lpFreeBytesAvailableToCaller,
    PULARGE_INTEGER lpTotalNumberOfBytes,
    PULARGE_INTEGER lpTotalNumberOfFreeBytes
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    OBJECT_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_FS_SIZE_INFORMATION NormalSizeInfo;

    ULARGE_INTEGER BytesPerAllocationUnit;
    ULARGE_INTEGER FreeBytesAvailableToCaller;
    ULARGE_INTEGER TotalNumberOfBytes;

    RIP_ON_NOT_TRUE("GetDiskFreeSpaceEx()", ARGUMENT_PRESENT(lpDirectoryName));

    RtlInitObjectString(&FileName, lpDirectoryName);

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        ObDosDevicesDirectory(),
        NULL
        );

    //
    // Open the file
    //

    Status = NtOpenFile(
                &Handle,
                (ACCESS_MASK)FILE_LIST_DIRECTORY | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE | FILE_OPEN_FOR_FREE_SPACE_QUERY
                );
    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        if ( GetLastError() == ERROR_FILE_NOT_FOUND ) {
            SetLastError(ERROR_PATH_NOT_FOUND);
            }
        return FALSE;
        }

    //
    // Determine the size parameters of the volume.
    //

    Status = NtQueryVolumeInformationFile(
                Handle,
                &IoStatusBlock,
                &NormalSizeInfo,
                sizeof(NormalSizeInfo),
                FileFsSizeInformation
                );
    NtClose(Handle);
    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        return FALSE;
        }

    BytesPerAllocationUnit.QuadPart =
        NormalSizeInfo.BytesPerSector * NormalSizeInfo.SectorsPerAllocationUnit;

    FreeBytesAvailableToCaller.QuadPart =
        BytesPerAllocationUnit.QuadPart * NormalSizeInfo.AvailableAllocationUnits.QuadPart;

    TotalNumberOfBytes.QuadPart =
        BytesPerAllocationUnit.QuadPart * NormalSizeInfo.TotalAllocationUnits.QuadPart;

    if ( ARGUMENT_PRESENT(lpFreeBytesAvailableToCaller) ) {
        lpFreeBytesAvailableToCaller->QuadPart = FreeBytesAvailableToCaller.QuadPart;
        }
    if ( ARGUMENT_PRESENT(lpTotalNumberOfBytes) ) {
        lpTotalNumberOfBytes->QuadPart = TotalNumberOfBytes.QuadPart;
        }
    if ( ARGUMENT_PRESENT(lpTotalNumberOfFreeBytes) ) {
        lpTotalNumberOfFreeBytes->QuadPart = FreeBytesAvailableToCaller.QuadPart;
        }

    return TRUE;
}


BOOL
APIENTRY
GetVolumeInformation(
    PCOSTR lpRootPathName,
    POSTR lpVolumeNameBuffer,
    DWORD nVolumeNameSize,
    LPDWORD lpVolumeSerialNumber,
    LPDWORD lpMaximumComponentLength,
    LPDWORD lpFileSystemFlags,
    POSTR lpFileSystemNameBuffer,
    DWORD nFileSystemNameSize
    )

/*++

Routine Description:

    This function returns information about the file system whose root
    directory is specified.

Arguments:

    lpRootPathName - An optional parameter, that if specified, supplies
        the root directory of the file system that information is to be
        returned about.  If this parameter is not specified, then the
        root of the current directory is used.

    lpVolumeNameBuffer - An optional parameter that if specified returns
        the name of the specified volume.

    nVolumeNameSize - Supplies the length of the volume name buffer.
        This parameter is ignored if the volume name buffer is not
        supplied.

    lpVolumeSerialNumber - An optional parameter that if specified
        points to a DWORD.  The DWORD contains the 32-bit of the volume
        serial number.

    lpMaximumComponentLength - An optional parameter that if specified
        returns the maximum length of a filename component supported by
        the specified file system.  A filename component is that portion
        of a filename between pathname seperators.

    lpFileSystemFlags - An optional parameter that if specified returns
        flags associated with the specified file system.

        lpFileSystemFlags Flags:

            FS_CASE_IS_PRESERVED - Indicates that the case of file names
                is preserved when the name is placed on disk.

            FS_CASE_SENSITIVE - Indicates that the file system supports
                case sensitive file name lookup.

            FS_UNICODE_STORED_ON_DISK - Indicates that the file system
                supports unicode in file names as they appear on disk.

    lpFileSystemNameBuffer - An optional parameter that if specified returns
        the name for the specified file system (e.g. FAT, HPFS...).

    nFileSystemNameSize - Supplies the length of the file system name
        buffer.  This parameter is ignored if the file system name
        buffer is not supplied.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    OBJECT_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    PFILE_FS_ATTRIBUTE_INFORMATION AttributeInfo;
    PFILE_FS_VOLUME_INFORMATION VolumeInfo;
    ULONG AttributeInfoLength;
    ULONG VolumeInfoLength;
    BOOL rv;

    rv = FALSE;

    nVolumeNameSize *= 2;
    nFileSystemNameSize *= 2;

    RIP_ON_NOT_TRUE("GetVolumeInformation()", ARGUMENT_PRESENT(lpRootPathName));

    RtlInitObjectString(&FileName, lpRootPathName);

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        ObDosDevicesDirectory(),
        NULL
        );

    AttributeInfo = NULL;
    VolumeInfo = NULL;

    //
    // Open the file
    //

    Status = NtOpenFile(
                &Handle,
                (ACCESS_MASK)FILE_LIST_DIRECTORY | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT
                );
    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        return FALSE;
        }

    if ( ARGUMENT_PRESENT(lpVolumeNameBuffer) ||
         ARGUMENT_PRESENT(lpVolumeSerialNumber) ) {
        if ( ARGUMENT_PRESENT(lpVolumeNameBuffer) ) {
            VolumeInfoLength = sizeof(*VolumeInfo)+nVolumeNameSize;
            }
        else {
            VolumeInfoLength = sizeof(*VolumeInfo)+MAX_PATH;
            }
        VolumeInfo = RtlAllocateHeap(XapiProcessHeap, 0, VolumeInfoLength);

        if ( !VolumeInfo ) {
            NtClose(Handle);
            XapiSetLastNTError(STATUS_NO_MEMORY);
            return FALSE;
            }
        }

    if ( ARGUMENT_PRESENT(lpFileSystemNameBuffer) ||
         ARGUMENT_PRESENT(lpMaximumComponentLength) ||
         ARGUMENT_PRESENT(lpFileSystemFlags) ) {
        if ( ARGUMENT_PRESENT(lpFileSystemNameBuffer) ) {
            AttributeInfoLength = sizeof(*AttributeInfo) + nFileSystemNameSize;
            }
        else {
            AttributeInfoLength = sizeof(*AttributeInfo) + MAX_PATH;
            }
        AttributeInfo = RtlAllocateHeap(XapiProcessHeap, 0, AttributeInfoLength);
        if ( !AttributeInfo ) {
            NtClose(Handle);
            if ( VolumeInfo ) {
                RtlFreeHeap(XapiProcessHeap, 0,VolumeInfo);
                }
            XapiSetLastNTError(STATUS_NO_MEMORY);
            return FALSE;
            }
        }

    try {
        if ( VolumeInfo ) {
            Status = NtQueryVolumeInformationFile(
                        Handle,
                        &IoStatusBlock,
                        VolumeInfo,
                        VolumeInfoLength,
                        FileFsVolumeInformation
                        );
            if ( !NT_SUCCESS(Status) ) {
                XapiSetLastNTError(Status);
                rv = FALSE;
                goto finally_exit;
                }
            }

        if ( AttributeInfo ) {
            Status = NtQueryVolumeInformationFile(
                        Handle,
                        &IoStatusBlock,
                        AttributeInfo,
                        AttributeInfoLength,
                        FileFsAttributeInformation
                        );
            if ( !NT_SUCCESS(Status) ) {
                XapiSetLastNTError(Status);
                rv = FALSE;
                goto finally_exit;
                }
            }
        try {

            if ( ARGUMENT_PRESENT(lpVolumeNameBuffer) ) {
                if ( VolumeInfo->VolumeLabelLength >= nVolumeNameSize ) {
                    SetLastError(ERROR_BAD_LENGTH);
                    rv = FALSE;
                    goto finally_exit;
                    }
                else {
                    RtlMoveMemory( lpVolumeNameBuffer,
                                   VolumeInfo->VolumeLabel,
                                   VolumeInfo->VolumeLabelLength );

                    *(lpVolumeNameBuffer + (VolumeInfo->VolumeLabelLength / sizeof(OCHAR))) = OBJECT_NULL;
                    }
                }

            if ( ARGUMENT_PRESENT(lpVolumeSerialNumber) ) {
                *lpVolumeSerialNumber = VolumeInfo->VolumeSerialNumber;
                }

            if ( ARGUMENT_PRESENT(lpFileSystemNameBuffer) ) {

                if ( AttributeInfo->FileSystemNameLength >= nFileSystemNameSize ) {
                    SetLastError(ERROR_BAD_LENGTH);
                    rv = FALSE;
                    goto finally_exit;
                    }
                else {
                    RtlMoveMemory( lpFileSystemNameBuffer,
                                   AttributeInfo->FileSystemName,
                                   AttributeInfo->FileSystemNameLength );

                    *(lpFileSystemNameBuffer + (AttributeInfo->FileSystemNameLength / sizeof(OCHAR))) = OBJECT_NULL;
                    }
                }

            if ( ARGUMENT_PRESENT(lpMaximumComponentLength) ) {
                *lpMaximumComponentLength = AttributeInfo->MaximumComponentNameLength;
                }

            if ( ARGUMENT_PRESENT(lpFileSystemFlags) ) {
                *lpFileSystemFlags = AttributeInfo->FileSystemAttributes;
                }
            }
        except (EXCEPTION_EXECUTE_HANDLER) {
            XapiSetLastNTError(STATUS_ACCESS_VIOLATION);
            return FALSE;
            }
        rv = TRUE;
finally_exit:;
        }
    finally {
        NtClose(Handle);
        if ( VolumeInfo ) {
            RtlFreeHeap(XapiProcessHeap, 0,VolumeInfo);
            }
        if ( AttributeInfo ) {
            RtlFreeHeap(XapiProcessHeap, 0,AttributeInfo);
            }
        }
    return rv;
}

NTSTATUS
XapiSelectCachePartition(
    IN BOOL fAlwaysFormat,
    OUT PULONG pnCachePartition,
    OUT PBOOL pfForceFormat
    )
{
    OBJECT_ATTRIBUTES oa;
    NTSTATUS          Status;
    IO_STATUS_BLOCK   statusBlock;
    HANDLE            hVolume;
    DWORD             dwTitleId = XeImageHeader()->Certificate->TitleID;
    ULONG             CachePartitionCount;
    ULONG             nCachePartition;

    ASSERT(pnCachePartition && pfForceFormat);

    InitializeObjectAttributes(&oa,
                               (POBJECT_STRING) &XapiHardDisk,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenFile(&hVolume,
                        SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE,
                        &oa,
                        &statusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_ALERT);

    if (NT_SUCCESS(Status))
    {
        UCHAR rgbSectorBuffer[XBOX_HD_SECTOR_SIZE];
        LARGE_INTEGER byteOffset;

        //
        // Read sector 4 (XBOX_CACHE_DB_SECTOR_INDEX)
        //

        byteOffset.QuadPart = XBOX_CACHE_DB_SECTOR_INDEX * XBOX_HD_SECTOR_SIZE;

        Status = NtReadFile(hVolume,
                            0,
                            NULL,
                            NULL,
                            &statusBlock,
                            rgbSectorBuffer,
                            sizeof(rgbSectorBuffer),
                            &byteOffset);

        if (NT_SUCCESS(Status))
        {
            PXBOX_CACHE_DB_SECTOR pCacheDBSec = (PXBOX_CACHE_DB_SECTOR) rgbSectorBuffer;
            PX_CACHE_DB_ENTRY pCacheDB = (PX_CACHE_DB_ENTRY) pCacheDBSec->Data;
            ULONG i;
            ULONG iPrevDBIndex = (*HalDiskCachePartitionCount - 1);
            ULONG iNewDBIndex;

            if ((XBOX_CACHE_DB_SECTOR_BEGIN_SIGNATURE != pCacheDBSec->SectorBeginSignature) ||
                (XBOX_CACHE_DB_SECTOR_END_SIGNATURE != pCacheDBSec->SectorEndSignature) ||
                (XBOX_CACHE_DB_CUR_VERSION != pCacheDBSec->Version))
            {
                RtlZeroMemory(rgbSectorBuffer, sizeof(rgbSectorBuffer));

                pCacheDBSec->SectorBeginSignature = XBOX_CACHE_DB_SECTOR_BEGIN_SIGNATURE;
                pCacheDBSec->Version = XBOX_CACHE_DB_CUR_VERSION;
                pCacheDBSec->SectorEndSignature = XBOX_CACHE_DB_SECTOR_END_SIGNATURE;
            }

            //
            // Assume that we're going to force the partition to be formatted unless
            // we find out otherwise
            //

            *pfForceFormat = TRUE;

            //
            // Obtain the number of cache partitions from the HAL.  The HAL
            // won't boot with a drive too small to contain one cache
            // partition, but we do need to limit the cache partition count
            // to the number that we can describe in the cache partition
            // database.
            //

            CachePartitionCount = *HalDiskCachePartitionCount;

            ASSERT(CachePartitionCount > 0);

            if (CachePartitionCount > XBOX_CACHE_DB_MAX_ENTRY_COUNT)
            {
                CachePartitionCount = XBOX_CACHE_DB_MAX_ENTRY_COUNT;
            }

            nCachePartition = 0;

            //
            // Search for a cache partition already allocated by this title
            //
            
            for (i = 0; i < CachePartitionCount; i++)
            {
                if ((dwTitleId == pCacheDB[i].dwTitleId) && pCacheDB[i].fUsed)
                {
                    nCachePartition = pCacheDB[i].nCacheIndex + XDISK_FIRST_CACHE_PARTITION;
                    iPrevDBIndex = i;
                    
                    //
                    // We found an existing cache partition, there is no longer a
                    // requirement that the partition be formatted.
                    //

                    *pfForceFormat = FALSE;
                    
                    break;
                }
            }

            //
            // If that search failed, search for a cache partition that is not in use
            // using ugly n-squared algorithm (fortunately, CachePartitionCount is small)
            //
            
            if (0 == nCachePartition)
            {
                UINT j;
                for (j = 0; j < CachePartitionCount; j++)
                {
                    for (i = 0; i < CachePartitionCount; i++)
                    {
                        if ((pCacheDB[i].fUsed) && (pCacheDB[i].nCacheIndex == j))
                        {
                            break;
                        }
                    }

                    //
                    // If we made it through the loop without a match, then this
                    // cache partition (index stored in the j variable) is available
                    //
                    
                    if (i == CachePartitionCount)
                    {
                        nCachePartition = j + XDISK_FIRST_CACHE_PARTITION;
                    }
                }
            }
                
            //
            // If that search failed, grab the oldest cache partition
            //
            // The Cache DB is stored in MRU order - the first entry was the most recently
            // used and the last entry was the least recently used
            //
            
            if (0 == nCachePartition)
            {
                nCachePartition = pCacheDB[CachePartitionCount - 1].nCacheIndex + XDISK_FIRST_CACHE_PARTITION;
            }

            //
            // If the value we've chosen is too large for some reason, pull it back and give
            // it a reasonable value
            //
            
            if (nCachePartition >= CachePartitionCount + XDISK_FIRST_CACHE_PARTITION)
            {
                nCachePartition = (CachePartitionCount - 1) + XDISK_FIRST_CACHE_PARTITION;
            }

            ASSERT(nCachePartition != 0);
            *pnCachePartition = nCachePartition;

            //
            // Normally, we bump this to the top of the cache db because that is how we
            // indicate that it was most recently used.  When fAlwaysFormat is set, we
            // always put it at the end of the list because we want it to be reclaimed
            // when the next title asks for a cache partition
            //
            
            iNewDBIndex = fAlwaysFormat ? (CachePartitionCount - 1) : 0;

            if (!fAlwaysFormat && (0 != iPrevDBIndex))
            {
                //
                // Modify the cache db - slide everything down and make room for this
                // entry at the top of the list
                //

                ASSERT(iPrevDBIndex < CachePartitionCount);
                
                RtlMoveMemory(&(pCacheDB[1]),
                              &(pCacheDB[0]),
                              iPrevDBIndex * sizeof(X_CACHE_DB_ENTRY));
            }
            
            //
            // Write this entry into the new index of the cache db
            //
            // Note that if this function was called with fAlwaysFormat set to TRUE,
            // the entry will be marked with fUsed == FALSE, so that it will be chosen
            // first the next time a title needs to allocate a new partition
            //

            pCacheDB[iNewDBIndex].dwTitleId = dwTitleId;
            pCacheDB[iNewDBIndex].nCacheIndex = (nCachePartition - XDISK_FIRST_CACHE_PARTITION);
            pCacheDB[iNewDBIndex].fUsed = (!fAlwaysFormat);

            //
            // Ignore status result
            //

            NtWriteFile(hVolume,
                        0,
                        NULL,
                        NULL,
                        &statusBlock,
                        rgbSectorBuffer,
                        sizeof(rgbSectorBuffer),
                        &byteOffset);
        }

        NtClose(hVolume);
    }

    return Status;
}


BOOL
WINAPI
XMountUtilityDrive(
    BOOL fFormatClean
    )
{
    BOOL fRet = TRUE;
    BOOL fForceFormat;
    ULONG nPartition;
    NTSTATUS Status;

#if DBG
    if (g_fMountedUtilityDrive)
    {
        RIP("XMountUtilityDrive(): Utility Drive has already been mounted");
    }
#endif // DBG

    Status = XapiSelectCachePartition(fFormatClean, &nPartition, &fForceFormat);

    if (NT_SUCCESS(Status))
    {
        OCHAR szCacheDrive[MAX_PATH];
        OBJECT_STRING VolString, DriveString;
        BOOL fDoFormat = (fFormatClean || fForceFormat);
        ULONG BytesPerCluster = XeUtilityDriveClusterSize();

        _snoprintf(szCacheDrive,
                   ARRAYSIZE(szCacheDrive),
                   CacheDriveFormat,
                   nPartition);

        RtlInitObjectString(&VolString, szCacheDrive);

        //
        // The DriveString should not end in a backslash, so init from the same
        // string, but subtract a character on the Length member.
        //

        RtlInitObjectString(&DriveString, szCacheDrive);
        DriveString.Length -= sizeof(OCHAR);

        if (fDoFormat)
        {
            fRet = XapiFormatFATVolumeEx(&DriveString, BytesPerCluster);
        }

        if (fRet)
        {
            Status = XapiValidateDiskPartitionEx(&VolString, BytesPerCluster);

            if (!NT_SUCCESS(Status) && !fDoFormat)
            {
                //
                // If the validate failed for some reason and we didn't just format
                // the partition, go ahead and format it now (make the system more
                // self-healing)
                //

                if (XapiFormatFATVolumeEx(&DriveString, BytesPerCluster))
                {
                    Status = XapiValidateDiskPartitionEx(&VolString, BytesPerCluster);
                }
            }

            if (NT_SUCCESS(Status))
            {
                // Give the cache partition a drive letter
                Status = IoCreateSymbolicLink((POBJECT_STRING) &ZDrive, &DriveString);
            }

            fRet = NT_SUCCESS(Status);

            if (!fRet)
            {
                XapiSetLastNTError(Status);
            }
        }
    }
    else
    {
        fRet = FALSE;
        XapiSetLastNTError(Status);
    }

#if DBG
    if (fRet)
    {
        g_fMountedUtilityDrive = TRUE;
    }
#endif // DBG

    return fRet;
}


BOOL
WINAPI
XFormatUtilityDrive(
    VOID
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    CHAR Target[MAX_PATH];
    ULONG TargetLength;
    OBJECT_STRING ObjectTarget;
    HANDLE Handle;

#if DBG
    if (!g_fMountedUtilityDrive)
    {
        RIP("XFormatUtilityDrive(): Utility Drive has not been mounted");
    }
#endif // DBG

    InitializeObjectAttributes(&ObjectAttributes,
                               (POBJECT_STRING) &ZDrive,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = NtOpenSymbolicLinkObject(&Handle, &ObjectAttributes);

    if (!NT_SUCCESS(status))
    {
        XapiSetLastNTError(status);
        return FALSE;
    }

    ObjectTarget.Buffer = Target;
    ObjectTarget.MaximumLength = sizeof(Target);

    status = NtQuerySymbolicLinkObject(Handle, &ObjectTarget, &TargetLength);

    NtClose(Handle);

    if (!NT_SUCCESS(status))
    {
        XapiSetLastNTError(status);
        return FALSE;
    }

    return XapiFormatFATVolumeEx(&ObjectTarget, XeUtilityDriveClusterSize());
}


DWORD
WINAPI
XMountAlternateTitle(
    IN PCOSTR lpRootPath,
    IN DWORD dwAltTitleId,
    OUT POCHAR pchDrive
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    OBJECT_STRING ObjectName;
    OCHAR szDosDevice[MAX_PATH];
    OCHAR Target[MAX_PATH];
    ULONG TargetLength;
    OBJECT_STRING ObjectTarget;
    OCHAR AltTitleId[CCHMAX_HEX_DWORD];
    HANDLE Handle;
    OCHAR chDrive;
    BOOL fTData;
    PXBEIMAGE_CERTIFICATE Certificate = XeImageHeader()->Certificate;
    int i;

    RIP_ON_NOT_TRUE(XMountAlternateTitle, (lpRootPath != NULL));
    RIP_ON_NOT_TRUE(XMountAlternateTitle, (lpRootPath[0] != '\0'));
    RIP_ON_NOT_TRUE(XMountAlternateTitle, (lpRootPath[1] == ':'));
    RIP_ON_NOT_TRUE(XMountAlternateTitle, (lpRootPath[2] == '\\'));
    RIP_ON_NOT_TRUE(XMountAlternateTitle, (lpRootPath[3] == '\0'));
    RIP_ON_NOT_TRUE(XMountAlternateTitle, (pchDrive != NULL));

    //
    // Removing the 0x20 bit will make lower case characters uppercase
    //

    chDrive = lpRootPath[0] & (~0x20);
    fTData = (HD_TDATA_DRIVE == chDrive);

#if DBG
    if (((chDrive < MU_FIRST_DRIVE) || (chDrive > MU_LAST_DRIVE)) &&
        (HD_UDATA_DRIVE != chDrive) &&
        (!fTData))
    {
        RIP("XFindFirstSaveGame() invalid drive letter parameter");
    }
#endif // DBG

    for (i = 0; i < ARRAYSIZE(Certificate->AlternateTitleIDs); i++)
    {
        if (0 == Certificate->AlternateTitleIDs[i])
        {
            return ERROR_ACCESS_DENIED;
        }

        if (dwAltTitleId == Certificate->AlternateTitleIDs[i])
        {
            break;
        }
    }

    if (i >= sizeof(Certificate->AlternateTitleIDs))
    {
        return ERROR_ACCESS_DENIED;
    }

    soprintf(szDosDevice, OTEXT("\\??\\%c:"), lpRootPath[0]);

    RtlInitObjectString(&ObjectName, szDosDevice);

    InitializeObjectAttributes(&ObjectAttributes,
                               &ObjectName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = NtOpenSymbolicLinkObject(&Handle, &ObjectAttributes);

    if (!NT_SUCCESS(status))
    {
        return RtlNtStatusToDosError(status);
    }

    ObjectTarget.Buffer = Target;
    ObjectTarget.MaximumLength = sizeof(Target);

    status = NtQuerySymbolicLinkObject(Handle, &ObjectTarget, &TargetLength);

    NtClose(Handle);

    if (!NT_SUCCESS(status))
    {
        return RtlNtStatusToDosError(status);
    }

    if ((TargetLength < CCHMAX_HEX_DWORD) ||
        ('\\' != Target[TargetLength - (CCHMAX_HEX_DWORD)]))
    {
        return ERROR_INVALID_DRIVE;
    }

    //
    // Remove the existing title id from the end of the string so we can
    // reuse ObjectTarget below in XapiMapLetterToDirectory()
    //

    ObjectTarget.Length -= CCHMAX_HEX_DWORD;

    DwordToStringO(dwAltTitleId, AltTitleId);

    status = XapiMapLetterToDirectory(fTData ? &WDrive : &XDrive,
                                      (PCOBJECT_STRING) &ObjectTarget,
                                      AltTitleId,
                                      FALSE,
                                      NULL,
                                      FALSE);

    if (NT_SUCCESS(status))
    {
        *pchDrive = fTData ? HD_ALT_TDATA_DRIVE : HD_ALT_UDATA_DRIVE;

        if (!fTData && (HD_UDATA_DRIVE != chDrive))
        {
            //
            // Remember that we've mapped an alternate drive letter to this MU
            // drive so that we can unmount the alternate drive automatically
            // if the "real" MU drive is unmounted later using XUnmountMU()
            //

            ASSERT(OBJECT_NULL == XapiMuInfo.DriveWithAltDriveMapped);
            XapiMuInfo.DriveWithAltDriveMapped = chDrive;
        }
    }

    return RtlNtStatusToDosError(status);
}

DWORD
WINAPI
XUnmountAlternateTitle(
    IN OCHAR chDrive
    )
{
    NTSTATUS Status;
    OCHAR szDosDevice[MAX_PATH];
    OBJECT_STRING DosDevice;

    //
    // Removing the 0x20 bit will make lower case characters uppercase
    //

    chDrive &= (~0x20);

#if DBG
    switch (chDrive)
    {
        case HD_ALT_TDATA_DRIVE:
        case HD_ALT_UDATA_DRIVE:
            break;

        default:
            RIP("XUnmountAlternateTitle() - invalid chDrive parameter");
    }
#endif // DBG

    soprintf(szDosDevice, OTEXT("\\??\\%c:"), chDrive);

    RtlInitObjectString(&DosDevice, szDosDevice);

    //
    // BUGBUG: Do more than remove the symbolic link - we need to unmount
    // the filesystem here.
    //

    Status = IoDeleteSymbolicLink(&DosDevice);

    if ((HD_ALT_UDATA_DRIVE == chDrive) && NT_SUCCESS(Status))
    {
        XapiMuInfo.DriveWithAltDriveMapped = OBJECT_NULL;
    }

    return RtlNtStatusToDosError(Status);
}

DWORD
WINAPI
XGetDiskClusterSize(
    PCOSTR lpRootPathName
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    OBJECT_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_FS_SIZE_INFORMATION NormalSizeInfo;

    RIP_ON_NOT_TRUE("XGetDiskClusterSize()", ARGUMENT_PRESENT(lpRootPathName));

    RtlInitObjectString(&FileName, lpRootPathName);

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        ObDosDevicesDirectory(),
        NULL
        );

    //
    // Open the file
    //

    Status = NtOpenFile(
                &Handle,
                (ACCESS_MASK)FILE_LIST_DIRECTORY | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE | FILE_OPEN_FOR_FREE_SPACE_QUERY
                );
    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        if ( GetLastError() == ERROR_FILE_NOT_FOUND ) {
            SetLastError(ERROR_PATH_NOT_FOUND);
            }
        return 0;
        }

    //
    // Determine the size parameters of the volume.
    //

    Status = NtQueryVolumeInformationFile(
                Handle,
                &IoStatusBlock,
                &NormalSizeInfo,
                sizeof(NormalSizeInfo),
                FileFsSizeInformation
                );
    NtClose(Handle);
    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        return 0;
        }

    ASSERT((0 != NormalSizeInfo.BytesPerSector) && (0 != NormalSizeInfo.SectorsPerAllocationUnit));

    return (ULONG) (NormalSizeInfo.BytesPerSector * NormalSizeInfo.SectorsPerAllocationUnit);
}

DWORD
WINAPI
XGetDiskSectorSize(
    PCOSTR lpRootPathName
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    OBJECT_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_FS_SIZE_INFORMATION NormalSizeInfo;

    RIP_ON_NOT_TRUE("XGetDiskSectorSize()", ARGUMENT_PRESENT(lpRootPathName));

    RtlInitObjectString(&FileName, lpRootPathName);

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        ObDosDevicesDirectory(),
        NULL
        );

    //
    // Open the file
    //

    Status = NtOpenFile(
                &Handle,
                (ACCESS_MASK)FILE_LIST_DIRECTORY | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE | FILE_OPEN_FOR_FREE_SPACE_QUERY
                );
    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        if ( GetLastError() == ERROR_FILE_NOT_FOUND ) {
            SetLastError(ERROR_PATH_NOT_FOUND);
            }
        return 0;
        }

    //
    // Determine the size parameters of the volume.
    //

    Status = NtQueryVolumeInformationFile(
                Handle,
                &IoStatusBlock,
                &NormalSizeInfo,
                sizeof(NormalSizeInfo),
                FileFsSizeInformation
                );
    NtClose(Handle);
    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        return 0;
        }

    ASSERT(0 != NormalSizeInfo.BytesPerSector);

    return NormalSizeInfo.BytesPerSector;
}


DWORD
WINAPI
XMUNameFromDriveLetter(
    IN CHAR chDrive,
    OUT LPWSTR lpName,
    IN UINT cchName
    )
{
    NTSTATUS Status;
    OCHAR szDosDevice[8];
    OBJECT_STRING DosDevice;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    IO_STATUS_BLOCK IoStatusBlock;
    FSCTL_VOLUME_METADATA VolumeMetadata;
    WCHAR VolumeName[FAT_VOLUME_NAME_LENGTH];

    //
    // Fail if the device is not already mounted.
    //
    if (!MU_IS_MOUNTED(chDrive))
    {
        XDBGERR("XAPI", "XMUNameFromDriveLetter() MU %c: is not mounted", chDrive);
        return ERROR_INVALID_DRIVE;
    }

    //
    // Open a handle to the volume or directory of the drive.
    //
    soprintf(szDosDevice, OTEXT("\\??\\%c:"), chDrive);
    RtlInitObjectString(&DosDevice, szDosDevice);

    InitializeObjectAttributes(
        &Obja,
        (POBJECT_STRING) &DosDevice,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenFile(&Handle,
                        SYNCHRONIZE | GENERIC_READ,
                        &Obja,
                        &IoStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        FILE_SYNCHRONOUS_IO_ALERT);

    if (NT_SUCCESS(Status))
    {
        VolumeMetadata.ByteOffset = FIELD_OFFSET(FAT_VOLUME_METADATA, VolumeName);
        VolumeMetadata.TransferLength = sizeof(VolumeName);
        VolumeMetadata.TransferBuffer = VolumeName;

        Status = NtFsControlFile(Handle,
                                 NULL,
                                 NULL,
                                 NULL,
                                 &IoStatusBlock,
                                 FSCTL_READ_VOLUME_METADATA,
                                 &VolumeMetadata,
                                 sizeof(VolumeMetadata),
                                 NULL,
                                 0);

        if (NT_SUCCESS(Status))
        {
            lstrcpynW(lpName, VolumeName, min(cchName, FAT_VOLUME_NAME_LENGTH));
        }

        NtClose(Handle);
    }

    return RtlNtStatusToDosError(Status);
}

#endif // ! XAPILIBP

#ifdef XAPILIBP

VOID
XapiDeleteCachePartition(
    IN DWORD dwTitleId
    )
{
    OBJECT_ATTRIBUTES oa;
    NTSTATUS          Status;
    IO_STATUS_BLOCK   statusBlock;
    HANDLE            hVolume;
    ULONG             CachePartitionCount;

    InitializeObjectAttributes(&oa,
                               (POBJECT_STRING) &XapiHardDisk,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenFile(&hVolume,
                        SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE,
                        &oa,
                        &statusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_ALERT);

    if (NT_SUCCESS(Status))
    {
        UCHAR rgbSectorBuffer[XBOX_HD_SECTOR_SIZE];
        LARGE_INTEGER byteOffset;

        //
        // Read sector 4 (XBOX_CACHE_DB_SECTOR_INDEX)
        //

        byteOffset.QuadPart = XBOX_CACHE_DB_SECTOR_INDEX * XBOX_HD_SECTOR_SIZE;

        Status = NtReadFile(hVolume,
                            0,
                            NULL,
                            NULL,
                            &statusBlock,
                            rgbSectorBuffer,
                            sizeof(rgbSectorBuffer),
                            &byteOffset);

        if (NT_SUCCESS(Status))
        {
            PXBOX_CACHE_DB_SECTOR pCacheDBSec = (PXBOX_CACHE_DB_SECTOR) rgbSectorBuffer;
            PX_CACHE_DB_ENTRY pCacheDB = (PX_CACHE_DB_ENTRY) pCacheDBSec->Data;
            ULONG i;

            if ((XBOX_CACHE_DB_SECTOR_BEGIN_SIGNATURE != pCacheDBSec->SectorBeginSignature) ||
                (XBOX_CACHE_DB_SECTOR_END_SIGNATURE != pCacheDBSec->SectorEndSignature) ||
                (XBOX_CACHE_DB_CUR_VERSION != pCacheDBSec->Version))
            {
                NtClose(hVolume);

                return;
            }

            //
            // Obtain the number of cache partitions from the HAL.  The HAL
            // won't boot with a drive too small to contain one cache
            // partition, but we do need to limit the cache partition count
            // to the number that we can describe in the cache partition
            // database.
            //

            CachePartitionCount = *HalDiskCachePartitionCount;

            ASSERT(CachePartitionCount > 0);

            if (CachePartitionCount > XBOX_CACHE_DB_MAX_ENTRY_COUNT)
            {
                CachePartitionCount = XBOX_CACHE_DB_MAX_ENTRY_COUNT;
            }

            //
            // Search the cache partition database for a matching title ID
            // If found, clear the title ID so we can write it back to the sector
            //

            for (i = 0; i < CachePartitionCount; i++)
            {
                if (dwTitleId == pCacheDB[i].dwTitleId)
                {
                    pCacheDB[i].dwTitleId = 0;
                    pCacheDB[i].fUsed = FALSE;

                    break;
                }
            }

            //
            // If we picked this partition because it is the oldest and not because
            // we matched a TitleId, then we must format the cache partition before
            // giving it to the title
            //

            //
            // Write back into the cache db
            //

            //
            // Ignore status result
            //

            Status = NtWriteFile(hVolume,
                                 0,
                                 NULL,
                                 NULL,
                                 &statusBlock,
                                 rgbSectorBuffer,
                                 sizeof(rgbSectorBuffer),
                                 &byteOffset);
        }

        NtClose(hVolume);
    }
}


NTSTATUS
XapiGetCachePartitions(
    IN PX_CACHE_DB_ENTRY pCacheEntriesBuffer,
    IN UINT cbBufferSize,
    OUT PDWORD pdwNumCacheEntries )
{
    OBJECT_ATTRIBUTES oa;
    NTSTATUS          Status;
    IO_STATUS_BLOCK   statusBlock;
    HANDLE            hVolume;
    ULONG             CachePartitionCount;

    ASSERT(pdwNumCacheEntries);

    //
    // Set the number of entries written to 0, in case of failure
    //

    *pdwNumCacheEntries = 0;

    InitializeObjectAttributes(&oa,
                               (POBJECT_STRING) &XapiHardDisk,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenFile(&hVolume,
                        SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE,
                        &oa,
                        &statusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_ALERT);

    if (NT_SUCCESS(Status))
    {
        UCHAR rgbSectorBuffer[XBOX_HD_SECTOR_SIZE];
        LARGE_INTEGER byteOffset;

        //
        // Read sector 4 (XBOX_CACHE_DB_SECTOR_INDEX)
        //

        byteOffset.QuadPart = XBOX_CACHE_DB_SECTOR_INDEX * XBOX_HD_SECTOR_SIZE;

        Status = NtReadFile(hVolume,
                            0,
                            NULL,
                            NULL,
                            &statusBlock,
                            rgbSectorBuffer,
                            sizeof(rgbSectorBuffer),
                            &byteOffset);

        if (NT_SUCCESS(Status))
        {
            PXBOX_CACHE_DB_SECTOR pCacheDBSec = (PXBOX_CACHE_DB_SECTOR) rgbSectorBuffer;
            PX_CACHE_DB_ENTRY pCacheDB = (PX_CACHE_DB_ENTRY) pCacheDBSec->Data;
            ULONG i;

            if ((XBOX_CACHE_DB_SECTOR_BEGIN_SIGNATURE != pCacheDBSec->SectorBeginSignature) ||
                (XBOX_CACHE_DB_SECTOR_END_SIGNATURE != pCacheDBSec->SectorEndSignature) ||
                (XBOX_CACHE_DB_CUR_VERSION != pCacheDBSec->Version))
            {
                RtlZeroMemory(rgbSectorBuffer, sizeof(rgbSectorBuffer));
            }

            //
            // Obtain the number of cache partitions from the HAL.  The HAL
            // won't boot with a drive too small to contain one cache
            // partition, but we do need to limit the cache partition count
            // to the number that we can describe in the cache partition
            // database.
            //

            CachePartitionCount = *HalDiskCachePartitionCount;

            ASSERT(CachePartitionCount > 0);

            if (CachePartitionCount > XBOX_CACHE_DB_MAX_ENTRY_COUNT)
            {
                CachePartitionCount = XBOX_CACHE_DB_MAX_ENTRY_COUNT;
            }

            //
            // Search the cache partition database for a matching title ID
            //

            for (i = 0; i < CachePartitionCount; i++)
            {
                if( 0 != pCacheDB[i].dwTitleId )
                {
                    if( ( pCacheEntriesBuffer != NULL ) && ( ( sizeof( X_CACHE_DB_ENTRY ) * (*pdwNumCacheEntries + 1) ) <= cbBufferSize ) )
                    {
                        RtlCopyMemory(&(pCacheEntriesBuffer[*pdwNumCacheEntries]),
                                      &(pCacheDB[i]),
                                      sizeof(X_CACHE_DB_ENTRY));
                    }

                    *pdwNumCacheEntries += 1;
                }
            }
        }

        NtClose(hVolume);
    }

    return Status;
}


DWORD
WINAPI
XMUWriteNameToDriveLetter(
    IN CHAR chDrive,
    IN LPCWSTR lpName
    )
{
    NTSTATUS Status;
    OCHAR szDosDevice[8];
    OBJECT_STRING DosDevice;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    IO_STATUS_BLOCK IoStatusBlock;
    FSCTL_VOLUME_METADATA VolumeMetadata;
    WCHAR VolumeName[FAT_VOLUME_NAME_LENGTH];

    //
    //  Fail if the device is not already mounted.
    //
    if (!MU_IS_MOUNTED(chDrive))
    {
        XDBGERR("XAPI", "XMUNameFromDriveLetter() MU %c: is not mounted", chDrive);
        return ERROR_INVALID_DRIVE;
    }

    ASSERT(wcslen(lpName) < MAX_MUNAME);

    //
    // Open a handle to the volume or directory of the drive.
    //
    soprintf(szDosDevice, OTEXT("\\??\\%c:"), chDrive);
    RtlInitObjectString(&DosDevice, szDosDevice);

    InitializeObjectAttributes(
        &Obja,
        (POBJECT_STRING) &DosDevice,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenFile(&Handle,
                        SYNCHRONIZE | GENERIC_WRITE,
                        &Obja,
                        &IoStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        FILE_SYNCHRONOUS_IO_ALERT);

    if (NT_SUCCESS(Status))
    {
        lstrcpynW(VolumeName, lpName, FAT_VOLUME_NAME_LENGTH);

        VolumeMetadata.ByteOffset = FIELD_OFFSET(FAT_VOLUME_METADATA, VolumeName);
        VolumeMetadata.TransferLength = sizeof(VolumeName);
        VolumeMetadata.TransferBuffer = VolumeName;

        Status = NtFsControlFile(Handle,
                                 NULL,
                                 NULL,
                                 NULL,
                                 &IoStatusBlock,
                                 FSCTL_WRITE_VOLUME_METADATA,
                                 &VolumeMetadata,
                                 sizeof(VolumeMetadata),
                                 NULL,
                                 0);

        NtClose(Handle);
    }

    return RtlNtStatusToDosError(Status);
}

#endif // XAPILIBP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\mountmu.c ===
/*++

Copyright (c) 2001-2002  Microsoft Corporation

Module Name:

    mountmu.c

Abstract:

    This module implements the XTL memory unit services.

--*/

#include "basedll.h"
#include <usbxapi.h>
#include <xboxp.h>
#include "..\..\fatx\fat.h"

#ifdef XAPILIBP

extern CRITICAL_SECTION XapiMountMUCriticalSection;

#ifdef DBG
extern ULONG g_XapiCurrentUserDevices;
#endif

#else  // XAPILIBP

INITIALIZED_CRITICAL_SECTION(XapiMountMUCriticalSection);

#ifdef DBG
ULONG g_XapiCurrentUserDevices = 0;
#endif

#endif // XAPILIBP

#ifndef XAPILIBP

DWORD
WINAPI
XMountMU(
    IN DWORD dwPort,
    IN DWORD dwSlot,
    OUT POCHAR pchDrive
    )
{
    NTSTATUS Status;
    OCHAR szTitleId[CCHMAX_HEX_DWORD];
    OCHAR szDeviceName[64];
    OCHAR szDosDevice[64];
    OCHAR chDrive;
    OBJECT_STRING DeviceName, DosDevice;

    RIP_ON_NOT_TRUE_WITH_MESSAGE(XPP_XInitDevicesHasBeenCalled, "XMountMU: XInitDevices must be called first!");

    if (NULL != pchDrive)
    {
        *pchDrive = OBJECT_NULL;
    }
    
    EnterCriticalSection(&XapiMountMUCriticalSection);

#if DBG
    if ((dwPort < MU_PORT_MIN) || (dwPort > MU_PORT_MAX))
    {
        RIP("XMountMU() invalid parameter (dwPort)");
    }

    if ((dwSlot < MU_SLOT_MIN) || (dwSlot > MU_SLOT_MAX))
    {
        RIP("XMountMU() invalid parameter (dwSlot)");
    }
    
    if(MU_MaxUserDevices <= g_XapiCurrentUserDevices)
    {
        RIP("XMountMU() more devices than specified in XInitDevices");
    }
#endif // DBG

    //
    //  Make sure that the device is not already mounted.
    //  (if it is, we sort of fail)
    chDrive = MU_DRIVE_LETTER_FROM_PORT_SLOT(dwPort, dwSlot);
    if(MU_IS_MOUNTED(chDrive))
    {
        RIP("XMountMU() MU already mounted.");
        *pchDrive = chDrive;
        LeaveCriticalSection(&XapiMountMUCriticalSection);
        return ERROR_ALREADY_ASSIGNED;
    }

    //
    // Setup the string buffer
    //
    DeviceName.Length = 0;
    DeviceName.MaximumLength = sizeof(szDeviceName)/sizeof(OCHAR)-1;
    DeviceName.Buffer = szDeviceName;

    //
    //  create the device object
    //
    Status = MU_CreateDeviceObject(
                dwPort,
                dwSlot,
                &DeviceName
                );

    if(NT_SUCCESS(Status))
    {
        soprintf(szDosDevice,
                 OTEXT("\\??\\%c:"),
                 chDrive);

        RtlInitObjectString(&DosDevice, szDosDevice);

        DwordToStringO(XeImageHeader()->Certificate->TitleID, szTitleId);

        //
        //  Tack on a '\\' to the end.  This way we are passing the MU's root directory,
        //  rather than the raw volume.  This is important to prevent the raw file system
        //  from mounting by mistake on a corrupt or unformatted MU.  The main evil of
        //  mounting the raw file system is that the error codes coming will be really
        //  strange.
        //
        ASSERT(DeviceName.Length+sizeof(OCHAR)<=DeviceName.MaximumLength);
        DeviceName.Buffer[DeviceName.Length++ / sizeof(OCHAR)] = OTEXT('\\');

        Status = XapiMapLetterToDirectory((PCOBJECT_STRING)&DosDevice,
                                          (PCOBJECT_STRING)&DeviceName,
                                          szTitleId,
                                          TRUE,
                                          XeImageHeader()->Certificate->TitleName,
                                          FALSE);

        if (NT_SUCCESS(Status))
        {
            if (NULL != pchDrive)
            {
                *pchDrive = chDrive;
            }
            MU_SET_MOUNTED(chDrive);
            #if DBG
            g_XapiCurrentUserDevices++;
            #endif
        }
        else
        {
            // Dismount the volume if necessary.
            IoDismountVolumeByName(&DeviceName);

            // We must assume that either a handle was successfully opened and
            // the filesystem was dismounted, or that it never managed to mount.
            // If not, then the following step breaks all further attempts to
            // mount MU's, but things were probably pretty well broken before
            // this anyway.
            MU_CloseDeviceObject(dwPort, dwSlot);
        }
    }
		
    LeaveCriticalSection(&XapiMountMUCriticalSection);

    return RtlNtStatusToDosError(Status);
}


DWORD
WINAPI
XMountMURoot(
    IN DWORD dwPort,
    IN DWORD dwSlot,
    OUT POCHAR pchDrive
    )
{
    NTSTATUS Status;
    OCHAR szDeviceName[64];
    OCHAR szDosDevice[64];
    OCHAR chDrive;
    OBJECT_STRING DeviceName, DosDevice;
    OBJECT_ATTRIBUTES Obja;
    HANDLE DirHandle;
    IO_STATUS_BLOCK IoStatusBlock;

    //
    // Fill out the MU type so that XAPI can
    // find it without explicitly referencing it.
    // This way the MU driver is not sucked in
    // by XAPI unless the MU is used.
    //

    if (NULL != pchDrive)
    {
        *pchDrive = OBJECT_NULL;
    }

    EnterCriticalSection(&XapiMountMUCriticalSection);
    
#if DBG
    if ((dwPort < MU_PORT_MIN) || (dwPort > MU_PORT_MAX))
    {
        RIP("XMountMURoot() invalid parameter (dwPort)");
    }

    if ((dwSlot < MU_SLOT_MIN) || (dwSlot > MU_SLOT_MAX))
    {
        RIP("XMountMURoot() invalid parameter (dwSlot)");
    }
    if(MU_MaxUserDevices <= g_XapiCurrentUserDevices)
    {
        RIP("XMountMU() more devices than specified in XInitDevices");
    }
#endif // DBG

    //
    //  Make sure that the device is not already mounted.
    //  (if it is, we sort of fail)
    chDrive = MU_DRIVE_LETTER_FROM_PORT_SLOT(dwPort, dwSlot);
    if(MU_IS_MOUNTED(chDrive))
    {
        RIP("XMountMU() MU already mounted.");
        *pchDrive = chDrive;
        LeaveCriticalSection(&XapiMountMUCriticalSection);
        return ERROR_ALREADY_ASSIGNED;
    }

    //
    // Setup the string buffer
    //
    DeviceName.Length = 0;
    //lie - so we have guaranteed space for a back slash (lie leave room for NULL, and a '\\')
    DeviceName.MaximumLength = sizeof(szDeviceName)/sizeof(OCHAR)-2;
    DeviceName.Buffer = szDeviceName;

    //
    //  create the device object
    //
    Status = MU_CreateDeviceObject(
                dwPort,
                dwSlot,
                &DeviceName
                );

    if(NT_SUCCESS(Status))
    {
        //We previously lied about the maximum length to guarantee room for a backslash
        //undo that lie.
        DeviceName.MaximumLength++;

        //Add a back slash to the name returned from MU_CreateDeviceObject
        szDeviceName[DeviceName.Length++] = OTEXT('\\');
        szDeviceName[DeviceName.Length] = OTEXT('\0');

        //Attempt to open the root directory (this effectively mounts the drive).
        InitializeObjectAttributes(
            &Obja,
            (POBJECT_STRING)&DeviceName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

        Status = NtCreateFile(
                    &DirHandle,
                    FILE_LIST_DIRECTORY | SYNCHRONIZE,
                    &Obja,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_OPEN_IF,
                    FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                    );

        //Whack the backslash off the device name
        szDeviceName[--DeviceName.Length] = OTEXT('\0');

        //If we succeeded in opening the root directory we can
        //create the symbolic link, etc.
        if (NT_SUCCESS(Status))
        {
            NtClose(DirHandle);  //Close the handle, we no longer need it

            soprintf(szDosDevice,
                 OTEXT("\\??\\%c:"),
                 chDrive);
            RtlInitObjectString(&DosDevice, szDosDevice);

            Status = IoCreateSymbolicLink(&DosDevice, &DeviceName);
            if(NT_ERROR(Status))
            {
                XDBGWRN("XAPI", "XMountMURoot() - IoCreateSymbolicLink failed with 0x%0.8x", Status);
            }
        }

        if (NT_SUCCESS(Status))
        {
            if (NULL != pchDrive)
            {
                *pchDrive = chDrive;
            }
            MU_SET_MOUNTED(chDrive);
	        #if DBG
            g_XapiCurrentUserDevices++;
            #endif
        } else
        //
        //  Failed to open the root or to create a symbolic link.  This does not mean a filesystem
        //  didn't mount, just in case we must force a dismount.
        {
            IoDismountVolumeByName(&DeviceName);

            //We must assume that either a handle was successfully opened and the filesystem was dismounted, or
            //that it never managed to mount.  If not, then the following step breaks all further attempts to
            //mount MU's, but things were probably pretty well broken before this anyway.
            MU_CloseDeviceObject(dwPort, dwSlot);
        }
    }

    LeaveCriticalSection(&XapiMountMUCriticalSection);

    return RtlNtStatusToDosError(Status);
}


DWORD
WINAPI
XUnmountMU(
    IN DWORD dwPort,
    IN DWORD dwSlot
    )
{
    NTSTATUS Status;
    OCHAR szDosDevice[64];
    OBJECT_STRING DosDevice;
    OBJECT_ATTRIBUTES Obja;
    HANDLE VolHandle;
    IO_STATUS_BLOCK IoStatusBlock;
    OCHAR chDrive = MU_DRIVE_LETTER_FROM_PORT_SLOT(dwPort, dwSlot);

#if DBG
    if ((dwPort < MU_PORT_MIN) || (dwPort > MU_PORT_MAX))
    {
        RIP("XUnmountMU() invalid parameter (dwPort)");
    }

    if ((dwSlot < MU_SLOT_MIN) || (dwSlot > MU_SLOT_MAX))
    {
        RIP("XUnmountMU() invalid parameter (dwSlot)");
    }
#endif // DBG

    EnterCriticalSection(&XapiMountMUCriticalSection);

    //
    //  Fail if the device is not already mounted.
    //
    if(!MU_IS_MOUNTED(chDrive))
    {
        RIP("XUnmountMU() MU not mounted.");
        LeaveCriticalSection(&XapiMountMUCriticalSection);
        return ERROR_INVALID_DRIVE;
    }

    //
    //  Unmount an alternate drive if it is mapped.
    //
    if (XapiMuInfo.DriveWithAltDriveMapped == chDrive)
    {
        //
        // An alternate drive is mapped to this MU drive, so let's auto dismount it here
        //

        XDBGWRN("XAPI", "XUnmountMU() called on MU drive (%c:) with alternate drive mapped (%c:)",
                chDrive, HD_ALT_UDATA_DRIVE);

        XUnmountAlternateTitle(HD_ALT_UDATA_DRIVE);
    }

    //
    //  open the symbolic link
    //
    soprintf(szDosDevice, OTEXT("\\??\\%c:"), chDrive);
    RtlInitObjectString(&DosDevice, szDosDevice);

    InitializeObjectAttributes(
        &Obja,
        (POBJECT_STRING)&DosDevice,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtCreateFile(
                    &VolHandle,
                    SYNCHRONIZE,
                    &Obja,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    0,
                    FILE_OPEN,
                    FILE_SYNCHRONOUS_IO_NONALERT
                    );

    //
    //  send FSCTL_DISMOUNT_VOLUME
    //
    if(NT_SUCCESS(Status))
    {
        Status = NtFsControlFile(VolHandle, NULL, NULL, NULL, &IoStatusBlock, FSCTL_DISMOUNT_VOLUME, NULL, 0, NULL, 0);
        NtClose(VolHandle); //Close handle whether the dismount succeeded or not.
    }

    if(NT_SUCCESS(Status))
    {
        //
        // Delete the symbolic link.
        //

        Status = IoDeleteSymbolicLink(&DosDevice);

        //
        //  Tell the MU driver to delete the DeviceObject
        //

        MU_CloseDeviceObject(dwPort, dwSlot);

        //
        //  Mark the drive as not mounted
        //

        MU_CLEAR_MOUNTED(chDrive);
        #if DBG
        g_XapiCurrentUserDevices--;
        #endif    
    }

    LeaveCriticalSection(&XapiMountMUCriticalSection);

    return RtlNtStatusToDosError(Status);
}


DWORD
WINAPI
XReadMUMetaData(
    IN DWORD dwPort,
    IN DWORD dwSlot,
    IN LPVOID lpBuffer,
    IN DWORD dwByteOffset,
    IN DWORD dwNumberOfBytesToRead
    )
{
    NTSTATUS Status;
    OCHAR szDeviceName[64];
    OBJECT_STRING DeviceName;
    OCHAR chDrive = MU_DRIVE_LETTER_FROM_PORT_SLOT(dwPort, dwSlot);
    PDEVICE_OBJECT DeviceObject;
    PFAT_VOLUME_METADATA VolumeMetadata;
    LARGE_INTEGER StartingOffset;
    DISK_GEOMETRY DiskGeometry;
    PARTITION_INFORMATION PartitionInformation;

#if DBG
    RIP_ON_NOT_TRUE_WITH_MESSAGE(XPP_XInitDevicesHasBeenCalled, "XReadMUMetaData: XInitDevices must be called first!");

    if ((dwPort < MU_PORT_MIN) || (dwPort > MU_PORT_MAX))
    {
        RIP("XReadMUMetaData() invalid parameter (dwPort)");
    }

    if ((dwSlot < MU_SLOT_MIN) || (dwSlot > MU_SLOT_MAX))
    {
        RIP("XReadMUMetaData() invalid parameter (dwSlot)");
    }

    if (dwByteOffset >= PAGE_SIZE)
    {
        RIP("XReadMUMetaData() invalid parameter (dwByteOffset)");
    }

    if ((PAGE_SIZE - dwByteOffset) < dwNumberOfBytesToRead)
    {
        RIP("XReadMUMetaData() invalid parameter (dwNumberOfBytesToRead)");
    }
#endif // DBG

    EnterCriticalSection(&XapiMountMUCriticalSection);

    if(!MU_IS_MOUNTED(chDrive))
    {
        //
        // Setup the string buffer
        //
        DeviceName.Length = 0;
        //lie - so we have guaranteed space for a back slash (lie leave room for NULL, and a '\\')
        DeviceName.MaximumLength = sizeof(szDeviceName)/sizeof(OCHAR)-2;
        DeviceName.Buffer = szDeviceName;

        //
        //  create the device object
        //
        Status = MU_CreateDeviceObject(
                    dwPort,
                    dwSlot,
                    &DeviceName
                    );
    }
    else
    {
        Status = STATUS_SUCCESS;
    }

    if (NT_SUCCESS(Status))
    {
        DeviceObject = MU_GetExistingDeviceObject(dwPort, dwSlot),

        //
        //  Before the memory unit can accept read requests, it must first
        //  initialize its drive geometry information.  Send the same IOCTLs
        //  that the file system would send during the mount process.  Neither
        //  of these need to synchronized with a file system that has already
        //  mounted, so send them directly to the device.
        //

        Status = IoSynchronousDeviceIoControlRequest(IOCTL_DISK_GET_DRIVE_GEOMETRY,
            DeviceObject, NULL, 0, &DiskGeometry, sizeof(DISK_GEOMETRY),
            NULL, FALSE);

        if (NT_SUCCESS(Status))
        {
            Status = IoSynchronousDeviceIoControlRequest(IOCTL_DISK_GET_PARTITION_INFO,
                DeviceObject, NULL, 0, &PartitionInformation,
                sizeof(PARTITION_INFORMATION), NULL, FALSE);

            if (PartitionInformation.PartitionLength.QuadPart < PAGE_SIZE)
            {
                Status = STATUS_UNRECOGNIZED_VOLUME;
            }
        }

        if (NT_SUCCESS(Status))
        {
            //
            //  Allocate a block of memory to hold the volume metadata block.  All
            //  device objects must support at least PAGE_SIZE transfers in order to
            //  support the file system cache.  Memory units typically have at least
            //  PAGE_SIZE sector sizes, so there's no point in trying to reduce this
            //  memory requirement.
            //

            VolumeMetadata = (PFAT_VOLUME_METADATA)LocalAlloc(LMEM_FIXED, PAGE_SIZE);

            if (VolumeMetadata != NULL)
            {
                //
                //  Submit a read request for PAGE_SIZE bytes from the start of
                //  the device.  Note that we don't need to synchronize this
                //  with the file system because all of the file systems we care
                //  about immediately flush any metadata writes to media.
                //

                StartingOffset.QuadPart = 0;

                Status = IoSynchronousFsdRequest(IRP_MJ_READ, DeviceObject,
                    VolumeMetadata, PAGE_SIZE, &StartingOffset);

                if (NT_SUCCESS(Status))
                {
                    //
                    //  Verify that the volume is formatted as FATX.  Memory units
                    //  never use any other file system.
                    //

                    if (VolumeMetadata->Signature == FAT_VOLUME_SIGNATURE)
                    {
                        CopyMemory(lpBuffer, (LPBYTE)VolumeMetadata + dwByteOffset,
                            dwNumberOfBytesToRead);

                        Status = STATUS_SUCCESS;
                    }
                    else
                    {
                        Status = STATUS_UNRECOGNIZED_VOLUME;
                    }
                }

                LocalFree(VolumeMetadata);
            }
            else
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        if(!MU_IS_MOUNTED(chDrive))
        {
            //
            //  Tell the MU driver to delete the DeviceObject
            //

            MU_CloseDeviceObject(dwPort, dwSlot);
        }
    }

    LeaveCriticalSection(&XapiMountMUCriticalSection);

    return RtlNtStatusToDosError(Status);
}

#endif // ! XAPILIBP

#ifdef XAPILIBP

DWORD
WINAPI
XMUNameFromPortSlot(
    IN DWORD dwPort,
    IN DWORD dwSlot,
    OUT LPWSTR lpName,
    IN UINT cchName
    )
{
    DWORD dwError;
    WCHAR VolumeName[FAT_VOLUME_NAME_LENGTH];

    dwError = XReadMUMetaData(dwPort, dwSlot, VolumeName,
        FIELD_OFFSET(FAT_VOLUME_METADATA, VolumeName), sizeof(VolumeName));

    if (dwError == ERROR_SUCCESS)
    {
        lstrcpynW(lpName, VolumeName, min(cchName, FAT_VOLUME_NAME_LENGTH));
    }

    return dwError;
}

#endif // XAPILIBP

#ifndef XAPILIBP

DWORD
WINAPI
XMUPortFromDriveLetter(
    OCHAR chDrive
    )
{
    if ((chDrive >= MU_FIRST_DRIVE) && (chDrive <= MU_LAST_DRIVE))
    {
        return MU_PORT_FROM_DRIVE_LETTER(chDrive);
    }
    else
    {
        return -1;
    }
}

DWORD
WINAPI
XMUSlotFromDriveLetter(
    OCHAR chDrive
    )
{
    if ((chDrive >= MU_FIRST_DRIVE) && (chDrive <= MU_LAST_DRIVE))
    {
        return MU_SLOT_FROM_DRIVE_LETTER(chDrive);
    }
    else
    {
        return -1;
    }
}

#endif // ! XAPILIBP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\mmtimer.c ===
/*++

Copyright (c) 1985-2000  Microsoft Corporation

Module Name:

    mmtimer.c

Abstract:

    This module implements the Win32 multimedia timer services.

--*/

#include "basedll.h"

//
// Define the maximum number of multimedia timers allowed.
//

#define MAXIMUM_MMTIMERS                (MAXIMUM_WAIT_OBJECTS - 1)

//
// Structure used to bind the parameters from timeSetEvent to its corresponding
// kernel timer object.
//

#include <pshpack4.h>

typedef struct _MMTIMER {
    KTIMER KernelTimer;
    LPTIMECALLBACK lpTimeCallback;
    DWORD dwTimeCallbackData;
    BOOLEAN Allocated;
    UCHAR Flags;
    USHORT SerialNumber;
    LARGE_INTEGER FireTime;
    LARGE_INTEGER Interval;
} MMTIMER, *PMMTIMER;

#include <poppack.h>

//
// Structure used to bind all of the timer state that is allocated on the timer
// thread's stack.
//

typedef struct _MMTIMER_THREAD_STATE {
    MMTIMER Timers[MAXIMUM_MMTIMERS];
    KEVENT ThreadEvent;
} MMTIMER_THREAD_STATE, *PMMTIMER_THREAD_STATE;

INITIALIZED_CRITICAL_SECTION(XapiMmTimerCriticalSection);
USHORT XapiMmTimerSerialNumber;
PMMTIMER_THREAD_STATE XapiMmTimerThreadState;

DWORD
WINAPI
XapiMmTimerThread(
    LPVOID lpThreadParameter
    )
{
    ULONG Index;
    MMTIMER_THREAD_STATE MmTimerThreadState;
    KWAIT_BLOCK WaitBlocks[MAXIMUM_WAIT_OBJECTS];
    PVOID WaitObjects[MAXIMUM_WAIT_OBJECTS];
    USHORT SerialNumbers[MAXIMUM_WAIT_OBJECTS];
    ULONG WaitObjectCount;
    NTSTATUS status;
    PMMTIMER MmTimer;
    LPTIMECALLBACK lpTimeCallback;
    DWORD dwTimeCallbackData;
    UINT uTimerID;
    UINT fuEvent;
    LARGE_INTEGER DueTime;

    //
    // Initialize the event used to signal that this thread needs to rebuild its
    // wait object array.
    //

    KeInitializeEvent(&MmTimerThreadState.ThreadEvent, SynchronizationEvent,
        FALSE);

    //
    // Initialize the kernel timers.
    //

    for (Index = 0; Index < MAXIMUM_MMTIMERS; Index++) {
        KeInitializeTimerEx(&MmTimerThreadState.Timers[Index].KernelTimer,
            SynchronizationTimer);
        MmTimerThreadState.Timers[Index].Allocated = FALSE;
    }

    //
    // The thread's state is now initialized.  Notify the thread that created us
    // that we're ready.
    //

    XapiMmTimerThreadState = &MmTimerThreadState;

    KeSetEvent((PKEVENT)lpThreadParameter, EVENT_INCREMENT, FALSE);

    //
    // Initially, we wait on only our thread event.
    //

    WaitObjects[0] = &MmTimerThreadState.ThreadEvent;
    WaitObjectCount = 1;

    for (;;) {

        //
        // Wait to be notified of the arrival or removal of a timer or for a
        // timer to be signaled.
        //

        status = KeWaitForMultipleObjects(WaitObjectCount, WaitObjects, WaitAny,
            UserRequest, UserMode, FALSE, NULL, WaitBlocks);

        if (status == STATUS_WAIT_0) {

            //
            // We've been signaled due to an addition or removal of a timer
            // from our thread state structure.  Recompute the local wait object
            // array.
            //

            EnterCriticalSection(&XapiMmTimerCriticalSection);

RecomputeWaitObjects:
            WaitObjectCount = 1;

            for (Index = 0; Index < MAXIMUM_WAIT_OBJECTS - 1; Index++) {

                //
                // If the timer has been allocated, add it to the wait object
                // array and capture the timer's serial number.  We need the
                // serial number to deal with a race where this thread is woken
                // in response to a signaled timer and another thread has
                // already called timeKillEvent.
                //

                if (MmTimerThreadState.Timers[Index].Allocated) {
                    SerialNumbers[WaitObjectCount] =
                        MmTimerThreadState.Timers[Index].SerialNumber;
                    WaitObjects[WaitObjectCount] =
                        &MmTimerThreadState.Timers[Index].KernelTimer;
                    WaitObjectCount++;
                }
            }

            LeaveCriticalSection(&XapiMmTimerCriticalSection);

        } else if (status >= STATUS_WAIT_1 && status < (STATUS_WAIT_1 +
            MAXIMUM_MMTIMERS)) {

            //
            // We've been signaled due to a timer firing.  Verify that the timer
            // is still allocated and that the serial number matches what we
            // think it should be.
            //

            EnterCriticalSection(&XapiMmTimerCriticalSection);

            MmTimer = CONTAINING_RECORD(WaitObjects[status], MMTIMER, KernelTimer);

            if (MmTimer->Allocated &&
                (MmTimer->SerialNumber == SerialNumbers[status])) {

                //
                // The timer is still allocated.  Depending on the timer flags,
                // either set an event, pulse an event, or invoke a callback.
                //

                fuEvent = (UINT)MmTimer->Flags;

                if ((fuEvent & TIME_CALLBACK_EVENT_SET) != 0) {

                    NtSetEvent((HANDLE)MmTimer->lpTimeCallback, NULL);

                } else if ((fuEvent & TIME_CALLBACK_EVENT_PULSE) != 0) {

                    NtPulseEvent((HANDLE)MmTimer->lpTimeCallback, NULL);

                } else {

                    //
                    // Capture the timer data to the stack so that we can invoke
                    // the callback outside of the critical section.
                    //

                    lpTimeCallback = MmTimer->lpTimeCallback;
                    dwTimeCallbackData = MmTimer->dwTimeCallbackData;
                    Index = MmTimer - &MmTimerThreadState.Timers[0];
                    uTimerID = MAKELONG(Index + 1, MmTimer->SerialNumber);

                    LeaveCriticalSection(&XapiMmTimerCriticalSection);

                    //
                    // Invoke the callback.  The callback or another thread may
                    // end up calling timeKillEvent for our timer ID so we can't
                    // touch the MMTIMER structure until we validate it again.
                    //

                    lpTimeCallback(uTimerID, 0, dwTimeCallbackData, 0, 0);

                    //
                    // Reenter the critical section and verify that the timer
                    // hasn't been killed.
                    //

                    EnterCriticalSection(&XapiMmTimerCriticalSection);

                    if (!MmTimer->Allocated ||
                        (MmTimer->SerialNumber != SerialNumbers[status])) {
                        LeaveCriticalSection(&XapiMmTimerCriticalSection);
                        continue;
                    }
                }

                if ((fuEvent & TIME_PERIODIC) != 0) {

                    //
                    // Initialize the timer with its new due time.  If the timer
                    // has already expired, then set the due time to zero so
                    // that we can immediately wake up and process the timer
                    // again.
                    //

                    MmTimer->FireTime.QuadPart -= MmTimer->Interval.QuadPart;

                    DueTime.QuadPart = KeQueryInterruptTime() -
                        MmTimer->FireTime.QuadPart;

                    if (DueTime.QuadPart > 0) {
                        DueTime.QuadPart = 0;
                    }

                    KeSetTimerEx(&MmTimer->KernelTimer, DueTime, 0, NULL);

                } else {

                    //
                    // Mark the timer as unallocated.
                    //

                    MmTimer->Allocated = FALSE;

                    //
                    // Jump into the code to recompute the wait objects array.
                    //

                    goto RecomputeWaitObjects;
                }
            }

            LeaveCriticalSection(&XapiMmTimerCriticalSection);

        } else {
            XDBGERR("XAPI", "XapiMmTimerThread woke for unexpected reason: %08x\n", status);
        }
    }
}

UINT
WINAPI
timeSetEvent(
    UINT uDelay,
    UINT uResolution,
    LPTIMECALLBACK lpTimeCallback,
    DWORD dwTimeCallbackData,
    UINT fuEvent
    )
{
    KEVENT ThreadReadyEvent;
    HANDLE hThread;
    ULONG Index;
    UINT uTimerID;
    PMMTIMER MmTimer;
    USHORT SerialNumber;

    EnterCriticalSection(&XapiMmTimerCriticalSection);

    //
    // Check if the multimedia timer thread has been started yet.
    //

    if (XapiMmTimerThreadState == NULL) {

        //
        // Create an event that the multimedia timer thread will signal when it
        // has finished initializating itself.
        //

        KeInitializeEvent(&ThreadReadyEvent, NotificationEvent, FALSE);

        //
        // Create the multimedia timer thread with the default stack size for
        // the title.
        //

        hThread = CreateThread(NULL, 0, XapiMmTimerThread, &ThreadReadyEvent, 0,
            NULL);

        if (hThread == NULL) {
            XDBGERR("XAPI", "XapiMmTimerThread cannot be created\n");
            LeaveCriticalSection(&XapiMmTimerCriticalSection);
            return 0;
        }

        CloseHandle(hThread);

        //
        // Wait for the multimedia timer thread to initialize itself.
        //

        KeWaitForSingleObject(&ThreadReadyEvent, Executive, UserMode, FALSE,
            NULL);

        //
        // At this point, the global timer thread state should have been filled
        // in.
        //

        ASSERT(XapiMmTimerThreadState != NULL);
    }

    uTimerID = 0;

    for (Index = 0; Index < MAXIMUM_WAIT_OBJECTS - 1; Index++) {

        if (!XapiMmTimerThreadState->Timers[Index].Allocated) {

            SerialNumber = XapiMmTimerSerialNumber++;

            MmTimer = &XapiMmTimerThreadState->Timers[Index];

            MmTimer->Allocated = TRUE;
            MmTimer->Flags = (UCHAR)fuEvent;
            MmTimer->SerialNumber = SerialNumber;
            MmTimer->lpTimeCallback = lpTimeCallback;
            MmTimer->dwTimeCallbackData = dwTimeCallbackData;

            //
            // Compute the initial due time for the timer and start the timer.
            //
            // We track the fire time and period interval ourselves instead of
            // using the period functionality of the kernel timer to avoid
            // timer drift that can occur.
            //

            MmTimer->Interval.QuadPart = -10000 * (LONGLONG)uDelay;

            MmTimer->FireTime.QuadPart = KeQueryInterruptTime() -
                MmTimer->Interval.QuadPart;

            KeSetTimerEx(&MmTimer->KernelTimer, MmTimer->Interval, 0, NULL);

            //
            // Signal the multimedia timer thread that it needs to add a timer
            // to its wait list.
            //

            KeSetEvent(&XapiMmTimerThreadState->ThreadEvent, EVENT_INCREMENT,
                FALSE);

            uTimerID = MAKELONG(Index + 1, SerialNumber);
            break;
        }
    }

    LeaveCriticalSection(&XapiMmTimerCriticalSection);

    return uTimerID;
}

MMRESULT
WINAPI
timeKillEvent(
    UINT uTimerID
    )
{
    MMRESULT mmresult;
    ULONG Index;
    PMMTIMER MmTimer;

    EnterCriticalSection(&XapiMmTimerCriticalSection);

    Index = LOWORD(uTimerID) - 1;

    //
    // Validate that this is a legal timer identifier.  The timer thread must be
    // already running in order to have obtained a valid identifier from
    // timeSetEvent.  The timer identifier must be in legal range and the timer
    // must be marked as having been allocated.
    //

    if ((XapiMmTimerThreadState != NULL) && (Index < MAXIMUM_MMTIMERS) &&
        XapiMmTimerThreadState->Timers[Index].Allocated &&
        XapiMmTimerThreadState->Timers[Index].SerialNumber == HIWORD(uTimerID)) {

        //
        // Cancel the timer and mark the timer as unallocated.
        //

        MmTimer = &XapiMmTimerThreadState->Timers[Index];

        KeCancelTimer(&MmTimer->KernelTimer);

        MmTimer->Allocated = FALSE;

        //
        // Signal the multimedia timer thread that it needs to remove a timer
        // from its wait list.
        //

        KeSetEvent(&XapiMmTimerThreadState->ThreadEvent, EVENT_INCREMENT, FALSE);

        mmresult = MMSYSERR_NOERROR;

    } else {
        mmresult = TIMERR_NOCANDO;
    }

    LeaveCriticalSection(&XapiMmTimerCriticalSection);

    return mmresult;
}

MMRESULT
WINAPI
timeGetSystemTime(
    LPMMTIME lpTime,
    UINT wSize
    )
{
    lpTime->u.ms = NtGetTickCount();
    lpTime->wType = TIME_MS;

    return TIMERR_NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\physical.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    physical.c

Abstract:

    This module implements the XBOX physical memory management services.

--*/

#include "basedll.h"
#pragma hdrstop

LPVOID
WINAPI
XPhysicalAlloc(
    IN SIZE_T dwSize,
    IN ULONG_PTR ulPhysicalAddress,
    IN ULONG_PTR ulAlignment,
    IN DWORD flProtect
    )
{
    ULONG ulLowestAcceptableAddress;
    ULONG ulHighestAcceptableAddress;
    LPVOID lpAddress;

    RIP_ON_NOT_TRUE("XPhysicalAlloc()", (dwSize != 0));
    RIP_ON_NOT_TRUE("XPhysicalAlloc()", ((ulAlignment & (ulAlignment - 1)) == 0));
    RIP_ON_NOT_TRUE("XPhysicalAlloc()",
        ((flProtect & ~(PAGE_READWRITE | PAGE_READONLY | PAGE_WRITECOMBINE | PAGE_NOCACHE)) == 0));

    if (ulPhysicalAddress != MAXULONG_PTR) {

        RIP_ON_NOT_TRUE("XPhysicalAlloc()", (BYTE_OFFSET(ulPhysicalAddress) == 0));

        ulLowestAcceptableAddress = ulPhysicalAddress;
        ulHighestAcceptableAddress = ulPhysicalAddress + dwSize - 1;

        //
        // Ignore the alignment parameter; the caller gave us a physical address
        // and we assume it has the appropriate alignment already applied.
        //

        ulAlignment = 0;

    } else {
        ulLowestAcceptableAddress = 0;
        ulHighestAcceptableAddress = MAXULONG_PTR;
    }

    lpAddress = MmAllocateContiguousMemoryEx(dwSize, ulLowestAcceptableAddress,
        ulHighestAcceptableAddress, ulAlignment, flProtect);

    if (lpAddress == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    return lpAddress;
}

SIZE_T
WINAPI
XPhysicalSize(
    IN LPVOID lpAddress
    )
{
    RIP_ON_NOT_TRUE("XPhysicalSize()", ((ULONG_PTR)lpAddress >= 0x80000000));

    return MmQueryAllocationSize(lpAddress);
}

VOID
WINAPI
XPhysicalProtect(
    IN LPVOID lpAddress,
    IN SIZE_T dwSize,
    IN DWORD flNewProtect
    )
{
    RIP_ON_NOT_TRUE("XPhysicalProtect()", ((ULONG_PTR)lpAddress >= 0x80000000));
    RIP_ON_NOT_TRUE("XPhysicalProtect()",
        ((flNewProtect & ~(PAGE_READWRITE | PAGE_READONLY | PAGE_WRITECOMBINE | PAGE_NOCACHE)) == 0));

    if (dwSize != 0) {
        MmSetAddressProtect(lpAddress, dwSize, flNewProtect);
    }
}

VOID
WINAPI
XPhysicalFree(
    IN LPVOID lpAddress
    )
{
    RIP_ON_NOT_TRUE("XPhysicalFree()", ((ULONG_PTR)lpAddress >= 0x80000000));

    MmFreeContiguousMemory(lpAddress);
}

DWORD
WINAPI
XQueryMemoryProtect(
    IN LPVOID lpAddress
    )
{
    return MmQueryAddressProtect(lpAddress);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\powerdwn.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    powerdwn.c

Abstract:

    Xbox Auto Power Down

    Provides a 6 hour auto power off timer.

    The following private API's are provided the dashboard
    and internal XSS components to manage the auto power down
    feature.

    XAutoPowerDownSet
    XAutoPowerDownGet
    XAutoPowerDownResetTimer

    For debug builds there is also:

    XAutoPowerDownDebugSetTimeout

Environment:

    XAPI

Notes:

Revision History:

    05-17-01 created by Mitchell Dernis (mitchd)

--*/
#include "basedll.h"
#include <xboxp.h>

#define AUTOPOWERDOWNTIMEOUT (-216000000000)  //This should be 6 hours worth of 100 ns intervals
                                              //6*60*60*1000*1000*10 : negative means from current time.
//---------------------------------------------------------
//  Declaration of Globals used in this module
//---------------------------------------------------------
typedef struct _XAPI_AUTOPOWERDOWN_GLOBAL
{
    KDPC    AutoPowerDownDpc;
    KTIMER  AutoPowerDownTimer;
    BOOL    fAutoPowerDown;
    BOOL    fReadWriteFailure;
#if DBG
    LARGE_INTEGER liTimeOut;  //The timeout is adjustable in debug builds only
#endif
} XAPI_AUTOPOWERDOWN_GLOBAL;
XAPI_AUTOPOWERDOWN_GLOBAL XapiAutoPowerDownGlobals;

//---------------------------------------------------------
//  Forward Declaration of Support Routines
//---------------------------------------------------------
VOID  XapiAutoPowerDownTimeout(PKDPC, PVOID, PVOID, PVOID); //Dpc Timeout

#ifdef XAPILIBP

/*
**  PRIVATE API ACCESSIBLE TO OTHER COMPONENTS
**  OF XSS and THE DASHBOARD
*/

DWORD
XAutoPowerDownSet(BOOL fAutoPowerDown)
/*++
  Routine Description:
   Turns the auto-power-down feature on and off.

  Arguments:
   fAutoPowerDown - The desired new setting.
  
  Return Value:
   Error code returned by XSetValue.

  Remarks:
   
   The only portion of this API that can fail is writing the new setting
   to EEPROM.  The error code returned is the one returned by this
   XSetValue. Regardless of whether the new value was successfully persisted,
   the new setting is adopted for the current session.

   THIS ROUTINE IS NOT THREAD SAFE!!! The only intended client
   is XDash, nobody else should be touching this.
   
--*/
{
    DWORD dwError;
    ULONG ulType, ulSize;
    DWORD dwMiscFlags;

    //
    //  Save the new value of the flag.
    //
    XapiAutoPowerDownGlobals.fAutoPowerDown = fAutoPowerDown;
    
    dwError = XQueryValue(XC_MISC_FLAGS, &ulType, &dwMiscFlags, sizeof(dwMiscFlags), &ulSize);

    //
    //  Sets or cancels the timer as appropriate.
    //
    if(fAutoPowerDown)
    {
        XAutoPowerDownResetTimer();
        dwMiscFlags |= XC_MISC_FLAG_AUTOPOWERDOWN;
    } else
    {
        dwMiscFlags &= ~XC_MISC_FLAG_AUTOPOWERDOWN;
    }

    //
    //  If the query succeeded, then write out the new value.
    //
    if(!dwError)
    {
        dwError = XSetValue(XC_MISC_FLAGS, REG_DWORD, &dwMiscFlags, sizeof(dwMiscFlags));
    }

    //
    //  Whether error or not we need to update the fReadWriteFailure flag.
    //
    XapiAutoPowerDownGlobals.fReadWriteFailure = dwError;

    return dwError;
}

DWORD
XAutoPowerDownGet(BOOL *pfAutoPowerDown)
/*++
  Routine Description:
   Retrieves the current setting of the
   auto-power-down feature.

  Arguments:
   pfAutoPowerDown - pointer to BOOL to receive setting.

  Return Value:
   Error code returned by XAutoPowerDownGet.
 
  Remarks:
   The API maintains the current operating mode of the feature
   separate from the persisted value.

   On each call to XAutoPowerDownGet, the API attempts to reestablish
   coherency between the persisted value and the current operating
   value.  It does this by checking to see if the last read\write
   operation falied.  If it was a failure, it calls
   XAutoPowerDownSet with the current operating value.
   
   In all cases, *pfAutoPowerDown is set to the current operating
   value.
--*/
{
    DWORD dwError = 0;

    //
    //  Save out the return value
    //
    *pfAutoPowerDown = XapiAutoPowerDownGlobals.fAutoPowerDown;

    //
    //  If the last read or write was a failure, try writing
    //  out the setting again.
    //
    if(XapiAutoPowerDownGlobals.fReadWriteFailure)
    {
        dwError = XAutoPowerDownSet(XapiAutoPowerDownGlobals.fAutoPowerDown);
    }
    return dwError;
}


#if DBG
void XAutoPowerDownDebugSetTimeout(LONGLONG llTimeout)
/*++
  Routine Description:
   In debug builds only we need a way to set the timer to something short to test
   the feature.

  Arguments:
   liTimeout - Time in 100 ns intervals to set the timeout.  This value should be negative.
               If the time is not negative, it is the absolute time after boot that the box should
               go off.
--*/
{
    XapiAutoPowerDownGlobals.liTimeOut.QuadPart = llTimeout;
}
#endif

#endif // XAPILIBP

#ifndef XAPILIBP

//---------------------------------------------------------
//  Initialization method called by Xapi Init
//---------------------------------------------------------
void XapiInitAutoPowerDown()
{
    ULONG ulSize, ulType;
    DWORD dwError, dwMiscFlags;

    //
    //  Initialize Dpc and Timer Structures
    //
    KeInitializeDpc(&XapiAutoPowerDownGlobals.AutoPowerDownDpc, XapiAutoPowerDownTimeout, NULL);
    KeInitializeTimer(&XapiAutoPowerDownGlobals.AutoPowerDownTimer);

#if DBG
    //
    //  In release builds, the timeout is hardcoded to six hours
    //  in debug builds it is variable.
    XapiAutoPowerDownGlobals.liTimeOut.QuadPart = AUTOPOWERDOWNTIMEOUT;
#endif

    //
    //  Initialize the feature state from the config settings
    //
    XapiAutoPowerDownGlobals.fAutoPowerDown = FALSE;
    XapiAutoPowerDownGlobals.fReadWriteFailure = FALSE;

    dwError = XQueryValue(XC_MISC_FLAGS, &ulType, &dwMiscFlags, sizeof(dwMiscFlags), &ulSize);
    if(!dwError)
    {
        XapiAutoPowerDownGlobals.fAutoPowerDown = (dwMiscFlags&XC_MISC_FLAG_AUTOPOWERDOWN) ? TRUE : FALSE;
    } else
    {
        XapiAutoPowerDownGlobals.fReadWriteFailure = TRUE;
    }

    //
    //  Start the timer.
    //
    XAutoPowerDownResetTimer();
}

void
XAutoPowerDownResetTimer()
/*++
  Routine Description:
   Resets the AutoPowerDownTimer so that the unit does not shut off.

  Remarks:
   Note that we always set the timer and never check XapiAutoPowerDownGlobals.fAutoPowerDown.
   This is by design.  The DPC timeout routine checks XapiAutoPowerDownGlobals.fAutoPowerDown.

   After some thought, it is not enough to check XapiAutoPowerDownGlobals.fAutoPowerDown here,
   unless you synchronize this routine with XAutoPowerDownSet.  That is a hassle, and it
   it is more code.

   Games must be able to run well with the timer running so you cannot argue that the having the
   timer running negatively affects performance.  In fact, if does negatively affect performance,
   it is even more important that it run all the time.

   So just let the timer run, we will check if the auto-power-down feature is on, only at the last
   moment when we need to turn off the box.

--*/
{
#if DBG
    KeSetTimer(
        &XapiAutoPowerDownGlobals.AutoPowerDownTimer,
        XapiAutoPowerDownGlobals.liTimeOut,
        &XapiAutoPowerDownGlobals.AutoPowerDownDpc
        );
#else
    LARGE_INTEGER liDueTime;
    liDueTime.QuadPart = AUTOPOWERDOWNTIMEOUT;
    KeSetTimer(&XapiAutoPowerDownGlobals.AutoPowerDownTimer, liDueTime, &XapiAutoPowerDownGlobals.AutoPowerDownDpc);
#endif
}

ULONG XAutoPowerDownTimeRemaining()
/*++
  Routine Description:
    This routine is available to games so that they may poll to see if an auto power down is imminent.
    Developers want this so that they may auto-save before the box shuts down.  Notifying them would be
    too hard, as we would need to call them at DPC.

  Return Value:
    If the auto power down feature is off, the return value is 0xFFFFFFFF.  If the auto power
    down feature is on, the return value is the time in milliseconds until auto power-down.
--*/
{
    KIRQL  oldIrql;
    ULARGE_INTEGER uliTimeRemaining;
    ULONGLONG ullCurrentTime;
    if(!XapiAutoPowerDownGlobals.fAutoPowerDown)
    {
        return 0xFFFFFFFF;
    }
    
    //synchronize access to timer structure
    oldIrql = KeRaiseIrqlToDpcLevel();
    
    //Get the current interrupt time
    ullCurrentTime = KeQueryInterruptTime();

    // Comute the difference, in 100 ns intervals.  The interrupt timer starts out at zero at boot and just runs.
    // With a 64-bit - 100 ns counter - it will wrap once every 58,494 and a quater years.  Don't worry about
    // counter wrap!
    if(XapiAutoPowerDownGlobals.AutoPowerDownTimer.DueTime.QuadPart >= ullCurrentTime)
    {
        uliTimeRemaining.QuadPart = XapiAutoPowerDownGlobals.AutoPowerDownTimer.DueTime.QuadPart - ullCurrentTime;
    } else
    {
        uliTimeRemaining.QuadPart = 0;
    }

    //Done synchronizing.
    KeLowerIrql(oldIrql);

    //Convert from 100 ns intevals to milliseconds
    uliTimeRemaining.QuadPart /= 10000;

    //Since we know that the time was never set for more than
    //six hours, we can trust that the HighPart is now zero.
    return uliTimeRemaining.LowPart;
}

/*
**  INTERNAL SUPPORT METHODS
**  
*/

VOID
XapiAutoPowerDownTimeout(
    PKDPC bogus1,
    PVOID bogus2,
    PVOID bogus3,
    PVOID bogus4
    )
/*++
  Routine Description:
    This is the timeout DPC for the Auto-power-down feature.
    When this routine is called it checks XapiAutoPowerDownGlobals.fAutoPowerDown.
    If TRUE it calls the appropriate Hal method to power down Xbox.
--*/
{
    if(XapiAutoPowerDownGlobals.fAutoPowerDown)
    {
        HalInitiateShutdown();
    }
}

#endif // ! XAPILIBP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\process.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    process.c

Abstract:

    Process management routines

--*/

#include "basedll.h"
#pragma hdrstop

BOOL
WINAPI
IsBadReadPtr(
    CONST VOID *lp,
    UINT_PTR cb
    )

/*++

Routine Description:

    This function verifies that the range of memory specified by the
    input parameters can be read by the calling process.

    If the entire range of memory is accessible, then a value of FALSE
    is returned; otherwise, a value of TRUE is returned.

    Note that since Win32 is a pre-emptive multi-tasking environment,
    the results of this test are only meaningful if the other threads in
    the process do not manipulate the range of memory being tested by
    this call.  Even after a pointer validation, an application should
    use the structured exception handling capabilities present in the
    system to guard access through pointers that it does not control.

Arguments:

    lp - Supplies the base address of the memory that is to be checked
        for read access.

    cb - Supplies the length in bytes to be checked.

Return Value:

    TRUE - Some portion of the specified range of memory is not accessible
        for read access.

    FALSE - All pages within the specified range have been successfully
        read.

--*/

{

    PSZ EndAddress;
    PSZ StartAddress;

    //
    // If the structure has zero length, then do not probe the structure for
    // read accessibility or alignment.
    //

    if (cb != 0) {

        //
        // If it is a NULL pointer just return TRUE, they are always bad
        //
        if (lp == NULL) {
            return TRUE;
            }

        StartAddress = (PSZ)lp;

        //
        // Compute the ending address of the structure and probe for
        // read accessibility.
        //

        EndAddress = StartAddress + cb - 1;
        if ( EndAddress < StartAddress ) {
           return TRUE;
            }
        else {
            try {
                *(volatile CHAR *)StartAddress;
                StartAddress = (PCHAR)((ULONG_PTR)StartAddress & (~((LONG)PAGE_SIZE - 1)));
                EndAddress = (PCHAR)((ULONG_PTR)EndAddress & (~((LONG)PAGE_SIZE - 1)));
                while (StartAddress != EndAddress) {
                    StartAddress = StartAddress + PAGE_SIZE;
                    *(volatile CHAR *)StartAddress;
                    }
                }
            except(EXCEPTION_EXECUTE_HANDLER) {
                return TRUE;
                }
            }
        }
    return FALSE;
}

BOOL
WINAPI
IsBadWritePtr(
    LPVOID lp,
    UINT_PTR cb
    )
/*++

Routine Description:

    This function verifies that the range of memory specified by the
    input parameters can be written by the calling process.

    If the entire range of memory is accessible, then a value of FALSE
    is returned; otherwise, a value of TRUE is returned.

    Note that since Win32 is a pre-emptive multi-tasking environment,
    the results of this test are only meaningful if the other threads in
    the process do not manipulate the range of memory being tested by
    this call.  Even after a pointer validation, an application should
    use the structured exception handling capabilities present in the
    system to guard access through pointers that it does not control.

    Also not that implementations are free to do a write test by reading
    a value and then writing it back.

Arguments:

    lp - Supplies the base address of the memory that is to be checked
        for write access.

    cb - Supplies the length in bytes to be checked.

Return Value:

    TRUE - Some portion of the specified range of memory is not accessible
        for write access.

    FALSE - All pages within the specified range have been successfully
        written.

--*/
{
    PSZ EndAddress;
    PSZ StartAddress;

    //
    // If the structure has zero length, then do not probe the structure for
    // write accessibility.
    //

    if (cb != 0) {

        //
        // If it is a NULL pointer just return TRUE, they are always bad
        //
        if (lp == NULL) {
            return TRUE;
            }

        StartAddress = (PCHAR)lp;

        //
        // Compute the ending address of the structure and probe for
        // write accessibility.
        //

        EndAddress = StartAddress + cb - 1;
        if ( EndAddress < StartAddress ) {
            return TRUE;
            }
        else {
            try {
                *(volatile CHAR *)StartAddress = *(volatile CHAR *)StartAddress;
                StartAddress = (PCHAR)((ULONG_PTR)StartAddress & (~((LONG)PAGE_SIZE - 1)));
                EndAddress = (PCHAR)((ULONG_PTR)EndAddress & (~((LONG)PAGE_SIZE - 1)));
                while (StartAddress != EndAddress) {
                    StartAddress = StartAddress + PAGE_SIZE;
                    *(volatile CHAR *)StartAddress = *(volatile CHAR *)StartAddress;
                    }
                }
            except(EXCEPTION_EXECUTE_HANDLER) {
                return TRUE;
                }
            }
        }
    return FALSE;
}

BOOL
WINAPI
IsBadCodePtr(
    FARPROC lpfn
    )

/*++

    Same as IsBadReadPtr with a length of 1

--*/

{
    return IsBadReadPtr((LPVOID)lpfn,1);
}

BOOL
WINAPI
IsBadStringPtrW(
    LPCWSTR lpsz,
    UINT_PTR cchMax
    )

/*++

Routine Description:

    This function verifies that the range of memory specified by the
    input parameters can be read by the calling process.

    The range is the smaller of the number of bytes covered by the
    specified NULL terminated UNICODE string, or the number of bytes
    specified by cchMax.

    If the entire range of memory is accessible, then a value of FALSE
    is returned; otherwise, a value of TRUE is returned.

    Note that since Win32 is a pre-emptive multi-tasking environment,
    the results of this test are only meaningful if the other threads in
    the process do not manipulate the range of memory being tested by
    this call.  Even after a pointer validation, an application should
    use the structured exception handling capabilities present in the
    system to guard access through pointers that it does not control.

Arguments:

    lpsz - Supplies the base address of the memory that is to be checked
        for read access.

    cchMax - Supplies the length in characters to be checked.

Return Value:

    TRUE - Some portion of the specified range of memory is not accessible
        for read access.

    FALSE - All pages within the specified range have been successfully
        read.

--*/

{

    LPCWSTR EndAddress;
    LPCWSTR StartAddress;
    WCHAR c;

    //
    // If the structure has zero length, then do not probe the structure for
    // read accessibility.
    //

    if (cchMax != 0) {

        //
        // If it is a NULL pointer just return TRUE, they are always bad
        //
        if (lpsz == NULL) {
            return TRUE;
            }

        StartAddress = lpsz;

        //
        // Compute the ending address of the structure and probe for
        // read accessibility.
        //

        EndAddress = (LPCWSTR)((PSZ)StartAddress + (cchMax*sizeof(WCHAR)) - sizeof(WCHAR));
        try {
            c = *(volatile WCHAR *)StartAddress;
            while ( c && StartAddress != EndAddress ) {
                StartAddress++;
                c = *(volatile WCHAR *)StartAddress;
                }
            }
        except(EXCEPTION_EXECUTE_HANDLER) {
            return TRUE;
            }
        }
    return FALSE;
}

BOOL
WINAPI
IsBadStringPtrA(
    LPCSTR lpsz,
    UINT_PTR cchMax
    )

/*++

Routine Description:

    This function verifies that the range of memory specified by the
    input parameters can be read by the calling process.

    The range is the smaller of the number of bytes covered by the
    specified NULL terminated UNICODE string, or the number of bytes
    specified by cchMax.

    If the entire range of memory is accessible, then a value of FALSE
    is returned; otherwise, a value of TRUE is returned.

    Note that since Win32 is a pre-emptive multi-tasking environment,
    the results of this test are only meaningful if the other threads in
    the process do not manipulate the range of memory being tested by
    this call.  Even after a pointer validation, an application should
    use the structured exception handling capabilities present in the
    system to guard access through pointers that it does not control.

Arguments:

    lpsz - Supplies the base address of the memory that is to be checked
        for read access.

    cchMax - Supplies the length in characters to be checked.

Return Value:

    TRUE - Some portion of the specified range of memory is not accessible
        for read access.

    FALSE - All pages within the specified range have been successfully
        read.

--*/

{

    LPCSTR EndAddress;
    LPCSTR StartAddress;
    CHAR c;

    //
    // If the structure has zero length, then do not probe the structure for
    // read accessibility.
    //

    if (cchMax != 0) {

        //
        // If it is a NULL pointer just return TRUE, they are always bad
        //
        if (lpsz == NULL) {
            return TRUE;
            }

        StartAddress = lpsz;

        //
        // Compute the ending address of the structure and probe for
        // read accessibility.
        //

        EndAddress = (LPCSTR)((PSZ)StartAddress + (cchMax*sizeof(CHAR)) - sizeof(CHAR));
        try {
            c = *(volatile CHAR *)StartAddress;
            while ( c && StartAddress != EndAddress ) {
                StartAddress++;
                c = *(volatile CHAR *)StartAddress;
                }
            }
        except(EXCEPTION_EXECUTE_HANDLER) {
            return TRUE;
            }
        }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\rect.c ===
#include "basedll.h"

#define VALIDATERECT(prc, retval)                              \
            RIP_ON_NOT_TRUE_WITH_MESSAGE(                      \
                (NULL != prc),                                 \
                "NULL LPRECT pointer passed to Rect function")

/***********************************************************************\
* SetRect (API)
*
* This function fills a rectangle structure with the passed in coordinates.
*
* History:
* 10-20-90 DarrinM      Translated from PMese to Windowses.
\***********************************************************************/

BOOL APIENTRY SetRect(
    LPRECT prc,
    int left,
    int top,
    int right,
    int bottom)
{
    VALIDATERECT(prc, FALSE);

    prc->left = left;
    prc->top = top;
    prc->right = right;
    prc->bottom = bottom;
    return TRUE;
}

#if 0

/************************************************************************\
* CopyInflateRect (API)
*
* This function copies the rect from prcSrc to prcDst, and inflates it.
*
* History:
* 12-16-93  FritzS
\************************************************************************/

BOOL APIENTRY CopyInflateRect(
    LPRECT prcDst,
    CONST RECT *prcSrc,
    int cx, int cy)
{
    prcDst->left   = prcSrc->left   - cx;
    prcDst->right  = prcSrc->right  + cx;
    prcDst->top    = prcSrc->top    - cy;
    prcDst->bottom = prcSrc->bottom + cy;
    return TRUE;
}

/************************************************************************\
* CopyOffsetRect (API)
*
* This function copies the rect from prcSrc to prcDst, and offsets it.
*
* History:
* 01-03-94  FritzS
\************************************************************************/

BOOL APIENTRY CopyOffsetRect(
    LPRECT prcDst,
    CONST RECT *prcSrc,
    int cx, int cy)
{
    prcDst->left   = prcSrc->left   + cx;
    prcDst->right  = prcSrc->right  + cx;
    prcDst->top    = prcSrc->top    + cy;
    prcDst->bottom = prcSrc->bottom + cy;
    return TRUE;
}

#endif // 0

/************************************************************************\
* IsRectEmpty (API)
*
* This function returns TRUE if *prc is an empty rect, FALSE
* otherwise.  An empty rect is one that has no area: right is
* less than or equal to left, bottom is less than or equal to top.
*
* Warning:
*   This function assumes that the rect is in device coordinates
*   mode where left and top coordinate are smaller than right and
*   bottom.
*
* History:
* 10-20-90 DarrinM      Translated from PMese to Windowses.
\************************************************************************/

BOOL APIENTRY IsRectEmpty(
    CONST RECT *prc)
{
    VALIDATERECT(prc, TRUE);

    return ((prc->left >= prc->right) || (prc->top >= prc->bottom));
}

/***********************************************************************\
* PtInRect (API)
*
* This function returns TRUE if *ppt falls inside of *prc.
*
* History:
* 10-20-90 DarrinM      Translated from PMese to Windowses.
\************************************************************************/

BOOL APIENTRY PtInRect(
    CONST RECT *prc,
    POINT  pt)
{
    VALIDATERECT(prc, FALSE);

    return ((pt.x >= prc->left) && (pt.x < prc->right) &&
            (pt.y >= prc->top)  && (pt.y < prc->bottom));
}

/************************************************************************\
* OffsetRect (API)
*
* This function offsets the coordinates of *prc by adding cx to
* both the left and right coordinates, and cy to both the top and
* bottom coordinates.
*
* History:
* 10-20-90 DarrinM      Translated from PMese to Windowses.
\************************************************************************/

BOOL APIENTRY OffsetRect(
    LPRECT prc,
    int cx,
    int cy)
{
    VALIDATERECT(prc, FALSE);

    prc->left   += cx;
    prc->right  += cx;
    prc->bottom += cy;
    prc->top    += cy;
    return TRUE;
}

/************************************************************************\
* InflateRect (API)
*
* This function expands the given rect by cx horizantally and cy
* vertically on all sides.  If cx or cy are negative, the rect
* is inset.  cx is subtracted from the left and added to the right,
* and cy is subtracted from the top and added to the bottom.
*
* History:
* 10-20-90 DarrinM      Translated from PMese to Windowses.
\************************************************************************/

BOOL APIENTRY InflateRect(
    LPRECT prc,
    int cx,
    int cy)
{
    VALIDATERECT(prc, FALSE);

    prc->left   -= cx;
    prc->right  += cx;
    prc->top    -= cy;
    prc->bottom += cy;
    return TRUE;
}

/************************************************************************\
* IntersectRect (API)
*
* Calculates the intersection between *prcSrc1 and *prcSrc2,
* returning the resulting rect in *prcDst.  Returns TRUE if
* *prcSrc1 intersects *prcSrc2, FALSE otherwise.  If there is no
* intersection, an empty rect is returned in *prcDst
*
* History:
* 10-20-90 DarrinM      Translated from PMese to Windowses.
\************************************************************************/

BOOL APIENTRY IntersectRect(
    LPRECT prcDst,
    CONST RECT *prcSrc1,
    CONST RECT *prcSrc2)

{
    VALIDATERECT(prcDst, FALSE);
    VALIDATERECT(prcSrc1, FALSE);
    VALIDATERECT(prcSrc2, FALSE);

    prcDst->left  = max(prcSrc1->left, prcSrc2->left);
    prcDst->right = min(prcSrc1->right, prcSrc2->right);

    /*
     * check for empty rect
     */
    if (prcDst->left < prcDst->right) {

        prcDst->top = max(prcSrc1->top, prcSrc2->top);
        prcDst->bottom = min(prcSrc1->bottom, prcSrc2->bottom);

        /*
         * check for empty rect
         */
        if (prcDst->top < prcDst->bottom) {
            return TRUE;        // not empty
        }
    }

    /*
     * empty rect
     */
    SetRectEmpty(prcDst);

    return FALSE;
}

/********************************************************************\
* UnionRect (API)
*
* This function calculates a rect that bounds *prcSrc1 and
* *prcSrc2, returning the result in *prcDst.  If either
* *prcSrc1 or *prcSrc2 are empty, then the other rect is
* returned.  Returns TRUE if *prcDst is a non-empty rect,
* FALSE otherwise.
*
* History:
* 10-20-90 DarrinM      Translated from PMese to Windowses.
\*******************************************************************/

BOOL APIENTRY UnionRect(
    LPRECT prcDst,
    CONST RECT *prcSrc1,
    CONST RECT *prcSrc2)
{
    BOOL frc1Empty, frc2Empty;

    VALIDATERECT(prcDst, FALSE);
    VALIDATERECT(prcSrc1, FALSE);
    VALIDATERECT(prcSrc2, FALSE);

    frc1Empty = ((prcSrc1->left >= prcSrc1->right) ||
            (prcSrc1->top >= prcSrc1->bottom));

    frc2Empty = ((prcSrc2->left >= prcSrc2->right) ||
            (prcSrc2->top >= prcSrc2->bottom));

    if (frc1Empty && frc2Empty) {
        SetRectEmpty(prcDst);
        return FALSE;
    }

    if (frc1Empty) {
        *prcDst = *prcSrc2;
        return TRUE;
    }

    if (frc2Empty) {
        *prcDst = *prcSrc1;
        return TRUE;
    }

    /*
     * form the union of the two non-empty rects
     */
    prcDst->left   = min(prcSrc1->left,   prcSrc2->left);
    prcDst->top    = min(prcSrc1->top,    prcSrc2->top);
    prcDst->right  = max(prcSrc1->right,  prcSrc2->right);
    prcDst->bottom = max(prcSrc1->bottom, prcSrc2->bottom);

    return TRUE;
}

/********************************************************************\
* EqualRect (API)
*
* This function returns TRUE if *prc1 and *prc2 are identical,
* FALSE otherwise.
*
* History:
* 10-20-90 DarrinM      Translated from PMese to Windowses.
\*****************************************************************/

#undef EqualRect     // don't let macro interfere with API
BOOL APIENTRY EqualRect(
    CONST RECT *prc1,
    CONST RECT *prc2)
{
    VALIDATERECT(prc1, FALSE);
    VALIDATERECT(prc2, FALSE);

    /*
     * Test equality only. This is what win31 does. win31 does not check to
     * see if the rectangles are "empty" first.
     */
    return RtlEqualMemory(prc1, prc2, sizeof(RECT));
}

/**********************************************************************\
* SubtractRect (API)
*
* This function subtracts *prc2 from *prc1, returning the result in *prcDst
* Returns FALSE if *lprDst is empty, TRUE otherwise.
*
* Warning:
*   Subtracting one rect from another may not always result in a
*   rectangular area; in this case SubtractRect will return *prc1 in
*   *prcDst.  For this reason, SubractRect provides only an
*   approximation of subtraction.  However, the area described by
*   *prcDst will always be greater than or equal to the "true" result
*   of the subtraction.
*
* History:
* 10-20-90 DarrinM      Translated from PMese to Windowsese.
\**********************************************************************/

BOOL APIENTRY SubtractRect(
    LPRECT prcDst,
    CONST RECT *prcSrc1,
    CONST RECT *prcSrc2)
{
    int cSidesOut;
    BOOL fIntersect;
    RECT rcInt;

    VALIDATERECT(prcDst, FALSE);
    VALIDATERECT(prcSrc1, FALSE);
    VALIDATERECT(prcSrc2, FALSE);

    fIntersect = IntersectRect(&rcInt, prcSrc1, prcSrc2);

    /*
     * this is done after the intersection in case prcDst is the same
     * pointer as prcSrc2
     */
    *prcDst = *prcSrc1;

    if (fIntersect) {
        /*
         * exactly any 3 sides of prc2 must be outside prc1 to subtract
         */
        cSidesOut = 0;
        if (rcInt.left   <= prcSrc1->left)
            cSidesOut++;
        if (rcInt.top    <= prcSrc1->top)
            cSidesOut++;
        if (rcInt.right  >= prcSrc1->right)
            cSidesOut++;
        if (rcInt.bottom >= prcSrc1->bottom)
            cSidesOut++;

        if (cSidesOut == 4) {
            /*
             * result is the empty rect
             */
             SetRectEmpty(prcDst);
             return FALSE;
        }

        if (cSidesOut == 3) {
            /*
             * subtract the intersecting rect
             */
            if (rcInt.left > prcSrc1->left)
                prcDst->right = rcInt.left;

            else if (rcInt.right < prcSrc1->right)
                prcDst->left = rcInt.right;

            else if (rcInt.top > prcSrc1->top)
                prcDst->bottom = rcInt.top;

            else if (rcInt.bottom < prcSrc1->bottom)
                prcDst->top = rcInt.bottom;
        }
    }

    if ((prcDst->left >= prcDst->right) || (prcDst->top >= prcDst->bottom))
        return FALSE;

    return TRUE;
}

/************************************************************************\
* CopyRect (API)
*
* This function copies the rect from prcSrc to prcDst.
*
* History:
* 10-20-90 DarrinM      Translated from PMese to Windowses.
\************************************************************************/

#undef CopyRect     // don't let macro interfere with API
BOOL APIENTRY CopyRect(
    LPRECT prcDst,
    CONST RECT *prcSrc)
{
    VALIDATERECT(prcDst, FALSE);
    VALIDATERECT(prcSrc, FALSE);

    *prcDst = *prcSrc;
    return TRUE;
}


/************************************************************************\
* SetRectEmpty (API)
*
* This fuction sets *prc to an empty rect by setting each field to 0.
* Equivalent to SetRect(prc, 0, 0, 0, 0).
*
* History:
* 10-20-90 DarrinM      Translated from PMese to Windowses.
\************************************************************************/

#undef SetRectEmpty     // don't let macro interfere with API
BOOL APIENTRY SetRectEmpty(
    LPRECT prc)
{
    VALIDATERECT(prc, FALSE);

    RtlZeroMemory(prc, sizeof(RECT));
    return TRUE;
}


#if 0

/***************************************************************************\
* RECTFromSIZERECT
*
* This function converts a SIZERECT to a RECT.
*
* History:
* 24-Sep-1996 adams     Created.
\***************************************************************************/

void
RECTFromSIZERECT(PRECT prc, PCSIZERECT psrc)
{
    prc->left = psrc->x;
    prc->top = psrc->y;
    prc->right = psrc->x + psrc->cx;
    prc->bottom = psrc->y + psrc->cy;
}


/***************************************************************************\
* SIZERECTFromRECT
* 
* Converts a RECT to a SIZERECT.
* 
* History:
* 09-May-1997 adams     Created.
\***************************************************************************/

void
SIZERECTFromRECT(PSIZERECT psrc, LPCRECT prc)
{
    psrc->x = prc->left;
    psrc->y = prc->top;
    psrc->cx = prc->right - prc->left;
    psrc->cy = prc->bottom - prc->top;
}

#endif // 0
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\sources.inc ===
!IF 0

Copyright (c) 1999  Microsoft Corporation

Module Name:

    sources

Abstract:

    Specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

MAJORCOMP=ntos
MINORCOMP=Xapi

TARGETTYPE=LIBRARY
UMTYPE=xbox

INCLUDES=..;..\..\inc;$(BASEDIR)\private\ntos\inc;$(BASEDIR)\private\inc\crypto;$(DDK_INC_PATH)

C_DEFINES=$(C_DEFINES) -D_XAPI_
MSC_WARNING_LEVEL=/W3 /WX

PRECOMPILED_INCLUDE=..\basedll.h
PRECOMPILED_PCH=basedll.pch
PRECOMPILED_OBJ=basedll.obj
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\thread.c ===
/*++

Copyright (c) 1990-2001  Microsoft Corporation

Module Name:

    thread.c

Abstract:

    This module implements Win32 Thread Object APIs

--*/

#include "basedll.h"
#pragma hdrstop

//
// Number of bytes that need to be allocated for thread local storage.
//
ULONG XapiTlsSize;

//
// General critical section used to guard XAPI data structures.
//
INITIALIZED_CRITICAL_SECTION(XapiProcessLock);

//
// List of routines to be notified at thread creation and deletion.  Access is
// guarded by the XapiProcessLock.
//
INITIALIZED_LIST_ENTRY(XapiThreadNotifyRoutineList);

//
// Top level Win32 exception filter implemented by the title.
//
LPTOP_LEVEL_EXCEPTION_FILTER XapiCurrentTopLevelFilter;

VOID
XapiCallThreadNotifyRoutines(
    BOOL Create
    )

/*++

Routine Description:

    Calls the registered thread notification routines when the active thread is
    created or deleted.

Arguments:

    Create - TRUE if the active thread has been created, else FALSE if the
        active thread is to be deleted.

Return Value:

    None.

--*/

{
    PLIST_ENTRY NextListEntry;
    PXTHREAD_NOTIFICATION ThreadNotification;

    XapiAcquireProcessLock();

    NextListEntry = XapiThreadNotifyRoutineList.Flink;

    while (NextListEntry != &XapiThreadNotifyRoutineList) {

        ThreadNotification = CONTAINING_RECORD(NextListEntry,
            XTHREAD_NOTIFICATION, ListEntry);
        NextListEntry = ThreadNotification->ListEntry.Flink;

        ThreadNotification->pfnNotifyRoutine(Create);
    }

    XapiReleaseProcessLock();
}

LONG
WINAPI
UnhandledExceptionFilter(
    IN PEXCEPTION_POINTERS ExceptionPointers
    )

/*++

Routine Description:

    Exception filter for exceptions that don't get handled before the
    top-level handler. This filter always spews debug info and passes
    on the exception to the exception handler.

Arguments:

    ExceptionPointers - Exception information

Return Value:

    EXCEPTION_EXECUTE_HANDLER - passes on control to the handler

--*/

{
#if DBG
    DbgPrint("Unhandled XAPI Exception. Exception Pointers = 0x%p\n", ExceptionPointers);
    DbgPrint("Code %x Addr %p\nInfo0 %p Info1 %p Info2 %p Info3 %p\n",
        ExceptionPointers->ExceptionRecord->ExceptionCode,
        (ULONG_PTR)ExceptionPointers->ExceptionRecord->ExceptionAddress,
        ExceptionPointers->ExceptionRecord->ExceptionInformation[0],
        ExceptionPointers->ExceptionRecord->ExceptionInformation[1],
        ExceptionPointers->ExceptionRecord->ExceptionInformation[2],
        ExceptionPointers->ExceptionRecord->ExceptionInformation[3]
        );
#endif // DBG

    if ( XapiCurrentTopLevelFilter )
    {
        LONG FilterReturn = (XapiCurrentTopLevelFilter)(ExceptionPointers);
        if ( FilterReturn == EXCEPTION_CONTINUE_EXECUTION )
        {
            return EXCEPTION_CONTINUE_EXECUTION;
        }
    }

    return EXCEPTION_CONTINUE_SEARCH;
}

VOID
XapiThreadStartup(
    IN PKSTART_ROUTINE StartRoutine,
    IN PVOID StartContext
    )

/*++

Routine Description:

    Called by the kernel on thread startup. We set up the default exception handler
    and a data structure to keep track of Xapi data.

Arguments:

    StartRoutine - address the thread should be started at.

    StartContext - an LPVOID pointer passed in to CreateThread to pass on to the thread.

Return Value:

    None.

--*/

{
    DWORD dwExitCode;

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    try
    {
        /* Need to set up the TLS data */
        PULONG TlsData;
        DWORD RawDataSize;

        ASSERT(KeGetCurrentThread()->TlsData);

#if DBG
        /* First make sure the TLS data is where we think it should be */
        ASSERT((ULONG_PTR)KeGetCurrentThread()->TlsData -
            (ULONG_PTR)KeGetCurrentTlsDataTop() == *((PULONG)_tls_used.AddressOfIndex) * 4);
#endif

        /* Need to fill the first slot with a pointer to the remainder */
        TlsData = (PULONG)KeGetCurrentThread()->TlsData + 1;
        TlsData[-1] = (ULONG_PTR)TlsData;

        /* Ensure 16-byte alignment */
        ASSERT(((ULONG_PTR)TlsData & 15) == 0);

        RawDataSize = _tls_used.EndAddressOfRawData - _tls_used.StartAddressOfRawData;

        RtlCopyMemory(TlsData, (PVOID)_tls_used.StartAddressOfRawData,
            RawDataSize);

        if (_tls_used.SizeOfZeroFill != 0) {
            RtlZeroMemory((PBYTE)TlsData + RawDataSize, _tls_used.SizeOfZeroFill);
        }

        XapiCallThreadNotifyRoutines(TRUE);

        dwExitCode = (*(LPTHREAD_START_ROUTINE)StartRoutine)(StartContext);

        XapiCallThreadNotifyRoutines(FALSE);
    }
    except (UnhandledExceptionFilter(GetExceptionInformation()))
    {
        //
        // UnhandledExceptionFilter will return either EXCEPTION_CONTINUE_SEARCH,
        // in which case, the exception search will stop since we're the top of
        // the exception stack, or it will return EXCEPTION_CONTINUE_EXECUTION.
        // We'll never execute this handler.
        //

        ASSERT(FALSE);
    }

    PsTerminateSystemThread(dwExitCode);
}

HANDLE
APIENTRY
CreateThread(
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    DWORD dwStackSize,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    DWORD dwCreationFlags,
    LPDWORD lpThreadId
    )

/*++

Routine Description:

    A thread object can be created to execute within the address space of the
    calling process using CreateThread.

    Creating a thread causes a new thread of execution to begin in the address
    space of the current process. The thread has access to all objects opened
    by the process.

    The thread begins executing at the address specified by the StartAddress
    parameter. If the thread returns from this procedure, the results are
    un-specified.

    The thread remains in the system until it has terminated and
    all handles to the thread
    have been closed through a call to CloseHandle.

    When a thread terminates, it attains a state of signaled satisfying all
    waits on the object.

    In addition to the STANDARD_RIGHTS_REQUIRED access flags, the following
    object type specific access flags are valid for thread objects:

        - THREAD_QUERY_INFORMATION - This access is required to read
          certain information from the thread object.

        - SYNCHRONIZE - This access is required to wait on a thread
          object.

        - THREAD_GET_CONTEXT - This access is required to read the
          context of a thread using GetThreadContext.

        - THREAD_SET_CONTEXT - This access is required to write the
          context of a thread using SetThreadContext.

        - THREAD_SUSPEND_RESUME - This access is required to suspend or
          resume a thread using SuspendThread or ResumeThread.

        - THREAD_ALL_ACCESS - This set of access flags specifies all of
          the possible access flags for a thread object.

Arguments:

    hProcess - Supplies the handle to the process in which the thread is
        to be create in.

    lpThreadAttributes - An optional parameter that may be used to specify
        the attributes of the new thread.  If the parameter is not
        specified, then the thread is created without a security
        descriptor, and the resulting handle is not inherited on process
        creation.

    dwStackSize - Supplies the size in bytes of the stack for the new thread.
        A value of zero specifies that the thread's stack size should be
        the same size as the stack size of the first thread in the process.
        This size is specified in the application's executable file.

    lpStartAddress - Supplies the starting address of the new thread.  The
        address is logically a procedure that never returns and that
        accepts a single 32-bit pointer argument.

    lpParameter - Supplies a single parameter value passed to the thread.

    dwCreationFlags - Supplies additional flags that control the creation
        of the thread.

        dwCreationFlags Flags:

        CREATE_SUSPENDED - The thread is created in a suspended state.
            The creator can resume this thread using ResumeThread.
            Until this is done, the thread will not begin execution.

    lpThreadId - Returns the thread identifier of the thread.  The
        thread ID is valid until the thread terminates.

Return Value:

    NON-NULL - Returns a handle to the new thread.  The handle has full
        access to the new thread and may be used in any API that
        requires a handle to a thread object.

    NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    HANDLE Handle;

    if (dwStackSize == 0) {
        dwStackSize = XeImageHeader()->SizeOfStackCommit;
    }

    Status = PsCreateSystemThreadEx(
                &Handle,
                0,
                dwStackSize,
                XapiTlsSize,
                (PHANDLE)lpThreadId,
                (PKSTART_ROUTINE)lpStartAddress,
                lpParameter,
                (BOOLEAN)((dwCreationFlags & CREATE_SUSPENDED) ? TRUE : FALSE),
                FALSE,
                (PKSYSTEM_ROUTINE)XapiThreadStartup
                );

    if (!NT_SUCCESS(Status) && XapiIsXapiThread()) {
        XapiSetLastNTError(Status);
        return NULL;
    }

    return Handle;
}

BOOL
APIENTRY
SetThreadPriority(
    HANDLE hThread,
    int nPriority
    )

/*++

Routine Description:

    The specified thread's priority can be set using SetThreadPriority.

    A thread's priority may be set using SetThreadPriority.  This call
    allows the thread's relative execution importance to be communicated
    to the system.  The system normally schedules threads according to
    their priority.  The system is free to temporarily boost the
    priority of a thread when signifigant events occur (e.g.  keyboard
    or mouse input...).  Similarly, as a thread runs without blocking,
    the system will decay its priority.  The system will never decay the
    priority below the value set by this call.

    In the absence of system originated priority boosts, threads will be
    scheduled in a round-robin fashion at each priority level from
    THREAD_PRIORITY_TIME_CRITICAL to THREAD_PRIORITY_IDLE.  Only when there
    are no runnable threads at a higher level, will scheduling of
    threads at a lower level take place.

    All threads initially start at THREAD_PRIORITY_NORMAL.

    If for some reason the thread needs more priority, it can be
    switched to THREAD_PRIORITY_ABOVE_NORMAL or THREAD_PRIORITY_HIGHEST.
    Switching to THREAD_PRIORITY_TIME_CRITICAL should only be done in extreme
    situations.  Since these threads are given the highes priority, they
    should only run in short bursts.  Running for long durations will
    soak up the systems processing bandwidth starving threads at lower
    levels.

    If a thread needs to do low priority work, or should only run there
    is nothing else to do, its priority should be set to
    THREAD_PRIORITY_BELOW_NORMAL or THREAD_PRIORITY_LOWEST.  For extreme
    cases, THREAD_PRIORITY_IDLE can be used.

    Care must be taken when manipulating priorites.  If priorities are
    used carelessly (every thread is set to THREAD_PRIORITY_TIME_CRITICAL),
    the effects of priority modifications can produce undesireable
    effects (e.g.  starvation, no effect...).

Arguments:

    hThread - Supplies a handle to the thread whose priority is to be
        set.  The handle must have been created with
        THREAD_SET_INFORMATION access.

    nPriority - Supplies the priority value for the thread.  The
        following five priority values (ordered from lowest priority to
        highest priority) are allowed.

        nPriority Values:

        THREAD_PRIORITY_IDLE - The thread's priority should be set to
            the lowest possible settable priority.

        THREAD_PRIORITY_LOWEST - The thread's priority should be set to
            the next lowest possible settable priority.

        THREAD_PRIORITY_BELOW_NORMAL - The thread's priority should be
            set to just below normal.

        THREAD_PRIORITY_NORMAL - The thread's priority should be set to
            the normal priority value.  This is the value that all
            threads begin execution at.

        THREAD_PRIORITY_ABOVE_NORMAL - The thread's priority should be
            set to just above normal priority.

        THREAD_PRIORITY_HIGHEST - The thread's priority should be set to
            the next highest possible settable priority.

        THREAD_PRIORITY_TIME_CRITICAL - The thread's priority should be set
            to the highest possible settable priority.  This priority is
            very likely to interfere with normal operation of the
            system.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.
--*/

{
    NTSTATUS Status;
    LONG BasePriority;
    PETHREAD Thread;

    Status = ObReferenceObjectByHandle(hThread,
                                       PsThreadObjectType,
                                       (PVOID *)&Thread);

    if (NT_SUCCESS(Status)) {

        BasePriority = (LONG)nPriority;
        if (BasePriority == THREAD_PRIORITY_TIME_CRITICAL) {
            BasePriority = ((HIGH_PRIORITY + 1) / 2);
        } else if (BasePriority == THREAD_PRIORITY_IDLE) {
            BasePriority = -((HIGH_PRIORITY + 1) / 2);
        }

        KeSetBasePriorityThread(&Thread->Tcb, BasePriority);
        ObDereferenceObject(Thread);
        return TRUE;
    } else {
        XapiSetLastNTError(Status);
        return FALSE;
    }
}

int
APIENTRY
GetThreadPriority(
    HANDLE hThread
    )

/*++

Routine Description:

    The specified thread's priority can be read using GetThreadPriority.

Arguments:

    hThread - Supplies a handle to the thread whose priority is to be
        set.  The handle must have been created with
        THREAD_QUERY_INFORMATION access.

Return Value:

    The value of the thread's current priority is returned.  If an error
    occured, the value THREAD_PRIORITY_ERROR_RETURN is returned.
    Extended error status is available using GetLastError.

--*/

{
    NTSTATUS Status;
    PETHREAD Thread;
    int returnvalue;

    Status = ObReferenceObjectByHandle(hThread,
                                       PsThreadObjectType,
                                       (PVOID *)&Thread);

    if (NT_SUCCESS(Status)) {

        returnvalue = (int)KeQueryBasePriorityThread(&Thread->Tcb);
        if (returnvalue == ((HIGH_PRIORITY + 1) / 2)) {
            returnvalue = THREAD_PRIORITY_TIME_CRITICAL;
        } else if (returnvalue == -((HIGH_PRIORITY + 1) / 2)) {
            returnvalue = THREAD_PRIORITY_IDLE;
        }

        ObDereferenceObject(Thread);
        return returnvalue;
    } else {
        XapiSetLastNTError(Status);
        return (int)THREAD_PRIORITY_ERROR_RETURN;
    }
}

BOOL
WINAPI
SetThreadPriorityBoost(
    HANDLE hThread,
    BOOL bDisablePriorityBoost
    )
{
    NTSTATUS Status;
    PETHREAD Thread;

    Status = ObReferenceObjectByHandle(hThread,
                                       PsThreadObjectType,
                                       (PVOID *)&Thread);

    if (NT_SUCCESS(Status)) {
        KeSetDisableBoostThread(&Thread->Tcb, bDisablePriorityBoost ? TRUE : FALSE);
        ObDereferenceObject(Thread);
        return TRUE;
    } else {
        XapiSetLastNTError(Status);
        return FALSE;
    }
}

BOOL
WINAPI
GetThreadPriorityBoost(
    HANDLE hThread,
    PBOOL pDisablePriorityBoost
    )
{
    NTSTATUS Status;
    PETHREAD Thread;

    Status = ObReferenceObjectByHandle(hThread,
                                       PsThreadObjectType,
                                       (PVOID *)&Thread);

    if (NT_SUCCESS(Status)) {
        *pDisablePriorityBoost = Thread->Tcb.DisableBoost ? TRUE : FALSE;
        ObDereferenceObject(Thread);
        return TRUE;
    } else {
        XapiSetLastNTError(Status);
        return FALSE;
    }
}

DWORD
APIENTRY
GetCurrentThreadId(
    VOID
    )

/*++

Routine Description:

    The thread ID of the current thread may be retrieved using
    GetCurrentThreadId.

Arguments:

    None.

Return Value:

    Returns a unique value representing the thread ID of the currently
    executing thread.  The return value may be used to identify a thread
    in the system.

--*/

{
    return HandleToUlong(PsGetCurrentThreadId());
}

DWORD
APIENTRY
SuspendThread(
    HANDLE hThread
    )

/*++

Routine Description:

    A thread can be suspended using SuspendThread.

    Suspending a thread causes the thread to stop executing user-mode
    (or application) code.  Each thread has a suspend count (with a
    maximum value of MAXIMUM_SUSPEND_COUNT).  If the suspend count is
    greater than zero, the thread is suspended; otherwise, the thread is
    not suspended and is eligible for execution.

    Calling SuspendThread causes the target thread's suspend count to
    increment.  Attempting to increment past the maximum suspend count
    causes an error without incrementing the count.

Arguments:

    hThread - Supplies a handle to the thread that is to be suspended.
        The handle must have been created with THREAD_SUSPEND_RESUME
        access to the thread.

Return Value:

    -1 - The operation failed.  Extended error status is available using
         GetLastError.

    Other - The target thread was suspended. The return value is the thread's
        previous suspend count.

--*/

{
    NTSTATUS Status;
    DWORD PreviousSuspendCount;

    Status = NtSuspendThread(hThread,&PreviousSuspendCount);

    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        return (DWORD)-1;
        }
    else {
        return PreviousSuspendCount;
        }
}

DWORD
APIENTRY
ResumeThread(
    IN HANDLE hThread
    )

/*++

Routine Description:

    A thread can be resumed using ResumeThread.

    Resuming a thread object checks the suspend count of the subject
    thread.  If the suspend count is zero, then the thread is not
    currently suspended and no operation is performed.  Otherwise, the
    subject thread's suspend count is decremented.  If the resultant
    value is zero , then the execution of the subject thread is resumed.

    The previous suspend count is returned as the function value.  If
    the return value is zero, then the subject thread was not previously
    suspended.  If the return value is one, then the subject thread's
    the subject thread is still suspended and must be resumed the number
    of times specified by the return value minus one before it will
    actually resume execution.

    Note that while reporting debug events, all threads withing the
    reporting process are frozen.  This has nothing to do with
    SuspendThread or ResumeThread.  Debuggers are expected to use
    SuspendThread and ResumeThread to limit the set of threads that can
    execute within a process.  By suspending all threads in a process
    except for the one reporting a debug event, it is possible to
    "single step" a single thread.  The other threads will not be
    released by a continue if they are suspended.

Arguments:

    hThread - Supplies a handle to the thread that is to be resumed.
        The handle must have been created with THREAD_SUSPEND_RESUME
        access to the thread.

Return Value:

    -1 - The operation failed.  Extended error status is available using
        GetLastError.

    Other - The target thread was resumed (or was not previously
        suspended).  The return value is the thread's previous suspend
        count.

--*/

{
    NTSTATUS Status;
    DWORD PreviousSuspendCount;

    Status = NtResumeThread(hThread,&PreviousSuspendCount);

    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        return (DWORD)-1;
        }
    else {
        return PreviousSuspendCount;
        }
}

VOID
APIENTRY
RaiseException(
    DWORD dwExceptionCode,
    DWORD dwExceptionFlags,
    DWORD nNumberOfArguments,
    CONST ULONG_PTR *lpArguments
    )

/*++

Routine Description:

    Raising an exception causes the exception dispatcher to go through
    its search for an exception handler.  This includes debugger
    notification, frame based handler searching, and system default
    actions.

Arguments:

    dwExceptionCode - Supplies the exception code of the exception being
        raised.  This value may be obtained in exception filters and in
        exception handlers by calling GetExceptionCode.

    dwExceptionFlags - Supplies a set of flags associated with the exception.

    dwExceptionFlags Flags:

        EXCEPTION_NONCONTINUABLE - The exception is non-continuable.
            Returning EXCEPTION_CONTINUE_EXECUTION from an exception
            marked in this way causes the
            STATUS_NONCONTINUABLE_EXCEPTION exception.

    nNumberOfArguments - Supplies the number of arguments associated
        with the exception.  This value may not exceed
        EXCEPTION_MAXIMUM_PARAMETERS.  This parameter is ignored if
        lpArguments is NULL.

    lpArguments - An optional parameter, that if present supplies the
        arguments for the exception.

Return Value:

    None.

--*/

{
    EXCEPTION_RECORD ExceptionRecord;
    ULONG n;
    PULONG_PTR s,d;
    ExceptionRecord.ExceptionCode = (DWORD)dwExceptionCode;
    ExceptionRecord.ExceptionFlags = dwExceptionFlags & EXCEPTION_NONCONTINUABLE;
    ExceptionRecord.ExceptionRecord = NULL;
    ExceptionRecord.ExceptionAddress = (PVOID)RaiseException;
    if ( ARGUMENT_PRESENT(lpArguments) ) {
        n =  nNumberOfArguments;
        if ( n > EXCEPTION_MAXIMUM_PARAMETERS ) {
            n = EXCEPTION_MAXIMUM_PARAMETERS;
            }
        ExceptionRecord.NumberParameters = n;
        s = (PULONG_PTR)lpArguments;
        d = ExceptionRecord.ExceptionInformation;
        while(n--){
            *d++ = *s++;
            }
        }
    else {
        ExceptionRecord.NumberParameters = 0;
        }
    RtlRaiseException(&ExceptionRecord);
}

VOID
XapiDispatchAPC(
    LPVOID lpApcArgument1,
    LPVOID lpApcArgument2,
    LPVOID lpApcArgument3
    )
{
    PAPCFUNC pfnAPC;
    ULONG_PTR dwData;

    pfnAPC = (PAPCFUNC)lpApcArgument1;
    dwData = (ULONG_PTR)lpApcArgument2;
    (pfnAPC)(dwData);
}


WINBASEAPI
DWORD
WINAPI
QueueUserAPC(
    PAPCFUNC pfnAPC,
    HANDLE hThread,
    ULONG_PTR dwData
    )
/*++

Routine Description:

    This function is used to queue a user-mode APC to the specified thread. The APC
    will fire when the specified thread does an alertable wait.

Arguments:

    pfnAPC - Supplies the address of the APC routine to execute when the
        APC fires.

    hHandle - Supplies a handle to a thread object.  The caller
        must have THREAD_SET_CONTEXT access to the thread.

    dwData - Supplies a DWORD passed to the APC

Return Value:

    TRUE - The operations was successful

    FALSE - The operation failed. GetLastError() is not defined.

--*/

{
    NTSTATUS Status;

    Status = NtQueueApcThread(
                hThread,
                (PPS_APC_ROUTINE)XapiDispatchAPC,
                (PVOID)pfnAPC,
                (PVOID)dwData,
                NULL
                );

    if ( !NT_SUCCESS(Status) ) {
        return 0;
        }
    return 1;
}

BOOL
WINAPI
SwitchToThread(
    VOID
    )

/*++

Routine Description:

    This function causes a yield from the running thread to any other
    thread that is ready and can run on the current processor.  The
    yield will be effective for up to one quantum and then the yielding
    thread will be scheduled again according to its priority and
    whatever other threads may also be avaliable to run.  The thread
    that yields will not bounce to another processor even it another
    processor is idle or running a lower priority thread.

Arguments:

    None

Return Value:

    TRUE - Calling this function caused a switch to another thread to occur
    FALSE - There were no other ready threads, so no context switch occured

--*/

{

    if ( NtYieldExecution() == STATUS_NO_YIELD_PERFORMED ) {
        return FALSE;
        }
    else {
        return TRUE;
        }
}

VOID
APIENTRY
ExitThread(
    DWORD dwExitCode
    )

/*++

Routine Description:

    The current thread can exit using ExitThread.

    ExitThread is the prefered method of exiting a thread.  When this
    API is called (either explicitly or by returning from a thread
    procedure), The current thread's stack is deallocated and the thread
    terminates.  If the thread is the last thread in the process when
    this API is called, the behavior of this API does not change.  DLLs
    are not notified as a result of a call to ExitThread.

Arguments:

    dwExitCode - Supplies the termination status for the thread.

Return Value:

    None.

--*/

{
    XapiCallThreadNotifyRoutines(FALSE);

    PsTerminateSystemThread(dwExitCode);
}

BOOL
APIENTRY
GetExitCodeThread(
    HANDLE hThread,
    LPDWORD lpExitCode
    )

/*++

Routine Description:

    The termination status of a thread can be read using
    GetExitCodeThread.

    If a Thread is in the signaled state, calling this function returns
    the termination status of the thread.  If the thread is not yet
    signaled, the termination status returned is STILL_ACTIVE.

Arguments:

    hThread - Supplies a handle to the thread whose termination status is
        to be read.  The handle must have been created with
        THREAD_QUERY_INFORMATION access.

    lpExitCode - Returns the current termination status of the
        thread.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    PETHREAD Thread;

    Status = ObReferenceObjectByHandle(hThread,
                                       PsThreadObjectType,
                                       (PVOID *)&Thread);

    if (NT_SUCCESS(Status)) {
        *lpExitCode = KeReadStateThread(&Thread->Tcb) ? Thread->ExitStatus : STATUS_PENDING;
        ObDereferenceObject(Thread);
        return TRUE;
    } else {
        XapiSetLastNTError(Status);
        return FALSE;
    }
}

LPTOP_LEVEL_EXCEPTION_FILTER
WINAPI
SetUnhandledExceptionFilter(
    LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter
    )

/*++

Routine Description:

    This function allows an application to supersede the top level
    exception handler that Win32 places at the top of each thread and
    process.

    If an exception occurs, and it makes it to the Win32 unhandled
    exception filter, and the process is not being debugged, the Win32
    filter will call the unhandled exception filter specified by
    lpTopLevelExceptionFilter.

    This filter may return:

        EXCEPTION_EXECUTE_HANDLER - Return from the Win32
            UnhandledExceptionFilter and execute the associated
            exception handler.  This will usually result in process
            termination

        EXCEPTION_CONTINUE_EXECUTION - Return from the Win32
            UnhandledExceptionFilter and continue execution from the
            point of the exception.  The filter is of course free to
            modify the continuation state my modifying the passed
            exception information.

        EXCEPTION_CONTINUE_SEARCH - Proceed with normal execution of the
            Win32 UnhandledExceptionFilter.  e.g.  obey the SetErrorMode
            flags, or invoke the Application Error popup.

    This function is not a general vectored exception handling
    mechanism.  It is intended to be used to establish a per-process
    exception filter that can monitor unhandled exceptions at the
    process level and respond to these exceptions appropriately.

Arguments:

    lpTopLevelExceptionFilter - Supplies the address of a top level
        filter function that will be called whenever the Win32
        UnhandledExceptionFilter gets control, and the process is NOT
        being debugged.  A value of NULL specifies default handling
        within the Win32 UnhandledExceptionFilter.

Return Value:

    This function returns the address of the previous exception filter
    established with this API.  A value of NULL means that there is no
    current top level handler.

--*/

{
    LPTOP_LEVEL_EXCEPTION_FILTER PreviousTopLevelFilter;

    PreviousTopLevelFilter = XapiCurrentTopLevelFilter;
    XapiCurrentTopLevelFilter = lpTopLevelExceptionFilter;

    return PreviousTopLevelFilter;
}

BOOL
WINAPI
GetThreadTimes(
    HANDLE hThread,
    LPFILETIME lpCreationTime,
    LPFILETIME lpExitTime,
    LPFILETIME lpKernelTime,
    LPFILETIME lpUserTime
    )

/*++

Routine Description:

    This function is used to return various timing information about the
    thread specified by hThread.

    All times are in units of 100ns increments. For lpCreationTime and lpExitTime,
    the times are in terms of the SYSTEM time or GMT time.

Arguments:

    hThread - Supplies an open handle to the specified thread.  The
        handle must have been created with THREAD_QUERY_INFORMATION
        access.

    lpCreationTime - Returns a creation time of the thread.

    lpExitTime - Returns the exit time of a thread.  If the thread has
        not exited, this value is not defined.

    lpKernelTime - Returns the amount of time that this thread has
        executed in kernel-mode.

    lpUserTime - Returns the amount of time that this thread has
        executed in user-mode.


Return Value:

    TRUE - The API was successful

    FALSE - The operation failed.  Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    PETHREAD Thread;

    Status = ObReferenceObjectByHandle(hThread,
                                       PsThreadObjectType,
                                       (PVOID *)&Thread);

    if (NT_SUCCESS(Status)) {

        *((PLARGE_INTEGER)lpCreationTime) = Thread->CreateTime;

        if (KeReadStateThread(&Thread->Tcb)) {
            *((PLARGE_INTEGER)lpExitTime) = Thread->ExitTime;
        } else {
            ((PLARGE_INTEGER)lpExitTime)->QuadPart = 0;
        }

        ((PLARGE_INTEGER)lpKernelTime)->QuadPart = UInt32x32To64(Thread->Tcb.KernelTime,
            *KeTimeIncrement);
        ((PLARGE_INTEGER)lpUserTime)->QuadPart = 0;

        ObDereferenceObject(Thread);
        return TRUE;
    } else {
        XapiSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

XBOXAPI
VOID
WINAPI
XRegisterThreadNotifyRoutine(
    PXTHREAD_NOTIFICATION pThreadNotification,
    BOOL fRegister
    )

/*++

Routine Description:

    Register or deregister a notification routine
    which will be called when a thread is created or deleted.

Arguments:

    pThreadNotification - Points to a XTHREAD_NOTIFICATION structure
        NOTE: The XTHREAD_NOTIFICATION structure must remain
        valid until the thread notification routine is deregistered.
        For example, you can use a global variable for this.
        But you should NOT use a local variable inside a function.

    fRegister - TRUE to register a new thread notification routine
        FALSE to deregister a previously registered notification routine

Return Value:

    None.

--*/

{
    XapiAcquireProcessLock();

    if (fRegister) {
        InsertTailList(&XapiThreadNotifyRoutineList,
            &pThreadNotification->ListEntry);
    } else {
        RemoveEntryList(&pThreadNotification->ListEntry);
    }

    XapiReleaseProcessLock();
}

XBOXAPI
VOID
XSetProcessQuantumLength(
    IN DWORD dwMilliseconds
    )

/*++

Routine Description:

    This routine changes the quantum length for the current process.  Changing
    the quantum length does not affect the quantum of the current thread.

    The quantum length determines the number of milliseconds that a thread is
    executed before the scheduler selects the next ready thread to execute.

Arguments:

    dwMilliseconds - Supplies the number of milliseconds for the process quantum
        length.

Return Value:

    None.

--*/

{
    LONG ThreadQuantum;

    if (dwMilliseconds == 0 || dwMilliseconds > 1000) {
        RIP("XSetProcessQuantumSize() invalid parameter (dwMilliseconds)");
    }

    ThreadQuantum = dwMilliseconds * CLOCK_QUANTUM_DECREMENT;
    KeGetCurrentThread()->ApcState.Process->ThreadQuantum = ThreadQuantum;
}

XBOXAPI
DWORD
XGetProcessQuantumLength(
    VOID
    )

/*++

Routine Description:

    This routine returns the quantum length for the current process.

    The quantum length determines the number of milliseconds that a thread is
    executed before the scheduler selects the next ready thread to execute.

Arguments:

    None.

Return Value:

    Returns the number of milliseconds for the process quantum length.

--*/

{
    LONG ThreadQuantum;

    ThreadQuantum = KeGetCurrentThread()->ApcState.Process->ThreadQuantum;

    return ThreadQuantum / CLOCK_QUANTUM_DECREMENT;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\tls.c ===
/*++

Copyright (c) 1990-2001  Microsoft Corporation

Module Name:

    thread.c

Abstract:

    This module implements Win32 Thread Local Storage APIs

--*/

#include "basedll.h"
#pragma hdrstop

//
// Array of per thread TLS slots.
//
__declspec(thread) PVOID XapiTlsSlots[TLS_MINIMUM_AVAILABLE];

//
// Bitmap of the allocated TLS slots.
//
ULONG XapiTlsAllocBitmap[TLS_MINIMUM_AVAILABLE / 32] = {
    0xFFFFFFFF
};

DWORD
APIENTRY
TlsAlloc(
    VOID
    )
/*++

Routine Description:

    A TLS index may be allocated using TlsAlloc.  Win32 garuntees a
    minimum number of TLS indexes are available in each process.  The
    constant TLS_MINIMUM_AVAILABLE defines the minimum number of
    available indexes.  This minimum is at least 64 for all Win32
    systems.

Arguments:

    None.

Return Value:

    Not-0xffffffff - Returns a TLS index that may be used in a
        subsequent call to TlsFree, TlsSetValue, or TlsGetValue.  The
        storage associated with the index is initialized to NULL.

    0xffffffff - The operation failed. Extended error status is available
        using GetLastError.

--*/
{
    DWORD dwBitmapIndex;
    DWORD dwBitIndex;
    DWORD dwTlsIndex;

    XapiAcquireProcessLock();

    dwTlsIndex = 0xffffffff;

    for (dwBitmapIndex = 0; dwBitmapIndex < ARRAYSIZE(XapiTlsAllocBitmap);
        dwBitmapIndex++) {

        //
        // If the bitmap location contains a non-zero value, then there's at
        // least TLS index that we can allocate from this block.  Find the
        // lowest free bit and remove it from the bitmap.
        //

        if (XapiTlsAllocBitmap[dwBitmapIndex] != 0) {
            dwBitIndex = RtlFindFirstSetRightMember(XapiTlsAllocBitmap[dwBitmapIndex]);
            XapiTlsAllocBitmap[dwBitmapIndex] &= ~(1 << dwBitIndex);
            dwTlsIndex = (dwBitmapIndex * 32) + dwBitIndex;
            break;
        }
    }

    XapiReleaseProcessLock();

    return dwTlsIndex;
}

LPVOID
APIENTRY
TlsGetValue(
    DWORD dwTlsIndex
    )

/*++

Routine Description:

    This function is used to retrive the value in the TLS storage
    associated with the specified index.

    If the index is valid this function clears the value returned by
    GetLastError(), and returns the value stored in the TLS slot
    associated with the specified index.  Otherwise a value of NULL is
    returned with GetLastError updated appropriately.

    It is expected, that DLLs will use TlsAlloc and TlsGetValue as
    follows:

      - Upon DLL initialization, a TLS index will be allocated using
        TlsAlloc.  The DLL will then allocate some dynamic storage and
        store its address in the TLS slot using TlsSetValue.  This
        completes the per thread initialization for the initial thread
        of the process.  The TLS index is stored in instance data for
        the DLL.

      - Each time a new thread attaches to the DLL, the DLL will
        allocate some dynamic storage and store its address in the TLS
        slot using TlsSetValue.  This completes the per thread
        initialization for the new thread.

      - Each time an initialized thread makes a DLL call requiring the
        TLS, the DLL will call TlsGetValue to get the TLS data for the
        thread.

Arguments:

    dwTlsIndex - Supplies a TLS index allocated using TlsAlloc.  The
        index specifies which TLS slot is to be located.  Translating a
        TlsIndex does not prevent a TlsFree call from proceding.

Return Value:

    NON-NULL - The function was successful. The value is the data stored
        in the TLS slot associated with the specified index.

    NULL - The operation failed, or the value associated with the
        specified index was NULL.  Extended error status is available
        using GetLastError.  If this returns non-zero, the index was
        invalid.

--*/
{
    RIP_ON_NOT_TRUE("TlsGetValue()", (dwTlsIndex < TLS_MINIMUM_AVAILABLE));

    return XapiTlsSlots[dwTlsIndex];
}

BOOL
APIENTRY
TlsSetValue(
    DWORD dwTlsIndex,
    LPVOID lpTlsValue
    )

/*++

Routine Description:

    This function is used to store a value in the TLS storage associated
    with the specified index.

    If the index is valid this function stores the value and returns
    TRUE. Otherwise a value of FALSE is returned.

    It is expected, that DLLs will use TlsAlloc and TlsSetValue as
    follows:

      - Upon DLL initialization, a TLS index will be allocated using
        TlsAlloc.  The DLL will then allocate some dynamic storage and
        store its address in the TLS slot using TlsSetValue.  This
        completes the per thread initialization for the initial thread
        of the process.  The TLS index is stored in instance data for
        the DLL.

      - Each time a new thread attaches to the DLL, the DLL will
        allocate some dynamic storage and store its address in the TLS
        slot using TlsSetValue.  This completes the per thread
        initialization for the new thread.

      - Each time an initialized thread makes a DLL call requiring the
        TLS, the DLL will call TlsGetValue to get the TLS data for the
        thread.

Arguments:

    dwTlsIndex - Supplies a TLS index allocated using TlsAlloc.  The
        index specifies which TLS slot is to be located.  Translating a
        TlsIndex does not prevent a TlsFree call from proceding.

    lpTlsValue - Supplies the value to be stored in the TLS Slot.

Return Value:

    TRUE - The function was successful. The value lpTlsValue was
        stored.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    RIP_ON_NOT_TRUE("TlsSetValue()", (dwTlsIndex < TLS_MINIMUM_AVAILABLE));

    XapiTlsSlots[dwTlsIndex] = lpTlsValue;

    return TRUE;
}

BOOL
APIENTRY
TlsFree(
    DWORD dwTlsIndex
    )

/*++

Routine Description:

    A valid TLS index may be free'd using TlsFree.

Arguments:

    dwTlsIndex - Supplies a TLS index allocated using TlsAlloc.  If the
        index is a valid index, it is released by this call and is made
        available for reuse.  DLLs should be carefull to release any
        per-thread data pointed to by all of their threads TLS slots
        before calling this function.  It is expected that DLLs will
        only call this function (if at ALL) during their process detach
        routine.

Return Value:

    TRUE - The operation was successful. TlsAlloc is free to reallocate this
        index.

    FALSE - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    DWORD dwBitmapIndex;
    DWORD dwBitIndex;
    ULONG TlsDataRelativeOffset;
    KIRQL OldIrql;
    PKPROCESS Process;
    PLIST_ENTRY NextListEntry;
    PKTHREAD Thread;

    RIP_ON_NOT_TRUE("TlsFree()", (dwTlsIndex < TLS_MINIMUM_AVAILABLE));

    XapiAcquireProcessLock();

    dwBitmapIndex = dwTlsIndex / 32;
    dwBitIndex = dwTlsIndex % 32;

    //
    // Mark the TLS index as free.
    //

    XapiTlsAllocBitmap[dwBitmapIndex] |= (1 << dwBitIndex);

    //
    // Compute the TLS data relative byte offset for the supplied TLS index.
    //

    TlsDataRelativeOffset = (ULONG_PTR)&XapiTlsSlots[dwTlsIndex] -
        (ULONG_PTR)KeGetCurrentThread()->TlsData;

    //
    // Loop over the active threads and zero out the freed TLS slot.
    //

    OldIrql = KeRaiseIrqlToDpcLevel();
    Process = KeGetCurrentThread()->ApcState.Process;
    NextListEntry = Process->ThreadListHead.Flink;

    while (NextListEntry != &Process->ThreadListHead) {

        Thread = CONTAINING_RECORD(NextListEntry, KTHREAD, ThreadListEntry);

        //
        // Only zero out the freed TLS slot for threads created by XAPI.
        //

        if (Thread->TlsData != NULL) {
            *((LPVOID*)((ULONG_PTR)Thread->TlsData + TlsDataRelativeOffset)) = NULL;
        }

        NextListEntry = Thread->ThreadListEntry.Flink;
    }

    KeLowerIrql(OldIrql);

    XapiReleaseProcessLock();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\support.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    support.c

Abstract:

    This module implements various conversion routines
    that transform Win32 parameters into NT parameters.

Author:

    Mark Lucovsky (markl) 20-Sep-1990

Revision History:

--*/

#include "basedll.h"

POBJECT_ATTRIBUTES
XapiFormatObjectAttributes(
    OUT POBJECT_ATTRIBUTES ObjectAttributes,
    OUT POBJECT_STRING ObjectName,
    IN PCOSTR lpName
    )

/*++

Routine Description:

    This function transforms a Win32 security attributes structure into
    an NT object attributes structure.  It returns the address of the
    resulting structure (or NULL if SecurityAttributes was not
    specified).

Arguments:

    ObjectAttributes - Returns an initialized NT object attributes structure.

    ObjectName - Returns an initialized OBJECT_STRING structure.

    lpName - Supplies the name of the object relative to the
        ObWin32NamedObjectsDirectory() object directory.

Return Value:

    NON-NULL - Returns the ObjectAttributes value.  The structure is
        properly initialized by this function.

--*/

{
    RtlInitObjectString(ObjectName, lpName);

    InitializeObjectAttributes(
        ObjectAttributes,
        ObjectName,
        OBJ_OPENIF,
        ObWin32NamedObjectsDirectory(),
        NULL
        );

    return ObjectAttributes;
}

PLARGE_INTEGER
XapiFormatTimeOut(
    OUT PLARGE_INTEGER TimeOut,
    IN DWORD Milliseconds
    )

/*++

Routine Description:

    This function translates a Win32 style timeout to an NT relative
    timeout value.

Arguments:

    TimeOut - Returns an initialized NT timeout value that is equivalent
         to the Milliseconds parameter.

    Milliseconds - Supplies the timeout value in milliseconds.  A value
         of -1 indicates indefinite timeout.

Return Value:


    NULL - A value of null should be used to mimic the behavior of the
        specified Milliseconds parameter.

    NON-NULL - Returns the TimeOut value.  The structure is properly
        initialized by this function.

--*/

{
    if ( (LONG) Milliseconds == -1 ) {
        return( NULL );
        }
    TimeOut->QuadPart = UInt32x32To64( Milliseconds, 10000 );
    TimeOut->QuadPart *= -1;
    return TimeOut;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\synch.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    synch.c

Abstract:

    This module implements all Win32 syncronization
    objects.

--*/

#include "basedll.h"

//
// Event Services
//

HANDLE
APIENTRY
CreateEvent(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    PCOSTR lpName
    )

/*++

Routine Description:

    An event object is created and a handle opened for access to the
    object with the CreateEvent function.

    The CreateEvent function creates an event object with the specified
    initial state.  If an event is in the Signaled state (TRUE), a wait
    operation on the event does not block.  If the event is in the Not-
    Signaled state (FALSE), a wait operation on the event blocks until
    the specified event attains a state of Signaled, or the timeout
    value is exceeded.

    In addition to the STANDARD_RIGHTS_REQUIRED access flags, the following
    object type specific access flags are valid for event objects:

        - EVENT_MODIFY_STATE - Modify state access (set and reset) to
          the event is desired.

        - SYNCHRONIZE - Synchronization access (wait) to the event is
          desired.

        - EVENT_ALL_ACCESS - This set of access flags specifies all of
          the possible access flags for an event object.


Arguments:

    lpEventAttributes - An optional parameter that may be used to
        specify the attributes of the new event.  If the parameter is
        not specified, then the event is created without a security
        descriptor, and the resulting handle is not inherited on process
        creation.

    bManualReset - Supplies a flag which if TRUE specifies that the
        event must be manually reset.  If the value is FALSE, then after
        releasing a single waiter, the system automaticaly resets the
        event.

    bInitialState - The initial state of the event object, one of TRUE
        or FALSE.  If the InitialState is specified as TRUE, the event's
        current state value is set to one, otherwise it is set to zero.

    lpName - Optional unicode name of event

Return Value:

    NON-NULL - Returns a handle to the new event.  The handle has full
        access to the new event and may be used in any API that requires
        a handle to an event object.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    POBJECT_ATTRIBUTES pObja;
    HANDLE Handle;
    OBJECT_STRING ObjectName;

    if ( ARGUMENT_PRESENT(lpName) ) {
        pObja = XapiFormatObjectAttributes(&Obja,&ObjectName,lpName);
        }
    else {
        pObja = NULL;
        }

    Status = NtCreateEvent(
                &Handle,
                pObja,
                bManualReset ? NotificationEvent : SynchronizationEvent,
                (BOOLEAN)bInitialState
                );

    if ( NT_SUCCESS(Status) ) {
        if ( Status == STATUS_OBJECT_NAME_EXISTS ) {
            SetLastError(ERROR_ALREADY_EXISTS);
            }
        else {
            SetLastError(0);
            }
        return Handle;
        }
    else {
        XapiSetLastNTError(Status);
        return NULL;
        }
}

HANDLE
APIENTRY
OpenEvent(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    PCOSTR lpName
    )
{
    OBJECT_ATTRIBUTES Obja;
    OBJECT_STRING ObjectName;
    NTSTATUS Status;
    HANDLE Object;

    if ( !lpName ) {
        XapiSetLastNTError(STATUS_INVALID_PARAMETER);
        return NULL;
        }

    RtlInitObjectString(&ObjectName,lpName);

    InitializeObjectAttributes(
        &Obja,
        &ObjectName,
        0,
        ObWin32NamedObjectsDirectory(),
        NULL
        );

    Status = ObOpenObjectByName(&Obja,
                                ExEventObjectType,
                                NULL,
                                &Object);

    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        return NULL;
        }
    return Object;
}

BOOL
SetEvent(
    HANDLE hEvent
    )

/*++

Routine Description:

    An event can be set to the signaled state (TRUE) with the SetEvent
    function.

    Setting the event causes the event to attain a state of Signaled,
    which releases all currently waiting threads (for manual reset
    events), or a single waiting thread (for automatic reset events).

Arguments:

    hEvent - Supplies an open handle to an event object.  The
        handle must have EVENT_MODIFY_STATE access to the event.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;

    Status = NtSetEvent(hEvent,NULL);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        XapiSetLastNTError(Status);
        return FALSE;
        }
}

BOOL
ResetEvent(
    HANDLE hEvent
    )

/*++

Routine Description:

    The state of an event is set to the Not-Signaled state (FALSE) using
    the ClearEvent function.

    Once the event attains a state of Not-Signaled, any threads which
    wait on the event block, awaiting the event to become Signaled.  The
    reset event service sets the event count to zero for the state of
    the event.

Arguments:

    hEvent - Supplies an open handle to an event object.  The
        handle must have EVENT_MODIFY_STATE access to the event.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;

    Status = NtClearEvent(hEvent);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        XapiSetLastNTError(Status);
        return FALSE;
        }
}

BOOL
PulseEvent(
    HANDLE hEvent
    )

/*++

Routine Description:

    An event can be set to the Signaled state and reset to the Not-
    Signaled state atomically with the PulseEvent function.

    Pulsing the event causes the event to attain a state of Signaled,
    release appropriate threads, and then reset the event.  When no
    waiters are currently waiting on the event, pulsing an event causes
    the event to release no threads and end up in the Not-Signaled
    state.  With waiters waiting on an event, pulsing an event has a
    different effect for manual reset events that it does for automatic
    reset events.  For manual reset events, pulsing releases all waiters
    and then leaves the event in the Not-Signaled state.  For automatic
    reset events, pulsing the event releases a single waiter and then
    leaves the event in the Not-Signaled state.

Arguments:

    hEvent - Supplies an open handle to an event object.  The
        handle must have EVENT_MODIFY_STATE access to the event.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;

    Status = NtPulseEvent(hEvent,NULL);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        XapiSetLastNTError(Status);
        return FALSE;
        }
}

//
// Semaphore Services
//

HANDLE
APIENTRY
CreateSemaphore(
    LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
    LONG lInitialCount,
    LONG lMaximumCount,
    PCOSTR lpName
    )

/*++

Routine Description:

    A semaphore object is created and a handle opened for access to the
    object with the CreateSemaphore function.

    The CreateSemaphore function causes a semaphore object to be created
    which contains the specified initial and maximum counts.

    In addition to the STANDARD_RIGHTS_REQUIRED access flags, the
    following object type specific access flags are valid for semaphore
    objects:

        - SEMAPHORE_MODIFY_STATE - Modify state access (release) to the
            semaphore is desired.

        - SYNCHRONIZE - Synchronization access (wait) to the semaphore
            is desired.

        - SEMAPHORE_ALL_ACCESS - This set of access flags specifies all
            of the possible access flags for a semaphore object.


Arguments:

    lpSemaphoreAttributes - An optional parameter that may be used to
        specify the attributes of the new semaphore.  If the parameter
        is not specified, then the semaphore is created without a
        security descriptor, , and the resulting handle is not inherited
        on process creation.

    lInitialCount - The initial count for the semaphore, this value
        must be positive and less than or equal to the maximum count.

    lMaximumCount - The maximum count for the semaphore, this value
        must be greater than zero..

    lpName - Supplies an optional unicode name for the object.

Return Value:

    NON-NULL - Returns a handle to the new semaphore.  The handle has
        full access to the new semaphore and may be used in any API that
        requires a handle to a semaphore object.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    POBJECT_ATTRIBUTES pObja;
    HANDLE Handle;
    OBJECT_STRING ObjectName;

    if ( ARGUMENT_PRESENT(lpName) ) {
        pObja = XapiFormatObjectAttributes(&Obja,&ObjectName,lpName);
        }
    else {
        pObja = NULL;
        }

    Status = NtCreateSemaphore(
                &Handle,
                pObja,
                lInitialCount,
                lMaximumCount
                );
    
    if ( NT_SUCCESS(Status) ) {
        if ( Status == STATUS_OBJECT_NAME_EXISTS ) {
            SetLastError(ERROR_ALREADY_EXISTS);
            }
        else {
            SetLastError(0);
            }
        return Handle;
        }
    else {
        XapiSetLastNTError(Status);
        return NULL;
        }
}

HANDLE
APIENTRY
OpenSemaphore(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    PCOSTR lpName
    )
{
    OBJECT_ATTRIBUTES Obja;
    OBJECT_STRING ObjectName;
    NTSTATUS Status;
    HANDLE Object;

    if ( !lpName ) {
        XapiSetLastNTError(STATUS_INVALID_PARAMETER);
        return NULL;
        }

    RtlInitObjectString(&ObjectName,lpName);

    InitializeObjectAttributes(
        &Obja,
        &ObjectName,
        0,
        ObWin32NamedObjectsDirectory(),
        NULL
        );

    Status = ObOpenObjectByName(&Obja,
                                ExSemaphoreObjectType,
                                NULL,
                                &Object);

    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        return NULL;
        }
    return Object;
}


BOOL
ReleaseSemaphore(
    HANDLE hSemaphore,
    LONG lReleaseCount,
    LPLONG lpPreviousCount
    )

/*++

Routine Description:

    A semaphore object can be released with the ReleaseSemaphore
    function.

    When the semaphore is released, the current count of the semaphore
    is incremented by the ReleaseCount.  Any threads that are waiting
    for the semaphore are examined to see if the current semaphore value
    is sufficient to satisfy their wait.

    If the value specified by ReleaseCount would cause the maximum count
    for the semaphore to be exceeded, then the count for the semaphore
    is not affected and an error status is returned.


Arguments:

    hSemaphore - Supplies an open handle to a semaphore object.  The
        handle must have SEMAPHORE_MODIFY_STATE access to the semaphore.

    lReleaseCount - The release count for the semaphore.  The count
        must be greater than zero and less than the maximum value
        specified for the semaphore.

    lpPreviousCount - An optional pointer to a variable that receives
        the previous count for the semaphore.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;

    Status = NtReleaseSemaphore(hSemaphore,lReleaseCount,lpPreviousCount);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        XapiSetLastNTError(Status);
        return FALSE;
        }
}

//
// Mutex Services
//

HANDLE
APIENTRY
CreateMutex(
    LPSECURITY_ATTRIBUTES lpMutexAttributes,
    BOOL bInitialOwner,
    PCOSTR lpName
    )

/*++

Routine Description:

    A mutex object can be created and a handle opened for access to the
    object with the CreateMutex function.

    A new mutex object is created and a handle opened to the object with
    ownership as determined by the InitialOwner parameter.  The status
    of the newly created mutex object is set to not abandoned.

    In addition to the STANDARD_RIGHTS_REQUIRED access flags, the
    following object type specific access flags are valid for mutex
    objects:

        - MUTEX_MODIFY_STATE - Modify access to the mutex is desired.
          This allows a process to release a mutex.

        - SYNCHRONIZE - Synchronization access (wait or release) to the
          mutex object is desired.

        - MUTEX_ALL_ACCESS - All possible types of access to the mutex
          object are desired.


Arguments:

    lpMutexAttributes - An optional parameter that may be used to specify
        the attributes of the new mutex.  If the parameter is not
        specified, then the mutex is created without a security
        descriptor, and the resulting handle is not inherited on process
        creation.

    bInitialOwner - A boolean value that determines whether the creator
        of the object desires immediate ownership of the mutex object.


    lpName - Supplies an optional unicode name for the mutex.

Return Value:

    NON-NULL - Returns a handle to the new mutex.  The handle has full
        access to the new mutex and may be used in any API that
        requires a handle to a mutex object.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    POBJECT_ATTRIBUTES pObja;
    HANDLE Handle;
    OBJECT_STRING ObjectName;

    if ( ARGUMENT_PRESENT(lpName) ) {
        pObja = XapiFormatObjectAttributes(&Obja,&ObjectName,lpName);
        }
    else {
        pObja = NULL;
        }

    Status = NtCreateMutant(
                &Handle,
                pObja,
                (BOOLEAN)bInitialOwner
                );

    if ( NT_SUCCESS(Status) ) {
        if ( Status == STATUS_OBJECT_NAME_EXISTS ) {
            SetLastError(ERROR_ALREADY_EXISTS);
            }
        else {
            SetLastError(0);
            }
        return Handle;
        }
    else {
        XapiSetLastNTError(Status);
        return NULL;
        }
}

HANDLE
APIENTRY
OpenMutex(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    PCOSTR lpName
    )
{
    OBJECT_ATTRIBUTES Obja;
    OBJECT_STRING ObjectName;
    NTSTATUS Status;
    HANDLE Object;

    if ( !lpName ) {
        XapiSetLastNTError(STATUS_INVALID_PARAMETER);
        return NULL;
        }

    RtlInitObjectString(&ObjectName,lpName);

    InitializeObjectAttributes(
        &Obja,
        &ObjectName,
        0,
        ObWin32NamedObjectsDirectory(),
        NULL
        );

    Status = ObOpenObjectByName(&Obja,
                                ExMutantObjectType,
                                NULL,
                                &Object);

    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        return NULL;
        }
    return Object;
}

BOOL
ReleaseMutex(
    HANDLE hMutex
    )

/*++

Routine Description:

    Ownership of a mutex object can be released with the ReleaseMutex
    function.

    A mutex object can only be released by a thread that currently owns
    the mutex object.  When the mutex is released, the current count of
    the mutex object is incremented by one.  If the resultant count is
    one, then the mutex object is no longer owned.  Any threads that are
    waiting for the mutex object are examined to see if their wait can
    be satisfied.

Arguments:

    hMutex - An open handle to a mutex object.  The handle must
        have MUTEX_MODIFY_STATE access to the mutex.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;

    Status = NtReleaseMutant(hMutex,NULL);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        XapiSetLastNTError(Status);
        return FALSE;
        }
}

//
// Wait Services
//

DWORD
WaitForSingleObject(
    HANDLE hHandle,
    DWORD dwMilliseconds
    )

/*++

Routine Description:

    A wait operation on a waitable object is accomplished with the
    WaitForSingleObject function.

    Waiting on an object checks the current state of the object.  If the
    current state of the object allows continued execution, any
    adjustments to the object state are made (for example, decrementing
    the semaphore count for a semaphore object) and the thread continues
    execution.  If the current state of the object does not allow
    continued execution, the thread is placed into the wait state
    pending the change of the object's state or time-out.

Arguments:

    hHandle - An open handle to a waitable object. The handle must have
        SYNCHRONIZE access to the object.

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  This allows an application to test an object to
        determine if it is in the signaled state.  A timeout value of -1
        specifies an infinite timeout period.

Return Value:

    WAIT_TIME_OUT - Indicates that the wait was terminated due to the
        TimeOut conditions.

    0 - indicates the specified object attained a Signaled
        state thus completing the wait.

    WAIT_ABANDONED - indicates the specified object attained a Signaled
        state but was abandoned.

--*/

{
    return WaitForSingleObjectEx(hHandle,dwMilliseconds,FALSE);
}

DWORD
APIENTRY
WaitForSingleObjectEx(
    HANDLE hHandle,
    DWORD dwMilliseconds,
    BOOL bAlertable
    )

/*++

Routine Description:

    A wait operation on a waitable object is accomplished with the
    WaitForSingleObjectEx function.

    Waiting on an object checks the current state of the object.  If the
    current state of the object allows continued execution, any
    adjustments to the object state are made (for example, decrementing
    the semaphore count for a semaphore object) and the thread continues
    execution.  If the current state of the object does not allow
    continued execution, the thread is placed into the wait state
    pending the change of the object's state or time-out.

    If the bAlertable parameter is FALSE, the only way the wait
    terminates is because the specified timeout period expires, or
    because the specified object entered the signaled state.  If the
    bAlertable parameter is TRUE, then the wait can return due to any
    one of the above wait termination conditions, or because an I/O
    completion callback terminated the wait early (return value of
    WAIT_IO_COMPLETION).

Arguments:

    hHandle - An open handle to a waitable object. The handle must have
        SYNCHRONIZE access to the object.

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  This allows an application to test an object to
        determine if it is in the signaled state.  A timeout value of
        0xffffffff specifies an infinite timeout period.

    bAlertable - Supplies a flag that controls whether or not the
        wait may terminate early due to an I/O completion callback.
        A value of TRUE allows this API to complete early due to an I/O
        completion callback.  A value of FALSE will not allow I/O
        completion callbacks to terminate this call early.

Return Value:

    WAIT_TIME_OUT - Indicates that the wait was terminated due to the
        TimeOut conditions.

    0 - indicates the specified object attained a Signaled
        state thus completing the wait.

    0xffffffff - The wait terminated due to an error. GetLastError may be
        used to get additional error information.

    WAIT_ABANDONED - indicates the specified object attained a Signaled
        state but was abandoned.

    WAIT_IO_COMPLETION - The wait terminated due to one or more I/O
        completion callbacks.

--*/
{
    NTSTATUS Status;
    LARGE_INTEGER TimeOut;
    PLARGE_INTEGER pTimeOut;

    pTimeOut = XapiFormatTimeOut(&TimeOut,dwMilliseconds);
rewait:
    Status = NtWaitForSingleObjectEx(hHandle,
                                     UserMode,
                                     (BOOLEAN)bAlertable,
                                     pTimeOut);
    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        Status = (NTSTATUS)0xffffffff;
        }
    else {
        if ( bAlertable && Status == STATUS_ALERTED ) {
            goto rewait;
            }
        }
    return (DWORD)Status;
}


DWORD
WINAPI
SignalObjectAndWait(
    HANDLE hObjectToSignal,
    HANDLE hObjectToWaitOn,
    DWORD dwMilliseconds,
    BOOL bAlertable
    )
{
    NTSTATUS Status;
    LARGE_INTEGER TimeOut;
    PLARGE_INTEGER pTimeOut;

    pTimeOut = XapiFormatTimeOut(&TimeOut,dwMilliseconds);
rewait:
    Status = NtSignalAndWaitForSingleObjectEx(
                hObjectToSignal,
                hObjectToWaitOn,
                UserMode,
                (BOOLEAN)bAlertable,
                pTimeOut
                );

    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        Status = (NTSTATUS)0xffffffff;
        }
    else {
        if ( bAlertable && Status == STATUS_ALERTED ) {
            goto rewait;
            }
        }
    return (DWORD)Status;
}

DWORD
WaitForMultipleObjects(
    DWORD nCount,
    CONST HANDLE *lpHandles,
    BOOL bWaitAll,
    DWORD dwMilliseconds
    )

/*++

Routine Description:

A wait operation on multiple waitable objects (up to
MAXIMUM_WAIT_OBJECTS) is accomplished with the WaitForMultipleObjects
function.

Arguments:

    nCount - A count of the number of objects that are to be waited on.

    lpHandles - An array of object handles.  Each handle must have
        SYNCHRONIZE access to the associated object.

    bWaitAll - A flag that supplies the wait type.  A value of TRUE
        indicates a "wait all".  A value of false indicates a "wait
        any".

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  This allows an application to test an object to
        determine if it is in the signaled state.  A timeout value of -1
        specifies an infinite timeout period.

Return Value:

    WAIT_TIME_OUT - indicates that the wait was terminated due to the
        TimeOut conditions.

    0 to MAXIMUM_WAIT_OBJECTS-1, indicates, in the case of wait for any
        object, the object number which satisfied the wait.  In the case
        of wait for all objects, the value only indicates that the wait
        was completed successfully.

    WAIT_ABANDONED_0 to (WAIT_ABANDONED_0)+(MAXIMUM_WAIT_OBJECTS - 1),
        indicates, in the case of wait for any object, the object number
        which satisfied the event, and that the object which satisfied
        the event was abandoned.  In the case of wait for all objects,
        the value indicates that the wait was completed successfully and
        at least one of the objects was abandoned.

--*/

{
    return WaitForMultipleObjectsEx(nCount,lpHandles,bWaitAll,dwMilliseconds,FALSE);
}

DWORD
APIENTRY
WaitForMultipleObjectsEx(
    DWORD nCount,
    CONST HANDLE *lpHandles,
    BOOL bWaitAll,
    DWORD dwMilliseconds,
    BOOL bAlertable
    )

/*++

Routine Description:

    A wait operation on multiple waitable objects (up to
    MAXIMUM_WAIT_OBJECTS) is accomplished with the
    WaitForMultipleObjects function.

    This API can be used to wait on any of the specified objects to
    enter the signaled state, or all of the objects to enter the
    signaled state.

    If the bAlertable parameter is FALSE, the only way the wait
    terminates is because the specified timeout period expires, or
    because the specified objects entered the signaled state.  If the
    bAlertable parameter is TRUE, then the wait can return due to any one of
    the above wait termination conditions, or because an I/O completion
    callback terminated the wait early (return value of
    WAIT_IO_COMPLETION).

Arguments:

    nCount - A count of the number of objects that are to be waited on.

    lpHandles - An array of object handles.  Each handle must have
        SYNCHRONIZE access to the associated object.

    bWaitAll - A flag that supplies the wait type.  A value of TRUE
        indicates a "wait all".  A value of false indicates a "wait
        any".

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  This allows an application to test an object to
        determine if it is in the signaled state.  A timeout value of
        0xffffffff specifies an infinite timeout period.

    bAlertable - Supplies a flag that controls whether or not the
        wait may terminate early due to an I/O completion callback.
        A value of TRUE allows this API to complete early due to an I/O
        completion callback.  A value of FALSE will not allow I/O
        completion callbacks to terminate this call early.

Return Value:

    WAIT_TIME_OUT - indicates that the wait was terminated due to the
        TimeOut conditions.

    0 to MAXIMUM_WAIT_OBJECTS-1, indicates, in the case of wait for any
        object, the object number which satisfied the wait.  In the case
        of wait for all objects, the value only indicates that the wait
        was completed successfully.

    0xffffffff - The wait terminated due to an error. GetLastError may be
        used to get additional error information.

    WAIT_ABANDONED_0 to (WAIT_ABANDONED_0)+(MAXIMUM_WAIT_OBJECTS - 1),
        indicates, in the case of wait for any object, the object number
        which satisfied the event, and that the object which satisfied
        the event was abandoned.  In the case of wait for all objects,
        the value indicates that the wait was completed successfully and
        at least one of the objects was abandoned.

    WAIT_IO_COMPLETION - The wait terminated due to one or more I/O
        completion callbacks.

--*/
{
    NTSTATUS Status;
    LARGE_INTEGER TimeOut;
    PLARGE_INTEGER pTimeOut;
    HANDLE HandleArray[MAXIMUM_WAIT_OBJECTS];

    if (nCount > MAXIMUM_WAIT_OBJECTS) {
        XapiSetLastNTError(STATUS_INVALID_PARAMETER);
        return (DWORD)0xffffffff;
    }
    RtlCopyMemory(HandleArray,(LPVOID)lpHandles,nCount*sizeof(HANDLE));

    pTimeOut = XapiFormatTimeOut(&TimeOut,dwMilliseconds);
rewait:
    Status = NtWaitForMultipleObjectsEx(
                 (CHAR)nCount,
                 HandleArray,
                 bWaitAll ? WaitAll : WaitAny,
                 UserMode,
                 (BOOLEAN)bAlertable,
                 pTimeOut
                 );
    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        Status = (NTSTATUS)0xffffffff;
        }
    else {
        if ( bAlertable && Status == STATUS_ALERTED ) {
            goto rewait;
            }
        }

    return (DWORD)Status;
}

VOID
Sleep(
    DWORD dwMilliseconds
    )

/*++

Routine Description:

    The execution of the current thread can be delayed for a specified
    interval of time with the Sleep function.

    The Sleep function causes the current thread to enter a
    waiting state until the specified interval of time has passed.

Arguments:

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  This allows an application to test an object to
        determine if it is in the signaled state.  A timeout value of -1
        specifies an infinite timeout period.

Return Value:

    None.

--*/

{
    SleepEx(dwMilliseconds,FALSE);
}

DWORD
APIENTRY
SleepEx(
    DWORD dwMilliseconds,
    BOOL bAlertable
    )

/*++

Routine Description:

    The execution of the current thread can be delayed for a specified
    interval of time with the SleepEx function.

    The SleepEx function causes the current thread to enter a waiting
    state until the specified interval of time has passed.

    If the bAlertable parameter is FALSE, the only way the SleepEx
    returns is when the specified time interval has passed.  If the
    bAlertable parameter is TRUE, then the SleepEx can return due to the
    expiration of the time interval (return value of 0), or because an
    I/O completion callback terminated the SleepEx early (return value
    of WAIT_IO_COMPLETION).

Arguments:

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  A timeout value of -1 specifies an infinite
        timeout period.

    bAlertable - Supplies a flag that controls whether or not the
        SleepEx may terminate early due to an I/O completion callback.
        A value of TRUE allows this API to complete early due to an I/O
        completion callback.  A value of FALSE will not allow I/O
        completion callbacks to terminate this call early.

Return Value:

    0 - The SleepEx terminated due to expiration of the time interval.

    WAIT_IO_COMPLETION - The SleepEx terminated due to one or more I/O
        completion callbacks.

--*/
{
    LARGE_INTEGER TimeOut;
    PLARGE_INTEGER pTimeOut;
    NTSTATUS Status;

    pTimeOut = XapiFormatTimeOut(&TimeOut,dwMilliseconds);
    if (pTimeOut == NULL) {
        //
        // If Sleep( -1 ) then delay for the longest possible integer
        // relative to now.
        //

        TimeOut.LowPart = 0x0;
        TimeOut.HighPart = 0x80000000;
        pTimeOut = &TimeOut;
        }

rewait:
    Status = KeDelayExecutionThread(
                UserMode,
                (BOOLEAN)bAlertable,
                pTimeOut
                );
    if ( bAlertable && Status == STATUS_ALERTED ) {
        goto rewait;
        }
    return Status == STATUS_USER_APC ? WAIT_IO_COMPLETION : 0;
}

HANDLE
WINAPI
CreateWaitableTimer(
    LPSECURITY_ATTRIBUTES lpTimerAttributes,
    BOOL bManualReset,
    PCOSTR lpTimerName
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    POBJECT_ATTRIBUTES pObja;
    HANDLE Handle;
    OBJECT_STRING ObjectName;

    if ( ARGUMENT_PRESENT(lpTimerName) ) {
        pObja = XapiFormatObjectAttributes(&Obja,&ObjectName,lpTimerName);
        }
    else {
        pObja = NULL;
        }

    Status = NtCreateTimer(
                &Handle,
                pObja,
                bManualReset ? NotificationTimer : SynchronizationTimer
                );

    if ( NT_SUCCESS(Status) ) {
        if ( Status == STATUS_OBJECT_NAME_EXISTS ) {
            SetLastError(ERROR_ALREADY_EXISTS);
            }
        else {
            SetLastError(0);
            }
        return Handle;
        }
    else {
        XapiSetLastNTError(Status);
        return NULL;
        }
}

HANDLE
WINAPI
OpenWaitableTimer(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    PCOSTR lpTimerName
    )
{
    OBJECT_ATTRIBUTES Obja;
    OBJECT_STRING ObjectName;
    NTSTATUS Status;
    HANDLE Object;

    if ( !lpTimerName ) {
        XapiSetLastNTError(STATUS_INVALID_PARAMETER);
        return NULL;
        }
    RtlInitObjectString(&ObjectName,lpTimerName);

    InitializeObjectAttributes(
        &Obja,
        &ObjectName,
        0,
        ObWin32NamedObjectsDirectory(),
        NULL
        );

    Status = ObOpenObjectByName(&Obja,
                                ExTimerObjectType,
                                NULL,
                                &Object);

    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        return NULL;
        }
    return Object;
}

BOOL
WINAPI
SetWaitableTimer(
    HANDLE hTimer,
    const LARGE_INTEGER *lpDueTime,
    LONG lPeriod,
    PTIMERAPCROUTINE pfnCompletionRoutine,
    LPVOID lpArgToCompletionRoutine,
    BOOL fResume
    )
{
    NTSTATUS Status;

    Status = NtSetTimerEx(
                hTimer,
                (PLARGE_INTEGER)lpDueTime,
                (PTIMER_APC_ROUTINE)pfnCompletionRoutine,
                UserMode,
                lpArgToCompletionRoutine,
                (BOOLEAN) fResume,
                lPeriod,
                NULL
                );

    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        return FALSE;
        }
    else {
        if ( Status == STATUS_TIMER_RESUME_IGNORED ) {
            SetLastError(ERROR_NOT_SUPPORTED);
            }
        else {
            SetLastError(0);
            }
        return TRUE;
        }
}

BOOL
WINAPI
CancelWaitableTimer(
    HANDLE hTimer
    )
{
    NTSTATUS Status;

    Status = NtCancelTimer(hTimer,NULL);
    if ( !NT_SUCCESS(Status) ) {
        XapiSetLastNTError(Status);
        return FALSE;
        }
    else {
        return TRUE;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\virtual.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    virtual.c

Abstract:

    This module implements the Win32 virtual memory management services.

--*/

#include "basedll.h"
#pragma hdrstop


PVOID
WINAPI
VirtualAlloc(
    PVOID lpAddress,
    SIZE_T dwSize,
    DWORD flAllocationType,
    DWORD flProtect
    )
{
    NTSTATUS Status;

#if DBG
    if (lpAddress != NULL && (ULONG_PTR)lpAddress < MM_ALLOCATION_GRANULARITY)
    {
        RIP("VirtualAlloc() invalid parameter (lpAddress)");
    }
#endif // DBG

    Status = NtAllocateVirtualMemory( &lpAddress,
                                      0,
                                      &dwSize,
                                      flAllocationType,
                                      flProtect
                                    );

    if (NT_SUCCESS( Status )) {
        return( lpAddress );
        }
    else {
        XapiSetLastNTError( Status );
        return( NULL );
        }
}

BOOL
WINAPI
VirtualFree(
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD dwFreeType
    )
{
    NTSTATUS Status;

    if ( (dwFreeType & MEM_RELEASE ) && dwSize != 0 ) {
        XapiSetLastNTError( STATUS_INVALID_PARAMETER );
        return FALSE;
        }

    Status = NtFreeVirtualMemory( &lpAddress,
                                  &dwSize,
                                  dwFreeType
                                );

    if (NT_SUCCESS( Status )) {
        return( TRUE );
        }
    else {
        XapiSetLastNTError( Status );
        return( FALSE );
        }
}


BOOL
WINAPI
VirtualProtect(
    PVOID lpAddress,
    SIZE_T dwSize,
    DWORD flNewProtect,
    PDWORD lpflOldProtect
    )
{
    NTSTATUS Status;

    Status = NtProtectVirtualMemory( &lpAddress,
                                     &dwSize,
                                     flNewProtect,
                                     lpflOldProtect
                                   );

    if (NT_SUCCESS( Status )) {
        return( TRUE );
        }
    else {
        XapiSetLastNTError( Status );
        return( FALSE );
        }
}

DWORD
WINAPI
VirtualQuery(
    LPCVOID lpAddress,
    PMEMORY_BASIC_INFORMATION lpBuffer,
    DWORD dwLength
    )
{
    NTSTATUS Status;

    Status = NtQueryVirtualMemory( (LPVOID)lpAddress,
                                   lpBuffer
                                 );
    if (NT_SUCCESS( Status )) {
        return( sizeof(*lpBuffer) );
        }
    else {
        XapiSetLastNTError( Status );
        return( 0 );
        }
}

PVOID
WINAPI
VirtualAllocEx(
    HANDLE hProcess,
    PVOID lpAddress,
    SIZE_T dwSize,
    DWORD flAllocationType,
    DWORD flProtect
    )
{

    return VirtualAlloc(
                lpAddress,
                dwSize,
                flAllocationType,
                flProtect
                );

}


BOOL
WINAPI
VirtualFreeEx(
    HANDLE hProcess,
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD dwFreeType
    )
{
    return VirtualFree(lpAddress,dwSize,dwFreeType);
}


BOOL
WINAPI
VirtualProtectEx(
    HANDLE hProcess,
    PVOID lpAddress,
    SIZE_T dwSize,
    DWORD flNewProtect,
    PDWORD lpflOldProtect
    )
{

    return VirtualProtect( lpAddress,
                           dwSize,
                           flNewProtect,
                           lpflOldProtect
                         );
}


DWORD
WINAPI
VirtualQueryEx(
    HANDLE hProcess,
    LPCVOID lpAddress,
    PMEMORY_BASIC_INFORMATION lpBuffer,
    DWORD dwLength
    )
{

    return VirtualQuery( lpAddress,
                         (PMEMORY_BASIC_INFORMATION)lpBuffer,
                         dwLength
                       );
}


VOID
WINAPI
GlobalMemoryStatus(
    LPMEMORYSTATUS lpBuffer
    )
{
    MM_STATISTICS MemoryStatistics;

    MemoryStatistics.Length = sizeof(MM_STATISTICS);
    MmQueryStatistics(&MemoryStatistics);

    lpBuffer->dwLength = sizeof(*lpBuffer);
    lpBuffer->dwMemoryLoad = 0;
    lpBuffer->dwTotalPageFile = 0;
    lpBuffer->dwAvailPageFile = 0;
    lpBuffer->dwTotalPhys = (MemoryStatistics.TotalPhysicalPages << PAGE_SHIFT);
    lpBuffer->dwAvailPhys = (MemoryStatistics.AvailablePages << PAGE_SHIFT);
    lpBuffer->dwTotalVirtual = (ULONG_PTR)MM_HIGHEST_USER_ADDRESS -
        (ULONG_PTR)MM_LOWEST_USER_ADDRESS + 1;
    lpBuffer->dwAvailVirtual = lpBuffer->dwTotalVirtual -
        MemoryStatistics.VirtualMemoryBytesReserved;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\widechar.c ===
#include "basedll.h"

int
UnicodeToUTF8(
    IN LPCWSTR lpWideCharStr,
    IN int cchWideChar,
    OUT LPSTR lpUTF8Str,
    IN int cbUTF8
    );

int
UTF8ToUnicode(
    IN LPCSTR lpUTF8Str,
    IN int cbUTF8,
    OUT LPWSTR lpWideCharStr,
    IN int cchWideChar
    );

int WINAPI MultiByteToWideChar(
    IN UINT     CodePage,
    IN DWORD    dwFlags,
    IN LPCSTR   lpMultiByteStr,
    IN int      cbMultiByte,
    OUT LPWSTR  lpWideCharStr,
    IN int      cchWideChar)
{
    USHORT LengthRequires;
    UNICODE_STRING Unicode;
    ANSI_STRING Ansi;
    NTSTATUS Status;

    if ( CodePage == 65000 ) {
        ASSERT( 0 && "CP_UTF7 is not supported" );
        SetLastError( ERROR_INVALID_PARAMETER );
        return 0;
    }

    if ( CodePage == CP_UTF8 ) {
        return UTF8ToUnicode(lpMultiByteStr, cbMultiByte, lpWideCharStr, cchWideChar);
    }

    if ( cbMultiByte == -1 ) {
        LengthRequires = (USHORT)(strlen(lpMultiByteStr) + sizeof(ANSI_NULL));
    } else {
        LengthRequires = (USHORT)(cbMultiByte + sizeof(ANSI_NULL));
    }

    if ( cchWideChar == 0 ) {
        return LengthRequires;
    }
    else if ( cchWideChar < (int)LengthRequires ) {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return 0;        
    }

    Ansi.Buffer = (PSTR)lpMultiByteStr;
    Ansi.Length = (USHORT)(LengthRequires - sizeof(ANSI_NULL));
    Ansi.MaximumLength = (USHORT)(LengthRequires);

    Unicode.Buffer = lpWideCharStr;
    Unicode.Length = (USHORT)((LengthRequires - sizeof(ANSI_NULL)) * sizeof(WCHAR));
    Unicode.MaximumLength = cchWideChar * sizeof(WCHAR);

    Status = RtlAnsiStringToUnicodeString( &Unicode, &Ansi, FALSE );

    if ( NT_SUCCESS(Status) ) {
        return LengthRequires;
    } else {
        SetLastError( RtlNtStatusToDosError(Status) );
        return 0;
    }
}

int WINAPI WideCharToMultiByte(
    IN UINT     CodePage,
    IN DWORD    dwFlags,
    IN LPCWSTR  lpWideCharStr,
    IN int      cchWideChar,
    OUT LPSTR   lpMultiByteStr,
    IN int      cbMultiByte,
    IN LPCSTR   lpDefaultChar,
    OUT LPBOOL  lpUsedDefaultChar)
{
    USHORT LengthRequires;
    UNICODE_STRING Unicode;
    ANSI_STRING Ansi;
    NTSTATUS Status;

    if ( CodePage == 65000 ) {
        ASSERT( 0 && "CP_UTF7 is not supported" );
        SetLastError( ERROR_INVALID_PARAMETER );
        return 0;
    }

    if ( CodePage == CP_UTF8 ) {
        return UnicodeToUTF8(lpWideCharStr, cchWideChar, lpMultiByteStr, cbMultiByte);
    }

    if ( lpDefaultChar ) {
        ASSERT( 0 && "lpDefaultChar is not supported" );
        SetLastError( ERROR_INVALID_PARAMETER );
        return 0;
    }

    if ( lpUsedDefaultChar ) {
        *lpUsedDefaultChar = FALSE;
    }

    if ( cchWideChar == -1 ) {
        LengthRequires = wcslen(lpWideCharStr) + sizeof(ANSI_NULL);
    } else {
        LengthRequires = cchWideChar + sizeof(ANSI_NULL);
    }

    if ( cbMultiByte == 0 ) {
        return LengthRequires;
    }
    else if ( cbMultiByte < (int)LengthRequires ) {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return 0;        
    }

    Ansi.Buffer = lpMultiByteStr;
    Ansi.Length = 0;
    Ansi.MaximumLength = (USHORT)cbMultiByte;

    Unicode.Buffer = (PWSTR)lpWideCharStr;
    Unicode.Length = (USHORT)(LengthRequires * sizeof(WCHAR) - sizeof(UNICODE_NULL));
    Unicode.MaximumLength = (USHORT)(LengthRequires * sizeof(WCHAR));

    Status = RtlUnicodeStringToAnsiString( &Ansi, &Unicode, FALSE );

    if ( NT_SUCCESS(Status) ) {
        return LengthRequires;
    } else {
        SetLastError( RtlNtStatusToDosError(Status) );
        return 0;
    }
}


//*****************************************************************************
// UTF8 <-> Unicode conversion functions
//

#define HIGH_BITS1 0x80
#define HIGH_BITS2 0xC0
#define HIGH_BITS3 0xE0
#define HIGH_BITS4 0xF0
#define LOW_BITS4  0x0F
#define LOW_BITS5  0x1F
#define LOW_BITS6  0x3F

unsigned long offsetsFromUTF8[6] = { 0x00000000, 0x00003080, 0x000E2080,
                                     0x03C82080, 0xFA082080, 0x82082080};

char bytesFromUTF8[256] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, 3,3,3,3,3,3,3,3,4,4,4,4,5,5,5,5};

unsigned long kReplacementCharacter = 0x0000FFFD;
unsigned long kMaximumSimpleUniChar = 0x0000FFFF;
unsigned long kMaximumUniChar       = 0x0010FFFF;
int           halfShift             = 10;
unsigned long halfBase              = 0x0010000;
unsigned long halfMask              = 0x3FF;
unsigned long kSurrogateHighStart   = 0xD800;
unsigned long kSurrogateLowStart    = 0xDC00;

/*******************************************************************************
UTF8ToUnicode
 
Converts a UTF8 string to a Unicode string.
 
Returns:
    DWORD size of Unicode string
*******************************************************************************/
int
UTF8ToUnicode(
    IN LPCSTR lpUTF8Str,
    IN int cbUTF8,
    OUT LPWSTR lpWideCharStr,
    IN int cchWideChar
    )
{
    int LengthRequires = 0;
    unsigned short *pchWideChar = (unsigned short *) lpWideCharStr;
    unsigned char *lpUTF8StrPtr = (unsigned char *)lpUTF8Str;
    unsigned long ch = 0;
    unsigned short extraBytesToWrite = 0;

    if ( cbUTF8 == -1 )
    {
        cbUTF8 = strlen(lpUTF8Str) + sizeof(ANSI_NULL);
    }

    while ((lpUTF8StrPtr - ((unsigned char *)lpUTF8Str)) < cbUTF8)
    {
        ch = 0;
        extraBytesToWrite = bytesFromUTF8[*lpUTF8StrPtr];

        if (((lpUTF8StrPtr - ((unsigned char *)lpUTF8Str)) + extraBytesToWrite) > cbUTF8)
        {
            break;
        }

        switch(extraBytesToWrite)
        {
            case 5:ch += *lpUTF8StrPtr++; ch <<=6;
            case 4:ch += *lpUTF8StrPtr++; ch <<=6;
            case 3:ch += *lpUTF8StrPtr++; ch <<=6;
            case 2:ch += *lpUTF8StrPtr++; ch <<=6;
            case 1:ch += *lpUTF8StrPtr++; ch <<=6;
            case 0:ch += *lpUTF8StrPtr++;
        }

        ch -= offsetsFromUTF8[extraBytesToWrite];

        if (ch <= kMaximumSimpleUniChar)
        {
            if (++LengthRequires <= cchWideChar)
            {
                *((unsigned long *)pchWideChar) = ch;
                pchWideChar++;
            }
        }
        else if (ch > kMaximumUniChar)
        {
            if (++LengthRequires <= cchWideChar)
            {
                *((unsigned long *)pchWideChar) = kReplacementCharacter;
                pchWideChar++;
            }
        }
        else
        {
            ch -= halfBase;

            if (++LengthRequires <= cchWideChar)
            {
                *((unsigned long *)pchWideChar) = ((ch >> halfShift) + kSurrogateHighStart);
                pchWideChar++;
            }

            if (++LengthRequires <= cchWideChar)
            {
                *((unsigned long *)pchWideChar) = ((ch & halfMask) + kSurrogateLowStart);
                pchWideChar++;
            }
        }
    }

    if ( cchWideChar == 0 )
    {
        return LengthRequires;
    }
    else if ( cchWideChar < LengthRequires )
    {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return 0;        
    }

    return LengthRequires;
}

/*******************************************************************************
UnicodeToUTF8
 
Converts a Unicode string to a UTF-8 string.
 
Returns:
    DWORD size of UTF8 string
*******************************************************************************/
int
UnicodeToUTF8(
    IN LPCWSTR lpWideCharStr,
    IN int cchWideChar,
    OUT LPSTR lpUTF8Str,
    IN int cbUTF8
    )
{
    BYTE b;
    int LengthRequires = 0;
    HRESULT hr = S_OK;
    int i = 0;
 
    if ( cchWideChar == -1 ) {
        cchWideChar = wcslen(lpWideCharStr) + sizeof(ANSI_NULL);
    }

    for ( i = 0; i < cchWideChar; i += 1 )
    {
        if (*lpWideCharStr <= 0x7F)
        {
            // Single byte encoding
            if (++LengthRequires <= cbUTF8)
            {
                if (lpUTF8Str != NULL) 
                { 
                    *lpUTF8Str++ = (char) *lpWideCharStr; 
                }
            }
        }
        else if (*lpWideCharStr <= 0x7FF)
        {
            // Double byte encoding
            if (++LengthRequires <= cbUTF8)
            {
                if (lpUTF8Str != NULL)
                {
                    b = (BYTE) ((*lpWideCharStr & (LOW_BITS5 << 6)) >> 6);
                    b |= HIGH_BITS2;
                    *lpUTF8Str++ = (char) b;
                }
            } 

            if (++LengthRequires <= cbUTF8)
            {
                if (lpUTF8Str != NULL)
                {
                    b = (BYTE) (*lpWideCharStr & LOW_BITS6);
                    b |= HIGH_BITS1;
                    *lpUTF8Str++ = (char) b;
                }
            }
        }
        else 
        {
            // Triple byte encoding
            if (++LengthRequires <= cbUTF8)
            {
                if (lpUTF8Str != NULL)
                {
                    b = (BYTE) ((*lpWideCharStr & (LOW_BITS4 << 12)) >> 12);
                    b |= HIGH_BITS3;
                    *lpUTF8Str++ = (char) b;
                }
            }

            if (++LengthRequires <= cbUTF8)
            {
                if (lpUTF8Str != NULL)
                {
                    b = (BYTE) ((*lpWideCharStr & (LOW_BITS6 << 6)) >> 6);
                    b |= HIGH_BITS1;
                    *lpUTF8Str++ = (char) b;
                }
            }

            if (++LengthRequires <= cbUTF8)
            {
                if (lpUTF8Str != NULL)
                {
                    b = (BYTE) (*lpWideCharStr & LOW_BITS6);
                    b |= HIGH_BITS1;
                    *lpUTF8Str++ = (char) b;
                }
            }
        }
 
        lpWideCharStr++;
    }

    if ( cbUTF8 == 0 )
    {
        return LengthRequires;
    }
    else if ( cbUTF8 < LengthRequires )
    {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return 0;        
    }

    return LengthRequires;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\xcalcsig.c ===
/*++

Copyright (c) Microsoft Corporation

Description:
    Implementation of routines to calculate the signature
    given a series of piecemeal data blobs

Module Name:

    xcalcsig.c

--*/

#include "basedll.h"
#pragma hdrstop

#include <sha.h>
#include <shahmac.h>

//
// Define the actual context structure
//
typedef struct
{
    DWORD                dwFlags;    // Flags
    PBYTE                pbTitleKey;    // Per-title key 
    XSHAHMAC_CONTEXT    shactx;        // SHA1 context

} XCALCSIG_CONTEXT, *PXCALCSIG_CONTEXT;

//
// Define some macros to abstract memory management
//
#define XCalcSigAlloc(n)        LocalAlloc(LMEM_FIXED, (n))
#define XCalcSigFree(p)            LocalFree(p)

//
// Define some debug facilities to track invalid contexts
//
#if DBG
#define XCALCSIG_FLAG_INVALID_CONTEXT    (0x80000000)
#endif

//
// Define the K padding size for SHA1-Hmac
//
#define HMAC_K_PADSIZE              64

//
// Define the well-known XOR factors for Kipad and Kopad
//
#define HMAC_KI_XOR_FACTOR            ((DWORD)0x36363636)
#define HMAC_KO_XOR_FACTOR            ((DWORD)0x5C5C5C5C)

//
// Function to initialize a piecemeal SHA1-Hmac evaluation
//
VOID WINAPI XShaHmacInitialize(
            IN PBYTE                pbKey,
            IN DWORD                cbKey,
            IN OUT XSHAHMAC_CONTEXT Shactx
            )
{
    HRESULT        hr = S_OK;
    BYTE        rgbKipad[HMAC_K_PADSIZE];
    ULONG        dwBlock;

    RIP_ON_NOT_TRUE("XShaHmacInitialize", (pbKey != NULL));
    RIP_ON_NOT_TRUE("XShaHmacInitialize", (cbKey >= sizeof(DWORD)));
    RIP_ON_NOT_TRUE("XShaHmacInitialize", (Shactx != NULL));
    
    // Shorten length if longer than our K padding
    if (cbKey > HMAC_K_PADSIZE)
        cbKey = HMAC_K_PADSIZE;

    // Build our Kipad
    memset(rgbKipad, 0, HMAC_K_PADSIZE);
    memcpy(rgbKipad, pbKey, cbKey);
    for (dwBlock = 0; 
         dwBlock < (HMAC_K_PADSIZE/sizeof(DWORD)); 
         dwBlock++)
    {
        ((DWORD*)rgbKipad)[dwBlock] ^= HMAC_KI_XOR_FACTOR;
    }

    // Initialize our SHA1 Hmac context
    XcSHAInit(Shactx);

    // Run our Kipad through this ...
    XcSHAUpdate(Shactx, rgbKipad, HMAC_K_PADSIZE);
}

//
// Function to update the Hmac
//
VOID WINAPI XShaHmacUpdate(
            IN XSHAHMAC_CONTEXT Shactx,
            IN PBYTE            pbData,
            IN DWORD            cbData
            )
{
    RIP_ON_NOT_TRUE("XShaHmacUpdate", (Shactx != NULL));
    RIP_ON_NOT_TRUE("XShaHmacUpdate", (pbData != NULL));
    RIP_ON_NOT_TRUE("XShaHmacUpdate", (cbData > 0));

    XcSHAUpdate(Shactx, pbData, cbData);
}
            
//
// Function to calculate the final Hmac
//
VOID WINAPI XShaHmacComputeFinal(
            IN XSHAHMAC_CONTEXT Shactx,
            IN PBYTE            pbKey,
            IN DWORD            cbKey,
            OUT PBYTE           pbHmac
            )
{
    HRESULT        hr = S_OK;
    BYTE        rgbKopad[HMAC_K_PADSIZE + A_SHA_DIGEST_LEN];
    ULONG        dwBlock;

    RIP_ON_NOT_TRUE("XShaHmacComputeFinal", (Shactx != NULL));
    RIP_ON_NOT_TRUE("XShaHmacComputeFinal", (pbHmac != NULL));
    
    // Shorten length if longer than our K padding
    if (cbKey > HMAC_K_PADSIZE)
        cbKey = HMAC_K_PADSIZE;

    // Build our Kipad
    memset(rgbKopad, 0, HMAC_K_PADSIZE);
    memcpy(rgbKopad, pbKey, cbKey);
    for (dwBlock = 0; 
         dwBlock < (HMAC_K_PADSIZE/sizeof(DWORD)); 
         dwBlock++)
    {
        ((DWORD*)rgbKopad)[dwBlock] ^= HMAC_KO_XOR_FACTOR;
    }

    // Finish off the hash, and place the result right
    // after the Kopad data
    XcSHAFinal(Shactx, rgbKopad + HMAC_K_PADSIZE);

    // Do another hash, now with the Kopad data
    XcSHAInit(Shactx);
    XcSHAUpdate(Shactx, rgbKopad, sizeof(rgbKopad));
    XcSHAFinal(Shactx, pbHmac);
}            

//
// Function to make a signature non-roamable. The two
// signature buffers must be different and must not overlap
//
BOOL XapiConvertSignatureToNonRoamable(
            PXCALCSIG_CONTEXT    pCalcSig,
            PXCALCSIG_SIGNATURE  psignatureRoamable,
            PXCALCSIG_SIGNATURE  psignatureNonRoamable
            )
{
    // Compute the Keyed SHA Hmac
    XShaHmacInitialize((LPBYTE)(*XboxHDKey), XBOX_KEY_LENGTH, 
                pCalcSig->shactx);
    
    XShaHmacUpdate(pCalcSig->shactx, 
                psignatureRoamable->Signature, 
                XCALCSIG_SIGNATURE_SIZE);
                
    XShaHmacComputeFinal(pCalcSig->shactx, 
                (LPBYTE)(*XboxHDKey), XBOX_KEY_LENGTH,
                psignatureNonRoamable->Signature);

    return(TRUE);
}

//
// Wrapper to XCalculateSignatureBeginEx() that does not take a
// title ID parameter (uses the current title's ID implicitly)
//
HANDLE WINAPI XCalculateSignatureBegin(
            IN DWORD dwFlags
            )
{
    return XCalculateSignatureBeginEx(dwFlags, XeImageHeader()->Certificate->TitleID);
}


//
// Function to begin the piecemeal process to calculate the
// signature of a blob of data
//
// Arguments:
//    dwFlags - Optional flags. Currently defined flags are:
//        XCALCSIG_FLAG_NON_ROAMABLE - this forces the resulting
//                signature to be unusable on any XBox other than
//                the one on which the signature is computed.
//    dwAltTitleId - Alternate title id or the current title id
//
// Return Values:
//    On success, this function returns a HANDLE that can be used
//    in subsequent calls to calculate a signature. On failure,
//    function returns INVALID_HANDLE_VALUE, extended error
//    information can be retrieved using GetLastError().
//
// Remarks:
//    On success, this fucntion allocates memory for the
//    returned HANDLE. The caller must explicitly call
//    XCalculateSignatureEnd to free the handle resources,
//    regardless of any intermediate failures.
//
HANDLE WINAPI XCalculateSignatureBeginEx(
            IN DWORD dwFlags,
            IN DWORD dwAltTitleId
            )
{
    PXCALCSIG_CONTEXT pCalcSig;
    PXBEIMAGE_CERTIFICATE Certificate = XeImageHeader()->Certificate;

    RIP_ON_NOT_TRUE("XCalculateSignatureBegin",
                    ((dwFlags & (~XCALCSIG_FLAG_NON_ROAMABLE)) == 0));
    
    // Allocate the context
    pCalcSig = XCalcSigAlloc(sizeof(XCALCSIG_CONTEXT));
    if (!pCalcSig)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Error;
    }

    // Initialize 
    pCalcSig->dwFlags = dwFlags;

    //
    // Get the per-title key
    // If dwAltTitleId is the current title's id, use XboxSignatureKey
    // Otherwise, try to user XboxAlternateSignatureKeys
    //
    
    if (Certificate->TitleID != dwAltTitleId)
    {
        int i;
        for (i = 0; i < ARRAYSIZE(Certificate->AlternateTitleIDs); i++)
        {
            if (0 == Certificate->AlternateTitleIDs[i])
            {
                SetLastError(ERROR_ACCESS_DENIED);
                goto Error;
            }

            if (dwAltTitleId == Certificate->AlternateTitleIDs[i])
            {
                break;
            }
        }

        if (i >= sizeof(Certificate->AlternateTitleIDs))
        {
            SetLastError(ERROR_ACCESS_DENIED);
            goto Error;
        }

        ASSERT(i < XBEIMAGE_ALTERNATE_TITLE_ID_COUNT);
        
        pCalcSig->pbTitleKey = (PBYTE)XboxAlternateSignatureKeys[i];
        
    }
    else
    {
        pCalcSig->pbTitleKey = (PBYTE)XboxSignatureKey;
    }

    // Initialize SHA Hmac
    XShaHmacInitialize(pCalcSig->pbTitleKey, 
                       XC_SYMMETRIC_KEY_SIZE,
                       pCalcSig->shactx);

    // Return context as opaque handle
    return((HANDLE)pCalcSig);

Error:
    return(INVALID_HANDLE_VALUE);
}


//
// This function continues to to update the calculation
// for the specified signature context handle. 
//
// Arguments:
//    hCalcSig - the context to update
//    pbData - the next chunk of data to update with
//    cbData - the size of the data chunk
//
// Return Values:
//    This function returns ERROR_SUCCESS on success, and if this
//    function failed, an appropriate Win32 error code is returned.
//    Either case, XCalculateSignatureEnd must be called to free 
//    any resources associated with the HANDLE.
//
DWORD WINAPI XCalculateSignatureUpdate(
            IN HANDLE hCalcSig,
            IN const BYTE *pbData,
            IN ULONG cbData
            )
{
    PXCALCSIG_CONTEXT pCalcSig = (PXCALCSIG_CONTEXT)hCalcSig;

    RIP_ON_NOT_TRUE("XCalculateSignatureUpdate", (pCalcSig != NULL));
    RIP_ON_NOT_TRUE("XCalculateSignatureUpdate", (pbData != NULL));

#if DBG
    RIP_ON_NOT_TRUE("XCalculateSignatureUpdate", 
                    ((pCalcSig->dwFlags & XCALCSIG_FLAG_INVALID_CONTEXT) == 0));
#endif

    // Call update
    XShaHmacUpdate(pCalcSig->shactx, (PBYTE)pbData, cbData);
    return(ERROR_SUCCESS);
}

//
// This function performs the last bit of precessing
// required to calculate the signature, returns the 
// signature blob, and releases the context.
//
// Arguments:
//    hCalcSig - the context to close
//    Signature - the buffer to receive the final signature
//
// Return Values:
//    On success, this function returns ERROR_SUCCESS, and the
//    final computed signature is returned in signature. If this 
//    function failed, an appropriate Win32 error code is returned.
//
// Remarks:
//    The context specified by hCalcSig will be released 
//    regardless of whether this function call succeeded
//    or not. hCalcSig should not be used after this function
//    returns unless it is reinitialized by XCalculateSignatureBegin.
//    This function can be used to just free the context. In
//    this case, NULL should be specified for the Signature argument.
//
DWORD WINAPI XCalculateSignatureEnd(
            IN HANDLE hCalcSig,
            OUT PXCALCSIG_SIGNATURE pSignature
            )
{
    BOOL                fResult = TRUE;
    PXCALCSIG_CONTEXT   pCalcSig = (PXCALCSIG_CONTEXT)hCalcSig;
    XCALCSIG_SIGNATURE  xcsSignature;
    BOOL                fNonRoamable;

    RIP_ON_NOT_TRUE("XCalculateSignatureEnd", (pCalcSig != NULL));

#if DBG
    RIP_ON_NOT_TRUE("XCalculateSignatureEnd", 
            ((pCalcSig->dwFlags & XCALCSIG_FLAG_INVALID_CONTEXT) == 0));
#endif

    fNonRoamable = ((pCalcSig->dwFlags & XCALCSIG_FLAG_NON_ROAMABLE) != 0);

    // Finish the calculation
    if (pSignature)
    {
        // Figure out the Hmac
        XShaHmacComputeFinal(pCalcSig->shactx, 
                    pCalcSig->pbTitleKey, 
                    XC_SYMMETRIC_KEY_SIZE,
                    (fNonRoamable)?xcsSignature.Signature:pSignature->Signature);
                        
        if (fNonRoamable)
        {
            fResult = XapiConvertSignatureToNonRoamable(
                        pCalcSig, &xcsSignature, pSignature);
        }
    }

    // Well, free the context either case
#if DBG
    pCalcSig->dwFlags |= XCALCSIG_FLAG_INVALID_CONTEXT;
#endif
    XCalcSigFree(pCalcSig);
    
    return(fResult?ERROR_SUCCESS:GetLastError());
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\xemodule.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    xemodule.c

Abstract:

    This module contains implementation of the routines that interface with
    XE loader in the kernel

--*/

#include "basedll.h"
#pragma hdrstop

#define IsValidSectionHandle(hSection) \
    (((PVOID)hSection >= (PVOID)XeImageHeader()->SectionHeaders) && \
    ((PVOID)hSection < (PVOID)(XeImageHeader()->SectionHeaders + XeImageHeader()->NumberOfSections)))

HANDLE
WINAPI
XGetSectionHandle(
    IN LPCSTR lpSectionName
    )
/*++

Routine Description:

    Finds a section in the current XE image

Arguments:

    lpSectionName - Supplies the name of the section to find.

Return Value:

    A handle to the section if found,
    otherwise INVALID_HANDLE_VALUE (GetLastError)

--*/
{
    STRING SearchString;
    PXBEIMAGE_SECTION Section;
    PXBEIMAGE_SECTION EndingSection;
    STRING SectionName;

    RIP_ON_NOT_TRUE("XGetSectionHandle()", (lpSectionName != NULL));

    RtlInitAnsiString(&SearchString, lpSectionName);

    //
    // Walk through each of the sections looking for a match by name.
    //

    Section = XeImageHeader()->SectionHeaders;
    EndingSection = Section + XeImageHeader()->NumberOfSections;

    while (Section < EndingSection) {

        RtlInitAnsiString(&SectionName, Section->SectionName);

        if (RtlEqualString(&SearchString, &SectionName, TRUE)) {
            return (HANDLE)Section;
        }

        Section++;
    }

    //
    // The section name was not found.
    //

    SetLastError(ERROR_NOT_FOUND);

    return INVALID_HANDLE_VALUE;
}

LPVOID
WINAPI
XLoadSectionByHandle(
    IN HANDLE hSection
    )
/*++

Routine Description:

    Loads a section from the current XE image file into memory.  If the section
    is already loaded, its reference count is incremented,

Arguments:

    hSection - Supplies the handle of the section

Return Value:

    Return the virtual address of the loaded section if succesful
    otherwise NULL (GetLastError)

--*/
{
    NTSTATUS status;
    PXBEIMAGE_SECTION Section;

    RIP_ON_NOT_TRUE("XLoadSectionByHandle()", IsValidSectionHandle(hSection));

    Section = (PXBEIMAGE_SECTION)hSection;

    status = XeLoadSection(Section);

    if (!NT_SUCCESS(status)) {
        XapiSetLastNTError(status);
        return NULL;
    }

    return (LPVOID)Section->VirtualAddress;
}

BOOL
WINAPI
XFreeSectionByHandle(
    HANDLE hSection
    )
/*++

Routine Description:

    Unloads a section from memory.  The section is only unloaded when
    its reference count goes to zero.

Arguments:

    hSection - Supplies the handle of the section

Return Value:

    TRUE if successful, 
    FALSE otherwise (GetLastError)

--*/
{
    NTSTATUS status;
    PXBEIMAGE_SECTION Section;

    RIP_ON_NOT_TRUE("XFreeSectionByHandle()", IsValidSectionHandle(hSection));

    Section = (PXBEIMAGE_SECTION)hSection;

    status = XeUnloadSection(Section);

    if (!NT_SUCCESS(status)) {
        XapiSetLastNTError(status);
        return FALSE;
    }

    return TRUE;
}

PVOID
WINAPI
XLoadSection(
    IN LPCSTR lpSectionName
    )
/*++

Routine Description:

    Loads a section from the current XE image file into memory.  If the section
    is already loaded, its reference count is incremented,

Arguments:

    lpSectionName - Supplies the name of the section from the XE file

Return Value:

    Return the virtual address of the loaded section if succesful
    otherwise NULL (GetLastError)

--*/
{
    HANDLE hSection;

    RIP_ON_NOT_TRUE("XLoadSection()", (lpSectionName != NULL));

    hSection = XGetSectionHandle(lpSectionName);

    if (hSection != INVALID_HANDLE_VALUE) {
        return XLoadSectionByHandle(hSection);
    } else {
        return NULL;
    }
}

BOOL
WINAPI
XFreeSection(
    IN LPCSTR lpSectionName
    )
/*++

Routine Description:

    Unloads a section from memory.  The section is only unloaded when
    its reference count goes to zero.

Arguments:

    lpSectionName - Supplies the name of the section from the XE file

Return Value:

    TRUE if successful,
    FALSE otherwise (GetLastError)

--*/
{
    HANDLE hSection;

    RIP_ON_NOT_TRUE("XFreeSection()", (lpSectionName != NULL));

    hSection = XGetSectionHandle(lpSectionName);

    if (hSection != INVALID_HANDLE_VALUE) {
        return XFreeSectionByHandle(hSection);
    } else {
        return FALSE;
    }
}

DWORD
WINAPI
XGetSectionSize(
    IN HANDLE hSection
    )
/*++

Routine Description:

    Returns the size of a section

Arguments:

    hSection - Supplies the handle of the section

Return Value:

    Return the size of a section or 0 (GetLastError)

--*/
{
    PXBEIMAGE_SECTION Section;

    RIP_ON_NOT_TRUE("XGetSectionSize()", IsValidSectionHandle(hSection));

    Section = (PXBEIMAGE_SECTION)hSection;

    return Section->VirtualSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\xclndrv.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

   xclndrv.c

Abstract:

    API's that clean drives by reclaiming empty title directories
    and corrupt games.

Author:

    Mitchell S. Dernis (mitchd) 05-Jun-2001

Revision History:

--*/

#include "basedll.h"



#ifdef XAPILIBP

DWORD
WINAPI
XCleanMUFromRoot(
    IN OCHAR chDrive,
    PCOSTR pszPreserveDir OPTIONAL
    )
/*++
  Routine Description:
    From a root mounted MU drive, clean all the title directories that do not
    contain games.  Except do not cleanup the directory specified by pszPreserveDir
  Arguments:
    chDrive - drive letter of root mounted MU.
    pszPreserveDir OPTIONAL - title directory to preserve, even if it has no games.
--*/
{
    NTSTATUS status;
    OCHAR szDosDevice[25];
    
    //
    // Removing the 0x20 bit will make lower case characters uppercase
    //

    chDrive &= ~0x20;

    //
    //  Debug check to make sure that this is an MU it should be root mounted.
    //
#if DBG
    if (
         ((chDrive < MU_FIRST_DRIVE) || (chDrive > MU_LAST_DRIVE))
    )
    {
        RIP("XCleanDrive() invalid drive letter parameter");
    }
#endif // DBG
    
    //
    //  Create a string with the full dos name
    //
    soprintf(szDosDevice, OTEXT("\\??\\%c:\\"), chDrive);

    //
    // Call XapiNukeSubdirsWithoutSubdirs.  
    //
    return XapiNukeEmptySubdirs(szDosDevice, pszPreserveDir, TRUE);
}

DWORD 
WINAPI
XCleanDrive(
    IN OCHAR chDrive
)
/*++
  Routine Description:
    From a mounted title drive (T, or any mounted MU, but not a root mounted MU),
    find all the title areas on the drive and cleanup any directory that does not
    contain valid saved games.  Except do not cleanup the directory of the current
    title.

  Arguments:
    chDrive - drive letter to cleanup

  Comments:
    XCleanDrive and DWORD XCleanMUFromRoot are both tasked with finding the root of a volume of
    title directories, and then cleaning them up.  XapiNukeSubdirsWithoutSubdirs
    does the work.
--*/
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    OBJECT_STRING ObjectName;
    OCHAR szDosDevice[25];
    OCHAR Target[MAX_PATH+1];
    ULONG TargetLength;
    OCHAR oszPreserveDir[CCHMAX_HEX_DWORD];
    OBJECT_STRING ObjectTarget;
    HANDLE Handle;
    
    //
    // Removing the 0x20 bit will make lower case characters uppercase
    //

    chDrive &= ~0x20;

    //
    //  Debug check to make sure that this is an MU or the T: drive.
    //
#if DBG
    if ((chDrive < MU_FIRST_DRIVE) || (chDrive > MU_LAST_DRIVE))
    {
        RIP("XCleanDrive() invalid drive letter parameter");
    }
#endif // DBG
    
    //
    //  Open the symbolic link, at the real path
    //
    soprintf(szDosDevice, OTEXT("\\??\\%c:"), chDrive);

    RtlInitObjectString(&ObjectName, szDosDevice);

    InitializeObjectAttributes(&ObjectAttributes,
                               &ObjectName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = NtOpenSymbolicLinkObject(&Handle, &ObjectAttributes);

    if (!NT_SUCCESS(status))
    {
        return RtlNtStatusToDosError(status);
    }

    ObjectTarget.Buffer = Target;
    ObjectTarget.MaximumLength = sizeof(Target)-1;

    status = NtQuerySymbolicLinkObject(Handle, &ObjectTarget, &TargetLength);

    NtClose(Handle);

    if (!NT_SUCCESS(status))
    {
        return RtlNtStatusToDosError(status);
    }

    //
    //  The title directory must be of length CCHMAX_HEX_DWORD.
    //
    if ((TargetLength < CCHMAX_HEX_DWORD) ||
        ('\\' != Target[TargetLength - (CCHMAX_HEX_DWORD)]))
    {
        return ERROR_INVALID_DRIVE;
    }

    //
    //  Break the Target into two strings.  The root path,
    //  and the current title library.
    //
    Target[TargetLength] = OBJECT_NULL;
    ocscpy(oszPreserveDir, &Target[TargetLength - (CCHMAX_HEX_DWORD)+1]);
    Target[TargetLength - (CCHMAX_HEX_DWORD)+1] = OBJECT_NULL; //remove subdir - maintain '\\'

    //
    // Call XapiNukeEmptySubdirs.  For all drives but T, we nuke the directory even if it contains  
    // files, as long as it has no subdirectories.
    //
    return XapiNukeEmptySubdirs(Target, oszPreserveDir, (HD_TDATA_DRIVE == chDrive) ? FALSE : TRUE );
}


DWORD 
XapiNukeEmptySubdirs(
    IN PCOSTR  pszDrivePath,
    IN PCOSTR  pszPreserveDir OPTIONAL,
    IN BOOLEAN fNukeFiles
    )
/*++
  Routine Description:
    
    Nukes all "empty} subdirectories under pszDrivePath, excluding the
    directory optionally specified by pszPreserveDir.

  Arguments:

    pszDrivePath   - path to directory that contains subdirectories.
    pszPreserveDir - optional relative path to single subdirectory
                     to preserve even if it does not have any subdirectories.
    fNukeFiles     - if true, it consider subdirectories empty even if they 
                     contain files, as long as they do not contain more
                     subdirectories.
  Comments:
    The motivation for having such a bizarre routine in XAPI is as a helper for cleaning
    up title directories.

    The primary clients are XCleanDrive and XCleanMUFromRoot.  The idea is
    to nuke empty title directories that do not contain useful user data.  There
    are two cases: U:\ (and all the MU's) and T:\.  In both cases, every time a
    game boots (and in the case of MU's mounts them) a subdirectory is created for
    that title.  For U:\ (and the MUs) each saved game is in a subdirectory.  Files
    that are not in a subdirectory are considered expandable.  In the T:\ case even
    individual files should be saved.  Thus fNukeFiles is passed as FALSE when
    cleaning the T:\ drive and TRUE for the other drives.

    pszPreserveDir is used to avoid deleting the title directory of the current title.
    It can be NULL.  The dashboard does this when cleaning up MU's.

--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE hRoot;
    ULONG EndingIndex;
    OBJECT_STRING DirectoryName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN fFindFirstFile = TRUE;
    struct {FILE_DIRECTORY_INFORMATION DirInfo;OCHAR Names[255];} Buffer;
    PFILE_DIRECTORY_INFORMATION DirectoryInfo = &Buffer.DirInfo;
    

    RtlInitObjectString(&DirectoryName, pszDrivePath);

    InitializeObjectAttributes(
        &Obja,
        &DirectoryName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Open the directory for list access.
    //

    Status = NtOpenFile(
                 &hRoot,
                 FILE_LIST_DIRECTORY | SYNCHRONIZE,
                 &Obja,
                 &IoStatusBlock,
                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                 );

    //
    // Loop over and find all the subdirectories
    //
    while(NT_SUCCESS(Status))
    {
        Status = NtQueryDirectoryFile(
                 hRoot,
                 NULL,
                 NULL,
                 NULL,
                 &IoStatusBlock,
                 DirectoryInfo,
                 sizeof(Buffer)-sizeof(OCHAR),
                 FileDirectoryInformation,
                 NULL,
                 fFindFirstFile
                 );
        fFindFirstFile = FALSE;
        //
        //  If we found a file, we need to determine if it is a subdirectory
        //  without subdirectories.
        //
        if(NT_SUCCESS(Status))
        {
           //
           //  Proceed only if it is a directory
           //
           if(DirectoryInfo->FileAttributes&FILE_ATTRIBUTE_DIRECTORY)
           {
               //
               //  Null terminate the name in place.  Note that we passed
               //  NtQueryDirectoryFile a small buffer length to save room for a NULL.
               //
               DirectoryInfo->FileName[DirectoryInfo->FileNameLength/sizeof(OCHAR)] = OBJECT_NULL;

               //
               //  Proceed only if we were not passed a directory to preserve, or
               //  if this is not that directory.
               //
               if(!pszPreserveDir || ocscmp(DirectoryInfo->FileName, pszPreserveDir))
               {
                   HANDLE   hSubDir;
                   NTSTATUS SubDirStatus;
                   BOOLEAN  fFindFirstSubDir = TRUE;
                   
                   //
                   // Open the subdirectory with FILE_LIST_DIRECTORY access
                   // to see if it has any subdirectories, and with DELETE and 
                   // FILE_WRITE_ATTRIBUTES access.
                   // 
                   // DELETE in case we need to delete it.  FILE_WRITE_ATTRIBUTES
                   // in case it turns out to have FILE_ATTRIBUTE_READONLY set
                   // when we go to DELETE it.
                   //
                   RtlInitObjectString(&DirectoryName, DirectoryInfo->FileName);
                   InitializeObjectAttributes(
                     &Obja,
                     &DirectoryName,
                     OBJ_CASE_INSENSITIVE,
                     hRoot,
                     NULL
                     );
                   SubDirStatus = NtOpenFile(
                         &hSubDir,
                         FILE_LIST_DIRECTORY | DELETE | FILE_WRITE_ATTRIBUTES |SYNCHRONIZE,
                         &Obja,
                         &IoStatusBlock,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                         );

                   //
                   // Loop while successful, except we break if we 
                   // as soon as we know that we want to preserve
                   // this subdirectory.
                   //
                   while(NT_SUCCESS(SubDirStatus))
                   {
                      SubDirStatus = NtQueryDirectoryFile(
                                         hSubDir,
                                         NULL,
                                         NULL,
                                         NULL,
                                         &IoStatusBlock,
                                         DirectoryInfo,
                                         sizeof(Buffer)-sizeof(OCHAR),
                                         FileDirectoryInformation,
                                         NULL,
                                         fFindFirstSubDir
                                         );
                       fFindFirstSubDir = FALSE;
                       
                       if(NT_SUCCESS(SubDirStatus))
                       {
                           //
                           //  If the fNukeFiles is not set, or 
                           //  if this is a directory, then we break.
                           //  This will leave the loop with Status ==
                           //  STATUS_SUCCESS, which prevents this subdirectory 
                           //  from being nuked.
                           //
                           if(!fNukeFiles || DirectoryInfo->FileAttributes&FILE_ATTRIBUTE_DIRECTORY)
                           {
                             break;
                           }
                       }
                   }

                   //
                   //  If !fFindFirstSubDir, then we have an opened
                   //  hSubDir handle.
                   //
                   if(!fFindFirstSubDir)
                   {
                       //
                       //   If we got to the end of the loop and didn't
                       //   find a file (if fNukeFile not set) or a
                       //   subdirectory in the subdirectory, then
                       //   nuke it.
                       //
                       if(
                           (STATUS_NO_MORE_FILES == SubDirStatus) ||
                           (STATUS_NO_SUCH_FILE == SubDirStatus)
                        )
                       {
                           XapiNukeDirectoryFromHandle(hSubDir, DirectoryInfo);    
                       }
                       //
                       //   We are done with the subdirectory, if we
                       //   called XapiNukeDirectoryFromHandle on the
                       //   handle, this finishes the job.  Otherwise,
                       //   the directory should still be around.
                       //
                       NtClose(hSubDir);
                   }
               }
           }
        }
    }

    //
    //  !fFindFirstFile implies that we manage open the root directory.
    //  If so we know that STATUS_NO_SUCH_FILE refers to the attempt
    //  to find subdirectories, and not to opening the root.
    //  Doctor error codes, and close the root.
    //
    if(!fFindFirstFile)
    {
        //
        //  The normal "successful" thing is that Status is STATUS_NO_MORE_FILES or
        //  STATUS_NO_SUCH_FILE. The caller just wants to see STATUS_SUCCESS.
        //
        if(
            (Status == STATUS_NO_MORE_FILES) ||
            (Status == STATUS_NO_SUCH_FILE)
        )
        {
            Status = STATUS_SUCCESS;
        }
        NtClose(hRoot);
    }

    return RtlNtStatusToDosError(Status);
}

#endif //XAPILIBP

#ifndef XAPILIBP

#undef DeleteFile
NTSTATUS
XapiNukeDirectoryFromHandle(
    HANDLE                      hDirectory,
    PFILE_DIRECTORY_INFORMATION DirectoryInfo
    )
/*++
  Routine Description:
    Helper function for XapiNukeDirectory.  Basically, it does the
    recursion of subdirectories.  It is more convenient to recursive
    using a handle.  This avoids writing ugly string parsing code which
    I am sure already exists in the object manager.  Additionally, since
    it doesn't open and close handles it is probably more efficient too.

  Arguments:
    hDirectory    - handle to directory to recursively delete.  Must be opened
                    with (FILE_LIST_DIRECTORY|DELETE|SYNCHRONIZE) access.
    DirectoryInfo - pointer to a FILE_DIRECTORY_INFORMATION immediately followed
                    by 255 characters (i.e. size must be sizeof(FILE_DIRECTORY_INFORMATION)
                    +sizeof(OCHAR)*255.
--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_STRING FileName;
    HANDLE hFile;
    BOOLEAN fFindFirst = TRUE;
    FILE_BASIC_INFORMATION BasicInfo;
    FILE_DISPOSITION_INFORMATION Disposition;

    do
    {
        Status = NtQueryDirectoryFile(
                    hDirectory,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    DirectoryInfo,
                    sizeof(FILE_DIRECTORY_INFORMATION)+sizeof(OCHAR)*254,
                    FileDirectoryInformation,
                    NULL,
                    fFindFirst
                    );
        fFindFirst = FALSE;
        //
        // If we succesfully found a file or directory then we have work to do
        //
        if (NT_SUCCESS(Status))
        {
            BOOLEAN fIsDirectory = (FILE_ATTRIBUTE_DIRECTORY&DirectoryInfo->FileAttributes) ? TRUE : FALSE;
            ACCESS_MASK accessMask = FILE_WRITE_ATTRIBUTES | DELETE | SYNCHRONIZE | (fIsDirectory ? FILE_LIST_DIRECTORY : 0);
            ULONG OpenOptions = FILE_OPEN_FOR_BACKUP_INTENT | (fIsDirectory ? FILE_DIRECTORY_FILE : FILE_NON_DIRECTORY_FILE);
            
            //
            //  Null terminate filename
            //
            DirectoryInfo->FileName[DirectoryInfo->FileNameLength/sizeof(OCHAR)] = OBJECT_NULL;

            //
            //  Create an OBJECT_STRING for the relative path of the filename
            //
            RtlInitObjectString(&FileName, DirectoryInfo->FileName);

            //
            //  Initialize Obja with Handle of the parent and the relative path.
            //
            InitializeObjectAttributes(
                &Obja,
                &FileName,
                OBJ_CASE_INSENSITIVE,
                hDirectory,
                NULL
                );

            //
            // Open the file
            //
            Status = NtOpenFile(
                        &hFile,
                        accessMask,
                        &Obja,
                        &IoStatusBlock,
                        FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                        OpenOptions
                        );

            if(NT_SUCCESS(Status))
            {
                //
                //  If it is a directory call ourselves recursively.
                //
                if(fIsDirectory)
                {
                    XapiNukeDirectoryFromHandle(hFile, DirectoryInfo);
                } else
                //
                //  Otherwise, Set FileDispositionInformation.DeleteFile = TRUE
                //
                {
                    //
                    //  If it has FILE_ATTRIBUTE_READONLY clear that first.
                    //
                    if(DirectoryInfo->FileAttributes&FILE_ATTRIBUTE_READONLY)
                    {
                        RtlZeroMemory(&BasicInfo,sizeof(BasicInfo));
                        BasicInfo.FileAttributes = 
                            (DirectoryInfo->FileAttributes&FILE_ATTRIBUTE_VALID_SET_FLAGS)&
                            ~FILE_ATTRIBUTE_READONLY;
                        BasicInfo.FileAttributes |= FILE_ATTRIBUTE_NORMAL;
                            
                        Status = NtSetInformationFile(
                                    hFile,
                                    &IoStatusBlock,
                                    &BasicInfo,
                                    sizeof(BasicInfo),
                                    FileBasicInformation
                                    );
                    }

                    if(NT_SUCCESS(Status))
                    {
                        //
                        // Sets to delete on close
                        //
                        Disposition.DeleteFile = TRUE;
                        Status = NtSetInformationFile(
                                    hFile,
                                    &IoStatusBlock,
                                    &Disposition,
                                    sizeof(Disposition),
                                    FileDispositionInformation
                                    );
                    }
                }
                //
                //  Close the handle, if it was a file this will delete it.
                //  If it was a directory, this should also delete it,
                //  provided the recursion succeeded.
                //
                NtClose(hFile);
            }
        }
    }while(NT_SUCCESS(Status));

    //
    //  If the loop terminated normally (we ran out of files to
    //  delete, or there were none in the first place), delete
    //  this handle.
    //
    if(
        (STATUS_NO_MORE_FILES == Status) ||
        (STATUS_NO_SUCH_FILE == Status)
    )
    {
        //
        //  Don't know if it is READ_ONLY.  Just blast over it,
        //  it will be deleted in a second anyway.
        //
        RtlZeroMemory(&BasicInfo,sizeof(BasicInfo));
        BasicInfo.FileAttributes = 
            (DirectoryInfo->FileAttributes&FILE_ATTRIBUTE_VALID_SET_FLAGS)&
            ~FILE_ATTRIBUTE_READONLY;
            BasicInfo.FileAttributes |= FILE_ATTRIBUTE_NORMAL;
        //
        //  Don't checked the error, this could conceivably fail
        //  and the coming delete will work anyway.  We would be fully
        //  satisfied.
        //
        NtSetInformationFile(
            hDirectory,
            &IoStatusBlock,
            &BasicInfo,
            sizeof(BasicInfo),
            FileBasicInformation
            );
        

        //
        // Sets to delete on close, the caller will
        // finish off the delete by closing the handle
        // it passed in.
        //
        Disposition.DeleteFile = TRUE;
        Status = NtSetInformationFile(
                        hDirectory,
                        &IoStatusBlock,
                        &Disposition,
                        sizeof(Disposition),
                        FileDispositionInformation
                        );
    }
    return Status;
}


NTSTATUS
XapiNukeDirectory(
    PCOSTR pszPath
    )
/*++
  Routine Description:
   Deletes a directory and all of its contents.
--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_STRING DirectoryName;
    HANDLE hDirectory;
    ASSERT(pszPath);

    //
    //  Open the file with delete permission
    //

    RtlInitObjectString(&DirectoryName, pszPath);
    InitializeObjectAttributes(
        &Obja,
        &DirectoryName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenFile(
            &hDirectory,
            FILE_LIST_DIRECTORY | DELETE | FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
            &Obja,
            &IoStatusBlock,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
            );

    if(NT_SUCCESS(Status))
    {
        struct {FILE_DIRECTORY_INFORMATION DirInfo;OCHAR Names[255];} Buffer;
        PFILE_DIRECTORY_INFORMATION DirectoryInfo = &Buffer.DirInfo;

        //
        //  Delegate to XapiNukeDirectoryFromHandle.
        //
        
        Status = XapiNukeDirectoryFromHandle(hDirectory, DirectoryInfo);

        //
        //  Close the handle, if XapiNukeDirectoryFromHandle was successful
        //  this will delete the file.
        //
        NtClose(hDirectory);
    }
    return Status;
}

#endif //XAPILIBP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\xvalue.c ===
#include "basedll.h"
#include "..\..\fatx\fatx.h"
#include "av.h"
#include "xconfig.h"
#include <xboxp.h>

#ifdef XAPILIBP

extern const OBJECT_STRING XapiHardDisk;

#else  // XAPILIBP

const OBJECT_STRING XapiHardDisk = CONSTANT_OBJECT_STRING( OTEXT("\\Device\\Harddisk0\\partition0") );

#endif // XAPILIBP


#ifdef XAPILIBP

DWORD
XSetValue(
    IN ULONG ulValueIndex,
    IN ULONG ulType,
    IN PVOID pValue,
    IN ULONG cbValueLength
    )
{
    NTSTATUS status;
    status = ExSaveNonVolatileSetting(ulValueIndex, ulType, pValue, cbValueLength);
    return RtlNtStatusToDosError(status);
}

#endif // XAPILIBP

#ifndef XAPILIBP

DWORD
XQueryValue(
    IN ULONG ulValueIndex,
    OUT PULONG pulType,
    OUT PVOID pValue,
    IN ULONG cbValueLength,
    IN OUT PULONG pcbResultLength
    )
{
    NTSTATUS status;

    status = ExQueryNonVolatileSetting(
                ulValueIndex,
                pulType,
                pValue,
                cbValueLength,
                pcbResultLength);

    return RtlNtStatusToDosError(status);
}


DWORD
XGetLanguage(
    VOID
    )
{
    ULONG ulType;
    DWORD dwValue;
    return NT_SUCCESS(ExQueryNonVolatileSetting(
                         XC_LANGUAGE,
                         &ulType,
                         &dwValue,
                         sizeof(dwValue),
                         NULL)) ? dwValue : XC_LANGUAGE_UNKNOWN;
}


DWORD
XGetAVPack(
    VOID
    )
{
    return *HalBootSMCVideoMode;
}


DWORD
XGetVideoStandard(
    VOID
    )
{
    ULONG ulType;
    DWORD dwValue;
    return NT_SUCCESS(ExQueryNonVolatileSetting(
                         XC_FACTORY_AV_REGION,
                         &ulType,
                         &dwValue,
                         sizeof(dwValue),
                         NULL)) ?
                          ((dwValue & AV_STANDARD_MASK) >> AV_STANDARD_BIT_SHIFT) :
                          0;
}


DWORD
XGetVideoFlags(
    VOID
    )
{
    ULONG ulType;
    DWORD dwValue = NT_SUCCESS(ExQueryNonVolatileSetting(
                               XC_VIDEO_FLAGS,
                               &ulType,
                               &dwValue,
                               sizeof(dwValue),
                               NULL)) ?
                                 ((dwValue & AV_USER_FLAGS_MASK) >> AV_USER_FLAGS_BIT_SHIFT) :
                                 0;

    switch (XGetAVPack())
    {
        case XC_AV_PACK_SCART:
        case XC_AV_PACK_VGA:
        case XC_AV_PACK_RFU:
        case XC_AV_PACK_SVIDEO:
        case XC_AV_PACK_STANDARD:

            //
            // Do not allow HDTV flags for AV packs that we know do not
            // support component out
            //

            dwValue &= ~(XC_VIDEO_FLAGS_HDTV_720p |
                         XC_VIDEO_FLAGS_HDTV_1080i |
                         XC_VIDEO_FLAGS_HDTV_480p);
            break;

        case XC_AV_PACK_HDTV:
        default:

             //
             // Allow HDTV flags for everything else
             //

             break;
    }

    return dwValue;
}


DWORD
XGetAudioFlags(
    VOID
    )
{
    ULONG ulType;
    DWORD dwValue = NT_SUCCESS(ExQueryNonVolatileSetting(
                               XC_AUDIO_FLAGS,
                               &ulType,
                               &dwValue,
                               sizeof(dwValue),
                               NULL)) ? dwValue : 0;

    switch (XGetAVPack())
    {
        case XC_AV_PACK_RFU:

            //
            // RF pack should always be mono because that is all that it can output
            //

            dwValue = XC_AUDIO_FLAGS_MONO;
            break;

        case XC_AV_PACK_STANDARD:

            //
            // Std pack has no optical output so we mask off DD & DTS bits
            //

            dwValue = XC_AUDIO_FLAGS_BASIC(dwValue);
            break;
    }

    return dwValue;
}


DWORD
XGetParentalControlSetting(
    VOID
    )
{
    ULONG ulType;
    DWORD dwValue;
    return NT_SUCCESS(ExQueryNonVolatileSetting(
                         XC_PARENTAL_CONTROL_GAMES,
                         &ulType,
                         &dwValue,
                         sizeof(dwValue),
                         NULL)) ? dwValue : 0;
}


DWORD
XGetGameRegion(
    VOID
    )
{
    ULONG ulType;
    DWORD dwValue;
    return NT_SUCCESS(ExQueryNonVolatileSetting(
                         XC_FACTORY_GAME_REGION,
                         &ulType,
                         &dwValue,
                         sizeof(dwValue),
                         NULL)) ? dwValue : 0;
}

#endif // ! XAPILIBP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\xapiheap.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    heap.c

Abstract:

    Maps the Win32 heap APIs to the Rtl heap functions

--*/

#include "basedll.h"
#pragma hdrstop

//
// Handle of the default process heap.
//
HANDLE XapiProcessHeap;

HANDLE
WINAPI
HeapCreate(
    DWORD flOptions,
    SIZE_T dwInitialSize,
    SIZE_T dwMaximumSize
    )
/*++

Routine Description:

    Creates a new heap

Arguments:

    flOptions - either HEAP_GENERATE_EXCEPTIONS or HEAP_NO_SERIALIZE
    dwInitialSize - initial heap size
    dwMaximumSize - maximum heap size

Return Value:

    Returns the new heap handle

--*/
{
    HANDLE hHeap;
    ULONG GrowthThreshold;
    ULONG Flags;


    Flags = (flOptions & (HEAP_GENERATE_EXCEPTIONS | HEAP_NO_SERIALIZE)) | HEAP_CLASS_1;
    GrowthThreshold = 0;

    if (dwMaximumSize < PAGE_SIZE) {

        if (dwMaximumSize == 0) {

            GrowthThreshold = PAGE_SIZE * 16;
            Flags |= HEAP_GROWABLE;
            }
        else {
            dwMaximumSize = PAGE_SIZE;
            }
        }

    if (GrowthThreshold == 0 && dwInitialSize > dwMaximumSize) {
        dwMaximumSize = dwInitialSize;
        }

    hHeap = (HANDLE)RtlCreateHeap( Flags,
                                   NULL,
                                   dwMaximumSize,
                                   dwInitialSize,
                                   0,
                                   NULL
                                 );
    if (hHeap == NULL) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        }

    return( hHeap );
}


BOOL
WINAPI
HeapDestroy(
    HANDLE hHeap
    )
{
    if (RtlDestroyHeap( (PVOID)hHeap ) == NULL ) {
        return( TRUE );
        }
    else {
        SetLastError( ERROR_INVALID_HANDLE );
        return( FALSE );
        }
}


BOOL
WINAPI
HeapFree(
    HANDLE hHeap,
    DWORD  dwFlags,
    LPVOID lpMem
    )
{
    return (BOOL) RtlFreeHeap( (PVOID)hHeap, dwFlags, lpMem );
}

#if DBG

BOOL
WINAPI
HeapValidate(
    HANDLE hHeap,
    DWORD dwFlags,
    LPVOID lpMem
    )
{
    return RtlValidateHeap( hHeap, dwFlags, lpMem );
}

#endif // DBG

HANDLE
WINAPI
GetProcessHeap( VOID )
/*++

Routine Description:

    Returns the handle for the process default heap (used with Local/GlobalXxxx functions)

Arguments:

Return Value:

    Process heap handle (can be used with HeapAlloc/HeapFree/HeapSize functions)

--*/
{
    return XapiProcessHeap;
}

#if DBG

WINBASEAPI
SIZE_T
WINAPI
HeapCompact(
    HANDLE hHeap,
    DWORD dwFlags
    )
{
    return RtlCompactHeap( hHeap, dwFlags );
}


WINBASEAPI
BOOL
WINAPI
HeapLock(
    HANDLE hHeap
    )
{
    return RtlLockHeap( hHeap );
}


WINBASEAPI
BOOL
WINAPI
HeapUnlock(
    HANDLE hHeap
    )
{
    return RtlUnlockHeap( hHeap );
}

WINBASEAPI
BOOL
WINAPI
HeapWalk(
    HANDLE hHeap,
    LPPROCESS_HEAP_ENTRY lpEntry
    )
{
    RTL_HEAP_WALK_ENTRY Entry;
    NTSTATUS Status;

    if (lpEntry->lpData == NULL) {
        Entry.DataAddress = NULL;
        Status = RtlWalkHeap( hHeap, &Entry );
        }
    else {
        Entry.DataAddress = lpEntry->lpData;
        Entry.SegmentIndex = lpEntry->iRegionIndex;
        if (lpEntry->wFlags & PROCESS_HEAP_REGION) {
            Entry.Flags = RTL_HEAP_SEGMENT;
            }
        else
        if (lpEntry->wFlags & PROCESS_HEAP_UNCOMMITTED_RANGE) {
            Entry.Flags = RTL_HEAP_UNCOMMITTED_RANGE;
            Entry.DataSize = lpEntry->cbData;
            }
        else
        if (lpEntry->wFlags & PROCESS_HEAP_ENTRY_BUSY) {
            Entry.Flags = RTL_HEAP_BUSY;
            }
        else {
            Entry.Flags = 0;
            }

        Status = RtlWalkHeap( hHeap, &Entry );
        }

    if (NT_SUCCESS( Status )) {
        lpEntry->lpData = Entry.DataAddress;
        lpEntry->cbData = (DWORD)Entry.DataSize;
        lpEntry->cbOverhead = Entry.OverheadBytes;
        lpEntry->iRegionIndex = Entry.SegmentIndex;
        if (Entry.Flags & RTL_HEAP_BUSY) {
            lpEntry->wFlags = PROCESS_HEAP_ENTRY_BUSY;

            //
            // DDESHARE and MOVEABLE are not meaningful on Xbox
            //
#if 0
            if (Entry.Flags & BASE_HEAP_FLAG_DDESHARE) {
                lpEntry->wFlags |= PROCESS_HEAP_ENTRY_DDESHARE;
                }

            if (Entry.Flags & BASE_HEAP_FLAG_MOVEABLE) {
                lpEntry->wFlags |= PROCESS_HEAP_ENTRY_MOVEABLE;
                lpEntry->Block.hMem = (HLOCAL)Entry.Block.Settable;
                }
#endif // 0

            memset( lpEntry->Block.dwReserved, 0, sizeof( lpEntry->Block.dwReserved ) );
            }
        else
        if (Entry.Flags & RTL_HEAP_SEGMENT) {
            lpEntry->wFlags = PROCESS_HEAP_REGION;
            lpEntry->Region.dwCommittedSize = Entry.Segment.CommittedSize;
            lpEntry->Region.dwUnCommittedSize = Entry.Segment.UnCommittedSize;
            lpEntry->Region.lpFirstBlock = Entry.Segment.FirstEntry;
            lpEntry->Region.lpLastBlock = Entry.Segment.LastEntry;
            }
        else
        if (Entry.Flags & RTL_HEAP_UNCOMMITTED_RANGE) {
            lpEntry->wFlags = PROCESS_HEAP_UNCOMMITTED_RANGE;
            memset( &lpEntry->Region, 0, sizeof( lpEntry->Region ) );
            }
        else {
            lpEntry->wFlags = 0;
            }

        return TRUE;
        }
    else {
        XapiSetLastNTError( Status );
        return FALSE;
        }
}

#endif // DBG

HLOCAL
WINAPI
LocalAlloc(
    UINT uFlags,
    SIZE_T uBytes
    )
/*++

Routine Description:

    The LocalAlloc function allocates the specified number of bytes from the heap.
    In the linear Win32 API environment, there is no difference between the
    local heap and the global heap.

    NOTE: Moveable memory is not implemented. LMEM_FIXED is always on.
Arguments:

    UINT uFlags - allocation attributes
    UINT uBytes - number of bytes to allocate

Return Value:

    Returns pointer to newly allocated memory or NULL on failure.

--*/
{
#if DBG
    // Validate flags
    if (uFlags & (LMEM_MOVEABLE | LMEM_DISCARDABLE))
    {
        RIP("LocalAlloc() invalid parameter (uFlags)");
    }
#endif // DBG

    return (HLOCAL)RtlAllocateHeap(XapiProcessHeap,
        (uFlags & LMEM_ZEROINIT) ? HEAP_ZERO_MEMORY : 0, (DWORD)uBytes);
}

HLOCAL
WINAPI
LocalReAlloc(
    HLOCAL hMem,
    SIZE_T uBytes,
    UINT uFlags
    )
/*++

Routine Description:

    The LocalReAlloc function changes the size of a specified 
    local memory object. The size can increase or decrease.

    NOTE: Since moveable memory isn't implemented, passing LMEM_MOVEABLE allows the handle
    (pointer) value to change on return. If LMEM_MOVEABLE is not passed in and there is
    no space following the memory block, the call may fail to grow the block size. Note
    that this is the opposite sense of the HEAP_REALLOC_IN_PLACE_ONLY flag.

Arguments:

    hMem - pointer to memory object to resize
    uBytes - new size
    uFlags - options for reallocation (same semantics as HeapReAlloc)

Return Value:

    returns the new handle (may have changed) or NULL on failure.

--*/
{
#if DBG
    // Validate flags
    if (uFlags & (LMEM_DISCARDABLE | LMEM_MODIFY))
    {
        RIP("LocalReAlloc() invalid parameter (uFlags)");
    }
#endif // DBG

    return (HLOCAL)RtlReAllocateHeap(XapiProcessHeap,
        (uFlags & LMEM_ZEROINIT) ? HEAP_ZERO_MEMORY : 0 +
        (uFlags & LMEM_MOVEABLE) ? 0 : HEAP_REALLOC_IN_PLACE_ONLY,
        (PVOID)hMem, (DWORD)uBytes);
}

SIZE_T
WINAPI
LocalSize(
    HLOCAL hMem
    )
/*++

Routine Description:

    Returns the size of an allocation in bytes. Also implements GlobalSize()

Arguments:

    hMem - pointer to memory

Return Value:

    size or zero on error.

--*/
{
    return (SIZE_T)RtlSizeHeap(XapiProcessHeap, 0, (LPVOID)hMem);
}

HLOCAL
WINAPI
LocalFree(
    HLOCAL hMem
    )
/*++

Routine Description:

    The LocalFree function frees the specified local memory object and
    invalidates its handle. Also implements GlobalFree().

Arguments:

    hMem - handle of local memory object

Return Value:

    If the function succeeds, the return value is NULL. If the function fails,
    the return value is equal to the handle of the local memory object.

--*/
{
    if (RtlFreeHeap(XapiProcessHeap, 0, (LPVOID)hMem))
        return NULL;
    else
        return hMem;
}

WINBASEAPI
LPVOID
WINAPI
LocalLock(
    IN HLOCAL hMem
    )
/*++

Routine Description:

    Maps a handle to a pointer. Since only fixed memory is supported,
    the input value is returned. This function is unneccesary overhead
    for applications to call. Note that no reference count is maintained.

Arguments:

    hMem - memory handle

Return Value:

    returns hMem cast to a pointer.

--*/
{
    return (LPVOID)hMem;
}

WINBASEAPI
HLOCAL
WINAPI
LocalHandle(
    IN LPCVOID pMem
    )
/*++

Routine Description:

    Maps a pointer to a handle. Since only fixed memory is supported,
    the input value is returned. It is safe to assume that handles == pointers
    for LocalXxxx functions.

Arguments:

    pMem - memory pointer

Return Value:

    returns pMem cast as a handle

--*/
{
    return (HLOCAL)pMem;
}

WINBASEAPI
BOOL
WINAPI
LocalUnlock(
    IN HLOCAL hMem
    )
/*++

Routine Description:

    Does nothing at all since only fixed memory is supported
    
Arguments:

    hMem - memory handle

Return Value:

    Always returns true

--*/
{
    return TRUE;
}

HGLOBAL
WINAPI
GlobalAlloc(
    UINT uFlags,
    SIZE_T dwBytes
    )
/*++

Routine Description:

    The GlobalAlloc function allocates the specified number of bytes from the heap.
    In the linear Win32 API environment, there is no difference between the 
    local heap and the global heap. 

    NOTE: Moveable memory is not implemented. GMEM_FIXED is always on.

Arguments:

    UINT uFlags - allocation attributes
    UINT uBytes - number of bytes to allocate  

Return Value:

    Returns pointer to newly allocated memory or NULL on failure.

--*/
{
#if DBG
    // Validate flags (don't allow GMEM_MOVEABLE or GMEM_DISCARDABLE
    // ignore all other flags--they should be completely benign)
    if (uFlags & (GMEM_MOVEABLE | GMEM_DISCARDABLE))
    {
        RIP("GlobalAlloc() invalid parameter (uFlags)");
    }
#endif // DBG

    return (HLOCAL)RtlAllocateHeap(XapiProcessHeap,
        (uFlags & GMEM_ZEROINIT) ? HEAP_ZERO_MEMORY : 0, (DWORD)dwBytes);
}

HGLOBAL
WINAPI
GlobalReAlloc(
    HANDLE hMem,
    SIZE_T uBytes,
    UINT uFlags
    )
/*++

Routine Description:

    The GlobalReAlloc function changes the size of a specified 
    local memory object. The size can increase or decrease.

    NOTE: Since moveable memory isn't implemented, passing GMEM_MOVEABLE allows the handle
    (pointer) value to change on return. If GMEM_MOVEABLE is not passed in and there is
    no space following the memory block, the call may fail to grow the block size. Note
    that this is the opposite sense of the HEAP_REALLOC_IN_PLACE_ONLY flag.

Arguments:

    hMem - pointer to memory object to resize
    uBytes - new size
    uFlags - options for reallocation (same semantics as HeapReAlloc)
    
Return Value:

    returns the new handle (may have changed) or NULL on failure.
    
--*/
{
#if DBG
    // Validate flags (don't allow GMEM_DISCARDABLE or GMEM_MODIFY, ignore others
    // as they should be completely benign)
    if (uFlags & (GMEM_DISCARDABLE | GMEM_MODIFY))
    {
        RIP("GlobalReAlloc() invalid parameter (uFlags)");
    }
#endif // DBG

    return (HLOCAL)RtlReAllocateHeap(XapiProcessHeap,
        (uFlags & GMEM_ZEROINIT) ? HEAP_ZERO_MEMORY : 0 +
        (uFlags & GMEM_MOVEABLE) ? 0 : HEAP_REALLOC_IN_PLACE_ONLY,
        (PVOID)hMem, (DWORD)uBytes);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\xsaveapi.c ===
#include "basedll.h"
#include "xmeta.h"

// Closest prime number to 2^48:
// 2^48 - 59 =  281474976710597 =  0xFFFFFFFFFFC5

#define SAVE_DIR_HASH_M 0xFFFFFFFFFFC5

#define HASHED_SAVE_GAME_CHARACTERS 12


__inline CHAR HexDigitToChar(INT d)
{
    return (d <= 9) ? (d + '0') : (d - 0xA + 'A');
}

//
// Unicode save game names are hashed into 48 bit numbers (12 8-bit hex characters)
//

VOID
XapiSaveGameHashEncode(
    PCWSTR pszSource,
    PSTR pszDestination,
    int cchDestination)
{
    int nChar = 0;
    DWORDLONG qwHashValue = 0;

    ASSERT(pszSource);
    ASSERT(pszDestination);
    ASSERT(cchDestination > HASHED_SAVE_GAME_CHARACTERS);

    while (pszSource[nChar])
    {
        //
        // This is effectively what we are doing below:
        //
        // qwHashValue = (((0x10000) * qwHashValue) + pszSource[nChar]) % SAVE_DIR_HASH_M;
        //

        qwHashValue = ((qwHashValue << 16) + pszSource[nChar]) % SAVE_DIR_HASH_M;
        nChar++;
    }

    for (nChar = (HASHED_SAVE_GAME_CHARACTERS - 1); nChar >= 0; nChar--)
    {
        pszDestination[nChar] =
            HexDigitToChar(
                ((INT) (qwHashValue >> (4 * ((HASHED_SAVE_GAME_CHARACTERS - 1) - nChar)))) & 0xF);
    }

    pszDestination[HASHED_SAVE_GAME_CHARACTERS] = '\0';
}

#if 0

//
// Note: hMetaFile should have been opened without FILE_SHARE_READ or
// FILE_SHARE_WRITE set, because we are potentially rewriting the entire file
// in this function
//

BOOL
XapiDeleteValueInMetaFile(
    HANDLE hMetaFile,
    LPCWSTR pszTag)
{
    PBYTE pBuffer;
    BOOL fRet = FALSE;
    DWORD dwSize = GetFileSize(hMetaFile, NULL);

    ASSERT(pszTag);

    if (dwSize)
    {
        pBuffer = (PBYTE) LocalAlloc(LMEM_FIXED, dwSize + sizeof(WCHAR));
        if (pBuffer)
        {
            PBYTE pCurrent = pBuffer;
            DWORD dwBytesRead;

            //
            // Place a NULL at the end of the buffer that should never
            // be overwritten - this makes it safe to use the wcsstr()
            // function later without worrying about running of the end
            //

            *((PWSTR) (&pBuffer[dwSize])) = UNICODE_NULL;

            SetFilePointer(hMetaFile, 0, NULL, FILE_BEGIN);

            while (ReadFile(hMetaFile,
                            pCurrent,
                            pBuffer - pCurrent - sizeof(WCHAR),
                            &dwBytesRead,
                            NULL))
            {
                if (0 == dwBytesRead)
                {
                    //
                    // The whole file has been read in
                    //

                    fRet = TRUE;
                    break;
                }
                pCurrent += dwBytesRead;

                if (pBuffer - pCurrent < sizeof(WCHAR))
                {
                    //
                    // Hmm.. the file is bigger than it used to be
                    //

                    break;
                }
            }

            if (fRet)
            {
                //
                // Scan the buffer for the tag/value pairs
                //

                DWORD dwNewSize = dwSize;
                PWSTR pszMatchTag, pszCRLF;
                int nTagLength = wcslen(pszTag);

                pCurrent = pBuffer;

                while ((pszMatchTag = wcsstr((PWSTR) pCurrent, pszTag)) &&
                       (pszCRLF = wcsstr((PWSTR) pCurrent, g_cszCRLF)))
                {
                    if ((pszMatchTag == (PWSTR) pCurrent) &&
                        (g_chEqual == pszMatchTag[nTagLength]))
                    {
                        //
                        // Got one
                        //

                        DWORD dwCutSize = sizeof(WCHAR) * (pszCRLF + g_cchCRLF - pszMatchTag);

                        ASSERT(dwNewSize >= dwCutSize);

                        dwNewSize -= dwCutSize;

                        //
                        // If we're not at the end of the buffer, slide the remaining
                        // buffer back to remove the part we just cut out
                        //

                        if (dwNewSize > (DWORD) (pCurrent - pBuffer))
                        {
                            RtlMoveMemory(pCurrent,
                                          pCurrent + dwCutSize,
                                          dwNewSize - (pCurrent - pBuffer));
                        }
                    }
                    else
                    {
                        pCurrent = (PBYTE) ((PWSTR) (pszCRLF + g_cchCRLF));
                    }

                    if ((DWORD) (pCurrent - pBuffer) >= dwNewSize)
                    {
                        //
                        // We've hit the end of the valid buffer
                        //

                        break;
                    }
                }

                if (dwNewSize != dwSize)
                {
                    DWORD dwBytesWritten;

                    //
                    // We've shrunk the size, so we need to write the file out
                    //

                    SetFilePointer(hMetaFile, 0, NULL, FILE_BEGIN);
                    SetEndOfFile(hMetaFile);

                    fRet = FALSE;

                    pCurrent = pBuffer;

                    while (WriteFile(hMetaFile,
                                     pCurrent,
                                     pBuffer + dwNewSize - pCurrent,
                                     &dwBytesWritten,
                                     NULL))
                    {
                        pCurrent += dwBytesWritten;

                        if ((DWORD) (pCurrent - pBuffer) >= dwNewSize)
                        {
                            fRet = TRUE;
                            break;
                        }
                    }
                }
            }

            SetFilePointer(hMetaFile, 0, NULL, FILE_BEGIN);

            LocalFree(pBuffer);
        }
    }

    return fRet;
}

#endif // 0

BOOL
XapiValidateAndSkipUnicodeSignature(
    HANDLE hMetaFile)
{
    WCHAR wchSig;
    DWORD dwRead;
    
    ASSERT(INVALID_HANDLE_VALUE != hMetaFile);
    ASSERT(hMetaFile);

    SetFilePointer(hMetaFile, 0, NULL, FILE_BEGIN);

    return (ReadFile(hMetaFile, &wchSig, sizeof(wchSig), &dwRead, NULL) &&
            (dwRead == sizeof(wchSig)) ||
            (wchSig == g_chUnicodeSignature));
}

BOOL
XapiFindValueInMetaFile(
    HANDLE hMetaFile,
    LPCWSTR pszTag,
    LPWSTR pszValue,
    int cchValue)
{
    BOOL  fRet = FALSE;
    DWORD dwBytesRead;
    WCHAR szBuffer[MAX_METADATA_LINE];
    PWSTR pszNextRead = szBuffer;
    UINT  cchRead = ARRAYSIZE(szBuffer) - 1;
    BOOL  fSkipThroughNextCRLF = FALSE;
    BOOL  fReuseBuffer = FALSE;
    int   nTagLength = wcslen(pszTag);

    //
    // Null terminate the end of the read buffer - we should never overwrite this
    //

    szBuffer[cchRead] = UNICODE_NULL;

    while (fReuseBuffer ||
           (ReadFile(hMetaFile,
                     pszNextRead,
                     cchRead * sizeof(WCHAR),
                     &dwBytesRead,
                     NULL) &&
            (0 != dwBytesRead)))
    {
        DWORD dwBytesValid = dwBytesRead + ((pszNextRead - szBuffer) * sizeof(WCHAR));

        fReuseBuffer = FALSE;

        if (fSkipThroughNextCRLF)
        {
            PWSTR pszCRLF = wcsstr(szBuffer, g_cszCRLF);
            pszNextRead = szBuffer;
            cchRead = ARRAYSIZE(szBuffer) - 1;

            if (pszCRLF)
            {
                DWORD dwBytesSkip;

                pszCRLF += g_cchCRLF;
                dwBytesSkip = ((PBYTE) pszCRLF - (PBYTE) szBuffer);

                ASSERT(dwBytesValid >= dwBytesSkip);

                if (dwBytesSkip < dwBytesValid)
                {
                    //
                    // move the next line of data that we just read to
                    // the beginning of the buffer
                    //

                    DWORD dwBytesMove = dwBytesValid - dwBytesSkip;

                    RtlMoveMemory(szBuffer,
                                  ((PBYTE) szBuffer) + dwBytesSkip,
                                  dwBytesMove);

                    pszNextRead = (PWSTR) (((PBYTE) szBuffer) + dwBytesMove);
                    cchRead = ARRAYSIZE(szBuffer) - 1 - (dwBytesMove >> 1);
                }

                fSkipThroughNextCRLF = FALSE;
            }
        }
        else
        {
            PWSTR pszMatchTag = wcsstr(szBuffer, pszTag);
            if (pszMatchTag && (g_chEqual == pszMatchTag[nTagLength]))
            {
                PWSTR pszCRLF;

                pszMatchTag += (nTagLength + 1);
                pszCRLF = wcsstr(pszMatchTag, g_cszCRLF);

                ASSERT(cchValue > 0);

                if (pszCRLF)
                {
                    DWORD dwBytesUsed;
                    int cchCopy = min(cchValue - 1, (pszCRLF - pszMatchTag));

                    //
                    // Copy the value string to the output buffer
                    //

                    wcsncpy(pszValue, pszMatchTag, cchCopy);

                    //
                    // Null terminate the output buffer
                    //

                    pszValue[cchCopy] = UNICODE_NULL;

                    pszCRLF += g_cchCRLF;

                    dwBytesUsed = ((PBYTE) pszCRLF - (PBYTE) szBuffer);

                    ASSERT(dwBytesValid >= dwBytesUsed);

                    if (dwBytesUsed < dwBytesValid)
                    {
                        //
                        // Move the file pointer back if we didn't use all of
                        // the data that we read
                        //

                        SetFilePointer(hMetaFile,
                                       (dwBytesUsed - dwBytesValid),
                                       NULL,
                                       FILE_CURRENT);
                    }

                    fRet = TRUE;

                    break;
                }
                else
                {
                    fSkipThroughNextCRLF = TRUE;
                    pszNextRead = szBuffer;
                    cchRead = ARRAYSIZE(szBuffer) - 1;
                }
            }
            else
            {
                fSkipThroughNextCRLF = TRUE;
                fReuseBuffer = TRUE;
            }
        }
    }

    return fRet;
}

BOOL
XapiFillInSaveGameData(
    PXGAME_FIND_DATA pFindGameData,
    PCOSTR pszRootDir,
    int cchRootDir)
{
    int nNameLen;
    int iCurIdentity;
    BOOL fRet = FALSE;

    ASSERT(pFindGameData);

    if (0 == (pFindGameData->wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
    {
        XDBGWRN("XAPI", "XFindSaveGame: Unexpected file found on save game drive");
        return FALSE;
    }

    nNameLen = ocslen(pFindGameData->wfd.cFileName);

    ASSERT(cchRootDir + nNameLen < ARRAYSIZE(pFindGameData->szSaveGameDirectory));

    ocscpy(pFindGameData->szSaveGameDirectory, pszRootDir);
    ocscpy(&(pFindGameData->szSaveGameDirectory[cchRootDir]),
           pFindGameData->wfd.cFileName);

    //
    // Append a backslash if there is room
    //

    if (cchRootDir + nNameLen < ARRAYSIZE(pFindGameData->szSaveGameDirectory) - 1)
    {
        pFindGameData->szSaveGameDirectory[cchRootDir + nNameLen] = OTEXT('\\');
        pFindGameData->szSaveGameDirectory[cchRootDir + nNameLen + 1] = OBJECT_NULL;
    }

    //
    // Attempt to open the metadata file
    //

    if (cchRootDir + nNameLen < (int) ARRAYSIZE(pFindGameData->szSaveGameDirectory) - g_cchSaveMetaFileName)
    {
        HANDLE hMetaFile;

        //
        // Borrow the output buffer temporarily to append the metadata filename
        //

        ocscpy(&(pFindGameData->szSaveGameDirectory[cchRootDir + nNameLen]), g_cszSaveMetaFileName);

        hMetaFile = CreateFile(pFindGameData->szSaveGameDirectory,
                               GENERIC_READ,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL);

        if (INVALID_HANDLE_VALUE != hMetaFile)
        {
            fRet = XapiValidateAndSkipUnicodeSignature(hMetaFile);

            if (fRet)
            {
                fRet = XapiFindValueInMetaFile(hMetaFile,
                                               g_cszNameTag,
                                               pFindGameData->szSaveGameName,
                                               ARRAYSIZE(pFindGameData->szSaveGameName));
            }

            CloseHandle(hMetaFile);
        }

        //
        // Restore the buffer (truncate to remove the metadata filename)
        //

        pFindGameData->szSaveGameDirectory[cchRootDir + nNameLen + 1] = OBJECT_NULL;
    }

    return fRet;
}

DWORD
XapiVerifyGameName(
    PCOSTR lpMetaFilePath,
    LPCWSTR lpSaveGameName)
{
    DWORD dwRet;

    HANDLE hMetaFile = CreateFile( lpMetaFilePath,
                                   SYNCHRONIZE | GENERIC_READ,
                                   0,
                                   NULL,
                                   OPEN_ALWAYS,
                                   FILE_ATTRIBUTE_SYSTEM,
                                   NULL);

    if (INVALID_HANDLE_VALUE != hMetaFile)
    {
        WCHAR szName[MAX_GAMENAME];

        if (XapiValidateAndSkipUnicodeSignature(hMetaFile) &&
            XapiFindValueInMetaFile(hMetaFile, g_cszNameTag, szName, ARRAYSIZE(szName)) &&
            (0 == wcscmp(szName, lpSaveGameName)))
        {
            dwRet = ERROR_SUCCESS;
        }
        else
        {
            dwRet = ERROR_NO_MATCH;
        }

        CloseHandle(hMetaFile);
    }
    else
    {
        dwRet = GetLastError();
    }

    return dwRet;
}

VOID
XapiTouchDirectoryTimestamp(
    LPCSTR pcszDir
    )
{
    HANDLE hDir = CreateFile(pcszDir,
                             GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             OPEN_EXISTING,
                             FILE_FLAG_BACKUP_SEMANTICS,
                             NULL);

    if (INVALID_HANDLE_VALUE != hDir)
    {
        FILE_BASIC_INFORMATION BasicInfo;
        IO_STATUS_BLOCK IoStatusBlock;

        //
        // Zero all the time values we can set.
        //

        RtlZeroMemory(&BasicInfo, sizeof(BasicInfo));

        //
        // Set the last write times
        //

        KeQuerySystemTime(&BasicInfo.LastWriteTime);

        NtSetInformationFile(
                    hDir,
                    &IoStatusBlock,
                    &BasicInfo,
                    sizeof(BasicInfo),
                    FileBasicInformation
                    );

        CloseHandle(hDir);
    }
}

DWORD
WINAPI
XCreateSaveGame(
    IN PCOSTR lpRootPathName,
    IN LPCWSTR lpSaveGameName,
    IN DWORD dwCreationDisposition,
    IN DWORD dwCreateFlags,
    OUT POSTR lpPathBuffer,
    IN UINT uSize)
{
    OCHAR szDirName[MAX_PATH];
    int nPathLength;
    int iCurIdentity;
    HANDLE hMetaFile;
    BOOL fNewCreation;
    DWORD dwNameVerifyResult;

#if DBG
    if ((NULL == lpSaveGameName) ||
        (wcslen(lpSaveGameName) >= MAX_GAMENAME) ||
        (NULL != wcsstr(lpSaveGameName, g_cszCRLF)) ||
        (NULL == lpRootPathName) ||
        (OTEXT('\0') == lpRootPathName[0]) ||
        (OTEXT(':') != lpRootPathName[1]) ||
        (OTEXT('\\') != lpRootPathName[2]) ||
        (OTEXT('\0') != lpRootPathName[3]) ||
        ((CREATE_NEW != dwCreationDisposition) &&
         (OPEN_EXISTING != dwCreationDisposition) &&
         (OPEN_ALWAYS != dwCreationDisposition)))
    {
        RIP("XCreateSaveGame() invalid parameter");
    }

    RIP_ON_NOT_TRUE("XCreateSaveGame()",
                    ((0 == dwCreateFlags) ||
                     ((XSAVEGAME_NOCOPY == dwCreateFlags) && (OPEN_EXISTING != dwCreationDisposition))));

    {
        //
        // Removing the 0x20 bit will make lower case characters uppercase
        //

        OCHAR chDrive = lpRootPathName[0] & (~0x20);

        if (((chDrive < MU_FIRST_DRIVE) || (chDrive > MU_LAST_DRIVE)) &&
            (HD_UDATA_DRIVE != chDrive) &&
            (HD_ALT_UDATA_DRIVE != chDrive))
        {
            RIP("XCreateSaveGame() invalid drive letter parameter");
        }
    }

#endif // DBG

    ocscpy(szDirName, lpRootPathName);
    nPathLength = ocslen(szDirName);
    XapiSaveGameHashEncode(lpSaveGameName,
                           &(szDirName[nPathLength]),
                           ARRAYSIZE(szDirName) - nPathLength - g_cchSaveMetaFileName);

    nPathLength = ocslen(szDirName);

    ASSERT(nPathLength < (int) ARRAYSIZE(szDirName) - g_cchSaveMetaFileName);

    if (OPEN_EXISTING == dwCreationDisposition)
    {
        ocscpy(&(szDirName[nPathLength]), g_cszSaveMetaFileName);
        dwNameVerifyResult = XapiVerifyGameName(szDirName, lpSaveGameName);
        szDirName[nPathLength] = OBJECT_NULL;

        if (ERROR_SUCCESS == dwNameVerifyResult)
        {
            //
            // The existing directory has a metadata file with the same game name,
            // so we're done
            //
            fNewCreation = FALSE;
        }
        else
        {
            return dwNameVerifyResult;
        }
    }
    else
    {
        if (CreateDirectory(szDirName, NULL))
        {
            fNewCreation = TRUE;
        }
        else
        {
            DWORD dwErr = GetLastError();

            dwNameVerifyResult = ERROR_NO_MATCH;

            if (ERROR_ALREADY_EXISTS == dwErr)
            {
                ocscpy(&(szDirName[nPathLength]), g_cszSaveMetaFileName);
                dwNameVerifyResult = XapiVerifyGameName(szDirName, lpSaveGameName);
                szDirName[nPathLength] = OBJECT_NULL;

                if (ERROR_SUCCESS == dwNameVerifyResult)
                {
                    //
                    // This is the right directory - touch the timestamp
                    // so that the dashboard will see this as the most recently
                    // used save game
                    //

                    XapiTouchDirectoryTimestamp(szDirName);
                }
                else
                {
                    return ERROR_CANNOT_MAKE;
                }
            }

            if ((CREATE_NEW != dwCreationDisposition) && (ERROR_SUCCESS == dwNameVerifyResult))
            {
                //
                // The save game name in the metadata file matched, so we're ok to
                // continue with the rest of this function
                //
                fNewCreation = FALSE;
            }
            else
            {
                return dwErr;
            }
        }
    }

    if (fNewCreation)
    {
        OBJECT_ATTRIBUTES objectAttributes;
        IO_STATUS_BLOCK   ioStatusBlock;
        LARGE_INTEGER     allocationSize;
        OBJECT_STRING     metaFilePathString;
        NTSTATUS          status;

        //
        // Create SAVEMETA.XBX file underneath the save game directory and
        // write metadata information there
        //
        ocscpy(&(szDirName[nPathLength]), g_cszSaveMetaFileName);

        RtlInitObjectString(&metaFilePathString, szDirName);
        
        InitializeObjectAttributes(
            &objectAttributes,
            &metaFilePathString,
            OBJ_CASE_INSENSITIVE,
            ObDosDevicesDirectory(),
            NULL
            );

        allocationSize.QuadPart = 1;

        status = NtCreateFile(
                      &hMetaFile,
                      SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE,
                      &objectAttributes,
                      &ioStatusBlock,
                      &allocationSize,
                      FILE_ATTRIBUTE_SYSTEM,
                      0,
                      FILE_OPEN_IF,
                      FILE_WRITE_THROUGH | FILE_SYNCHRONOUS_IO_NONALERT
                      );

        szDirName[nPathLength] = OBJECT_NULL;

        if(FAILED(status))
        {
            DWORD dwErr = RtlNtStatusToDosError(status);

            //
            // We failed, so try to remove the directory that we just created
            // so we don't leave an orphan empty directory in the file system.
            //

            RemoveDirectory(szDirName);

            return dwErr;
        }
        else
        {
            DWORD dwBytesWritten = 0;
            DWORD dwSize;

            //
            // One signature WCHAR plus a line of meta data
            //
            
            WCHAR szBuffer[1 + MAX_METADATA_LINE + g_cchNoCopyTrue];

            //
            // Only write the name into the metadata file when we first create it
            //

            _snwprintf(szBuffer,
                       ARRAYSIZE(szBuffer),
                       (XSAVEGAME_NOCOPY & dwCreateFlags) ?
                           L"%lc%ls%lc%ls%ls%ls" :
                           L"%lc%ls%lc%ls%ls",
                       g_chUnicodeSignature,
                       g_cszNameTag,
                       g_chEqual,
                       lpSaveGameName,
                       g_cszCRLF,
                       g_cszNoCopyTrue);

            dwSize = sizeof(WCHAR) * wcslen(szBuffer);

            while (dwSize)
            {
                DWORD dwWrittenNow;
                
                if (!WriteFile(hMetaFile,
                               (PBYTE) szBuffer + dwBytesWritten,
                               dwSize,
                               &dwWrittenNow,
                               NULL))
                {
                    DWORD dwErr = GetLastError();

                    CloseHandle(hMetaFile);
                    
                    //
                    // We failed, so try to remove the directory that we just created
                    // so we don't leave an orphan empty directory in the file system.
                    //
                    
                    RemoveDirectory(szDirName);

                    return dwErr;
                }

                dwSize -= dwWrittenNow;
            }

            CloseHandle(hMetaFile);
        }
    }
#if DBG
    else if (0 != dwCreateFlags)
    {
        XDBGWRN("XAPI",
                "XCreateSaveGame() ignoring dwCreateFlags because save game %ls already exists",
                lpSaveGameName);
    }
#endif // DBG

    if (NULL != lpPathBuffer)
    {
        lstrcpynO(lpPathBuffer, szDirName, uSize);

        if ((UINT) nPathLength < (uSize - 1))
        {
            //
            // Append a backslash (if there is room)
            //

            lpPathBuffer[nPathLength] = OTEXT('\\');
            lpPathBuffer[nPathLength + 1] = OBJECT_NULL;
        }
    }

    return ERROR_SUCCESS;
}

DWORD
WINAPI
XDeleteSaveGame(
    IN PCOSTR lpRootPathName,
    IN LPCWSTR lpSaveGameName)
{
    OCHAR szDirName[64 + MAX_PATH];
    int nPathLength;
    DWORD dwNameVerifyResult;
    int nPrefixLength;
    NTSTATUS Status;

#if DBG
    if ((NULL == lpSaveGameName) ||
        (wcslen(lpSaveGameName) >= MAX_GAMENAME) ||
        (NULL != wcsstr(lpSaveGameName, g_cszCRLF)) ||
        (NULL == lpRootPathName) ||
        (OTEXT('\0') == lpRootPathName[0]) ||
        (OTEXT(':')  != lpRootPathName[1]) ||
        (OTEXT('\\') != lpRootPathName[2]) ||
        (OTEXT('\0') != lpRootPathName[3]))
    {
        RIP("XDeleteSaveGame() invalid parameter");
    }

    {
        //
        // Removing the 0x20 bit will make lower case characters uppercase
        //

        OCHAR chDrive = lpRootPathName[0] & (~0x20);

        if (((chDrive < MU_FIRST_DRIVE) || (chDrive > MU_LAST_DRIVE)) &&
            (HD_UDATA_DRIVE != chDrive) &&
            (HD_ALT_UDATA_DRIVE != chDrive))
        {
            RIP("XDeleteSaveGame() invalid drive letter parameter");
        }
    }
#endif // DBG

    ocscpy(szDirName, OTEXT("\\??\\"));
    nPrefixLength = ocslen(szDirName);

    ocscpy(&(szDirName[nPrefixLength]), lpRootPathName);
    nPathLength = ocslen(szDirName);

    XapiSaveGameHashEncode(lpSaveGameName,
                           &(szDirName[nPathLength]),
                           ARRAYSIZE(szDirName) - nPathLength - g_cchSaveMetaFileName);

    nPathLength = ocslen(szDirName);

    ASSERT(nPathLength < (int) ARRAYSIZE(szDirName) - g_cchSaveMetaFileName);

    ocscpy(&(szDirName[nPathLength]), g_cszSaveMetaFileName);
    dwNameVerifyResult = XapiVerifyGameName(&(szDirName[nPrefixLength]), lpSaveGameName);
    szDirName[nPathLength] = OBJECT_NULL;

    if (ERROR_SUCCESS != dwNameVerifyResult)
    {
        return dwNameVerifyResult;
    }

    //
    // The directory exists with a metadata file in it with a matching game
    // name, so it is safe to proceed
    //
    
    szDirName[nPathLength] = OTEXT('\\');
    szDirName[nPathLength + 1] = OBJECT_NULL;

    Status = XapiNukeDirectory(szDirName);

    return RtlNtStatusToDosError(Status);
}

HANDLE
WINAPI
XFindFirstSaveGame(
    IN PCOSTR lpRootPathName,
    OUT PXGAME_FIND_DATA pFindGameData)
{
    OCHAR szDirName[MAX_PATH];
    int cchRootDir;
    HANDLE hRet;

#if DBG
    if ((NULL == pFindGameData) ||
        (NULL == lpRootPathName) ||
        (OTEXT('\0') == lpRootPathName[0]) ||
        (OTEXT(':')  != lpRootPathName[1]) ||
        (OTEXT('\\') != lpRootPathName[2]) ||
        (OTEXT('\0') != lpRootPathName[3]))
    {
        RIP("XFindFirstSaveGame() invalid parameter");
    }

    {
        //
        // Removing the 0x20 bit will make lower case characters uppercase
        //

        OCHAR chDrive = lpRootPathName[0] & (~0x20);

        if (((chDrive < MU_FIRST_DRIVE) || (chDrive > MU_LAST_DRIVE)) &&
            (HD_UDATA_DRIVE != chDrive) &&
            (HD_ALT_UDATA_DRIVE != chDrive))
        {
            RIP("XFindFirstSaveGame() invalid drive letter parameter");
        }
    }
#endif // DBG

    //
    // Create <path>\<*.*> in our own buffer
    //

    ocscpy(szDirName, lpRootPathName);
    cchRootDir = ocslen(szDirName);

    if (cchRootDir > ((int) ARRAYSIZE(szDirName) - 1 - g_cchStar))
    {
        RIP("XFindFirstSaveGame() lpRootPathName parameter too long");
    }

    ocscpy(&(szDirName[cchRootDir]), g_cszStar);

    hRet = FindFirstFile(szDirName, (PWIN32_FIND_DATA) pFindGameData);

    if (INVALID_HANDLE_VALUE != hRet)
    {
        if (!XapiFillInSaveGameData(pFindGameData, lpRootPathName, cchRootDir))
        {
            BOOL fFound;

            while (fFound = FindNextFile(hRet, (PWIN32_FIND_DATA) pFindGameData))
            {
                if (XapiFillInSaveGameData(pFindGameData, lpRootPathName, cchRootDir))
                {
                    break;
                }
            }

            if (!fFound)
            {
                //
                // We didn't find a save game directory
                //

                FindClose(hRet);
                hRet = INVALID_HANDLE_VALUE;
                SetLastError(ERROR_NO_MORE_FILES);
            }
        }
    }

    if (INVALID_HANDLE_VALUE != hRet)
    {
        PFINDGAME_HANDLE pFindGame = LocalAlloc(LMEM_FIXED, sizeof(FINDGAME_HANDLE));

        if (NULL != pFindGame)
        {
            pFindGame->dwSignature = FH_SIG_SAVEGAME;
            pFindGame->hFindFile = hRet;
            pFindGame->cchRootDir = cchRootDir;
            lstrcpynO(pFindGame->szRootDir, lpRootPathName, ARRAYSIZE(pFindGame->szRootDir));
            hRet = (HANDLE) pFindGame;
        }
        else
        {
            FindClose(hRet);
            hRet = INVALID_HANDLE_VALUE;
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    return hRet;
}

BOOL
WINAPI
XFindNextSaveGame(
    IN HANDLE hFindGame,
    OUT PXGAME_FIND_DATA pFindGameData)
{
    BOOL bRet = FALSE;

#if DBG
    if ((NULL == hFindGame) ||
        (INVALID_HANDLE_VALUE == hFindGame) ||
        (FH_SIG_SAVEGAME != ((PFINDGAME_HANDLE) hFindGame)->dwSignature) ||
        (NULL == pFindGameData))
    {
        RIP("XFindNextSaveGame() invalid parameter");
    }
#endif // DBG

    {
        PFINDGAME_HANDLE pFindGame = (PFINDGAME_HANDLE) hFindGame;

        while (bRet = FindNextFile(pFindGame->hFindFile, (PWIN32_FIND_DATA) pFindGameData))
        {
            if (XapiFillInSaveGameData(pFindGameData, pFindGame->szRootDir, pFindGame->cchRootDir))
            {
                break;
            }
        }
    }

    return bRet;
}

BOOL
WINAPI
XFindClose(
    IN HANDLE hFindGame)
{
    BOOL fRet = FALSE;

    //
    // Note that all XFind handles begin with a DWORD signature that
    // identifies the type of XFind handle we're dealing with
    //

#if DBG
    if ((INVALID_HANDLE_VALUE == hFindGame) ||
        (NULL == hFindGame) ||
        ((FH_SIG_SAVEGAME != *((PDWORD) hFindGame)) &&
         (FH_SIG_NICKNAME != *((PDWORD) hFindGame)) &&
         (FH_SIG_CONTENT!= *((PDWORD) hFindGame)) &&
         (FH_SIG_SOUNDTRACK != *((PDWORD) hFindGame))))
    {
        RIP("XFindClose() invalid parameter (hFindGame)");
    }
#endif // DBG

    switch (*((PDWORD) hFindGame))
    {
        case FH_SIG_SAVEGAME:
        {
            PFINDGAME_HANDLE pFindGame = (PFINDGAME_HANDLE) hFindGame;
            HANDLE hFindFile = pFindGame->hFindFile;
            LocalFree(pFindGame);

            fRet = FindClose(hFindFile);
            break;
        }

        case FH_SIG_CONTENT:
        {
            PFINDCONTENT_HANDLE pFindCont = (PFINDCONTENT_HANDLE) hFindGame;
            HANDLE hFindFile = pFindCont->hFindFile;
            LocalFree(pFindCont);

            fRet = FindClose(hFindFile);
            break;
        }

        case FH_SIG_SOUNDTRACK:
        {
            PSNDTRK_ENUMSTATE pst = (PSNDTRK_ENUMSTATE) hFindGame;
            HANDLE hFindFile = pst->DbHandle;
            LocalFree(pst);

            fRet = FindClose(hFindFile);
            break;
        }

        case FH_SIG_NICKNAME:
        {
            LocalFree(hFindGame);
            fRet = TRUE;
            break;
        }
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\xprofile.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    xprofile.c

Abstract:

    XAPI profiling support functions

Notes:

    We access the kernel's profiling data buffer directly.
    If the kernel's data structure changes, be sure to
    update the CAP_Start_Profiling and CAP_End_Profiling
    functions accordingly.

--*/

#include "basedll.h"

#ifdef _XBOX_ENABLE_PROFILING

#include "xprofp.h"

//
// Pointer to the kernel's global profiling data structure
//
XProfpGlobals* XapipProfileData;

VOID XapipInitProfiling() {
    XapipProfileData = XProfpGetData();
}


VOID __declspec(naked) __stdcall
_CAP_Start_Profiling(
    VOID* caller,
    VOID* callee
    )

/*++

Routine Description:

    Just before a function is about to be called

Arguments:

    caller - Specifies the caller function
    callee - Specifies the called function

Return Value:

    NONE

Notes:

    All registers are preserved.

--*/

{
    /*
        ULONG* buf;

    loop:
        buf = XProfpData.bufnext
        if buf >= XProfpData.bufend, return
        Atomical incremnt XProfpData.bufnext by 4 ULONGs
        if failed, goto loop

        buf[0] = timestamp-high
        buf[1] = timestamp-low
        buf[2] = caller
        buf[3] = callee

     */

    __asm {
        push    ecx
        mov     ecx, XapipProfileData
        test    ecx, ecx
        jz      ret2

        push    eax
        push    edx
        mov     eax, [ecx]          ; eax = XProfpData.bufnext
    loop1:
        cmp     eax, [ecx+4]        ; XProfpData.bufnext >= XProfpData.bufend?
        jae     ret1
        lea     edx, [eax+16]       ; XProfpData.bufnext += 4
        cmpxchg [ecx], edx
        jnz     loop1

        mov     ecx, eax
        rdtsc
        mov     [ecx], edx          ; timestamp-high
        mov     [ecx+4], eax        ; timestamp-low
        mov     eax, [esp+16]       ; caller - 3 pushes + return address
        mov     [ecx+8], eax
        mov     eax, [esp+20]       ; callee
        mov     [ecx+12], eax

    ret1:
        pop     edx
        pop     eax
    ret2:
        pop     ecx
        ret     8
    }
}


VOID __declspec(naked) __stdcall
_CAP_End_Profiling(
    VOID* caller
    )
/*++

Routine Description:

    Just after a function call is made

Arguments:

    caller - Specifies the caller function

Return Value:

    NONE

Notes:

    All registers are preserved.

--*/

{
    // Same logic as above, except the record is smaller by 1 ULONG

    __asm {
        push    ecx
        mov     ecx, XapipProfileData
        test    ecx, ecx
        jz      ret2

        push    eax
        push    edx
        mov     eax, [ecx]          ; eax = XProfpData.bufnext
    loop1:
        cmp     eax, [ecx+4]        ; XProfpData.bufnext >= XProfpData.bufend?
        jae     ret1
        lea     edx, [eax+12]       ; XProfpData.bufnext += 3
        cmpxchg [ecx], edx
        jnz     loop1

        mov     ecx, eax
        rdtsc
        bts     edx, 29             ; timestamp-high | XPROFREC_CALL_END
        mov     [ecx], edx
        mov     [ecx+4], eax        ; timestamp-low
        mov     eax, [esp+16]       ; caller
        mov     [ecx+8], eax

    ret1:
        pop     edx
        pop     eax
    ret2:
        pop     ecx
        ret     4
    }
}

#endif // _XBOX_ENABLE_PROFILING
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\xpp.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    xpp.c

Abstract:

    Xbox Peripheral Port support

    The USB stack reports the insertion and removal of all devices here.  This module converts the PNP_CLASS_ID
    to the Xbox Device Type and vice versa.

    The Xbox device type is a simple 0 based index into a table of devices allowing an efficient implementation
    of XGetDevices, XGetDeviceChanges.

Environment:

    XAPI

Notes:

Revision History:

    06-26-00 created by Mitchell Dernis (mitchd)

--*/

#include "basedll.h"
#pragma warning( push, 4 )
#pragma warning( disable: 4213)
#include <usbxapi.h>

typedef struct _XPP_DEVICE_TYPE_INTERNAL
{
    ULONG CurrentConnected;
    ULONG ChangeConnected;
    ULONG PreviousConnected;
} XPP_DEVICE_TYPE_INTERNAL, *PXPP_DEVICE_TYPE_INTERNAL;

BOOL XPP_XInitDevicesHasBeenCalled = FALSE;

VOID
XdReportDeviceInsertionRemoval(
    PXPP_DEVICE_TYPE XppDeviceType,
    ULONG    PortBit,
    BOOLEAN  fInserted
    )

/*++
Routine Description:

    Called by the USB stack to report the insertion and removal of devices.
    Keeps the XPP_GlobalDeviceTable up-to-date.

Comments:
    This routine is called at DPC level

Parameters:
    XppDeviceType - Pointer to XPP type.
    PortBit   - Port bit position in bitmap.
    fInserted - TRUE on device insertion, FALSE on removal.

--*/
{
    DWORD dwPortMask = 1 << PortBit;
    PXPP_DEVICE_TYPE_INTERNAL pXppTypeInternal =
        (PXPP_DEVICE_TYPE_INTERNAL) XppDeviceType;
    ASSERT(sizeof(PXPP_DEVICE_TYPE_INTERNAL)==sizeof(PXPP_DEVICE_TYPE));

    //
    //  Set the change flag
    //
    pXppTypeInternal->ChangeConnected |=dwPortMask;
    //
    //  Set or clear the CurrentConnected bit
    //
    if(fInserted)
    {
        pXppTypeInternal->CurrentConnected |= dwPortMask;
    } else
    {
        pXppTypeInternal->CurrentConnected &= ~dwPortMask;
    }
}

//------------------------------------------------------------------
//  Internal API
//------------------------------------------------------------------
DWORD
WINAPI
XPeekDevices(
    IN  PXPP_DEVICE_TYPE DeviceType,
    IN  OUT PDWORD pLastGotten,
    IN  OUT PDWORD pStale
    )
/*++
  Routine Description:
    This is an internal routine which can be used to determine which devices are connected.
    It is designed not to interfere with the game which calles XGetDevices and XGetDeviceChanges.
    It also allows the caller to track what the game knows about.
  Arguments:
    DeviceType  - the device for which information is requested.
    pLastGotten - If non-NULL, filled out on exit with a bitmap of connected devices
                  as seen by the game.
    pState      - If non-NULL, filled out on exit with a bitmap of devices which have
                  been removed and reinserted since the last time the game called
                  XGetDevices or XGetDeviceChanges.
--*/
{
    KIRQL oldIrql;
    DWORD dwRetVal;
    PXPP_DEVICE_TYPE_INTERNAL pXppTypeInternal = 
        (PXPP_DEVICE_TYPE_INTERNAL) DeviceType;

    RIP_ON_NOT_TRUE_WITH_MESSAGE(XPP_XInitDevicesHasBeenCalled, "XGetDevices: XInitDevices must be called first!");
  
    //
    //  Raise to DPC for sync.
    //
    oldIrql = KeRaiseIrqlToDpcLevel();

    //
    //  Return all devices
    //
    dwRetVal = pXppTypeInternal->CurrentConnected;

    //
    //  Fill out *pLastGotten.
    //
    if(pLastGotten)
    {
        *pLastGotten = pXppTypeInternal->PreviousConnected;
    }

    //
    //  Fill out *pStale.
    //
    if(pStale)
    {
        *pStale = pXppTypeInternal->CurrentConnected & 
                  pXppTypeInternal->PreviousConnected &
                  pXppTypeInternal->ChangeConnected;
    }

    //
    //  Done with syncronization.
    //
    KeLowerIrql(oldIrql);
    return dwRetVal;
}


//------------------------------------------------------------------
//  Public API
//------------------------------------------------------------------

VOID
WINAPI
XInitDevices(DWORD NumDeviceTypes, PXDEVICE_PREALLOC_TYPE DeviceTypes)
{
#if DBG
    if(XPP_XInitDevicesHasBeenCalled)
    {
        RIP("XInitDevices() is called more than once.  Fatal Error.");
    }
    else
    {
        XPP_XInitDevicesHasBeenCalled = TRUE;
    }
#endif

    USBD_Init(NumDeviceTypes, DeviceTypes);
}


DWORD
WINAPI
XGetDevices(
    IN  PXPP_DEVICE_TYPE DeviceType
    )
{
    KIRQL oldIrql;
    DWORD dwRetVal;
    PXPP_DEVICE_TYPE_INTERNAL pXppTypeInternal = 
        (PXPP_DEVICE_TYPE_INTERNAL) DeviceType;

    RIP_ON_NOT_TRUE_WITH_MESSAGE(XPP_XInitDevicesHasBeenCalled, "XGetDevices: XInitDevices must be called first!");
  
    //
    //  Raise to DPC for sync.
    //
    oldIrql = KeRaiseIrqlToDpcLevel();
    //
    //  Fill in insertion bitmap with all devices
    //
    dwRetVal = pXppTypeInternal->CurrentConnected;
    //
    //  Erase changed and reset previous
    //
    pXppTypeInternal->ChangeConnected = 0;
    pXppTypeInternal->PreviousConnected = pXppTypeInternal->CurrentConnected;

    //
    //  Done with syncronization.
    //
    KeLowerIrql(oldIrql);
    return dwRetVal;
}

BOOL
WINAPI
XGetDeviceChanges(
    IN  IN  PXPP_DEVICE_TYPE DeviceType,
    OUT PDWORD pInsertions,
    OUT PDWORD pRemovals
    )
{
    KIRQL oldIrql;

    PXPP_DEVICE_TYPE_INTERNAL pXppTypeInternal = 
        (PXPP_DEVICE_TYPE_INTERNAL) DeviceType;

    RIP_ON_NOT_TRUE_WITH_MESSAGE(XPP_XInitDevicesHasBeenCalled, "XGetDeviceChanges: XInitDevices must be called first!");
    
    if(!pXppTypeInternal->ChangeConnected)
    {
        //
        //  Nothing has changed since the last call.  Get out quickly.
        //
        *pInsertions = 0;
        *pRemovals = 0;
        return FALSE;
    }
    else
    {
      //
      //  Something has changed, so calculate the full info.
      //

      ULONG RemoveInsert;

      //
      //  Raise to DPC for sync.
      //

      oldIrql = KeRaiseIrqlToDpcLevel();

      //
      //  Construct the simple case of add or remove.
      //

      *pInsertions = (pXppTypeInternal->CurrentConnected & ~pXppTypeInternal->PreviousConnected);
      *pRemovals = (pXppTypeInternal->PreviousConnected & ~pXppTypeInternal->CurrentConnected);

      //
      // Now add more insertions and removals for the case of remove and reinsert
      //

      RemoveInsert = pXppTypeInternal->ChangeConnected &
                     pXppTypeInternal->CurrentConnected &
                     pXppTypeInternal->PreviousConnected;
      *pRemovals |= RemoveInsert;
      *pInsertions |= RemoveInsert;

      //
      //  Record that we retrieved info
      //
      
      pXppTypeInternal->ChangeConnected = 0;
      pXppTypeInternal->PreviousConnected = pXppTypeInternal->CurrentConnected;
      
      //
      //  Done with syncronization.
      //

      KeLowerIrql(oldIrql);
      return (*pInsertions|*pRemovals) ? TRUE : FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\xsndtrk.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    xsndtrk.c

Abstract:

    XTL Soundtrack Enumeration APIs

Notes:

    Provides support for enumerating the soundtracks a user has ripped through
    the dash and enumerating the songs w/in those soundtracks.

--*/

#include "basedll.h"
#include <xboxp.h>

const OBJECT_STRING XapiStDbFile = CONSTANT_OBJECT_STRING(OTEXT("\\Device\\Harddisk0\\partition1\\TDATA\\FFFE0000\\MUSIC\\ST.DB"));
#define STDB_MUSICDIR "\\Device\\Harddisk0\\partition1\\TDATA\\FFFE0000\\MUSIC\\"


//
// Lookaside variables for fast access to data when querying for songs.
//
STDB_LIST XapiListLookaside = {0,INVALID_STID};
STDB_STDESC XapiStLookaside = {0,INVALID_STID};

BOOL
XapiReadFromStDb (
    HANDLE Handle,
    PBYTE Buffer,
    DWORD Signature
    )

/*++

Routine Description:

    Simple helper routing for reading data from the database.

Arguments:

    Handle - Contains a valid file handle of the open soundtrack database.
    Buffer - Used as a buffer for the read.
    Signature - If non-zero, assumes that the first DWORD in the buffer is a signature
                and checks it against this value.

Return Value:

    TRUE if the data was successfully read and the (optional) signature matches. FALSE otherwise.

Notes:



--*/

{

    DWORD byteCount;
    return ReadFile (Handle, Buffer, STDB_PAGE_SIZE, &byteCount, NULL)
        && byteCount == STDB_PAGE_SIZE
        && (!Signature || (*(PDWORD) Buffer) == Signature);
}


NTSTATUS
XapiOpenStDbAndReadHeader (
    HANDLE * Handle,
    PBYTE Buffer
    )

/*++

Routine Description:

    Opens the soundtrack database and validates the header.

Arguments:

    Handle - Receives a valid file handle on success.
    Buffer - Used as a buffer for reading. Receives the header structure of
             the soundtrack database on success.

Return Value:

    STATUS_SUCCESS or error code.

Notes:



--*/

{

    NTSTATUS status;
    OBJECT_ATTRIBUTES obja;
    IO_STATUS_BLOCK iosb;



    InitializeObjectAttributes (&obja, (POBJECT_STRING) &XapiStDbFile, OBJ_CASE_INSENSITIVE, NULL, NULL);

    //
    // Attempt to open the soundtrack database.
    //

    status = NtCreateFile (
                Handle,
                SYNCHRONIZE | GENERIC_READ,
                &obja,
                &iosb,
                NULL,
                FILE_ATTRIBUTE_SYSTEM | FILE_NO_INTERMEDIATE_BUFFERING,
                FILE_SHARE_READ,
                FILE_OPEN,
                FILE_SYNCHRONOUS_IO_NONALERT
                );

    if (NT_SUCCESS(status) && !XapiReadFromStDb (*Handle, Buffer, 0)) {

            status = STATUS_UNSUCCESSFUL;
            NtClose (*Handle);
    }

    return status;

}



BOOL
XapiGetNextSoundtrack (
    PBYTE Buffer,
    PSNDTRK_ENUMSTATE State,
    PXSOUNDTRACK_DATA Data
    )

/*++

Routine Description:

    Worker function for retrieving the next soundtrack from the database.

Arguments:

    Buffer - Buffer for reading from the soundtrack database.
    State - State variable used for internal tracking of enumeration data.
    Data - receives soundtrack data for the next soundtrack.

Return Value:

    TRUE if there are additional soundtracks to enumerate, FALSE otherwise.

Notes:



--*/


{
    BOOL ok = FALSE;

    //
    // Note that Buffer is passed down to XapiGetNextSoundtrack for use as a temporary buffer.
    // XFindFirstSoundtrack and XFindNextSoundtrack must not assume anything about the contents
    // of this buffer following the call. Therefore, if they use the buffer (like XFindFirstSoundtrack
    // does) they are responsible for ensuring that the data in that buffer is not needed after the
    // XapiGetNextSoundtrack call. This was done to reduce the size of the stack allocations when using
    // the enum APIs.
    //


    if (State->Index < State->MaxIndex) {

        SetFilePointer (State->DbHandle, STDB_PAGE_SIZE * (State->Index + 1), NULL, FILE_BEGIN);
        State->Index++;

        ok = XapiReadFromStDb (State->DbHandle, Buffer, STDB_STSIG);
    }

    if (ok) {

        memcpy (&XapiStLookaside, Buffer, sizeof(STDB_STDESC));
        wcsncpy (Data->szName, XapiStLookaside.Name, MAX_SOUNDTRACK_NAME);
        Data->uSoundtrackId = XapiStLookaside.Id;
        Data->uSongCount = XapiStLookaside.SongCount;
        Data->uSoundtrackLength = XapiStLookaside.SoundtrackLength;

    }

    return ok;
}

XBOXAPI
BOOL
WINAPI
XFindNextSoundtrack (
    IN HANDLE FindHandle,
    OUT PXSOUNDTRACK_DATA SoundtrackData
    )

/*++

Routine Description:

    Continues an enumeration of soundtracks begun with XFindFirstSoundtrack.

Arguments:

    Handle - Contains a valid file handle returned from XFindFirstSoundtrack.
    SoundtrackData - Valid pointer to a soundtrack data structure. On
                     success, receives the data of the next soundtrack in the list.

Return Value:

    TRUE if there are additional soundtracks to enumerate, FALSE otherwise.

Notes:



--*/

{
    BYTE buf[STDB_PAGE_SIZE];

    RIP_ON_NOT_TRUE("XFindNextSoundtrack()", (NULL != FindHandle));
    RIP_ON_NOT_TRUE("XFindNextSoundtrack()", (INVALID_HANDLE_VALUE != FindHandle));
    RIP_ON_NOT_TRUE("XFindNextSoundtrack()", (NULL != SoundtrackData));

#if DBG
    if (FH_SIG_SOUNDTRACK != ((PSNDTRK_ENUMSTATE) FindHandle)->Signature)
    {
        RIP("XFindNextSoundtrack() - invalid parameter (FindHandle)");
    }
#endif // DBG

    return XapiGetNextSoundtrack (buf, (PSNDTRK_ENUMSTATE) FindHandle, SoundtrackData);

}

XBOXAPI
HANDLE
WINAPI
XFindFirstSoundtrack (
    OUT PXSOUNDTRACK_DATA SoundtrackData
    )

/*++

Routine Description:

    Begins an enumeration of the soundtracks on the media and returns the
    first soundtrack.

Arguments:

    SoundtrackData - Valid pointer to a soundtrack data structure. On
                     success, receives the data of the first soundtrack.

Return Value:

    valid HANDLE which may be used in future calls to XFindNextSoundtrack on success,
    otherwise, INVALID_HANDLE_VALUE.

Notes:



--*/

{


    HANDLE h;
    PSNDTRK_ENUMSTATE state = NULL;
    NTSTATUS status;
    BYTE buf[STDB_PAGE_SIZE];
    PSTDB_HDR hdr;



    RIP_ON_NOT_TRUE("XFindFirstSoundtrack()", (NULL != SoundtrackData));


    status = XapiOpenStDbAndReadHeader (&h, buf);

    //
    // Build the enum state data that will be passed back to the caller.
    //
    if (NT_SUCCESS (status)) {

        hdr = (PSTDB_HDR) buf;
        state = LocalAlloc (LMEM_FIXED, sizeof (SNDTRK_ENUMSTATE));

        if (!state) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            SetLastError (RtlNtStatusToDosError (status));
            NtClose (h);
        }
        else {

            state->Signature = FH_SIG_SOUNDTRACK;
            state->MaxIndex = hdr->StCount;
            state->Index = 0;
            state->DbHandle = h;
        }
    }
    else {

        SetLastError (RtlNtStatusToDosError (status));

    }

    //
    // Now, attempt to retrieve the first soundtrack from the database.
    //
    if (NT_SUCCESS (status)) {

            if (!XapiGetNextSoundtrack (buf, state, SoundtrackData)) {

                NtClose (h);
                LocalFree (state);
                state = NULL;

            }
    }


    return state ? (HANDLE) state : INVALID_HANDLE_VALUE;
}

XBOXAPI
BOOL
WINAPI
XGetSoundtrackSongInfo (
    IN DWORD SoundtrackId,
    IN UINT Index,
    OUT PDWORD SongId,
    OUT PDWORD SongLength,
    OUT OPTIONAL PWSTR NameBuffer,
    IN UINT BufferSize
    )

/*++

Routine Description:

    Retrieves information about a particular song index in a soundtrack.

Arguments:

    SoundtrackId - Contains the soundtrack identifier of interest.
    Index - Contains the index of the song within the soundtrack of interest.
    SongId - Receives the unique identifier of the song at the given index within the soundtrack.
    NameBuffer - Optionally receives the UNICODE name of the song.
    BufferSize - If NameBuffer is non null, specifies the size of NameBuffer in UNICODE characters.

Return Value:

    TRUE if the data was successfully returned, FALSE otherwise.

Notes:

    This API allows a title to randomly access songs from within a given soundtrack (for doing things
    such as shuffle, random play, etc.) However, linearly incrementing index is the most efficient
    way to enumerate songs because individual songs are batched in groups of 7 within the database. As long
    as the index is within the same group of seven as the last call to this function, no additional read
    is necessary.

--*/

{
    BOOL ok = TRUE;
    HANDLE h = INVALID_HANDLE_VALUE;
    PSTDB_HDR hdr;
    BYTE buf[STDB_PAGE_SIZE];
    UINT i;
    UINT val;
    NTSTATUS status;

    RIP_ON_NOT_TRUE("XGetSongInfo()", (INVALID_STID != SoundtrackId));
    RIP_ON_NOT_TRUE("XGetSongInfo()", (NULL != SongId));

#if DBG

    if (NameBuffer && BufferSize < MAX_SONG_NAME) {

        RIP ("XGetSongInfo() - 'NameBuffer' Buffer too small.");
    }

#endif

    //
    // Make sure the correct soundtrack is in the lookaside list.
    //
    if (XapiStLookaside.Id != SoundtrackId) {

        status = XapiOpenStDbAndReadHeader (&h, buf);
        ok = NT_SUCCESS(status);
        if (ok) {

            //
            // The header contains an array of all the possible soundtrack blocks
            // and the soundtrack ids in each of those blocks. Read through
            // the array to find the block to seek to.
            //

            hdr = (PSTDB_HDR) buf;
            val = min (hdr->StCount, MAX_SOUNDTRACKS);


            for (i = 0; i < val; i++) {
                if (hdr->StBlocks[i] == SoundtrackId) {
                    break;
                }
            }

            if (i == val)  {
                ok = FALSE;
                SetLastError (ERROR_INVALID_PARAMETER);
            }
        }
        else {

            SetLastError (RtlNtStatusToDosError (status));
        }


        if (ok) {
            ok = (SetFilePointer (h, i * STDB_PAGE_SIZE, NULL, FILE_CURRENT) != INVALID_SET_FILE_POINTER);
            if (!ok) {
                SetLastError (ERROR_INVALID_DATA);
            }

        }

        if (ok) {
            ok = XapiReadFromStDb (h, buf, STDB_STSIG);
        }

        if (ok) {
            memcpy (&XapiStLookaside, buf, sizeof (STDB_STDESC));
            ok = XapiStLookaside.Id == SoundtrackId && XapiStLookaside.SongCount > Index;
            if (!ok) {
                SetLastError (ERROR_INVALID_PARAMETER);
            }
        }
    }


    //
    // Make sure the correct list segment is in the lookaside list.
    //
    if (ok) {

        if (XapiListLookaside.StId != SoundtrackId ||
            Index < (XapiListLookaside.ListIndex * WMADESC_LIST_SIZE) ||
            Index >= (XapiListLookaside.ListIndex + 1) * WMADESC_LIST_SIZE
            ) {


            if (h == INVALID_HANDLE_VALUE) {
                status = XapiOpenStDbAndReadHeader (&h, buf);
                ok = NT_SUCCESS(status);
                if (!ok) {
                    SetLastError (RtlNtStatusToDosError (status));
                }
            }

            if (ok) {
                val = (XapiStLookaside.ListBlocks[Index / WMADESC_LIST_SIZE] + 1 + MAX_SOUNDTRACKS) * STDB_PAGE_SIZE;
                ok = (SetFilePointer (h, val, NULL, FILE_BEGIN) != INVALID_SET_FILE_POINTER);
                if (!ok) {
                    SetLastError (ERROR_INVALID_DATA);
                }
            }


            if (ok) {
                ok = XapiReadFromStDb (h, buf, STDB_LISTSIG);
            }

            if (ok) {
                memcpy (&XapiListLookaside, buf, sizeof (STDB_LIST));
                ok = XapiListLookaside.StId == SoundtrackId;
                if (!ok) {
                    SetLastError (ERROR_INVALID_DATA);
                }
            }
        }
    }

    //
    // Get the song info for the selected song.
    //
    if (Index > XapiStLookaside.SongCount) {

        ok = FALSE;
        SetLastError (ERROR_INVALID_PARAMETER);
    }

    if (ok) {



        *SongId = XapiListLookaside.SongIds[Index % WMADESC_LIST_SIZE];
        *SongLength = XapiListLookaside.SongLengths[Index % WMADESC_LIST_SIZE];
        if (NameBuffer) {
            wcsncpy (NameBuffer, XapiListLookaside.SongNames[Index % WMADESC_LIST_SIZE], MAX_SONG_NAME);
        }

    }

    if (h != INVALID_HANDLE_VALUE) {
        CloseHandle (h);
    }

    return ok;
}
/*++

Copyright (c) Microsoft Corporation

Module Name:

    xsndtrk.c

Abstract:

    This module contains the Xbox Soundtrack APIs

Author:

    Marc R. Whitten (marcw)  13-Feb-2001

Revision History:

--*/


XBOXAPI
HANDLE
WINAPI
XOpenSoundtrackSong (
    IN DWORD SongId,
    IN BOOL Asynchronous
    )

/*++

Routine Description:

    Opens the WMA song matching the song ID in the Dash Music directory.

Arguments:

    SongId - Contains the songid to open.
    Asynchronous - TRUE if the flag should be opened for asynchronous reads, FALSE if
                   it should be opened for synchronous reading.

Return Value:

    A valid file handle to the WMA song represented by the songid if successful, or
    INVALID_HANDLE_VALUE otherwise.

Notes:



--*/
{
    CHAR path[MAX_PATH];
    HANDLE h;
    NTSTATUS status;
    OBJECT_ATTRIBUTES obja;
    IO_STATUS_BLOCK iosb;
    OBJECT_STRING oPath;



    sprintf (path, "%s%04x\\%08x.WMA", STDB_MUSICDIR, HIWORD(SongId), SongId);


    RtlInitObjectString(&oPath, path);
    InitializeObjectAttributes (&obja, &oPath, OBJ_CASE_INSENSITIVE, NULL, NULL);


    //
    // Attempt to open the soundtrack.
    //
    status = NtCreateFile (
            &h,
            SYNCHRONIZE | GENERIC_READ | FILE_READ_ATTRIBUTES,
            &obja,
            &iosb,
            NULL,
            0,
            FILE_SHARE_READ,
            FILE_OPEN,
            FILE_NON_DIRECTORY_FILE | (Asynchronous ? FILE_NO_INTERMEDIATE_BUFFERING : FILE_SYNCHRONOUS_IO_NONALERT)
            );



    if (!NT_SUCCESS(status)) {
        XapiSetLastNTError (status);
    }

    return NT_SUCCESS (status) ? h : INVALID_HANDLE_VALUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\lib\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\dbgmon\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\i386\intrlock.asm ===
title   "Interlocked API Support"
;++
;
;  Copyright (c) 1991  Microsoft Corporation
;
;  Module Name:
;
;     intrlock.asm
;
;  Abstract:
;
;     This module implements functions to support user mode interlocked operations.
;
;  Author:
;
;     Bryan M. Willman (bryanwi) 2-Oct-91
;
;  Environment:
;
;     Any mode.
;
;  Revision History:
;
;--

.486p
        .xlist
include ks386.inc
include callconv.inc
        .list

_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

Addend      equ     [esp + 4]

        page , 132
        subttl  "InterlockedIncrement"
;++
;
; LONG
; InterlockedIncrement(
;    IN PLONG Addend
;    )
;
; Routine Description:
;
;    This function performs an interlocked add of one to the addend variable.
;
;    No checking is done for overflow.
;
; Arguments:
;
;    Addend - Supplies a pointer to a variable whose value is to be
;       incremented by one.
;
; Return Value:
;
;   (eax) - the incremented value.
;
;--

cPublicProc __InterlockedIncrement,1
cPublicFpo 1,0
        mov     ecx,Addend              ; get pointer to addend variable
        mov     eax,1                   ; set increment value

        xadd    [ecx],eax               ; interlocked increment
        inc     eax                     ; adjust return value
        stdRET __InterlockedIncrement    ;

stdENDP __InterlockedIncrement

        page , 132
        subttl  "InterlockedDecrment"
;++
;
; LONG
; InterlockedDecrement(
;    IN PLONG Addend
;    )
;
; Routine Description:
;
;    This function performs an interlocked add of -1 to the addend variable.
;
;    No checking is done for overflow
;
; Arguments:
;
;    Addend - Supplies a pointer to a variable whose value is to be
;       decremented by one.
;
; Return Value:
;
;   (eax) - The decremented value.
;
;--

cPublicProc __InterlockedDecrement,1
cPublicFpo 1,0

        mov     ecx,Addend              ; get pointer to addend variable
        mov     eax,-1                  ; set decrement value

        xadd    [ecx],eax               ; interlocked decrement
        dec     eax                     ; adjust return value
        stdRET __InterlockedDecrement    ;

stdENDP __InterlockedDecrement

        page , 132
        subttl  "Interlocked Exchange"
;++
;
; LONG
; InterlockedExchange(
;    IN OUT LPLONG Target,
;    IN LONG Value
;    )
;
; Routine Description:
;
;    This function atomically exchanges the Target and Value, returning
;    the prior contents of Target
;
; Arguments:
;
;    Target - Address of LONG to exchange
;    Value  - New value of LONG
;
; Return Value:
;
;    (eax) - The prior value of target.
;--

cPublicProc __InterlockedExchange, 2
cPublicFpo 2,0

        mov     ecx, [esp+4]                ; (ecx) = Target
        mov     edx, [esp+8]                ; (edx) = Value
        mov     eax, [ecx]                  ; get comperand value
Ixchg:
        cmpxchg [ecx], edx                  ; compare and swap
        jnz     Ixchg                       ; if nz, exchange failed
        stdRET  __InterlockedExchange

stdENDP __InterlockedExchange

        page , 132
        subttl  "Interlocked Compare Exchange"
;++
;
;   PVOID
;   InterlockedCompareExchange (
;       IN OUT PVOID *Destination,
;       IN PVOID Exchange,
;       IN PVOID Comperand
;       )
;
;   Routine Description:
;
;    This function performs an interlocked compare of the destination
;    value with the comperand value. If the destination value is equal
;    to the comperand value, then the exchange value is stored in the
;    destination. Otherwise, no operation is performed.
;
; Arguments:
;
;    Destination - Supplies a pointer to destination value.
;
;    Exchange - Supplies the exchange value.
;
;    Comperand - Supplies the comperand value.
;
; Return Value:
;
;    (eax) - The initial destination value.
;
;--

cPublicProc __InterlockedCompareExchange, 3
cPublicFpo 3,0

        mov     ecx, [esp + 4]          ; get destination address
        mov     edx, [esp + 8]          ; get exchange value
        mov     eax, [esp + 12]         ; get comperand value

        cmpxchg [ecx], edx              ; compare and exchange
        stdRET  __InterlockedCompareExchange

stdENDP __InterlockedCompareExchange

        page , 132
        subttl  "Interlocked Exchange Add"
;++
;
;   LONG
;   InterlockedExchangeAdd (
;       IN OUT PLONG Addend,
;       IN LONG Increment
;       )
;
;   Routine Description:
;
;    This function performs an interlocked add of an increment value to an
;    addend variable of type unsinged long. The initial value of the addend
;    variable is returned as the function value.
;
;       It is NOT possible to mix ExInterlockedDecrementLong and
;       ExInterlockedIncrementong with ExInterlockedAddUlong.
;
;
; Arguments:
;
;    Addend - Supplies a pointer to a variable whose value is to be
;       adjusted by the increment value.
;
;    Increment - Supplies the increment value to be added to the
;       addend variable.
;
; Return Value:
;
;    (eax) - The initial value of the addend.
;
;--

cPublicProc __InterlockedExchangeAdd, 2
cPublicFpo 2,0

        mov     ecx, [esp + 4]          ; get addend address
        mov     eax, [esp + 8]          ; get increment value

        xadd    [ecx], eax              ; exchange add
        stdRET  __InterlockedExchangeAdd

stdENDP __InterlockedExchangeAdd

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xapi\k32\i386\muldiv.asm ===
title   "Multiply and Divide"
;++
;
;  Copyright (c) 1991  Microsoft Corporation
;
;  Module Name:
;
;     muldiv.asm (taken from base\client\i386\critsect.asm)
;
;  Abstract:
;
;     Optimized multiply and divide routines
;
;  Author:
;
;     Bryan M. Willman (bryanwi) 2-Oct-91
;
;  Environment:
;
;     Any mode.
;
;
;--

.486p
        .xlist
include ks386.inc
include callconv.inc
        .list

_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page , 132
        subttl  "Multiply and Divide"
;++
;
; LONG
; MulDiv(
;    IN LONG nNumber,
;    IN LONG nNumerator,
;    IN LONG nDenominator
;    )
;
; Routine Description:
;
;    This function multiples two 32-bit numbers forming a 64-bit product.
;    The 64-bit product is rounded and then divided by a 32-bit divisor
;    yielding a 32-bit result.
;
; Arguments:
;
;    nNumber - Supllies the multiplier.
;
;    nNumerator - Supplies the multiplicand.
;
;    nDenominator - Supplies the divisor.
;
; Return Value:
;
;    If the divisor is zero or an overflow occurs, then a value of -1 is
;    returned as the function value. Otherwise, the rounded quotient is
;    returned as the funtion value.
;
;--

nNumber      equ [esp + 4]
nNumerator   equ [esp + 8]
nDenominator equ DWORD PTR [esp + 12]

cPublicProc _MulDiv, 3
cPublicFpo 3,0
        mov     eax, nNumber            ; get multiplier absolute value
        or      eax, eax                ;
        js      short MD32_First        ; if s, multiplier is negative

;
; The multiplier is positive.
;

        mov     edx, nNumerator         ; get multiplicand absolute value
        or      edx, edx                ;
        js      MD32_Second             ; if s, multiplicand is negative

;
; The multiplicand is positive.
;

        mul     edx                     ; compute 64-bit product
        mov     ecx, nDenominator       ; get denominator absolute value
        or      ecx, ecx                ;
        js      MD32_Third              ; if s, divisor is negative

;
; The divisor is positive.
;

        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        cmp     edx, nDenominator       ; check for overflow
        jae     short MD32_error        ; if ae, overflow or divide by 0
        div     nDenominator            ; compute quotient

;
; The result is postive.
;

        or      eax, eax                ; check for overflow
        js      short MD32_error        ; if s, overlfow has occured

        stdRET  _MulDiv

MD32_error:
        xor     eax, eax                ; set return value to - 1
        dec     eax                     ;

        stdRET  _MulDiv

;
; The multiplier is negative.
;

MD32_First:                             ;
        neg     eax                     ; negate multiplier
        mov     edx, nNumerator         ; get multiplicand absolute value
        or      edx, edx                ;
        js      short MD32_First10      ; if s, multiplicand is negative

;
; The multiplicand is positive.
;

        mul     edx                     ; compute 64-bit product
        mov     ecx, nDenominator       ; get denominator absolute value
        or      ecx, ecx                ;
        js      short MD32_First20      ; if s, divisor is negative

;
; The divisor is positive.
;

        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        cmp     edx, nDenominator       ; check for overflow
        jae     short MD32_error10      ; if ae, overflow or divide by 0
        div     nDenominator            ; compute quotient

;
; The result is negative.
;

        neg     eax                     ; negate result
        jg      short MD32_error10      ; if g, overlfow has occured

        stdRET  _MulDiv

;
; The multiplier is negative and the multiplicand is negative.
;

MD32_First10:                           ;
        neg     edx                     ; negate multiplicand
        mul     edx                     ; compute 64-bit product
        mov     ecx, nDenominator       ; get denominator absolute value
        or      ecx, ecx                ;
        js      short MD32_First30      ; if s, divisor is negative

;
; The divisor is positive.
;

        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        cmp     edx, nDenominator       ; check for overflow
        jae     short MD32_error10      ; if ae, overflow or divide by 0
        div     nDenominator            ; compute quotient

;
; The result is positive.
;

        or      eax, eax                ; check for overflow
        js      short MD32_error10      ; if s, overlfow has occured

        stdRET  _MulDiv

MD32_error10:                           ;
        xor     eax, eax                ; set return value to - 1
        dec     eax                     ;

        stdRET  _MulDiv


;
; The multiplier is negative, the multiplicand is positive, and the
; divisor is negative.
;

MD32_First20:                           ;
        neg     ecx                     ; negate divisor
        push    ecx                     ; save absolute value of divisor
        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        pop     ecx                     ; restore divisor
        cmp     edx, ecx                ; check for overflow
        jae     short MD32_error10      ; if ae, overflow or divide by 0
        div     ecx                     ; compute quotient

;
; The result is postive.
;

        or      eax, eax                ; check for overflow
        js      short MD32_error10      ; if s, overlfow has occured

        stdRET  _MulDiv

;
; The multiplier is negative, the multiplier is negative, and the divisor
; is negative.
;

MD32_First30:                           ;
        neg     ecx                     ; negate divisor
        push    ecx                     ; save absolute value of divisor
        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        pop     ecx                     ; restore divisor
        cmp     edx, ecx                ; check for overflow
        jae     short MD32_error10      ; if ae, overflow or divide by 0
        div     ecx                     ; compute quotient

;
; The result is negative.
;

        neg     eax                     ; negate result
        jg      short MD32_error10      ; if g, overlfow has occured

        stdRET  _MulDiv

;
; The multiplier is positive and the multiplicand is negative.
;

MD32_Second:                            ;
        neg     edx                     ; negate multiplicand
        mul     edx                     ; compute 64-bit product
        mov     ecx, nDenominator       ; get denominator absolute value
        or      ecx, ecx                ;
        js      short MD32_Second10     ; if s, divisor is negative

;
; The divisor is positive.
;

        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        cmp     edx, nDenominator       ; check for overflow
        jae     short MD32_error20      ; if ae, overflow or divide by 0
        div     nDenominator            ; compute quotient

;
; The result is negative.
;

        neg     eax                     ; check for overflow
        jg      short MD32_error20      ; if g, overlfow has occured

        stdRET  _MulDiv

MD32_error20:                           ;
        xor     eax, eax                ; set return value to - 1
        dec     eax                     ;

        stdRET  _MulDiv

;
; The multiplier is positive, the multiplicand is negative, and the divisor
; is negative.
;

MD32_Second10:                          ;
        neg     ecx                     ; negate divisor
        push    ecx                     ; save absolute value of divisor
        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        pop     ecx                     ; restore divisor
        cmp     edx, ecx                ; check for overflow
        jae     short MD32_error20      ; if ae, overflow or divide by 0
        div     ecx                     ; compute quotient

;
; The result is positive.
;

        or      eax, eax                ; check for overflow
        js      short MD32_error10      ; if s, overlfow has occured

        stdRET  _MulDiv

;
; The multiplier is positive, the multiplicand is positive, the divisor
; is negative.
;

MD32_Third:                             ;
        neg     ecx                     ; negate divisor
        push    ecx                     ; save absolute value of divisor
        sar     ecx, 1                  ; compute rounding value
        add     eax, ecx                ; round the 64-bit produce by the
        adc     edx, 0                  ; divisor / 2
        pop     ecx                     ; restore divisor
        cmp     edx, ecx                ; check for overflow
        jae     short MD32_error20      ; if ae, overflow or divide by 0
        div     ecx                     ; compute quotient

;
; The result is negative.
;

        neg     eax                     ; negate result
        jg      short MD32_error20      ; if g, overflow has occured

        stdRET  _MulDiv

stdENDP _MulDiv

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\sources.inc ===
INCLUDES=\
    $(BASEDIR)\private\ntos\xnet\inc; \
    $(BASEDIR)\private\ntos\inc

C_DEFINES=\
    $(C_DEFINES) \
    -D_UNICODE \
    -DUNICODE \
    -DNT

MSC_WARNING_LEVEL=/W3 /WX

PRECOMPILED_INCLUDE=precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=$(TARGETNAME)pre.obj

!if defined(XNET_DEBUG_COMPILE_LEVEL)
C_DEFINES=$(C_DEFINES) -DXNET_DEBUG_COMPILE_LEVEL=$(XNET_DEBUG_COMPILE_LEVEL)
!endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\dhcp\precomp.h ===
#include "xnetp.h"
#include "xboxp.h"
#include "route.h"
#include "dhcp.h"
#include "dhcplib.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\dhcp\dhcp.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dhcp.h

Abstract:

    DHCP and Autonet protocol related declarations

Revision History:

    04/21/2000 davidx
        Created it.

Notes:

    Please refer to RFC2131, RFC2132, and RFC951. Also, the internet draft
    http://search.ietf.org/internet-drafts/draft-ietf-dhc-ipv4-autoconfig-05.txt.

--*/

#ifndef _DHCP_H
#define _DHCP_H

//
// UDP port numbers used by DHCP
//
#define DHCP_SERVER_PORT HTONS(67)
#define DHCP_CLIENT_PORT HTONS(68)

//
// DHCP message format
// NOTE: default the options field to 64 bytes
// which is the size of BOOTP vendor-specified area
//

typedef struct _DhcpMessage {
    BYTE op;                // message type
    BYTE htype;             // hareware address type
    BYTE hlen;              // hardware address length
    BYTE hops;              // relay hops
    DWORD xid;              // transaction ID
    WORD secs;              // seconds since address acquisition process began
    WORD flags;             // flags
    IPADDR ciaddr;          // client IP address
    IPADDR yiaddr;          // "your" (client) IP address
    IPADDR siaddr;          // server IP address
    IPADDR giaddr;          // relay agent IP address
    BYTE chaddr[16];        // client hardware address
    BYTE sname[64];         // optional server hostname
    BYTE file[128];         // boot filename
    BYTE options[64];       // optional parameters (variable length)
} DhcpMessage;

//
// Our default DHCP packet buffer is 576 bytes
//
#define BOOTP_MESSAGE_SIZE sizeof(DhcpMessage)
#define DEFAULT_DHCP_BUFSIZE 576
#define DHCPHDRLEN offsetof(DhcpMessage, options)

//
// Minimum and maximum DHCP hardware address length
//
#define MIN_DHCP_HWADDRLEN 1
#define MAX_DHCP_HWADDRLEN 16

//
// BOOTP message type constants
//
#define BOOTREQUEST 1
#define BOOTREPLY   2

//
// Hardware type constants
//
#define HWTYPE_10MB_ETHERNET 1
#define HWTYPE_PPP           8

//
// Constants for DHCP_MESSAGE.flags
//
#define DHCP_BROADCAST 0x8000

//
// DHCP message type constants
//
#define DHCPDISCOVER    1
#define DHCPOFFER       2
#define DHCPREQUEST     3
#define DHCPDECLINE     4
#define DHCPACK         5
#define DHCPNAK         6
#define DHCPRELEASE     7
#define DHCPINFORM      8

//
// DHCP option tag constants
//

// Fixed-length options

#define DHCPOPT_PAD                     0
#define DHCPOPT_END                     255

// Standard options

#define DHCPOPT_SUBNET_MASK             1
#define DHCPOPT_TIME_OFFSET             2
#define DHCPOPT_ROUTERS                 3
#define DHCPOPT_TIME_SERVERS            4
#define DHCPOPT_IEN116_SERVERS          5
#define DHCPOPT_DNS_SERVERS             6
#define DHCPOPT_LOG_SERVERS             7
#define DHCPOPT_COOKIE_SERVERS          8
#define DHCPOPT_LPR_SERVERS             9
#define DHCPOPT_IMPRESS_SERVERS         10
#define DHCPOPT_RLP_SERVERS             11
#define DHCPOPT_HOST_NAME               12
#define DHCPOPT_BOOT_FILESIZE           13
#define DHCPOPT_DUMP_FILE               14
#define DHCPOPT_DOMAIN_NAME             15
#define DHCPOPT_SWAP_SERVER             16
#define DHCPOPT_ROOT_PATH               17
#define DHCPOPT_EXTENSIONS_PATH         18

// IP parameters (per host)

#define DHCPOPT_ENABLE_FORWARD          19
#define DHCPOPT_NONLOCAL_SRCROUTING     20
#define DHCPOPT_POLICY_FILTER           21
#define DHCPOPT_MAX_REASSEMBLY_SIZE     22
#define DHCPOPT_DEFAULT_IP_TTL          23
#define DHCPOPT_PMTU_AGING_TIMEOUT      24
#define DHCPOPT_PMTU_PLATEAU_TABLE      25

// IP parameters (per interface)

#define DHCPOPT_INTERFACE_MTU           26
#define DHCPOPT_ALL_SUBNETS_LOCAL       27
#define DHCPOPT_BROADCAST_ADDRESS       28
#define DHCPOPT_MASK_DISCOVERY          29
#define DHCPOPT_MASK_SUPPLIER           30
#define DHCPOPT_ROUTER_DISCOVERY        31
#define DHCPOPT_SOLICIT_ROUTER_ADDR     32
#define DHCPOPT_STATIC_ROUTES           33

// Link layer parameters

#define DHCPOPT_TRAILER_ENCAPS          34
#define DHCPOPT_ARP_CACHE_TIMEOUT       35
#define DHCPOPT_ETHERNET_ENCAPS         36

// TCP parameters

#define DHCPOPT_DEFAULT_TCP_TTL         37
#define DHCPOPT_KEEPALIVE_INTERVAL      38
#define DHCPOPT_KEEPALIVE_GARBAGE       39

// Application parameters

#define DHCPOPT_NIS_DOMAIN              40
#define DHCPOPT_NIS_SERVERS             41
#define DHCPOPT_NTP_SERVERS             42

// DHCP extensions

#define DHCPOPT_REQUESTED_IPADDR        50
#define DHCPOPT_IPADDR_LEASE_TIME       51
#define DHCPOPT_FIELD_OVERLOAD          52
#define DHCPOPT_TFTP_SERVER_NAME        66
#define DHCPOPT_BOOT_FILENAME           67
#define DHCPOPT_DHCP_MESSAGE_TYPE       53
#define DHCPOPT_SERVERID                54
#define DHCPOPT_PARAM_REQUEST_LIST      55
#define DHCPOPT_MESSAGE                 56
#define DHCPOPT_MAX_DHCP_MESSAGESIZE    57
#define DHCPOPT_T1_INTERVAL             58
#define DHCPOPT_T2_INTERVAL             59
#define DHCPOPT_VENDOR_CLASSID          60
#define DHCPOPT_CLIENTID                61

// Vendor-specific information

#define DHCPOPT_VENDOR_INFO             43
#define DHCPOPT_NETBIOS_NAMESERVERS     44
#define DHCPOPT_NETBIOS_DATASERVERS     45
#define DHCPOPT_NETBIOS_NODETYPE        46
#define DHCPOPT_NETBIOS_SCOPE           47
#define DHCPOPT_X11_FONTSERVERS         48
#define DHCPOPT_X11_DISPLAYSERVERS      49
#define DHCPOPT_NIS2_DOMAIN             64
#define DHCPOPT_NIS2_SERVERS            65
#define DHCPOPT_MOBILEIP_HOME_AGENTS    68
#define DHCPOPT_SMTP_SERVERS            69
#define DHCPOPT_POP3_SERVERS            70
#define DHCPOPT_NNTP_SERVERS            71
#define DHCPOPT_WWW_SERVERS             72
#define DHCPOPT_FINGER_SERVERS          73
#define DHCPOPT_IRC_SERVERS             74
#define DHCPOPT_STREETTALK_SERVERS      75
#define DHCPOPT_STREETTALKDA_SERVERS    76

//
// DHCP magic cookie: 99, 130, 83, 99
//
#define DHCPCOOKIELEN 4
extern const BYTE DhcpMagicCookie[DHCPCOOKIELEN];

//
// DHCP time value (in seconds)
//
// NOTE: We use 32-bit unsigned interface to represent
// the number of seconds ellapsed since the start of 1/1/2000.
// This should last until year 2136 before overflowing.
//
typedef DWORD DHCPTIME;

#define DHCPTIME_INFINITE 0xffffffff

//
// Autonet address range: 169.254/16
//  don't use the first 256 and the last 256 addresses
//
#define AUTONET_ADDRMASK    0xffff0000
#define AUTONET_ADDRBASE    0xa9fe0100
#define AUTONET_ADDRRANGE   0x0000fcff

#endif // !_DHCP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\dhcp\dhcpdump.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dhcpdump.c

Abstract:

    Dump DHCP message content to the debugger

Revision History:

    05/25/2000 davidx
        Created it.

--*/

#include "precomp.h"

//
// Whether to dump incoming and outgoing DHCP messages
//
#if DBG

INT _dhcpDumpFlag = FALSE;

PRIVATE VOID
DhcpDumpByteArray(
    const BYTE* buf,
    UINT buflen
    )

/*++

Routine Description:

    Dump a byte array in hexdecimal format

Arguments:

    buf - Points to the data buffer
    buflen - Buffer length

Return Value:

    NONE

--*/

{
    for ( ; buflen--; buf++) {
        DbgPrint("%02x", *buf);
    }
}


PRIVATE VOID
DhcpDumpOption(
    IN const BYTE* buf,
    IN UINT buflen,
    OUT BYTE* overload
    )

/*++

Routine Description:

    Dump DHCP options

Arguments:

    buf - Points to the option data buffer
    buflen - Data buffer length
    overload - Returns the option overload flags

Return Value:

    NONE

--*/

{
    static PCSTR dhcpMessageTypeStrs[] = {
        "***",
        "DHCPDISCOVER",
        "DHCPOFFER",
        "DHCPREQUEST",
        "DHCPDECLINE",
        "DHCPACK",
        "DHCPNAK",
        "DHCPRELEASE",
        "DHCPINFORM"
    };

    UINT tag, len, val;

    while (buflen && *buf != DHCPOPT_END) {
        // Special case for DHCPOPT_PAD - single byte
        if (*buf == DHCPOPT_PAD) {
            DbgPrint("    PAD\n");
            buflen--, buf++;
            continue;
        }

        // Check option length
        if (buflen < 2 || buflen-2 < (len = buf[1])) goto badopt;

        switch (tag = buf[0]) {
        case DHCPOPT_DHCP_MESSAGE_TYPE:
            if (len != 1) goto badopt;
            val = buf[2];
            if (val > 0 && val < ARRAYCOUNT(dhcpMessageTypeStrs)) {
                DbgPrint("    %s", dhcpMessageTypeStrs[val]);
            } else {
                DbgPrint("    Unknown DHCP message type: %d", val);
            }
            break;

        case DHCPOPT_FIELD_OVERLOAD:
            if (len != 1) goto badopt;
            DbgPrint("    OVERLOAD: %d", buf[2]);
            if (overload)
                *overload = buf[2];
            else
                DbgPrint(" !!!");
            break;

        case DHCPOPT_REQUESTED_IPADDR:
        case DHCPOPT_SERVERID:
            if (len != 4) goto badopt;
            DbgPrint("    %s %d.%d.%d.%d",
                (tag == DHCPOPT_SERVERID) ? "SERVERID" : "REQUEST IP ADDR",
                buf[2], buf[3], buf[4], buf[5]);
            break;

        default:
            DbgPrint("    %d - ", tag);
            DhcpDumpByteArray(buf+2, len);
            break;
        }

        DbgPrint("\n");
        buf += len+2;
        buflen -= len+2;
    }

    if (buflen == 0) {
        DbgPrint("!!! Missing 'end' option\n");
    } else {
        do {
            buflen--, buf++;
        } while (buflen && *buf == 0);

        if (buflen != 0)
            DbgPrint("!!! Extra data after 'end' option\n");
    }
    return;

badopt:
    DbgPrint("!!! Bad DHCP option data\n");
}


VOID
DhcpDumpMessage(
    const DhcpMessage* msg,
    UINT msglen
    )

/*++

Routine Description:

    Dump the content of a DHCP message

Arguments:

    msg - Points to the DHCP message
    msglen - Message length

Return Value:

    NONE

--*/

{
    const BYTE* option;
    BYTE overload = 0;

    if (!_dhcpDumpFlag) return;

    //
    // Sanity check
    //
    if (msglen < DHCPHDRLEN) {
        DbgPrint("!!! DHCP message too small: %d bytes\n", msglen);
        return;
    }

    //
    // Dump out fixed header information
    //
    DbgPrint("DHCP message: ");
    if (msg->op == BOOTREQUEST)
        DbgPrint("BOOTREQUEST\n");
    else if (msg->op == BOOTREPLY)
        DbgPrint("BOOTREPLY\n");
    else
        DbgPrint("%d\n", msg->op);

    DbgPrint("  htype: %d\n", msg->htype);
    if (msg->hlen > sizeof(msg->chaddr)) {
        DbgPrint("!!! Invalid hardware address length: %d\n", msg->hlen);
    } else if (msg->hlen) {
        DbgPrint("  chaddr: ");
        DhcpDumpByteArray(msg->chaddr, msg->hlen);
        DbgPrint("\n");
    }

    DbgPrint("  hops: %d\n", msg->hops);
    DbgPrint("  xid: 0x%08x\n", NTOHL(msg->xid));
    DbgPrint("  secs: %d\n", NTOHS(msg->secs));
    DbgPrint("  flags: 0x%04x\n", NTOHS(msg->flags));
    DbgPrint("  ciaddr: %s\n", IPADDRSTR(msg->ciaddr));
    DbgPrint("  yiaddr: %s\n", IPADDRSTR(msg->yiaddr));
    DbgPrint("  siaddr: %s\n", IPADDRSTR(msg->siaddr));
    DbgPrint("  giaddr: %s\n", IPADDRSTR(msg->giaddr));

    //
    // Dump options
    //
    option = msg->options;
    msglen -= DHCPHDRLEN;

    if (msglen < DHCPCOOKIELEN ||
        !EqualMem(option, DhcpMagicCookie, DHCPCOOKIELEN)) {
        DbgPrint("!!! Invalid DHCP magic cookie\n");
        return;
    }
    msglen -= DHCPCOOKIELEN;
    option += DHCPCOOKIELEN;

    DbgPrint("  options:\n");
    DhcpDumpOption(option, msglen, &overload);

    if (overload & 1) {
        DbgPrint("  overload options (file):\n");
        DhcpDumpOption(msg->file, sizeof(msg->file), NULL);
    }

    if (overload & 2) {
        DbgPrint("  overload options (sname):\n");
        DhcpDumpOption(msg->sname, sizeof(msg->sname), NULL);
    }
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\dhcp\dhcp.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    protocol.c

Abstract:

    DHCP client protocol handling code
    as well as Autonet implementation

Revision History:

    04/21/2000 davidx
        Created it.

    05/25/2000 davidx
        Ported over to the new net tree.

--*/

#include "precomp.h"


//
// First 4 bytes of the options field in a DHCP message
// must match the following magic cookie
//
const BYTE DhcpMagicCookie[DHCPCOOKIELEN] = { 99, 130, 83, 99 };

//
// Default address lease time requested:
//  let the server decide
//
UINT cfgDefaultLeaseTime = 0;

//
// Minimum retransmission timeout while in
// RENEWING and REBINDING states: 60 seconds
//
UINT cfgMinRenewTimeout = 60;

//
// Number of seconds to wait after reboot
// before we start sending out DHCPDISCOVER packets
//
// NOTE: RFC2131 recommends that we wait between 1 to 10 seconds.
// But we're only doing 1 seconds here for faster startup time.
//
UINT cfgStartupWaitMin = 0;
UINT cfgStartupWaitMax = 1;

//
// Number of times we'll attempt to resend
// DHCPDISCOVER and DHCPREQUEST packets
//
// NOTE: Non-standard behavior!!!
//  We're capping the timeout between retries to a maximum of 10 seconds.
//
UINT cfgDhcpRetryCount = 3;
UINT cfgDhcpRetryMaxTimeout = 10;

//
// Number of autonet addresses we'll attempt before giving up
//
UINT cfgAutonetAddrRetries = 10;

//
// How frequently to look for DHCP server when in Autonet mode
//
UINT cfgAutonetDhcpCheckInterval = 5*60;

//
// How many ARP requests to send
// when checking for address conflict
//
UINT cfgConflictCheckRetries = 2;

//
// Global transaction ID
//
PRIVATE DWORD DhcpGlobalXid = 0;

//
// Forward function declarations
//
PRIVATE VOID DhcpChangeState(DhcpInfo*, INT);
PRIVATE VOID DhcpSetIfTimerRelative(DhcpInfo*, UINT, UINT);
PRIVATE VOID DhcpSetIfTimerAbsolute(DhcpInfo*, DHCPTIME);
PRIVATE VOID DhcpHandleTimeout(DhcpInfo*);
PRIVATE VOID DhcpResetInterface(DhcpInfo*);
PRIVATE VOID DhcpSelectAutonetAddr(DhcpInfo*);

PRIVATE NTSTATUS DhcpSendDiscover(DhcpInfo*);
PRIVATE NTSTATUS DhcpSendRequest(DhcpInfo*);
PRIVATE NTSTATUS DhcpSendInform(DhcpInfo*);
PRIVATE NTSTATUS DhcpSendDecline(DhcpInfo*, IPADDR, IPADDR);
PRIVATE NTSTATUS DhcpSendRelease(DhcpInfo*);

PRIVATE VOID DhcpUseOptionParams(DhcpInfo*, DhcpOptionParam*);
PRIVATE NTSTATUS DhcpParseOptionParams(DhcpOptionParam*, const BYTE*, UINT, BYTE*);
PRIVATE NTSTATUS DhcpProcessOffer(DhcpInfo*, IPADDR, DhcpOptionParam*);
PRIVATE NTSTATUS DhcpProcessAck(DhcpInfo*, IPADDR, DhcpOptionParam*);
PRIVATE NTSTATUS DhcpProcessNak(DhcpInfo*, IPADDR);
PRIVATE VOID DhcpLoadConfigInfo(DhcpInfo*);

// Check to see if we're forced to use autonet address
//  (without trying to find DHCP servers)
INLINE BOOL DhcpForceAutonet(IPADDR addr, IPADDR mask) {
    return (mask == HTONL(AUTONET_ADDRMASK)) && 
           (addr & mask) == (HTONL(AUTONET_ADDRBASE) & mask);
}



NTSTATUS
DhcpInitialize(
    IfInfo* ifp
    )

/*++

Routine Description:

    Initialize the DHCP related data structure for an interface

Arguments:

    ifp - Points to the interface structure

Return Value:

    Status code

--*/

{
    DhcpInfo* dhcp;

    if ((dhcp = ifp->dhcpInfo) != NULL) {
        dhcp->flags |= FLAG_CREATED_BY_DEBUGGER;
        return NETERR_OK;
    }

    dhcp = (DhcpInfo*) SysAlloc0(sizeof(DhcpInfo), PTAG_DHCP);
    if (!dhcp) return NETERR_MEMORY;

    KeInitializeEvent(&dhcp->addrEvent, NotificationEvent, FALSE);
    dhcp->ifp = ifp;
    dhcp->state = STATE_NONE;
    dhcp->flags = FLAG_SEND_DHCPINFORM;
    dhcp->timer = 0xffffffff;

    ifp->dhcpInfo = dhcp;

    // Load persistent DHCP configuration parameters
    DhcpLoadConfigInfo(dhcp);

    if (dhcp->activeaddr != 0 &&
        !DhcpForceAutonet(dhcp->activeaddr, dhcp->activemask)) {

        //
        // If we're using static address, inform the IP stack
        // BUGBUG - also need to set up the default DNS server?
        //
        IfSetIpAddr(ifp, dhcp->activeaddr, dhcp->activemask);
        DhcpSignalAddrEvent(dhcp);
        DhcpSetDefaultGateways(ifp);
        DhcpChangeState(dhcp, STATE_STATIC_ADDR);

    } else if (!(ifp->flags & IFFLAG_CONNECTED_BOOT) ||
               (cfgXnetConfigFlags & XNET_INITFLAG_FORCE_AUTONET) ||
               dhcp->activeaddr != 0) {

        //
        // Skip the DHCP address discovery process and
        // go straight to autonet mode if:
        //  1. The net cable is disconnected at boot time
        //  2. XnetInitialize was called with force-autonet mode
        //  3. User has configed static IP address = 169.254.x.x
        //
        WARNING_("Forcing autonet...");
        dhcp->activeaddr = dhcp->activemask = 0;
        DhcpChangeState(dhcp, STATE_SELECT_AUTOADDR);

    } else {

        //
        // Obtain address via DHCP or Autonet
        // Be quiet for a while after startup
        //
        DhcpSetIfTimerRelative(dhcp, cfgStartupWaitMin, cfgStartupWaitMax);
    }

    return NETERR_OK;
}


VOID
DhcpCleanup(
    IfInfo* ifp
    )

/*++

Routine Description:

    Clean up DHCP related data for an interface

Arguments:

    ifp - Points to the interface structure

Return Value:

    NONE

--*/

{
    DhcpInfo* dhcp = ifp->dhcpInfo;

    RUNS_AT_DISPATCH_LEVEL
    if (!dhcp) return;
    if (dhcp->flags & FLAG_CREATED_BY_DEBUGGER) {
        dhcp->flags &= ~FLAG_CREATED_BY_DEBUGGER;
        return;
    }
    ifp->dhcpInfo = NULL;

    // Release the DHCP address if necessary
    if (ActiveDhcpAddr(dhcp) && (dhcp->flags & FLAG_RELEASE_ON_REBOOT)) {
        DhcpSendRelease(dhcp);
    }

    // Free the memory for the interface structure
    SysFree(dhcp);
}


VOID
DhcpTimerProc(
    IfInfo* ifp
    )

/*++

Routine Description:

    DHCP timer routine for an interface

Arguments:

    ifp - Points to the interface structure

Return Value:

    NONE

--*/

{
    DhcpInfo* dhcp = ifp->dhcpInfo;

    // Do nothing if the timer hasn't expired
    if (dhcp == NULL ||
        dhcp->timer == 0xffffffff ||
        dhcp->timer-- > 1)
        return;

    DhcpHandleTimeout(dhcp);
}


VOID
DhcpReceivePacket(
    IfInfo* ifp,
    Packet* pkt
    )

/*++

Routine Description:

    Handle a UDP packet received on an interface
    that's destined for the DHCP client port

Arguments:

    ifp - Points to the interface structure
    pkt - Points to the received packet

Return Value:

    NONE

Note:

    The caller retains ownership of the received packet.
    So we don't call CompletePacket on it here.

--*/

{
    DhcpInfo* dhcp = ifp->dhcpInfo;
    DhcpMessage* msg;
    UINT msglen;
    DhcpOptionParam* dhcpParams = NULL;
    BYTE* option;
    BYTE overload = 0;
    NTSTATUS status = NETERR_DISCARDED;

    RUNS_AT_DISPATCH_LEVEL
    if (!dhcp) return;

    msg = GETPKTDATA(pkt, DhcpMessage);
    msglen = pkt->datalen;

    DhcpDumpMessage(msg, msglen);

    //
    // Basic sanity checks: was the packet really meant for us?
    //
    if (msglen < DHCPHDRLEN ||
        msg->op != BOOTREPLY ||
        msg->htype != DhcpMapHwtype(ifp->iftype) ||
        msg->hlen != ifp->hwaddrlen ||
        !EqualMem(msg->chaddr, ifp->hwaddr, ifp->hwaddrlen) ||
        NTOHL(msg->xid) != dhcp->xid) {
        return;
    }

    dhcpParams = (DhcpOptionParam*) XnetAlloc0(sizeof(*dhcpParams), PTAG_DHCP);
    if (!dhcpParams) {
        status = NETERR_MEMORY;
        goto exit;
    }

    //
    // Skip the DHCP magic cookie
    //
    option = msg->options;
    msglen -= DHCPHDRLEN;
    if (msglen < DHCPCOOKIELEN ||
        !EqualMem(option, DhcpMagicCookie, DHCPCOOKIELEN)) {
        goto exit;
    }
    msglen -= DHCPCOOKIELEN;
    option += DHCPCOOKIELEN;

    //
    // Parse the regular options
    //
    status = DhcpParseOptionParams(dhcpParams, option, msglen, &overload);
    if (!NT_SUCCESS(status)) goto exit;

    //
    // Parse overloaded options in the msg->file field
    //
    if (overload & 1) {
        status = DhcpParseOptionParams(dhcpParams, msg->file, sizeof(msg->file), NULL);
        if (!NT_SUCCESS(status)) goto exit;
    }

    //
    // Parse overloaded options in the msg->sname field
    //
    if (overload & 2) {
        status = DhcpParseOptionParams(dhcpParams, msg->sname, sizeof(msg->sname), NULL); 
        if (!NT_SUCCESS(status)) goto exit;
    }

    //
    // The received packet must have a server identifier option
    //
    if (dhcpParams->dhcpServer == 0) {
        status = NETERR_PARAM;
        goto exit;
    }

    //
    // Now that we've parsed the option data,
    // use it appropriately
    //
    status = NETERR_DISCARDED;

    switch (dhcp->state) {
    case STATE_INIT:
        // Expecting DHCPOFFER...
        if (dhcpParams->recvMsgType == DHCPOFFER)
            status = DhcpProcessOffer(dhcp, msg->yiaddr, dhcpParams);
        break;

    case STATE_INIT_REBOOT:
    case STATE_REQUESTING:
    case STATE_RENEWING:
    case STATE_REBINDING:
        // Expecting DHCPACK or DHCPNAK...
        if (dhcpParams->recvMsgType == DHCPACK)
            status = DhcpProcessAck(dhcp, msg->yiaddr, dhcpParams);
        else if (dhcpParams->recvMsgType == DHCPNAK)
            status = DhcpProcessNak(dhcp, dhcpParams->dhcpServer);
        break;

    case STATE_STATIC_ADDR:
        // Expecting DHCPACK...
        if (dhcpParams->recvMsgType == DHCPACK) {
            // Use the option parameters from the server
            DhcpUseOptionParams(dhcp, dhcpParams);
            status = NETERR_OK;
        }
        break;
    }

exit:

    if (!NT_SUCCESS(status) && status != NETERR_DISCARDED) {
        WARNING_("ProcessDhcpPacket failed: 0x%x", status);
    }

    XnetFree(dhcpParams);
}


VOID
DhcpNotifyAddressConflict(
    IfInfo* ifp
    )

/*++

Routine Description:

    This is called when the interface layer detects
    an address conflict (e.g. through ARP)

Arguments:

    ifp - Points to the interface structure

Return Value:

    NONE

--*/

{
    DhcpInfo* dhcp = ifp->dhcpInfo;

    RUNS_AT_DISPATCH_LEVEL
    if (!dhcp) return;

    if (dhcp->state == STATE_SELECT_AUTOADDR) {
        // the last autonet address we chose was no good
        // so we need to find another one
        DhcpSelectAutonetAddr(dhcp);
    } else {
        WARNING_("!!! Address conflict: %s", IPADDRSTR(dhcp->activeaddr));
    }
}


//
// Number of seconds from start of 1601 to start of 2000
//
static const LONGLONG StartOf2000 = 0x2ee7dd480;

PRIVATE DHCPTIME
DhcpTime()

/*++

Routine Description:

    Return the number of seconds ellapsed since 00:00:00
    January 1, 2000, coordinated universal time.

Arguments:

    NONE

Return Value:

    See above.

--*/

{
    LARGE_INTEGER currentTime;

    // Get the current UTC time
    //  = number of 100 nanoseconds since 1/1/1601
    KeQuerySystemTime(&currentTime);

    // Return the number of seconds since the start of 2000
    return (DHCPTIME) (currentTime.QuadPart / 10000000 - StartOf2000);
}


PRIVATE VOID
DhcpSetIfTimerRelative(
    DhcpInfo* dhcp,
    UINT minWait,
    UINT maxWait
    )

/*++

Routine Description:

    Set the timer for an interface:
        randomized and relative to current time

Arguments:

    dhcp - Points to the DHCP structure
    minWait, maxWait - minimum and maximum wait time, in seconds

Return Value:

    NONE

--*/

{
    // Compute the randomized wait time
    minWait += XnetRandScaled(maxWait - minWait);

    if ((dhcp->timer = minWait) == 0) {
        DhcpHandleTimeout(dhcp);
    }
}


PRIVATE VOID
DhcpSetIfTimerAbsolute(
    DhcpInfo* dhcp,
    DHCPTIME timer
    )

/*++

Routine Description:

    Set the timer for an interface: absolute time

Arguments:

    dhcp - Points to the DHCP structure
    timer - When the timer should expire
        number of seconds since the start of 1/1/2000

Return Value:

    NONE

--*/

{
    DHCPTIME now;

    if (timer == DHCPTIME_INFINITE) {
        // Infinite wait
        dhcp->timer = 0xffffffff;
        return;
    }

    now = DhcpTime();
    if (timer > now) {
        dhcp->timer = timer - now;
    } else {
        dhcp->timer = 0;
        DhcpHandleTimeout(dhcp);
    }
}


PRIVATE VOID
DhcpComputeTimeout(
    DhcpInfo* dhcp
    )

/*++

Routine Description:

    Compute the next timeout interval after sending out a packet

Arguments:

    dhcp - Points to the DHCP structure

Return Value:

    Status code

--*/

{
    UINT minWait, maxWait;

    switch (dhcp->state) {
    case STATE_INIT:
        if (ActiveAutonetAddr(dhcp)) {
            //
            // Special case: we're currently using an Autonet address
            // and we're sending out periodic DHCPDISCOVER packets.
            //
            // DhcpSetIfTimerRelative(
            //     dhcp,
            //     cfgAutonetDhcpCheckInterval,
            //     cfgAutonetDhcpCheckInterval);

            // NOTE: Non-standard behavior!!!
            //  We do not send out DHCPDISCOVER messages
            //  while we're using an active AutoNet address.
            DhcpSetIfTimerAbsolute(dhcp, DHCPTIME_INFINITE);
            break;
        }

        // Fall through

    case STATE_REQUESTING:
    case STATE_INIT_REBOOT:
        //
        // timeout = 2**retry x 2 +/- 1, i.e.
        //  4 +/- 1
        //  8 +/- 1
        //  16 +/- 1
        //  32 +/- 1
        //

        minWait = 2 << dhcp->retries;
        if (minWait > cfgDhcpRetryMaxTimeout)
            minWait = cfgDhcpRetryMaxTimeout;

        minWait -= 1;
        maxWait = minWait + 2;
        DhcpSetIfTimerRelative(dhcp, minWait, maxWait);
        break;

    case STATE_BOUND:
        //
        // timeout when T1 expires
        //
        DhcpSetIfTimerAbsolute(dhcp, dhcp->t1time);
        break;

    case STATE_RENEWING:
    case STATE_REBINDING: {
        //
        // calculate retransmission timeout for
        // RENEWING and REBINDING states:
        //  1. half the time from now to T2 (renew) or expiration (rebind)
        //  2. make sure it's at least 60 seconds
        //

        DHCPTIME t1, t2;
        t1 = DhcpTime();
        t2 = (dhcp->state == STATE_RENEWING) ? dhcp->t2time : dhcp->exptime;

        if (t1 < t2) {
            minWait = (t2-t1) / 2;
            if (minWait >= cfgMinRenewTimeout)
                t1 += minWait;
            else {
                t1 += cfgMinRenewTimeout;
                if (t1 > t2) t1 = t2;
            }
        }

        DhcpSetIfTimerAbsolute(dhcp, t1);
        }
        break;

    case STATE_DECLINING:
        //
        // Wait 10 seconds after sending DHCP decline
        //
        DhcpSetIfTimerRelative(dhcp, 10, 10);
        break;
    
    case STATE_SELECT_AUTOADDR:
        //
        // Wait ~2 seconds for address conflict detection
        //
        DhcpSetIfTimerRelative(dhcp, 2, 2);
        break;

    default:
        // Should not happen - shut off the timer just in case
        ASSERT(FALSE);

    case STATE_STATIC_ADDR:
    case STATE_NONE:
        DhcpSetIfTimerAbsolute(dhcp, DHCPTIME_INFINITE);
        break;
    }
}


PRIVATE VOID
DhcpHandleTimeout(
    DhcpInfo* dhcp
    )

/*++

Routine Description:

    Handle a timeout event for an interface

Arguments:

    dhcp - Points to the DHCP structure

Return Value:

    NONE

--*/

{
    switch (dhcp->state) {
    case STATE_NONE:
        //
        // We got here because we just finished the quiet
        // period after startup
        //
        // If we had a valid lease before, start in
        // INIT-REBOOT state; otherwise, start in INIT state
        //
        DhcpChangeState(dhcp, dhcp->dhcpaddr ? STATE_INIT_REBOOT : STATE_INIT);
        break;
    
    case STATE_INIT:
        //
        // We're sending DHCPDISCOVER messages
        //
        if (dhcp->retries >= cfgDhcpRetryCount && !ActiveAutonetAddr(dhcp)) {
            //
            // Too many retries, give up and
            // start Autonet address acquisition process
            //
            VERBOSE_("Couldn't discover DHCP server, trying autonet...");
            DhcpChangeState(dhcp, STATE_SELECT_AUTOADDR);
        } else {
            //
            // Send out another DHCPDISCOVER packet
            //
            VERBOSE_("Retransmit DHCPDISCOVER");
            DhcpSendDiscover(dhcp);
        }
        break;

    case STATE_INIT_REBOOT:
    case STATE_REQUESTING:
        //
        // We're sending DHCPREQUEST
        //
        if (dhcp->retries >= cfgDhcpRetryCount) {
            //
            // Too many retries, go back to INIT state
            //
            VERBOSE_(dhcp->state == STATE_INIT_REBOOT ?
                        "Failed to reuse a prior lease" :
                        "No ack for an offered address");

            DhcpChangeState(dhcp, STATE_INIT);
        } else {
            //
            // Send out another DHCPREQUEST packet
            //
            VERBOSE_("Retransmit DHCPREQUEST");
            DhcpSendRequest(dhcp);
        }
        break;
    
    case STATE_DECLINING:
        //
        // We just finished waiting after sending DHCPDECLINE
        //
        DhcpChangeState(dhcp, STATE_INIT);
        break;
    
    case STATE_BOUND:
        //
        // T1 expired, start the renewing process
        //
        VERBOSE_("Switching to RENEWING state");
        DhcpChangeState(dhcp, STATE_RENEWING);
        break;

    case STATE_RENEWING:
        //
        // We're trying to renew a valid address.
        // If T2 expired, start the rebinding process.
        //
        if (DhcpTime() >= dhcp->t2time) {
            VERBOSE_("Switching to REBINDING state");
            DhcpChangeState(dhcp, STATE_REBINDING);
        } else {
            // Send out another DHCPREQUEST
            VERBOSE_("Retransmit DHCPREQUEST");
            DhcpSendRequest(dhcp);
        }
        break;

    case STATE_REBINDING:
        //
        // We're trying to rebind a valid lease
        //  did our lease expire?
        //
        if (DhcpTime() >= dhcp->exptime) {
            // Inform IP stack to discard the active address
            VERBOSE_("Address lease expired - start over");
            DhcpResetInterface(dhcp);

            // Too bad, go back to INIT state
            DhcpChangeState(dhcp, STATE_INIT);
        } else {
            // Send out another DHCPREQUEST
            VERBOSE_("Retransmit DHCPREQUEST");
            DhcpSendRequest(dhcp);
        }
        break;

    case STATE_SELECT_AUTOADDR:
        if (++dhcp->retries >= cfgConflictCheckRetries) {
            // We've successfully picked an autonet address.
            VERBOSE_("Selected autonet address: %s", IPADDRSTR(dhcp->autonetaddr));

            dhcp->activeaddr = dhcp->autonetaddr;
            dhcp->activemask = HTONL(AUTONET_ADDRMASK);
            dhcp->flags |= FLAG_ACTIVE_AUTONETADDR;
            IfSetIpAddr(dhcp->ifp, dhcp->activeaddr, dhcp->activemask);
            DhcpSignalAddrEvent(dhcp);

            // Switch to INIT state to continue looking
            // for a DHCP server
            dhcp->initRetryCount = 0;
            DhcpChangeState(dhcp, STATE_INIT);
        } else {
            // No response to our previous ARP request.
            // Try again just to be sure.
            DhcpCheckAddressConflict(dhcp->ifp, dhcp->autonetaddr);
            DhcpComputeTimeout(dhcp);
        }
        break;

    default:
        VERBOSE_("Unexpected timeout");
        DhcpSetIfTimerAbsolute(dhcp, DHCPTIME_INFINITE);
        break;
    }
}


PRIVATE VOID
DhcpChangeState(
    DhcpInfo* dhcp,
    INT state
    )

/*++

Routine Description:

    Change the state of an interface

Arguments:

    dhcp - Points to the DHCP structure
    state - Specifies the new state for the interface

Return Value:

    NONE

--*/

{
    INT oldstate = dhcp->state;

    dhcp->state = state;
    dhcp->retries = 0;

    // Assign a new transaction ID for the next outgoing message.

    if (DhcpGlobalXid == 0) DhcpGlobalXid = XnetRand();
    dhcp->xid = DhcpGlobalXid++;

    switch (state) {
    case STATE_STATIC_ADDR:
        // Should we send DHCPINFORM?
        if (dhcp->flags & FLAG_SEND_DHCPINFORM) {
            DhcpSendInform(dhcp);
        }
        break;

    case STATE_INIT_REBOOT:
    case STATE_REQUESTING:
    case STATE_RENEWING:
    case STATE_REBINDING:
        // Send out DHCPREQUEST
        DhcpSendRequest(dhcp);
        break;

    case STATE_INIT:
        if (oldstate == STATE_SELECT_AUTOADDR) {
            // We just selected an autonet address.
            // Continue to look for a DHCP server.
            DhcpComputeTimeout(dhcp);
        } else if (++dhcp->initRetryCount > cfgDhcpRetryCount) {
            // We went through the INIT state too many times
            // without getting a valid address lease. Just give up.
            // We don't try Autonet because in this case there
            // is a DHCP server but somehow we can't work with it.
            WARNING_("Couldn't get a valid DHCP address after many tries");
            DhcpChangeState(dhcp, STATE_NONE);

            // Signal that Xnet initialization was completed abnormally
            DhcpSignalAddrEvent(dhcp);
        } else {
            // Send out DHCPDISCOVER
            DhcpSendDiscover(dhcp);
        }
        break;

    case STATE_BOUND:
        DhcpComputeTimeout(dhcp);
        VERBOSE_("Sleep %d seconds till renewal...", dhcp->t1time - DhcpTime());
        break;

    case STATE_SELECT_AUTOADDR:
        dhcp->initRetryCount = 0;
        DhcpSelectAutonetAddr(dhcp);
        break;

    case STATE_NONE:
        DhcpSetIfTimerAbsolute(dhcp, DHCPTIME_INFINITE);
        break;
    }
}


PRIVATE VOID
DhcpResetInterface(
    DhcpInfo* dhcp
    )

/*++

Routine Description:

    Reset an interface to have no address

Arguments:

    dhcp - Points to the DHCP structure

Return Value:

    Status code

--*/

{
    IfSetIpAddr(dhcp->ifp, 0, 0);
    dhcp->flags &= ~FLAG_ACTIVE_ADDRMASK;
    if (dhcp->state != STATE_STATIC_ADDR)
        dhcp->activeaddr = 0;

    // Since we don't have an active address anymore,
    // we need to notify the DNS module of the change.
    DnsNotifyDefaultServers(dhcp->ifp);
}


PRIVATE NTSTATUS
DhcpSendMessage(
    DhcpInfo* dhcp,
    Packet* pkt,
    BOOL broadcast
    )

/*++

Routine Description:

    Send out a DHCP message on the specified interface

Arguments:

    dhcp - Points to the DHCP structure
    pkt - Points to the message to be sent
        !!! we assume the message buffer is at least 300 bytes
        and unused bytes are zero-filled.
    broadcast - Whether to use broadcast or unicast

Return Value:

    Status code

--*/

{
    IpAddrPair addrpair;
    DhcpMessage* msg;
    UINT msglen;

    addrpair.dstaddr = broadcast ? IPADDR_BCAST : dhcp->dhcpServer;
    addrpair.srcaddr = dhcp->activeaddr;
    addrpair.dstport = DHCP_SERVER_PORT;
    addrpair.srcport = DHCP_CLIENT_PORT;

    msg = GETPKTDATA(pkt, DhcpMessage);
    msglen = pkt->datalen;

    // Debug trace
    DhcpDumpMessage(msg, msglen);

    // Set broadcast flag if necessary
    if (!dhcp->activeaddr || ActiveAutonetAddr(dhcp))
        msg->flags |= HTONS(DHCP_BROADCAST);

    // Call UDP directly to send out the packet
    UdpSendPacketInternal(pkt, &addrpair, dhcp->ifp);

    // Calculate the timeout value
    dhcp->retries++;
    DhcpComputeTimeout(dhcp);

    return NETERR_OK;
}


//
// Append the 'parameter request list' option
//  !!! we assume the data buffer is large enough.
//
PRIVATE BYTE*
DhcpAppendParamReqList(
    BYTE* option
    )
{
    //
    // our default list of option parameters
    //
    static const BYTE defaultParamReqList[] = {
        DHCPOPT_SUBNET_MASK,
        DHCPOPT_ROUTERS,
        DHCPOPT_DNS_SERVERS,
        DHCPOPT_DOMAIN_NAME
    };

    UINT count = sizeof(defaultParamReqList);

    option[0] = DHCPOPT_PARAM_REQUEST_LIST;
    option[1] = (BYTE) count;
    option += 2;

    CopyMem(option, defaultParamReqList, count);
    return option + count;
}

//
// Append an option whose value is a DWORD
//
PRIVATE BYTE*
DhcpAppendDWordOption(
    BYTE* option,
    INT tag,
    DWORD val
    )
{
    option[0] = (BYTE) tag;
    option[1] = sizeof(DWORD);
    option += 2;

    CopyMem(option, &val, sizeof(DWORD));
    return option + sizeof(DWORD);
}


//
// Append the 'address lease time' option
//
PRIVATE BYTE*
DhcpAppendLeaseTimeOption(
    BYTE* option
    )
{
    if (cfgDefaultLeaseTime == 0) return option;

    return DhcpAppendDWordOption(   
                option,
                DHCPOPT_IPADDR_LEASE_TIME,
                HTONL(cfgDefaultLeaseTime));
}


PRIVATE BYTE*
DhcpFillMessageHeader(
    DhcpInfo* dhcp,
    BYTE* buf,
    INT msgtype
    )

/*++

Routine Description:

    Fill in the common header information for
    all outgoing DHCP messages

Arguments:

    dhcp - Points to the DHCP structure
    buf - Points to the message buffer
        !!! must be at least DEFAULT_DHCP_BUFSIZE bytes
    msgtype - DHCP message type

Return Value:

    Points to the first byte after the common options:
        magic cookie
        DHCP message type
        client identifier

--*/

{
    DhcpMessage* msg = (DhcpMessage*) buf;
    BYTE* option = msg->options;
    IfInfo* ifp = dhcp->ifp;
    BYTE hwtype;

    ZeroMem(buf, DEFAULT_DHCP_BUFSIZE);
    msg->op = BOOTREQUEST;
    msg->htype = hwtype = DhcpMapHwtype(ifp->iftype);
    msg->hlen = (BYTE) ifp->hwaddrlen;
    CopyMem(msg->chaddr, ifp->hwaddr, ifp->hwaddrlen);

    //
    // Fill in the transaction ID field
    // NOTE: We reuse the same XID for retransmissions.
    //
    msg->xid = HTONL(dhcp->xid);

    // Number of seconds since we started the address
    // acquisition process.
    msg->secs = (WORD) HTONS(dhcp->secsSinceStart);

    // Start with the magic cookie
    CopyMem(option, DhcpMagicCookie, DHCPCOOKIELEN);
    option += DHCPCOOKIELEN;

    // Append the message type option
    option[0] = DHCPOPT_DHCP_MESSAGE_TYPE;
    option[1] = 1;
    option[2] = (BYTE) msgtype;
    option += 3;

    // Append the client identifier option
    option[0] = DHCPOPT_CLIENTID;
    option[1] = (BYTE) (ifp->hwaddrlen+1);
    option[2] = hwtype;
    option += 3;
    CopyMem(option, ifp->hwaddr, ifp->hwaddrlen);
    option += ifp->hwaddrlen;

    return option;
}


PRIVATE VOID
DhcpComputeSecsSinceStart(
    DhcpInfo* dhcp
    )

/*++

Routine Description:

    Compute the number of seconds since the current
    address acqusition process started.

Arguments:

    dhcp - Points to the DHCP structure

Return Value:

    NONE

--*/

{
    DHCPTIME now = DhcpTime();

    if (dhcp->retries == 0) dhcp->acqtime = now;
    dhcp->secsSinceStart = now - dhcp->acqtime;
}


//
// Common prolog and epilog for SendDhcpXXX functions
//
#define SEND_DHCP_MESSAGE_PROLOG() \
        DhcpMessage* msg; \
        BYTE* buf; \
        BYTE* option; \
        Packet* pkt = XnetAllocIpPacket(UDPHDRLEN, DEFAULT_DHCP_BUFSIZE); \
        if (!pkt) return NETERR_MEMORY; \
        buf = pkt->data; \
        msg = (DhcpMessage*) buf

#define SEND_DHCP_MESSAGE_RETURN(_bcast) \
        pkt->datalen = option - buf; \
        return DhcpSendMessage(dhcp, pkt, _bcast)


PRIVATE NTSTATUS
DhcpSendDiscover(
    DhcpInfo* dhcp
    )

/*++

Routine Description:

    Broadcast a DHCPDISCOVER message

Arguments:

    dhcp - Points to the DHCP structure

Return Value:

    Status code

--*/

{
    SEND_DHCP_MESSAGE_PROLOG();

    ASSERT(dhcp->state == STATE_INIT);

    DhcpComputeSecsSinceStart(dhcp);

    // Fill in common header fields
    option = DhcpFillMessageHeader(dhcp, buf, DHCPDISCOVER);

    // Fill in the parameter request list
    option = DhcpAppendParamReqList(option);

    // Fill in requested ip address and lease time option
    if (dhcp->dhcpaddr)
        option = DhcpAppendDWordOption(option, DHCPOPT_REQUESTED_IPADDR, dhcp->dhcpaddr);

    // Fill in the lease time option
    option = DhcpAppendLeaseTimeOption(option);
    *option++ = DHCPOPT_END;

    // Emit the message
    SEND_DHCP_MESSAGE_RETURN(TRUE);
}


PRIVATE NTSTATUS
DhcpSendRequest(
    DhcpInfo* dhcp
    )

/*++

Routine Description:

    Send (broadcast/unicast) a DHCPREQUEST message

Arguments:

    dhcp - Points to the DHCP structure

Return Value:

    Status code

--*/

{
    INT state = dhcp->state;
    SEND_DHCP_MESSAGE_PROLOG();

    ASSERT(state == STATE_REQUESTING ||
           state == STATE_RENEWING ||
           state == STATE_REBINDING ||
           state == STATE_INIT_REBOOT);

    //
    // If we're in REQUESTING state, then don't update
    // the secsSinceStart field. This is so that the
    // secs in DHCPREQUEST message will be the same as
    // what's in the original DHCPDISCOVER message.
    //
    if (state != STATE_REQUESTING) {
        DhcpComputeSecsSinceStart(dhcp);
    }

    // Fill in common header fields
    option = DhcpFillMessageHeader(dhcp, buf, DHCPREQUEST);

    // Fill in the ciaddr field and the 'requested ip addr' option
    if (state == STATE_RENEWING || state == STATE_REBINDING) {
        msg->ciaddr = dhcp->dhcpaddr;
    } else if (dhcp->dhcpaddr) {
        // state == STATE_INIT_REBOOT || state == STATE_REQUESTING
        option = DhcpAppendDWordOption(option, DHCPOPT_REQUESTED_IPADDR, dhcp->dhcpaddr);
    }

    // Fill in the parameter request list
    option = DhcpAppendParamReqList(option);

    // Fill in the lease time option
    option = DhcpAppendLeaseTimeOption(option);

    // Fill in the server identifier option
    if (state == STATE_REQUESTING)
        option = DhcpAppendDWordOption(option, DHCPOPT_SERVERID, dhcp->dhcpServer);

    *option++ = DHCPOPT_END;

    // Emit the message:
    //  unicast in RENEWING state, broadcast otherwise
    SEND_DHCP_MESSAGE_RETURN(state != STATE_RENEWING);
}


PRIVATE NTSTATUS
DhcpSendInform(
    DhcpInfo* dhcp
    )

/*++

Routine Description:

    Broadcast a DHCPINFORM message

Arguments:

    dhcp - Points to the DHCP structure

Return Value:

    Status code

--*/

{
    SEND_DHCP_MESSAGE_PROLOG();

    ASSERT(dhcp->state == STATE_STATIC_ADDR);

    DhcpComputeSecsSinceStart(dhcp);

    // Fill in common header fields
    option = DhcpFillMessageHeader(dhcp, buf, DHCPINFORM);

    // Fill in ciaddr field
    msg->ciaddr = dhcp->activeaddr;

    // Fill in the parameter request list
    option = DhcpAppendParamReqList(option);
    *option++ = DHCPOPT_END;

    // Emit the message
    SEND_DHCP_MESSAGE_RETURN(TRUE);
}


#ifdef _ENABLE_SEND_DECLINE

PRIVATE NTSTATUS
DhcpSendDecline(
    DhcpInfo* dhcp,
    IPADDR dhcpServer,
    IPADDR ipaddr
    )

/*++

Routine Description:

    Broadcast a DHCPDECLINE message

Arguments:

    dhcp - Points to the DHCP structure
    dhcpServer - The server that offered the IP address
    ipaddr - The IP address to decline

Return Value:

    Status code

--*/

{
    SEND_DHCP_MESSAGE_PROLOG();

    ASSERT(dhcp->state == STATE_INIT_REBOOT ||
           dhcp->state == STATE_REQUESTING);

    DhcpChangeState(dhcp, STATE_DECLINING);
    dhcp->secsSinceStart = 0;

    // Fill in common header fields
    option = DhcpFillMessageHeader(dhcp, buf, DHCPDECLINE);

    // Fill in 'requested ip addr' and 'server identifier' options
    option = DhcpAppendDWordOption(option, DHCPOPT_REQUESTED_IPADDR, ipaddr);
    option = DhcpAppendDWordOption(option, DHCPOPT_SERVERID, dhcpServer);
    *option++ = DHCPOPT_END;

    // Emit the message
    SEND_DHCP_MESSAGE_RETURN(TRUE);
}

#endif // _ENABLE_SEND_DECLINE


PRIVATE NTSTATUS
DhcpSendRelease(
    DhcpInfo* dhcp
    )

/*++

Routine Description:

    Unicast a DHCPRELEASE message to the server

Arguments:

    dhcp - Points to the DHCP structure

Return Value:

    Status code

--*/

{
    SEND_DHCP_MESSAGE_PROLOG();

    ASSERT(dhcp->state == STATE_BOUND ||
           dhcp->state == STATE_RENEWING ||
           dhcp->state == STATE_REBINDING);

    DhcpChangeState(dhcp, STATE_NONE);
    dhcp->secsSinceStart = 0;

    // Fill in common header fields
    option = DhcpFillMessageHeader(dhcp, buf, DHCPRELEASE);

    // Fill in 'server identifier' option
    option = DhcpAppendDWordOption(option, DHCPOPT_SERVERID, dhcp->dhcpServer);
    *option++ = DHCPOPT_END;

    // Fill in ciaddr field
    msg->ciaddr = dhcp->dhcpaddr;

    // Emit the message
    SEND_DHCP_MESSAGE_RETURN(FALSE);
}


PRIVATE BOOL
DhcpValidateOffer(
    IPADDR yiaddr,
    DhcpOptionParam* param
    )

/*++

Routine Description:

    Perform simple sanity check of offered DHCP parameters

Arguments:

    yiaddr - Offered IP address
    param - Other offered parameters

Return Value:

    TRUE if ok, FALSE otherwise

--*/

{
    if (!XnetIsValidUnicastAddr(yiaddr) ||
        !XnetIsValidUnicastAddr(param->dhcpServer) ||
        param->exptime < 8*cfgMinRenewTimeout)
        return FALSE;

    if (param->dhcpmask == 0)
        param->dhcpmask = XnetGetDefaultSubnetMask(yiaddr);

    if (param->t1time == 0 ||
        param->t2time == 0 ||
        param->t1time >= param->t2time ||
        param->t2time - param->t1time < cfgMinRenewTimeout ||
        param->t2time >= param->exptime ||
        param->exptime - param->t2time < cfgMinRenewTimeout) {
        param->t1time = param->exptime / 2;
        param->t2time = param->exptime * 7 / 8;
    }

    return TRUE;
}


PRIVATE NTSTATUS
DhcpProcessOffer(
    DhcpInfo* dhcp,
    IPADDR yiaddr,
    DhcpOptionParam* param
    )

/*++

Routine Description:

    Process a received DHCPOFFER packet

Arguments:

    dhcp - Points to the DHCP structure
    yiaddr - Offered address
    param - Option parameters

Return Value:

    Status code

--*/

{
    ASSERT(dhcp->state == STATE_INIT);

    VERBOSE_("Received DHCPOFFER %s", IPADDRSTR(yiaddr));
    VERBOSE_(" from %s", IPADDRSTR(param->dhcpServer));
    VERBOSE_(" @ time %d", DhcpTime());

    // Simply sanity check of offered parameters
    if (!DhcpValidateOffer(yiaddr, param))
        return NETERR_PARAM;

    dhcp->dhcpServer = param->dhcpServer;
    dhcp->dhcpaddr = yiaddr;

    // Send DHCPREQUEST and ignore error
    DhcpChangeState(dhcp, STATE_REQUESTING);
    return NETERR_OK;
}


PRIVATE VOID
DhcpAddOrRemoveGateways(
    DhcpInfo* dhcp,
    BOOL doDelete
    )

/*++

Routine Description:

    Set or delete default gateways

Arguments:

    dhcp - Points to the DHCP structure
    doDelete - Whether to set or delete gateways

Return Value:

    NONE

--*/

#define DEFAULT_METRIC 1

{
    UINT i;
    IPADDR addr;

    if (doDelete) {
        for (i=0; i < dhcp->gatewayCount; i++) {
            addr = dhcp->gateways[i];
            TRACE_("Remove gateway: %s", IPADDRSTR(addr));
            IpRemoveDefaultGateway(addr);
        }
    } else {
        for (i=0; i < dhcp->gatewayCount; i++) {
            addr = dhcp->gateways[i];
            TRACE_("Add gateway: %s", IPADDRSTR(addr));
            IpAddDefaultGateway(addr, DEFAULT_METRIC+i, dhcp->ifp);
        }
    }
}


VOID
DhcpSetDefaultGateways(
    IfInfo* ifp
    )
{
    KIRQL irql = RaiseToDpc();
    DhcpInfo* dhcp = ifp->dhcpInfo;

    if (dhcp) {
        DhcpAddOrRemoveGateways(dhcp, FALSE);
    }

    LowerFromDpc(irql);
}


PRIVATE VOID
DhcpUseOptionParams(
    DhcpInfo* dhcp,
    DhcpOptionParam* param
    )

/*++

Routine Description:

    Make use of the option parameters received from the server

Arguments:

    dhcp - Points to the DHCP structure
    param - Optional parameter values

Return Value:

    Status code

--*/

{
    BOOL resetGateways;

    //
    // Remember the originating server address and lease info
    //
    dhcp->dhcpServer = param->dhcpServer;

    if (param->exptime == DHCPTIME_INFINITE) {
        dhcp->t1time =
        dhcp->t2time =
        dhcp->exptime = DHCPTIME_INFINITE;
    } else {
        dhcp->t1time = dhcp->acqtime + param->t1time;
        dhcp->t2time = dhcp->acqtime + param->t2time;
        dhcp->exptime = dhcp->acqtime + param->exptime;
    }

    //
    // Set gateways in the IP stack
    //
    if (param->gatewayCount == 0 || dhcp->gatewayCount == 0) {
        resetGateways = TRUE;
    } else {
        UINT oldcnt = dhcp->gatewayCount;
        UINT newcnt = param->gatewayCount;
        UINT i, j;

        for (i=0; i < newcnt; i++) {
            for (j=0; j < oldcnt; j++)
                if (param->gateways[i] != dhcp->gateways[j]) break;
            if (j < oldcnt) break;
        }
        resetGateways = (i < newcnt);
    }

    if (resetGateways) {
        //
        // Reset gateways if anything has changed
        //  first delete existing gateways
        //  then set new gateways
        //
        // NOTE: should we ping the new gateways here?
        //
        DhcpAddOrRemoveGateways(dhcp, TRUE);

        dhcp->gatewayCount = param->gatewayCount;
        CopyMem(dhcp->gateways,
                param->gateways,
                param->gatewayCount * sizeof(IPADDR));

        DhcpAddOrRemoveGateways(dhcp, FALSE);
    }

    dhcp->dnsServerCount = param->dnsServerCount;
    CopyMem(dhcp->dnsServers,
            param->dnsServers,
            param->dnsServerCount * sizeof(IPADDR));

    strcpy(dhcp->domainName, param->domainName);
}


PRIVATE NTSTATUS
DhcpProcessAck(
    DhcpInfo* dhcp,
    IPADDR yiaddr,
    DhcpOptionParam* param
    )

/*++

Routine Description:

    Process a received DHCPACK packet

Arguments:

    dhcp - Points to the DHCP structure
    yiaddr - Offered address
    param - Option parameters

Return Value:

    Status code

--*/

{
    VERBOSE_("Received DHCPACK %s", IPADDRSTR(yiaddr));
    VERBOSE_("  from %s", IPADDRSTR(param->dhcpServer));

    ASSERT(dhcp->state == STATE_INIT_REBOOT ||
           dhcp->state == STATE_REQUESTING ||
           dhcp->state == STATE_RENEWING ||
           dhcp->state == STATE_REBINDING);

    // Simply sanity check of offered parameters
    if (!DhcpValidateOffer(yiaddr, param))
        return NETERR_PARAM;

    // Note: We're not checking for address conflicts
    // and just assume the offered address is valid.

    // If we're currently using a different address, give it up
    if ((dhcp->activeaddr != 0) &&
        (dhcp->activeaddr != yiaddr ||
         dhcp->activemask != param->dhcpmask) ||
         ActiveAutonetAddr(dhcp))
    {
        VERBOSE_("Giving up old IP address %s", IPADDRSTR(dhcp->activeaddr));
        DhcpResetInterface(dhcp);
    }

    // If we got a new address, set it down in the IP stack
    if (dhcp->activeaddr == 0) {
        IfSetIpAddr(dhcp->ifp, yiaddr, param->dhcpmask);
        DhcpSignalAddrEvent(dhcp);
        dhcp->activeaddr = dhcp->dhcpaddr = yiaddr;
        dhcp->activemask = dhcp->dhcpmask = param->dhcpmask;
        dhcp->flags |= FLAG_ACTIVE_DHCPADDR;
    }

    VERBOSE_("Accepted IP address: %s", IPADDRSTR(yiaddr));
    VERBOSE_("Lease time: %d / %d / %d", param->t1time, param->t2time, param->exptime);

    //
    // Set other option parameters
    //
    dhcp->initRetryCount = 0;
    DhcpUseOptionParams(dhcp, param);

    // We're now in bound state.
    // Set timer to expire at T1 time.
    DhcpChangeState(dhcp, STATE_BOUND);
    return NETERR_OK;
}


PRIVATE NTSTATUS
DhcpProcessNak(
    DhcpInfo* dhcp,
    IPADDR dhcpServer
    )

/*++

Routine Description:

    Process a received DHCPNAK packet

Arguments:

    dhcp - Points to the DHCP structure
    dhcpServer - The originating server address

Return Value:

    Status code

--*/

{
    VERBOSE_("Received DHCPNAK from %s", IPADDRSTR(dhcpServer));

    ASSERT(dhcp->state == STATE_INIT_REBOOT ||
           dhcp->state == STATE_REQUESTING ||
           dhcp->state == STATE_RENEWING ||
           dhcp->state == STATE_REBINDING);

    // Barf if we got DHCPNAK from an unexpected server
    if (dhcp->state != STATE_INIT_REBOOT && dhcpServer != dhcp->dhcpServer) {
        WARNING_("Random DHCPNAK from %s?", IPADDRSTR(dhcpServer));
    }

    // If we're using an address, give it up
    if (dhcp->activeaddr) {
        DhcpResetInterface(dhcp);
    }

    //
    // Go to INIT state to start over again
    // Send DHCPDISCOVER and ignore error
    //
    DhcpChangeState(dhcp, STATE_INIT);
    return NETERR_OK;
}


PRIVATE NTSTATUS
DhcpParseOptionParams(
    DhcpOptionParam* param,
    const BYTE* buf,
    UINT buflen,
    BYTE* overload
    )

/*++

Routine Description:

    Parse option parameters in a received DHCP packet

Arguments:

    param - Where to store the resulting information
    buf - Points to the option data buffer
    buflen - Buffer length
    overload - Returns the overload option value

Return Value:

    Status code

--*/

// NOTE: we're assuming little-endian machine here.
#define EXTRACT_DWORD_OPTION(_result) \
        if (len != 4) goto exit; \
        if (_result == 0) { \
            _result = (((DWORD) buf[0] << 24) | \
                       ((DWORD) buf[1] << 16) | \
                       ((DWORD) buf[2] <<  8) | \
                       ((DWORD) buf[3]      )); \
        }

#define EXTRACT_IPADDR_OPTION(_result) \
        if (len != 4) goto exit; \
        if (_result == 0) _result = *((IPADDR*) buf)

{
    while (buflen) {
        UINT tag, len;

        // Stop after seeing the 'end' option
        if ((tag = buf[0]) == DHCPOPT_END) break;

        // Skip the 'pad' option
        if (tag == DHCPOPT_PAD) {
            buf++; buflen--;
            continue;
        }

        // Is the option length field valid?
        if (buflen < 2 || buflen-2 < (len = buf[1])) goto exit;
        buf += 2; buflen -= 2;
    
        // Interpret option data
        switch (tag) {
        case DHCPOPT_DHCP_MESSAGE_TYPE:
            if (len != 1) goto exit;
            if (param->recvMsgType == 0)
                param->recvMsgType = *buf;
            break;

        case DHCPOPT_SERVERID:
            EXTRACT_IPADDR_OPTION(param->dhcpServer);
            break;

        case DHCPOPT_SUBNET_MASK:
            EXTRACT_IPADDR_OPTION(param->dhcpmask);
            break;

        case DHCPOPT_ROUTERS:
        case DHCPOPT_DNS_SERVERS: {
            UINT* pcount;
            IPADDR* parray;
            UINT n;

            if (len == 0 || len % sizeof(IPADDR) != 0) goto exit;
            if (tag == DHCPOPT_ROUTERS) {
                pcount = &param->gatewayCount;
                parray = param->gateways;
                n = MAX_DEFAULT_GATEWAYS * sizeof(IPADDR);
            } else {
                pcount = &param->dnsServerCount;
                parray = param->dnsServers;
                n = MAX_DEFAULT_DNSSERVERS * sizeof(IPADDR);
            }
        
            if (n > len) n = len;
            if (*pcount == 0) {
                *pcount = n / sizeof(IPADDR);
                CopyMem(parray, buf, n);
            }
            }
            break;

        case DHCPOPT_DOMAIN_NAME:
            if (len < 1 || len >= sizeof(param->domainName)) goto exit;
            if (param->domainName[0] == 0) {
                CopyMem(param->domainName, buf, len);
                param->domainName[len] = 0;
            }
            break;

        case DHCPOPT_IPADDR_LEASE_TIME:
            EXTRACT_DWORD_OPTION(param->exptime);
            break;

        case DHCPOPT_T1_INTERVAL:
            EXTRACT_DWORD_OPTION(param->t1time);
            break;

        case DHCPOPT_T2_INTERVAL:
            EXTRACT_DWORD_OPTION(param->t2time);
            break;

        case DHCPOPT_FIELD_OVERLOAD:
            if (len != 1) goto exit;
            if (overload && *overload == 0) *overload = *buf;
            break;
        }

        buf += len; buflen -= len;
    }

    return NETERR_OK;

exit:
    WARNING_("Invalid option data");
    return NETERR_PARAM;
}


PRIVATE VOID
DhcpSelectAutonetAddr(
    DhcpInfo* dhcp
    )

/*++

Routine Description:

    Attempt to select an autonet address

Arguments:

    dhcp - Points to the DHCP structure

Return Value:

    NONE

--*/

{
    IPADDR addr;

    ASSERT(dhcp->state == STATE_SELECT_AUTOADDR);

    if (++dhcp->initRetryCount > cfgAutonetAddrRetries) {
        //
        // We tried too many autonet addresses without success.
        // Just give up.
        //
        dhcp->initRetryCount = 0;
        DhcpChangeState(dhcp, STATE_NONE);

        // Signal that Xnet initialization was completed abnormally
        WARNING_("Failed to pick an autonet address.");
        DhcpSignalAddrEvent(dhcp);
        return;
    }

    // Generate a random autonet address
    addr = AUTONET_ADDRBASE + XnetRandScaled(AUTONET_ADDRRANGE);
    dhcp->autonetaddr = addr = HTONL(addr);

    VERBOSE_("Trying autonet address: %s", IPADDRSTR(addr));

    if (dhcp->ifp->flags & IFFLAG_CONNECTED_BOOT) {
        DhcpCheckAddressConflict(dhcp->ifp, addr);
        dhcp->retries = 0;
        DhcpComputeTimeout(dhcp);
    } else {
        //
        // NOTE: if net cable isn't connected at boot time,
        // there is no point trying to check for address conflicts.
        //
        dhcp->retries = cfgConflictCheckRetries;
        DhcpHandleTimeout(dhcp);
    }
}


NTSTATUS
DhcpGetDefaultDnsServers(
    IfInfo* ifp,
    CHAR* domainName,
    UINT namelen,
    IPADDR* serverAddrs,
    UINT* serverCnt
    )

/*++

Routine Description:

    Get the default DNS server information
    associated with the specified interface

Arguments:

    ifp - Points to an interface structure
    domainName - Buffer for receiving the default domain name
    namelen - Size of the domain name buffer
    serverAddrs - Buffer for receiving the default server addresses
    serverCnt - Number of default servers
        On entry, it specifies the size of the server address buffer
        On return, it contains the actual number of default servers

Return Value:

    Status code

--*/

{
    DhcpInfo* dhcp = ifp->dhcpInfo;
    UINT count;

    RUNS_AT_DISPATCH_LEVEL
    if (!dhcp) return NETERR_PARAM;

    //
    // Return the default domain name
    //
    count = dhcp->domainName ? strlen(dhcp->domainName) : 0;
    if (namelen <= count) return NETERR_MEMORY;
    if (count) {
        CopyMem(domainName, dhcp->domainName, count);
    }
    domainName[count] = 0;

    //
    // Return the default DNS server addresses
    //
    if (dhcp->dnsServerCount) {
        count = min(*serverCnt, dhcp->dnsServerCount);
        *serverCnt = count;
        CopyMem(serverAddrs, dhcp->dnsServers, count*sizeof(IPADDR));
    } else {
        *serverCnt = 0;
    }

    return NETERR_OK;
}


PRIVATE IPADDR
DhcpReadConfigIpAddr(
    ULONG index
    )

/*++

Routine Description:

    Wrapper function to read an IP address value
    from the xbox configuration sector

Arguments:

    index - Specifies the address of interest

Return Value:

    IP address value, 0 if there is an error

--*/

{
    ULONG type, size, addr;
    INT err = XQueryValue(index, &type, (VOID*) &addr, IPADDRLEN, &size);

    // If the query call failed, return 0 address.
    if (err != NO_ERROR || type != REG_DWORD || size != IPADDRLEN) {
        VERBOSE_("XQueryValue(%d) failed: %d, %d, %d", index, err, type, size);
        return 0;
    }

    return addr;
}


PRIVATE VOID
DhcpLoadConfigInfo(
    DhcpInfo* dhcp
    )

/*++

Routine Description:

    Load persistent DHCP configuration parameters

Arguments:

    dhcp - Points to the DHCP structure

Return Value:

    NONE

--*/

{
    //
    // Read the static IP address value.
    // Return right away if none is set.
    //
    dhcp->activeaddr = DhcpReadConfigIpAddr(XC_ONLINE_IP_ADDRESS);
    if (dhcp->activeaddr == 0) return;

    //
    // Read the subnet mask value.
    // If none is set, generate a default mask.
    //
    dhcp->activemask = DhcpReadConfigIpAddr(XC_ONLINE_SUBNET_ADDRESS);
    if (dhcp->activemask == 0) {
        dhcp->activemask = XnetGetDefaultSubnetMask(dhcp->activeaddr);
    }

    //
    // Read the default gateway address.
    //
    dhcp->gateways[0] = DhcpReadConfigIpAddr(XC_ONLINE_DEFAULT_GATEWAY_ADDRESS);
    if (dhcp->gateways[0] != 0)
        dhcp->gatewayCount = 1;
}


DWORD
DhcpGetActiveAddressType(
    IfInfo* ifp
    )

/*++

Routine Description:

    Determine how we obtained our currently active IP address

Arguments:

    ifp - Points to the interface structure

Return Value:

    Flags (see winsockx.h)

--*/

{
    DhcpInfo* dhcp;
    DWORD flags = 0;

    RUNS_AT_DISPATCH_LEVEL

    if ((dhcp = ifp->dhcpInfo) != NULL) {
        if (ActiveDhcpAddr(dhcp)) {
            flags = XNET_ADDR_DHCP;
        } else if (ActiveAutonetAddr(dhcp)) {
            flags = XNET_ADDR_AUTOIP;
        } else if (dhcp->state == STATE_STATIC_ADDR) {
            flags = XNET_ADDR_STATIC;
        }

        if (dhcp->gatewayCount)
            flags |= XNET_HAS_GATEWAY;
    }

    return flags;
}


NTSTATUS
DhcpWaitForAddress(
    IfInfo* ifp
    )

/*++

Routine Description:

    Wait for address acquisition process to complete

Arguments:

    ifp - Points to the interface structure

Return Value:

    Status code

--*/

{
    DhcpInfo* dhcp = ifp->dhcpInfo;
    NTSTATUS status;

    if (dhcp) {
        status = WaitKernelEventObject(&dhcp->addrEvent, 0);

        // Check if the acquisition process failed
        if (status == NETERR_OK && dhcp->state == STATE_NONE)
            status = NETERR_NETDOWN;
    } else
        status = NETERR(WSASYSNOTREADY);
    
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\dns\dns.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dns.h

Abstract:

    DNS protocol related declarations

Revision History:

    07/12/2000 davidx
        Created it.

--*/

#ifndef _DNS_H
#define _DNS_H

//
// DNS name format:
//  1 byte - label length (N)
//  N bytes - label
//  ... more labels
//  0 - root label
//
// Compression:
//  Normally, the two high bits of the label length byte is 00.
//  But if the two high bits are 11, then the remaining 6 bits
//  and the next byte form an offset. The offset is relative to
//  the beginning of the DNS message. The domain name continues
//  with data from that offset.
//

//
// Resource record (RR) format
//  NAME - see above
//  2 bytes - type
//  2 bytes - class
//  4 bytes - TTL (time-to-live)
//  2 bytes - RDATA length
//  RDATA - variable length
//

//
// RDATA format for well-known types
//
// A
//  4 bytes - internet address
//
// PTR
//  PTRDNAME: <name> - pointer to some location in the domain name space
//
// CNAME
//  CNAME: <name> - canonical name for the record owner
//
// MX
//  2 bytes - preference value
//  EXCHANGE: <name> - domain name for the mail exchange host
//
// SOA
//  MNAME: <name> - name server that's the primary data source for this zone
//  RNAME: <name> - mailbox of the zone administrator
//  4 bytes - version number of the original copy of the zone
//  4 bytes - time interval before the zone should be refreshed
//  4 bytes - wait time before a failed refresh should be retried
//  4 bytes - max time interval before the zone is no longer authoritative
//  4 bytes - minimum TTL that should be used for any RR in this zone
//

//
// RR type constants
//
#define RRTYPE_A        1   // a host address
#define RRTYPE_NS       2   // an authoritative name server
#define RRTYPE_MD       3   // a mail destination (Obsolete - use MX)
#define RRTYPE_MF       4   // a mail forwarder (Obsolete - use MX)
#define RRTYPE_CNAME    5   // the canonical name for an alias
#define RRTYPE_SOA      6   // marks the start of a zone of authority
#define RRTYPE_MB       7   // a mailbox domain name (EXPERIMENTAL)
#define RRTYPE_MG       8   // a mail group member (EXPERIMENTAL)
#define RRTYPE_MR       9   // a mail rename domain name (EXPERIMENTAL)
#define RRTYPE_NULL     10  // a null RR (EXPERIMENTAL)
#define RRTYPE_WKS      11  // a well known service description
#define RRTYPE_PTR      12  // a domain name pointer
#define RRTYPE_HINFO    13  // host information
#define RRTYPE_MINFO    14  // mailbox or mail list information
#define RRTYPE_MX       15  // mail exchange
#define RRTYPE_TXT      16  // text strings

// Additional query type constants
#define QTYPE_AXFR      252 // a transfer of an entire zone
#define QTYPE_MAILB     253 // mailbox-related records (MB, MG or MR)
#define QTYPE_MAILA     254 // mail agent RRs (Obsolete - see MX)
#define QTYPE_ALL       255 // all records

//
// RR class constants
//
#define RRCLASS_IN      1   // the Internet
#define QCLASS_ANY      255 // any class

//
// Limits
//
#define DNS_MAXLABELLEN 63
#define DNS_MAXNAMELEN  255
#define DNS_MAXMSGLEN   512

//
// DNS message format
//  header section
//  question section
//  answer section
//  authority section
//  additional section
//

typedef struct _DnsHeader {
    WORD id;
    WORD code;
    WORD questions;
    WORD answers;
    WORD nservers;
    WORD extras;
} DnsHeader;

#define DNSHDRLEN sizeof(DnsHeader)

//
// Bit assignment for the DnsHeader.code field
//  bit 15: whether the message is a query or a response
//  bit 14-11: specifies the kind of query
//      0 - standard query
//      1 - inverse query
//      2 - server status request
//      others - reserved
//  bit 10: whether the responding name server is an authority
//      for the domain name in question
//  bit 9: whether this message was truncated
//  bit 8: whether recursion is desired by the requester
//  bit 7: whether recursion is available on the server
//  bit 6-4: reserved
//  bit 3-0: response code (see below)
//
#define DNSFLAG_QUERY       (0 << 15)
#define DNSFLAG_RESPONSE    BIT(15)
#define DNSFLAG_AA          BIT(10)
#define DNSFLAG_TC          BIT(9)
#define DNSFLAG_RD          BIT(8)
#define DNSFLAG_RA          BIT(7)

#define DNSGETOPCODE(x)     (((x) >> 11) & 0xf)
#define DNSOPCODE_STDQUERY  0

#define DNSGETRCODE(x)      ((x) & 0xf)
#define RCODE_OK            0
#define RCODE_FORMAT_ERROR  1
#define RCODE_SERVER_FAILED 2
#define RCODE_NAME_ERROR    3
#define RCODE_NOTIMPL       4
#define RCODE_REFUSED       5

//
// Data format for the query section
//  QNAME: <name> - the domain name in question
//  QTYPE: 2 bytes - query type
//  QCLASS: 2 bytes - query class
//

//
// DNS server port number
//
#define DNS_SERVER_PORT 53

#endif // !_DNS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\dns\dnslib.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dnslib.h

Abstract:

    DNS client implementation related declarations

Revision History:

    07/11/2000 davidx
        Created it.

--*/

#ifndef _DNSLIB_H
#define _DNSLIB_H

//
// Internal DNS domain name representation
//  We represent the DNS domain name as an array of bytes.
//  1st byte is the total length of the name (not including the first two bytes)
//  2nd byte is the number of labels.
//  followed by the normal domain name data (as in RFC1035).
//  e.g.
//      19
//      3
//      3 www
//      9 microsoft
//      3 com
//      0
//
typedef BYTE DnsName;
DnsName* CreateDnsNameFromString(const CHAR* buf);
INLINE VOID FreeDnsName(DnsName* dnsname) {
    SysFree(dnsname);
}

#define SetDnsNameLen(_dnsname, _len)       ((_dnsname)[0] = (BYTE) (_len))
#define SetDnsNameLabels(_dnsname, _labels) ((_dnsname)[1] = (BYTE) (_labels))
#define GetDnsNameLen(_dnsname)             (_dnsname)[0]
#define GetDnsNameLabels(_dnsname)          (_dnsname)[1]
#define GetDnsNameData(_dnsname)            ((_dnsname) + 2)

#define SkipDnsNameLabel(_p) ((_p) + 1 + *(_p))

INLINE const BYTE* SkipDnsNameLabels(const BYTE* p, UINT n) {
    while (n--) {
        p = SkipDnsNameLabel(p);
    }
    return p;
}

// Make a copy of a DNS name
INLINE DnsName* CopyDnsName(const DnsName* dnsname) {
    UINT len = (UINT) GetDnsNameLen(dnsname) + 2;
    DnsName* newname = (DnsName*) SysAlloc(len, PTAG_DNS);
    if (newname) {
        CopyMem(newname, dnsname, len);
    }
    return newname;
}


//
// Cached DNS server entry
//
typedef struct _DnsServerCacheEntry {
    LIST_ENTRY links;
        // doubly-linked list pointers
        // must be the first field!

    UINT expires;
        // expiration time (in 0.5 seconds)

    IPADDR serverAddr;
        // DNS server address

    DnsName* domain;
        // name of the domain this server can handle

    UINT priority;
        // server precedence
        // lower value is more preferred
} DnsServerCacheEntry;


//
// Cached DNS lookup entry
//  we artifically limit the maximum number of aliases to 4
//
#define MAXALIASCNT 4

typedef struct _DnsCacheEntry {
    LIST_ENTRY links;
        // doubly-linked list pointers
        // must be the first field!
    
    LONG refcount;
        // reference count

    UINT expires;
        // expiration time (in 0.5 seconds)

    NTSTATUS status;
        // entry status

    WORD type;
        // entry type:
        //  RRTYPE_A
        //  RRTYPE_PTR

    BYTE namecnt;
        // number of names

    BYTE addrcnt;
        // number of addresses

    IPADDR addrs[MAXALIASCNT];
        // list of addresses

    DnsName* names[MAXALIASCNT];
        // list of names

    KEVENT event;
        // wait event object
} DnsCacheEntry;

//
// Map relative TTL value in seconds to
// absolute expiration time in ticks
//
#define DnsCacheExpires(_ttl) \
        (TcpTickCount + (_ttl) * SLOW_TCP_TIMER_FREQ)


//
// Data structure for storing parsed information
// from a DNS response message
//
typedef struct _DnsRR DnsRR;
typedef struct _DnsRR {
    DnsRR* next;            // points to the next RR
    DnsName* rrname;        // record name
    WORD type;              // record type
    WORD unused;
    UINT ttl;               // TTL
    union {
        IPADDR addr;        // IP address for RRTYPE_A record
        DnsName* dataname;  // data for other records:
                            //  RRTYPE_NS
                            //  RRTYPE_CNAME
                            //  RRTYPE_SOA
                            //  RRTYPE_PTR
    };
};

typedef struct _DnsResp {
    BYTE* start;            // points to where the DNS response message starts
    BYTE* end;              // points to after the DNS message
    DnsRR* answers;         // information in the answers section
    DnsRR* nservers;        // ... the nservers section
    DnsRR* extras;          // ... the extras section

    // temporary name buffer
    BYTE namebuf[DNS_MAXNAMELEN+1];
} DnsResp;

#endif // !_DNSLIB_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\dns\dns.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dns.c

Abstract:

    DNS client implementation

Revision History:

    07/12/2000 davidx
        Created it.

--*/

#include "precomp.h"

//
// Access to global DNS client data is protected by a mutex
//
RTL_CRITICAL_SECTION DnsCritSect;

#define DnsLock()   RtlEnterCriticalSection(&DnsCritSect)
#define DnsUnlock() RtlLeaveCriticalSection(&DnsCritSect)

//
// Default suffixes we'll try to append to the user specified
// name when doing a DNS lookup.
// 
#define MAX_DEFAULT_SUFFIXES 2
DnsName* DnsDefaultSuffixes[MAX_DEFAULT_SUFFIXES];
UINT DnsDefaultSuffixCount;

const DnsName* DnsRootDomainName = "\1\0";

//
// Cached list of DNS servers
//
LIST_ENTRY DnsServerCache;
UINT DnsServerCacheSize;
UINT cfgMaxDnsServerCacheSize = 16;

// Loop through all entries of the DNS server cache

#define DnsServerCacheFirst() ((DnsServerCacheEntry*) DnsServerCache.Flink)
#define DnsServerCacheNull() ((DnsServerCacheEntry*) &DnsServerCache)
#define DnsServerCacheFlink(_dnssrv) ((DnsServerCacheEntry*) (_dnssrv)->links.Flink)

#define LOOP_THRU_DNSSERVER_CACHE(_dnssrv) { \
            DnsServerCacheEntry* _next; \
            _dnssrv = DnsServerCacheFirst(); \
            for (; _dnssrv != DnsServerCacheNull(); _dnssrv = _next) { \
                _next = DnsServerCacheFlink(_dnssrv);

#define END_DNSSERVER_CACHE_LOOP \
            } \
        }

//
// Cached result of DNS lookups
// NOTE: we're using a simple linked list structure here.
// If the number of cache entries gets big, we may need
// something more elaborated for better perf.
//
LIST_ENTRY DnsCache;
UINT DnsCacheSize;
UINT cfgMaxDnsCacheSize = 64;
UINT cfgMaxLookupRetries = 4;
UINT cfgMinLookupTimeout = 5;
UINT cfgMaxDnsCacheTtl = 2*60*60;

// Loop through all entries of the DNS lookup cache

#define DnsCacheFirst() ((DnsCacheEntry*) DnsCache.Flink)
#define DnsCacheNull() ((DnsCacheEntry*) &DnsCache)
#define DnsCacheFlink(_dnsent) ((DnsCacheEntry*) (_dnsent)->links.Flink)

#define LOOP_THRU_DNS_CACHE(_dnsent) { \
            DnsCacheEntry* _next; \
            _dnsent = DnsCacheFirst(); \
            for (; _dnsent != DnsCacheNull(); _dnsent = _next) { \
                _next = DnsCacheFlink(_dnsent);

#define END_DNS_CACHE_LOOP \
            } \
        }

//
// Pending request to set default DNS domain and servers
//
IfInfo* DnsSetDefaultIfp;

//
// Next DNS query message ID
//
WORD DnsQueryMsgId;

//
// Forward function declarations
//
PRIVATE NTSTATUS DnsLookupProc(DnsName*, IPADDR, DnsCacheEntry**);


NTSTATUS
DnsInitialize()

/*++

Routine Description:

    Initialize the DNS client module

Arguments:

    NONE

Return Value:

    Status code

--*/

{
    RtlInitializeCriticalSection(&DnsCritSect);

    ZeroMem(DnsDefaultSuffixes, sizeof(DnsDefaultSuffixes));
    DnsDefaultSuffixCount = 0;

    InitializeListHead(&DnsServerCache);
    InitializeListHead(&DnsCache);
    DnsServerCacheSize = DnsCacheSize = 0;

    DnsQueryMsgId = (WORD) XnetRand();
    return NETERR_OK;
}


//
// Clean up the default search suffixes
//
INLINE VOID DnsCleanupDefaultSuffixes() {
    while (DnsDefaultSuffixCount) {
        DnsDefaultSuffixCount--;
        FreeDnsName(DnsDefaultSuffixes[DnsDefaultSuffixCount]);
        DnsDefaultSuffixes[DnsDefaultSuffixCount] = NULL;
    }
}

//
// Remove an entry from the DNS lookup cache
//
INLINE VOID FreeDnsCacheEntry(DnsCacheEntry* dnsent) {
    UINT index;
    for (index=0; index < dnsent->namecnt; index++) {
        FreeDnsName(dnsent->names[index]);
    }
    SysFree(dnsent);
}

INLINE VOID RemoveDnsCacheEntry(DnsCacheEntry* dnsent) {
    RemoveEntryList(&dnsent->links);
    DnsCacheSize--;

    ASSERT(dnsent->refcount != 0);
    if (dnsent->refcount > 1) {
        dnsent->refcount--;
        if (dnsent->status == NETERR_PENDING) {
            dnsent->status = NETERR_NETDOWN;
            SetKernelEvent(&dnsent->event);
        }
    } else {
        FreeDnsCacheEntry(dnsent);
    }
}

INLINE VOID DnsCacheEntryRelease(DnsCacheEntry* dnsent) {
    if (InterlockedDecrement(&dnsent->refcount) == 0) {
        FreeDnsCacheEntry(dnsent);
    }
}


//
// Remove an entry from the DNS server cache
//
INLINE VOID RemoveDnsServerCacheEntry(DnsServerCacheEntry* dnssrv) {
    RemoveEntryList(&dnssrv->links);
    SysFree(dnssrv);
    DnsServerCacheSize--;
}


VOID
DnsCleanup()

/*++

Routine Description:

    Clean up all DNS client data

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    // If DnsInitialize hasn't been called, do nothing
    if (IsListNull(&DnsServerCache)) return;

    DnsLock();

    // Clean up the default search suffixes
    DnsCleanupDefaultSuffixes();

    // Clean up the cached DNS servers
    while (!IsListEmpty(&DnsServerCache)) {
        DnsServerCacheEntry* dnssrv = DnsServerCacheFirst();
        RemoveDnsServerCacheEntry(dnssrv);
    }

    // Clean up the cached DNS lookup results
    while (!IsListEmpty(&DnsCache)) {
        DnsCacheEntry* dnsent = DnsCacheFirst();
        RemoveDnsCacheEntry(dnsent);
    }

    DnsUnlock();

    RtlDeleteCriticalSection(&DnsCritSect);
    DnsSetDefaultIfp = NULL;
}


DnsName*
CreateDnsNameFromString(
    const CHAR* str
    )

/*++

Routine Description:

    Create a DNS name structure from a character string

Arguments:

    str - Points to the domain name character string 

Return Value:

    Pointer to the new DNS name structure
    NULL if there is an error

--*/

{
    DnsName* dnsname;
    BYTE* data;
    BYTE* p;
    BYTE* q;
    UINT labels = 0;
    UINT len = strlen(str);

    // Validate length
    if (len == 0 || len >= DNS_MAXNAMELEN-1) return NULL;

    dnsname = (DnsName*) SysAlloc(len+4, PTAG_DNS);
    if (!dnsname) return NULL;

    data = GetDnsNameData(dnsname);
    p = data+1;
    CopyMem(p, str, len+1);

    // parse the '.' separated labels
    do {
        for (q=p; *q && *q != '.'; q++)
            NULL;
        
        // zero-length label is an error unless it's at the end
        // (in that case, the extra . is ignored).

        if (q == p) {
            if (*q == 0 && labels > 0) {
                *--q = 0;
                break;
            }
            SysFree(dnsname);
            return NULL;
        }

        if (q-p > DNS_MAXLABELLEN) {
            SysFree(dnsname);
            return NULL;
        }
        p[-1] = (BYTE) (q-p);
        labels++;
        p = q+1;
    } while (*q);

    SetDnsNameLen(dnsname, q-data+1);
    SetDnsNameLabels(dnsname, labels);
    return dnsname;
}


PRIVATE DnsName*
CreateDnsNameFromLabels(
    const BYTE* data
    )

/*++

Routine Description:

    Create a DNS name structure from a sequence of labels

Arguments:

    data - Points to the label data

Return Value:

    Pointer to the newly created DNS name
    NULL if there is an error

Note:

    We assume the label data is already validated.

--*/

{
    UINT len = 1;
    UINT labels = 0;
    const BYTE* p = data;
    DnsName* dnsname;

    while (*p) {
        labels++;
        len += 1 + *p;
        p = SkipDnsNameLabel(p);
    }
    
    dnsname = (DnsName*) SysAlloc(len+2, PTAG_DNS);
    if (dnsname) {
        SetDnsNameLen(dnsname, len);
        SetDnsNameLabels(dnsname, labels);
        CopyMem(GetDnsNameData(dnsname), data, len);
    }

    return dnsname;
}


PRIVATE DnsName*
CreateDnsNameFromAddr(
    IPADDR addr
    )

/*++

Routine Description:

    Create a DNS name from an IP address:
        x.x.x.x.IN-ADDR.ARPA

Arguments:

    addr - Specifies the IP address

Return Value:

    Pointer to the newly created DNS name
    NULL if there is an error

--*/

{
    CHAR buf[32];

    // Reverse the byte order
    addr = HTONL(addr);
    IpAddrToString(addr, buf, sizeof(buf));
    strcat(buf, ".IN-ADDR.ARPA");

    return CreateDnsNameFromString(buf);
}


PRIVATE UINT
MatchDnsNames(
    const DnsName* name1,
    const DnsName* name2
    )

/*++

Routine Description:

    Compare two DNS names and how closely they match

Arguments:

    name1, name2 - Specifies the two DNS names to be compared

Return Value:

    Number of labels that are common between the two DNS names

--*/

#define IsEqualDnsNameLabel(_p1, _p2) \
        (*(_p1) == *(_p2) && _strnicmp((_p1), (_p2), *(_p1)) == 0)

{
    UINT labels, l1, l2;
    const BYTE* data1;
    const BYTE* data2;

    l1 = GetDnsNameLabels(name1);
    l2 = GetDnsNameLabels(name2);
    labels = min(l1, l2);
    data1 = GetDnsNameData(name1);
    data2 = GetDnsNameData(name2);

    data1 = SkipDnsNameLabels(data1, l1-labels);
    data2 = SkipDnsNameLabels(data2, l2-labels);

    l1 = labels;
    while (labels--) {
        if (!IsEqualDnsNameLabel(data1, data2))
            l1 = labels;
        data1 = SkipDnsNameLabel(data1);
        data2 = SkipDnsNameLabel(data2);
    }

    return l1;
}


PRIVATE BOOL
IsEqualDnsNames(
    const DnsName* name1,
    const DnsName* name2
    )

/*++

Routine Description:

    Check if two DNS names are the same (case insensitive)

Arguments:

    name1, name2 - Specifies the two DNS names to be compared

Return Value:

    TRUE if two names are the same, FALSE otherwise

--*/

{
    BYTE labels = GetDnsNameLabels(name1);
    const BYTE* data1;
    const BYTE* data2;

    // must have the same number of labels
    if (labels != GetDnsNameLabels(name2)) return FALSE;

    data1 = GetDnsNameData(name1);
    data2 = GetDnsNameData(name2);
    while (labels--) {
        // every label must be equal
        if (!IsEqualDnsNameLabel(data1, data2))
            return FALSE;
        data1 = SkipDnsNameLabel(data1);
        data2 = SkipDnsNameLabel(data2);
    }
    return TRUE;
}


PRIVATE VOID
DnsNameToString(
    const DnsName* dnsname,
    CHAR* buf,
    UINT buflen
    )

/*++

Routine Description:

    Convert a DNS name string to a null-terminated ASCII string

Arguments:

    dnsname - Points to the DNS name structure
    buf - Points to the buffer for storing the ASCII string
    buflen - Size of the buffer

Return Value:

    NONE

--*/

{
    const BYTE* data = GetDnsNameData(dnsname);
    UINT len;

    // If the output buffer is not big enough,
    // just return an empty string.
    if (buflen < GetDnsNameLen(dnsname) ||
        GetDnsNameLen(dnsname) <= 1) {
        *buf = 0;
        return;
    }

    while ((len = *data++) != 0) {
        CopyMem(buf, data, len);
        data += len;
        buf += len;
        *buf++ = '.';
    }

    buf[-1] = 0;
}


INLINE CHAR* DNSNAMESTR(const DnsName* dnsname) {
    static CHAR buf[256];
    DnsNameToString(dnsname, buf, sizeof(buf));
    return buf;
}

DnsName*
ConcatDnsNames(
    const DnsName* name1,
    const DnsName* name2
    )

/*++

Routine Description:

    Concatenate two DNS names together to form a new name

Arguments:

    name1 - Specifies the name to put in the front
    name2 - Specifies the name to put at the end

Return Value:

    Points to the new concatenated name
    NULL if there is an error

--*/

{
    DnsName* dnsname;
    BYTE* data;
    UINT l1, l2, labels;

    l1 = GetDnsNameLen(name1);
    l2 = GetDnsNameLen(name2);
    labels = (UINT) GetDnsNameLabels(name1) +
             (UINT) GetDnsNameLabels(name2);

    // Make sure the resulting DNS is not too long
    if (l1+l2-1 > DNS_MAXNAMELEN)
        return NULL;

    dnsname = (DnsName*) SysAlloc(l1+l2+1, PTAG_DNS);
    if (dnsname) {
        data = GetDnsNameData(dnsname);
        CopyMem(data, GetDnsNameData(name1), l1);
        CopyMem(data+l1-1, GetDnsNameData(name2), l2);
        SetDnsNameLen(dnsname, l1+l2-1);
        SetDnsNameLabels(dnsname, labels);
    }

    return dnsname;
}


VOID
DnsNotifyDefaultServers(
    IfInfo* ifp
    )

/*++

Routine Description:

    This is called by the lower level modules to notify us
    that the default DNS server information has changed.

Arguments:

    ifp - Points to the interface in question

Return Value:

    NONE

Note:

    This function is called by the DHCP module
    (potentially at DISPATCH_LEVEL).

--*/

{
    // We don't immediately set the default servers.
    // Rather, we'll queue up a request which will be
    // executed upon the next lookup operation.
    //
    // If there is another pending request,
    // it'll be replaced by the new request.

    CACHE_IFP_REFERENCE(DnsSetDefaultIfp, ifp);
}


PRIVATE NTSTATUS
AddDnsServerCacheEntry(
    const DnsName* domain,
    IPADDR serverAddr,
    UINT expires,
    UINT priority
    )

/*++

Routine Description:

    Add an entry to the DNS server cache

Arguments:

    domain - Specifies the domain for which the server is responsible
    serverAddr - Specifies the server's IP address
    expires - When will this entry be no longer valid
    priority - The server precedence value (smaller is better)

Return Value:

    Status code

--*/

{
    DnsServerCacheEntry* newsrv;
    DnsServerCacheEntry* dnssrv;
    DnsServerCacheEntry* oldie;
    UINT len;

    TRACE_("Adding DNS server: %s %s %d",
           DNSNAMESTR(domain),
           IPADDRSTR(serverAddr),
           expires);

    if (!XnetIsValidUnicastAddr(serverAddr))
        return NETERR_PARAM;

    len = GetDnsNameLen(domain) + 2;
    newsrv = (DnsServerCacheEntry*) SysAlloc(sizeof(*newsrv) + len, PTAG_DNS);
    if (!newsrv) return NETERR_MEMORY;

    newsrv->serverAddr = serverAddr;
    newsrv->expires = expires;
    newsrv->priority = priority;
    newsrv->domain = (DnsName*) (newsrv+1);
    CopyMem(newsrv->domain, domain, len);

    DnsLock();
    expires = (UINT) -1;
    oldie = DnsServerCacheNull();
    LOOP_THRU_DNSSERVER_CACHE(dnssrv)

        // If the specified domain/server combination is
        // already in the cache, just return success.
        if ((dnssrv->serverAddr == serverAddr) &&
            IsEqualDnsNames(dnssrv->domain, domain)) {
            dnssrv->expires = max(newsrv->expires, dnssrv->expires);
            dnssrv->priority = min(newsrv->priority, dnssrv->priority);
            DnsUnlock();
            SysFree(newsrv);
            return NETERR_OK;
        }

        // Remember the entry that'll expire the earliest.
        if (dnssrv->expires < expires) {
            oldie = dnssrv;
            expires = dnssrv->expires;
        }

    END_DNSSERVER_CACHE_LOOP

    if (DnsServerCacheSize >= cfgMaxDnsServerCacheSize) {
        // If there are too many entries in the DNS server cache,
        // remove the one with the smallest TTL. If no such
        // entry exists, return error.

        if (oldie == DnsServerCacheNull()) {
            DnsUnlock();
            SysFree(newsrv);
            WARNING_("DNS server cache is full.");
            return NETERR_MEMORY;
        }

        RemoveDnsServerCacheEntry(oldie);
    }

    InsertHeadList(&DnsServerCache, &newsrv->links);
    DnsServerCacheSize++;
    DnsUnlock();

    return NETERR_OK;
}


PRIVATE VOID
DnsExecutePendingSetDefaultReq()

/*++

Routine Description:

    Execute pending request to set default DNS domain and servers

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    DnsName* domainName;
    CHAR namestr[DNS_MAXNAMELEN+1];
    IPADDR addrs[MAX_DEFAULT_DNSSERVERS];
    UINT index, addrcnt;
    IfInfo* ifp;
    NTSTATUS status;

    ifp = DnsSetDefaultIfp;
    DnsSetDefaultIfp = NULL;
    if (!ifp) return;

    addrcnt = MAX_DEFAULT_DNSSERVERS;
    status = IfGetDefaultDnsServers(ifp, namestr, ARRAYCOUNT(namestr), addrs, &addrcnt);
    if (!NT_SUCCESS(status)) return;

    // Cleanup the DNS cache first
    DnsCleanup();
    if (addrcnt == 0) return;

    domainName = namestr[0] ?
                    CreateDnsNameFromString(namestr) :
                    CopyDnsName(DnsRootDomainName);

    if (!domainName) return;

    DnsLock();
    DnsCleanupDefaultSuffixes();

    DnsDefaultSuffixCount = 1;
    DnsDefaultSuffixes[0] = domainName;
    TRACE_("Default DNS search suffix: %s", DNSNAMESTR(domainName));

    // If the domain name has 3 or more labels, we'll add
    // the parent domain to the default search suffix list as well
    if (GetDnsNameLabels(domainName) >= 3) {
        BYTE* data;
        DnsName* dnsname;

        data = GetDnsNameData(domainName);
        data = SkipDnsNameLabel(data);
        dnsname = CreateDnsNameFromLabels(data);
        if (dnsname) {
            DnsDefaultSuffixCount++;
            DnsDefaultSuffixes[1] = dnsname;
            TRACE_("Default DNS search suffix: %s", DNSNAMESTR(dnsname));
        }
    }

    // Add default DNS servers to the cache
    for (index=0; index < addrcnt; index++) {
        AddDnsServerCacheEntry(domainName, *addrs, (UINT) -1, index);
    }

    DnsUnlock();
}


PRIVATE DnsCacheEntry*
CreateDnsCacheEntry(
    DnsName* dnsname,
    IPADDR addr
    )

/*++

Routine Description:

    Create a new entry in the DNS cache

Arguments:

    dnsname - Points to the name for the new entry

Return Value:

    Pointer to the newly created DNS cache entry
    NULL if there is an error

--*/

{
    DnsCacheEntry* dnsent;

    // Create a new entry and inserted it into the list
    dnsent = (DnsCacheEntry*) SysAlloc0(sizeof(*dnsent), PTAG_DNS);
    if (!dnsent) return NULL;

    if (dnsname) {
        dnsname = CopyDnsName(dnsname);
        if (!dnsname) {
            SysFree(dnsent);
            return NULL;
        }

        dnsent->namecnt = 1;
        dnsent->names[0] = dnsname;
    } else {
        dnsent->addrcnt = 1;
        dnsent->addrs[0] = addr;
    }

    // Refcount is initialized to 2 here:
    //  1 for keeping it in the cache
    //  1 for the caller 
    dnsent->refcount = 2;
    dnsent->status = NETERR_PENDING;
    dnsent->type = (WORD) (dnsname ? RRTYPE_A : RRTYPE_PTR);
    KeInitializeEvent(&dnsent->event, NotificationEvent, FALSE);

    InsertHeadList(&DnsCache, &dnsent->links);
    DnsCacheSize++;
    return dnsent;
}


PRIVATE IPADDR
FindBestDnsServer(
    DnsName* qname
    )

/*++

Routine Description:

    Find the best DNS server to use for the specified query

Arguments:

    qname - Specifies the query name

Return Value:

    IP address of the DNS server to use
    0 if no server is found

--*/

{
    UINT match, bestMatch, priority;
    IPADDR serverAddr;
    DnsServerCacheEntry* dnssrv;
    DnsServerCacheEntry* found;

    found = NULL;
    priority = (UINT) -1;
    bestMatch = 0;
    DnsLock();

    LOOP_THRU_DNSSERVER_CACHE(dnssrv)
        
        // Get rid of expired cache entries
        if (dnssrv->expires <= TcpTickCount) {
            RemoveDnsServerCacheEntry(dnssrv);
            continue;
        }

        match = MatchDnsNames(qname, dnssrv->domain);
        if (match > bestMatch ||
            match == bestMatch && dnssrv->priority < priority) {
            found = dnssrv;
            priority = dnssrv->priority;
            bestMatch = match;
        }

    END_DNSSERVER_CACHE_LOOP

    if (found) {
        // Move the server to the end of the search list
        // so that another server with the same priority
        // will get taken for the next lookup.
        RemoveEntryList(&found->links);
        InsertTailList(&DnsServerCache, &found->links);
        serverAddr = found->serverAddr;
    } else
        serverAddr = 0;

    DnsUnlock();
    return serverAddr;
}


PRIVATE VOID
MarkBadDnsServer(
    IPADDR serverAddr
    )

/*++

Routine Description:

    This function is called when we timed out while waiting
    for a response from the specified DNS server.

Arguments:

    serverAddr - Specifies the DNS server's IP address

Return Value:

    NONE

--*/

{
    DnsServerCacheEntry* dnssrv;
    DnsServerCacheEntry* prev;

    DnsLock();

    // NOTE: We can't use the LOOP_THRU_DNSSERVER_CACHE macro here
    // because we must go through the list in reverse order

    dnssrv = (DnsServerCacheEntry*) DnsServerCache.Blink;
    while (dnssrv != DnsServerCacheNull()) {
        prev = (DnsServerCacheEntry*) dnssrv->links.Blink;

        // Lower the server's precedence and
        // also move it to the end of the search list.
        if (dnssrv->serverAddr == serverAddr) {
            dnssrv->priority++;
            if (dnssrv->priority == -1)
                dnssrv->priority = 0;

            RemoveEntryList(&dnssrv->links);
            InsertTailList(&DnsServerCache, &dnssrv->links);
        }
        dnssrv = prev;
    }

    DnsUnlock();
}


PRIVATE INT
ComposeDnsQuery(
    BYTE* buf,
    DnsName* qname,
    WORD qtype
    )

/*++

Routine Description:

    Compose a DNS query message

Arguments:

    buf - Points to the data buffer
    qname - Query name
    qtype - Query type: RRTYPE_A or RRTYPE_PTR

Return Value:

    The length of the composed DNS query message

Note:
    
    We assume the data buffer size is at least DNS_MAXMSGLEN bytes.

--*/

{
    DnsHeader* dnshdr = (DnsHeader*) buf;
    WORD code;
    BYTE* p;
    UINT len;

    DnsQueryMsgId++;
    dnshdr->id = HTONS(DnsQueryMsgId);
    dnshdr->questions = HTONS(1);
    dnshdr->answers = dnshdr->nservers = dnshdr->extras = HTONS(0);

    // We always request recursive mode. But if the server
    // doesn't support, we'll fall back to use iterative mode.
    code = DNSFLAG_QUERY | DNSFLAG_RD | DNSOPCODE_STDQUERY;
    dnshdr->code = HTONS(code);

    p = buf + DNSHDRLEN;
    len = GetDnsNameLen(qname);
    CopyMem(p, GetDnsNameData(qname), len);
    p += len;

    *((WORD*) p) = HTONS(qtype);
    p += 2;

    *((WORD*) p) = HTONS(RRCLASS_IN);
    p += 2;

    return (p - buf);
}


//
// Extract a 16-bit value from the received message.
// NOTE: we're assuming little-endian machines here.
//
#define DNS_EXTRACT_WORD(_p) ((WORD) \
        (((WORD) (_p)[0] << 8) | \
         ((WORD) (_p)[1]     )))

// Extract a 32-bit value from the received message.
#define DNS_EXTRACT_DWORD(_p) \
        (((DWORD) (_p)[0] << 24) | \
         ((DWORD) (_p)[1] << 16) | \
         ((DWORD) (_p)[2] <<  8) | \
         ((DWORD) (_p)[3]      ))


//
// Free information about a resource record section
//
PRIVATE VOID FreeDnsRRList(DnsRR* rrlist) {
    while (rrlist) {
        DnsRR* rr = rrlist;
        rrlist = rrlist->next;

        FreeDnsName(rr->rrname);
        if (rr->type != RRTYPE_A) {
            FreeDnsName(rr->dataname);
        }
        SysFree(rr);
    }
}

//
// Free the information we parsed out of a DNS response
// Note: The DnsResp structure itself is not freed. 
//
PRIVATE VOID FreeDnsResp(DnsResp* dnsresp) {
    FreeDnsRRList(dnsresp->answers);
    FreeDnsRRList(dnsresp->nservers);
    FreeDnsRRList(dnsresp->extras);
}


PRIVATE BYTE*
DnsParseName(
    DnsResp* dnsresp,
    BYTE* p,
    DnsName** result
    )

/*++

Routine Description:

    Parse a name field out of a DNS response message
    (handles message compression too)

Arguments:

    dnsresp - Points to the information about the DNS response message
    p - Where the name field starts
    result - Returns a pointer to the parsed DNS name
        or NULL if there is an error

Return Value:

    Points to the first byte after the DNS name
    NULL if there is an error

--*/

{
    UINT totallen = 0;
    UINT ptrcnt = 0;
    BYTE* end = dnsresp->end;
    BYTE* retval = NULL;
    BYTE* namebuf = dnsresp->namebuf;

    *result = NULL;
    while (TRUE) {
        UINT b1, b2;

        if (p == end) return NULL;
        b1 = *p++;

        // Stop if we see the last label
        if (b1 == 0) {
            if (retval == NULL) retval = p;
            namebuf[totallen++] = 0;
            break;
        }

        b2 = b1 >> 6;
        if (b2 == 0) {
            // Regular label
            if (totallen + b1 + 1 >= DNS_MAXNAMELEN) return NULL;
            namebuf[totallen++] = (BYTE) b1;
            CopyMem(namebuf+totallen, p, b1);
            p += b1;
            totallen += b1;
        } else {
            // Name compression
            //  we artificially limit the number of name pointers to 8
            //  to avoid infinite recursion.
            INT offset;

            if (b2 == 1 || b2 == 2 || p == end || ++ptrcnt > 8)
                return NULL;
            
            offset = ((b1 & 0x3f) << 8) | *p++;
            if (offset >= end - dnsresp->start) return NULL;

            if (retval == NULL) retval = p;
            p = dnsresp->start + offset;
        }
    }

    *result = CreateDnsNameFromLabels(namebuf);
    return *result ? retval : NULL;
}


PRIVATE BYTE*
DnsParseRRSection(
    DnsResp* dnsresp,
    BYTE* p,
    DnsRR** sect,
    WORD count
    )

/*++

Routine Description:

    Parse a resource record section of a DNS response message

Arguments:

    dnsresp - Points to the information about the DNS response message
    p - Where the resource record section starts
    sect - Returns parsed information about the RR section
    count - Number of RRs as specified in the DNS message header

Return Value:

    Points to the first byte after the RR section

--*/

{
    BYTE* end = dnsresp->end;
    DnsRR* rrlist;
    DnsRR* rr;
    DnsName* dnsname;

    ASSERT(*sect == NULL);
    rrlist = NULL;
    count = NTOHS(count);

    while (count-- && p < end) {
        WORD type, cls, rdlen;
        DWORD ttl;
        BYTE* rdata;

        // record name
        p = DnsParseName(dnsresp, p, &dnsname);
        if (!p) break;

        // record type and class, ttl, and data length
        if (end-p < 10) goto badrr2;
        type = DNS_EXTRACT_WORD(p); p += 2;
        cls = DNS_EXTRACT_WORD(p); p += 2;
        ttl = DNS_EXTRACT_DWORD(p); p += 4;
        rdlen = DNS_EXTRACT_WORD(p); p += 2;
        if (end-p < rdlen) goto badrr2;
        rdata = p;
        p += rdlen;

        if (cls != RRCLASS_IN ||
            type != RRTYPE_A &&
            type != RRTYPE_NS &&
            type != RRTYPE_CNAME &&
            type != RRTYPE_SOA &&
            type != RRTYPE_PTR) {
            FreeDnsName(dnsname);
            continue;
        }

        rr = (DnsRR*) SysAlloc(sizeof(DnsRR), PTAG_DNS);
        if (!rr) goto badrr2;
        
        // record data
        switch (rr->type = type) {
        case RRTYPE_A:
            if (rdlen < IPADDRLEN) goto badrr1;
            CopyMem(&rr->addr, rdata, IPADDRLEN);
            break;

        case RRTYPE_NS:
        case RRTYPE_CNAME:
        case RRTYPE_PTR:
            if (!DnsParseName(dnsresp, rdata, &rr->dataname))
                goto badrr1;
            break;

        case RRTYPE_SOA: {
            DnsName* mxadmin;

            rdata = DnsParseName(dnsresp, rdata, &rr->dataname);
            if (rdata == NULL) goto badrr1;

            rdata = DnsParseName(dnsresp, rdata, &mxadmin);
            if (rdata == NULL) goto badrr1;

            FreeDnsName(mxadmin);
            if (end-rdata < 20) goto badrr1;

            // The TTL field isn't meaningful for SOA records.
            // Instead, we use the MINIMUM field as the TTL value
            // for negative caching.
            rdata += 16;
            ttl = DNS_EXTRACT_DWORD(rdata);
            }
            break;
        }

        rr->rrname = dnsname;
        rr->next = rrlist;
        rr->ttl = min(ttl, cfgMaxDnsCacheTtl);
        rrlist = rr;
    }

exit:
    // Reverse the resource record list
    // NOTE: even in case of error, a partial resource record list
    // is still returned to the caller.

    rr = rrlist;
    rrlist = NULL;
    while (rr) {
        DnsRR* next = rr->next;
        rr->next = rrlist;
        rrlist = rr;
        rr = next;
    }

    *sect = rrlist;
    return p;

badrr1:
    SysFree(rr);
badrr2:
    FreeDnsName(dnsname);
    p = NULL;
    goto exit;
}


//
// Check if a name is already associated with a DNS cache entry
//
INLINE BOOL DnsEntHasName(DnsName** names, UINT namecnt, DnsName* dnsname) {
    while (namecnt--) {
        if (IsEqualDnsNames(*names, dnsname)) return TRUE;
        names++;
    }
    return FALSE;
}


//
// Check if an address is already associated with a DNS cache entry
//
INLINE BOOL DnsEntHasAddr(IPADDR* addrs, UINT addrcnt, IPADDR addr) {
    while (addrcnt--) {
        if (*addrs++ == addr) return TRUE;
    }
    return FALSE;
}


//
// Add a name to a DNS cache entry
//
PRIVATE BOOL DnsEntAddName(DnsCacheEntry* dnsent, DnsName* dnsname) {
    if (DnsEntHasName(dnsent->names, dnsent->namecnt, dnsname) ||
        dnsent->namecnt >= MAXALIASCNT)
        return FALSE;

    dnsent->names[dnsent->namecnt++] = dnsname;
    return TRUE;
}


//
// Process CNAME records in a DNS response message
//
PRIVATE VOID DnsProcessCNames(DnsCacheEntry* dnsent, DnsRR* rrlist) {
    DnsName* dnsname;
    DnsRR* rr;
    UINT high, index = 0;

    while (index < dnsent->namecnt) {
        dnsname = dnsent->names[index++];
        for (rr=rrlist; rr; rr=rr->next) {
            if (rr->type == RRTYPE_CNAME && IsEqualDnsNames(rr->rrname, dnsname)) {
                DnsEntAddName(dnsent, rr->dataname);
            }
        }
    }

    // Reverse the name list
    ASSERT(dnsent->namecnt);
    index = 0;
    high = dnsent->namecnt - 1;
    while (index < high) {
        dnsname = dnsent->names[index];
        dnsent->names[index++] = dnsent->names[high];
        dnsent->names[high--] = dnsname;
    }
}


//
// Find the first DNS resource record of the specified
// name/type combination in a RR section
//
INLINE DnsRR* DnsFindRR(DnsRR* rrlist, DnsName* name, WORD type) {
    while (rrlist) {
        if ((rrlist->type == type) && 
            (name == NULL || IsEqualDnsNames(name, rrlist->rrname)))
            break;
        rrlist = rrlist->next;
    }
    return rrlist;
}


PRIVATE VOID
DnsProcessPositiveResp(
    DnsCacheEntry* dnsent,
    DnsResp* dnsresp,
    DnsName* qname
    )

/*++

Routine Description:

    Process a positive answer from the DNS server

Arguments:

    dnsent - Points to the DNS cache entry corresponding to the DNS query
    dnsresp - Information about the DNS response message
    qname - Specifies the original DNS query name

Return Value:

    NONE

--*/

{
    DnsRR* rr = dnsresp->answers;
    UINT ttl = (UINT) -1;

    if (dnsent->type == RRTYPE_PTR) {
        // Process all PTR records first
        while (rr) {
            if (rr->type == RRTYPE_PTR && IsEqualDnsNames(rr->rrname, qname)) {
                if (DnsEntAddName(dnsent, rr->dataname)) {
                    rr->dataname = NULL;
                    ttl = min(ttl, rr->ttl);
                }
            }
            rr = rr->next;
        }

        // Then process all CNAME records
        DnsProcessCNames(dnsent, dnsresp->answers);
    } else {
        // Process all CNAME records first
        DnsProcessCNames(dnsent, rr);

        // Then process all A records
        while (rr) {
            if (rr->type == RRTYPE_A &&
                DnsEntHasName(dnsent->names, dnsent->namecnt, rr->rrname) &&
                !DnsEntHasAddr(dnsent->addrs, dnsent->addrcnt, rr->addr) &&
                dnsent->addrcnt < MAXALIASCNT) {
                dnsent->addrs[dnsent->addrcnt++] = rr->addr;
                ttl = min(ttl, rr->ttl);
            }
            rr = rr->next;
        }
    }

    dnsent->expires = DnsCacheExpires(ttl);
}


PRIVATE VOID
DnsProcessNegativeResp(
    DnsCacheEntry* dnsent,
    DnsResp* dnsresp
    )

/*++

Routine Description:

    Process negative response to a DNS query

Arguments:

    dnsent - Points to the DNS cache entry corresponding to the query
    dnsresp - Information about the DNS response message

Return Value:

    NONE

--*/

{
    DnsRR* rr;

    // If this was a name-to-address query,
    // process the CNAME records.
    if (dnsent->type == RRTYPE_A) {
        DnsProcessCNames(dnsent, dnsresp->answers);
    }

    // Figure out the negative cache TTL
    rr = DnsFindRR(dnsresp->nservers, NULL, RRTYPE_SOA);
    dnsent->expires = DnsCacheExpires(rr ? rr->ttl : 0);
}


PRIVATE NTSTATUS
DnsProcessNServers(
    DnsCacheEntry* dnsent,
    DnsResp* dnsresp,
    BOOL referral
    )

/*++

Routine Description:

    Process the name server information inside the nservers and extras
    sections of a DNS response message

Arguments:

    dnsent - Points to the DNS cache entry corresponding to a DNS query
    dnsresp - Information about the DNS response message
    referral - Whether the response is a referral

Return Value:

    Status code

--*/

{
    DnsRR* rrNS;
    DnsRR* rrA;
    IPADDR serverAddr;
    NTSTATUS status = NETERR_OK;

    for (rrNS = dnsresp->nservers; rrNS; rrNS = rrNS->next) {
        if (rrNS->type != RRTYPE_NS) continue;
        rrA = DnsFindRR(dnsresp->extras, rrNS->dataname, RRTYPE_A);

        if (rrA) {
            serverAddr = rrA->addr;
        } else {
            serverAddr = 0;

            if (referral) {
                DnsCacheEntry* found;
                status = DnsLookupProc(rrNS->dataname, 0, &found);
                if (NT_SUCCESS(status)) {
                    status = found->status;
                    serverAddr = found->addrs[0];
                    DnsCacheEntryRelease(found);

                    // If anther thread is actively resolving
                    // the address of our referred server,
                    // return WSATRY_AGAIN error rather than wait here
                    // to avoid potential deadlock.
                    if (status == NETERR_PENDING) {
                        status = NETERR(WSATRY_AGAIN);
                    }
                }
            }
        }

        if (serverAddr) {
            status = AddDnsServerCacheEntry(
                            rrNS->rrname,
                            serverAddr,
                            DnsCacheExpires(rrNS->ttl),
                            0);
        }

        // If this function was called because of a referral response,
        // we'll return after seeing the first NS records.
        if (referral) return status;
    }

    return referral ? NETERR_PARAM : NETERR_OK;
}


PRIVATE NTSTATUS
DnsProcessResponse(
    DnsCacheEntry* dnsent,
    DnsResp* dnsresp,
    DnsName* qname,
    DnsName** tempname
    )

/*++

Routine Description:

    Process a received DNS query response

Arguments:

    dnsent - Points to the DNS cache entry
    dnsresp - Points to the DNS response information
    qname - Specifies the name that's being queried
    tempname - Returns a pointer to the new query name
        if the response is a referral and
        the query type involved was RRTYPE_PTR

Return Value:

    Status code:
        NETERR_OK - the response was a positive answer to our query
        NETERR(WSAHOST_NOT_FOUND)
        NETERR(WSANO_DATA) - the response was a negative answer
        DNSRESP_REFERRAL - the response was a referral
        other error code - there was an error interpreting the response

--*/

#define DNSRESP_REFERRAL 1

{
    NTSTATUS status;
    DnsHeader* dnshdr;
    WORD code, type, cls;
    BYTE* p;
    DnsName* dnsname;

    // Validate header information
    // NOTE: We don't compare DNS message ID here.
    if (dnsresp->end - dnsresp->start < DNSHDRLEN)
        return NETERR_PARAM;

    dnshdr = (DnsHeader*) dnsresp->start;
    code = NTOHS(dnshdr->code);
    if (!(code & DNSFLAG_RESPONSE) ||
        DNSGETOPCODE(code) != DNSOPCODE_STDQUERY ||
        dnshdr->questions != HTONS(1)) {
        return NETERR_PARAM;
    }

    // Interpret the RCODE
    code = (WORD) DNSGETRCODE(code);
    switch (code) {
    case RCODE_OK:
    case RCODE_NAME_ERROR:
        // continue processing
        break;

    case RCODE_SERVER_FAILED:
        return NETERR(WSATRY_AGAIN);

    case RCODE_FORMAT_ERROR:
    default:
        return NETERR_PARAM;
    }

    // Parse the questions section

    p = dnsresp->start + DNSHDRLEN;
    p = DnsParseName(dnsresp, p, &dnsname);
    if (!dnsname || !IsEqualDnsNames(dnsname, qname)) {
        FreeDnsName(dnsname);
        return NETERR_PARAM;
    }
    FreeDnsName(dnsname);

    if (dnsresp->end - p < 4) return NETERR_PARAM;
    type = DNS_EXTRACT_WORD(p); p += 2;
    cls = DNS_EXTRACT_WORD(p); p += 2;
    if (type != dnsent->type || cls != RRCLASS_IN)
        return NETERR_PARAM;

    // Parse the resource record sections:
    //  We only require the answers section to be complete.
    //  Errors in the other two sections are ignored.
    p = DnsParseRRSection(dnsresp, p, &dnsresp->answers, dnshdr->answers);
    if (!p) return NETERR_PARAM;

    p = DnsParseRRSection(dnsresp, p, &dnsresp->nservers, dnshdr->nservers);
    if (p) {
        DnsParseRRSection(dnsresp, p, &dnsresp->extras, dnshdr->extras);
    }

    // Process the information in the answers section
    if (code == RCODE_OK) {
        if (DnsFindRR(dnsresp->answers, qname, dnsent->type)) {
            // Positive answer
            DnsProcessPositiveResp(dnsent, dnsresp, qname);
            status = NETERR_OK;
        } else {
            // We differentiate the "no data" case from the "referral" case
            // by the presence of SOA record or the absence of NS record
            // in the nservers section.
            if (DnsFindRR(dnsresp->nservers, NULL, RRTYPE_SOA) ||
                !DnsFindRR(dnsresp->nservers, NULL, RRTYPE_NS)) {
                TRACE_("No data for host: %s", DNSNAMESTR(qname));
                DnsProcessNegativeResp(dnsent, dnsresp);
                status = NETERR(WSANO_DATA);
            } else {
                TRACE_("Referral for host: %s", DNSNAMESTR(qname));
                if (dnsent->type == RRTYPE_A) {
                    DnsProcessCNames(dnsent, dnsresp->answers); 
                    TRACE_("  %s", DNSNAMESTR(dnsent->names[0]));
                } else {
                    DnsRR* rr = DnsFindRR(dnsresp->answers, qname, RRTYPE_CNAME);
                    if (rr) {
                        TRACE_("  %s", DNSNAMESTR(rr->dataname));
                        FreeDnsName(*tempname);
                        *tempname = rr->dataname;
                        rr->dataname = NULL;
                    }
                }
                status = DNSRESP_REFERRAL;
            }
        }
    } else {
        // Name error
        TRACE_("Host not found: %s", DNSNAMESTR(qname));
        DnsProcessNegativeResp(dnsent, dnsresp);
        status = NETERR(WSAHOST_NOT_FOUND);
    }

    // Process the information in the nservers and extras sections
    if (status == DNSRESP_REFERRAL) {
        NTSTATUS status1 = DnsProcessNServers(dnsent, dnsresp, TRUE);
        if (!NT_SUCCESS(status1)) status = status1;
    } else {
        DnsProcessNServers(dnsent, dnsresp, FALSE);
    }

    return status;
}


PRIVATE NTSTATUS
ResolveDnsCacheEntry(
    DnsCacheEntry* dnsent
    )

/*++

Routine Description:

    Resolve a DNS cache entry

Arguments:

    dnsent - Points to the DNS cache entry to be resolved

Return Value:

    Status code

--*/

{
    SOCKET s = INVALID_SOCKET;
    struct sockaddr_in sockname;
    INT fromlen, datalen;
    NTSTATUS status;
    UINT retries, timeout;
    CHAR* databuf;
    DnsName* qname;
    DnsName* tempname = NULL;
    IPADDR serverAddr;
    UINT cnames = 0;
    DnsResp* dnsresp;

    ASSERT(dnsent->status == NETERR_PENDING);
    dnsent->expires = (UINT) -1;

    // allocate temporary buffer for send and receive
    // create a UDP socket and bind it
    databuf = (BYTE*) SysAlloc(DNS_MAXMSGLEN, PTAG_DNS);
    dnsresp = (DnsResp*) SysAlloc(sizeof(DnsResp), PTAG_DNS);
    if (!databuf || !dnsresp) {
        status = NETERR_MEMORY; goto exit;
    }

    s = socket(AF_INET, SOCK_DGRAM, 0);
    if (s == INVALID_SOCKET) goto errexit;

    ZeroMem(&sockname, sizeof(sockname));
    sockname.sin_family = AF_INET;
    sockname.sin_port = 0;
    sockname.sin_addr.s_addr = INADDR_ANY;

    status = bind(s, (struct sockaddr*) &sockname, sizeof(sockname));
    if (status != NO_ERROR) goto errexit;

    // Generate IN-ADDR.ARPA query name if we're
    // doing an address-to-name lookup
    if (dnsent->type == RRTYPE_PTR) {
        tempname = CreateDnsNameFromAddr(dnsent->addrs[0]);
        if (!tempname) {
            status = NETERR_MEMORY; goto exit;
        }
    }

newlookup:
    // Give up if there are too many levels of CNAMEs
    if (cnames++ >= MAXALIASCNT) {
        status = NETERR(WSAHOST_NOT_FOUND);
        goto exit;
    }

    timeout = cfgMinLookupTimeout * 1000;
    retries = cfgMaxLookupRetries;
    while (TRUE) {
        if (retries-- == 0) {
            status = NETERR(WSATRY_AGAIN);
            break;
        }

        // Look for an appropriate DNS server
        qname = (dnsent->type == RRTYPE_A) ? dnsent->names[0] : tempname;
        TRACE_("Query DNS name: %s", DNSNAMESTR(qname));

        serverAddr = FindBestDnsServer(qname);
        if (serverAddr == 0) {
            status = NETERR(WSAENETDOWN);
            break;
        }
        // Send out a message
        datalen = ComposeDnsQuery(databuf, qname, dnsent->type);

        sockname.sin_port = HTONS(DNS_SERVER_PORT);
        sockname.sin_addr.s_addr = serverAddr;
        TRACE_("  DNS server: %s", inet_ntoa(sockname.sin_addr));

        fromlen = sizeof(sockname);
        datalen = sendto(s, databuf, datalen, 0, (struct sockaddr*) &sockname, fromlen);
        if (datalen == SOCKET_ERROR) continue;

        // wait for reply
        status = setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, (CHAR*) &timeout, sizeof(timeout));
        if (status != NO_ERROR) goto errexit;
        timeout += timeout;

        datalen = recvfrom(s, databuf, DNS_MAXMSGLEN, 0, (struct sockaddr*) &sockname, &fromlen);
        if (datalen == SOCKET_ERROR) {
            if (WSAGetLastError() != WSAETIMEDOUT) goto errexit;
            MarkBadDnsServer(serverAddr);
            continue;
        }
        TRACE_("Response recieved from server: %s", inet_ntoa(sockname.sin_addr));

        // Process the received message
        dnsresp->start = databuf;
        dnsresp->end = databuf + datalen;
        dnsresp->answers = dnsresp->nservers = dnsresp->extras = NULL;
        status = DnsProcessResponse(dnsent, dnsresp, qname, &tempname);
        FreeDnsResp(dnsresp);

        switch (status) {
        case DNSRESP_REFERRAL:
            // Iterative lookup
            goto newlookup;
        
        case NETERR_OK:
        case NETERR(WSAHOST_NOT_FOUND):
        case NETERR(WSANO_DATA):
            // stop searching and return appropriate error code
            goto exit;

        default:
            // continue on with the next server
            VERBOSE_("Error processing response: 0x%x", status);
            break;
        }
    }

exit:
    if (s != INVALID_SOCKET) {
        closesocket(s);
    }
    SysFree(databuf);
    SysFree(dnsresp);
    FreeDnsName(tempname);

    // In case of temporary server error,
    // cache the negative response for a few seconds
    if (dnsent->expires == -1) {
        dnsent->expires = DnsCacheExpires(cfgMinLookupTimeout);
    }
    dnsent->status = status;
    SetKernelEvent(&dnsent->event);
    return status;

errexit:
    status = WSAGetLastError();
    status = (status == NO_ERROR) ? NETERR_SYSCALL : NETERR(status);
    goto exit;
}


PRIVATE NTSTATUS
DnsLookupProc(
    DnsName* dnsname,
    IPADDR addr,
    DnsCacheEntry** result
    )

/*++

Routine Description:

    DNS lookup function - called to:
    - resolve a host name to IP addresses,
    - resolve an IP address to host names

Arguments:

    dnsname - Specifies the host name (NULL if doing lookup by address)
    addr - Specifies the IP address
    result - Return the result of the lookup

Return Value:

    Status code

--*/

{
    DnsCacheEntry* dnsent;
    DnsCacheEntry* found;
    DnsCacheEntry* oldie;
    UINT expires;

    *result = NULL;
    found = NULL;
    expires = (UINT) -1;
    oldie = DnsCacheNull();

    DnsLock();
    LOOP_THRU_DNS_CACHE(dnsent)
        
        // If we have an entry that's already expired,
        // remove it from the list now.
        if (dnsent->expires <= TcpTickCount) {
            RemoveDnsCacheEntry(dnsent);
            continue;
        }

        // Check if the specified name or address matches
        // the names or addresses associated with this DNS cache entry
        if (dnsname && DnsEntHasName(dnsent->names, dnsent->namecnt, dnsname) ||
            !dnsname && DnsEntHasAddr(dnsent->addrs, dnsent->addrcnt, addr)) {
            dnsent->refcount++;
            found = dnsent;
            break;
        }

        // Remember the entry that has the earliest
        // expiration time.

        if (dnsent->expires < expires) {
            oldie = dnsent;
            expires = dnsent->expires;
        }

    END_DNS_CACHE_LOOP

    if (!found) {
        // If the name is not already in the cache,
        // we'll create a new DNS cache entry.

        if (DnsCacheSize >= cfgMaxDnsCacheSize) {
            if (oldie == DnsCacheNull()) {
                DnsUnlock();
                WARNING_("DNS cache is full.");
                return NETERR_MEMORY;
            }
            RemoveDnsCacheEntry(oldie);
        }

        found = CreateDnsCacheEntry(dnsname, addr);
        DnsUnlock();
        if (!found) return NETERR_MEMORY;

        // Resolve the new entry now
        ResolveDnsCacheEntry(found);
    } else {
        DnsUnlock();
    }

    *result = found;
    return NETERR_OK;
}


PRIVATE NTSTATUS
ReturnDnsEntryInfo(
    DnsCacheEntry* dnsent,
    DnsLookupCallback callback,
    VOID* param
    )

/*++

Routine Description:

    Return information for a DNS lookup

Arguments:

    dnsent - Points to the cached DNS entry
    callback - Callback function for allocating output buffers
    param - Parameter passed to the callback function

Return Value:

    Status code

--*/

{
    UINT size;
    BYTE index, namecnt, addrcnt, namelen;
    struct hostent* hostentbuf;
    BYTE *p;

    // Check if some other thread is actively resolving this entry.
    // If so, we'll just wait until the other thread complete its work.
    if (dnsent->status == NETERR_PENDING) {
        WaitKernelEventObject(&dnsent->event, 0);
    }

    // If the result was unsuccessful, return error
    if (!NT_SUCCESS(dnsent->status))
        return dnsent->status;

    namecnt = dnsent->namecnt;
    addrcnt = dnsent->addrcnt;
    ASSERT(namecnt && addrcnt);

    // Figure out the total buffer size we need to
    // output the information in the DNS entry
    size = sizeof(struct hostent) +
           sizeof(CHAR*) * namecnt +
           sizeof(CHAR*) * (addrcnt + 1) +
           sizeof(struct in_addr) * addrcnt;

    for (index=0; index < namecnt; index++) {
        size += GetDnsNameLen(dnsent->names[index]);
    }

    // Allocate memory buffer
    hostentbuf = callback(size, param);
    if (!hostentbuf) return NETERR_MEMORY;

    hostentbuf->h_addrtype = AF_INET;
    hostentbuf->h_length = IPADDRLEN;

    // 1. null-terminated array of alias name pointers
    // comes after the hostent structure itself

    p = (BYTE*) (hostentbuf+1);
    hostentbuf->h_aliases = (CHAR**) p;
    p += sizeof(CHAR*) * namecnt;

    // 2. then comes the null-terminate array of pointers to
    // the list of addresses.

    hostentbuf->h_addr_list = (CHAR**) p;
    p += sizeof(CHAR*) * (addrcnt + 1);

    // 3. then comes the array of addresses themselves

    for (index=0; index < addrcnt; index++) {
        hostentbuf->h_addr_list[index] = (CHAR*) p;
        ((struct in_addr*) p)->s_addr = dnsent->addrs[index];
        p += sizeof(struct in_addr);
    }
    hostentbuf->h_addr_list[addrcnt] = NULL;

    // 4. then comes the primary DNS name

    hostentbuf->h_name = (CHAR*) p;
    namelen = GetDnsNameLen(dnsent->names[0]);
    DnsNameToString(dnsent->names[0], p, namelen);
    p += namelen;

    // 5. and finally the list of name aliases

    for (index=1; index < namecnt; index++) {
        hostentbuf->h_aliases[index-1] = (CHAR*) p;
        namelen = GetDnsNameLen(dnsent->names[index]);
        DnsNameToString(dnsent->names[index], p, namelen);
        p += namelen;
    }
    hostentbuf->h_aliases[namecnt-1] = NULL;

    return NETERR_OK;
}


NTSTATUS
DnsLookupByName(
    const CHAR* name,
    DnsLookupCallback callback,
    VOID* param
    )

/*++

Routine Description:

    Map a hostname to its corresponding IP addresses

Arguments:

    name - Specifies the host name to be looked up
    callback - Callback function for allocating output buffers
    param - Parameter passed to the callback function

Return Value:

    Status code

--*/

{
    DnsCacheEntry* found;
    DnsName* dnsname;
    DnsName* names[MAX_DEFAULT_SUFFIXES+1];
    UINT index, namecnt;
    NTSTATUS status = NETERR_OK;

    // If there is a pending request to set default
    // DNS domain and servers, execute it now.
    if (DnsSetDefaultIfp) {
        DnsExecutePendingSetDefaultReq();
    }

    dnsname = CreateDnsNameFromString(name);
    if (!dnsname) return NETERR_MEMORY;

    // Compose a list of names to search for
    // by appending the default search suffixes.

    namecnt = 0;
    DnsLock();

    // If the specified name has more than 1 labels,
    // then search it first.
    if (GetDnsNameLabels(dnsname) > 1)
        names[namecnt++] = dnsname;

    // If the specified name ends in '.'
    // then we don't try the default search suffixes
    if (name[strlen(name)-1] != '.') {
        for (index=0; index < DnsDefaultSuffixCount; index++) {
            names[namecnt] = ConcatDnsNames(dnsname, DnsDefaultSuffixes[index]);
            if (names[namecnt]) 
                namecnt++;
        }
    }
    
    // If the specified name has just 1 label, then
    // search it last.
    if (GetDnsNameLabels(dnsname) <= 1)
        names[namecnt++] = dnsname;

    DnsUnlock();

    // Try all the name combinations and stop until one succeeds
    for (index=0; index < namecnt; index++) {
        NTSTATUS statusTemp;

        statusTemp = DnsLookupProc(names[index], 0, &found);
        if (NT_SUCCESS(statusTemp)) {
            statusTemp = ReturnDnsEntryInfo(found, callback, param);
            DnsCacheEntryRelease(found);

            if (NT_SUCCESS(statusTemp)) {
                status = statusTemp;
                break;
            }
        }

        // Remember the error code if this was the original name
        if (names[index] == dnsname)
            status = statusTemp;
    }

    for (index=0; index < namecnt; index++) {
        FreeDnsName(names[index]);
    }
    return status;
}


NTSTATUS
DnsLookupByAddr(
    IPADDR addr,
    DnsLookupCallback callback,
    VOID* param
    )

/*++

Routine Description:

    Map an IP address to its corresponding hostnames

Arguments:

    addr - Specifies the IP address to be looked up
    callback - Callback function for allocating output buffers
    param - Parameter passed to the callback function

Return Value:

    Status code

--*/

{
    DnsCacheEntry* found;
    NTSTATUS status;

    // If there is a pending request to set default
    // DNS domain and servers, execute it now.
    if (DnsSetDefaultIfp) {
        DnsExecutePendingSetDefaultReq();
    }

    status = DnsLookupProc(NULL, addr, &found);
    if (NT_SUCCESS(status)) {
        status = ReturnDnsEntryInfo(found, callback, param);
        DnsCacheEntryRelease(found);
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\dhcp\dhcplib.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dhcplib.h

Abstract:

    DHCP client implementation for XBox

Revision History:

    04/21/2000 davidx
        Created it.

--*/

#ifndef _DHCPLIB_H
#define _DHCPLIB_H

//
// Information we extract from DHCP options
//
typedef struct _DhcpOptionParam {
    INT recvMsgType;        // type message received
    IPADDR dhcpmask;        // subnet mask
    IPADDR dhcpServer;      // dhcp server address
    DHCPTIME t1time;        // when to enter renewing state
    DHCPTIME t2time;        // when to enter rebinding state
    DHCPTIME exptime;       // lease expiration time
    UINT gatewayCount;      // number of gateways
    IPADDR gateways[MAX_DEFAULT_GATEWAYS];
    UINT dnsServerCount;    // number of DNS servers
    IPADDR dnsServers[MAX_DEFAULT_DNSSERVERS];
    CHAR domainName[256];   // domain name
} DhcpOptionParam;


//
// Information we maintain for each interface
//
typedef struct _DhcpInfo {
    IfInfo* ifp;            // Pointer back to the interface
    KEVENT addrEvent;       // address acquisition event
    INT state;              // current state of the interface
    INT flags;              // misc. flags (see constants below)
    IPADDR activeaddr;      // active IP address and mask
    IPADDR activemask;      //
    IPADDR dhcpaddr;        // last DHCP address
    IPADDR autonetaddr;     // last autonet address
    DHCPTIME acqtime;       // when lease acquisition started
    DWORD xid;              // XID for the next outgoing message
    UINT retries;           // number of retries for the current message
    UINT initRetryCount;    // how many retries into INIT state
    UINT secsSinceStart;    // secs since the address-req process started
    UINT timer;             // timer (unit = second)
    union {                 // DHCP option paramters
        // We're using this odd-looking syntax construct so that
        // we can reference the fields in DhcpOptionParam directly.
        DhcpOptionParam;
        DhcpOptionParam optionParam;
    };
} DhcpInfo;


//
// States for an interface
//
enum {
    STATE_NONE,             // temporary wait state after startup
    STATE_STATIC_ADDR,      // statically assigned address
    STATE_INIT,             // sending discover
    STATE_REQUESTING,       // waiting for DHCPACK after selecting
    STATE_INIT_REBOOT,      // rebooting with valid lease
    STATE_BOUND,            // bound with valid address lease
    STATE_RENEWING,         // renewing after T1 expires
    STATE_REBINDING,        // rebinding after T2 expires
    STATE_DECLINING,        // temporary wait state after sending decline
    STATE_SELECT_AUTOADDR   // checking autonet address conflicts
};

//
// Constants for the DhcpInfo.flags field:
//
#define FLAG_RELEASE_ON_REBOOT  0x0001
#define FLAG_SEND_DHCPINFORM    0x0002
#define FLAG_CREATED_BY_DEBUGGER 0x0004

#define FLAG_ACTIVE_DHCPADDR    0x00010000
#define FLAG_ACTIVE_AUTONETADDR 0x00020000
#define FLAG_ACTIVE_ADDRMASK    (FLAG_ACTIVE_DHCPADDR | FLAG_ACTIVE_AUTONETADDR)

INLINE BOOL ActiveDhcpAddr(DhcpInfo* dhcp) {
    return (dhcp->flags & FLAG_ACTIVE_DHCPADDR);
}

INLINE BOOL ActiveAutonetAddr(DhcpInfo* dhcp) {
    return (dhcp->flags & FLAG_ACTIVE_AUTONETADDR);
}

//
// Dump DHCP message in the debugger
//

#if DBG
VOID DhcpDumpMessage(const DhcpMessage* msg, UINT msglen);
#else
#define DhcpDumpMessage(msg, msglen)
#endif

//
// Map interface hardware type to DHCP hardware type
//
INLINE BYTE DhcpMapHwtype(WORD iftype) {
    return (BYTE) ((iftype == IFTYPE_ETHERNET) ?
                    HWTYPE_10MB_ETHERNET :
                    HWTYPE_PPP);
}

//
// Check whether there is a conflict with an IP address
//
INLINE VOID DhcpCheckAddressConflict(IfInfo* ifp, IPADDR ipaddr) {
    ifp->Ioctl(ifp, IFCTL_CHECK_ADDR_CONFLICT, &ipaddr, sizeof(ipaddr), NULL, NULL);
}

//
// Signal address acquisition event
//
INLINE VOID DhcpSignalAddrEvent(DhcpInfo* dhcp) {
    KeSetEvent(&dhcp->addrEvent, IO_NO_INCREMENT, FALSE);
}

#endif // !_DHCPLIB_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\enet\dbgmon.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dbgmon.h

Abstract:

    Macros to hide the difference between normal build
    and the special build for the debug monitor

Revision History:

    07/21/2000 davidx
        Created it.

Note:

    This header file must not be included into multiple C files!

--*/

#ifndef _DBGMON_H
#define _DBGMON_H

// IP packet reception function
typedef VOID (*IPRECEIVEPROC)(Packet*);
typedef VOID (*FREEPKTPROC)(Packet*);
typedef VOID* (*UNCACHEDALLOCPROC)(SIZE_T, ULONG);
typedef VOID (*UNCACHEDFREEPROC)(VOID*);

typedef struct _ENETINITPARAMS {
    IN IPRECEIVEPROC IpReceiveProc;
    IN FREEPKTPROC FreePktProc;
    OUT UNCACHEDALLOCPROC UncachedAllocProc;
    OUT UNCACHEDFREEPROC UncachedFreeProc;
} ENETINITPARAMS;

// Enet initialization function provided by the debug monitor
typedef IfEnet* (*DBGMON_ENETINITPROC)(ENETINITPARAMS*);

#ifndef BUILD_FOR_DEBUGGER

// Pass the received frame up to the IP layer
#define IPRECEIVEPACKET IpReceivePacket

// Dispose of a packet after transmission
#define COMPLETEPACKET XnetCompletePacket

// Check to see if we should delete the enet interface
#define IFENET_DELETE_CHECK(ifp) \
        ASSERT((ifp)->refcount == 1); \
        (ifp)->refcount--

// Set the enet interface information in the process control block
#define SET_DBGMON_ENETINFO(ifp)

//
// Function called by the debug monitor enet driver to
// dispose of packets that the regular stack has passed down
//
INLINE VOID FreePacketCallback(Packet* pkt) {
    XnetFreePacket(pkt);
}

//
// Check if the debug monitor has already initialized the enet interface
//
#define CHECK_DBGMON_ENETINFO() { \
            DBGMON_ENETINITPROC enetInitProc; \
            enetInitProc = (DBGMON_ENETINITPROC) KeGetCurrentPrcb()->DmEnetFunc; \
            if (enetInitProc) { \
                ENETINITPARAMS initParams = { IpReceivePacket, FreePacketCallback, }; \
                ifp = enetInitProc(&initParams); \
                *newifp = (IfInfo*) ifp; \
                XnetUncachedAllocProc = initParams.UncachedAllocProc; \
                XnetUncachedFreeProc = initParams.UncachedFreeProc; \
                IfSetIpAddr(*newifp, ifp->ipaddr, ifp->addrmask); \
                DhcpSetDefaultGateways(*newifp); \
                return NETERR_OK; \
            } \
        }

#else // BUILD_FOR_DEBUGGER

#include "dm.h"
#include "xbdm.h"

// Pass the received frame up to the IP layer
VOID IPRECEIVEPACKET(Packet* pkt);

// Dispose of a packet after transmission
VOID COMPLETEPACKET(Packet* pkt, NTSTATUS status);

// Check to see if we should delete the enet interface
VOID IFENET_DELETE_CHECK(IfEnet* ifp);

// Set the enet interface information in the process control block
VOID SET_DBGMON_ENETINFO(IfEnet* ifp);

// Check if the debug monitor has already initialized the enet interface
#define CHECK_DBGMON_ENETINFO()

#endif // BUILD_FOR_DEBUGGER

#endif // !_DBGMON_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\enet\arp.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    arp.c

Abstract:

    Handles the ARP protocol

Revision History:

    05/04/2000 davidx
        Created it.

--*/

#include "precomp.h"

//
// Global ARP configuration info:
//  ARP cache entry timeout value (in seconds)
//  # of ARP cache entries per-interface
//  # of retries for ARP requests
//
UINT cfgPositiveArpCacheTimeout = POSITIVE_ARP_CACHE_TIMEOUT;
UINT cfgNegativeArpCacheTimeout = NEGATIVE_ARP_CACHE_TIMEOUT;
UINT cfgArpRequestRetries = ARP_REQUEST_RETRIES;


NTSTATUS
ArpSendPacket(
    IfEnet* ifp,
    WORD op,
    IPADDR tpa,
    IPADDR spa,
    const BYTE* tha
    )

/*++

Routine Description:

    Send out an ARP packet

Arguments:

    ifp - Points to the interface structure
    op - opcode: ARP_REQUEST or ARP_REPLY
    tpa - Specifies the target IP address
    spa - Specifies the source IP address
    tha - Sppecifies the target hardware address
        NULL when opcode is ARP_REQUEST

Return Value:

    Status code

--*/

{
    Packet* pkt;
    EnetFrameHeader* enethdr;
    ArpPacket* arppkt;
    UINT size = ENETHDRLEN + ARPPKTLEN;

    // Allocate memory for the packet
    pkt = XnetAllocPacket(size, PKTFLAG_NETPOOL);
    if (!pkt) return NETERR_MEMORY;
    pkt->datalen = size;

    // Fill out Ethernet header
    //  assume pkt->data is DWORD-aligned initially
    enethdr = GETPKTDATA(pkt, EnetFrameHeader);
    CopyMem(enethdr->dstaddr, tha ? tha : EnetBroadcastAddr, ENETADDRLEN);
    CopyMem(enethdr->srcaddr, ifp->hwaddr, ENETADDRLEN);
    enethdr->etherType = HTONS(ENETTYPE_ARP);
    
    // Fill out the ARP request packet
    arppkt = (ArpPacket*) (enethdr+1);
    arppkt->hrd = HTONS(ARP_HWTYPE_ENET);
    arppkt->pro = HTONS(ENETTYPE_IP);
    arppkt->hln = ENETADDRLEN;
    arppkt->pln = IPADDRLEN;
    arppkt->op = HTONS(op);
    CopyMem(arppkt->sha, ifp->hwaddr, ENETADDRLEN);
    arppkt->spa = spa;
    arppkt->tpa = tpa;
    if (tha) {
        CopyMem(arppkt->tha, tha, ENETADDRLEN);
    } else {
        ZeroMem(arppkt->tha, ENETADDRLEN);
    }

    NicTransmitFrame(ifp, pkt);
    return NETERR_OK;
}


ArpCacheEntry*
ArpFindCacheEntry(
    IfEnet* ifp,
    IPADDR ipaddr,
    INT resolve
    )

/*++

Routine Description:

    Resolve the specified target IP address to an ARP cache entry.
    If no existing entry is found, then:
    - if resolve is RESOLVE_NONE, we'll simple return NULL;
    - if resolve is RESOLVE_CREATE_ENTRY, we'll try to make a new entry
      for the specified address and return it to the caller;
    - if resolve is RESOLVE_SEND_REQUEST, we'll create the entry
      as well as send out a ARP request packet.

Arguments:

    ifp - Points to the interface structure
    ipaddr - Specifies the target address
    resolve - What to do if no existing entry is found

Return Value:

    ARP cache entry for the specified IP address
    NULL if there is an error

--*/

// Not a terribly fancy hash function
// but it should serve our purpose.
#define ARPHASH(_addr) ((_addr) % ARP_HASH_MODULO)

{
    ArpCacheEntry* arpEntry;
    ArpCacheEntry* retryEnd;
    ArpCacheEntry* hashEntry;
    UINT hash;

    RUNS_AT_DISPATCH_LEVEL
    ASSERT(XnetIsValidUnicastAddr(ipaddr));

    // Fast check
    if (ipaddr == ifp->lastArpAddr)
        return ifp->lastArpEntry;

    // Get the hash bucket for the specified address
    hash = ARPHASH(ipaddr);
    arpEntry = &ifp->arpCache[hash];

    // Found the target address in the cache via a direct hash hit
    if (arpEntry->ipaddr == ipaddr) {
found:
        ifp->lastArpAddr = ipaddr;
        return (ifp->lastArpEntry = arpEntry);
    }

    // No direct hash hit, try linear search
    hashEntry = arpEntry;
    retryEnd = arpEntry + ARP_HASH_RETRY;
    while (++arpEntry < retryEnd) {
        if (arpEntry->ipaddr == ipaddr) goto found;
    }

    if (resolve == RESOLVE_NONE)
        return NULL;

    //
    // The target IP address is not in the cache:
    //  send out an ARP request if specified;
    //  and make a new cache entry for the target
    //
    
    // Check to see if the hack bucket is free
    arpEntry = hashEntry;
    if (!IsArpEntryFree(arpEntry)) {
        while (++arpEntry < retryEnd) {
            if (IsArpEntryFree(arpEntry)) break;
        }
        
        // Couldn't find a free entry
        //  fall back and try to find a non-busy entry
        if (arpEntry == retryEnd) {
            arpEntry = hashEntry;
            while (++arpEntry < retryEnd) {
                if (!IsArpEntryBusy(arpEntry)) break;
            }

            if (arpEntry == retryEnd) {
                // Too bad: couldn't find either a free or non-busy entry
                //  emit a warning and give up
                WARNING_("ARP cache collision error");
                return NULL;
            }

            // This entry is currently used for another address:
            // we'll just bump it off here.
            VERBOSE_("Bumped ARP entry for %s", IPADDRSTR(arpEntry->ipaddr));
            ifp->arpCacheCount--;
        }
    }

    TRACE_("Add ARP entry for %s", IPADDRSTR(ipaddr));
    arpEntry->ipaddr = ipaddr;
    ASSERT(PktQIsEmpty(&arpEntry->waitq));

    if (resolve == RESOLVE_SEND_REQUEST) {
        arpEntry->state = ARPST_BUSY;
        arpEntry->timer = cfgArpRequestRetries;
        ArpSendRequest(ifp, ipaddr, ifp->ipaddr);
    } else {
        // NOTE: we mark the entry free here
        // It'll be immediately marked as OK in ArpReceivePacket
        // after this function returns.
        arpEntry->state = ARPST_FREE;
    }

    ifp->arpCacheCount++;
    goto found;
}


VOID
ArpTimerProc(
    IfEnet* ifp
    )

/*++

Routine Description:

    ARP timer routine

Arguments:

    ifp - Points to the interface structure

Return Value:

    NONE

--*/

{
    ArpCacheEntry* arpEntry;
    INT index;

    // Quick check: do nothing if all entries are free
    if (ifp->arpCacheCount == 0) return;
    ASSERT(ifp->arpCacheCount > 0);

    // Loop through all cache entries
    for (index=0; index < ARP_CACHE_SIZE; index++) {
        arpEntry = &ifp->arpCache[index];
        if (arpEntry->state == ARPST_FREE) continue;

        switch (arpEntry->state) {
        case ARPST_BUSY:
            //
            // The entry is currently being resolved
            //
            if (--arpEntry->timer == 0) {
                //
                // And the entry has expired:
                //  mark the entry as bad and complete any waiting packet
                //  with error status
                //
                arpEntry->state = ARPST_BAD;
                arpEntry->timer = cfgNegativeArpCacheTimeout;

                while (!PktQIsEmpty(&arpEntry->waitq)) {
                    Packet* pkt = PktQRemoveHead(&arpEntry->waitq);
                    COMPLETEPACKET(pkt, NETERR_UNREACHABLE);
                }
            } else {
                //
                // Timeout while waiting for ARP reply:
                //  retransmit the ARP request frame
                //
                ArpSendRequest(ifp, arpEntry->ipaddr, ifp->ipaddr);
            }
            break;
        
        case ARPST_OK:
        case ARPST_BAD:
            if (--arpEntry->timer == 0) {
                //
                // If the entry has expired, remove it from the cache
                //
                TRACE_("ARP entry for %s timed out", IPADDRSTR(arpEntry->ipaddr));

                // Reset the last ARP lookup info if applicable.
                if (arpEntry == ifp->lastArpEntry) {
                    ifp->lastArpAddr = 0;
                    ifp->lastArpEntry = NULL;
                }

                ZeroMem(arpEntry, sizeof(*arpEntry));
                ifp->arpCacheCount--;
            }
            break;
        }
    }
}


VOID
ArpReceivePacket(
    IfEnet* ifp,
    Packet* pkt
    )

/*++

Routine Description:

    Process an incoming ARP packet

Arguments:

    ifp - Points to the interface structure
    pkt - The received ARP packet

Return Value:

    NONE

--*/

{
    ArpPacket* arppkt = GETPKTDATA(pkt, ArpPacket);
    WORD op;
    IPADDR spa, tpa;
    ArpCacheEntry* arpEntry;
    INT resolve;
    BYTE sha[ENETADDRLEN];

    ASSERT(pkt->datalen >= ARPPKTLEN);

    op = NTOHS(arppkt->op);
    spa = arppkt->spa;
    tpa = arppkt->tpa;

    // Simple sanity check
    if (arppkt->hrd != HTONS(ARP_HWTYPE_ENET) &&
        arppkt->hrd != HTONS(ARP_HWTYPE_802) ||
        arppkt->pro != HTONS(ENETTYPE_IP) ||
        arppkt->hln != ENETADDRLEN ||
        arppkt->pln != IPADDRLEN ||
        op != ARP_REQUEST && op != ARP_REPLY ||
        !XnetIsValidUnicastAddr(spa) ||
        !XnetIsValidUnicastAddr(tpa)) {
        goto exit;
    }

    // Check to see if we have an existing entry for the sender
    // in our ARP cache. If we're the target and there is no
    // existing entry, then we'll create a new entry.
    // This assumes that communication will likely be bidirectional.

    if (spa == ifp->ipaddr || spa == ifp->checkConflictAddr) {
        if (IfDhcpEnabled(ifp)) {
            ifp->checkConflictAddr = 0;
            DhcpNotifyAddressConflict((IfInfo*) ifp);
        }

        // In case the other case is checking for address conflict,
        // send out a reply to indicate we already have the address.
        if (tpa == ifp->ipaddr && op == ARP_REQUEST) {
            ArpSendReply(ifp, spa, arppkt->sha);
        }
        goto exit;
    } else if (!IfRunning(ifp)) {
        goto exit;
    }

    CopyMem(sha, arppkt->sha, ENETADDRLEN);
    resolve = (tpa == ifp->ipaddr) ? RESOLVE_CREATE_ENTRY : RESOLVE_NONE;
    
    // We should return the incoming packet structure
    // back to the Enet driver as soon as possible.
    COMPLETEPACKET(pkt, NETERR_OK);
    arpEntry = ArpFindCacheEntry(ifp, spa, resolve);

    if (arpEntry) {
        arpEntry->state = ARPST_OK;
        arpEntry->timer = cfgPositiveArpCacheTimeout;
        CopyMem(arpEntry->enetaddr, sha, ENETADDRLEN);

        // If there were packets waiting on this entry,
        // now that we have the address resolve, it's
        // time to start the transmission.
        //
        // NOTE: We insert the waiting packets at the head of
        // the interface's send queue. We're not calling
        // EnetTransmitPacket directly because we want to
        // limit the depth of the command queue (which is
        // done inside EnetStartOutput).

        if (!PktQIsEmpty(&arpEntry->waitq)) {
            PktQJoinBefore(&ifp->sendq, &arpEntry->waitq);
            PktQInit(&arpEntry->waitq);
            EnetStartOutput(ifp);
        }
    }
    
    // If we're the target and the packet is an ARP request,
    // then send out an ARP reply. Notice that we allocate a
    // new Packet here instead reusing the incoming packet.

    if (tpa == ifp->ipaddr && op == ARP_REQUEST) {
        ArpSendReply(ifp, spa, sha);
    }
    return;

exit:
    // Return the packet to the caller
    COMPLETEPACKET(pkt, NETERR_DISCARDED);
}


VOID
ArpCleanup(
    IfEnet* ifp
    )

/*++

Routine Description:

    Clean up ARP related data

Arguments:

    ifp - Points to the interface structure

Return Value:

    NONE

--*/

{
    ArpCacheEntry* arpEntry;
    Packet* pkt;
    INT index;

    // Loop thru all cache entries
    for (index=0; index < ARP_CACHE_SIZE; index++) {
        arpEntry = &ifp->arpCache[index];
        arpEntry->state = ARPST_BAD;

        // Complete any packets waiting on the entry
        while (!PktQIsEmpty(&arpEntry->waitq)) {
            pkt = PktQRemoveHead(&arpEntry->waitq);
            COMPLETEPACKET(pkt, NETERR_CANCELLED);
        }
    }

    ifp->lastArpAddr = 0;
    ifp->lastArpEntry = NULL;
    ifp->arpCacheCount = 0;
    ZeroMem(&ifp->arpCache, sizeof(ifp->arpCache));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\enet\enet.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    enet.c

Abstract:

    Handle Ethernet frame transmission and reception

Revision History:

    05/04/2000 davidx
        Created it.

--*/

#include "precomp.h"

//
// Ethernet broadcast address
//
const BYTE EnetBroadcastAddr[ENETADDRLEN] = {
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

//
// IEEE LLC and SNAP headers for an Ethernet frame
//
const BYTE IeeeEnetHeaders[] = {
    SNAP_DSAP,      // DSAP - 0xaa
    SNAP_SSAP,      // SSAP - 0xaa
    LLC_DGRAM,      // control - 3
    0, 0, 0         // org code
};

//
// Maximum length of the transmit and receive queue.
//
UINT cfgXmitQLength = 8;
UINT cfgRecvQLength = 10;

//
// Enet system shutdown notification routine
//
PRIVATE BOOL EnetShutdownNotifyRegistered;
PRIVATE HAL_SHUTDOWN_REGISTRATION EnetShutdownNotification;


PRIVATE VOID
EnetTransmitPacket(
    IfEnet* ifp,
    Packet* pkt,
    const BYTE* dsthwaddr
    )

/*++

Routine Description:

    Transmit an IP datagram to the Ethernet interface

Arguments:

    ifp - Points to the interface structure
    pkt - Points to the packet to be transmitted
    dsthwaddr - Specifies the destination Ethernet hardware address

Return Value:

    NONE

--*/

{
    EnetFrameHeader* enethdr;

    //
    // We assume that the outgoing packet has enough free
    // space before the data buffer to hold the Ethernet frame header.
    //
    ASSERT(PktSpaceBefore(pkt) >= ENETHDRLEN);

    pkt->data -= ENETHDRLEN;
    pkt->datalen += ENETHDRLEN;

    // Now slap on the Ethernet frame header and send it out
    enethdr = GETPKTDATA(pkt, EnetFrameHeader);
    CopyMem(enethdr->dstaddr, dsthwaddr, ENETADDRLEN);
    CopyMem(enethdr->srcaddr, ifp->hwaddr, ENETADDRLEN);
    
    enethdr->etherType = HTONS(ENETTYPE_IP);
    NicTransmitFrame(ifp, pkt);
}


VOID
EnetReceiveFrame(
    IfEnet* ifp,
    Packet* pkt
    )

/*++

Routine Description:

    Process a received Ethernet frame

Arguments:

    ifp - Points to the interface structure
    pkt - Points to the received packet

Return Value:

    NONE

--*/

{
    EnetFrameHeader* enethdr;
    WORD etherType;

    // We assume the whole frame fits inside a single Packet
    // and the packet data length is validated by the NIC functions.
    // We also assume the Ethernet frame header starts on
    // a WORD-aligned boundary.
    ASSERT(pkt->datalen >= ENETHDRLEN + ENET_MINDATASIZE &&
           pkt->datalen <= ENETHDRLEN + ENET_MAXDATASIZE);

    // Peel off the Ethernet frame header
    enethdr = GETPKTDATA(pkt, EnetFrameHeader);
    pkt->data += ENETHDRLEN;
    pkt->datalen -= ENETHDRLEN;
    etherType = NTOHS(enethdr->etherType);

    // Peel off the IEEE 802.3 LLC and SNAP headers if necessary
    if (IsIEEE802Frame(etherType)) {
        IEEE802Header* ieeehdr = GETPKTDATA(pkt, IEEE802Header);
        pkt->data += IEEE802HDRLEN;
        pkt->datalen -= IEEE802HDRLEN;

        // If the IEEE frame wasn't meant for us, discard it.
        if (!EqualMem(ieeehdr, IeeeEnetHeaders, IEEE802HDRLEN))
            goto discard;

        etherType = NTOHS(ieeehdr->etherType);
    }

    if (etherType == ENETTYPE_IP) {
        // Was the frame received as a broadcast or multicast?
        if (IsEnetAddrMcast(enethdr->dstaddr))
            pkt->pktflags |= PKTFLAG_MCAST;

        // Pass the received frame up to the IP layer and return
        IPRECEIVEPACKET(pkt);
        return;
    }
    
    if (etherType == ENETTYPE_ARP) {
        if (EqualMem(enethdr->srcaddr, ifp->hwaddr, ENETADDRLEN)) {
            // If an ARP packet was receive and the source address
            // was the same as ours, then we have an Ethernet
            // address conflict. We assume we don't receive
            // our own transmissions.
            WARNING_("Ethernet address conflict: db %x!", enethdr);
            ASSERT(FALSE);
        } else {
            // Process incoming ARP packets
            ArpReceivePacket(ifp, pkt);
            return;
        }
    }

discard:
    // Ethernet frame wasn't recognized; quietly discard it.
    COMPLETEPACKET(pkt, NETERR_DISCARDED);
}


VOID
EnetStartOutput(
    IfEnet* ifp
    )

/*++

Routine Description:

    Start output on the Ethernet interface

Arguments:

    ifp - Points to the interface structure

Return Value:

    NONE

--*/

{
    Packet* pkt;
    ArpCacheEntry* arpEntry;
    NTSTATUS status;
    IPADDR nexthop;

    // Must be called at DISPATCH_LEVEL.
    ASSERT_DISPATCH_LEVEL();

    //
    // Remove the packet at the head of the output queue
    // NOTE: We need to make sure we don't flood the NIC's command queue.
    // 
    while (!PktQIsEmpty(&ifp->sendq) && !NicIsXmitQFull(ifp)) {
        pkt = IfDequeuePacket(ifp);

        nexthop = pkt->nexthop;
        if (IfBcastAddr(ifp, nexthop)) {
            // Broadcast packet
            // NOTE: We assume broadcast loopback is handled in the upper layer.
            if (IfUp(ifp)) {
                EnetTransmitPacket(ifp, pkt, EnetBroadcastAddr);
                continue;
            }
            status = NETERR_NETDOWN;
        } else if (IS_MCAST_IPADDR(nexthop)) {
            // Multicast packet
            // NOTE: We assume multicast loopback is handled in the upper layer.
            if (IfUp(ifp)) {
                BYTE mcastaddr[ENETADDRLEN];
                EnetGenerateMcastAddr(nexthop, mcastaddr);
                EnetTransmitPacket(ifp, pkt, mcastaddr);
                continue;
            }
            status = NETERR_NETDOWN;
        } else {
            // Unicast packet
            // Otherwise, resolve the nexthop IP address to Ethernet address
            if (!IfRunning(ifp)) {
                // Can't send unicast message if the interface is inactive
                status = NETERR_NETDOWN;
            } else if ((arpEntry = ArpFindCacheEntry(ifp, nexthop, RESOLVE_SEND_REQUEST)) == NULL) {
                status = NETERR_MEMORY;
            } else if (IsArpEntryOk(arpEntry)) {
                // Found a valid existing entry in the ARP cache
                // for the next hop address
                EnetTransmitPacket(ifp, pkt, arpEntry->enetaddr);
                continue;
            } else if (IsArpEntryBad(arpEntry)) {
                // Found an existing entry for the next hop address
                // but the entry indicates the target is unreachable.
                status = NETERR_UNREACHABLE;
            } else {
                // Created a new entry for the next hop address
                // or found an existing entry that's currently being resolved
                ASSERT(IsArpEntryBusy(arpEntry));
                PktQInsertTail(&arpEntry->waitq, pkt);
                continue;
            }
        }

        // Complete the packet with error status and move on
        VERBOSE_("Failed to send packet: 0x%x", status);
        COMPLETEPACKET(pkt, status);
    }
}


PRIVATE VOID
EnetDelete(
    IfEnet* ifp
    )

/*++

Routine Description:

    Delete the Ethernet interface

Arguments:

    ifp - Points to the interface structure

Return Value:

    NONE

--*/

{
    RUNS_AT_DISPATCH_LEVEL

    IFENET_DELETE_CHECK(ifp);
    if (ifp->refcount) return;

    // Unregister shutdown notification routine
    if (EnetShutdownNotifyRegistered) {
        HalRegisterShutdownNotification(&EnetShutdownNotification, FALSE);
        EnetShutdownNotifyRegistered = FALSE;
    }

    // Make sure the NIC is stopped
    ifp->flags &= ~(IFFLAG_UP|IFFLAG_RUNNING);
    NicReset(ifp, TRUE);

    // Cleanup the send queue
    while (!PktQIsEmpty(&ifp->sendq)) {
        Packet* pkt = PktQRemoveHead(&ifp->sendq);
        COMPLETEPACKET(pkt, NETERR_CANCELLED);
    }

    ArpCleanup(ifp);
    NicCleanup(ifp);
    SysFree(ifp);
}


PRIVATE VOID
EnetShutdownNotifyProc(
    HAL_SHUTDOWN_REGISTRATION* param
    )

/*++

Routine Description:

    Notification routine that's called during system shutdown

Arguments:

    param - Shutdown notification parameters

Return Value:

    NONE

--*/

{
    KIRQL irql = RaiseToDpc();
    IfEnet* ifp = (IfEnet*) LanIfp;

    // Make sure the NIC is stopped
    ifp->flags &= ~(IFFLAG_UP|IFFLAG_RUNNING);
    NicReset(ifp, TRUE);

    LowerFromDpc(irql);
}


PRIVATE VOID
EnetTimer(
    IfEnet* ifp
    )

/*++

Routine Description:

    Ethernet interface timer routine (called once a second)

Arguments:

    ifp - Points to the interface structure

Return Value:

    NONE

--*/

{
    if (IfUp(ifp)) {
        ArpTimerProc(ifp);
        NicTimerProc(ifp);
    }
}


PRIVATE NTSTATUS
EnetSetMcastAddrs(
    IfEnet* ifp
    )

/*++

Routine Description:

    Update the multicast filter on the NIC hardware

Arguments:

    ifp - Points to the interface structure

Return Value:

    Status code

--*/

{
    BYTE* addrs;
    UINT count;
    NTSTATUS status;

    RUNS_AT_DISPATCH_LEVEL

    count = ifp->mcastData->groupCount;
    if (count) {
        addrs = SysAlloc(count * ENETADDRLEN, PTAG_MCAST);
        if (addrs) {
            BYTE* p = addrs;
            IfMcastGroup* mcastgrp = ifp->mcastData->mcastGroups;
            UINT i;

            for (i=0; i < count; i++) {
                EnetGenerateMcastAddr(mcastgrp->mcastaddr, p);
                mcastgrp++;
                p += ENETADDRLEN;
            }
        } else {
            return NETERR_MEMORY;
        }
    } else {
        addrs = NULL;
    }

    status = NicSetMcastAddrs(ifp, addrs, count);
    SysFree(addrs);
    return status;
}


PRIVATE NTSTATUS
EnetIoctl(
    IfEnet* ifp,
    INT ctlcode,
    VOID* inbuf,
    UINT inlen,
    VOID* outbuf,
    UINT* outlen
    )

/*++

Routine Description:

    Ethernet interface I/O control function

Arguments:

    ifp - Points to the interface structure
    ctlcode - Control code
    inbuf - Points to the input buffer
    inlen - Size of the input buffer
    outbuf - Points to the output buffer
    outlen - On entry, this contains the size of the output buffer
        On return, this is the actually number of output bytes

Return Value:

    Status code

--*/

{
    NTSTATUS status;
    IPADDR ipaddr;
    KIRQL irql = RaiseToDpc();

    switch (ctlcode) {
    case IFCTL_SET_MCAST_ADDRS:
        //
        // Send multicast addresses down to the NIC
        //
        status = EnetSetMcastAddrs(ifp);
        break;

    case IFCTL_CHECK_ADDR_CONFLICT:
        //
        // Check for IP address conflict
        //
        ASSERT(inlen == IPADDRLEN);

        ipaddr = *((IPADDR*) inbuf);
        ASSERT(XnetIsValidUnicastAddr(ipaddr));
        
        ifp->checkConflictAddr = ipaddr;
        status = ipaddr ? ArpSendRequest(ifp, ipaddr, ipaddr) : NETERR_OK;
        break;

    default:
        status = NETERR_NOTIMPL;
        break;
    }

    LowerFromDpc(irql);
    return status;
}


NTSTATUS
EnetInitialize(
    IfInfo** newifp
    )

/*++

Routine Description:

    Initialize the Ethernet interface.

Arguments:

    NONE

Return Value:

    Status code

--*/

{
    IfEnet* ifp;
    NTSTATUS status;

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    // Check if the debug monitor has already initialized the enet interface
    #pragma warning(disable:4055)
    CHECK_DBGMON_ENETINFO();

    #ifdef DVTSNOOPBUG
    status = XnetUncachedPoolInit();
    if (!NT_SUCCESS(status)) return NETERR_MEMORY;
    #endif

    // Allocate memory to hold our interface structure

    ifp = SysAlloc0(sizeof(IfEnet), PTAG_ENET);
    if (!ifp) return NETERR_MEMORY;
    ifp->refcount = 1;
    ifp->ifname = "Ethernet";
    ifp->magicCookie = 'TENE';

    // Interface functions
    ifp->Delete = (IfDeleteProc) EnetDelete;
    ifp->StartOutput = (IfStartOutputProc) EnetStartOutput;
    ifp->Timer = (IfTimerProc) EnetTimer;
    ifp->Ioctl = (IfIoctlProc) EnetIoctl;

    ifp->iftype = IFTYPE_ETHERNET;
    ifp->framehdrlen = ENETHDRLEN;
    ifp->mtu = ENET_MAXDATASIZE;

    // Initialize the NIC interface
    status = NicInitialize(ifp);
    if (!NT_SUCCESS(status)) goto failed;

    // Now mark the interface as fully initialized
    // and start handling interrupts.

    ifp->flags |= IFFLAG_UP |
                  IFFLAG_DHCP_ENABLED |
                  IFFLAG_BCAST |
                  IFFLAG_MCAST;

    *newifp = (IfInfo*) ifp;
    IfSetIpAddr(*newifp, 0, 0);

    // Set the enet interface information in the process control block
    SET_DBGMON_ENETINFO(ifp);

    // Register shutdown notification routine
    EnetShutdownNotification.NotificationRoutine = EnetShutdownNotifyProc;
    HalRegisterShutdownNotification(&EnetShutdownNotification, TRUE);
    EnetShutdownNotifyRegistered = TRUE;

    NicEnableInterrupt();
    return NETERR_OK;

failed:
    WARNING_("EnetInitialize failed: 0x%x", status);
    EnetDelete(ifp);
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\dns\precomp.h ===
#define WINSOCK_API_LINKAGE

#include "xnetp.h"
#include "dns.h"
#include "dnslib.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\enet\i82558.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    i82558.h

Abstract:

    Intel 82558 NIC hardware related declarations

Revision History:

    05/07/2000 davidx
        Created it.

--*/

#ifndef _82558_H
#define _82558_H

//
// Vendor and device IDs for EPRO100+
//
#define NIC_VENDORID 0x8086
#define NIC_DEVICEID 0x1229

//------------------------------------------------------------------------
// I82558 command/status registers
//------------------------------------------------------------------------

typedef struct _NIC_CSR {
    BYTE cusRus;
        // CU and RU status
        // Bit 7-6: CUS - CU status field
        //  00 - idle
        //  01 - suspended
        //  10 - active
        //  11 - * (reserved)
        // Bit 5-2: RUS - RU status field
        //  0000 - idle
        //  0001 - suspended
        //  0010 - no resources
        //  0011 - *
        //  0100 - ready
        //  0101 - *
        //  0110 - *
        //  0111 - *
        //  1000 - *
        //  1001 - suspended with no more RBDs
        //  1010 - No resources due to no more RBDs
        //  1011 - *
        //  1100 - ready with no RBDs present
        //  1101 - *
        //  1110 - *
        //  1111 - *
        // Bit 1-0: reserved

    #define SCB_STAT_CUS(x) (((x) >> 6) & 3)
    #define   CUS_IDLE          0
    #define   CUS_SUSPENDED     1
    #define   CUS_ACTIVE        2
    #define SCB_STAT_RUS(x) (((x) >> 2) & 0xf)
    #define   RUS_IDLE          0
    #define   RUS_SUSPENDED     1
    #define   RUS_NORES         2
    #define   RUS_READY         4
    #define   RUS_SUSPENDED_RBD 9
    #define   RUS_NORES_RBD     10
    #define   RUS_READY_RBD     12

    BYTE statAck;
        // Interrupt status and acknowledgement bits
        // Bit 7: CX - CU finished executing a command with I-bit set
        // Bit 6: FR - RU finished receiving a frame
        // Bit 5: CNA - CU went from active to idle or suspended state
        // Bit 4: RNR - RU left ready state
        // Bit 3: MDI - MDI read or write cycle is done
        // Bit 2: SWI - software generated an interrupt
        // Bit 1: reserved
        // Bit 0: FCP - flow control pause interrupt bit

    #define SCB_STAT_CX     BIT(7)
    #define SCB_STAT_FR     BIT(6)
    #define SCB_STAT_CNA    BIT(5)
    #define SCB_STAT_RNR    BIT(4)
    #define SCB_STAT_MDI    BIT(3)
    #define SCB_STAT_SWI    BIT(2)
    #define SCB_STAT_FCP    BIT(0)

    BYTE cucRuc;
        // Bit 7-4: CUC - CU command field
        //  0000 - NOP
        //  0001 - CU start
        //  0010 - CU resume
        //  0011 - *
        //  0100 - load dump counters address
        //  0101 - dump statistical counters
        //  0110 - load CU base
        //  0111 - dump and reset statistical counters
        //  1000 - *
        //  1001 - *
        //  1010 - static resume
        //  1011 - *
        //  ...
        //  1111 - *
        // Bit 3: reserved
        // Bit 2-0: RU command field
        //  000 - NOP
        //  001 - RU start
        //  010 - RU resume
        //  011 - RU DMA redirect
        //  100 - RU abort
        //  101 - load header data size
        //  110 - load RU base
        //  111 - RBD resume

    #define CUC_NOP             (0 << 4)
    #define CUC_START           (1 << 4)
    #define CUC_RESUME          (2 << 4)
    #define CUC_LOAD_DUMP_ADDR  (4 << 4)
    #define CUC_DUMP_STAT       (5 << 4)
    #define CUC_LOAD_CU_BASE    (6 << 4)
    #define CUC_DUMP_RESET_STAT (7 << 4)
    #define CUC_STATIC_RESUME   (10 << 4)

    #define RUC_NOP             0
    #define RUC_START           1
    #define RUC_RESUME          2
    #define RUC_RCVDMA_REDIRECT 3
    #define RUC_ABORT           4
    #define RUC_LOAD_HDS        5
    #define RUC_LOAD_RU_BASE    6
    #define RUC_RBD_RESUME      7

    BYTE intrMask;
        // Bit 7: CX interrupt mask bit
        // Bit 6: FR interrupt mask bit
        // Bit 5: CNA interrupt mask bit
        // Bit 4: RNR interrupt mask bit
        // Bit 3: ER interrupt mask bit
        // Bit 2: FCP interrupt mask bit
        // Bit 1: SI - software interrupt request
        // Bit 0: M - global interrupt mask

    #define CX_INTR_BIT     BIT(7)
    #define FR_INTR_BIT     BIT(6)
    #define CNA_INTR_BIT    BIT(5)
    #define RNR_INTR_BIT    BIT(4)
    #define ER_INTR_BIT     BIT(3)
    #define FCP_INTR_BIT    BIT(2)
    #define SW_INTR_BIT     BIT(1)
    #define INTR_MASK_BIT   BIT(0)

    DWORD scbGeneralPtr;
        // SCB general pointer

    DWORD port;
        // PORT interface
        // Bit 31-4: address bits
        // Bit 3-0: port function selection
        //  0000 - software reset
        //  0001 - self-test
        //  0010 - selective reset
        //  0011 - dump
        //  0100 - *
        //  ...
        //  1111 - *

    #define PORTCMD_SOFTWARE_RESET  0
    #define PORTCMD_SELF_TEST       1
    #define PORTCMD_SELECTIVE_RESET 2
    #define PORTCMD_DUMP            3

    WORD flashCtrl;
        // Flash control register

    WORD eepromCtrl;
        // EEPROM control register
        // Bit 7-4: reserved
        // Bit 3: EEDO - data out
        // Bit 2: EEDI - data in
        // Bit 1: EECS - chip select
        // Bit 0: EESK - serial clock

    #define EEPROM_DO   BIT(3)
    #define EEPROM_DI   BIT(2)
    #define EEPROM_CS   BIT(1)
    #define EEPROM_SK   BIT(0)

    #define EEPROMOP_WRITE  1
    #define EEPROMOP_READ   2

    DWORD mdiCtrl;
        // MDI control register
        // Bit 31-30: reserved
        // Bit 29: interrupt enable
        // Bit 28: ready
        // Bit 27-26: opcode
        //  00 - *
        //  01 - MDI write
        //  10 - MDI read
        //  11 - *
        // Bit 25-21: PHY address
        // Bit 20-16: PHY register address
        // Bit 15-0: data field

    #define MDI_INTR_ENABLE     BIT(29)
    #define MDI_READY           BIT(28)
    #define MDIOP_WRITE         (1 << 26)
    #define MDIOP_READ          (2 << 26)
    #define MDI_PHY_ADDR(x)     ((x) << 21)
    #define MDI_PHY_REG_ADDR(x) ((x) << 16)

    DWORD reserved1;
    DWORD reserved2;
        // Bit 31-24: PMDR - power management driver register
        // Bit 23-8: flow control register
        // Bit 7-0: reserved
} volatile *PNIC_CSR;

extern PNIC_CSR NicCsr;

//------------------------------------------------------------------------
// 82558 general action command format
// NOTE: We store this information in the Packet.ifdata field
// of an outgoing packet. And it's tail-aligned so that it's
// contiguous with the packet data field.
//------------------------------------------------------------------------

typedef struct _ActionCmdBlock {
    DWORD cmdstatus;
        // Command and status:
        //  bit 31 (EL) - end of command block list
        //  bit 30 (S) - suspend after command completion
        //  bit 29 (I) - interrupt after command completion
        //  bit 28-19 - varies with different commands
        //  bit 18-16 (CMD) - command code
        //  bit 15 (C) - command completed
        //  bit 14 - reserved
        //  bit 13 - command executed ok
        //  bit 12-0 - varies with different commands

    #define CMDFLAG_EL          BIT(31)
    #define CMDFLAG_S           BIT(30)
    #define CMDFLAG_I           BIT(29)

    #define ACTIONCMD_NOP       (0 << 16)
    #define ACTIONCMD_IA_SETUP  (1 << 16)
    #define ACTIONCMD_CONFIGURE (2 << 16)
    #define ACTIONCMD_MC_SETUP  (3 << 16)
    #define ACTIONCMD_TRANSMIT  (4 << 16)
    #define ACTIONCMD_DUMP      (6 << 16)
    #define ACTIONCMD_DIAGNOSE  (7 << 16)

    #define CMDSTATUS_C         BIT(15)
    #define CMDSTATUS_OK        BIT(13)

    DWORD link;
        // link to the next command block in the list
        //  this is a physical address
        //  use 0xffffffff at the end of the list

    #define LINK_OFFSET_NULL 0xffffffff

} ActionCmdBlock;

//------------------------------------------------------------------------
// Transmit command block (TxCB)
//------------------------------------------------------------------------

typedef struct _TransmitCmdBlock {
    ActionCmdBlock;
        // General action command data:
        //  command / status
        //  link
        // Additional command and status flags:
        //  bit 20 (NC) - no CRC and source address insertion
        //  bit 19 (SF) - simple or flexible mode
        //  bit 12 (U) - transmit underrun encountered

    #define TxCBFLAG_NC     BIT(20)
    #define TxCBFLAG_SF     BIT(19)

    #define TxCBSTATUS_U    BIT(12)

    DWORD tbdArray;
        // in flexible mode, physical address of the TBD array

    WORD byteCount;
        // bit 15 (EOF) - whole frame is kept inside the command block itself
        // bit 14 - reserved
        // bit 13-0: amount of data in the transmit command block itself

    #define TxCB_EOF        BIT(15)

    BYTE txThreshold;
        // number of bytes that should be present in the Tx FIFO
        // before it starts transmitting the frame

    BYTE tbdNumber;
        // in flexible mode, represent the number of transmit buffers
        // in the TBD array
} TransmitCmdBlock;

//
// Early transmit threshold
//  This number is multiplied by 8 to get the actual byte count.
//  BOGUS: Not sure why w2k driver uses such a high value which
//  basically disables the early transmit feature.
//
#define DEFAULT_Tx_THRESHOLD 200

//
// Maximum number of TBD's for transmitting a single packet.
// This is not a hardware limit. Rather it's an arbitrary software
// limit we set. When there are two many fragments for a single
// packet, something upstream must be pretty bad and it's better
// to address the real issues there.
//
#define MAX_TBD_PER_XMIT 4

//
// TBD (Transmit Buffer Descriptor) entry
//
typedef struct _TBDEntry {
    DWORD bufaddr;
        // physical address of the buffer data

    DWORD bufsize;
        // bit 31-16: reserved
        // bit 15 (EL): end of the TBD array
        // bit 14: reserved
        // bit 13-0: buffer size (in bytes)
} TBDEntry;

//------------------------------------------------------------------------
// Multicast setup command block
//------------------------------------------------------------------------

typedef struct _McastSetupCmdBlock {
    ActionCmdBlock;
        // General action command data:
        //  command / status
        //  link
    
    WORD mcastCount;
        // Number of multicast addresses to follow
    
    BYTE mcastAddrs[ENETADDRLEN];
        // variable number of Ethernet multicast addresses
} McastSetupCmdBlock;

//------------------------------------------------------------------------
// Individual address setup command block
//------------------------------------------------------------------------

typedef struct _IASetupCmdBlock {
    ActionCmdBlock;
        // General action command data:
        //  command / status
        //  link

    BYTE hwaddr[ENETADDRLEN];
        // Individual address
} IASetupCmdBlock;

//------------------------------------------------------------------------
// Configure command block
//------------------------------------------------------------------------

typedef struct _ConfigCmdBlock {
    ActionCmdBlock;
        // General action command data:
        //  command / status
        //  link

    // Maximum number of configuration parameters
    #define CONFIG_PARAM_COUNT 22

    BYTE params[CONFIG_PARAM_COUNT];
        // Configuration parameters
} ConfigCmdBlock;

//------------------------------------------------------------------------
// Receive frame descriptor (RFD)
//------------------------------------------------------------------------

typedef struct _RecvFrameDesc {
    ActionCmdBlock;
        // General action command data:
        //  command / status
        //  link
        // Additional command and status flags:
        //  bit 20 (H) - indicate this RFD is a Header RFC
        //  bit 19 (SF) - simple or flexible mode
        //
        //  bit 11 - CRC error in an aligned frame
        //  bit 10 - alignment error (number of bits is not 8x)
        //  bit 9 - ran out of buffer space - no resources
        //  bit 8 - DMA overrun - failed to acquire the system bus
        //  bit 7 - frame too short
        //  bit 5 - type/length: 1 for Ethernet frame, 0 for 802.3 frame
        //  bit 4 - receive error
        //  bit 2 - no address match
        //  bit 1 - IA match bit
        //  bit 0 - receive collision
    
    #define RFDFLAG_H   BIT(20)
    #define RFDFLAG_SF  BIT(19)

    #define RFDSTATUS_CRC_ERROR     BIT(11)
    #define RFDSTATUS_ALIGN_ERROR   BIT(10)
    #define RFDSTATUS_NO_BUFFER     BIT(9)
    #define RFDSTATUS_DMA_OVERRUN   BIT(8)
    #define RFDSTATUS_SHORT_FRAME   BIT(7)
    #define RFDSTATUS_ENET_FRAME    BIT(5)
    #define RFDSTATUS_RECV_ERROR    BIT(4)
    #define RFDSTATUS_NOADDR_MATCH  BIT(2)
    #define RFDSTATUS_IA_MATCH      BIT(1)
    #define RFDSTATUS_COLLISION     BIT(0)

    DWORD rbdAddr;
        // only used in flexible mode
        // address of RBD (receive buffer descriptor)
    
    WORD actualCount;
        // bit 15 (EOF): set by 82558 when it writes data into the data area
        // bit 14 (F): set by 82558 when it updates the actualCount field
        // bit 13-0: number of bytes written into the data area

    #define RFD_EOF     BIT(15)
    #define RFD_F       BIT(14)
    #define RFD_CNTMASK 0x3fff

    WORD size;
        // bit 15-14: reserved
        // bit 13-0: size of the data buffer
} RecvFrameDesc;

//------------------------------------------------------------------------
// 82558 Statistical Counters
//------------------------------------------------------------------------

typedef struct _NicStatCounters {
    DWORD xmitGoodFrames;
    DWORD xmitMaxCollisionsErrors;
    DWORD xmitLateCollisionsErrors;
    DWORD xmitUnderrunErrors;
    DWORD xmitLostCarrierSense;
    DWORD xmitDeferred;
    DWORD xmitSingleCollisions;
    DWORD xmitMultipleCollisions;
    DWORD xmitTotalCollisions;
    DWORD recvGoodFrames;
    DWORD recvCrcErrors;
    DWORD recvAlignmentErrors;
    DWORD recvResourceErrors;
    DWORD recvOverrunErrors;
    DWORD recvCollisionDetectErrors;
    DWORD recvShortFrameErrors;
    DWORD dumpCompletionStatus;
} NicStatCounters;


//
// We allocate a page of physically contiguous memory that's shared by
// the CPU and the NIC. This buffer is used for storing action command
// data (e.g. transmit command block and transmit buffer descriptor)
// that's passed to the NIC.
//
//  start  head        tail         last
//   |      |           |           |
//   v      v           v           v
//  |       xxxxxxxxxxxx           |
//
// Note that we always leave at least one unit empty in the buffer.
// If head = tail, that means the whole buffer is empty.
//
typedef struct _NicCmdBuffer {
    BYTE* start;        // buffer base virtual address
    BYTE* last;         // points to after the buffer
    BYTE* head;         // points to the first busy entry
    BYTE* tail;         // points to the first free entry
    UINT phyaddrOffset; // offset between virtual and physical address
} NicCmdBuffer;

// The smallest allocation unit is 8 bytes.
#define CMDBUF_ALLOC_UNIT 8

// Map virtual command buffer address to physical address
#define CmdBufferGetPhyAddr(nic, p) \
        ((UINT_PTR) (p) + (nic)->cmdbuf.phyaddrOffset)

//
// Extra header information at the beginning of the DMA packet
// that's used by the NIC for receiving frames:
//  receive frame descriptor
//
#define RECVPKT_OVERHEAD sizeof(RecvFrameDesc)

//
// Allocate shared memory buffers for the NIC
//
#define NicAllocSharedMem(size) MmAllocateContiguousMemory(size)
#define NicFreeSharedMem(p) MmFreeContiguousMemory(p)

//
// Disable and enable NIC interrupts
//
INLINE VOID NicDisableInterrupt() {
    NicCsr->intrMask = INTR_MASK_BIT;
}

INLINE VOID NicEnableInterrupt() {
    NicCsr->intrMask = 0;
}

#endif // !_82558_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\enet\ifenet.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    ifenet.h

Abstract:

    Ethernet and ARP implementation related declarations

Revision History:

    05/04/2000 davidx
        Created it.

--*/

#ifndef _IFENET_H
#define _IFENET_H

//
// ARP cache entry
//
typedef struct _ArpCacheEntry {
    IPADDR ipaddr;              // target IP address
    UINT timer;                 // timer (in seconds)
    PacketQueue waitq;          // outgoing packets blocked on this entry
    WORD state;                 // current state of the entry
    BYTE enetaddr[ENETADDRLEN]; // target Ethernet address
} ArpCacheEntry;

//
// Constants for ArpCacheEntry.flags
//
#define ARPST_FREE  0           // entry is free
#define ARPST_BUSY  1           // entry is being resolved
#define ARPST_OK    2           // entry is good
#define ARPST_BAD   3           // target is unreachable

#define IsArpEntryFree(_arpEntry) ((_arpEntry)->state == ARPST_FREE)
#define IsArpEntryBusy(_arpEntry) ((_arpEntry)->state == ARPST_BUSY)
#define IsArpEntryOk(_arpEntry) ((_arpEntry)->state == ARPST_OK)
#define IsArpEntryBad(_arpEntry) ((_arpEntry)->state == ARPST_BAD)

//
// Ethernet interface data structure
//
typedef struct _IfEnet {
    //
    // Information common to all network interfaces
    // !! must be the first field of the structure
    //
    IfInfo;
    DWORD magicCookie;          // magic cookie for debugging purpose

    //
    // NIC specific information
    //
    NicInfo;

    //
    // Used for DHCP/autonet: the tentative address that
    //  we need to check for conflict
    //
    IPADDR checkConflictAddr;

    //
    // ARP cache (the modulo value should be a prime number)
    //
    #define ARP_CACHE_SIZE  64
    #define ARP_HASH_RETRY  5
    #define ARP_HASH_MODULO (ARP_CACHE_SIZE-ARP_HASH_RETRY)

    IPADDR lastArpAddr;
    ArpCacheEntry* lastArpEntry;
    INT arpCacheCount;
    ArpCacheEntry arpCache[ARP_CACHE_SIZE];
} IfEnet;


//
// ARP configuration parameters
//
extern UINT cfgPositiveArpCacheTimeout;
extern UINT cfgNegativeArpCacheTimeout;
extern UINT cfgArpRequestRetries;

//
// Default ARP cache entry timeout (in seconds)
//  = 10 minutes for positive cache
//  = 1 minute for negative cache
//
#define POSITIVE_ARP_CACHE_TIMEOUT (10*60)
#define NEGATIVE_ARP_CACHE_TIMEOUT 60

//
// Number of times we try to retransmit an ARP request
//  (with 1 second delay)
//
#define ARP_REQUEST_RETRIES 2

//
// Resolve an IP address to an ARP cache entry
//  
#define RESOLVE_NONE            0
#define RESOLVE_CREATE_ENTRY    1
#define RESOLVE_SEND_REQUEST    2

ArpCacheEntry* ArpFindCacheEntry(IfEnet* ifp, IPADDR ipaddr, INT resolve);

// ARP timer function
VOID ArpTimerProc(IfEnet* ifp);

// Send out an ARP request or reply packet
NTSTATUS ArpSendPacket(IfEnet*, WORD, IPADDR, IPADDR, const BYTE*);

INLINE NTSTATUS ArpSendRequest(IfEnet* ifp, IPADDR tpa, IPADDR spa) {
    return ArpSendPacket(ifp, ARP_REQUEST, tpa, spa, NULL);
}

INLINE NTSTATUS ArpSendReply(IfEnet* ifp, IPADDR tpa, const BYTE* tha) {
    return ArpSendPacket(ifp, ARP_REPLY, tpa, ifp->ipaddr, tha);
}

// Process an incoming ARP packet
VOID ArpReceivePacket(IfEnet* ifp, Packet* pkt);

// Cleanup ARP related data
VOID ArpCleanup(IfEnet* ifp);

// Start output on the Ethernet interface
VOID EnetStartOutput(IfEnet* ifp);

// Generate an Ethernet multicast address from an IP multicast address
INLINE VOID EnetGenerateMcastAddr(IPADDR ipaddr, BYTE* hwaddr) {
    //
    // Refer to RFC1112 - section 6.4:
    // An IP host group address is mapped to an Ethernet multicast address
    // by placing the low-order 23-bits of the IP address into the low-order
    // 23 bits of the Ethernet multicast address 01-00-5E-00-00-00 (hex).
    //
    hwaddr[0] = 0x01;
    hwaddr[1] = 0x00;
    hwaddr[2] = 0x5e;

    // Note that IPADDR is in network byte order
    hwaddr[3] = (BYTE) ((ipaddr >> 8) & 0x7f);
    hwaddr[4] = (BYTE) (ipaddr >> 16);
    hwaddr[5] = (BYTE) (ipaddr >> 24);
}

//
// NIC functions
//
NTSTATUS NicInitialize(IfEnet* nic);
VOID NicReset(IfEnet* nic, BOOL disconnectIntr);
VOID NicCleanup(IfEnet* nic);
VOID NicTimerProc(IfEnet* nic);
VOID NicTransmitFrame(IfEnet* nic, Packet* pkt);
NTSTATUS NicSetMcastAddrs(IfEnet* nic, const BYTE* addrs, UINT count);
VOID NicWaitForXmitQEmpty(IfEnet* nic);
INLINE BOOL NicIsXmitQFull(IfEnet* nic) { return (nic->cmdqCount >= cfgXmitQLength); }

extern KINTERRUPT NicIntrObject;
INLINE VOID NicDisconnectInterrupt(IfEnet* nic) {
    if (NicIntrObject.Connected) {
        KeDisconnectInterrupt(&NicIntrObject);
        KeRemoveQueueDpc(&nic->dpc);
    }
}

VOID EnetReceiveFrame(IfEnet* ifp, Packet* pkt);
INLINE BOOL EnetIsSendQEmpty(IfEnet* ifp) { return PktQIsEmpty(&ifp->sendq); }

#endif // !_IFENET_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\enet\precomp.h ===
#include "xnetp.h"
#include "ethernet.h"
#include "phy.h"

#ifdef SILVER
#include "i82558.h"
#else
#include "xnic.h"
#endif

#include "nicp.h"
#include "ifenet.h"
#include "dbgmon.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\enet\nicp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    nicp.h

Abstract:

    Private header file for the NIC "driver" code

Revision History:

    01/24/2001 davidx
        Created it.

--*/

#ifndef _NICP_H
#define _NICP_H

//
// NIC data structure
//
typedef struct _NicInfo {
    PNIC_CSR CSR;               // points to NIC CSR structure
    ULONG csrSize;              // size of mapped CSR structure
    PacketQueue recvq;          // receive packet queue
    PacketQueue cmdq;           // NIC command queue
    UINT cmdqCount;             // # of entries in the command queue
    UINT cmdqWatchdog;          // command queue watchdog timer
    NicCmdBuffer cmdbuf;        // NIC command buffer
    KDPC dpc;                   // DPC object
    ULONG intrVector;           // interrupt vector
    KIRQL intrIrql;             // interrupt IRQ level
    DWORD rxpollFreq;           // XNIC Rx polling frequency
    DWORD linkStatus;           // last known link status
} NicInfo;

//
// Functions for managing DMA packet pool
//
// NOTE: The DMA packet size actually only needs to be as big as:
//      PKTHDRLEN + RECVPKT_OVERHEAD + ENETHDRLEN + ENET_MAXDATASIZE = 1546
// But we're have to use 2KB here to workaround an nVidia NIC hardware problem
// whether a receive buffer cannot cross physical page boundary.
//
#define DMAPKT_SIZE 2048
#define DMAPKT_MAXDATA (DMAPKT_SIZE - PKTHDRLEN - RECVPKT_OVERHEAD)

// Virtual and physical offset of the DMA packet pool
extern BYTE* NicPktPoolBase;
extern UINT_PTR NicPktPoolPhyAddrOffset;

INLINE Packet* NicPktAlloc(UINT index) {
    Packet* pkt = (Packet*) (NicPktPoolBase + index*DMAPKT_SIZE);
    ZeroMem(pkt, PKTHDRLEN);
    pkt->pktflags = PKTFLAG_DMA;
    pkt->data = pkt->buf;
    return pkt;
}

INLINE UINT_PTR NicPktGetPhyAddr(VOID* data) {
    return (UINT_PTR) data + NicPktPoolPhyAddrOffset;
}

INLINE NTSTATUS NicPktPoolInit(UINT count) {
    NicPktPoolBase = (BYTE*) NicAllocSharedMem(count * DMAPKT_SIZE);
    if (!NicPktPoolBase) return NETERR_MEMORY;
    NicPktPoolPhyAddrOffset = MmGetPhysicalAddress(NicPktPoolBase) - (UINT_PTR) NicPktPoolBase;
    return NETERR_OK;
}

INLINE VOID NicPktPoolCleanup() {
    if (NicPktPoolBase) {
        NicFreeSharedMem(NicPktPoolBase);
        NicPktPoolBase = NULL;
        NicPktPoolPhyAddrOffset = 0;
    }
}

#endif // !_NICP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\enet\i82558.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    82558.c

Abstract:

    Intel 82558 NIC related functions

Revision History:

    05/09/2000 davidx
        Created it.

    01/24/2000 davidx
        Moved into the kernel.

Note:

    We assume every NIC function here runs at DISPATCH_LEVEL
    unless noted otherwise.

--*/

#include "precomp.h"

#ifdef SILVER
#include <pci.h>


//
// NIC driver global variables
//
PNIC_CSR NicCsr;
BYTE* NicPktPoolBase;
UINT_PTR NicPktPoolPhyAddrOffset;
KINTERRUPT NicIntrObject;

// Forward declaration of local functions
PRIVATE VOID NicProcessRecvInterrupt(IfEnet* nic);
PRIVATE BOOL NicProcessXmitInterrupt(IfEnet* nic, BYTE statAck);

//
// Interlocked bit-wise AND and OR operations
//
INLINE __declspec(naked) VOID __fastcall InterlockedAND(DWORD* p, DWORD mask) {
    __asm and DWORD PTR [ecx], edx
    __asm ret
}

INLINE __declspec(naked) VOID __fastcall InterlockedOR(DWORD* p, DWORD mask) {
    __asm or DWORD PTR [ecx], edx
    __asm ret
}

//
// For an outgoing packet, we store the command block information
// associated with the packet in the Packet.ifdata field.
//  high word: offset to where the command block starts
//  low word: command block size
//
#define SetPktCmdBlk(nic, pkt, cmdblk, cmdsize) \
        (pkt)->ifdata = ((cmdsize) | (((BYTE*) (cmdblk) - (nic)->cmdbuf.start) << 16))

#define GetPktCmdBlk(nic, pkt) \
        ((ActionCmdBlock*) ((nic)->cmdbuf.start + ((pkt)->ifdata >> 16)))

#define GetPktCmdBlkSize(nic, pkt) ((pkt)->ifdata & 0xffff)

//
// For a received packet, the packet content after the the packet header is:
//  RecvFrameDesc - receive frame descriptor
//  Ethernet frame header
//  frame data
//
#define GetPktRFD(pkt) GETPKTBUF(pkt, RecvFrameDesc)
#define GetPktRFDPhy(pkt) NicPktGetPhyAddr((pkt)->buf)

//
// Lock and unlock the physical pages containing packet data
//
INLINE VOID NicLockPacketPages(Packet* pkt) {
    if (pkt->datalen) {
        MmLockUnlockBufferPages(pkt->data, pkt->datalen, FALSE);
    }
}

INLINE VOID NicUnlockPacketPages(Packet* pkt) {
    if (pkt->datalen) {
        MmLockUnlockBufferPages(pkt->data, pkt->datalen, TRUE);
    }
}


PRIVATE NTSTATUS
NicWaitScb(
    PNIC_CSR csr
    )

/*++

Routine Description:

    Wait for the low SCB command byte to be clear
    (before we can issue CU or RU commands)

Arguments:

    csr - Points to the 82558 CSR registers

Return Value:

    Status code

--*/

{
    // BOGUS: not sure where w2k driver got this 600ms number
    //  which seems an awfully long time to wait
    UINT timeout = 60000;

    while (timeout--) {
        if (csr->cucRuc == 0) return NETERR_OK;
        KeStallExecutionProcessor(10);
    }

    WARNING_("NicWaitScb failed!");
    return NETERR_HARDWARE;
}


PRIVATE NTSTATUS
NicExecuteActionCmdAndWait(
    IfEnet* nic,
    ActionCmdBlock* cmdblk,
    INT opcode
    )

/*++

Routine Description:

    Execute an action command and wait for its completion

Arguments:

    nic - Points to the NIC data structure
    cmdblk - Points to the action command data block
    opcode - Specifies the command opcode

Return Value:

    Status code

Note:

    This function should only be called when the command unit is idle
    and interrupts are disabled. It issues the command and busy-wait
    for the command to complete. It's intended to be called during
    initialization.

--*/

{
    NTSTATUS status;
    PNIC_CSR csr = nic->CSR;
    UINT timeout;

    // Wait until the command unit is ready to accept
    // a new command and then issue the command.
    cmdblk->cmdstatus = opcode | CMDFLAG_EL;
    cmdblk->link = LINK_OFFSET_NULL;
    status = NicWaitScb(csr);
    if (!NT_SUCCESS(status)) return status;

    csr->scbGeneralPtr = CmdBufferGetPhyAddr(nic, cmdblk);
    csr->cucRuc = CUC_START;

    // Now wait for command completion
    //  BOGUS: seems to be an extremely long timeout period (3sec)
    timeout = 300000;
    while (!(cmdblk->cmdstatus & CMDSTATUS_C) && timeout--) {
        KeStallExecutionProcessor(10);
    }

    // Acknowledge any pending interrupts
    csr->statAck = csr->statAck;

    if (cmdblk->cmdstatus & CMDSTATUS_OK) return NETERR_OK;

    WARNING_("NicExecuteActionCmdAndWait failed!");
    return NETERR_HARDWARE;
}


PRIVATE NTSTATUS
NicDoIASetupCmd(
    IfEnet* nic
    )

/*++

Routine Description:

    Configure the individual address

Arguments:

    nic - Points to the NIC data structure

Return Value:

    Status code

--*/

{
    // We assume the CU is idle and we can use
    // the entire shared command data buffer.
    IASetupCmdBlock* cmdblk = (IASetupCmdBlock*) nic->cmdbuf.start;

    CopyMem(cmdblk->hwaddr, nic->hwaddr, ENETADDRLEN);
    return NicExecuteActionCmdAndWait(nic, (ActionCmdBlock*) cmdblk, ACTIONCMD_IA_SETUP);
}


PRIVATE NTSTATUS
NicDoConfigureCmd(
    IfEnet* nic
    )

/*++

Routine Description:

    Configure the default 82558 operating parameters

Arguments:

    nic - Points to the NIC data structure

Return Value:

    Status code

--*/

{
    // These values are copied directly from w2k driver.
    static const BYTE defaultParams[CONFIG_PARAM_COUNT] = {
        CONFIG_PARAM_COUNT,
        0x88, // 1: Tx and Rx FIFO limits
        0x00, // 2: no adaptive IFS
        0x01, // 3: MWI enable
        0x00, // 4: Rx DMA max count
        0x00, // 5: Tx DMA max count
        0x32, // 6: discard bad frames, extended stats, CNA intr, non-direct recv DMA
        0x03, // 7: 1 underrun retry, discard short frames
        0x01, // 8:
        0x00, // 9:
        0x2e, // 10: no loopback, 7 bytes preamble, no SA insertion
        0x00, // 11:
        0x60, // 12: inter-frame spacing (IFS) = 96 bit time
        0x00, // 13:
        0xf2, // 14:
        0xc8, // 15:
        0x00, // 16: 
        0x40, // 17:
        0xf2, // 18: padding enabled
        0x80, // 19: auto full-duplex
        0x3f, // 20:
        0x05  // 21:
    };

    // We assume the CU is idle and we can use
    // the entire shared command data buffer.
    ConfigCmdBlock* cmdblk = (ConfigCmdBlock*) nic->cmdbuf.start;

    CopyMem(cmdblk->params, defaultParams, CONFIG_PARAM_COUNT);
    return NicExecuteActionCmdAndWait(nic, (ActionCmdBlock*) cmdblk, ACTIONCMD_CONFIGURE);
}


PRIVATE NTSTATUS
NicCmdBufferInit(
    IfEnet* nic
    )

/*++

Routine Description:

    Initialize the shared command data buffer

Arguments:

    nic - Points to the NIC data structure

Return Value:

    Status code

--*/

{
    BYTE* buf;

    // Allocate a page and get its physical address
    buf = (BYTE*) NicAllocSharedMem(PAGE_SIZE);
    if (!buf) return NETERR_MEMORY;

    nic->cmdbuf.head = nic->cmdbuf.tail = nic->cmdbuf.start = buf;
    nic->cmdbuf.last = buf + PAGE_SIZE;
    nic->cmdbuf.phyaddrOffset = MmGetPhysicalAddress(buf) - (UINT_PTR) buf;

    return NETERR_OK;
}


PRIVATE NTSTATUS
NicStartCommandUnit(
    IfEnet* nic,
    ActionCmdBlock* cmdblk
    )

/*++

Routine Description:

    Start the 82558 CU (command unit) if it's idle

Arguments:

    nic - Points to the NIC data structure
    cmdblk - Points to the action command data block

Return Value:

    Status code

--*/

{
    PNIC_CSR csr = nic->CSR;
    INT cus = SCB_STAT_CUS(csr->cusRus);
    NTSTATUS status;

    // CU is active, do nothing
    if (cus != CUS_IDLE || (cmdblk->cmdstatus & CMDSTATUS_C))
        return NETERR_OK;

    // Wait for SCB and then issue CUC_START command
    status = NicWaitScb(csr);
    if (NT_SUCCESS(status)) {
        csr->scbGeneralPtr = CmdBufferGetPhyAddr(nic, cmdblk);
        csr->cucRuc = CUC_START;
    }
    return status;
}


PRIVATE VOID
NicEnqueueRecvBuffer(
    IfEnet* nic,
    Packet* pkt
    )

/*++

Routine Description:

    Queue up a packet in the receive queue

Arguments:

    nic - Points to the NIC data structure
    pkt - Points to the packet to be queue

Return Value:

    NONE

Notes:

    We maintain a queue of buffers to try to always keep
    the 82558 receive unit (RU) ready. The buffers are
    allocated for DMA transfer.

    After a packet is received, we pass it up to upper
    layer protocols. Those protocols are expected to
    process the packet as soon as possible and return
    the packet back to us with a CompletePacket call.

    When a packet is returned to us by the upper layer
    protocols, we'll put the packet back to the receive
    queue (unless we already have enough packets in the queue).

--*/

{
    Packet* q;
    RecvFrameDesc* rfd;

    //
    // Initialize the packet header fields
    //
    rfd = GetPktRFD(pkt);
    pkt->nextpkt = NULL;
    pkt->pktflags = PKTFLAG_DMA;
    pkt->data = (BYTE*) (rfd+1);
    pkt->datalen = 0;

    //
    // Initialize the RFD structure, which is stored in the first
    // 16 bytes of the packet buffer is used to store the RFD structure.
    // Note that we always use the simple mode.
    //
    rfd->cmdstatus = CMDFLAG_EL;
    rfd->rbdAddr = rfd->link = LINK_OFFSET_NULL;
    rfd->size = ENETHDRLEN + ENET_MAXDATASIZE;
    rfd->actualCount = 0;

    // Append the packet to the receive queue
    q = nic->recvq.tail;
    PktQInsertTail(&nic->recvq, pkt);

    if (q) {
        // Chain the previous RFD to the current one
        // and clear its EOL flag bit.
        rfd = GetPktRFD(q);
        rfd->link = GetPktRFDPhy(pkt);
        InterlockedAND(&rfd->cmdstatus, ~CMDFLAG_EL);
    }
}


PRIVATE VOID
NicRecvBufferPktCompletion(
    Packet* pkt,
    NTSTATUS status
    )

/*++

Routine Description:

    Receive packet completion routine

Arguments:

    pkt - Points to the packet being completed
    status - Completion status

Return Value:

    NONE

--*/

{
    // Insert the packet back into the receive queue
    NicEnqueueRecvBuffer((IfEnet*) pkt->recvifp, pkt);
}

    
PRIVATE NTSTATUS
NicRecvBufferInit(
    IfEnet* nic
    )

/*++

Routine Description:

    Initialize the receive packet queue

Arguments:

    nic - Points to the NIC data structure

Return Value:

    Status code

--*/

{
    NTSTATUS status;
    UINT index;
    Packet* pkt;
    
    status = NicPktPoolInit(cfgRecvQLength);
    if (!NT_SUCCESS(status)) {
        WARNING_("Couldn't allocate DMA receive buffers.");
        return status;
    }

    for (index=0; index < cfgRecvQLength; index++) {
        pkt = NicPktAlloc(index);
        pkt->recvifp = (IfInfo*) nic;
        XnetSetPacketCompletion(pkt, NicRecvBufferPktCompletion);
        NicEnqueueRecvBuffer(nic, pkt);
    }

    return NETERR_OK;
}


PRIVATE NTSTATUS
NicStartReceiveUnit(
    IfEnet* nic
    )

/*++

Routine Description:

    Start the 82558 RU (receive unit). We assume the RU is
    not in the ready state when this function is called.

Arguments:

    nic - Points to the NIC data structure

Return Value:

    Status code

--*/

{
    PNIC_CSR csr = nic->CSR;
    NTSTATUS status = NETERR_OK;

    while (SCB_STAT_RUS(csr->cusRus) != RUS_READY) {
        Packet* pkt = nic->recvq.head;

        if (GetPktRFD(pkt)->cmdstatus & CMDSTATUS_C) {
            // If the head of the receive buffer queue is completed
            // but not yet processed, process it first.
            NicProcessRecvInterrupt(nic);
        } else {
            UINT timeout;

            // Wait for SCB and then issue the RUC_START command
            status = NicWaitScb(csr);
            if (NT_SUCCESS(status)) {
                ASSERT(SCB_STAT_RUS(csr->cusRus) != RUS_READY);
                csr->scbGeneralPtr = GetPktRFDPhy(pkt);
                csr->cucRuc = RUC_START;

                // Wait until the RU to accept the command
                // BOGUS: the 80000 number came from w2k driver
                NicWaitScb(csr);
                timeout = 80000;
                while (timeout && SCB_STAT_RUS(csr->cusRus) != RUS_READY) {
                    timeout--;
                    KeStallExecutionProcessor(10);
                }

                if (timeout == 0)
                    status = NETERR_HARDWARE;
            }

            if (!NT_SUCCESS(status)) {
                WARNING_("Failed to start receiveer.");
            }

            break;
        }
    }

    return status;
}


PRIVATE WORD
NicReadEEPROM(
    volatile WORD* eepromCtrl,
    INT addr
    )

/*++

Routine Description:

    Read a WORD out of the 82558 EEPROM

Arguments:

    eepromCtrl - Address of the EEPROM control register
    addr - EEPROM location to be read

Return Value:

    WORD value read out of the EEPROM

--*/

// Wait for about 100us after toggling signals to the EEPROM
//  BOGUS: not sure why w2k driver picked this 100us number
#define WaitEEPROM() KeStallExecutionProcessor(100)

// Toggle EEPROM SK bit
#define RaiseEEPROMClock() \
        reg |= EEPROM_SK; \
        *eepromCtrl = reg; \
        WaitEEPROM()

#define LowerEEPROMClock() \
        reg &= ~EEPROM_SK; \
        *eepromCtrl = reg; \
        WaitEEPROM()

{
    INT bit;
    WORD reg, result;

    // start bit + opcode + address
    addr = (1 << 8) | (EEPROMOP_READ << 6) | (addr & 0x3f);

    //
    // Set EEPROM CS bit
    //
    reg = *eepromCtrl;
    reg &= ~(EEPROM_SK | EEPROM_DI | EEPROM_DO);
    reg |= EEPROM_CS;
    *eepromCtrl = reg;

    //
    // Shift out 9 bits - from MSB to LSB
    //
    for (bit=8; bit >= 0; bit--) {
        // Write EEPROM DI bit
        if (addr & (1 << bit))
            reg |= EEPROM_DI;
        else
            reg &= ~EEPROM_DI;
        *eepromCtrl = reg;
        WaitEEPROM();

        // Toggle EEPROM SK bit
        RaiseEEPROMClock();
        LowerEEPROMClock();
    }

    // EEPROM DO bit must be 0 at this point

    //
    // Read out 16 data bits
    //
    result = 0;
    reg &= ~EEPROM_DI;

    for (bit=0; bit < 16; bit++) {
        // Raise EEPROM SK bit
        // then read EEPROM DO bit
        // finally lower EEPROM SK bit

        RaiseEEPROMClock();

        result = (WORD) (result << 1);
        if (*eepromCtrl & EEPROM_DO)
            result |= 1;

        LowerEEPROMClock();
    }

    //
    // Deassert EEPROM CS bit
    //  BOGUS: not sure why we need to toggle the clock bit here
    //
    reg &= ~EEPROM_CS;
    *eepromCtrl = reg;
    RaiseEEPROMClock();
    LowerEEPROMClock();

    return result;
}


PRIVATE NTSTATUS
NicReadEnetAddr(
    IfEnet* nic
    )

/*++

Routine Description:

    Read permanent Ethernet address from the EEPROM

Arguments:

    nic - Points to the NIC data structure

Return Value:

    Status code

--*/

{
    volatile WORD* eepromCtrl;
    WORD* addr;

    eepromCtrl = &nic->CSR->eepromCtrl;
    addr = (WORD*) nic->hwaddr;

    addr[0] = NicReadEEPROM(eepromCtrl, 0);
    addr[1] = NicReadEEPROM(eepromCtrl, 1);
    addr[2] = NicReadEEPROM(eepromCtrl, 2);

    nic->hwaddrlen = ENETADDRLEN;
    return NETERR_OK;
}


VOID
NicReset(
    IfEnet* nic,
    BOOL disconnectIntr
    )

/*++

Routine Description:

    Reset the NIC (stop both command and receive units)
    Also disconnects the NIC interrupts.

Arguments:

    nic - Points to the NIC data structure
    disconnectIntr - Whether to disconnect NIC interrupts

Return Value:

    NONE

--*/

{
    if (!nic->CSR) return;

    nic->CSR->port = PORTCMD_SELECTIVE_RESET;
    KeStallExecutionProcessor(20);
    NicDisableInterrupt();

    // Clear pending interrupts
    nic->CSR->statAck = nic->CSR->statAck;

    if (disconnectIntr) {
        NicDisconnectInterrupt(nic);
    }
}


VOID
NicTimerProc(
    IfEnet* nic
    )

/*++

Routine Description:

    NIC interface timer routine

Arguments:

    nic - Points to the NIC data structure

Return Value:

    NONE

--*/

{
    BYTE cusRus = nic->CSR->cusRus;

    // NOTE:
    //  We shouldn't have to do any of the following
    //  under normal operations. Just being paranoid here.

    // If RU is idle, start it
    if (SCB_STAT_RUS(cusRus) != RUS_READY) {
        NicProcessRecvInterrupt(nic);
        NicStartReceiveUnit(nic);
    }

    // If CU is stuck, start or resume it
    if (!PktQIsEmpty(&nic->cmdq) && nic->cmdqWatchdog++ > 2) {
        Packet* pkt = nic->cmdq.head;
        ActionCmdBlock* cmdblk = GetPktCmdBlk(nic, pkt);

        WARNING_("Transmitter is stuck.");
        nic->cmdqWatchdog = 0;

        if ((cmdblk->cmdstatus & CMDSTATUS_C) || SCB_STAT_CUS(cusRus) != CUS_IDLE) {
            nic->CSR->cucRuc = CUC_RESUME;
        } else {
            NicStartCommandUnit(nic, cmdblk);
        }
    }
}


PRIVATE VOID*
NicCmdBufferReserve(
    IfEnet* nic,
    UINT count
    )

/*++

Routine Description:

    Reserve the requested number of bytes in the shared command buffer

Arguments:

    nic - Points to the NIC data structure
    count - Specifies the desired number of bytes

Return Value:

    Pointer to the first reserved byte in the command buffer
    NULL if the request cannot be satisfied (no space left)

--*/

{
    BYTE* addr;
    UINT freeCount;
    INT reclaim = 0;

    // We always allocate in 8-byte chunks
    ASSERT(count % CMDBUF_ALLOC_UNIT == 0);

retry: 

    if (nic->cmdbuf.tail >= nic->cmdbuf.head) {
        // we have the following case:
        //       head        tail
        //  |    xxxxxxxxxxxxx   |

        // first check to see if we have enough room at the end of the buffer
        if (count <= (freeCount = nic->cmdbuf.last - nic->cmdbuf.tail)) {
            // yes, reserve space at the end
            if (nic->cmdbuf.head > nic->cmdbuf.start) freeCount++;
            addr = nic->cmdbuf.tail;
        } else {
            freeCount = nic->cmdbuf.head - nic->cmdbuf.start;
            addr = nic->cmdbuf.start;
        }
    } else {
        // we have the following case:
        //      tail       head
        //  |xxxx           xxxxx|

        freeCount = nic->cmdbuf.head - nic->cmdbuf.tail;
        addr = nic->cmdbuf.tail;
    }

    //
    // If there is enough room, then return success.
    // Otherwise, try to process any pending CU interrupts
    // and reclaim the shared command buffer space.
    //
    if (count < freeCount) return addr;
    if (reclaim++ == 0 && NicProcessXmitInterrupt(nic, 0)) goto retry;

    WARNING_("Failed to allocate command buffer space.");
    return NULL;
}

//
// Commit the command buffer space previously reserved by NicCmdBufferReserve.
// The count parameter must be equal to or less than the original
// value passed to NicCmdBufferReserve.
//
INLINE VOID NicCmdBufferCommit(IfEnet* nic, VOID* addr, UINT count) {
    BYTE* tail = (BYTE*) addr + count;
    nic->cmdbuf.tail = (tail < nic->cmdbuf.last) ? tail : (tail-PAGE_SIZE);
}


PRIVATE NTSTATUS
NicEnqueueCmdBlock(
    IfEnet* nic,
    Packet* pkt,
    ActionCmdBlock* cmdblk,
    UINT cmdsize
    )

/*++

Routine Description:

    Queue up a command description block for execution

Arguments:

    nic - Points to the NIC data structure
    pkt - Points to the packet to be queued
    cmdblk - Points to the data for this command in the shared buffer
    cmdsize - Number of bytes taken by this command

Return Value:

    Status code

--*/

{
    Packet* q;

    // Keep a pointer to the command block in the packet
    cmdblk->link = LINK_OFFSET_NULL;
    SetPktCmdBlk(nic, pkt, cmdblk, cmdsize);

    // If the 82558 command unit is idle or suspended
    // and the command queue was empty, start or resume it here.
    if ((q = nic->cmdq.tail) == NULL) {
        NTSTATUS status = NicStartCommandUnit(nic, cmdblk);
        if (!NT_SUCCESS(status)) return status;
    }

    // Append this entry to the command queue
    NicCmdBufferCommit(nic, cmdblk, cmdsize);
    PktQInsertTail(&nic->cmdq, pkt);
    nic->cmdqCount++;

    // And modify the last command's link field
    // and clear its EOL flag.
    if (q != NULL) {
        ActionCmdBlock* lastcmd = GetPktCmdBlk(nic, q);
        lastcmd->link = CmdBufferGetPhyAddr(nic, cmdblk);
        InterlockedAND(&lastcmd->cmdstatus, ~CMDFLAG_EL);
    }
    return NETERR_OK;
}


VOID
NicWaitForXmitQEmpty(
    IfEnet* nic
    )

/*++

Routine Description:

    Wait until the transmit queue is empty
    This is only called by the debug monitor when the regular net stack is unloaded.

Arguments:

    nic - Points to the NIC data structure

Return Value:

    NONE

--*/

{
    UINT timeout = 0;
    while (!PktQIsEmpty(&nic->cmdq)) {
        NicProcessXmitInterrupt(nic, nic->CSR->statAck);
        KeStallExecutionProcessor(50);

        timeout++;
        ASSERT(timeout < 20000);
    }
}


PRIVATE BOOL
NicProcessXmitInterrupt(
    IfEnet* nic,
    BYTE statAck
    )

/*++

Routine Description:

    Process command completion interrupts

Arguments:

    nic - Points to the NIC data structure
    statAck - NIC interrupt status bits

Return Value:

    TRUE if any command was completed
    FALSE otherwise

--*/

{
    Packet* pkt;
    ActionCmdBlock* cmdblk;
    NTSTATUS status;
    BOOL processed = FALSE;

    // Loop through our command queue
    while ((pkt = nic->cmdq.head) != NULL) {
        // Stop when we encounter a command which hasn't completed yet
        cmdblk = GetPktCmdBlk(nic, pkt);
        if (!(cmdblk->cmdstatus & CMDSTATUS_C)) {
            if (processed || (statAck & SCB_STAT_CNA)) {
                //
                // HACK to take care of the following scenario:
                //  We appended an entry to the command queue and
                //  modified the link and EOL info in the previous
                //  command (inside function NicEnqueueCmdBlock). But
                //  CU could be completing the previous command just
                //  as we were modifying it. So it could end up in
                //  the idle state instead of starting to execute
                //  the new command.
                // 
                NicStartCommandUnit(nic, cmdblk);
            }
            break;
        }

        // Remove the completed command from the queue
        // and do any necessary post-processing.
        processed = TRUE;
        PktQRemoveHead(&nic->cmdq);
        nic->cmdqCount--;
        nic->cmdqWatchdog = 0;
        status = (cmdblk->cmdstatus & CMDSTATUS_OK) ?
                    NETERR_OK :
                    NETERR_HARDWARE;

        // Free up the space taken in the shared command data buffer
        if (PktQIsEmpty(&nic->cmdq)) {
            //
            // no more outstanding commands
            //  reset the command buffer to its default state
            //
            nic->cmdbuf.head =
            nic->cmdbuf.tail = nic->cmdbuf.start;
        } else {
            //
            // Notice that if there is a gap at the end of
            // the command data buffer after , the head pointer
            // won't be correctly updated here. But that's ok
            // because it'll be correct again after the next
            // command is completed.
            //
            nic->cmdbuf.head = (BYTE*) cmdblk + GetPktCmdBlkSize(nic, pkt);
            if (nic->cmdbuf.head >= nic->cmdbuf.last)
                nic->cmdbuf.head -= PAGE_SIZE;
        }
        NicUnlockPacketPages(pkt);
        COMPLETEPACKET(pkt, status);
    }

    return processed;
}


PRIVATE VOID
NicProcessRecvInterrupt(
    IfEnet* nic
    )

/*++

Routine Description:

    Process packet reception interrupts

Arguments:

    nic - Points to the NIC data structure

Return Value:

    NONE

--*/

{
    while (TRUE) {
        Packet* pkt = nic->recvq.head;
        RecvFrameDesc* rfd = GetPktRFD(pkt);
        UINT pktlen;
        
        // No more received packets
        if (!(rfd->cmdstatus & CMDSTATUS_C)) return;
        
        // Take the packet off the receive buffer queue
        PktQRemoveHead(&nic->recvq);

        if (rfd->cmdstatus & CMDSTATUS_OK) {
            //
            // If the packet was received without error, process it.
            //
            ASSERT(rfd->actualCount & RFD_EOF);
            ASSERT(rfd->actualCount & RFD_F);

            pkt->datalen = pktlen = (rfd->actualCount & RFD_CNTMASK);
            ASSERT(pktlen >= ENETHDRLEN + ENET_MINDATASIZE);

            EnetReceiveFrame(nic, pkt);
        } else {
            //
            // Bad reception: just recycle the packet back into
            // the receive buffer queue
            //
            NicEnqueueRecvBuffer(nic, pkt);
        }
    }
}


PRIVATE VOID
NicInterruptDpc(
    PKDPC dpc,
    IfEnet* nic,
    VOID* arg1,
    VOID* arg2
    )

/*++

Routine Description:

    Ethernet interface interrupt service routine
    (runs at DISPATCH_LEVEL)

Arguments:

    dpc - Pointer to the DPC object
    nic - Points to the NIC data structure
    arg1, arg2 - Unused arguments

Return Value:

    NONE

--*/

{
    PNIC_CSR csr = nic->CSR;
    BYTE statAck = csr->statAck;

    // Acknowledge pending interrupts
    csr->statAck = statAck;

    // Process any received packets
    NicProcessRecvInterrupt(nic);

    // Process any completed action commands
    if (!PktQIsEmpty(&nic->cmdq)) {
        NicProcessXmitInterrupt(nic, statAck);
    }

    // Start the receive unit if it has been stopped
    NicStartReceiveUnit(nic);

    // If there is more room now in the command queue, we can
    // move some packets from the send queue to the command queue.
    if (!EnetIsSendQEmpty(nic) && nic->cmdqCount < cfgXmitQLength) {
        EnetStartOutput(nic);
    }

    // Reenable interrupts
    NicEnableInterrupt();
}


PRIVATE BOOLEAN
NicIsr(
    PKINTERRUPT interrupt,
    IfEnet* nic
    )

/*++

Routine Description:

    Ethernet interrupt service routine (runs at DIRQL)

Arguments:

    interrupt - Interrupt object
    nic - Points to the NIC data structure

Return Value:

    TRUE if the interrupt was handled
    FALSE if the interrupt wasn't generated by our device

--*/

{
    if ((nic->CSR->intrMask & INTR_MASK_BIT) || !nic->CSR->statAck)
        return FALSE;

    // Yep, this is ours:
    //  schedule the DPC routine for execution
    //  and disable further interrupts
    KeInsertQueueDpc(&nic->dpc, NULL, NULL);
    NicDisableInterrupt();
    return TRUE;
}


VOID
NicTransmitFrame(
    IfEnet* nic,
    Packet* pkt
    )

/*++

Routine Description:

    Transmit an Ethernet frame to the NIC

Arguments:

    nic - Points to the NIC data structure
    pkt - Points to the frame to be transmitted
        We assume the Ethernet frame has been completed filled out
        and all the data are inside a single Packet structure.

Return Value:

    NONE

--*/

{
    NTSTATUS status;
    TransmitCmdBlock* txcb;
    TBDEntry* tbdArray;
    UINT tbdCount, cmdsize, len;
    UINT_PTR phyaddr0, phyaddr1;

    //
    // Lock the physical pages contain packet data
    //
    NicLockPacketPages(pkt);

    //
    // Allocate space in the shared command buffer:
    //  transmit command block followed by
    //  max number of transmission block descriptors
    //
    cmdsize = sizeof(TransmitCmdBlock) + sizeof(TBDEntry) * MAX_TBD_PER_XMIT;
    txcb = (TransmitCmdBlock*) NicCmdBufferReserve(nic, cmdsize);
    if (!txcb) {
        status = NETERR_MEMORY;
        goto exit;
    }

    // Make sure the packet is not too big
    ASSERT(pkt->datalen != 0);
    if (pkt->datalen > ENETHDRLEN+ENET_MAXDATASIZE) {
        status = NETERR_MSGSIZE;
        goto exit;
    }

    // Since the total buffer size is <= 1500+14 bytes,
    // it can at most span two physical pages.
    len = pkt->datalen;
    phyaddr0 = MmGetPhysicalAddress(pkt->data);
    phyaddr1 = MmGetPhysicalAddress(pkt->data + (len-1));

    tbdArray = (TBDEntry*) (txcb+1);
    tbdCount = 0;
    tbdArray[tbdCount].bufaddr = phyaddr0;

    if ((phyaddr1 - phyaddr0) == len-1) {
        // The buffer is physically contiguous.
        // We only need one TBD here.
        tbdArray[tbdCount++].bufsize = len;
    } else {
        // The buffer is not physically contiguous.
        // So we need two TBDs.
        UINT len0 = PAGE_SIZE - (phyaddr0 & (PAGE_SIZE-1));
        tbdArray[tbdCount++].bufsize = len0;
        tbdArray[tbdCount].bufaddr = phyaddr1 & ~(PAGE_SIZE-1);
        tbdArray[tbdCount++].bufsize = len - len0;
    }

    cmdsize = sizeof(TransmitCmdBlock) + sizeof(TBDEntry) * tbdCount;

    //
    // Fill out the TxCB (transmit command block) itself
    //
    txcb->cmdstatus =
        ACTIONCMD_TRANSMIT |    // transmit command
        CMDFLAG_EL |            // end-of-list
        CMDFLAG_I |             // interrupt after completion
        TxCBFLAG_SF;            // flexible mode

    txcb->tbdArray = CmdBufferGetPhyAddr(nic, tbdArray);
    txcb->byteCount = 0;        // no data bytes in the TxCB
    txcb->txThreshold = DEFAULT_Tx_THRESHOLD;
    txcb->tbdNumber = (BYTE) tbdCount;

    // Queue up the transmit command for execution
    status = NicEnqueueCmdBlock(nic, pkt, (ActionCmdBlock*) txcb, cmdsize);

exit:
    //
    // If we failed to insert the packet into the NIC's command queue,
    // complete the packet here with error status. This is because we
    // won't get a command-completion interrupt and do it then.
    //
    if (!NT_SUCCESS(status)) {
        WARNING_("NicTransmitFrame failed: 0x%x", status);
        NicUnlockPacketPages(pkt);
        COMPLETEPACKET(pkt, status);
    }
}


NTSTATUS
NicSetMcastAddrs(
    IfEnet* nic,
    const BYTE* addrs,
    UINT count
    )

/*++

Routine Description:

    Send multicast addresses down to the NIC.
    We assume the new list will replace the existing one.

Arguments:

    nic - Points to the NIC data structure
    addrs - Points to an array of multicast addresses
    count - Specifies the number of multicast addresses

Return Value:

    Status code

--*/

{
    McastSetupCmdBlock* mcastcmd;
    UINT cmdsize;
    Packet* pkt;
    NTSTATUS status;

    //
    // Reserve space in the shared command data buffer
    //
    cmdsize = offsetof(McastSetupCmdBlock, mcastAddrs) + count * ENETADDRLEN;
    cmdsize = ROUNDUP8(cmdsize);
    mcastcmd = (McastSetupCmdBlock*) NicCmdBufferReserve(nic, cmdsize);
    if (!mcastcmd) return NETERR_MEMORY;

    // Allocate a dummy packet for the command queue
    //  HACK: When the command finishes, CompletePacket is called.
    //  That ends up in the up-level Ethernet interface code.
    //  It'll just free the memory back to the system pool.
    pkt = SysAlloc0(PKTHDRLEN, PTAG_NIC);
    if (!pkt) return NETERR_MEMORY;

    pkt->data = pkt->buf;
    pkt->pktflags = (WORD)defaultPacketAllocFlag;
    NicLockPacketPages(pkt);

    //
    // Fill out the multicast setup command block
    //
    mcastcmd->cmdstatus =
        ACTIONCMD_MC_SETUP |
        CMDFLAG_EL |
        CMDFLAG_I;

    mcastcmd->mcastCount = (WORD) (count * ENETADDRLEN);
    if (count) {
        CopyMem(mcastcmd->mcastAddrs, addrs, count * ENETADDRLEN);
    }

    // Queue up the multicast setup command for execution
    status = NicEnqueueCmdBlock(nic, pkt, (ActionCmdBlock*) mcastcmd, cmdsize);
    if (!NT_SUCCESS(status)) {
        NicUnlockPacketPages(pkt);
        SysFree(pkt);
    }
    return status;
}


PRIVATE NTSTATUS
NicClaimHardware(
    IfEnet* nic
    )

/*++

Routine Description:

    Locate and claim the NIC adapter and
    map the NIC's CSR register into memory space

Arguments:

    nic - Points to the NIC data structure

Return Value:

    Status code

--*/

{
    NTSTATUS status;
    ULONG deviceCount = 1;
    PCI_DEVICE_DESCRIPTOR hwres;

    ZeroMem(&hwres, sizeof(hwres));
    hwres.Bus =
    hwres.Slot = 0xffffffff;
    hwres.VendorID = NIC_VENDORID;
    hwres.DeviceID = NIC_DEVICEID;
    hwres.BaseClass = PCI_CLASS_NETWORK_CTLR;
    hwres.SubClass = PCI_SUBCLASS_NET_ETHERNET_CTLR;
    hwres.ProgIf = 0xff;

    status = HalSetupPciDevice(&hwres, &deviceCount);
    if (!NT_SUCCESS(status)) {
        WARNING_("Couldn't find NIC adapter: 0x%x!", status);
        return NETERR_HARDWARE;
    }

    ASSERT(hwres.ResourceData.Address[0].Type == CmResourceTypeMemory);
    ASSERT(hwres.ResourceData.Address[0].u.Memory.Length >= sizeof(struct _NIC_CSR));

    NicCsr = nic->CSR = (PNIC_CSR) hwres.ResourceData.Address[0].u.Memory.TranslatedAddress;
    nic->csrSize = hwres.ResourceData.Address[0].u.Memory.Length;
    nic->intrVector = hwres.ResourceData.Interrupt.Vector;
    nic->intrIrql = hwres.ResourceData.Interrupt.Irql;

    return NETERR_OK;
}


VOID
NicCleanup(
    IfEnet* nic
    )

/*++

Routine Description:

    Cleanup the NIC interface

Arguments:

    nic - Points to the NIC data structure

Return Value:

    NONE

--*/

{
    // Clean up the command queue and the shared command data buffer
    while (!PktQIsEmpty(&nic->cmdq)) {
        Packet* pkt = PktQRemoveHead(&nic->cmdq);
        NicUnlockPacketPages(pkt);
        COMPLETEPACKET(pkt, NETERR_CANCELLED);
    }

    if (nic->cmdbuf.start) {
        NicFreeSharedMem(nic->cmdbuf.start);
        nic->cmdbuf.start = NULL;
    }

    // Clean up the receive buffer queue
    NicPktPoolCleanup();
    PktQInit(&nic->recvq);

    // Acknowledge pending interrupts
    if (NicCsr) {
        NicCsr->statAck = NicCsr->statAck;
        NicDisableInterrupt();
        NicDisconnectInterrupt(nic);

        // Unmap CSR from the virtual address space.
        MmUnmapIoSpace((VOID*) NicCsr, nic->csrSize);
        NicCsr = NULL;
    }
}


NTSTATUS
NicInitialize(
    IfEnet* nic
    )

/*++

Routine Description:

    Initialize the NIC "driver" code

Arguments:

    nic - Points to the NIC data structure

Return Value:

    Status code

--*/

{
    PNIC_CSR csr;
    NTSTATUS status = NETERR_HARDWARE;
    DWORD linkState;

    // Locate the NIC card and get the assigned resources
    status = NicClaimHardware(nic);
    if (!NT_SUCCESS(status)) goto err;
    csr = NicCsr;

    KeInitializeDpc(&nic->dpc, (PKDEFERRED_ROUTINE) NicInterruptDpc, nic);
    KeInitializeInterrupt(
        &NicIntrObject,
        (PKSERVICE_ROUTINE) NicIsr,
        nic,
        nic->intrVector,
        nic->intrIrql,
        LevelSensitive,
        TRUE);


    // Per 82558 manual, we should do a selective reset first
    // before doing a full software reset.
    csr->port = PORTCMD_SELECTIVE_RESET;
    KeStallExecutionProcessor(20);
    csr->port = PORTCMD_SOFTWARE_RESET;
    KeStallExecutionProcessor(20);

    // Interrupts are enabled after a reset.
    // So disable them here.
    NicDisableInterrupt();

    // Load CU and RU base to 0 (linear flat addressing)
    status = NicWaitScb(csr);
    if (!NT_SUCCESS(status)) goto err;
    csr->scbGeneralPtr = 0;
    csr->cucRuc = CUC_LOAD_CU_BASE;

    status = NicWaitScb(csr);
    if (!NT_SUCCESS(status)) goto err;
    csr->scbGeneralPtr = 0;
    csr->cucRuc = RUC_LOAD_RU_BASE;

    // Initialize the shared command data buffer
    // and the receive buffer queue
    status = NicCmdBufferInit(nic);
    if (!NT_SUCCESS(status)) goto err;
    status = NicRecvBufferInit(nic);
    if (!NT_SUCCESS(status)) goto err;

    // Read permanent Ethernet address from EEPROM
    status = NicReadEnetAddr(nic);
    if (!NT_SUCCESS(status)) goto err;

    // Configure the NIC parameters
    status = NicDoConfigureCmd(nic);
    if (!NT_SUCCESS(status)) goto err;

    // BOGUS: why in the world do we need to wait 500msec here?
    // The number is from win2k driver. But the NIC seems to work fine
    // if we take out the wait. The wait has also been taken out of the
    // current driver in Whistler.
    // KeStallExecutionProcessor(500000);

    // Set up the individual address
    status = NicDoIASetupCmd(nic);
    if (!NT_SUCCESS(status)) goto err;

    // Start the RU and enable interrupts
    status = NicStartReceiveUnit(nic);
    if (!NT_SUCCESS(status)) goto err;

    // Check if the Ethernet link is up
    PhyInitialize(FALSE, (VOID*) nic->CSR);
    linkState = PhyGetLinkState(FALSE);

    VERBOSE_("Ethernet link status: %s %dMbps %s-duplex",
        (linkState & XNET_LINK_IS_UP) ? "up" : "down",
        (linkState & XNET_LINK_100MBPS) ? 100 :
            (linkState & XNET_LINK_10MBPS) ? 10 : 0,
        (linkState & XNET_LINK_FULL_DUPLEX) ? "full" :
            (linkState & XNET_LINK_HALF_DUPLEX) ? "half" : "?");

    if (linkState & XNET_LINK_IS_UP)
        nic->flags |= IFFLAG_CONNECTED_BOOT;

    // Connect the NIC interrupt
    if (KeConnectInterrupt(&NicIntrObject))
        return NETERR_OK;

    status = STATUS_BIOS_FAILED_TO_CONNECT_INTERRUPT;

err:
    NicReset(nic, FALSE);
    NicCleanup(nic);
    return status;
}

#endif // SILVER
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\enet\sources.inc ===
!include ..\..\sources.inc

TARGETNAME=enet
TARGETPATH=obj
TARGETTYPE=LIBRARY

INCLUDES=..\;$(INCLUDES)

PRECOMPILED_INCLUDE=..\precomp.h

SOURCES=\
    ..\arp.c \
    ..\enet.c \
    ..\i82558.c \
    ..\xnic.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\enet\xnic.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    nic.c

Abstract:

    XBox network controller "driver" code

Revision History:

    07/25/2000 davidx
        Created it.

--*/

#include "precomp.h"

#ifndef SILVER
#include <xboxp.h>

//
// NIC driver global variables
//
UINT NicXmitDescCount;
BYTE* NicPktPoolBase;
UINT_PTR NicPktPoolPhyAddrOffset;
KINTERRUPT NicIntrObject;
BOOL NicDontCopyReceivedPacket;

PRIVATE VOID NicInterruptDpc(PKDPC, PVOID, PVOID, PVOID);

// BUGBUG: temporary workaround for nv2a snooping bug
#ifdef DVTSNOOPBUG
BYTE NicTempRecvBuffer[DMAPKT_SIZE];
PRIVATE VOID NicTempRecvBufferPktCompletion(Packet* pkt, NTSTATUS status) {}
#endif

//
// NIC statistics
//
typedef struct _XNICSTATS {
    ULONG isrCount;
    ULONG dpcCount;
    ULONG txGoodFrames;
    ULONG rxGoodFrames;
    ULONG txStuckXmits;
    ULONG txUnderflowErrors;
    ULONG txLateCollisions;
    ULONG txLostCarriers;
    ULONG txDefers;
    ULONG txExcessiveDefers;
    ULONG txRetryErrors;
    ULONG rxFramingErrors;
    ULONG rxOverFlowErrors;
    ULONG rxCrcErrors;
    ULONG rxLengthErrors;
    ULONG rxMaxFrameErrors;
    ULONG rxLateCollisions;
    ULONG rxRunts;
    ULONG rxExtraByteErrors;
    ULONG rxMissedFrames;
    ULONG rxEndOfFrameErrors;
} XNICSTATS;
XNICSTATS NicStats;

//
// Lock and unlock the physical pages containing packet data
//
INLINE VOID NicLockPacketPages(Packet* pkt) {
    MmLockUnlockBufferPages(pkt->data, pkt->datalen, FALSE);
}

INLINE VOID NicUnlockPacketPages(Packet* pkt) {
    MmLockUnlockBufferPages(pkt->data, pkt->datalen, TRUE);
}

//
// Where the received Ethernet frame data starts
//
#define GetPktFrameData(pkt) (&(pkt)->buf[RECVPKT_OVERHEAD])

//
// Receive packet completion routine
//
PRIVATE VOID NicRecvBufferPktCompletion(Packet* pkt, NTSTATUS status) {
    pkt->nextpkt = NULL;
    pkt->data = GetPktFrameData(pkt);
    pkt->pktflags = PKTFLAG_DMA;
}


PRIVATE VOID
NicStopXmitRecv(
    IfEnet* nic,
    INT handleIntr
    )

/*++

Routine Description:

    Stop the controller from receiving and transmitting

Arguments:

    nic - Points to the NIC data structure
    handleIntr - Whether to handle the pending interrupts
        > 0 : disable and then handle interrupts
        = 0 : disable interrupts
        < 0 : leave interrupts alone

Return Value:

    NONE

--*/

{
    PNIC_CSR csr = nic->CSR;
    INT timeout;

    // Turn off the transmitter and receiver
    csr->rx_poll = 0;
    csr->rx_en = 0;
    csr->tx_en = 0;

    // Wait for a max of 5msec until both 
    // the transmitter and receiver are idle
    for (timeout=500; timeout--; ) {
        if (!(csr->rx_sta & RXSTA_BUSY) &&
            !(csr->tx_sta & TXSTA_BUSY))
            break;
        KeStallExecutionProcessor(10);
    }

    // Ensure there is no active DMA transfer in progress
    csr->mode = MODE_DISABLE_DMA;
    for (timeout=500; timeout--; ) {
        if (csr->mode & MODE_DMA_IDLE) break;
        KeStallExecutionProcessor(10);
    }
    csr->mode = 0;

    if (handleIntr >= 0) {
        // Disable interrupts and
        // handle any pending interrupts if requested
        NicDisableInterrupt();

        if (handleIntr > 0) {
            NicInterruptDpc(&nic->dpc, nic, nic, NULL);
        }
    }
}


//
// Start the transmitter and receiver
//
INLINE VOID NicStartXmitRecv(PNIC_CSR csr, DWORD rxpoll_freq) {
    csr->rx_poll = RXPOLL_EN | rxpoll_freq;
    csr->tx_en = TXEN_ENABLE;
    csr->rx_en = RXEN_ENABLE;
    csr->mode = MODE_TXDM;
}

PRIVATE VOID
NicProcessRecvInterrupt(
    IfEnet* nic
    )

/*++

Routine Description:

    Process receive interrupts

Arguments:

    nic - Points to the NIC data structure

Return Value:

    NONE

--*/

{
    NicBufDesc* bufdesc = nic->cmdbuf.rxptr;
    Packet* pkt;
    DWORD flags_count;

    // Looping until we ran into a receive descriptor
    // that's still owned by the controller
    while (!((flags_count = bufdesc->flags_count) & RXDESC_OWN)) {
        pkt = PktQRemoveHead(&nic->recvq);
        if (flags_count & RXDESC_REND) {
            //
            // NOTE: Workaround for hardware bug
            //  Framing errors are ignored.
            //
            if (!(flags_count & RXDESC_ERR) || (flags_count & RXDESC_FRAM)) {
                //
                // A packet was received successfully.
                // Pass it upstream for processing.
                //
                // Note: we expect the processing to be done
                // synchronously here and the upstream component
                // we'll call CompletePacket on our packet
                // inside the following call.
                //

                NicStats.rxGoodFrames++;
                pkt->datalen = flags_count & 0xffff;

                // NOTE: Workaround for hardware bug
                //  If extra byte flag is set, decrement the frame length by 1
                if (flags_count & RXDESC_FRAM) {
                    NicStats.rxFramingErrors++;
                    if (flags_count & RXDESC_EXTRA) {
                        NicStats.rxExtraByteErrors++;
                        pkt->datalen--;
                    }
                }

                // BUGBUG: workaround for nv2a hardware bug
                #ifndef DVTSNOOPBUG

                EnetReceiveFrame(nic, pkt);

                #else // DVTSNOOPBUG

                {
                    UINT len = pkt->datalen;
                    Packet* p = (Packet*) NicTempRecvBuffer;

                    p->nextpkt = NULL;
                    p->pktflags = p->iphdrOffset = 0;
                    p->data = p->buf;
                    p->datalen = len;
                    p->recvifp = (IfInfo*) nic;
                    p->completionCallback = NicTempRecvBufferPktCompletion;
                    memcpy(p->data, pkt->data, len);

                    NicRecvBufferPktCompletion(pkt, NETERR_OK);
                    EnetReceiveFrame(nic, p);
                }

                #endif // DVTSNOOPBUG
            } else {
                if (flags_count & RXDESC_OFOL) NicStats.rxOverFlowErrors++;
                if (flags_count & RXDESC_CRC ) NicStats.rxCrcErrors++;
                if (flags_count & RXDESC_LFER) NicStats.rxLengthErrors++;
                if (flags_count & RXDESC_MAX ) NicStats.rxMaxFrameErrors++;
                if (flags_count & RXDESC_LCOL) NicStats.rxLateCollisions++;
                if (flags_count & RXDESC_RUNT) NicStats.rxRunts++;
            }
        } else {
            NicStats.rxEndOfFrameErrors++;
        }

        // Give the ownership of the receive descriptor back to the NIC
        // And tell the receiver to check the receive descriptor ring
        ASSERT(bufdesc->phyaddr == MmGetPhysicalAddress(pkt->data));
        PktQInsertTail(&nic->recvq, pkt);
        bufdesc->flags_count = RXDESC_OWN | (DMAPKT_MAXDATA - 1);

        // Move on to the next receive descriptor
        if (++bufdesc == nic->cmdbuf.rxend)
            bufdesc = nic->cmdbuf.rxstart;
    }

    // Update the next receive descriptor pointer
    nic->cmdbuf.rxptr = bufdesc;
}


PRIVATE VOID
NicCheckMiiStatus(
    IfEnet* nic,
    DWORD mintr,
    BOOL init
    )

/*++

Routine Description:

    Check the PHY status

Arguments:

    nic - Points to the NIC data structure
    mintr - MII interrupt bits
    init - Whether this is the first call after reboot
        (Tx and Rx are currently stopped)

Return Value:

    NONE

--*/

{
    PNIC_CSR csr = nic->CSR;
    DWORD miics = csr->mii_cs;
    DWORD delta = nic->linkStatus ^ miics;

    if (init || ((mintr & MINTR_MAPI) && (delta & MIICS_LS) && (miics & MIICS_LS))) {
        DWORD linkState = PhyGetLinkState(!init);

        // BUGBUG: always dump out Ethernet link status for now
        #if DBG
        DbgPrint("Ethernet link status: %s %dMbps %s-duplex\n",
            (linkState & XNET_LINK_IS_UP) ? "up" : "down",
            (linkState & XNET_LINK_100MBPS) ? 100 :
                (linkState & XNET_LINK_10MBPS) ? 10 : 0,
            (linkState & XNET_LINK_FULL_DUPLEX) ? "full" :
                (linkState & XNET_LINK_HALF_DUPLEX) ? "half" : "?");
        #endif

        // NOTE: When the link was up before, we need to stop
        // both Tx and Rx and then set Rx polling frequency
        // and Tx duplex mode according to the link status.

        if (!init) {
            NicStopXmitRecv(nic, -1);
        }

        nic->rxpollFreq = (linkState & XNET_LINK_10MBPS) ?
                                RXPOLL_FREQ_10MPS :
                                RXPOLL_FREQ_100MPS;

        if (linkState & XNET_LINK_FULL_DUPLEX)
            csr->tx_cntl &= ~TXCNTL_HDEN;
        else
            csr->tx_cntl |= TXCNTL_HDEN;

        if (!init) {
            NicStartXmitRecv(csr, nic->rxpollFreq);
        }

        if (init && (linkState & XNET_LINK_IS_UP))
            nic->flags |= IFFLAG_CONNECTED_BOOT;
    }

    nic->linkStatus = miics;
}


//
// Check if transmit descriptor td2 is the last one used
// to transmit an Ethernet frame that started at td1.
//
INLINE BOOL IsEndXmitDesc(IfEnet* nic, NicBufDesc* td1, NicBufDesc* td2) {
    if (td1 == td2) return TRUE;
    if (td1->flags_count & TXDESC_TEND) return FALSE;
    if (++td1 == nic->cmdbuf.txend)
        td1 = nic->cmdbuf.txstart;
    return (td1 == td2);
}


PRIVATE BOOL
NicProcessXmitInterrupt(
    IfEnet* nic
    )

/*++

Routine Description:

    Process transmit interrupts

Arguments:

    nic - Points to the NIC data structure

Return Value:

    TRUE if we processed any transmit completion interrupts
    FALSE otherwise

--*/

{
    NicBufDesc* bufdesc;
    Packet* pkt;
    DWORD flags_count;
    NTSTATUS status;
    BOOL processed = FALSE;
    
    // Loop through uncompleted transmission queue
    while (pkt = nic->cmdq.head) {
        bufdesc = (NicBufDesc*) pkt->ifdata;
        if ((flags_count = bufdesc->flags_count) & TXDESC_OWN) break;

        processed = TRUE;
        PktQRemoveHead(&nic->cmdq);
        nic->cmdqCount--;
        nic->cmdqWatchdog = 0;
        NicUnlockPacketPages(pkt);

        ASSERT(flags_count & TXDESC_TEND);
        if (!(flags_count & TXDESC_ERR)) {
            NicStats.txGoodFrames++;
            status = NETERR_OK;
        } else {
            if (flags_count & TXDESC_UFLO) NicStats.txUnderflowErrors++;
            if (flags_count & TXDESC_LCOL) NicStats.txLateCollisions++;
            if (flags_count & TXDESC_LCAR) NicStats.txLostCarriers++;
            if (flags_count & TXDESC_DEF) NicStats.txDefers++;
            if (flags_count & TXDESC_EXDEF) NicStats.txExcessiveDefers++;
            if (flags_count & TXDESC_RTRY) NicStats.txRetryErrors++;

            status = NETERR_HARDWARE;
        }
        COMPLETEPACKET(pkt, status);

        // Update the uncompleted transmit descriptor pointer
        ASSERT(IsEndXmitDesc(nic, nic->cmdbuf.txtail, bufdesc));
        ASSERT((nic->cmdbuf.txtail->flags_count & TXDESC_OWN) == 0);
        bufdesc++;
        nic->cmdbuf.txtail = (bufdesc == nic->cmdbuf.txend) ? nic->cmdbuf.txstart : bufdesc;
    }

    return processed;
}


VOID
NicWaitForXmitQEmpty(
    IfEnet* nic
    )

/*++

Routine Description:

    Wait until the transmit queue is empty
    This is only called by the debug monitor when the regular net stack is unloaded.

Arguments:

    nic - Points to the NIC data structure

Return Value:

    NONE

--*/

{
    UINT timeout = 0;
    while (!PktQIsEmpty(&nic->cmdq)) {
        NicProcessXmitInterrupt(nic);
        KeStallExecutionProcessor(50);

        timeout++;
        ASSERT(timeout < 20000);
    }
}


PRIVATE VOID
NicInterruptDpc(
    PKDPC dpc,
    PVOID deferredContext,
    PVOID noReenable,
    PVOID arg2
    )

/*++

Routine Description:

    Ethernet interface interrupt service routine
    (runs at DISPATCH_LEVEL)

Arguments:

    dpc - Pointer to the DPC object
    deferredContext - Points to the NIC data structure
    noReenable - Leave interrupts disabled
    arg2 - Unused arguments

Return Value:

    NONE

--*/

{
    IfEnet* nic = (IfEnet*) deferredContext;
    PNIC_CSR csr = nic->CSR;

    NicStats.dpcCount++;
    while (TRUE) {
        DWORD mintr = csr->mintr;
        DWORD intr = csr->intr;

        // Acknowledge all pending interrupts
        //  note that we need to acknowledge MII interrupts first
        if (intr == 0) break;
        csr->mintr = mintr;
        csr->intr = intr;

        if (intr & INTR_MINT) {
            // Process MII interrupt
            NicCheckMiiStatus(nic, mintr, FALSE);
        }

        if (intr & (INTR_MISS|INTR_RCINT|INTR_REINT)) {
            // Process any received packets
            NicProcessRecvInterrupt(nic);
            if (intr & INTR_MISS) {
                csr->mode = MODE_RXDM;
                NicStats.rxMissedFrames++;
            }
        }

        if (intr & (INTR_TCINT|INTR_TEINT)) {
            // Process any completed transmissions
            NicProcessXmitInterrupt(nic);

            // If there is more room now in the command queue, we can
            // move some packets from the send queue to the command queue.
            if (!EnetIsSendQEmpty(nic) && nic->cmdqCount < cfgXmitQLength) {
                EnetStartOutput(nic);
            }
        }
    }

    // Reenable interrupts
    if (!noReenable) {
        NicEnableInterrupt();
    }
}


PRIVATE BOOLEAN
NicIsr(
    PKINTERRUPT interrupt,
    PVOID serviceContext
    )

/*++

Routine Description:

    Ethernet interrupt service routine (runs at DIRQL)

Arguments:

    interrupt - Interrupt object
    serviceContext - Points to the NIC data structure

Return Value:

    TRUE if the interrupt was handled
    FALSE if the interrupt wasn't generated by our device

--*/

{
    IfEnet* nic = (IfEnet*) serviceContext;

    NicStats.isrCount++;
    if ((nic->CSR->intr & nic->CSR->intr_mk) == 0)
        return FALSE;

    // Yep, this is ours:
    //  schedule the DPC routine for execution
    //  and disable further interrupts
    KeInsertQueueDpc(&nic->dpc, NULL, NULL);
    NicDisableInterrupt();
    return TRUE;
}


VOID
NicTimerProc(
    IfEnet* nic
    )

/*++

Routine Description:

    NIC timer procedure

Arguments:

    nic - Points to the NIC data structure

Return Value:

    NONE

--*/

{
    // If the transmitter is stuck, start it
    if (!PktQIsEmpty(&nic->cmdq) && nic->cmdqWatchdog++ > 2) {
        WARNING_("Transmitter is stuck.");
        nic->cmdqWatchdog = 0;
        NicStats.txStuckXmits++;

        NicProcessXmitInterrupt(nic);
        nic->CSR->mode = MODE_TXDM;
    }
}


VOID
NicTransmitFrame(
    IfEnet* nic,
    Packet* pkt
    )

/*++

Routine Description:

    Transmit an Ethernet frame to the NIC

Arguments:

    nic - Points to the NIC data structure
    pkt - Points to the frame to be transmitted
        We assume the Ethernet frame has been completed filled out.

Return Value:

    NONE

--*/

{
    UINT_PTR phyaddr0;
    UINT len, len0;
    NicBufDesc* bufdesc;

    // Make sure we have at least 2 transmit descriptors available
    len = (nic->cmdbuf.txtail <= nic->cmdbuf.txhead) ?
            (NicXmitDescCount - (nic->cmdbuf.txhead - nic->cmdbuf.txtail)) :
            (nic->cmdbuf.txtail - nic->cmdbuf.txhead);
    
    if (len <= 2) {
        WARNING_("Out of transmit descriptors.");
        COMPLETEPACKET(pkt, NETERR_MEMORY);
        return;
    }

    // Check the packet data size
    ASSERT(pkt->datalen != 0);
    if (pkt->datalen > ENETHDRLEN+ENET_MAXDATASIZE) {
        COMPLETEPACKET(pkt, NETERR_MSGSIZE);
        return;
    }

    NicLockPacketPages(pkt);

    // Since the total buffer size is <= 1500+14 bytes,
    // it can at most span two physical pages.
    len = pkt->datalen;
    phyaddr0 = MmGetPhysicalAddress(pkt->data);
    len0 = PAGE_SIZE - (phyaddr0 & (PAGE_SIZE-1));

    if (len <= len0) {
        // The buffer is in a single physical page.
        // We only need one transmit descriptor here.
        //
        // Notice the funny len-1 business below.
        // This is an odd requirement of the NIC.
        bufdesc = nic->cmdbuf.txhead;
        bufdesc->phyaddr = phyaddr0;
        bufdesc->flags_count = TXDESC_OWN | TXDESC_TEND | (len-1);
    } else {
        // The buffer straddles page boundary.
        // So we need two transmit descriptors.
        NicBufDesc* bufdesc0 = nic->cmdbuf.txhead;

        bufdesc = bufdesc0+1;
        if (bufdesc == nic->cmdbuf.txend)
            bufdesc = nic->cmdbuf.txstart;

        // NOTE: We're setting up the second transmit descriptor
        // before the first one. Otherwise, the NIC might use up
        // the first descriptor before we have the second one ready.
        bufdesc->phyaddr = MmGetPhysicalAddress(pkt->data + len0);
        bufdesc->flags_count = TXDESC_OWN | TXDESC_TEND | (len-len0-1);
        bufdesc0->phyaddr = phyaddr0;
        bufdesc0->flags_count = TXDESC_OWN | (len0-1);
    }

    pkt->ifdata = (UINT_PTR) bufdesc;
    PktQInsertTail(&nic->cmdq, pkt);
    nic->cmdqCount++;

    // Tell the transmitter to check the transmit descriptor ring
    nic->CSR->mode = MODE_TXDM;

    bufdesc++;
    nic->cmdbuf.txhead = (bufdesc == nic->cmdbuf.txend) ? nic->cmdbuf.txstart : bufdesc;
}


//
// Tell the NIC to not to receive any multicast frames
//
INLINE VOID NicRecvMcastNone(PNIC_CSR csr) {
    csr->mult_mk0 = 0;
    csr->mult_mk1 = 0;
    csr->mult0 = 1;
    csr->mult1 = 0;
}


NTSTATUS
NicSetMcastAddrs(
    IfEnet* nic,
    const BYTE* addrs,
    UINT count
    )

/*++

Routine Description:

    Send multicast addresses down to the NIC.

Arguments:

    nic - Points to the NIC data structure
    addrs - Points to an array of multicast addresses
    count - Specifies the number of multicast addresses

Return Value:

    Status code

--*/

// Converting Ethernet address from a sequence of bytes
// to two DWORDs that can be set into UNIn and MULTn registers
#define HWADDR0(_hwaddr) ((const DWORD*) (_hwaddr))[0]
#define HWADDR1(_hwaddr) ((const WORD*) (_hwaddr))[2]

{
    PNIC_CSR csr = nic->CSR;

    // Stop the controller from transmitting and receiving
    NicStopXmitRecv(nic, 1);

    if (count == 0) {
        // Don't receive any multicast frames
        NicRecvMcastNone(csr);
    } else {
        // Compute the multicast address filter values.
        // Notice that the filtering here is not perfect.
        // Exactly filtering is done inside IP receive function.

        DWORD andMask0 = -1;
        DWORD orMask0 = 0;
        WORD andMask1 = -1;
        WORD orMask1 = 0;

        while (count--) {
            andMask0 &= HWADDR0(addrs);
            orMask0  |= HWADDR0(addrs);
            andMask1 &= HWADDR1(addrs);
            orMask1  |= HWADDR1(addrs);
            addrs += ENETADDRLEN;
        }

        orMask0 = andMask0 | ~orMask0;
        orMask1 = andMask1 | ~orMask1;

        csr->mult0 = andMask0;
        csr->mult1 = andMask1;
        csr->mult_mk0 = orMask0;
        csr->mult_mk1 = orMask1;
    }

    // Restart transmitter and receiver
    NicStartXmitRecv(csr, nic->rxpollFreq);
    NicEnableInterrupt();
    return NETERR_OK;
}


VOID
NicReset(
    IfEnet* nic,
    BOOL disconnectIntr
    )

/*++

Routine Description:

    Reset the network controller:
        disable transmit and receive
        disable all interrupts
        clear any pending interrupt bits

Arguments:

    nic - Points to the NIC data structure
    disconnectIntr - Whether to disconnect interrupts

Return Value:

    NONE

--*/

{
    PNIC_CSR csr = nic->CSR;

    // Stop transmitter and receiver
    NicStopXmitRecv(nic, 0);
    
    // Reset buffer management
    csr->mode = MODE_RESET_BUFFERS;
    KeStallExecutionProcessor(10);
    csr->mode = 0;
    KeStallExecutionProcessor(10);

    csr->intr_mk = 0;
    csr->mintr_mk = 0;
    csr->pm_cntl = 0;
    csr->swtr_cntl = 0;
    csr->tx_poll = 0;
    csr->rx_poll = 0;

    csr->tx_sta = csr->tx_sta;
    csr->rx_sta = csr->rx_sta;
    csr->intr = csr->intr;
    csr->mintr = csr->mintr;

    if (disconnectIntr) {
        NicDisconnectInterrupt(nic);
    }
}


PRIVATE NTSTATUS
NicInitBuffers(
    IfEnet* nic
    )

/*++

Routine Description:

    Initialize transmit and receive buffer descriptors

Arguments:

    nic - Points to the NIC data structure

Return Value:

    Status code

--*/

{
    BYTE* buf;
    NicBufDesc* bufdesc;
    UINT index;
    Packet* pkt;
    NTSTATUS status;

    status = NicPktPoolInit(cfgRecvQLength);
    if (!NT_SUCCESS(status)) return status;
    
    // Allocate one contiguous physical page
    buf = (BYTE*) NicAllocSharedMem(PAGE_SIZE);
    if (!buf) return NETERR_MEMORY;
    
    ZeroMem(buf, PAGE_SIZE);
    nic->cmdbuf.phyaddrOffset = MmGetPhysicalAddress(buf) - (UINT_PTR) buf;

    // First half page is used for transmit buffer descriptors
    nic->cmdbuf.txstart = (NicBufDesc*) buf;
    nic->cmdbuf.txend = nic->cmdbuf.txstart + NicXmitDescCount;
    nic->cmdbuf.txhead = nic->cmdbuf.txtail = nic->cmdbuf.txstart;

    // Second half page is used for receive buffer descriptors
    nic->cmdbuf.rxstart = (NicBufDesc*) (buf + PAGE_SIZE / 2);
    nic->cmdbuf.rxend = nic->cmdbuf.rxstart + cfgRecvQLength;
    nic->cmdbuf.rxptr = nic->cmdbuf.rxstart;

    // Allocate receive buffers
    bufdesc = nic->cmdbuf.rxstart;
    for (index=0; index < cfgRecvQLength; index++) {
        pkt = NicPktAlloc(index);
        pkt->data = GetPktFrameData(pkt);
        pkt->recvifp = (IfInfo*) nic;
        XnetSetPacketCompletion(pkt, NicRecvBufferPktCompletion);
        PktQInsertTail(&nic->recvq, pkt);

        bufdesc->phyaddr = NicPktGetPhyAddr(pkt->data);
        bufdesc->flags_count = RXDESC_OWN | (DMAPKT_MAXDATA - 1);
        bufdesc++;
    }

    return NETERR_OK;
}


PRIVATE NTSTATUS
NicReadEnetAddr(
    IfEnet* nic
    )

/*++

Routine Description:

    Read permanent Ethernet address

Arguments:

    nic - Points to the NIC data structure

Return Value:

    Status code

--*/

{
    DWORD err;
    ULONG type, size, tick0;

    err = XQueryValue(XC_FACTORY_ETHERNET_ADDR, &type, nic->hwaddr, ENETADDRLEN, &size);
    if (err != ERROR_SUCCESS || size != ENETADDRLEN) {
        // NOTE:
        // If we failed to read Ethernet address from non-volatile memory,
        // pick a random address among the first 32 addresses of
        // the 00-50-f2 address block. This is so that we can at least boot
        // on the manufacturing line and start communicating with the test server.

        #ifdef DEVKIT
        DbgPrint("########## Invalid Ethernet address:\n");
        DbgPrint("  You must run the Recovery CD.\n");
        DbgPrint("  Defaulting to hardcoded Ethernet address...\n");
        #endif

        __asm {
            rdtsc
            mov tick0, eax
        }

        nic->hwaddr[0] = 0x00;
        nic->hwaddr[1] = 0x50;
        nic->hwaddr[2] = 0xf2;
        nic->hwaddr[3] = 0x00;
        nic->hwaddr[4] = 0x00;
        nic->hwaddr[5] = (BYTE) (tick0 & 0x1f);
    }

    nic->hwaddrlen = ENETADDRLEN;
    return NETERR_OK;
}


VOID
NicCleanup(
    IfEnet* nic
    )

/*++

Routine Description:

    Cleanup the NIC interface

Arguments:

    nic - Points to the NIC data structure

Return Value:

    NONE

--*/

{
    // Clean up the command queue and the shared command data buffer
    while (!PktQIsEmpty(&nic->cmdq)) {
        Packet* pkt = PktQRemoveHead(&nic->cmdq);
        NicUnlockPacketPages(pkt);
        COMPLETEPACKET(pkt, NETERR_CANCELLED);
    }

    // Clean up the receive buffer queue
    NicPktPoolCleanup();
    PktQInit(&nic->recvq);

    if (nic->cmdbuf.txstart) {
        NicFreeSharedMem(nic->cmdbuf.txstart);
        nic->cmdbuf.txstart = NULL;
    }

    NicDisconnectInterrupt(nic);
}


NTSTATUS
NicInitialize(
    IfEnet* nic
    )

/*++

Routine Description:

    Initialize the NIC "driver" code

Arguments:

    nic - Points to the NIC data structure

Return Value:

    Status code

--*/

{
    PNIC_CSR csr = NicCsr;
    NTSTATUS status = NETERR_HARDWARE;

    // NicXmitDescCount must be > 2*cfgXmitQLength and < PAGE_SIZE/(2*8)
    NicXmitDescCount = 2*cfgXmitQLength+1;
    if (NicXmitDescCount < 64) NicXmitDescCount = 64;
    ASSERT(NicXmitDescCount < PAGE_SIZE/(2*sizeof(NicBufDesc)));

    // Locate the NIC card and get the assigned resources
    nic->CSR = (PNIC_CSR) XPCICFG_NIC_MEMORY_REGISTER_BASE_0;
    nic->csrSize = XPCICFG_NIC_MEMORY_REGISTER_LENGTH_0;
    nic->intrVector = HalGetInterruptVector(XPCICFG_NIC_IRQ, &nic->intrIrql);

    KeInitializeDpc(&nic->dpc, NicInterruptDpc, nic);
    KeInitializeInterrupt(
        &NicIntrObject,
        NicIsr,
        nic,
        nic->intrVector,
        nic->intrIrql,
        LevelSensitive,
        TRUE);

    // Reset the NIC
    NicReset(nic, FALSE);

    // Initialize transmit and receive buffers
    status = NicInitBuffers(nic);
    if (!NT_SUCCESS(status)) goto err;

    // Read permanent Ethernet address
    status = NicReadEnetAddr(nic);
    if (!NT_SUCCESS(status)) goto err;

    nic->rxpollFreq = RXPOLL_FREQ_100MPS;
    csr->uni0 = HWADDR0(nic->hwaddr);
    csr->uni1 = HWADDR1(nic->hwaddr);
    
    // Disable multicast frame reception by default
    NicRecvMcastNone(csr);

    // Setup transmitter and receiver
    // NOTE: nVidia NIC somehow expects the maximum
    // receive buffer size is 1518 instead of 1514.
    ASSERT(DMAPKT_MAXDATA > 1518);
    csr->rx_cntl_1 = 1518;
    csr->rx_cntl_0 = RXCNTL_DEFAULT;
    csr->tx_cntl = TXCNTL_DEFAULT;

    csr->bkoff_cntl = BKOFFCNTL_DEFAULT;
    csr->tx_def = TXDEF_DEFAULT;
    csr->rx_def = RXDEF_DEFAULT;

    csr->tx_dadr = NicBufPhyAddr(nic, nic->cmdbuf.txhead);
    csr->rx_dadr = NicBufPhyAddr(nic, nic->cmdbuf.rxptr);
    csr->dlen = ((cfgRecvQLength-1) << 16) | (NicXmitDescCount-1);
    csr->rx_fifo_wm = RXFIFOWM_DEFAULT;
    csr->tx_fifo_wm = TXFIFOWM_DEFAULT;

    // Enable MII auto-polling interrupt
    csr->mii_cs = MIICS_DEFAULT;
    csr->mii_tm = MIITM_DEFAULT;
    csr->mintr_mk = MINTR_MAPI;

    // Initialize the PHY
    csr->mii_cs &= ~MIICS_APEN;
    status = PhyInitialize(FALSE, NULL);
    csr->mii_cs |= MIICS_APEN;
    if (!NT_SUCCESS(status)) goto err;

    NicCheckMiiStatus(nic, 0, TRUE);

    // Enable transmit and receive
    NicStartXmitRecv(csr, nic->rxpollFreq);

    // Connect the NIC interrupt
    if (KeConnectInterrupt(&NicIntrObject))
        return NETERR_OK;

    status = STATUS_BIOS_FAILED_TO_CONNECT_INTERRUPT;

err:
    NicReset(nic, FALSE);
    NicCleanup(nic);
    return status;
}

#endif // !SILVER
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\enet\xnic.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    nic.h

Abstract:

    XBox Ethernet controller related declarations
    Refer to Medium Access Controller hardware spec for more info.

Revision History:

    07/24/2000 davidx
        Created it.

--*/

#ifndef _XNIC_H
#define _XNIC_H

//
// Nvidia PCI vendor and device ID
//
#define NIC_VENDORID 0x10DE
#define NIC_DEVICEID 0x01C3

//
// Receive and transmit descriptor
//
typedef struct _NicBufDesc {
    DWORD phyaddr;
        // physical address of the rx or tx buffer

    DWORD flags_count;
        // bit 31-16: control and status bits (see below)
        // bit 15-0: byte count (for tx, set to actual count - 1)
} NicBufDesc;

// Receive control and status bits
//  bit 31 (OWN):
//      0 - host owns the descriptor
//      1 - controller owns the descriptor
//  bit 30 (ERR): a receive error
//  bit 29 (FRAM): framing error
//  bit 28 (OFOL): overflow error
//  bit 27 (CRC): CRC error
//  bit 26 (LFER): length field error
//  bit 25 (MAX): received frame is larger than the max frame size
//  bit 24 (LCOL): late collision
//  bit 23 (RUNT): runt packet received
//  bit 22 (PAM): physical address match
//  bit 21 (MAM): multicast address match
//  bit 20 (BAM): broadcast address match
//  bit 19: reserved
//  bit 18 (EXTRA): received frame length has an extra byte
//  bit 17 (MISS): missed data reception
//  bit 16 (REND): end of receive frame

#define RXDESC_OWN      BIT(31)
#define RXDESC_ERR      BIT(30)
#define RXDESC_FRAM     BIT(29)
#define RXDESC_OFOL     BIT(28)
#define RXDESC_CRC      BIT(27)
#define RXDESC_LFER     BIT(26)
#define RXDESC_MAX      BIT(25)
#define RXDESC_LCOL     BIT(24)
#define RXDESC_RUNT     BIT(23)
#define RXDESC_PAM      BIT(22)
#define RXDESC_MAM      BIT(21)
#define RXDESC_BAM      BIT(20)
#define RXDESC_EXTRA    BIT(18)
#define RXDESC_MISS     BIT(17)
#define RXDESC_REND     BIT(16)

// Transmit control and status bits
//  bit 31 (OWN):
//      0 - host owns the descriptor
//      1 - controller owns the descriptor
//  bit 30 (ERR): transmit error
//  bit 29 (UFLO): underflow error
//  bit 28 (LCOL): late collision
//  bit 27 (LCAR): loss of carrier
//  bit 26 (DEF): deferred
//  bit 25 (EXDEF): excessive deferral
//  bit 24 (INTEN): interrupt override
//  bit 23-20 (TRC): transmit retry count
//  bit 19 (RTRY): retry error
//  bit 18-17: reserved
//  bit 16 (TEND): end of transmit frame

#define TXDESC_OWN      BIT(31)
#define TXDESC_ERR      BIT(30)
#define TXDESC_UFLO     BIT(29)
#define TXDESC_LCOL     BIT(28)
#define TXDESC_LCAR     BIT(27)
#define TXDESC_DEF      BIT(26)
#define TXDESC_EXDEF    BIT(25)
#define TXDESC_INTEN    BIT(24)
#define TXDESC_RTRY     BIT(19)
#define TXDESC_TEND     BIT(16)

//
// NIC registers
//
typedef struct _NIC_CSR {                   // base address fef00000
    DWORD intr;                             // 000
        // Interrupt register
        //  bit 7: reserved
        //  bit 6 (MINT): MII interrupt
        //  bit 5 (STINT): software timer interrupt
        //  bit 4 (TCINT): transmit complete w/o error interrupt
        //  bit 3 (TEINT): transmit complete with error interrupt
        //  bit 2 (MISS): missed a frame
        //  bit 1 (RCINT): receive complete w/o error interrupt
        //  bit 0 (REINT): receive complete with error interrupt

    #define INTR_MINT   BIT(6)
    #define INTR_STINT  BIT(5)
    #define INTR_TCINT  BIT(4)
    #define INTR_TEINT  BIT(3)
    #define INTR_MISS   BIT(2)
    #define INTR_RCINT  BIT(1)
    #define INTR_REINT  BIT(0)

    #define INTR_ALL    (INTR_MINT | \
                         INTR_TCINT | \
                         INTR_TEINT | \
                         INTR_MISS | \
                         INTR_RCINT | \
                         INTR_REINT)
    
    DWORD intr_mk;                          // 004
        // Master interrupt mask
        //  bit 7: reserved
        //  bit 6: MINT mask - 1 = enable and 0 = disable
        //  bit 5: STINT mask
        //  bit 4: TCINT mask
        //  bit 3: TEINT mask
        //  bit 2: MISS mask
        //  bit 1: RCINT mask
        //  bit 0: REINT mask

    DWORD swtr_cntl;                        // 008
        // Software timer control register
        //  bit 1 (STEN): software timer enable
        //  bit 0 (STREN): software timer reload enable

    DWORD swtr_itc;                         // 00c
        // Software timer register
        //  bit 31-16: current software timer count
        //  bit 15-0: software timer interval

    BYTE gap1[0x80 - 0x10];

    DWORD tx_cntl;                          // 080
        // Transmit control register
        //  bit 31-22: reserved
        //  bit 21 (UFLOM): underflow error mask
        //  bit 20 (TCOLM): transmit late collision mask
        //  bit 19 (LCARM): loss of carrier mask
        //  bit 18 (DEFM): deferred mask
        //  bit 17 (EXDEFM): excessive deferral mask
        //  bit 16 (RTRYM): retry error mask
        //  bit 15-12: reserved
        //  bit 11-8: maximum number of retries on collisions
        //  bit 7-6: MAC-PHY interface
        //  bit 5 (TDEFEN): two-part deferral enable
        //  bit 4 (FCSEN): FCS append enable
        //  bit 3 (PADEN): pad enable
        //  bit 2 (RTRYEN): retry enable
        //  bit 1 (HDEN): half-duplex enable
        //  bit 0: reserved
    
    #define TXCNTL_UFLOM    BIT(21)
    #define TXCNTL_TCOLM    BIT(20)
    #define TXCNTL_LCARM    BIT(19)
    #define TXCNTL_DEFM     BIT(18)
    #define TXCNTL_EXDEFM   BIT(17)
    #define TXCNTL_RTRYM    BIT(16)
    #define TXCNTL_RCSHIFT  8
    #define TXCNTL_PHYSHIFT 6
    #define TXCNTL_TDEFEN   BIT(5)
    #define TXCNTL_FCSEN    BIT(4)
    #define TXCNTL_PADEN    BIT(3)
    #define TXCNTL_RTRYEN   BIT(2)
    #define TXCNTL_HDEN     BIT(1)

    #define PHY_TYPE_MII    0
    #define TXCNTL_DEFAULT  (TXCNTL_UFLOM | \
                             TXCNTL_TCOLM | \
                             TXCNTL_LCARM | \
                             TXCNTL_EXDEFM | \
                             TXCNTL_RTRYM | \
                             TXCNTL_TDEFEN | \
                             TXCNTL_FCSEN | \
                             TXCNTL_PADEN | \
                             TXCNTL_RTRYEN | \
                             TXCNTL_HDEN | \
                             (PHY_TYPE_MII << TXCNTL_PHYSHIFT) | \
                             (15 << TXCNTL_RCSHIFT))

    DWORD tx_en;                            // 084
        // Transmit enable register
        //  bit 1: transmit enable

    #define TXEN_ENABLE     BIT(0)

    DWORD tx_sta;                           // 088
        // Transmit status register
        //  bit 31-22: reserved
        //  bit 21 (UFLO): underflow error
        //  bit 20 (TCOL): transmit late collision
        //  bit 19 (LCAR): loss of carrier
        //  bit 18 (DEF): deferred
        //  bit 17 (EXDEF): excessive deferral
        //  bit 16 (RTRY): retry error
        //  bit 15-1: reserved
        //  bit 0: transmit channel idle status
    
    #define TXSTA_UFLO      BIT(21)
    #define TXSTA_TCOL      BIT(20)
    #define TXSTA_LCAR      BIT(19)
    #define TXSTA_DEF       BIT(18)
    #define TXSTA_EXDEF     BIT(17)
    #define TXSTA_RTRY      BIT(16)
    #define TXSTA_BUSY      BIT(0)

    DWORD rx_cntl_0;                        // 08c
        // Receive control
        //  bit 31-23: reserved
        //  bit 22 (FRAMM): frame alignment error mask
        //  bit 21 (OFOLM): overflow error mask
        //  bit 20 (CRCM): FCS error mask
        //  bit 19 (LFERM): length error mask
        //  bit 18 (MAXM): maximum length error mask
        //  bit 17 (RLCOLM): receive late collision mask
        //  bit 16 (RUNTM): runt receive mask
        //  bit 15-9: reserved
        //  bit 8 (RDEFEN): receive deferral enable
        //  bit 7 (BRDIS): broadcast receive disable
        //  bit 6 (RUNTEN): runt packet receive enable
        //  bit 5 (AFEN): address filtering enable
        //  bit 4 (LBEN): loopback enable
        //  bit 3 (PAEN): pause enable
        //  bit 2 (FCSREN): FCS relay enable
        //  bit 1 (PADSEN): pad strip enable
        //  bit 0: reserved

    #define RXCNTL_FRAMM    BIT(22)
    #define RXCNTL_OFLOM    BIT(21)
    #define RXCNTL_CRCM     BIT(20)
    #define RXCNTL_LFERM    BIT(19)
    #define RXCNTL_MAXM     BIT(18)
    #define RXCNTL_RLCOLM   BIT(17)
    #define RXCNTL_RUNTM    BIT(16)
    #define RXCNTL_RDEFEN   BIT(8)
    #define RXCNTL_BRDIS    BIT(7)
    #define RXCNTL_RUNTEN   BIT(6)
    #define RXCNTL_AFEN     BIT(5)
    #define RXCNTL_LBEN     BIT(4)
    #define RXCNTL_PAEN     BIT(3)
    #define RXCNTL_FCSREN   BIT(2)
    #define RXCNTL_PADSEN   BIT(1)

    #define RXCNTL_DEFAULT  (RXCNTL_FRAMM | \
                             RXCNTL_OFLOM | \
                             RXCNTL_CRCM | \
                             RXCNTL_LFERM | \
                             RXCNTL_MAXM | \
                             RXCNTL_RLCOLM | \
                             RXCNTL_RUNTM | \
                             RXCNTL_AFEN)

    DWORD rx_cntl_1;                        // 090
        // Maximum receive frame size register

    DWORD rx_en;                            // 094
        // Receive enable register
        //  bit 1: receive enable

    #define RXEN_ENABLE     BIT(0)

    DWORD rx_sta;                           // 098
        // Receive status register
        //  bit 31-23: reserved
        //  bit 22 (FRAM): frame alignment error
        //  bit 21 (OFOL): overflow error
        //  bit 20 (CRC): FCS error
        //  bit 19 (LFER): length error
        //  bit 18 (MAX): maximum length error
        //  bit 17 (RLCOL): receive late collision
        //  bit 16 (RUNT): runt receive
        //  bit 15-1: reserved
        //  bit 0: receive channel idle status
    
    #define RXSTA_FRAM      BIT(22)
    #define RXSTA_OFLO      BIT(21)
    #define RXSTA_CRC       BIT(20)
    #define RXSTA_LFER      BIT(19)
    #define RXSTA_MAX       BIT(18)
    #define RXSTA_RLCOL     BIT(17)
    #define RXSTA_RUNT      BIT(16)
    #define RXSTA_BUSY      BIT(0)

    DWORD bkoff_cntl;                       // 09c
        // Backoff control register (for HomePNA)
        //  bit 31-16: reserved
        //  bit 15-8: slot time, 127 for IEEE 802.3
        //  bit 7-0: random seed

    #define BKOFFCNTL_RSSHIFT   0
    #define BKOFFCNTL_STSHIFT   8

    #define BKOFFCNTL_DEFAULT   ((8 << BKOFFCNTL_RSSHIFT) | \
                                 (127 << BKOFFCNTL_STSHIFT))

    DWORD tx_def;                           // 0a0
        // Transmit deferral timing register
        //  bit 31-24: reserved
        //  bit 23-16 (TIFG): number of clocks for inter-frame gap
        //      when two-part deferral is disabled
        //  bit 15-8 (TIFG2): number of clocks for the second part
        //      inter-frame gap for two-part deferral
        //  bit 7-0 (TIFG1): number of clocks for the first part
        //      inter-frame gap for two-part deferral

    #define TXDEF_GSHIFT    16
    #define TXDEF_G2SHIFT   8
    #define TXDEF_G1SHIFT   0

    // Default values for IEEE 802.3
    #define TXDEF_DEFAULT   ((15 << TXDEF_G1SHIFT) | \
                             (7 << TXDEF_G2SHIFT) | \
                             (22 << TXDEF_GSHIFT))

    DWORD rx_def;                           // 0a4
        // Receive deferral register
        //  bit 7-0 (RIFG): number of clocks for inter-frame gap
        //      when receive deferral is enabled

    #define RXDEF_DEFAULT   0x16

    DWORD uni0;                             // 0a8
        // Lower 32-bits of the unicast address

    DWORD uni1;                             // 0ac
        // Higher 16-bits of the unicast address

    DWORD mult0;                            // 0b0
        // Lower 32-bits of the multicast address

    DWORD mult1;                            // 0b4
        // Higher 16-bits of the multicast address

    DWORD mult_mk0;                         // 0b8
        // Lower 32-bits of the multicast address mask

    DWORD mult_mk1;                         // 0bc
        // Higher 16-bits of the multicast address mask

    BYTE gap2[0x100 - 0xc0];

    DWORD tx_dadr;                          // 100
        // Transmit descriptor ring physical address

    DWORD rx_dadr;                          // 104
        // Receive descriptor ring physical address

    DWORD dlen;                             // 108
        // Descriptor ring length register
        //  bit 31-26: reserved
        //  bit 25-16 (RDLEN): receive descriptor block length (-1)
        //  bit 15-10: reserved
        //  bit 9-0 (TDLEN): transmit descriptor block length (-1)

    DWORD tx_poll;                          // 10c
        // Transmit descriptor poll register
        //  bit 31-17: reserved
        //  bit 16 (TPEN): transmit poll enable
        //  bit 15-0: transmit poll interval

    DWORD rx_poll;                          // 110
        // Receive descriptor poll register
        //  bit 31-17: reserved
        //  bit 16 (RPEN): receive poll enable
        //  bit 15-0: receive poll interval
        //      this is measured in 66MHz / 15ns clock cycles

    #define RXPOLL_EN           BIT(16)
    #define RXPOLL_FREQ_100MPS  100
    #define RXPOLL_FREQ_10MPS   1000

    DWORD tx_pcnt;                          // 114
        // Current transmit poll count

    DWORD rx_pcnt;                          // 118
        // Current receive poll count

    DWORD tx_cur_dadr;                      // 11c
        // Current transmit descriptor physical address

    DWORD rx_cur_dadr;                      // 120
        // Current receive descriptor physical address

    DWORD tx_cur_prd0;                      // 124
        // Current transmit physical address

    DWORD tx_cur_prd1;                      // 128
        // bit 31-16: current status of actively transmited frame
        // bit 15-0: current number of bytes remaining

    DWORD rx_cur_prd0;                      // 12c
        // Current receive physical address

    DWORD rx_cur_prd1;                      // 130
        // bit 31-16: current status of actively received frame
        // bit 15-0: current number of bytes remaining

    DWORD tx_nxt_dadr;                      // 134
        // Next transmit descriptor physical address

    DWORD rx_nxt_dadr;                      // 138
        // Next receive descriptor physical address

    DWORD tx_fifo_wm;                       // 13c
        // Transmit FIFO watermarks
        //  bit 31-24: reserved
        //  bit 23-16: High watermark
        //  bit 15-8: reserved
        //  bit 7-0: Low watermark

    #define TXFIFOWM_HWSHIFT    16
    #define TXFIFOWM_LWSHIFT    0

    #define TXFIFOWM_DEFAULT    ((0x10 << TXFIFOWM_LWSHIFT) | \
                                 (0x30 << TXFIFOWM_HWSHIFT))

    DWORD rx_fifo_wm;                       // 140
        // Receive FIFO watermarks
        //  bit 31-24: reserved
        //  bit 23-16: High watermark
        //  bit 15-8: reserved
        //  bit 7-0: Low watermark

    #define RXFIFOWM_HWSHIFT    16
    #define RXFIFOWM_LWSHIFT    0

    #define RXFIFOWM_DEFAULT    ((0x10 << RXFIFOWM_LWSHIFT) | \
                                 (0x30 << RXFIFOWM_HWSHIFT))
    DWORD mode;                             // 144
        // Mode register
        //  bit 4: buffer management reset
        //      need to be set for >= 3.2us before it's cleared
        //  bit 3: there is no active DMA transfer in progress
        //  bit 2: disable DMA transfer
        //  bit 1 (RXDM): receive demand
        //  bit 0 (TXDM): transmit demand

    #define MODE_RESET_BUFFERS  BIT(4)
    #define MODE_DMA_IDLE       BIT(3)
    #define MODE_DISABLE_DMA    BIT(2)
    #define MODE_RXDM           BIT(1)
    #define MODE_TXDM           BIT(0)

    BYTE gap3[0x180 - 0x148];

    DWORD mintr;                            // 180
        // MII interrupt register
        //  bit 7-5: reserved
        //  bit 4 (MPDI): MII PHY detect interrupt
        //  bit 3 (MAPI): MII auto-polling interrupt
        //  bit 2 (MCCI): MII command complete interrupt
        //  bit 1 (MCCII): MII command complete internal interrupt
        //  bit 0 (MREI): MII read error interrupt
    
    #define MINTR_MPDI  BIT(4)
    #define MINTR_MAPI  BIT(3)
    #define MINTR_MCCI  BIT(2)
    #define MINTR_MCCII BIT(1)
    #define MINTR_MREI  BIT(0)

    DWORD mintr_mk;                         // 184
        // MII interrupt mask register
        //  bit 7-5: reserved
        //  bit 4: MPDI mask - 1 to enable and 0 to disable
        //  bit 3: MAPI mask
        //  bit 2: MCCI mask
        //  bit 1: MCCII mask
        //  bit 0: MREI mask

    DWORD mii_cs;                           // 188
        // MII control and status register
        //  bit 31-29: reserved
        //  bit 28-24: PHY address
        //  bit 23-21: reserved
        //  bit 20 (APEN): auto-polling enable
        //  bit 19-16 (APTI): auto-polling time interval
        //  bit 15 (T4): 100BASE-T4
        //  bit 14 (XFD): 100BASE-X full duplex
        //  bit 13 (XHD): 100BASE-X half duplex
        //  bit 12 (10FD): 10Mb/s full-duplex
        //  bit 11 (10HD): 10Mb/s half-duplex
        //  bit 10 (ET2FD): 100BASE-T2 full-duplex
        //  bit 9 (T2HD): 100BASE-T2 half-duplex
        //  bit 8 (EXST): extended status
        //  bit 7: reserved
        //  bit 6 (MFPS): MF preamble suppression
        //  bit 5 (ANC): auto negotiation complete
        //  bit 4 (RF): remote fault
        //  bit 3 (ANA): auto-negotiation ability
        //  bit 2 (LS): link status
        //  bit 1 (JD): Jabber detect
        //  bit 0 (EC): extended capability
    
    #define MIICS_PADRSHIFT 24
    #define MIICS_APEN      BIT(20)
    #define MIICS_APSHIFT   16
    #define MIICS_T4        BIT(15)
    #define MIICS_XFD       BIT(14)
    #define MIICS_XHD       BIT(13)
    #define MIICS_10FD      BIT(12)
    #define MIICS_10HD      BIT(11)
    #define MIICS_ET2FD     BIT(10)
    #define MIICS_T2HD      BIT(9)
    #define MIICS_EXST      BIT(8)
    #define MIICS_MFPS      BIT(6)
    #define MIICS_ANC       BIT(5)
    #define MIICS_RF        BIT(4)
    #define MIICS_ANA       BIT(3)
    #define MIICS_LS        BIT(2)
    #define MIICS_JD        BIT(1)
    #define MIICS_EC        BIT(0)

    #define PHY_ADDR        1
    #define MIICS_DEFAULT   ((PHY_ADDR << MIICS_PADRSHIFT) | \
                             (4 << MIICS_APSHIFT) | \
                             MIICS_APEN)

    DWORD mii_tm;                           // 18c
        // MII clock timer register
        //  bit 15: MII timer status
        //  bit 14-9: reserved
        //  bit 8: MII timer enable
        //  bit 7-0: MII timer interval

    #define MIITM_BUSY      BIT(15)
    #define MIITM_EN        BIT(8)
    #define MIITM_TISHIFT   0

    #define MIITM_INTERVAL  5
    #define MIITM_DEFAULT   ((MIITM_INTERVAL << MIITM_TISHIFT) | MIITM_EN)
    #define PHYRW_TIMEOUT   ((64*2*2*400*MIITM_INTERVAL/1000)*4)

    DWORD mdio_adr;                         // 190
        // MDIO address register
        //  bit 15 (MDLK): MDIO lock
        //  bit 14-11: reserved
        //  bit 10 (MDRW): MDIO read/write
        //  bit 9-5 (PHYADR): physical address of the PHY to be accessed
        //  bit 4-0 (PHYREG): register address of the PHY to be accessed

    #define MDIOADR_LOCK        BIT(15)
    #define MDIOADR_WRITE       BIT(10)
    #define MDIOADR_PHYSHIFT    5
    #define MDIOADR_REGSHIFT    0

    DWORD mdio_data;                        // 194
        // MDIO data register
        //  bit 15-0 (PHYD): data for the last PHY read/write access

    BYTE gap4[0x200 - 0x198];

    DWORD pm_cntl;                          // 200
        // Power management control register

    struct {
        DWORD crc;
        DWORD mask0;
        DWORD mask1;
        DWORD mask2;
        DWORD mask3;
    } pmc_crc[5];
        // Pattern match CRC registers

    DWORD pmc_alias;
        // PCI power management register 0 alias

    DWORD pmcsr_alias;
        // PCI power management register 1 alias
} volatile *PNIC_CSR;

#define NicCsr ((PNIC_CSR) XPCICFG_NIC_MEMORY_REGISTER_BASE_0)
        

//
// NIC transmit and receive buffer descriptors
//
typedef struct _NicCmdBuffer {
    UINT_PTR phyaddrOffset;
    NicBufDesc* txstart;
    NicBufDesc* txend;
    NicBufDesc* txhead;
    NicBufDesc* txtail;
    NicBufDesc* rxstart;
    NicBufDesc* rxend;
    NicBufDesc* rxptr;
} NicCmdBuffer;

#define NicBufPhyAddr(nic, p) \
        ((UINT_PTR) (p) + (nic)->cmdbuf.phyaddrOffset)

//
// Extra overhead required by the NIC in the DMA receive buffer
// NOTE: We don't actually need any overhead for nVidia NIC.
// But we'll reserve 8 bytes of space after the Packet header (24 bytes)
// so that the received frame data starts on a 32-byte aligned address.
//
#define RECVPKT_OVERHEAD 8

//
// Allocate shared memory buffers for the NIC
//  BUGBUG!!! We have to used uncached memory for shared DMA buffers
//  because of a hardware snooping bug in nv2a.
//
#define NicFreeSharedMem(p) MmFreeContiguousMemory(p)
#ifndef DVTSNOOPBUG
#define NicAllocSharedMem(size) MmAllocateContiguousMemory(size)
#else // DVTSNOOPBUG
INLINE VOID* NicAllocSharedMem(UINT size) {
    VOID* p = MmAllocateContiguousMemoryEx(size, 0, MAXULONG_PTR, 0, PAGE_READWRITE|PAGE_NOCACHE);
    __asm wbinvd
}
#endif // DVTSNOOPBUG

//
// Disable and enable NIC interrupts
//
INLINE VOID NicDisableInterrupt() {
    NicCsr->intr_mk = 0;
}

INLINE VOID NicEnableInterrupt() {
    NicCsr->intr_mk = INTR_ALL;
}

#endif // !_XNIC_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\enet\dbgmon\dbgmon.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dbgmon.c

Abstract:

    Functions that are specific to the debug monitor stack

Revision History:

    08/04/2000 davidx
        Created it.

--*/

#include "precomp.h"

//
// Debug monitor related global variables
//
PRIVATE IPRECEIVEPROC IpReceivePacketProc;
PRIVATE FREEPKTPROC FreePacketProc;
PRIVATE IfEnet *IfpEnetShared;

VOID
DmExFreePool(
    IN PVOID P
    );

//
// Pass the received frame up to the IP layer
//
VOID IPRECEIVEPACKET(Packet* pkt) {
    // If two stacks are present, we need to figure out
    // who's supposed to get this packet.
    if (IpReceivePacketProc) {
        IpHeader* iphdr;
        TcpHeader* tcphdr;
        UdpHeader* udphdr;
        UINT iphdrlen;

        // We assume the packet data length >= IPHDRLEN
        iphdr = GETPKTDATA(pkt, IpHeader);
        iphdrlen = GETIPHDRLEN(iphdr);
        tcphdr = (TcpHeader*) ((BYTE*) iphdr + iphdrlen);
        udphdr = (UdpHeader*) ((BYTE*) iphdr + iphdrlen);

        if (iphdrlen && 
            (iphdr->protocol == IPPROTOCOL_TCP &&
            iphdrlen+TCPHDRLEN <= pkt->datalen &&
            tcphdr->dstport == HTONS(DEBUGGER_PORT)) ||
            (iphdr->protocol == IPPROTOCOL_UDP &&
            iphdrlen+UDPHDRLEN <= pkt->datalen &&
            udphdr->dstport == HTONS(DEBUGGER_PORT))) {
            IpReceivePacket(pkt);
        } else {
            IpReceivePacketProc(pkt);
        }
    } else {
        IpReceivePacket(pkt);
    }
}


//
// Dispose of a packet after transmission
//
VOID COMPLETEPACKET(Packet* pkt, NTSTATUS status) {
    if (pkt->pktflags & PKTFLAG_DBGMON) {
        XnetCompletePacket(pkt, status);
    } else {
        // This packet came from the regular net stack.
        // We must use the callback function to dispose of it.
        if (pkt->completionCallback) {
            pkt->completionCallback(pkt, status);
        #ifdef DVTSNOOPBUG
        } else if (pkt->pktflags & PKTFLAG_UNCACHED) {
            XnetUncachedFreeProc(pkt);
        #endif
        } else if (!(pkt->pktflags & PKTFLAG_NETPOOL)) {
            // The packet memory came from the system pool
            DmExFreePool(pkt);
        } else if (FreePacketProc) {
            // The packet memory came from the private pool
            FreePacketProc(pkt);
        }
    }
}


//
// Cancel any pending transmissions that
// originated from the regular stack.
//
VOID DmCancelPendingPackets(PacketQueue* pktq) {
    PacketQueue tmpq;
    Packet* pkt;
    INT dropped = 0;
    
    PktQInit(&tmpq);
    while (!PktQIsEmpty(pktq)) {
        pkt = PktQRemoveHead(pktq);
        if (pkt->pktflags & PKTFLAG_DBGMON) {
            PktQInsertTail(&tmpq, pkt);
        } else {
            COMPLETEPACKET(pkt, NETERR_CANCELLED);
            dropped++;
        }
    }

    *pktq = tmpq;
    if (dropped) {
        WARNING_("Pending transmissions cancelled: %d", dropped);
    }
}


//
// Check to see if we should delete the enet interface
//
VOID IFENET_DELETE_CHECK(IfEnet* ifp) {
    ASSERT(ifp->refcount > 0);
    if (--ifp->refcount > 0) {
        //
        // Cancel any pending transmissions that
        // originated from the regular stack.
        //
        INT index;
        DmCancelPendingPackets(&ifp->sendq);
        NicWaitForXmitQEmpty(ifp);
        for (index=0; index < ARP_CACHE_SIZE; index++) {
            DmCancelPendingPackets(&ifp->arpCache[index].waitq);
        }

        IpReceivePacketProc = NULL;
        FreePacketProc = NULL;
    }
}


//
// Notify the debug monitor that regular netstack is starting up
//
PRIVATE IfEnet* EnetStartTitleStack(ENETINITPARAMS* initParams) {
    // NOTE: Wait until we acquired an address 
    // before starting the title stack.
    DhcpWaitForAddress((IfInfo*) IfpEnetShared);

    IpReceivePacketProc = initParams->IpReceiveProc;
    FreePacketProc = initParams->FreePktProc;
    initParams->UncachedAllocProc = XnetUncachedAllocProc;
    initParams->UncachedFreeProc = XnetUncachedFreeProc;
    IfpEnetShared->refcount++;
    return IfpEnetShared;
}



//
// Set the enet interface information in the process control block
//
VOID SET_DBGMON_ENETINFO(IfEnet* ifp) {
    IfpEnetShared = ifp;
    ASSERT(KeGetCurrentPrcb()->DmEnetFunc == 0);

    #pragma warning(disable:4054)
    KeGetCurrentPrcb()->DmEnetFunc = (VOID*) EnetStartTitleStack;
}


//
// Return the IP address of the Ethernet interface to the debugger
//
DWORD DmGetIpAddress(void) {
    return IfpEnetShared ? HTONL(IfpEnetShared->ipaddr) : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\http\precomp.h ===
#include <xnetp.h>
#include <wininet.h>

#include "wininetp.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\inc\debug.h ===
/*++

Copyright (c) 1999

Module Name:

    debug.h

Abstract:

    Macros used for debugging purposes

Revision History:

    12/16/1999 davidx
        Created it.

--*/

#ifndef _DEBUG_H
#define _DEBUG_H

#include <xdbg.h>

//
// These macros are used for debugging purposes.
// They expand to nop on a free build.
//
#ifndef XNET_DEBUG_COMPILE_LEVEL
#define XNET_DEBUG_COMPILE_LEVEL XDBG_COMPILE_LEVEL
#endif

#if DBG && (XNET_DEBUG_COMPILE_LEVEL >= XDBG_WARNING)
extern VOID XnetDbgWarn(CHAR* format, ...);
#define WARNING_ XnetDbgWarn
#else 
#define WARNING_ 1 ? (void)0 : (void)
#endif

#if DBG && (XNET_DEBUG_COMPILE_LEVEL >= XDBG_TRACE)
extern VOID XnetDbgVerbose(CHAR* format, ...);
#define VERBOSE_ XnetDbgVerbose
#else 
#define VERBOSE_ 1 ? (void)0 : (void)
#endif

#if DBG && (XNET_DEBUG_COMPILE_LEVEL >= XDBG_ENTRY)
extern VOID XnetDbgTrace(CHAR* format, ...);
#define TRACE_ XnetDbgTrace
#else 
#define TRACE_ 1 ? (void)0 : (void)
#endif

#if DBG

#define ASSERT_DISPATCH_LEVEL() \
        ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL)

//
// This macro is used as a reminder that a particular function
// needs to run at DISPATCH_LEVEL.
//
#define RUNS_AT_DISPATCH_LEVEL

#else // !DBG

#define ASSERT_DISPATCH_LEVEL()
#define RUNS_AT_DISPATCH_LEVEL

#endif // !DBG

#endif // !_DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\http\handle.cxx ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    handle.cxx

Abstract:

    Functions for managing various types of WININET handles

Revision History:

    08/08/2000 davidx
        Created it.

--*/

#include "precomp.h"

HINTERNET WINAPI
InternetOpen(
    IN LPCWSTR lpszAgent,
    IN DWORD dwAccessType,
    IN LPCWSTR lpszProxy OPTIONAL,
    IN LPCWSTR lpszProxyBypass OPTIONAL,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Initializes an application's use of the Wininet functions.

Arguments:

    lpszAgent - Name of the user agent
    dwAccessType - Type of access required
    lpszProxy - Host name of the proxy server
    lpszProxyBypass - Must be NULL
    dwFlags - Must be 0

Return Value:

    Handle to the Wininet object
    NULL if there is an error

--*/

{
    // Validate function parameters:
    // - INTERNET_OPEN_TYPE_PRECONFIG and
    //   INTERNET_OPEN_TYPE_PRECONFIG_WITH_NO_AUTOPROXY
    //   are treated the same way as INTERNET_OPEN_TYPE_DIRECT
    // - we don't support proxy bypass,
    //   either everything go through the proxy
    //   or nothing go through the proxy
    // - flag parameter must be 0

    switch (dwAccessType) {
    case INTERNET_OPEN_TYPE_DIRECT:
    case INTERNET_OPEN_TYPE_PRECONFIG:
    case INTERNET_OPEN_TYPE_PRECONFIG_WITH_NO_AUTOPROXY:
        if (lpszProxy) {
            WARNING_("Proxy server ignored for direct connection");
            lpszProxy = NULL;
        }
        break;
    
    case INTERNET_OPEN_TYPE_PROXY:
        if (lpszProxy) break;

        // Fall through

    default:
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    if (lpszProxyBypass || dwFlags) {
        WARNING_("Unsupported InternetOpen parameters");
        SetLastError(ERROR_NOT_SUPPORTED);
        return NULL;
    }

    return InternetObject::Create(lpszAgent, lpszProxy);
}


BOOL WINAPI
InternetCloseHandle(
    IN HINTERNET hInternet
    )

/*++

Routine Description:

    Closes a single Internet handle.

Arguments:

    hInternet - Specifies the handle to be closed

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    BaseObject* obj = BaseObject::Lock(hInternet, OBJTYPE_NONE);
    if (!obj) return FALSE;

    obj->Unlock();
    obj->Release();
    return TRUE;
}


HINTERNET WINAPI
InternetConnect(
    IN HINTERNET hInternet,
    IN LPCWSTR lpszServerName,
    IN INTERNET_PORT nServerPort,
    IN LPCWSTR lpszUserName OPTIONAL,
    IN LPCWSTR lpszPassword OPTIONAL,
    IN DWORD dwService,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Opens a HTTP session for a given site.

Arguments:

    hInternet - Handle returned by InternetOpen
    lpszServerName - Server host name
    nServerPort - Server port number
    lpszUserName - Username
    lpszPassword - Password
    dwService - Must be INTERNET_SERVICE_HTTP
    dwFlags - Must be 0
    dwContext - App-specific context value

Return Value:

    Handle to the connection object
    NULL if there is an error

--*/

{
    InternetObject* inetobj;
    ConnectObject* connobj;

    // Just assert to save code in free build
    ASSERT(lpszServerName != NULL);
    
    if (dwService != INTERNET_SERVICE_HTTP) {
        WARNING_("Unsupported InternetConnect parameters");
        SetLastError(ERROR_NOT_SUPPORTED);
        return NULL;
    }

    if (dwFlags != 0) {
        WARNING_("Flags to InternetConnect ignored: 0x%x", dwFlags);
    }
    
    inetobj = LOCK_INTERNET_OBJECT(hInternet);
    if (!inetobj) return NULL;

    // No need to hold the lock to inetobj
    // because it doesn't have any volatile fields.
    // Just incrementing its refcount is enough.
    inetobj->AddRef();
    inetobj->Unlock();

    connobj = ConnectObject::Create(
                inetobj,
                lpszServerName,
                nServerPort,
                lpszUserName,
                lpszPassword,
                dwContext);

    inetobj->Release();
    return connobj;
}


HINTERNET WINAPI
HttpOpenRequest(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszVerb,
    IN LPCWSTR lpszObjectName,
    IN LPCWSTR lpszVersion,
    IN LPCWSTR lpszReferrer OPTIONAL,
    IN LPCWSTR* lplpszAcceptTypes OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Creates an HTTP request handle.

Arguments:

    hConnect - Handle to the HTTP connection object
    lpszVerb - Verb to use for the request
    lpszObjectName - Object name
    lpszVersion - HTTP version number
    lpszReferrer - Referer URL
    lplpszAcceptTypes - Media types accepted by the client
    dwFlags - Must be 0
    dwContext - App-specific context value

Return Value:

    Handle to the request object
    NULL if there is an error

--*/

{
    ConnectObject* connobj;
    RequestObject* reqobj;

    if (dwFlags != 0) {
        WARNING_("Unsupported HttpOpenRequest parameters");
        SetLastError(ERROR_NOT_SUPPORTED);
        return NULL;
    }

    connobj = LOCK_CONNECT_OBJECT(hConnect);
    if (!connobj) return NULL;

    connobj->AddRef();
    connobj->Unlock();

    if (!lpszVerb) lpszVerb = HttpDefaultVerbStr;
    if (!lpszVersion) lpszVersion = HttpDefaultVersionStr;
    if (!lpszObjectName) lpszObjectName = HttpDefaultObjectStr;

    reqobj = RequestObject::Create(
                connobj,
                lpszVerb,
                lpszObjectName,
                lpszVersion,
                lpszReferrer,
                lplpszAcceptTypes,
                dwContext);

    connobj->Release();
    return reqobj;
}


HINTERNET WINAPI
InternetOpenUrl(
    IN HINTERNET hInternet,
    IN LPCWSTR lpszUrl,
    IN LPCWSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Begins reading a complete HTTP URL

Arguments:

    hInternet - Points to the internet object returned by InternetOpen
    lpszUrl - URL string
    lpszHeaders - Extra HTTP request headers
    dwHeadersLength - Extra header length
    dwFlags - Must be 0
    dwContext - App-specific context value

Return Value:

    Handle to the HTTP request object
    NULL if there is an error

--*/

{
    WCHAR* serverName = NULL;
    WCHAR* objectName = NULL;
    HINTERNET hConnect = NULL;
    HINTERNET hRequest = NULL;
    INTERNET_PORT serverPort;

    //
    // Parse the HTTP URL to extra the server name and the object name
    //
    if (!HttpParseUrl(lpszUrl, &serverName, &serverPort, &objectName))
        return NULL;

    //
    // Create a connection handle
    //
    hConnect = InternetConnect(
                    hInternet,
                    serverName,
                    serverPort,
                    NULL,
                    NULL,
                    INTERNET_SERVICE_HTTP,
                    0,
                    0);

    if (hInternet) {
        //
        // Create a request handle
        //
        hRequest = HttpOpenRequest(
                        hConnect,
                        NULL,
                        objectName,
                        NULL,
                        NULL,
                        NULL,
                        0,
                        0);

        //
        // Send out the HTTP request to the server
        //
        if (hRequest &&
            !HttpSendRequest(hRequest, lpszHeaders, dwHeadersLength, NULL, 0)) {
            InternetCloseHandle(hRequest);
            hRequest = NULL;
        }
    }

    if (hConnect) { InternetCloseHandle(hConnect); }
    Free(serverName);
    Free(objectName);

    if (!hRequest) {
        WARNING_("InternetOpenUrl failed: %d", GetLastError());
    }
    return hRequest;
}


BOOL WINAPI
HttpSendRequest(
    IN HINTERNET hRequest,
    IN LPCWSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength
    )

/*++

Routine Description:

    Sends the specified request to the HTTP server.

Arguments:

    hRequest - Handle to an HTTP request object
    lpszHeaders - Extra HTTP request headers
    dwHeadersLength - Extra header length
    lpOptional - Optional data sent in the HTTP request
    dwOptionalLength - Optional data length

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    RequestObject* reqobj;
    BOOL result;

    ASSERT(lpszHeaders || !dwHeadersLength);
    ASSERT(lpOptional || !dwOptionalLength);

    reqobj = LOCK_REQUEST_OBJECT(hRequest);
    if (!reqobj) return FALSE;

    result = reqobj->SendRequest(
                lpszHeaders,
                dwHeadersLength,
                lpOptional,
                dwOptionalLength);

    reqobj->Unlock();
    return result;
}


BOOL WINAPI
InternetQueryDataAvailable(
    IN HINTERNET hRequest,
    OUT LPDWORD lpdwNumberOfBytesAvailable,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Query the amount of response data currently available for reading

Arguments:

    hRequest - Handle to the HTTP request object
    lpdwNumberOfBytesAvailable - Returns the number of bytes available
    dwFlags - Must be 0
    dwContext - Ignored

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    RequestObject* reqobj;
    BOOL result;
    
    ASSERT(lpdwNumberOfBytesAvailable != NULL);

    if (dwFlags != 0) {
        WARNING_("Unsupported InternetQueryDataAvailable parameters");
        SetLastError(ERROR_NOT_SUPPORTED);
        return FALSE;
    }
    
    reqobj = LOCK_REQUEST_OBJECT(hRequest);
    if (!reqobj) return FALSE;

    result = reqobj->QueryDataAvailable(lpdwNumberOfBytesAvailable);
    reqobj->Unlock();

    return result;
}


BOOL WINAPI
InternetReadFile(
    IN HINTERNET hRequest,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
    )

/*++

Routine Description:

    Read HTTP response data

Arguments:

    hRequest - Handle to the HTTP request
    lpBuffer - Output data buffer
    dwNumberOfBytesToRead - Output buffer size
    lpdwNumberOfBytesRead - Returns the number of bytes actually read

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    RequestObject* reqobj;
    BOOL result;

    ASSERT(lpBuffer && lpdwNumberOfBytesRead);

    reqobj = LOCK_REQUEST_OBJECT(hRequest);
    if (!reqobj) return FALSE;

    result = reqobj->ReadData((CHAR*) lpBuffer, dwNumberOfBytesToRead, lpdwNumberOfBytesRead);
    reqobj->Unlock();

    return result;
}


BOOL WINAPI
HttpQueryInfo(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN LPVOID lpvBuffer,
    IN LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex
    )

/*++

Routine Description:

    Retrieves header information associated with an HTTP request

Arguments:

    hRequest - Handle to the HTTP request
    dwInfoLevel - Specifies what attribute to retrieve
    lpvBuffer - Output data buffer
    lpdwBufferLength - Output data buffer size
        On entry, it contains the buffer size in number of WCHARs
        On return, it contains either the actual output data in number
        of WCHARs (not including the null terminator) or the actual
        number of bytes needed if the output buffer is too small
    lpdwIndex - 0-based index specifying which occurrence if of interest

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    RequestObject* reqobj;
    BOOL result;

    ASSERT(lpdwBufferLength);
    ASSERT(lpvBuffer || *lpdwBufferLength == 0);

    reqobj = LOCK_REQUEST_OBJECT(hRequest);
    if (!reqobj) return FALSE;

    result = reqobj->QueryRespInfo(
                        dwInfoLevel,
                        (WCHAR*) lpvBuffer,
                        lpdwBufferLength,
                        lpdwIndex);

    reqobj->Unlock();
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\http\http.cxx ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    http.cxx

Abstract:

    HTTP client functions

Revision History:

    08/08/2000 davidx
        Created it.

--*/

#include "precomp.h"
#include <stdio.h>
#include "httptime.h"

//
// Default HTTP string constants
//
const WCHAR WininetImpl::HttpDefaultVerbStr[] = L"GET";
const WCHAR WininetImpl::HttpDefaultVersionStr[] = HTTP_VERSION;
const WCHAR WininetImpl::HttpDefaultObjectStr[] = L"/";
static const WCHAR HttpSchemeStr[] = L"http://";


InternetObject*
InternetObject::Create(
    const WCHAR* userAgent,
    const WCHAR* proxyServer
    )

/*++

Routine Description:

    Instantiate a new internet object

Arguments:

    userAgent - Specifies the user agent
    proxyServer - Specifies the proxy server name

Return Value:

    Pointer to the newly created internet object
    NULL if there is an error

--*/

{
    static const WCHAR defaultUserAgent[] = L"XBox HTTP Client Library";
    InternetObject* inetobj;
    WSADATA wsadata;
    INT err;

    // Instantiate the object
    inetobj = new InternetObject();
    if (!inetobj) goto failed;

    // Startup winsock
    err = WSAStartup(WINSOCK_VERSION, &wsadata);
    if (err != NO_ERROR) {
        SetLastError(err);
        goto failed;
    }
    inetobj->wsastartup = TRUE;

    // Save user-agent string
    if (!userAgent) userAgent = defaultUserAgent;
    inetobj->userAgent = strdupWtoA(userAgent);
    if (!inetobj->userAgent) goto failed;

    // Save proxy server name and resolve its IP address
    if (proxyServer) {
        inetobj->proxyServer = strdupWtoA(proxyServer);
        if (!inetobj->proxyServer) goto failed;

        inetobj->proxyServerAddr = ResolveHostAddr(inetobj->proxyServer);
        if (inetobj->proxyServerAddr.s_addr == 0) goto failed;
    }

    return inetobj;

failed:
    WARNING_("InternetOpen failed: %d", GetLastError());
    delete inetobj;
    return NULL;
}


ConnectObject*
ConnectObject::Create(
    InternetObject* inetobj,
    const WCHAR* serverName,
    INTERNET_PORT serverPort,
    const WCHAR* username,
    const WCHAR* password,
    DWORD_PTR appContext
    )

/*++

Routine Description:

    Instantiate an HTTP connection object

Arguments:

    inetobj - Points to an InternetObject
    serverName - Server host name
    username - Username
    password - Password
    appContext - App-specific context value

Return Value:

    Pointer to the newly created connection object
    NULL if there is an error

--*/

{
    ConnectObject* connobj;

    connobj = new ConnectObject();
    if (!connobj) goto failed;

    // Keep a reference to the internet object
    inetobj->AddRef();
    connobj->inetobj = inetobj;
    connobj->appContext = appContext;
    connobj->serverPort = serverPort;

    // Save server name and resolve its IP address
    connobj->serverName = strdupWtoA(serverName);
    if (!connobj->serverName) goto failed;

    if (inetobj->GetProxyServer()) {
        connobj->serverAddr = inetobj->GetProxyServerAddr();
    } else {
        connobj->serverAddr = ResolveHostAddr(connobj->serverName);
        if (connobj->serverAddr.s_addr == 0) goto failed;
    }

    // Save username and password information
    if (username) {
        connobj->username = strdupWtoA(username);
        if (!connobj->username) goto failed;
    }

    if (password) {
        connobj->password = strdupWtoA(password);
        if (!connobj->password) goto failed;
    }

    // Successful return
    return connobj;

failed:
    WARNING_("InternetConnect failed: %d", GetLastError());
    delete connobj;
    return NULL;
}


RequestObject*
RequestObject::Create(
    ConnectObject* connobj,
    const WCHAR* verb,
    const WCHAR* objectName,
    const WCHAR* httpVer,
    const WCHAR* referer OPTIONAL,
    const WCHAR* acceptTypes[] OPTIONAL,
    DWORD_PTR appContext
    )

/*++

Routine Description:

    Instantiate a new HTTP request object

Arguments:

    connobj - Points to the HTTP connection object
    verb - Verb for the HTTP request
    objectName - Name of the object in question
    httpVer - HTTP version string
    referer - Referer URL
    acceptTypes - Media types accepted by the client
    appContext - App-specific context value

Return Value:

    Pointer to the newly created HTTP request object
    NULL if there is an error

--*/

{
    RequestObject* reqobj;

    reqobj = new RequestObject();
    if (!reqobj) return NULL;

    // Keep a reference to the parent connection object
    connobj->AddRef();
    reqobj->connobj = connobj;
    reqobj->appContext = appContext;

    //
    // Assemble default HTTP request headers
    //
    InternetObject* inetobj = connobj->GetInternetObject();
    HdrBuf* hdrbuf = &reqobj->reqhdrs;
    INT ok;

    // Request-line
    ok = hdrbuf->AppendUnicodeString(verb, SPACE);
    if (inetobj->GetProxyServer()) {
        ok &= hdrbuf->AppendUnicodeString(HttpSchemeStr, 0);
        ok &= hdrbuf->AppendAsciiString(connobj->GetServerName(), 0);
    }
    ok &= hdrbuf->AppendUnicodeString(objectName, SPACE);
    ok &= hdrbuf->AppendUnicodeString(httpVer, LF);

    // User-agent
    ok &= hdrbuf->AppendAsciiString("User-Agent", COLON);
    ok &= hdrbuf->AppendAsciiString(inetobj->GetUserAgent(), LF);

    // Accept
    //  note: this is actually an HTTP/1.1 header field
    if (acceptTypes && *acceptTypes) {
        const WCHAR* lasttype = *acceptTypes++;
        ok &= hdrbuf->AppendAsciiString("Accept", COLON);
        while (*acceptTypes) {
            ok &= hdrbuf->AppendUnicodeString(lasttype, COMMA);
            lasttype = *acceptTypes++;
        }
        ok &= hdrbuf->AppendUnicodeString(lasttype, LF);
    }

    // Referer
    if (referer) {
        ok &= hdrbuf->AppendAsciiString("Referer", COLON);
        ok &= hdrbuf->AppendUnicodeString(referer, LF);
    }

    if (!ok) {
        WARNING_("Failed to assembly default HTTP request headers");
        delete reqobj;
        return NULL;
    }
    return reqobj;
}


BOOL
RequestObject::Connect()

/*++

Routine Description:

    Establish a TCP connection to the HTTP server

Arguments:

    NONE

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    struct sockaddr_in serveraddr;

    // Do nothing if already connected
    if (IsConnected()) return TRUE;

    // Create the socket and connect to the HTTP server
    sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock == INVALID_SOCKET)
        return FALSE;

    connobj->GetServerAddr(&serveraddr);
    if (_connect(sock, &serveraddr) != NO_ERROR) {
        Disconnect();
        return FALSE;
    }

    // NOTE: we could set receive timeout option here...
    return TRUE;
}


static BOOL
DoSendData(
    SOCKET s,
    WSABUF* bufs,
    UINT bufcnt
    )

/*++

Routine Description:

    Send data out of a TCP connection

Arguments:

    s - Socket handle
    bufs - Data buffers
    bufcnt - Number of data buffers

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    INT err;
    DWORD sent;

    while (bufcnt) {
        err = WSASend(s, bufs, bufcnt, &sent, 0, NULL, NULL);
        if (err != NO_ERROR) return FALSE;

        // Only partial amount of data was sent:
        //  we need to update the send buffers and 
        //  then call WSASend again
        while (sent) {
            DWORD n = min(sent, bufs->len);

            if ((bufs->len -= n) == 0) {
                bufs++, bufcnt--;
            } else
                bufs->buf += n;
            sent -= n;
        }
    }

    return TRUE;
}


static HANDLE
DoOpenFile(
    const WCHAR* filename,
    UINT* fileSize
    )

/*++

Routine Description:

    Open a file for reading and get the file size

Arguments:

    filename - Specifies the filename
    fileSize - Return the file size

Return Value:

    Handle to the open file
    INVALID_HANDLE_VALUE if there is an error

--*/

{
    // BUGBUG
    // Since CreateFileW API is gone, we need to strip down
    // the Unicode string to ANSI string. Eventually we should
    // change the HttpSendRequest API to have it pass in
    // ANSI string.

    XDBGWRN("HTTP",
        "HttpSendRequest: lpOptional parameter is treated as Unicode filename - %ws",
        filename);
    
    CHAR *p, buf[MAX_PATH];
    ASSERT(wcslen(filename) < MAX_PATH);

    p = buf;
    while ((*p++ = (CHAR) *filename++) != 0)
        ;

    HANDLE file;

    //
    // Open the file for reading
    //
    file = CreateFileA(
                buf,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL|FILE_FLAG_SEQUENTIAL_SCAN,
                NULL);

    if (file != INVALID_HANDLE_VALUE) {
        //
        // Get file size
        //
        *fileSize = GetFileSize(file, NULL);
        if (*fileSize == 0xffffffff) {
            CloseHandle(file);
            file = INVALID_HANDLE_VALUE;
        }
    }

    return file;
}


static BOOL
DoSendFile(
    SOCKET s,
    HANDLE file,
    UINT filesize
    )

/*++

Routine Description:

    Send the content of a file out of a TCP connection

Arguments:

    s - Specifies the socket handle
    file - Specifies the open file handle
    filesize - Total file size

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

#define SENDFILE_BLKSIZE 4096

{
    CHAR* buf = NULL;
    WSABUF wsabuf;
    UINT bufsize;
    
    bufsize = min(filesize, SENDFILE_BLKSIZE);
    buf = (CHAR*) MAlloc(bufsize);
    if (!buf) return FALSE;

    while (filesize) {
        DWORD count = min(filesize, bufsize);
        DWORD bytesRead;

        // Read the next chunk of data from the file
        if (!ReadFile(file, buf, count, &bytesRead, NULL) ||
            count != bytesRead)
            break;
        
        // Send it out
        wsabuf.buf = buf;
        wsabuf.len = count;
        if (!DoSendData(s, &wsabuf, 1)) break;

        filesize -= count;
    }

    Free(buf);
    return (filesize == 0);
}


BOOL
RequestObject::SendRequest(
    const WCHAR* headers,
    UINT headerLength,
    const VOID* optionalData,
    UINT optionalLength
    )

/*++

Routine Description:

    Send the request to the HTTP server

Arguments:

    headers - Points to extra HTTP request headers
    headerLength - Extra header length
    optionalData - Points to optional data sent along the HTTP request
    optionalLength - Optional data length

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    // Establish a TCP connection to the server
    if (!Connect()) return FALSE;

    // Free any existing response information
    ResetRespInfo();

    HdrBuf hdrend;
    CHAR* extrahdrs = NULL;
    INT ok = 1;
    HANDLE file = INVALID_HANDLE_VALUE;

    //
    // Artificial loop for error handling
    //
    do {
        CHAR lenstr[16];

        // Content-Length header field
        if (optionalLength == 0xffffffff) {
            file = DoOpenFile((const WCHAR*) optionalData, &optionalLength);
            if (file == INVALID_HANDLE_VALUE) {
                WARNING_("Couldn't open file: %ws", optionalData);
                ok = 0;
                break;
            }
        }

        ok &= hdrend.AppendAsciiString("Content-Length", COLON);
        sprintf(lenstr, "%u", optionalLength);
        ok &= hdrend.AppendAsciiString(lenstr, LF);

        // Empty line
        ok &= hdrend.AppendAsciiString("", LF);
        if (!ok) break;

        // Assemble send buffers
        WSABUF bufs[4];
        UINT bufcnt = 0;

        bufs[bufcnt].len = reqhdrs.size;
        bufs[bufcnt++].buf = (CHAR*) reqhdrs.data;

        if (headerLength == 0xffffffff) {
            headerLength = wcslen(headers);
        }

        if (headerLength) {
            extrahdrs = strdupWtoA(headers, headerLength);
            if (!extrahdrs) break;

            bufs[bufcnt].len = headerLength;
            bufs[bufcnt++].buf = extrahdrs;
        }

        bufs[bufcnt].len = hdrend.size;
        bufs[bufcnt++].buf = (CHAR*) hdrend.data;

        if (optionalLength && file == INVALID_HANDLE_VALUE) {
            bufs[bufcnt].len = optionalLength;
            bufs[bufcnt++].buf = (CHAR*) optionalData;
        }

        // Send request data
        //  note: we need to use a wrapper function here
        //  and cann't call WSASend directly because
        //  WSASend can return success only after
        //  sending partial amount of data.
        ok = DoSendData(sock, bufs, bufcnt) &&
             (file == INVALID_HANDLE_VALUE ||
              DoSendFile(sock, file, optionalLength));
    } while (FALSE);

    if (file == INVALID_HANDLE_VALUE) {
        CloseHandle(file);
    }
    Free(extrahdrs);

    if (!ok) {
        Disconnect();
    }
    return ok;
}


BOOL
RequestObject::QueryDataAvailable(
    DWORD* bytesAvailable
    )

/*++

Routine Description:

    Query the amount of HTTP response data available

Arguments:

    bytesAvailable - Returns the number of bytes available

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    //
    // Make sure we're connected and
    // we have already read the HTTP response headers
    //
    if (!ReadRespHdrs(FALSE)) return FALSE;

    // We didn't finish reading the response headers
    if (!IsRespHdrsOk()) {
        *bytesAvailable = 0;
        return TRUE;
    }

    // Check if there is any data to be read
    ULONG avail;
    INT err = ioctlsocket(sock, FIONREAD, &avail);

    if (err != NO_ERROR) return FALSE;
    *bytesAvailable = peeklen + avail;
    if (*bytesAvailable)
        return TRUE;

    // If there is no data, check if the connection is closed
    fd_set fds;
    FD_ZERO(&fds);
    FD_SET(sock, &fds);
    struct timeval timeout = { 0, 0 };

    err = select(1, &fds, NULL, NULL, &timeout);
    switch (err) {
    case 0:
        break;

    case SOCKET_ERROR:
        return FALSE;
    
    default:
        ASSERT(err == 1);
        err = ioctlsocket(sock, FIONREAD, &avail);
        if (err != NO_ERROR) return FALSE;

        // Connection has been closed
        if (avail == 0) {
            SetLastError(ERROR_HANDLE_EOF);
            return FALSE;
        }

        *bytesAvailable = avail;
        break;
    }

    return TRUE;
}


BOOL
RequestObject::ReadData(
    CHAR* buffer,
    UINT bufferSize,
    DWORD* bytesRead
    )

/*++

Routine Description:

    Read HTTP response data

Arguments:

    buffer - Output data buffer
    bufferSize - Output buffer size
    bytesRead - Returns the number of bytes actually read

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    *bytesRead = 0;

    //
    // Make sure we're connected and
    // we have already read the HTTP response headers
    //
    if (!ReadRespHdrs(TRUE)) return FALSE;

    //
    // If we have read too much data while parsing
    // the response headers, return it here.
    //
    UINT n;
    if (peeklen) {
        n = min(bufferSize, peeklen);
        CopyMem(buffer, peekdata, n);
        buffer += n;
        peekdata += n;
        peeklen -= n;

        *bytesRead += n;
        readcnt += n;
        bufferSize -= n;
    }

    while (bufferSize) {
        n = bufferSize;
        if (contentlen != 0xffffffff) {
            //
            // If Content-Length header field is not present,
            // we'll keep on reading until the server closes
            // the connection.
            //
            // Otherwise, we only read the specified amount of
            // data (and ignore any extra data at the end).
            //
            if (readcnt >= contentlen) break;
            if (n > contentlen - readcnt)
                n = contentlen - readcnt;
        }

        INT count = recv(sock, buffer, n, 0);
        if (count < 0) return FALSE;

        // Stop if connection is closed
        if (count == 0) break;

        n = count;
        *bytesRead += n;
        readcnt += n;
        buffer += n;
        bufferSize -= n;
    }

    return TRUE;
}


BOOL
RequestObject::ReadRespHdrs(
    BOOL wait
    )

/*++

Routine Description:

    Read HTTP response headers

Arguments:

    wait - Whether to wait for the header data

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    //
    // Check if we're currently connected
    //
    if (!IsConnected()) {
        SetLastError(ERROR_NOT_CONNECTED);
        return FALSE;
    }

    //
    // Check if we have already read the response headers
    //
    if (IsRespHdrsOk()) return TRUE;

    do {
        //
        // Reallocate memory buffer if necessary
        //
        if (resphdrs.SpaceLeft() < 512) {
            BYTE* olddata = resphdrs.data;
            if (!resphdrs.ReserveSpace(512)) goto failed;

            UINT offset = resphdrs.data - olddata;
            peekdata += offset;
            for (UINT i=0; i < resphdrLinecnt; i++)
                resphdrLines[i] += offset;
        }
        
        UINT n = resphdrs.SpaceLeft();
        INT result;
        if (!wait) {
            ULONG avail;
            result = ioctlsocket(sock, FIONREAD, &avail);
            if (result == SOCKET_ERROR) goto failed;
            if (avail == 0) break;
            if (n > avail) n = avail;
        }

        result = recv(sock, (CHAR*) resphdrs.data + resphdrs.size, n, 0);
        if (result == SOCKET_ERROR) goto failed;

        resphdrs.size += result;
        ParseRespHdrs(result == 0);
        if (result == 0) {
            //
            // Server has closed the connection
            //
            if (peeklen != 0) goto failed;
            resphdrsOk = TRUE;
        }
    } while (!IsRespHdrsOk());
    return TRUE;

failed:
    Disconnect();
    WARNING_("Failed to read HTTP response headers");
    SetLastError(ERROR_INVALID_DATA);
    return FALSE;
}


VOID
RequestObject::ParseRespHdrs(
    BOOL eof
    )

/*++

Routine Description:

    Parse HTTP response header fields

Arguments:

    eof - Whether the server connection has been closed

Return Value:

    NONE

--*/

#define IsLWS(c) ((c) == SPACE || (c) == TAB)

{
    BYTE* start = peekdata;
    BYTE* end = resphdrs.data + (resphdrs.size-1);

    while (TRUE) {
        //
        // Find the end of the next line
        //
        BYTE* p = start;
        BYTE* q;

    findeol:
        while (p < end) {
            if (p[0] == CR || p[1] == LF) break;
            p++;
        }
        if (p >= end) break;

        if (p == start) {
            //
            // Empty line - end of header section
            //
            start += 2;
            resphdrsOk = TRUE;
            break;
        }

        //
        // Handle line continuations
        //
        q = p + 2;
        if (q > end) {
            if (!eof) break;
        } else if (IsLWS(*q)) {
            do {
                q++;
            } while (q <= end && IsLWS(*q));
            if (q > end) break;

            UINT movecnt = (end-q) + 1;
            *p++ = SPACE;
            MoveMem(p, q, movecnt);

            end -= (q - p);
            goto findeol;
        }

        //
        // Strip trailing whitespaces
        //
        do {
            *p-- = 0;
        } while (p >= start && IsLWS(*p));

        if (resphdrLinecnt < MAXRESPHDRS) {
            resphdrLines[resphdrLinecnt++] = start;
        } else {
            WARNING_("Too many response header fields");
        }

        start = q;

        //
        // Look for Content-Length: field
        //
        CHAR* str;
        if (MatchHeaderField(start, "Content-Length", &str)) {
            NTSTATUS status;
            ULONG val;
            status = RtlCharToInteger(str, 10, &val);
            if (NT_SUCCESS(status)) contentlen = val;
        }
    }

    peekdata = start;
    peeklen = (end - start) + 1;
}


BOOL
RequestObject::MatchHeaderField(
    BYTE* data,
    const CHAR* fieldname,
    CHAR** fieldval
    )

/*++

Routine Description:

    Match a specified header field

Arguments:

    data - Points to the header field data
    fieldname - Specifies the name of the interested field
    fieldval - Return a pointer to the field value string

Return Value:

    TRUE if the name of the field matches the specified name
    FALSE otherwise

--*/

{
    INT len = strlen(fieldname);

    if (_strnicmp((CHAR*) data, fieldname, len) != 0 || data[len] != COLON)
        return FALSE;

    data += (len+1);
    while (*data && IsLWS(*data)) data++;
    *fieldval = (CHAR*) data;
    return TRUE;
}


BOOL
RequestObject::QueryRespInfo(
    DWORD infoLevel,
    WCHAR* buffer,
    DWORD* buflen,
    DWORD* hdrindex
    )

/*++

Routine Description:

    Retrieves header information associated with an HTTP request

Arguments:

    infoLevel - Specifies what attribute to retrieve
    buffer - Output data buffer
    buflen - Output data buffer size
        On entry, it contains the buffer size in number of WCHARs
        On return, it contains either the actual output data in number
        of WCHARs (not including the null terminator) or the actual
        number of bytes needed if the output buffer is too small
    hdrindex - 0-based index specifying which occurrence if of interest

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

#define HTTP_QUERY_FLAG_ALL \
        (HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_FLAG_SYSTEMTIME)

#define ReturnInsufficientBufferError(_bytesNeeded) { \
            *buflen = (_bytesNeeded); \
            SetLastError(ERROR_INSUFFICIENT_BUFFER); \
            return FALSE; \
        }

{
    static const struct {
        DWORD fieldindex;
        const CHAR* fieldname;
    } mapping[] = {
        { HTTP_QUERY_CONTENT_LENGTH, "Content-Length" },
        { HTTP_QUERY_CONTENT_TYPE, "Content-Type" },
        { HTTP_QUERY_DATE, "Date" },
        { HTTP_QUERY_EXPIRES, "Expires" },
        { HTTP_QUERY_LAST_MODIFIED, "Last-Modified" },
        { HTTP_QUERY_ACCEPT, "Accept" },
    };

    DWORD modifier = infoLevel & 0xffff0000;
    DWORD fieldIndex = infoLevel & 0xffff;
    CHAR tempbuf[64];
    const CHAR* fieldname;
    CHAR* fieldval = NULL;
    UINT i, count;
    DWORD occurrence = hdrindex ? *hdrindex : 0;

    //
    // Make sure we're connected and
    // we have already read the HTTP response headers
    //
    if (!ReadRespHdrs(TRUE)) return FALSE;

    if (modifier & ~HTTP_QUERY_FLAG_ALL)
        goto unsupported;

    switch (fieldIndex) {
    case HTTP_QUERY_VERSION:
    case HTTP_QUERY_STATUS_CODE:
    case HTTP_QUERY_STATUS_TEXT:
        //
        // Extract information from the status line
        //
        if (occurrence) goto unsupported;
        fieldval = ParseStatusLine(tempbuf, sizeof(tempbuf), fieldIndex);
        break;

    case HTTP_QUERY_RAW_HEADERS:
    case HTTP_QUERY_RAW_HEADERS_CRLF:
        //
        // Return all the header fields
        //
        if (modifier || occurrence) goto unsupported;
        return ReturnAllRespHdrs(buffer, buflen, fieldIndex);

    default:
        if (fieldIndex == HTTP_QUERY_CUSTOM) {
            //
            // Arbitrary field name
            //
            count = wcslen(buffer);
            if (count >= sizeof(tempbuf)) goto unsupported;
            strcpyWtoA(tempbuf, buffer);
            fieldname = tempbuf;
        } else {
            //
            // Map field index to field name
            //
            count = ARRAYCOUNT(mapping);
            for (i=0; i < count; i++) {
                if (fieldIndex == mapping[i].fieldindex) break;
            }

            if (i == count) goto unsupported;
            fieldname = mapping[i].fieldname;
        }

        //
        // Find the field with the specified name
        //
        for (i=count=0; i < resphdrLinecnt; i++) {
            if (MatchHeaderField(resphdrLines[i], fieldname, &fieldval)) {
                if (count == occurrence) break;
                count++;
            }
        }

        if (i == resphdrLinecnt)
            fieldval = NULL;
        break;
    }

    //
    // Check if the specified field is present
    //
    if (fieldval == NULL) {
        SetLastError(ERROR_NO_DATA);
        return FALSE;
    }

    if (modifier & HTTP_QUERY_FLAG_NUMBER) {
        //
        // Return the field value as an integer
        // NOTE: This is really confusing at the API level:
        //  should app pass in buffer length in # of WCHARs
        //  or should it be in # of bytes?
        if (*buflen < sizeof(DWORD)) {
            ReturnInsufficientBufferError(sizeof(DWORD));
        }

        NTSTATUS status;
        ULONG val;

        status = RtlCharToInteger(fieldval, 10, &val);
        if (!NT_SUCCESS(status)) {
            SetLastError(ERROR_INVALID_DATA);
            return FALSE;
        }

        *((DWORD*) buffer) = val;
    } else if (modifier & HTTP_QUERY_FLAG_SYSTEMTIME) {
        //
        // Parse the HTTP date/time string
        //
        if (*buflen < sizeof(SYSTEMTIME)) {
            ReturnInsufficientBufferError(sizeof(SYSTEMTIME));
        }

        if (!HttpDateTime::Parse(fieldval, (SYSTEMTIME*) buffer))
            return FALSE;
    } else {
        //
        // Return the field value as Unicode string.
        // Check if the caller's buffer is large enough
        //
        count = strlen(fieldval);
        if (*buflen <= count) {
            ReturnInsufficientBufferError((count + 1) * sizeof(WCHAR));
        }

        *buflen = count;
        strcpyAtoW(buffer, fieldval);
    }

    if (hdrindex) *hdrindex = ++occurrence;
    return TRUE;

unsupported:
    WARNING_("HttpQueryInfo: unsupported parameter", infoLevel);
    SetLastError(ERROR_NOT_SUPPORTED);
    return FALSE;
}


CHAR*
RequestObject::ParseStatusLine(
    CHAR* buf,
    DWORD buflen,
    DWORD field
    )

/*++

Routine Description:

    Extract the specified field from the HTTP response status line

Arguments:

    buf - Points to the output buffer
    buflen - Output buffer size
        These two parameters are only used for the version
        and status code fields.
    field - Specifies which field the caller is interested in

Return Value:

    Pointer to the string value for the specified field

--*/

{
    if (resphdrLinecnt == 0) return NULL;

    field = (field == HTTP_QUERY_VERSION) ? 0 :
            (field == HTTP_QUERY_STATUS_CODE) ? 1 : 2;

    CHAR* q = (CHAR*) resphdrLines[0];
    CHAR* p = NULL;
    DWORD i, n;

    for (i=n=0; i <= field; i++) {
        p = q;
        if (i < 2) {
            while (*q && !IsLWS(*q)) q++;
            n = q - p;
            while (*q && IsLWS(*q)) q++;
        } else {
            n = strlen(q);
            q += n;
        }
    }

    //
    // The request field is not present
    //
    if (n == 0) return NULL;

    //
    // For the status text field, return
    // a pointer to our internal data buffer
    //
    if (field == 2) return p;

    //
    // Copy version and status code value into the output buffer
    //
    if (buflen <= n) return NULL;
    CopyMem(buf, p, n);
    buf[n] = 0;
    return buf;
}


BOOL
RequestObject::ReturnAllRespHdrs(
    WCHAR* buf,
    DWORD* buflen,
    DWORD field
    )

/*++

Routine Description:

    Return all the HTTP response headers in one chunk

Arguments:

    buf - Points to the output buffer
    buflen - See comments for QueryRespInfo
    field - Specifies whether the header fields should be separated
        by the null character or the CRLF

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    if (resphdrLinecnt == 0) {
        SetLastError(ERROR_NO_DATA);
        return FALSE;
    }

    //
    // Figure out the size of output buffer we need
    //

    BOOL crlf = (field == HTTP_QUERY_RAW_HEADERS_CRLF);
    UINT i, count;

    for (i=count=0; i < resphdrLinecnt; i++)
        count += strlen((CHAR*) resphdrLines[i]);

    count += resphdrLinecnt * (crlf ? 2 : 1);
    if (*buflen <= count) {
        ReturnInsufficientBufferError((count + 1) * sizeof(WCHAR));
    }

    //
    // Copy all the header fields to the output buffer
    //

    *buflen = count;
    for (i=0; i < resphdrLinecnt; i++) {
        CHAR* str = (CHAR*) resphdrLines[i];
        strcpyAtoW(buf, str);
        count = strlen(str);
        buf += count;
        if (crlf) {
            *buf++ = CR;
            *buf++ = LF;
        } else
            *buf++ = 0;
    }

    *buf = 0;
    return TRUE;
}


BOOL
WininetImpl::HttpParseUrl(
    const WCHAR* url,
    WCHAR** serverName,
    INTERNET_PORT* serverPort,
    WCHAR** objectName
    )

/*++

Routine Description:

    Crack an HTTP URL to extract various parts:
        serverName
        serverPort
        objectName

Arguments:

    url - Specifies the input URL string
    serverName - Returns a pointer to the server name string
    serverPort - Returns the server port number
    objectName - Returns a pointer to the object name string

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    ASSERT(url != NULL);
    *serverName = NULL;
    *objectName = NULL;
    *serverPort = INTERNET_DEFAULT_HTTP_PORT;

    //
    // Artificial loop for error handling
    //
    while (TRUE) {
        //
        // We only support http:// scheme
        //
        UINT len = wcslen(HttpSchemeStr);
        if (_wcsnicmp(url, HttpSchemeStr, len) != 0) break;

        //
        // Parse the server name
        //
        const WCHAR* server = url + len;
        const WCHAR* cp = server;

        while (*cp && *cp != COLON && *cp != SLASH) cp++;
        if ((len = cp - server) == 0) break;
        
        WCHAR* p = (WCHAR*) MAlloc((len+1) * sizeof(WCHAR));
        if (!p) break;

        CopyMem(p, server, len*sizeof(WCHAR));
        p[len] = 0;
        *serverName = p;

        //
        // Parse the server port number
        //
        if (*cp == COLON) {
            const WCHAR* port = ++cp;
            while (*cp && *cp != SLASH) cp++;
            if ((len = cp - port) == 0) break;

            UNICODE_STRING ustr;
            NTSTATUS status;
            ULONG val;

            ustr.Buffer = (WCHAR*) port;
            ustr.Length = (USHORT) (len * sizeof(WCHAR));
            ustr.MaximumLength = (USHORT) (ustr.Length + sizeof(WCHAR));
            status = RtlUnicodeStringToInteger(&ustr, 0, &val);

            if (!NT_SUCCESS(status) || val > 0xffff) break;
            *serverPort = (INTERNET_PORT) val;
        }

        //
        // Parse the object name
        //
        if (*cp == SLASH) {
            len = (wcslen(cp) + 1) * sizeof(WCHAR);
            p = (WCHAR*) MAlloc(len);
            if (!p) break;

            *objectName = p;
            CopyMem(p, cp, len);
        }
        return TRUE;
    }

    WARNING_("HttpParseUrl failed: %ws", url);
    SetLastError(ERROR_INVALID_PARAMETER);
    Free(*serverName);
    *serverName = NULL;
    return FALSE;
}


//
// Semi-klugy way to determine if a hostname
// string is in dotted-decimal form
//
inline BOOL IsHostAddrString(const CHAR* hostname) {
    const CHAR* p = hostname;
    while (*p) {
        if ((*p < '0' || *p > '9') && *p != '.')
            return FALSE;
        p++;
    }
    return TRUE;
}

struct in_addr
WininetImpl::ResolveHostAddr(
    const CHAR* hostname
    )

/*++

Routine Description:

    Resolve a host name to its IP address

Arguments:

    hostname - Points to the hostname string

Return Value:

    IP address of the specified host
    0 if there is an error

--*/

{
    struct in_addr hostaddr;

    hostaddr.s_addr = 0;
    if (IsHostAddrString(hostname)) {
        //
        // The hostname is in dotted-decimal form:
        //  just convert it to IP address directly
        //
        LONG addr = inet_addr(hostname);
        if (addr != INADDR_NONE)
            hostaddr.s_addr = addr;
    } else {
        //
        // Use DNS to map hostname to IP address
        //
        struct hostent* hostent;
        LONG* paddr;

        hostent = gethostbyname(hostname);
        if (hostent) {
            ASSERT(hostent->h_addr_list);
            paddr = (LONG*) hostent->h_addr_list[0];
            if (paddr) hostaddr.s_addr = *paddr;
        }
    }

    return hostaddr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\http\httptime.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    httptime.h

Abstract:

    Helper class for parsing HTTP date/time string

Revision History:

    08/17/2000 davidx
        Created it.

--*/

#ifndef _HTTPTIME_H
#define _HTTPTIME_H

//
// Helper class to parse HTTP date/time string
//
class HttpDateTime {

public:

    // Parse a HTTP date/time string
    static BOOL Parse(const CHAR* s, SYSTEMTIME* systime) {
        HttpDateTime dateTime(s);
        if (dateTime.IsInvalid()) {
            SetLastError(ERROR_INVALID_DATA);
            return FALSE;
        }

        systime->wYear = dateTime.year;
        systime->wMonth = dateTime.month;
        systime->wDay = dateTime.day;
        systime->wDayOfWeek = dateTime.wkday;
        systime->wHour = dateTime.hour;
        systime->wMinute = dateTime.minute;
        systime->wSecond = dateTime.second;
        systime->wMilliseconds = 0;
        return TRUE;
    }

private:

    // Parse a HTTP date/time string
    HttpDateTime(const CHAR* s) {
        // Mark the object as invalid
        MarkInvalid();

        cp = s;
        while (*cp && *cp != COMMA && *cp != SPACE) cp++;
        if (*cp == 0) return;

        INT wkdaylen = cp - s;
        INT fmt;
        
        // Determine the date/time string format
        // from the content of the day-of-week field

        if (*cp == SPACE) {
            if (wkdaylen != 3) return;
            fmt = DTFMT_ANSIC;
        } else {
            cp++;
            fmt = (wkdaylen == 3) ? DTFMT_RFC822 : DTFMT_RFC850;
        }
        if (*cp++ != SPACE || !ParseWkDay(s, wkdaylen)) return;

        BOOL ok = FALSE;
        switch (fmt) {
        case DTFMT_RFC822:
            ok = ParseInt(&day, 2, SPACE) &&
                 ParseMonth(SPACE) &&
                 ParseInt(&year, 4, SPACE) &&
                 ParseTime() &&
                 strcmp(cp, "GMT") == 0;
            break;

        case DTFMT_RFC850:
            ok = ParseInt(&day, 2, DASH) &&
                 ParseMonth(DASH) &&
                 ParseInt(&year, 2, SPACE) &&
                 ParseTime() &&
                 strcmp(cp, "GMT") == 0;

            // Handle 2-digit year
            year = (WORD) (year + ((year < 70) ? 2000 : 1900));
            break;

        case DTFMT_ANSIC:
            ok = ParseMonth(SPACE) &&
                 ((*cp == SPACE) ?
                    (cp++, ParseInt(&day, 1, SPACE)) :
                    ParseInt(&day, 2, SPACE)) &&
                 ParseTime() &&
                 ParseInt(&year, 4, 0);
            break;
        }

        if (ok && VerifyMonthDay()) {
            // Mark the object as valid if everything was ok
            this->format = (WORD) fmt;
        }
    }

    // Parse an integer field
    BOOL ParseInt(WORD* result, INT width, CHAR sep) {
        WORD val = 0;
        while (width--) {
            if (*cp < '0' || *cp > '9') return FALSE;
            val = (WORD) (val*10 + (*cp++ - '0'));
        }
        if (*cp++ != sep) return FALSE;
        *result = val;
        return TRUE;
    }

    // Parse the time field hh:mm:ss
    BOOL ParseTime() {
        return ParseInt(&hour, 2, COLON) &&
               ParseInt(&minute, 2, COLON) &&
               ParseInt(&second, 2, SPACE) &&
               hour < 24 &&
               minute < 60 &&
               second < 60;
    }

    // Interpret the day-of-week string
    BOOL ParseWkDay(const CHAR* s, INT len) {
        static const PCSTR wkdays[] = {
            "Sunday"
            "Monday",
            "Tuesday",
            "Wednesday",
            "Thursday",
            "Friday",
            "Saturday"
        };

        for (INT d=0; d < 7; d++) {
            if (strncmp(s, wkdays[d], len) == 0) {
                wkday = (WORD) d;
                return TRUE;
            }
        }
        return FALSE;
    }

    // Interpret the month string
    BOOL ParseMonth(CHAR sep) {
        static const CHAR months[] = "JanFebMarAprMayJunJulAugSepOctNovDec";
        const CHAR* s = months;

        for (INT m=0; m < 12; m++, s+=3) {
            if (s[0] == cp[0] &&
                s[1] == cp[1] && 
                s[2] == cp[2]) {
                if (cp[3] == sep) {
                    cp += 4;
                    month = (WORD) (m+1);
                    return TRUE;
                } else
                    break;
            }
        }
        return FALSE;
    }

    // Verify the day of the month
    BOOL VerifyMonthDay() {
        // NOTE: This is a simple-minded check here
        // without taking leap-year into account.
        static const BYTE monthDays[12] = {
            31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
        };

        return day > 0 && day <= monthDays[month-1];
    }

    VOID MarkInvalid() { format = DTFMT_INVALID; }
    BOOL IsInvalid() { return (format == DTFMT_INVALID); }

    // Date/time string format
    enum {
        DTFMT_INVALID,
        DTFMT_RFC822,
            // RFC 822 format: Sun, 06 Nov 1994 08:49:37 GMT
        DTFMT_RFC850,
            // RFC 850 format: Sunday, 06-Nov-94 08:49:37 GMT
        DTFMT_ANSIC,
            // ANSI C's asctime() format: Sun Nov  6 08:49:37 1994
    };

    WORD format;
    WORD year, month, day, wkday;
    WORD hour, minute, second;
    const CHAR* cp;
};

#endif // !_HTTPTIME_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\inc\ethernet.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    ethernet.h

Abstract:

    Ethernet and ARP protocol related declarations

Notes:

    Please refer to RFC 894, 826, and 1042.
    Also see RFC 1122, section 2.3.2 on ARP.

Revision History:

    05/02/2000 davidx
        Created it.

--*/

#ifndef _ETHERNET_H
#define _ETHERNET_H

//
// Ethernet hardware address is 6 bytes (48 bits)
//
#define ENETADDRLEN 6

//
// Ethernet frame header
//
#include <pshpack1.h>

typedef struct _EnetFrameHeader {
    BYTE dstaddr[ENETADDRLEN];
    BYTE srcaddr[ENETADDRLEN];
    WORD etherType;
} EnetFrameHeader;

#include <poppack.h>

//
// Ethernet frame header is 14 bytes
//
#define ENETHDRLEN sizeof(EnetFrameHeader)

//
// Mininum and maximum data size in an Ethernet frame
//
#define ENET_MINDATASIZE 46
#define ENET_MAXDATASIZE 1500

//
// Ethernet frame types
//
#define ENETTYPE_IP         0x0800
#define ENETTYPE_ARP        0x0806
#define ENETTYPE_LOOPBACK   0x9000

//
// IEEE 802.LLC and SNAP headers
//
#include <pshpack1.h>

typedef struct _IEEE802Header {
    BYTE DSAP;          // 0xaa
    BYTE SSAP;          // 0xaa
    BYTE control;       // 0x03
    BYTE orgcode[3];    // 0x00 0x00 0x00
    WORD etherType;
} IEEE802Header;

#define IEEE802HDRLEN sizeof(IEEE802Header)

#include <poppack.h>

//
// Constants we expect in the IEEE header
//
#define SNAP_DSAP 0xaa
#define SNAP_SSAP 0xaa
#define LLC_DGRAM 3

//
// Check if an Ethernet frame is actually an 802.3 frame
//
INLINE BOOL IsIEEE802Frame(WORD etherType) {
    return etherType <= ENET_MAXDATASIZE;
}

//
// Determine if an Ethernet hardware address is
// a broadcast or a multicast address
//
extern const BYTE EnetBroadcastAddr[ENETADDRLEN];

INLINE BOOL IsEnetAddrMcast(const BYTE* enetAddr) {
    return (enetAddr[0] & 1) != 0;
}

//
// ARP packet format
//
#include <pshpack1.h>

typedef struct _ArpPacket {
    WORD hrd;               // hardware address space
    WORD pro;               // protocol address space: ENETTYPE_IP
    BYTE hln;               // hardware address length: 6
    BYTE pln;               // protocol address length: 4
    WORD op;                // opcode
    BYTE sha[ENETADDRLEN];  // sender's hardware address
    IPADDR spa;             // sender's protocol address
    BYTE tha[ENETADDRLEN];  // target's hardware address
    IPADDR tpa;             // target's protocol address
} ArpPacket;

#include <poppack.h>

//
// Size of an ARP packet
//
#define ARPPKTLEN sizeof(ArpPacket)

//
// ARP packet opcodes
//
#define ARP_REQUEST 1
#define ARP_REPLY   2

//
// ARP hardware address spaces
//
#define ARP_HWTYPE_ENET 1
#define ARP_HWTYPE_802  6

#endif // !_ETHERNET_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\http\wininetp.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    wininetp.h

Abstract:

    Private header file for lightweight HTTP client implementation

Revision History:

    08/08/2000 davidx
        Created it.

--*/

#ifndef _WININETP_H
#define _WININETP_H


//
// Header information common to all handle types
//
class BaseObject {

protected:

    LONG lock;
        // Object lock

    #define OBJLOCK_CLOSED  '-NIH'
    #define OBJLOCK_ACTIVE  '+NIH'
    #define OBJLOCK_BUSY    '*NIH'

    LONG refcount;
        // reference count

    INT type;
        // Object type

    #define OBJTYPE_NONE        0
    #define OBJTYPE_INTERNET    1
    #define OBJTYPE_CONNECT     2
    #define OBJTYPE_REQUEST     3

protected:
    
    BaseObject(INT type) {
        lock = OBJLOCK_ACTIVE;
        this->type = type;
        refcount = 1;
    }

    virtual ~BaseObject() {
        // Mark the object as freed for simple protection
        // against apps that reuse a closed handle.
        lock = OBJLOCK_CLOSED;
    }

public:

    //
    // Lock an object handle
    //
    static BaseObject* Lock(HINTERNET handle, INT type) {
        BaseObject* obj = (BaseObject*) handle;
        INT err = ERROR_INVALID_HANDLE;
        LONG lock;

        // NOTE: We don't allow multiple threads to access the same
        // handle simultaneously. If the app tries to do that, the first
        // thread will succeed and other threads will get an error return.

        if (obj) {
            lock = InterlockedCompareExchange(&obj->lock, OBJLOCK_BUSY, OBJLOCK_ACTIVE);
            if (lock == OBJLOCK_ACTIVE) {
                if (obj->type == type || type == OBJTYPE_NONE) return obj;
                obj->Unlock();
            }

            if (lock == OBJLOCK_BUSY)
                err = ERROR_BUSY;
        }

        WARNING_("Invalid Wininet handle: %x, %d", obj, err);
        SetLastError(err);
        return NULL;
    }

    //
    // Unlock an object
    //
    VOID Unlock() {
        // NOTE: we assume this is an atomic operation
        lock = OBJLOCK_ACTIVE;
    }

    //
    // Increment / decrement the reference count of a handle
    //
    LONG AddRef() {
        return InterlockedIncrement(&refcount);
    }

    LONG Release() {
        LONG count = InterlockedDecrement(&refcount);
        if (count == 0) delete this;
        return count;
    }
};


//
// Object returned by InternetOpen call (OBJTYPE_INTERNET)
//
class InternetObject : public BaseObject {

public:
    // Instantiation
    static InternetObject*
    Create(
        const WCHAR* userAgent,
        const WCHAR* proxyServer
        );

    CHAR* GetUserAgent() { return userAgent; }
    CHAR* GetProxyServer() { return proxyServer; }
    struct in_addr GetProxyServerAddr() { return proxyServerAddr; }

protected:

    InternetObject() : BaseObject(OBJTYPE_INTERNET) {
        userAgent = proxyServer = NULL;
        wsastartup = FALSE;
    }

    ~InternetObject() {
        Free(userAgent);
        Free(proxyServer);
        if (wsastartup) {
            WSACleanup();
        }
    }

    CHAR* userAgent;
        // User agent

    CHAR* proxyServer;
        // Pointer to the proxy server name
        // NULL if we're not using proxy

    struct in_addr proxyServerAddr;
        // Proxy server IP address (0 if no proxy is used)

    BOOL wsastartup;
        // Whether we called WSAStartup successfully
};


//
// Special separators
//
enum {
    CR = 0xd,
    LF = 0xa,
    TAB = '\t',
    SPACE = ' ',
    COMMA = ',',
    SLASH = '/',
    COLON = ':',
    DASH = '-'
};


//
// Buffers for holding HTTP request/response header information
//
class HdrBuf {

public:

    UINT size;
        // Number of bytes currently in the buffer

    UINT maxsize;
        // Max buffer size

    BYTE* data;
        // Pointer to data buffer

    //
    // Constructor / destructor
    //
    HdrBuf() {
        size = maxsize = 0;
        data = NULL;
    }
    ~HdrBuf() { Dispose(); }

    //
    // Amount of space left in this buffer
    //
    UINT SpaceLeft() { return (maxsize-size); }

    //
    // Reserve additional space in the buffer
    //
    BOOL ReserveSpace(UINT bytesNeeded) {
        return (bytesNeeded <= SpaceLeft()) ||
               Alloc(size + bytesNeeded);
    }

    //
    // Append data to the end of this buffer
    //
    INT Append(const VOID* buf, UINT buflen) {
        // If the data buffer is too small, grow it first
        if (!ReserveSpace(buflen)) return 0;

        CopyMem(data+size, buf, buflen);
        size += buflen;
        return 1;
    }

    //
    // Append ASCII string to the buffer
    //
    INT AppendAsciiString(const CHAR* str, CHAR sep) {
        UINT len = strlen(str);

        if (!ReserveSpace(len+2)) return 0;
        CopyMem(data+size, str, len);
        size += len;

        AppendSeparator(sep);
        return 1;
    }

    //
    // Append Unicode string to the buffer
    //
    INT AppendUnicodeString(const WCHAR* str, CHAR sep) {
        UINT len = wcslen(str);

        if (!ReserveSpace(len+2)) return 0;

        BYTE* p = data + size;
        size += len;
        while (len--)
            *p++ = (BYTE) *str++;
        
        AppendSeparator(sep);
        return 1;
    }

    //
    // Free the data buffer
    //
    VOID Dispose() {
        Free(data);
        data = NULL;
        size = maxsize = 0;
    }

private:

    enum { ALLOCINCR = 1024 };
        // Grow the buffer in 1KB blocks

    //
    // Allocate data memory for this buffer
    //
    BOOL Alloc(UINT newMaxsize) {
        // Check if the buffer is already big enough
        if (maxsize >= newMaxsize) return TRUE;

        // Allocate new data buffer
        newMaxsize = (newMaxsize+ALLOCINCR-1) & ~(ALLOCINCR-1);
        BYTE* newData = (BYTE*) MAlloc(newMaxsize);
        if (!newData) return FALSE;

        // Copy the content of the existing data buffer
        if (size) {
            CopyMem(newData, data, size);
        }
        Free(data);
        data = newData;
        maxsize = newMaxsize;
        return TRUE;
    }

    //
    // Append separator to the buffer
    //  The buffer has at least 2 bytes of available space
    //
    VOID AppendSeparator(CHAR sep) {
        switch (sep) {
        case 0:
            break;
        case LF:
            data[size++] = CR;
            data[size++] = LF;
            break;
        case COMMA:
            data[size++] = COMMA;
            data[size++] = SPACE;
            break;
        case COLON:
            data[size++] = COLON;
            data[size++] = SPACE;
            break;
        default:
            data[size++] = sep;
            break;
        }
    }
};


//
// Object returned by InternetConnect call (OBJTYPE_CONNECT)
//
class ConnectObject : public BaseObject {
public:

    // Instantiate a new HTTP connection object
    static ConnectObject*
    Create(
        InternetObject* inetobj,
        const WCHAR* serverName,
        INTERNET_PORT serverPort,
        const WCHAR* username,
        const WCHAR* password,
        DWORD_PTR appContext
        );

    // Return the server address and port number
    // for this connection object
    VOID GetServerAddr(struct sockaddr_in* serveraddr) {
        ZeroMem(serveraddr, sizeof(*serveraddr));
        serveraddr->sin_family = AF_INET;
        serveraddr->sin_port = HTONS(serverPort);
        serveraddr->sin_addr = serverAddr;
    }

    CHAR* GetServerName() { return serverName; }
    CHAR* GetUserName() { return username; }
    InternetObject* GetInternetObject() { return inetobj; }

protected:

    ConnectObject() : BaseObject(OBJTYPE_CONNECT) {
        inetobj = NULL;
        serverName = username = password = NULL;
    }

    ~ConnectObject() {
        if (inetobj) inetobj->Release();
        Free(serverName);
        Free(username);
        Free(password);
    }

    InternetObject* inetobj;
        // Reference to the internet object

    CHAR* serverName;
    struct in_addr serverAddr;
    INTERNET_PORT serverPort;
        // Server host name and IP address and port number
    
    CHAR* username;
    CHAR* password;
        // Username and password
    
    DWORD_PTR appContext;
        // App-specific context value
};


//
// Object returned by InternetOpenUrl and InternetOpenRequest calls (OBJTYPE_REQUEST)
//
class RequestObject : public BaseObject {

public:

    // Instantiate a new HTTP request object
    static RequestObject*
    Create(
        ConnectObject* connobj,
        const WCHAR* verb,
        const WCHAR* objectName,
        const WCHAR* httpVer,
        const WCHAR* referer,
        const WCHAR* acceptTypes[],
        DWORD_PTR appContext
        );

    // Send out the HTTP request
    BOOL
    SendRequest(
        const WCHAR* headers,
        UINT headerLength,
        const VOID* optionalData,
        UINT optionalLength
        );

    // Query response header information
    BOOL
    QueryRespInfo(
        DWORD infoLevel,
        WCHAR* buffer,
        DWORD* buflen,
        DWORD* hdrindex
        );

    // Query the amount of HTTP response data available
    BOOL QueryDataAvailable(DWORD* bytesAvailable);

    // Read HTTP response data
    BOOL ReadData(CHAR* buffer, UINT bufferSize, DWORD* bytesRead);

protected:

    RequestObject() : BaseObject(OBJTYPE_REQUEST) {
        connobj = NULL;
        sock = INVALID_SOCKET;
    }

    ~RequestObject() {
        Disconnect();
        if (connobj) connobj->Release();
    }

    BOOL IsConnected() { return (sock != INVALID_SOCKET); }
    BOOL Connect();
    VOID Disconnect() {
        if (sock != INVALID_SOCKET) {
            closesocket(sock);
            sock = INVALID_SOCKET;
        }
        ResetRespInfo();
    }

    VOID ResetRespInfo() {
        resphdrs.Dispose();
        resphdrsOk = FALSE;
        resphdrLinecnt = 0;
        peekdata = resphdrs.data;
        peeklen = 0;
        contentlen = 0xffffffff;
        readcnt = 0;
    }

    BOOL ReadRespHdrs(BOOL wait);
    BOOL IsRespHdrsOk() { return resphdrsOk != 0; }
    VOID ParseRespHdrs(BOOL eof);
    BOOL MatchHeaderField(BYTE* data, const CHAR* fieldname, CHAR** fieldval);

    CHAR* ParseStatusLine(CHAR* buf, DWORD buflen, DWORD field);
    BOOL ReturnAllRespHdrs(WCHAR* buf, DWORD* buflen, DWORD field);

    ConnectObject* connobj;
        // Reference to the parent connection object
    
    DWORD_PTR appContext;
        // App-specific context value

    SOCKET sock;
        // Open socket handle

    HdrBuf reqhdrs;
        // HTTP request headers

    enum { MAXRESPHDRS = 32 };
        // Maximum number of HTTP response headers allowed

    HdrBuf resphdrs;
    BOOL resphdrsOk;
    BYTE* resphdrLines[MAXRESPHDRS];
    UINT resphdrLinecnt;
    BYTE* peekdata;
    UINT peeklen;
    UINT contentlen;
    UINT readcnt;
        // HTTP response information
};


//
// Macros for getting 
//
#define LOCK_INTERNET_OBJECT(_handle) \
        ((InternetObject*) BaseObject::Lock(_handle, OBJTYPE_INTERNET))

#define LOCK_CONNECT_OBJECT(_handle) \
        ((ConnectObject*) BaseObject::Lock(_handle, OBJTYPE_CONNECT))

#define LOCK_REQUEST_OBJECT(_handle) \
        ((RequestObject*) BaseObject::Lock(_handle, OBJTYPE_REQUEST))


//
// Wrap implementation-specific global functions
// and variable in our private namespace.
//
namespace WininetImpl {
    //
    // Resolve a host name to its IP address
    //  if the host name string is in dotted decimal form, 
    //  it's treated directly as an IP address string.
    //
    struct in_addr ResolveHostAddr(const CHAR* hostname);

    //
    // Crack an HTTP URL to extract various parts:
    //  serverName
    //  serverPort
    //  objectName
    //
    BOOL
    HttpParseUrl(
        const WCHAR* url,
        WCHAR** serverName,
        INTERNET_PORT* serverPort,
        WCHAR** objectName
        );


    //
    // Default HTTP string constants
    //
    extern const WCHAR HttpDefaultVerbStr[];
    extern const WCHAR HttpDefaultVersionStr[];
    extern const WCHAR HttpDefaultObjectStr[];

    //
    // Wrappers for Winsock APIs
    //
    inline _connect(SOCKET s, struct sockaddr_in* addr) {
        return connect(s, (struct sockaddr*) addr, sizeof(*addr));
    }

    //
    // Convert a Unicode string to an ASCII string
    //
    inline CHAR* strdupWtoA(const WCHAR* wstr, UINT count = 0xffffffff) {
        if (count == 0xffffffff) count = wcslen(wstr) + 1;
        CHAR* str = (CHAR*) MAlloc(count);
        CHAR* p;

        if ((p = str) != NULL) {
            // Just chop off the high byte of the Unicode value
            while (count--)
                *p++ = (CHAR) *wstr++;
        }
        return str;
    }

    inline VOID strcpyWtoA(CHAR* dst, const WCHAR* src) {
        while ((*dst++ = (CHAR) *src++) != 0) ;
    }

    inline VOID strcpyAtoW(WCHAR* dst, const CHAR* src) {
        while ((*dst++ = (UCHAR) *src++) != 0) ;
    }
}

using namespace WininetImpl;

#endif // !_WININETP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\inc\interface.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    interface.h

Abstract:

    Common declarations for all network interfaces

Revision History:

    05/04/2000 davidx
        Created it.

--*/

#ifndef _INTERFACE_H
#define _INTERFACE_H

//
// Common information for all network interfaces
//
typedef VOID (*IfDeleteProc)(IfInfo*);
typedef VOID (*IfStartOutputProc)(IfInfo*);
typedef VOID (*IfTimerProc)(IfInfo*);
typedef NTSTATUS (*IfIoctlProc)(IfInfo*, INT, VOID*, UINT, VOID*, UINT*);
typedef struct _IfMcastData IfMcastData;
typedef struct _DhcpInfo DhcpInfo;

typedef struct _IfInfo {
    //
    // Reference count
    //
    LONG refcount;

    //
    // Interface name
    //
    const CHAR* ifname;

    //
    // Interface functions:
    //  deletion
    //  start output
    //  timer
    //  ioctl
    //
    IfDeleteProc Delete;
    IfStartOutputProc StartOutput;
    IfTimerProc Timer;
    IfIoctlProc Ioctl;

    //
    // Output packet queue
    //
    PacketQueue sendq;

    //
    // Flags:
    //  low-order word is common to all interface types
    //  high-order word is interface type specific
    //
    INT flags;

    #define IFFLAG_UP               0x0001  // interface is initialized
    #define IFFLAG_RUNNING          0x0002  //  ... and has a valid IP address
    #define IFFLAG_DHCP_ENABLED     0x0100  // interface is enabled for DHCP
    #define IFFLAG_BCAST            0x0200  // ... supports broadcast
    #define IFFLAG_MCAST            0x0400  // ... supports multicast
    #define IFFLAG_CONNECTED_BOOT   0x0800  // ... is connected to at boot time

    //
    // Hardware address
    //  maximum hardware address length is 16 bytes
    //
    #define MAXHWADDRLEN    16
    #define IFTYPE_LOOPBACK 0
    #define IFTYPE_ETHERNET 1
    #define IFTYPE_DIALUP   2

    WORD iftype;
    WORD hwaddrlen;
    BYTE hwaddr[MAXHWADDRLEN];

    //
    // IP address and subnet mask
    //
    IPADDR ipaddr, addrmask;
    IPADDR subnetAddr, subnetBcastAddr;

    //
    // DHCP related data
    //
    DhcpInfo* dhcpInfo;

    //
    // Multicast groups that we belong to.
    // NOTE: This points to an array of IfMcast structures.
    // The last structure must have its mcastaddr field = 0.
    //
    IfMcastData* mcastData;

    //
    // Misc. configuration parameters
    //
    UINT mtu;               // MTU (maximum transfer unit)
    UINT framehdrlen;       // link layer frame header length
} IfInfo;

//
// Maximum link-layer header size (for all interfaces)
//  should be a multiple of 4
//
#define MAXLINKHDRLEN 16

//
// We only support a maximum of 3 interfaces
//
#define IFINDEX_LOOPBACK    0
#define IFINDEX_LAN         1
#define IFINDEX_DIALUP      2
#define IFINDEX_MAX         3

extern IfInfo* Interfaces[IFINDEX_MAX];

#define LoopbackIfp Interfaces[IFINDEX_LOOPBACK]
#define LanIfp      Interfaces[IFINDEX_LAN]
#define DialupIfp   Interfaces[IFINDEX_DIALUP]

//
// Loop through all interfaces - notice that we count
// down from the last interface to the first interface.
//
#define LOOP_THRU_INTERFACE_LIST(_ifp) { \
            INT _ifindex = IFINDEX_MAX; \
            while (_ifindex-- > 0) { \
                if ((_ifp = Interfaces[_ifindex]) == NULL) continue;

#define END_INTERFACE_LIST_LOOP() \
            } \
        }

// Find the interface with the specified IP address
INLINE IfInfo* IfFindInterface(IPADDR ipaddr) {
    IfInfo* ifp;

    RUNS_AT_DISPATCH_LEVEL

    LOOP_THRU_INTERFACE_LIST(ifp)
        if (ifp->ipaddr == ipaddr) return ifp;
    END_INTERFACE_LIST_LOOP()
    return NULL;
}

// Cache a reference to an interface object
#define CACHE_IFP_REFERENCE(_var, _ifp) ((_var) = (_ifp))

//
// Convenience macros for checking interface flags
//
#define IfUp(_ifp) ((_ifp)->flags & IFFLAG_UP)
#define IfRunning(_ifp) ((_ifp)->flags & IFFLAG_RUNNING)
#define IfDhcpEnabled(_ifp) ((_ifp)->flags & IFFLAG_DHCP_ENABLED)
#define IfBcastEnabled(_ifp) ((_ifp)->flags & IFFLAG_BCAST)
#define IfMcastEnabled(_ifp) ((_ifp)->flags & IFFLAG_MCAST)
#define IfLoopback(_ifp) ((_ifp)->iftype == IFTYPE_LOOPBACK)

//
// Check if the specified address is a broadcast address
// for a particular interface
//
#define IfBcastAddr(_ifp, _addr) \
        (IS_BCAST_IPADDR(_addr) || (_addr) == (_ifp)->subnetBcastAddr)

//
// Append a packet to the end of an interface's output queue.
//  NOTE: we assume we're at DISPATCH_LEVEL.
//
#define IfEnqueuePacket(_ifp, _pkt) \
        PktQInsertTail(&_ifp->sendq, _pkt)

#define IfDequeuePacket(_ifp) \
        PktQRemoveHead(&_ifp->sendq)

//
// Interface I/O control code
//
#define IFCTL_SET_MCAST_ADDRS       1
#define IFCTL_CHECK_ADDR_CONFLICT   2
#define IFCTL_GET_DNSSERVERS        3

//
// Multicast group membership information for each network interface
//
typedef struct _IfMcastGroup {
    LONG refcount;          // reference count for this mcast group
    IPADDR mcastaddr;       // mcast group address
    UINT reportTimer;       // when to send a report for this group
    BOOL sentLastReport;    // we were the last host to send report for this group
} IfMcastGroup;

typedef struct _IfMcastData {
    BOOL hasV1Querier;      // whether there is IGMPv1 querier
    UINT v1QuerierTimer;    // last time we heard IGMPv1 query (in seconds)

    // Variable number of multicast groups
    UINT groupCount;
    IfMcastGroup mcastGroups[1];
} IfMcastData;

// Join and leave multicast groups on an interface
NTSTATUS IfChangeMcastGroup(IfInfo* ifp, IPADDR addr, BOOL add);

#endif // !_INTERFACE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\inc\nettypes.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    nettypes.h

Abstract:

    Common type definitions for the networking code

Revision History:

    05/04/2000 davidx
        Created it.

--*/

#ifndef _NETTYPES_H
#define _NETTYPES_H

//
// C inline function declaration
//
#define INLINE __inline

//
// Private function declaration
//  don't do it for debug build
//
#if DBG
#define PRIVATE
#else
#define PRIVATE static
#endif

//
// Map from bit index to bit mask
//
#define BIT(n) (1u << (n))

//
// System pool allocation functions
//
INLINE VOID* SysAlloc(SIZE_T size, ULONG tag) {
    return ExAllocatePoolWithTag(size, tag);
}

INLINE VOID* SysAlloc0(SIZE_T size, ULONG tag) {
    VOID* p = ExAllocatePoolWithTag(size, tag);
    if (p) { memset(p, 0, size); }
    return p;
}

INLINE VOID SysFree(VOID* ptr) {
    if (ptr) { ExFreePool(ptr); }
}

//
// Private pool allocation functions
//
NTSTATUS XnetPoolInit();
VOID XnetPoolCleanup();
VOID XnetPoolDump();
VOID* XnetAlloc(SIZE_T size, ULONG tag);
VOID XnetFree(VOID* ptr);
INLINE VOID* XnetAlloc0(SIZE_T size, ULONG tag) {
    VOID* p = XnetAlloc(size, tag);
    if (p) { memset(p, 0, size); }
    return p;
}

extern VOID* (*XnetUncachedAllocProc)(SIZE_T, ULONG);
extern VOID (*XnetUncachedFreeProc)(VOID*);
#ifdef DVTSNOOPBUG
NTSTATUS XnetUncachedPoolInit();
VOID XnetUncachedPoolCleanup();
#endif


//------------------------------------------------------------------------
// IP address and port types
//------------------------------------------------------------------------

// Byte-order swapping macros
//  - equivalent to htons/htonl/ntohs/ntohl functions
//  - assumes we're on a little-endian machine

#define HTONL(l) \
        ((((l) >> 24) & 0x000000FFL) | \
         (((l) >>  8) & 0x0000FF00L) | \
         (((l) <<  8) & 0x00FF0000L) | \
         (((l) << 24)              ))

#define HTONS(s) ((WORD) \
        ((((s) >> 8) & 0x00FF) | \
         (((s) << 8) & 0xFF00)))

#define NTOHL HTONL
#define NTOHS HTONS

// IPv4 address in network byte order
typedef DWORD IPADDR;

#define IPADDRLEN                sizeof(IPADDR)
#define IPADDR_ANY               0
#define IPADDR_BCAST             0xffffffff
#define IPADDR_LOOPBACK          HTONL(0x7f000001)
#define IPADDR_ALLHOSTS          HTONL(0xe0000001)
#define IPADDR_ALLROUTERS        HTONL(0xe0000002)
#define CLASSA_NETMASK           HTONL(0xff000000)
#define CLASSB_NETMASK           HTONL(0xffff0000)
#define CLASSC_NETMASK           HTONL(0xffffff00)
#define CLASSD_NETMASK           HTONL(0xf0000000)
#define CLASSD_NETID             HTONL(0xe0000000)
#define LOOPBACK_NETID           HTONL(0x7f000000)
#define IS_MCAST_IPADDR          IS_CLASSD_IPADDR
#define IS_BCAST_IPADDR(addr)    ((addr) == IPADDR_BCAST)
#define IS_CLASSA_IPADDR(addr)   (((addr) & HTONL(0x80000000)) == 0)
#define IS_CLASSB_IPADDR(addr)   (((addr) & HTONL(0xc0000000)) == HTONL(0x80000000))
#define IS_CLASSC_IPADDR(addr)   (((addr) & HTONL(0xe0000000)) == HTONL(0xc0000000))
#define IS_CLASSD_IPADDR(addr)   (((addr) & CLASSD_NETMASK) == CLASSD_NETID)
#define IS_LOOPBACK_IPADDR(addr) (((addr) & CLASSA_NETMASK) == LOOPBACK_NETID)

// TCP/UDP port number in network byte order
typedef WORD IPPORT;

// Source and destination address/port combination
typedef struct _IpAddrPair {
    IPADDR dstaddr;
    IPADDR srcaddr;
    IPPORT dstport;
    IPPORT srcport;
} IpAddrPair;

//------------------------------------------------------------------------
// Network data packet
//------------------------------------------------------------------------

typedef struct _IfInfo IfInfo;
typedef struct _Packet Packet;
typedef struct _IpHeader IpHeader;
typedef struct _RouteTableEntry RTE;
typedef VOID (*PktCompletionProc)(Packet* pkt, NTSTATUS status);

typedef struct _Packet {
    Packet* nextpkt;
        // Points to the next packet in the queue

    WORD pktflags;
        // Packet flags

    WORD iphdrOffset;
        // Offset to where IP datagram header starts

    BYTE* data;
        // Points to where actual data starts

    UINT datalen;
        // Specifies amount of data in the packet

    union {
        IPADDR nexthop;
        IfInfo* recvifp;
        UINT_PTR ifdata;
    };
        // This field has different meaning depending on
        // whether the packet is an incoming packet or
        // an outgoing packet:
        //  for an outgoing packet -
        //      initially contains the next hop IP address
        //      later used as scratch space by the interface driver 
        //  for an incoming packet -
        //      a pointer to the receiving interface

    PktCompletionProc completionCallback;
        // Before passing a packet along for processing,
        // the caller can optionally set up a packet completion
        // routine. When the callee is done with the packet,
        // it'll calls CompletePacket to dispose of the packet.
        // CompletePacket will call the completion routine
        // if it's present. Otherwise, it simply frees the
        // packet memory buffer.
        //
        // !! IMPORTANT NOTE:
        // The callee must not reuse a packet for other purposes
        // if the completion routine is present. Specifically,
        // when an interface driver passes a packet to the upper
        // layer protocols, the upper layer protocol must not
        // reuse the same packet for transmission if the packet
        // completion routine is set.

    BYTE buf[1];
        // Variable size data buffer
} Packet;

//
// Packet header size
//  NOTE: Change the packet fields with care. It should be
//  kept to be a multiple of 8 bytes.
//
#define PKTHDRLEN offsetof(Packet, buf)

// Convenience macros for getting a typecasted pointer
// to the beginning of the packet data buffer and to
// the current packet data.
#define GETPKTBUF(_pkt, _type) ((_type *) (_pkt)->buf)
#define GETPKTDATA(_pkt, _type) ((_type *) (_pkt)->data)

// Figure out where the IP header data starts
#define GETPKTIPHDR(_pkt) ((IpHeader*) ((BYTE*) (_pkt) + (_pkt)->iphdrOffset))
#define SETPKTIPHDR(_pkt, _iphdr) (_pkt)->iphdrOffset = (WORD) ((BYTE*) (_iphdr) - (BYTE*) (_pkt))

//
// bit 0: whether the packet memory came from our private pool
// bit 1: whether the packet is used by the debug monitor stack
// bit 2: physically contiguous memory allocated for DMA transfer
// bit 3: received as link-layer broadcast or multicast packet
//
#define PKTFLAG_NETPOOL BIT(0)  // came from our private pool
#define PKTFLAG_DBGMON  BIT(1)  // used by the debug monitor stack
#define PKTFLAG_DMA     BIT(2)  // receive-only
#define PKTFLAG_MCAST   BIT(3)  // receive-only
#define PKTFLAG_REXMIT  BIT(4)  // send-only: for retransmitted packets
#define PKTFLAG_UNCACHED BIT(5) // temporary hack to workaround nv2a bug

// Allocate and free a network packet
Packet* XnetAllocPacket(UINT size, UINT pktflags);
INLINE VOID XnetFreePacket(Packet* pkt) {
    #ifdef DVTSNOOPBUG
    if (pkt->pktflags & PKTFLAG_UNCACHED) {
        XnetUncachedFreeProc(pkt);
    } else
    #endif
    if (pkt->pktflags & PKTFLAG_NETPOOL) {
        XnetFree(pkt);
    } else {
        SysFree(pkt);
    }
}

// Call this to dispose a packet when we're done using it
INLINE VOID XnetCompletePacket(Packet* pkt, NTSTATUS status) {
    if (pkt->completionCallback) {
        // If the packet has an associated completion function, call it.
        pkt->completionCallback(pkt, status);
    } else {
        // Otherwise, just free it back to the packet pool
        XnetFreePacket(pkt);
    }
}

// Set packet completion function
INLINE VOID XnetSetPacketCompletion(Packet* pkt, PktCompletionProc proc) {
    pkt->completionCallback = proc;
}

//
// Calculate the free space in a packet before and after
// the current data buffer:
//  pkt             pkt->data  ... + pkt->datalen
//   |               |                |
//   v  header       v                v
//  |xxxxxxxxxxx     xxxxxxxxxxxxxxxxx          |
//              space                   space
//              before                  after
//
#define PktSpaceBefore(_pkt) \
        ((_pkt)->data - (_pkt)->buf)

//------------------------------------------------------------------------
// A singly-linked packet queue
//------------------------------------------------------------------------

typedef struct _PacketQueue {
    Packet* head;
    Packet* tail;
} PacketQueue;

// Initialize a packet queue
#define PktQInit(_q) ((_q)->head = (_q)->tail = NULL)

// Determine if a packet queue is empty
#define PktQIsEmpty(_q) ((_q)->head == NULL)

// Insert a packet to the end of a packet queue
INLINE VOID PktQInsertTail(PacketQueue* q, Packet* pkt) {
    if (q->tail)
        q->tail->nextpkt = pkt;
    else
        q->head = pkt;

    q->tail = pkt;
    pkt->nextpkt = NULL;
}

// Insert a packet to the beginning of a packet queue
INLINE VOID PktQInsertHead(PacketQueue* q, Packet* pkt) {
    if ((pkt->nextpkt = q->head) == NULL)
        q->tail = pkt;
    q->head = pkt;
}

// Remove a packet at the head of a packet queue
//  !!! The queue must not be empty when this is called.
INLINE Packet* PktQRemoveHead(PacketQueue* q) {
    Packet* pkt = q->head;

    if ((q->head = pkt->nextpkt) == NULL)
        q->tail = NULL;
    else
        pkt->nextpkt = NULL;

    return pkt;
}

// Join two queues together:
//  q2 is inserted before q1
//  and we assume q2 isn't empty
INLINE VOID PktQJoinBefore(PacketQueue* q1, PacketQueue* q2) {
    if (!q1->tail) q1->tail = q2->tail;
    q2->tail->nextpkt = q1->head;
    q1->head = q2->head;
}

#endif // !_NETTYPES_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\inc\netutil.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    netutil.h

Abstract:

    Common functions and macros shared by the networking code

Revision History:

    03/27/2000 davidx
        Created it.

--*/

#ifndef _NETUTIL_H
#define _NETUTIL_H

//
// Misc. macros
//
#define SizeofWSTR(ws)  ((wcslen(ws) + 1) * sizeof(WCHAR))
#define SizeofSTR(s)    ((strlen(s) + 1) * sizeof(CHAR))
#define ARRAYCOUNT(a)   (sizeof(a) / sizeof(a[0]))
#define ROUNDUP4(count) (((UINT)(count) + 3) & ~3)
#define ROUNDUP8(count) (((UINT)(count) + 7) & ~7)
#define ZeroMem(p, n)   memset(p, 0, n)
#define CopyMem         memcpy
#define MoveMem         memmove
#define EqualMem(d,s,n) (memcmp(d, s, n) == 0)

//
// Memory allocation and deallocation functions
//

#ifdef _XNET_SERVICE

// allocate from the process heap
INLINE VOID* MAlloc(SIZE_T size) {
    return (VOID*) LocalAlloc(LMEM_FIXED, size);
}

INLINE VOID* MAlloc0(SIZE_T size) {
    return (VOID*) LocalAlloc(LPTR, size);
}

// free to the process heap
INLINE VOID Free(VOID* ptr) {
    LocalFree((HLOCAL) (ptr));
}

#endif // _XNET_SERVICE

//
// General net error codes:
//  facility = win32 + winsock error code
//
#define NETERR(_err)        HRESULT_FROM_WIN32(_err)
#define NETERR_OK           STATUS_SUCCESS
#define NETERR_PARAM        NETERR(WSAEINVAL)
#define NETERR_MEMORY       NETERR(WSAENOBUFS)
#define NETERR_SYSCALL      NETERR(WSASYSCALLFAILURE)
#define NETERR_FAULT        NETERR(WSAEFAULT)
#define NETERR_CANCELLED    NETERR(WSAECANCELLED)
#define NETERR_PENDING      NETERR(WSA_IO_PENDING)
#define NETERR_WOULDBLOCK   NETERR(WSAEWOULDBLOCK)
#define NETERR_MSGSIZE      NETERR(WSAEMSGSIZE)
#define NETERR_TIMEOUT      NETERR(WSAETIMEDOUT)
#define NETERR_NOTIMPL      NETERR(ERROR_CALL_NOT_IMPLEMENTED)
#define NETERR_UNREACHABLE  NETERR(WSAEHOSTUNREACH)
#define NETERR_NETDOWN      NETERR(WSAENETDOWN)
#define NETERR_ADDRINUSE    NETERR(WSAEADDRINUSE)
#define NETERR_ADDRCONFLICT NETERR(ERROR_DHCP_ADDRESS_CONFLICT)
#define NETERR_CONNRESET    NETERR(WSAECONNRESET)

// XBox-specific net error codes:
#define NETERR_HARDWARE     0x801f0001  // hardware not responding
#define NETERR_DISCARDED    0x801f0002  // packet discarded
#define NETERR_REASSEMBLY   0x801f0003  // IP datagram reassembly failed

//
// Raise IRQL to DISPATCH_LEVEL and restore it
//
#define RaiseToDpc KeRaiseIrqlToDpcLevel
#define LowerFromDpc KeLowerIrql

// Check if a doubly-linked list head is NULL (uninitialized)
#define IsListNull(_list) ((_list)->Flink == NULL)

#ifndef _NTSYSTEM_

//
// Pseudo-random number generator
//  range: 0 to 0x7fffffff
//
extern ULONG XnetRandSeed;

VOID XnetInitRandSeed();

INLINE ULONG XnetRand() {
    return RtlRandom(&XnetRandSeed);
}

INLINE ULONG XnetRandScaled(ULONG maxval) {
    return RtlRandom(&XnetRandSeed) % (maxval+1);
}

// Check if an IP address is a valid non-loopback unicast address
INLINE XnetIsValidUnicastAddr(IPADDR addr) {
    return (addr != 0) &&
           !IS_BCAST_IPADDR(addr) &&
           !IS_MCAST_IPADDR(addr) &&
           !IS_LOOPBACK_IPADDR(addr);
}

// Convert an IP address to an ASCII character string and vice versa
CHAR* IpAddrToString(IPADDR ipaddr, CHAR* buf, INT buflen);
BOOL IpAddrFromString(const CHAR* str, IPADDR* addr);

INLINE CHAR* IPADDRSTR(IPADDR ipaddr) {
    static CHAR buf[16];
    return IpAddrToString(ipaddr, buf, sizeof(buf));
}

// Return the default subnet mask for a given IP address
IPADDR XnetGetDefaultSubnetMask(IPADDR ipaddr);

// Check if a subnet mask is valid (i.e. of the form 111...000)
INLINE BOOL XnetIsValidSubnetMask(IPADDR addrmask) {
    addrmask = ~NTOHL(addrmask);
    return (addrmask & (addrmask+1)) == 0;
}

//
// Compute and set the checksum field of some message header
//
UINT tcpipxsum(UINT xsum, const VOID* buf, UINT buflen);
#define COMPUTE_CHECKSUM(_field, _buf, _len) \
        (_field) = 0; \
        (_field) = (WORD) ~tcpipxsum(0, _buf, _len)

//
// Make a copy of the specified packet
//
Packet* XnetCopyPacket(Packet* pkt, UINT extraHdr);

//
// Deferenece an XAPI event handle to get
// a pointer to the kernel-mode event object
//
INLINE PRKEVENT GetKernelEventObject(HANDLE hEvent) {
    NTSTATUS status;
    PRKEVENT kEvent;

    if (!hEvent) return NULL;
    status = ObReferenceObjectByHandle(
                hEvent,
                ExEventObjectType,
                (VOID**) &kEvent);

    return NT_SUCCESS(status) ? kEvent : NULL;
}

//
// Wait for a kernel event object to be signalled
//
INLINE NTSTATUS WaitKernelEventObject(PRKEVENT kEvent, UINT timeout) {
    LARGE_INTEGER waittime;
    NTSTATUS status;

    waittime.QuadPart = Int32x32To64(timeout, -10000);
    status = KeWaitForSingleObject(
                    kEvent,
                    UserRequest,
                    UserMode,
                    FALSE,
                    timeout ? &waittime : NULL);

    return (status == STATUS_SUCCESS) ? NETERR_OK : NETERR_TIMEOUT;
}

//
// Signal a kernel event object
//
INLINE VOID SetKernelEvent(PRKEVENT kEvent) {
    KeSetEvent(kEvent, EVENT_INCREMENT, FALSE);
}

#endif // !_NTSYSTEM_

//
// Pool tags
//
#define PTAG_POOL   '!TEN'
#define PTAG_PKT    '0TEN'
#define PTAG_ENET   '1TEN'
#define PTAG_ARP    '2TEN'
#define PTAG_LPBK   '3TEN'
#define PTAG_MCAST  '4TEN'
#define PTAG_RTE    '5TEN'
#define PTAG_PCB    '6TEN'
#define PTAG_TCB    '7TEN'
#define PTAG_RREQ   '8TEN'
#define PTAG_RBUF   '9TEN'
#define PTAG_DHCP   'aTEN'
#define PTAG_DNS    'bTEN'
#define PTAG_SOPTS  'cTEN'
#define PTAG_NIC    'dTEN'

#endif // !_NETUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\inc\route.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    route.h

Abstract:

    Routing related declarations

Revision History:

    05/23/2000 davidx
        Created it.

--*/

#ifndef _ROUTE_H
#define _ROUTE_H

//
// Routing table entry
//
typedef struct _RouteTableEntry {
    union {                 // double-link pointers - must be the first field!
        LIST_ENTRY links;
        LIST_ENTRY;
    };
    LONG refcount;          // reference count on this entry
    INT flags;              // route flags
    INT metric;             // route metrics: smaller value = higher priority
    IPADDR dstaddr;         // destination address
    IPADDR addrmask;        // address mask
    IPADDR nexthop;         // next hop gateway address
    IfInfo* ifp;            // next hop interface
};

// Route table entry flags
#define RTEFLAG_ORPHAN      0x0001  // the route entry is orphaned
#define RTEFLAG_HOST        0x0002  // host route
#define RTEFLAG_DEFAULT     0x0004  // default gateway route
#define RTEFLAG_LOCAL       0x0008  // local route
#define RTEFLAG_BCAST       0x0010  // broadcast route
#define RTEFLAG_MCAST       0x0020  // multicast route

#define IsRteLocal(_rte)    ((_rte)->flags & RTEFLAG_LOCAL)
#define IsRteBcast(_rte)    ((_rte)->flags & RTEFLAG_BCAST)
#define IsRteOrphaned(_rte) ((_rte)->flags & RTEFLAG_ORPHAN)

// Increment or decrement route table entry reference count
#define RteAddRef(_rte) ((_rte)->refcount += 1)
#define RteDecRef(_rte) ((_rte)->refcount -= 1)

// Initialize and clean up the route table
NTSTATUS IpInitRouteTable();
VOID IpRemoveInterfaceRTE(IfInfo* ifp, BOOL deleteBcastRte);
INLINE VOID IpCleanupRouteTable() {
    IpRemoveInterfaceRTE(NULL, TRUE);
}

// Dump the route table in the debugger
#if DBG
VOID IpDumpRouteTable();
#endif

// Find a route table entry for the specified destination address
RTE* IpFindRTE(IPADDR dstaddr, IfInfo* ifp);

// Add or remove a route table entry
NTSTATUS
IpAddRTE(
    IPADDR dstaddr,
    IPADDR addrmask,
    IPADDR nexthop,
    IfInfo* ifp,
    INT flags,
    INT metric
    );

// Default route metric value
#define DEFAULT_RTE_METRIC 1

// Redirect the route for a destination host
VOID
IpRedirectHostRoute(
    IfInfo* ifp,
    IPADDR dstaddr,
    IPADDR oldgwaddr,
    IPADDR newgwaddr
    );

// Remove route table entries
VOID IpRemoveRTE(IPADDR dstaddr, IPADDR addrmask, IPADDR nexthop);

// Release the reference to a cached route entry
INLINE VOID IpReleaseCachedRTE(RTE* rte) {
    if (InterlockedDecrement(&rte->refcount) == 0) {
        ASSERT(IsRteOrphaned(rte));
        XnetFree(rte);
    }
}

// Add a default gateway route going through an interface
INLINE VOID IpAddDefaultGateway(IPADDR gwaddr, INT metric, IfInfo* ifp) {
    IpAddRTE(0, 0, gwaddr, ifp, RTEFLAG_DEFAULT, metric);
}

// Remove a default route going through an interface
INLINE VOID IpRemoveDefaultGateway(IPADDR gwaddr) {
    IpRemoveRTE(0, 0, gwaddr);
}

// Designate an interface for transmit outgoing broadcast/multicast packets.
NTSTATUS IpSetBroadcastInterface(IfInfo* ifp);
NTSTATUS IpSetMulticastInterface(IfInfo* ifp);

#endif // !_ROUTE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\inc\tcp.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    tcp.h

Abstract:

    TCP/UDP protocol related declarations.

Notes:

    Please refer to RFC 793, 768, and 2581.

Revision History:

    05/02/2000 davidx
        Created it.

--*/

#ifndef _TCP_H
#define _TCP_H

//
// UDP datagram header format
//
typedef struct _UdpHeader {
    IPPORT srcport;     // source port
    IPPORT dstport;     // destination port
    WORD length;        // datagram length (incl. header)
    WORD checksum;      // datagram checksum
} UdpHeader;

// UDP header length
#define UDPHDRLEN sizeof(UdpHeader)

//
// TCP/UDP pseudo-header structure
//
typedef struct _PseudoHeader {
    IPADDR srcaddr;
    IPADDR dstaddr;
    BYTE zero;
    BYTE protocol;
    WORD length;
} PseudoHeader;

//
// TCP segment header format
//
typedef struct _TcpHeader {
    IPPORT srcport;     // source port
    IPPORT dstport;     // destination port
    DWORD seqnum;       // sequence number
    DWORD acknum;       // acknowledgement number
    BYTE hdrlen;        // header length (# of DWORDs)
    BYTE flags;         // flags
    WORD window;        // window
    WORD checksum;      // checksum
    WORD urgent;        // urgent pointer
} TcpHeader;

// Default TCP header length (without options)
#define TCPHDRLEN sizeof(TcpHeader)
#define MAXTCPHDRLEN (4*15)

// Extract the TCP header length (in bytes)
#define GETTCPHDRLEN(_tcphdr) (((_tcphdr)->hdrlen & 0xf0) >> 2)
#define SETTCPHDRLEN(_tcphdr, _hdrlen) ((_tcphdr)->hdrlen = (BYTE) (ROUNDUP4(_hdrlen) << 2))

// TCP segment flag bits
#define TCP_FIN 0x01
#define TCP_SYN 0x02
#define TCP_RST 0x04
#define TCP_PSH 0x08
#define TCP_ACK 0x10
#define TCP_URG 0x20

// Control flags
#define TCP_CONTROLS (TCP_SYN|TCP_FIN|TCP_RST) 

// convenience macro for checking segment flags
#define ISTCPSEG(_tcphdr, _flag) ((_tcphdr)->flags & TCP_##_flag)

//
// TCP option tags
//
#define TCPOPT_EOL              0x00
#define TCPOPT_NOP              0x01
#define TCPOPT_MAX_SEGSIZE      0x02
#define TCPOPT_WINDOW_SCALE     0x03
#define TCPOPT_SACK_PERMITTED   0x04
#define TCPOPT_SACK             0x05
#define TCPOPT_TIMESTAMP        0x08

// Default MSS (maximum segment size)
//  576 - 20 (IP header) - 20 (TCP header)
#define TCP_DEFAULT_MSS 536

#endif // !_TCP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\inc\ip.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    ip.h

Abstract:

    IPv4 protocol related declarations

Notes:

    Please refer to RFC 791, 950, and 1519.

Revision History:

    05/02/2000 davidx
        Created it.

--*/

#ifndef _IP_H
#define _IP_H

//
// IPv4 datagram header
//
typedef struct _IpHeader {
    BYTE ver_hdrlen;    // version & header length
    BYTE tos;           // type of service
    WORD length;        // total length
    WORD id;            // identification
    WORD fragoffset;    // flags & fragment offset
    BYTE ttl;           // time to live
    BYTE protocol;      // protocol
    WORD hdrxsum;       // header checksum
    IPADDR srcaddr;     // source address
    IPADDR dstaddr;     // destination address
} IpHeader;

// IP datagram header length without options (20 bytes)
#define IPHDRLEN sizeof(IpHeader)

// Maximum IP header length (60 bytes)
#define MAXIPHDRLEN (15*4)

// Maximum IP datagram length
#define MAXIPLEN 0xffff

// Check IP version and get header length (in bytes)
#define IPVER4 0x40
#define VERIFY_IPVER_HDRLEN(_verhdrlen) \
        ((((_verhdrlen) & 0xf0) == IPVER4) ? (((_verhdrlen) & 0x0f) << 2) : 0)

#define GETIPHDRLEN(_iphdr) (((_iphdr)->ver_hdrlen & 0x0f) << 2)
#define GETIPLEN(_iphdr)    NTOHS((_iphdr)->length)

//
// Bit assignment for the flags & fragment offset field
//  bit 15: reserved
//  bit 14: 1 = don't fragment
//  bit 13: 1 = more fragments
//  bit 12-0: fragment offset (in units of 8 bytes)
//
#define DONT_FRAGMENT   BIT(14)
#define MORE_FRAGMENTS  BIT(13)
#define FRAGOFFSET_MASK 0x1fff

//
// IP option tags
//  bit 7: 1 = option copied into fragments
//  bit 6-5: option class
//  bit 4-0: option number
//
#define IPOPT_EOL               0x00    // no copy
#define IPOPT_NOP               0x01    // no copy
#define IPOPT_SECURITY          0x82    // copy, control
#define IPOPT_LOOSE_SRCROUTE    0x83    // copy, control
#define IPOPT_RECORD_ROUTE      0x07    // no copy, control
#define IPOPT_STREAM_ID         0x88    // copy, control
#define IPOPT_STRICT_SRCROUTE   0x89    // copy, control
#define IPOPT_TIMESTAMP         0x44    // no copy, debug

//
// IP protocol numbers
//
#define IPPROTOCOL_ICMP 1
#define IPPROTOCOL_IGMP 2
#define IPPROTOCOL_TCP  6
#define IPPROTOCOL_UDP  17

#endif // !_IP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\inc\xmodem.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

    xmodem.h

Abstract:

    Microsoft XBox specific modem APIs.

--*/

#ifndef __XMODEM_H__
#define __XMODEM_H__

#define MODEM_BUFFER_SIZE 64

BOOL ModemIsConnected(VOID);
BOOL ModemOpen(HANDLE hEvent);
BOOL ModemClose(VOID);

BOOL ModemWrite(PUCHAR buffer, ULONG *pcb);
BOOL ModemRead(PUCHAR buffer, ULONG *pcb);
BOOL ModemPurge(DWORD dwFlags);

BOOL ModemGetLineCoding(PULONG pBaudRate, PUCHAR pStopBits, PUCHAR pParity,
        PUCHAR pDataBits);
BOOL ModemSetLineCoding(ULONG BaudRate, UCHAR StopBits, UCHAR Parity,
        UCHAR DataBits);
BOOL ModemGetDtrRts(USHORT *pwState);
BOOL ModemSetDtrRts(USHORT wState);

#endif // __XMODEM_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\inc\xppp.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

    xppp.h

Abstract:

    Xbox PPP APIs.

--*/

#ifndef __XPPP_H__
#define __XPPP_H__

/*
 * Errors
 */
#define PPP_ERROR_BASE                  600
#define ERROR_PENDING                   (PPP_ERROR_BASE + 0)
#define ERROR_BUFFER_TOO_SMALL          (PPP_ERROR_BASE + 3)
#define ERROR_UNKNOWN                   (PPP_ERROR_BASE + 35)
#define ERROR_AUTHENTICATION_FAILURE    (PPP_ERROR_BASE + 91)
#define ERROR_PPP_INVALID_PACKET        (PPP_ERROR_BASE + 122)
#define ERROR_PPP_NOT_CONVERGING        (PPP_ERROR_BASE + 132)
#define ERROR_PPP_CP_REJECTED           (PPP_ERROR_BASE + 133)
#define ERROR_PPP_LOOPBACK_DETECTED     (PPP_ERROR_BASE + 137)

/*
 * API entry points
 */
BOOL PppConnect(CHAR *pszUsername, CHAR *pszPassword, CHAR *pszDomain, CHAR *pszNumber);

#endif // __XPPP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\inc\xnetp.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    xnetp.h

Abstract:

    Prototypes shared by XBox net implementation

Revision History:

    05/17/2000 davidx
        Created it.

--*/

#ifndef _XNETP_H
#define _XNETP_H

// Put all xnet code in its own section
#pragma code_seg("XNET")
#pragma const_seg("XNET_RD")

#define _NTDRIVER_

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#include <stddef.h>
#include <ntos.h>
#include <nturtl.h>

#ifdef __cplusplus
}
#endif // __cplusplus

#include <xtl.h>
#include <winsockp.h>

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#include "nettypes.h"
#include "debug.h"
#include "ip.h"
#include "tcp.h"
#include "interface.h"
#include "netutil.h"

//
// TCP/UDP module
//

NTSTATUS TcpInitialize();
VOID TcpCleanup();
VOID TcpReceivePacket(Packet* pkt);
VOID TcpSourceQuench(const IpHeader* iphdr);
VOID UdpReceivePacket(Packet* pkt);
VOID RawReceivePacket(Packet* pkt);
VOID UdpSendPacketInternal(Packet*, IpAddrPair*, IfInfo*);

// TCP tick count is increment every half second (500ms)
#define SLOW_TCP_TIMER_FREQ 2
extern UINT TcpTickCount;

//
// IP module
//

NTSTATUS IpInitialize();
VOID IpCleanup();
VOID IpTimerProc();

NTSTATUS IpSendPacket(Packet* pkt, IPADDR dstaddr, IfInfo* ifp, RTE** rte);
VOID IpSendPacketInternal(Packet*, IPADDR, IPADDR, BYTE, IfInfo*);
VOID IcmpSendError(Packet* pkt, UINT type, UINT code);
VOID IpReceivePacket(Packet* pkt);

DWORD IpGetBestAddress(IPADDR* addr);
VOID IfSetIpAddr(IfInfo*, IPADDR, IPADDR);
NTSTATUS IfGetDefaultDnsServers(IfInfo*, CHAR*, UINT, IPADDR*, UINT*);

// Return the identifier for the next outgoing IP datagram
// Note that we use the same global ID space for all interfaces.
extern WORD IpNextDgramId;

// Fill in the information in an IP datagram header
#define FILL_IPHEADER(_iphdr, _hdrlen, _tos, _len, _df, _ttl, _proto, _srcaddr, _dstaddr) { \
            (_iphdr)->ver_hdrlen = (BYTE) (IPVER4 | (_hdrlen) >> 2); \
            (_iphdr)->tos = (_tos); \
            (_iphdr)->length = HTONS(_len); \
            (_iphdr)->id = HTONS(IpNextDgramId); IpNextDgramId++; \
            (_iphdr)->fragoffset = (WORD) (_df); \
            (_iphdr)->ttl = (BYTE) (_ttl); \
            (_iphdr)->protocol = (_proto); \
            (_iphdr)->srcaddr = (_srcaddr); \
            (_iphdr)->dstaddr = (_dstaddr); \
            COMPUTE_CHECKSUM((_iphdr)->hdrxsum, (_iphdr), (_hdrlen)); \
        }

// Allocate packet to hold the specified amount of
// protocol header information as well as data
INLINE Packet* XnetAllocIpPacket(UINT ipoptlen, UINT datalen) {
    // Reserve enough space at the beginning of the packet buffer
    // to hold the link-layer frame header. Then add the IP header
    // and option length.
    UINT hdrlen = MAXLINKHDRLEN + IPHDRLEN + ROUNDUP4(ipoptlen);
    Packet* pkt;

    if ((pkt = XnetAllocPacket(hdrlen+datalen, PKTFLAG_NETPOOL)) != NULL) {
        pkt->iphdrOffset = PKTHDRLEN + MAXLINKHDRLEN;
        pkt->data += hdrlen;
        pkt->datalen = datalen;
    }
    return pkt;
}

//
// DHCP module
//

NTSTATUS DhcpInitialize(IfInfo* ifp);
VOID DhcpCleanup(IfInfo* ifp);
VOID DhcpTimerProc(IfInfo* ifp);
VOID DhcpReceivePacket(IfInfo* ifp, Packet* pkt);
VOID DhcpNotifyAddressConflict(IfInfo* ifp);
VOID DhcpSetDefaultGateways(IfInfo* ifp);
DWORD DhcpGetActiveAddressType(IfInfo* ifp);
NTSTATUS DhcpWaitForAddress(IfInfo* ifp);
NTSTATUS DhcpGetDefaultDnsServers(IfInfo*, CHAR*, UINT, IPADDR*, UINT*);

//
// Network interface modules
//

NTSTATUS EnetInitialize(IfInfo** newifp);
NTSTATUS IpQueueLoopbackPacket(Packet* pkt, BOOL copyflag);

//
// DNS module
//

NTSTATUS DnsInitialize();
VOID DnsCleanup();
VOID DnsNotifyDefaultServers(IfInfo* ifp);

typedef struct hostent* (*DnsLookupCallback)(UINT size, VOID* param);
NTSTATUS DnsLookupByName(const char* name, DnsLookupCallback callback, VOID* param);
NTSTATUS DnsLookupByAddr(IPADDR addr, DnsLookupCallback callback, VOID* param);

//
// Configuration parameters
//
extern UINT cfgXnetPoolSize;
extern UINT cfgRecvQLength;
extern UINT cfgXmitQLength;
extern UINT cfgMaxReassemblySize;
extern UINT cfgMaxReassemblyDgrams;
extern BYTE cfgDefaultTtl;
extern BYTE cfgDefaultTos;
extern UINT cfgDefaultSendBufsize;
extern UINT cfgDefaultRecvBufsize;
extern UINT cfgMaxSendRecvBufsize;
extern UINT cfgMaxSockets;
extern UINT cfgXnetConfigFlags;

extern UINT defaultPacketAllocFlag;

// Check if XNET is running inside the debug monitor
#define XnetInsideDbgmon() (defaultPacketAllocFlag & PKTFLAG_DBGMON)

//
// Maximum number of default gateways and DNS servers
//
#define MAX_DEFAULT_DNSSERVERS 4
#define MAX_DEFAULT_GATEWAYS 4

//
// Perf counters
//
#ifdef DEVKIT

extern ULONGLONG IpTotalBytesSent;
extern ULONGLONG IpTotalBytesRecv;
extern ULONGLONG TcpTotalBytesSent;
extern ULONGLONG TcpTotalBytesRecv;
extern ULONGLONG UdpTotalBytesSent;
extern ULONGLONG UdpTotalBytesRecv;
extern ULONG IpTotalDgramsSent;
extern ULONG IpTotalDgramsRecv;
extern ULONG UdpTotalDgramsSent;
extern ULONG UdpTotalDgramsRecv;
extern ULONG TcpTotalSegmentsSent;
extern ULONG TcpTotalSegmentsRecv;

#define XnetIncrementPerfCount(counter, incr) ((counter) += (incr))

#else // !DEVKIT

#define XnetIncrementPerfCount(counter, incr)

#endif // !DEVKIT

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // !_XNETP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\ip\icmp.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    icmp.c

Abstract:

    Implementation of ICMP related functions

Revision History:

    05/22/2000 davidx
        Created it.

--*/

#include "precomp.h"


PRIVATE IPADDR
IcmpShouldSendResponse(
    Packet* recvpkt,
    BOOL error
    )

/*++

Routine Description:

    Determine if we should send an ICMP message in response
    to a received datagram

Arguments:

    recvpkt - Specifies the received datagram
    error - Whether we're trying to send an error response

Return Value:

    IP address of the host we should send the ICMP message to;
    0 if we should not send a response

--*/

{
    IPADDR fromaddr, toaddr;
    IfInfo* ifp = recvpkt->recvifp;
    IpHeader* iphdr = GETPKTIPHDR(recvpkt);

    fromaddr = iphdr->srcaddr;
    toaddr = iphdr->dstaddr;

    // We don't respond to ICMP Echo Requests
    // sent to broadcast or multicast addresses
    if (IfBcastAddr(ifp, toaddr) || IS_MCAST_IPADDR(toaddr))
        return 0;

    // Source IP address cannot be one of the following:
    //  0, broadcast or multicast addresses
    if (fromaddr == 0 ||
        IfBcastAddr(ifp, fromaddr) ||
        IS_MCAST_IPADDR(fromaddr))
        return 0;

    if (error) {
        // 1. We don't send ICMP error message to *any* ICMP message
        //    instead of just ICMP error messages.
        // 2. Only send ICMP error for the very first segment.
        // 3. Don't respond if link-layer broadcast or multicast.
        // 4. Don't respond if source is loopback address.
        if ((iphdr->protocol == IPPROTOCOL_ICMP) ||
            (iphdr->fragoffset & HTONS(FRAGOFFSET_MASK)) ||
            (recvpkt->pktflags & PKTFLAG_MCAST) ||
            IS_LOOPBACK_IPADDR(fromaddr))
            return 0;
    }

    return fromaddr;
}


VOID
IcmpSendError(
    Packet* origpkt,
    UINT type,
    UINT code
    )

/*++

Routine Description:

    Send out an ICMP error message in response to a received datagram

Arguments:

    origpkt - The received datagram
    type, code - Specifies the ICMP message type and code

Return Value:

    NONE

--*/

{
    Packet* sendpkt;
    UINT icmpdatalen;
    IcmpMessage* icmpmsg;
    IPADDR fromaddr;
    IpHeader* origiphdr;
    IfInfo* ifp = origpkt->recvifp;

    // make sure we're allowed to send an ICMP message
    fromaddr = IcmpShouldSendResponse(origpkt, TRUE);
    if (fromaddr == 0) return;
    
    // allocate packet buffer for composing the ICMP message
    origiphdr = GETPKTIPHDR(origpkt);
    icmpdatalen = min(GETIPHDRLEN(origiphdr) + 8, GETIPLEN(origiphdr));

    sendpkt = XnetAllocIpPacket(0, ICMPHDRLEN+icmpdatalen);
    if (!sendpkt) return;

    icmpmsg = GETPKTDATA(sendpkt, IcmpMessage);
    ZeroMem(icmpmsg, ICMPHDRLEN);
    icmpmsg->type = (BYTE) type;
    icmpmsg->code = (BYTE) code;
    CopyMem(icmpmsg->origdata, origiphdr, icmpdatalen);

    COMPUTE_CHECKSUM(icmpmsg->checksum, icmpmsg, ICMPHDRLEN+icmpdatalen);

    IpSendPacketInternal(sendpkt, ifp->ipaddr, fromaddr, IPPROTOCOL_ICMP, ifp);
}


PRIVATE VOID
IcmpSendEchoReply(
    Packet* reqpkt
    )

/*++

Routine Description:

    Respond to an ICMP Echo request message by sending
    out an ICMP Echo Reply message

Arguments:

    reqpkt - Points to the received packet

Return Value:

    NONE

--*/

{
    IPADDR fromaddr;
    Packet* replypkt;
    IfInfo* ifp;
    IcmpMessage* icmpreq;
    IcmpMessage* icmpreply;
    IpHeader* iphdrreq;
    IpHeader* iphdrreply;
    UINT iphdrlen, ipdatalen;

    // make sure it's ok to reply to the request
    fromaddr = IcmpShouldSendResponse(reqpkt, FALSE);
    if (!fromaddr) return;

    // calculate the reply message length
    //  (truncate data if we need to fragment)
    ifp = reqpkt->recvifp;
    iphdrreq = GETPKTIPHDR(reqpkt);
    iphdrlen = GETIPHDRLEN(iphdrreq);
    ipdatalen = GETIPLEN(iphdrreq) - iphdrlen;
    if (iphdrlen+ipdatalen > ifp->mtu)
        ipdatalen = ifp->mtu - iphdrlen;

    // allocate packet buffer and compose
    // the ICMP reply message

    replypkt = XnetAllocIpPacket(iphdrlen-IPHDRLEN, ipdatalen);
    if (!replypkt) return;

    iphdrreply = GETPKTIPHDR(replypkt);
    CopyMem(iphdrreply, iphdrreq, iphdrlen+ipdatalen);

    icmpreq = (IcmpMessage*) ((BYTE*) iphdrreq + iphdrlen);
    icmpreply = (IcmpMessage*) ((BYTE*) iphdrreply + iphdrlen);
    icmpreply->type = ICMPTYPE_ECHO_REPLY;
    icmpreply->code = icmpreq->code;
    icmpreply->id = icmpreq->id;
    icmpreply->seqno = icmpreq->seqno;

    COMPUTE_CHECKSUM(icmpreply->checksum, icmpreply, ipdatalen);

    // reflect option data in the IP header
    fromaddr = IpReflectIpOptions(ifp, iphdrreply, fromaddr);

    IpSendPacketInternal(replypkt, ifp->ipaddr, fromaddr, IPPROTOCOL_ICMP, ifp);
}


PRIVATE BOOL
IcmpCheckEmbeddedIpHeader(
    const IpHeader* iphdr,
    UINT buflen
    )

/*++

Routine Description:

    Validate the embedded IP header information inside an ICMP message

Arguments:

    iphdr - Points to the beginning of the embedded ICMP data
    buflen - Length of the data buffer

Return Value:

    TRUE if the embedded IP header information is valid
    FALSE otherwise

--*/

{
    UINT iphdrlen, iplen;

    if (buflen < IPHDRLEN) return FALSE;

    iphdrlen = VERIFY_IPVER_HDRLEN(iphdr->ver_hdrlen);
    iplen = NTOHS(iphdr->length);

    // must include the IP header plus at least 8 bytes of data
    return (iphdrlen >= IPHDRLEN &&
            iphdrlen <= iplen &&
            iphdrlen+8 <= buflen);
}


VOID
IcmpReceivePacket(
    Packet* pkt
    )

/*++

Routine Description:

    Handle the reception of an ICMP message

Arguments:

    pkt - Points to the received packet

Return Value:

    NONE

--*/

{
    IcmpMessage* icmpmsg;
    IpHeader* origiphdr;

    // verify the ICMP message length and checksum
    if (pkt->datalen < ICMPHDRLEN) goto discard;
    if (tcpipxsum(0, pkt->data, pkt->datalen) != 0xffff)
        goto discard;

    icmpmsg = GETPKTDATA(pkt, IcmpMessage);
    origiphdr = (IpHeader*) icmpmsg->origdata;

    switch (icmpmsg->type) {
    case ICMPTYPE_DESTINATION_UNREACHABLE:
    case ICMPTYPE_TIME_EXECEEDED:
    case ICMPTYPE_PARAMETER_PROBLEM:
    case ICMPTYPE_SOURCE_QUENCH:
    case ICMPTYPE_REDIRECT:
        // verify embedded IP header inside the ICMP message
        if (!IcmpCheckEmbeddedIpHeader(origiphdr, pkt->datalen-ICMPHDRLEN))
            goto discard;

        // handle ICMP redirect message
        //  we treat host and network redirects the same way
        if ((icmpmsg->type == ICMPTYPE_REDIRECT) &&
            (icmpmsg->code == ICMPCODE_REDIRECT_NET ||
             icmpmsg->code == ICMPCODE_REDIRECT_HOST ||
             icmpmsg->code == ICMPCODE_REDIRECT_NET_TOS ||
             icmpmsg->code == ICMPCODE_REDIRECT_HOST_TOS)) {
            IpRedirectHostRoute(
                pkt->recvifp,
                origiphdr->dstaddr,
                GETPKTIPHDR(pkt)->srcaddr,
                icmpmsg->gwaddr);
        }

        // Pass ICMP source quench error message to TCP layer
        if (icmpmsg->type == ICMPTYPE_SOURCE_QUENCH &&
            origiphdr->protocol == IPPROTOCOL_TCP) {
            TcpSourceQuench(origiphdr);
        }
        break;

    case ICMPTYPE_ECHO_REQUEST:
        IcmpSendEchoReply(pkt);
        break;
    }

    RawReceivePacket(pkt);
    return;

discard:
    XnetCompletePacket(pkt, NETERR_DISCARDED);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\ip\igmp.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    igmp.c

Abstract:

    Handle IGMP protocol version 2

Revision History:

    05/31/2000 davidx
        Created it.

--*/

#include "precomp.h"


VOID
IgmpSendMessage(
    IfInfo* ifp,
    IPADDR dstaddr,
    BYTE type,
    IPADDR groupaddr
    )

/*++

Routine Description:

    Send out an IGMP report or leave message

Arguments:

    ifp - Points to the interface structure
    dstaddr - Specifies the message's destination address
    type - Message type
    groupaddr - Address of the multicast group in question

Return Value:

    NONE

--*/

{
    Packet* pkt;
    IgmpMessage* igmpmsg;
    IpHeader* iphdr;

    pkt = XnetAllocIpPacket(0, IGMPHDRLEN);
    if (!pkt) return;

    igmpmsg = GETPKTDATA(pkt, IgmpMessage);
    igmpmsg->type = type;
    igmpmsg->maxresptime = 0;
    igmpmsg->groupaddr = groupaddr;
    COMPUTE_CHECKSUM(igmpmsg->checksum, igmpmsg, IGMPHDRLEN);

    iphdr = GETPKTIPHDR(pkt);
    pkt->data -= IPHDRLEN;
    pkt->datalen += IPHDRLEN;
    pkt->nexthop = dstaddr;

    FILL_IPHEADER(
        iphdr,
        IPHDRLEN,
        0,
        pkt->datalen,
        0,
        1,
        IPPROTOCOL_IGMP,
        ifp->ipaddr,
        dstaddr);

    // Queue up the packet for transmission
    IfEnqueuePacket(ifp, pkt);
    ifp->StartOutput(ifp);
}


PRIVATE VOID
IgmpSetQueryReportTimer(
    IfInfo* ifp,
    IfMcastGroup* mcastgrp,
    UINT maxresptime
    )

/*++

Routine Description:

    Set the query report timer on a multicast group we belong to.

Arguments:

    ifp - Points to the interface structure
    mcastgrp - Points to the multicast group in question
    maxresptime - Specifies the maximum response time in 1/10 of a second

Return Value:

    NONE

--*/

{
    // If existing timer value is less than the new max response time,
    // then we just leave the existing timer alone.
    if (mcastgrp->reportTimer && mcastgrp->reportTimer*10 <= maxresptime)
        return;

    // Randomize the response timer
    maxresptime = XnetRandScaled(maxresptime) / 10;

    if ((mcastgrp->reportTimer = maxresptime) == 0) {
        IgmpSendReport(ifp, mcastgrp);
    }
}


PRIVATE VOID
IgmpProcessMessage(
    IfInfo* ifp,
    IgmpMessage* igmpmsg,
    IPADDR dstaddr
    )

/*++

Routine Description:

    Process a received IGMP message

Arguments:

    ifp - Points to the interface structure
    igmpmsg - Points to the received IGMP message
    dstaddr - Destination group the message is addressed to

Return Value:

    NONE

Note:
    
    This function will only be called when the interface
    belongs to the message's destination address group.

--*/

#define LOCATE_MCASTGROUP() \
        while (count--) { \
            if (mcastgrp->mcastaddr == dstaddr) break; \
            mcastgrp++; \
        }

{
    IfMcastData* ifmcast = ifp->mcastData;
    IfMcastGroup* mcastgrp = ifmcast->mcastGroups;
    UINT count = ifmcast->groupCount;
    IPADDR grpaddr = igmpmsg->groupaddr;

    switch (igmpmsg->type) {
    case IGMPTYPE_MEMBER_QUERY:
        if (grpaddr == 0) {
            UINT maxresptime;

            // General query must be directed to all-hosts address
            if (dstaddr != IPADDR_ALLHOSTS) return;

            if (igmpmsg->maxresptime == 0) {
                ifmcast->hasV1Querier = TRUE;
                ifmcast->v1QuerierTimer = IGMP_V1_QUERIER_TIMER;
                maxresptime = IGMP_V1_QUERY_RESPONSE*10;
            } else
                maxresptime = igmpmsg->maxresptime;

            while (count--) {
                IgmpSetQueryReportTimer(ifp, mcastgrp, maxresptime);
                mcastgrp++;
            }
        } else {
            // Group-specific query must directed to that group address
            if (dstaddr != grpaddr) return;

            LOCATE_MCASTGROUP();
            IgmpSetQueryReportTimer(ifp, mcastgrp, igmpmsg->maxresptime);
        }
        break;

    case IGMPTYPE_MEMBER_REPORT_1:
    case IGMPTYPE_MEMBER_REPORT_2:
        // Membership report must be sent to the specific group
        if (dstaddr != grpaddr) return;

        LOCATE_MCASTGROUP();
        mcastgrp->reportTimer = 0;
        mcastgrp->sentLastReport = FALSE;
        break;
    }
}


VOID
IgmpReceivePacket(
    Packet* pkt
    )

/*++

Routine Description:

    Receive  an IGMP packet

Arguments:

    pkt - Points to the received IGMP message

Return Value:

    NONE

--*/

{
    RUNS_AT_DISPATCH_LEVEL

    // Verify packet length and checksum
    if (pkt->datalen < IGMPHDRLEN ||
        tcpipxsum(0, pkt->data, pkt->datalen) != 0xffff) {
        XnetCompletePacket(pkt, NETERR_DISCARDED);
        return;
    }

    // We're only interested in packets addressed
    // to the all-host multicast group here.
    if (pkt->recvifp->mcastData) {
        IgmpProcessMessage(
            pkt->recvifp,
            GETPKTDATA(pkt, IgmpMessage),
            GETPKTIPHDR(pkt)->dstaddr);
    }

    // Pass the packet upstream for further processing
    RawReceivePacket(pkt);
}


VOID
IgmpTimerProc(
    IfInfo* ifp
    )

/*++

Routine Description:

    IGMP timer procedure

Arguments:

    ifp - Points to the interface structure

Return Value:

    NONE

--*/

{
    IfMcastData* ifmcast = ifp->mcastData;
    IfMcastGroup* mcastgrp;
    UINT count;

    ASSERT(ifmcast != NULL);

    if (ifmcast->v1QuerierTimer && --(ifmcast->v1QuerierTimer) == 0)
        ifmcast->hasV1Querier = FALSE;

    mcastgrp = ifmcast->mcastGroups;
    count = ifmcast->groupCount;
    while (count--) {
        if (mcastgrp->reportTimer && --(mcastgrp->reportTimer) == 0) {
            IgmpSendReport(ifp, mcastgrp);
        }
        mcastgrp++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\ip\ipimpl.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    ipimpl.h

Abstract:

    Declarations private to the IP implementation

Revision History:

    05/22/2000 davidx
        Created it.

--*/

#ifndef _IPIMPL_H
#define _IPIMPL_H

// IP datagram reassembly related functions
VOID IpCleanupReassemblyPkts(IfInfo* ifp);
VOID IpReassemblyTimerProc();

// Handle the reception of an ICMP message
VOID IcmpReceivePacket(Packet* pkt);

// Reflect option data in the IP header
IPADDR IpReflectIpOptions(IfInfo* ifp, IpHeader* iphdr, IPADDR dstaddr);

//
// Returns the number of milliseconds since midnight GMT
//
INLINE UINT IpGetMsecsSinceMidnightGMT() {
    LARGE_INTEGER time;
    TIME_FIELDS timeFields;

    KeQuerySystemTime(&time);
    RtlTimeToTimeFields(&time, &timeFields);

    return timeFields.Milliseconds +
           (timeFields.Hour * 3600 +
            timeFields.Minute * 60 +
            timeFields.Second) * 1000;
}

// Find if an interface belongs to a multicast group
BOOL IfFindMcastGroup(IfInfo* ifp, IPADDR addr);
NTSTATUS IfInitMcastGroup(IfInfo* ifp);

// Initialize the loopback interface
NTSTATUS LoopbackInitialize(IfInfo** newifp);

// Process a received IGMP message
VOID IgmpReceivePacket(Packet* pkt);
VOID IgmpTimerProc(IfInfo* ifp);
VOID IgmpSendMessage(IfInfo* ifp, IPADDR dstaddr, BYTE type, IPADDR groupaddr);

INLINE VOID IgmpSendReport(IfInfo* ifp, IfMcastGroup* mcastgrp) {
    if (mcastgrp->mcastaddr != IPADDR_ALLHOSTS) {
        mcastgrp->sentLastReport = TRUE;
        IgmpSendMessage(
            ifp,
            mcastgrp->mcastaddr, 
            (BYTE) (ifp->mcastData->hasV1Querier ?
                    IGMPTYPE_MEMBER_REPORT_1 :
                    IGMPTYPE_MEMBER_REPORT_2),
            mcastgrp->mcastaddr);
    }
}

INLINE VOID IgmpSendLeave(IfInfo* ifp, IfMcastGroup* mcastgrp) {
    if (mcastgrp->mcastaddr != IPADDR_ALLHOSTS &&
        !ifp->mcastData->hasV1Querier &&
        mcastgrp->sentLastReport) {
        IgmpSendMessage(
            ifp,
            IPADDR_ALLROUTERS,
            IGMPTYPE_LEAVE_GROUP,
            mcastgrp->mcastaddr);
    }
}

#endif // !_IPIMPL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\ip\ipinit.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    ipinit.c

Abstract:

    IP module initialization and cleanup related functions

Revision History:

    05/24/2000 davidx
        Created it.

--*/

#include "precomp.h"


//
// Global interface table
//
IfInfo* Interfaces[IFINDEX_MAX];

VOID
IpTimerProc()

/*++

Routine Description:

    IP timer routine - called once a second

Arguments:

    dpc, context, param1, param2 - DPC function parameters

Return Value:

    NONE

--*/

{
    IfInfo* ifp;

    // Call interface timer routines
    LOOP_THRU_INTERFACE_LIST(ifp)
        // NOTE: This is a hack to ensure we don't call the Ethernet interface's
        // timer function twice when we are running under the debug monitor.
        if (XnetInsideDbgmon() &&
            ifp->refcount > 1 &&
            IfRunning(ifp))
            continue;

        if (ifp->Timer) ifp->Timer(ifp);
        if (ifp->mcastData) {
            IgmpTimerProc(ifp);
        }
        if (IfDhcpEnabled(ifp)) {
            DhcpTimerProc(ifp);
        }
    END_INTERFACE_LIST_LOOP()

    // Datagram reassembly timer routine
    IpReassemblyTimerProc();
}


//
// Interface initialization function
//
typedef NTSTATUS (*IfInitProc)(IfInfo**);
static const IfInitProc IfInitProcTable[IFINDEX_MAX] = {
    LoopbackInitialize,     // loopback interface
    EnetInitialize,         // Ethernet interface
    NULL                    // dial-up interface
};

NTSTATUS
IpInitialize()

/*++

Routine Description:

    Initialize the IP module

Arguments:

    NONE

Return Value:

    Status code

--*/

{
    NTSTATUS status;
    UINT ifindex;

    status = IpInitRouteTable();
    if (!NT_SUCCESS(status)) goto failed;

    for (ifindex=0; ifindex < IFINDEX_MAX; ifindex++) {
        IfInitProc initProc = IfInitProcTable[ifindex];
        IfInfo* ifp;

        if (!initProc) continue;
        status = initProc(&ifp);
        if (!NT_SUCCESS(status)) goto failed;

        ASSERT(ifp->hwaddrlen <= MAXHWADDRLEN);
        Interfaces[ifindex] = ifp;

        // Adjust the pseudo-random number generator seed
        // with the Ethernet hardware ID
        if (ifp->iftype == IFTYPE_ETHERNET) {
            ULONG seed = 0;
            WORD addrbyte;
            for (addrbyte=0; addrbyte < ifp->hwaddrlen; addrbyte++) {
                seed = (seed << 8) ^ ifp->hwaddr[addrbyte];
            }
            XnetRandSeed = (XnetRandSeed ^ seed) & 0x7fffffff;
        }

        if (IfBcastEnabled(ifp)) {
            status = IpSetBroadcastInterface(ifp);
            if (!NT_SUCCESS(status)) goto failed;
        }

        if (IfMcastEnabled(ifp)) {
            status = IfInitMcastGroup(ifp);
            if (!NT_SUCCESS(status)) goto failed;
        }

        if (IfDhcpEnabled(ifp)) {
            status = DhcpInitialize(ifp);
            if (!NT_SUCCESS(status)) goto failed;
        }
    }
    
    IpNextDgramId = (WORD) XnetRand();
    return NETERR_OK;

failed:
    WARNING_("IpInitialize failed: 0x%x", status);
    return status;
}


VOID
IpCleanup()

/*++

Routine Description:

    Cleanup the IP module

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    IfInfo* ifp;

    RUNS_AT_DISPATCH_LEVEL

    // Cleanup DHCP info
    LOOP_THRU_INTERFACE_LIST(ifp)
        if (IfDhcpEnabled(ifp)) {
            DhcpCleanup(ifp);
        }
    END_INTERFACE_LIST_LOOP()

    IpCleanupReassemblyPkts(NULL);
    IpCleanupRouteTable();

    // Delete the interfaces
    LOOP_THRU_INTERFACE_LIST(ifp)
        Interfaces[_ifindex] = NULL;

        // NOTE: We shouldn't free per-interface multicast data
        // if the interface is shared by the debug monitor stack.
        if (ifp->refcount <= 1) {
            SysFree(ifp->mcastData);
            ifp->mcastData = NULL;
        }

        ifp->Delete(ifp);
    END_INTERFACE_LIST_LOOP()
    ZeroMem(Interfaces, sizeof(Interfaces));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\ip\icmp.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    icmp.h

Abstract:

    ICMP protocol related declarations.

Notes:

    Please refer to RFC 792 and 1256.

Revision History:

    05/02/2000 davidx
        Created it.

--*/

#ifndef _ICMP_H
#define _ICMP_H

//
// ICMP message types and codes
//
#define ICMPTYPE_DESTINATION_UNREACHABLE    3
#define   ICMPCODE_NET_UNREACHABLE          0
#define   ICMPCODE_HOST_UNREACHABLE         1
#define   ICMPCODE_PROTOCOL_UNREACHABLE     2
#define   ICMPCODE_PORT_UNREACHABLE         3
#define   ICMPCODE_CANT_FRAGMENT_WITH_DF    4
#define   ICMPCODE_SRCROUTE_FAILED          5
#define   ICMPCODE_DEST_NET_UNKNOWN         6
#define   ICMPCODE_DEST_HOST_UNKNOWN        7
#define   ICMPCODE_SRC_HOST_ISOLATED        8
#define   ICMPCODE_DEST_NET_PROHIBITED      9
#define   ICMPCODE_DEST_HOST_PROHIBITED     10
#define   ICMPCODE_NET_UNREACHABLE_TOS      11
#define   ICMPCODE_HOST_UNREACHABLE_TOS     12
#define ICMPTYPE_TIME_EXECEEDED             11
#define   ICMPCODE_TTL_EXCEEDED             0
#define   ICMPCODE_REASSEMBLY_TIMEOUT       1
#define ICMPTYPE_PARAMETER_PROBLEM          12
#define   ICMPCODE_PTR_INDICATES_ERROR      0
#define   ICMPCODE_MISSING_REQD_OPTION      1
#define ICMPTYPE_SOURCE_QUENCH              4
#define ICMPTYPE_REDIRECT                   5
#define   ICMPCODE_REDIRECT_NET             0
#define   ICMPCODE_REDIRECT_HOST            1
#define   ICMPCODE_REDIRECT_NET_TOS         2
#define   ICMPCODE_REDIRECT_HOST_TOS        3
#define ICMPTYPE_ECHO_REQUEST               8
#define ICMPTYPE_ECHO_REPLY                 0
#define ICMPTYPE_TIMESTAMP_REQUEST          13
#define ICMPTYPE_TIMESTAMP_REPLY            14
#define ICMPTYPE_INFO_REQUEST               15
#define ICMPTYPE_INFO_REPLY                 16

//
// Generic ICMP message format
//
typedef struct _IcmpMessage {
    BYTE type;          // ICMP message type
    BYTE code;          // type specific code
    WORD checksum;      // ICMP checksum
    union {             // type/code specific parameters
        struct {        // - for request/reply messages:
            WORD id;    //   identifier
            WORD seqno; //   sequence number
        };
        IPADDR gwaddr;  // - redirect message: gateway address
        BYTE info[4];   // - for other messages
        DWORD unused;   //
    };
    BYTE origdata[1];   // original IP header + some data
} IcmpMessage;

// ICMP message header length
#define ICMPHDRLEN offsetof(IcmpMessage, origdata)

#endif // !_ICMP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\ip\igmp.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    igmp.h

Abstract:

    IGMP protocol related declarations.

Notes:

    Please refer to RFC 1112 and 2236.

Revision History:

    05/02/2000 davidx
        Created it.

--*/

#ifndef _IGMP_H
#define _IGMP_H

//
// IGMP v2 message header format
//
typedef struct _IgmpMessage {
    BYTE type;              // message type
    BYTE maxresptime;       // max response time
    WORD checksum;          // checksum
    IPADDR groupaddr;       // multicast group address
} IgmpMessage;

#define IGMPHDRLEN sizeof(IgmpMessage)

//
// Message type constants
//
#define IGMPTYPE_MEMBER_QUERY    0x11   // membership query
#define IGMPTYPE_MEMBER_REPORT_1 0x12   // membership report (version 1)
#define IGMPTYPE_MEMBER_REPORT_2 0x16   // membership report (version 2)
#define IGMPTYPE_LEAVE_GROUP     0x17   // leave group

//
// When we join a new group, we'll send out two membership report messages.
// The second report is sent out 2 seconds after the first one.
//
#define IGMP_JOIN_RETRY_TIMER   2

//
// IGMPv1 query response timer (10 seconds)
//
#define IGMP_V1_QUERY_RESPONSE  10

//
// How long to wait after hearing an IGMPv1 query
// before we can send IGMPv2 messages again.
//
#define IGMP_V1_QUERIER_TIMER   400

#endif // !_IGMP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\ip\iprecv.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    iprecv.c

Abstract:

    Handles IP datagram reception

Revision History:

    05/17/2000 davidx
        Created it.

--*/

#include "precomp.h"


//
// A singly-linked list of datagrams that're currently
// being reassembled. We're using a list rather than a
// hash table here for simplicity. We assume that fragmentation
// occurs very infrequently.
//
PRIVATE Packet* IpReassemblyPktList;
PRIVATE UINT IpReassemblyPktCount;

// Maximum number of actively reassembled datagrams
UINT cfgMaxReassemblyDgrams = 4;

// Maximum size for a reassembled datagram
UINT cfgMaxReassemblySize = 2048;

// Reassembly timeout period = 60sec
UINT cfgReassemblyTimeout = 60;

//
// Packet containing a datagram that's being reassembled:
//  packet header
//  reassembly information
//  space to hold maximum IP header
//  actual datagram data
//
typedef struct _ReassemblyHeader {
    IPADDR srcaddr;         // source IP address
    IPADDR dstaddr;         // destination IP address
    UINT proto_id;          // datagram ID and protocol
    UINT timer;             // reassembly timer
    UINT origdatalen;       // total length of the original IP datagram
    DWORD bitFlags[1];      // which fragments have arrived?
} ReassemblyHeader;


VOID
IpCleanupReassemblyPkts(
    IfInfo* ifp
    )

/*++

Routine Description:

    Clean up all partially reassembly datagrams

Arguments:

    ifp - Optional parameter: when present we only clean up
        the partial datagrams from the specified interface;
        otherwise, we clean up all partial datagrams.

Return Value:

    NONE

--*/

{
    Packet** link = &IpReassemblyPktList;
    Packet* pkt;

    while ((pkt = *link) != NULL) {
        if (ifp == pkt->recvifp || ifp == NULL) {
            *link = pkt->nextpkt;
            IpReassemblyPktCount--;
            XnetCompletePacket(pkt, NETERR_CANCELLED);
        } else {
            link = &pkt->nextpkt;
        }
    }
}


VOID
IpReassemblyTimerProc()

/*++

Routine Description:

    IP datagram reassembly timer routine

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    Packet** link = &IpReassemblyPktList;
    Packet* pkt;
    ReassemblyHeader* rahdr;

    while ((pkt = *link) != NULL) {
        rahdr = GETPKTBUF(pkt, ReassemblyHeader);
        if (rahdr->timer-- == 0) {
            TRACE_("Reassembly timeout: src = %s", IPADDRSTR(rahdr->srcaddr));
            *link = pkt->nextpkt;
            IpReassemblyPktCount--;

            // Send out an ICMP error message if fragment 0 has been received
            if (pkt->iphdrOffset) {
                pkt->data = (BYTE*) GETPKTIPHDR(pkt);
                IcmpSendError(
                    pkt,
                    ICMPTYPE_TIME_EXECEEDED,
                    ICMPCODE_REASSEMBLY_TIMEOUT);
            }

            XnetCompletePacket(pkt, NETERR_REASSEMBLY);
        } else
            link = &pkt->nextpkt;
    }
}


PRIVATE Packet**
IpFindReassemblyPkt(
    IPADDR srcaddr,
    IPADDR dstaddr,
    UINT proto_id
    )

/*++

Routine Description:

    Check if we already have a partially assembled datagram
    matching the specified identification information.

Arguments:

    srcaddr - Specifies the source IP address
    dstaddr - Specifies the destination IP address
    proto_id - IP protocol number and datagram ID

Return Value:

    Address of the link pointer to the specified datagram

--*/

{
    Packet** link = &IpReassemblyPktList;
    Packet* pkt;
    ReassemblyHeader* rahdr;

    while ((pkt = *link) != NULL) {
        rahdr = GETPKTBUF(pkt, ReassemblyHeader);
        if (rahdr->srcaddr == srcaddr &&
            rahdr->dstaddr == dstaddr &&
            rahdr->proto_id == proto_id)
            break;

        link = &pkt->nextpkt;
    }

    return link;
}


PRIVATE Packet*
IpAllocReassemblyPkt(
    IPADDR srcaddr,
    IPADDR dstaddr,
    UINT proto_id,
    IfInfo* ifp
    )

/*++

Routine Description:

    Allocate buffer for assembling a datagram

Arguments:

    srcaddr - Specifies the source IP address
    dstaddr - Specifies the destination IP address
    proto_id - IP protocol number and datagram ID
    ifp - Points to the receiving interface

Return Value:

    Pointer to the allocated packet
    NULL if there is an error

--*/

{
    Packet* pkt;
    UINT hdrsize;
    ReassemblyHeader* rahdr;

    //
    // We reserve some space in the head of the packet buffer
    // for storing reassembly information.
    //

    hdrsize = offsetof(ReassemblyHeader, bitFlags) +
              (((cfgMaxReassemblySize / 8) + 31) / 32) * 4 +
              MAXIPHDRLEN;

    pkt = XnetAllocPacket(hdrsize + cfgMaxReassemblySize, PKTFLAG_NETPOOL);
    if (!pkt) return NULL;
    pkt->iphdrOffset = 0;

    rahdr = GETPKTBUF(pkt, ReassemblyHeader);
    ZeroMem(rahdr, hdrsize);
    rahdr->timer = cfgReassemblyTimeout;
    rahdr->srcaddr = srcaddr;
    rahdr->dstaddr = dstaddr;
    rahdr->proto_id = proto_id;

    pkt->data += hdrsize;
    CACHE_IFP_REFERENCE(pkt->recvifp,ifp);
    return pkt;
}


PRIVATE BOOL
IpUpdateFragmentFlags(
    Packet* pkt,
    UINT fragOffset,
    UINT fragCount
    )

/*++

Routine Description:

    Update the bit flags to indicate which fragments have already arrived

Arguments:

    pkt - Points to the packet contain partially assembled datagram
    fragOffset - Starting chunk offset for the current fragment
    fragCount - Number of 8 byte chunks in the current fragment

Return Value:

    TRUE if the entire datagram has been completed
    FALSE otherwise

--*/

{
    UINT chunks, i;
    ReassemblyHeader* rahdr = GETPKTBUF(pkt, ReassemblyHeader);

    // Update flag bits
    chunks = fragOffset % 32;
    i = fragOffset / 32;

    if (chunks) {
        UINT bits = min(fragCount, 32-chunks);
        rahdr->bitFlags[i++] |= (((1 << bits) - 1) << chunks);
        fragCount -= bits;
    }

    while (fragCount >= 32) {
        rahdr->bitFlags[i++] = 0xffffffff;
        fragCount -= 32;
    }

    if (fragCount)
        rahdr->bitFlags[i] |= (1 << fragCount) - 1;

    // We don't know the total datagram length yet,
    // which must mean we haven't finished reassembly.
    if (rahdr->origdatalen == 0) return FALSE;

    // Check if all bit flags are set
    i = 0;
    chunks = (rahdr->origdatalen + 7) / 8;
    while (chunks >= 32) {
        if (rahdr->bitFlags[i++] != 0xffffffff) return FALSE;
        chunks -= 32;
    }

    return (chunks == 0 ||
            rahdr->bitFlags[i] == (1u << chunks) - 1);
}


PRIVATE VOID
IpReassemblePkt(
    Packet* pkt
    )

/*++

Routine Description:

    Handle IP datagram reassembly:
    called when a datagram fragment is received

Arguments:

    pkt - Points to the received packet (datagram fragment)

Return Value:

    NONE

NOTE:

    We assume that fragmented datagrams are rare. Consequently,
    our priority here is implementation simplicity (over efficiency).

--*/

{
    IpHeader* iphdr = GETPKTIPHDR(pkt);
    UINT iphdrlen = GETIPHDRLEN(iphdr);
    UINT iplen = GETIPLEN(iphdr);
    UINT proto_id, fragOffset, lastbyte;
    BOOL moreFlag;
    Packet** link;
    Packet* rapkt;
    ReassemblyHeader* rahdr;

    // Extract datagram header information
    fragOffset = NTOHS(iphdr->fragoffset);
    moreFlag = (fragOffset & MORE_FRAGMENTS) != 0;
    fragOffset &= FRAGOFFSET_MASK;

    proto_id = NTOHS(iphdr->id);
    proto_id = (proto_id << 16) | iphdr->protocol;
    link = IpFindReassemblyPkt(iphdr->srcaddr, iphdr->dstaddr, proto_id);
    
    // Check if we already have fragments from the same datagram.
    // If no existing fragments are found, then we need to
    // allocate a new reassembly buffer
    if ((rapkt = *link) == NULL) {
        if (IpReassemblyPktCount >= cfgMaxReassemblyDgrams) {
            WARNING_("Too many fragmented IP datagrams");
            goto discard_fragment;
        }

        rapkt = IpAllocReassemblyPkt(iphdr->srcaddr, iphdr->dstaddr, proto_id, pkt->recvifp);
        if (!rapkt) goto discard_fragment;
        *link = rapkt;
        IpReassemblyPktCount++;
    }

    if ((iplen -= iphdrlen) == 0) goto reassembly_failed;
    lastbyte = fragOffset*8 + iplen;
    if (lastbyte > cfgMaxReassemblySize) {
        WARNING_("Exceeded max reassembly size");
        goto reassembly_failed;
    }

    rahdr = GETPKTBUF(rapkt, ReassemblyHeader);
    if (moreFlag) {
        // Only the last fragment can have size that's not a multiple of 8.
        if (iplen % 8 != 0) goto reassembly_failed;
    } else {
        // Update the total length field for the entire datagram
        if (rahdr->origdatalen && rahdr->origdatalen != lastbyte)
            goto reassembly_failed;

        rahdr->origdatalen = lastbyte;
    }

    // Check if we got the first fragment.
    // Remember the original IP datagram header if we did.
    if (fragOffset == 0 && rapkt->iphdrOffset == 0) {
        BYTE* hdr = rapkt->data - iphdrlen;
        SETPKTIPHDR(rapkt, hdr);
        CopyMem(hdr, pkt->data, iphdrlen);
        rapkt->pktflags |= (pkt->pktflags & PKTFLAG_MCAST);
    }

    // Copy the fragment data into the reassembly buffer
    CopyMem(rapkt->data + fragOffset*8, pkt->data + iphdrlen, iplen);
    XnetCompletePacket(pkt, NETERR_OK);

    // Update the flags to indicate which fragments have already arrived.
    // If the datagram is complete, pass it upstream for processing.
    if (IpUpdateFragmentFlags(rapkt, fragOffset, (iplen+7)/8)) {
        *link = rapkt->nextpkt;
        IpReassemblyPktCount--;
        rapkt->nextpkt = NULL;

        iphdr = GETPKTIPHDR(rapkt);
        iphdrlen = GETIPHDRLEN(iphdr);
        rapkt->data = (BYTE*) iphdr;
        rapkt->datalen = iphdrlen + rahdr->origdatalen;
        iphdr->length = (WORD) HTONS(rapkt->datalen);
        iphdr->fragoffset &= ~HTONS(MORE_FRAGMENTS|FRAGOFFSET_MASK);
        COMPUTE_CHECKSUM(iphdr->hdrxsum, iphdr, iphdrlen);
        IpReceivePacket(rapkt);
    }
    return;

reassembly_failed:
    // We detected an error during the reassembly process.
    // Flush all associated fragments.
    *link = rapkt->nextpkt;
    IpReassemblyPktCount--;

    TRACE_("Datagram reassembly failed");
    XnetCompletePacket(rapkt, NETERR_REASSEMBLY);

discard_fragment:
    // Discard this fragment and return
    XnetCompletePacket(pkt, NETERR_DISCARDED);
}



PRIVATE BOOL
IpProcessRecvOptions(
    BYTE* buf,
    UINT buflen,
    IfInfo* ifp
    )

/*++

Routine Description:

    Process options in a received IP datagram

Arguments:

    buf - Points to the option data buffer
    buflen - Size of the buffer, in bytes
    ifp - The interface that received the datagram

Return Value:

    TRUE if the option data is valid
    FALSE if there is an error and the datagram should be discarded

--*/

{
    BYTE opt, optlen, ptr;
    IPADDR* paddr;

    while (buflen) {
        // reached the end of option list?
        if ((opt = *buf) == IPOPT_EOL) break;

        // skip over the NOP option
        if (opt == IPOPT_NOP) {
            buf++; buflen--;
            continue;
        }

        // check the option length field
        if (buflen < 2 || (optlen = buf[1]) < 2 || optlen > buflen)
            return FALSE;

        switch (opt) {
        case IPOPT_LOOSE_SRCROUTE:
        case IPOPT_STRICT_SRCROUTE:
            // loose or strict source and record route options
            if (optlen % 4 != 3 || (ptr = buf[2]) < 4 || ptr % 4 != 0)
                return FALSE;
            
            // reached the end of the IP address list?
            if (ptr > optlen) break;

            // only one address left and it's ours
            //  this shouldn't happen but we handle it anyway
            paddr = (IPADDR*) (buf+ptr-1);
            if (optlen - ptr == 3 && ifp->ipaddr && ifp->ipaddr == *paddr) {
                *paddr = 0;
                break;
            }

            // otherwise, discard the datagram since we don't
            // participate in source routing.
            return FALSE;

        case IPOPT_RECORD_ROUTE:
            // record route
            if (optlen % 4 != 3 || (ptr = buf[2]) < 4 || ptr % 4 != 0)
                return FALSE;
            break;

        case IPOPT_TIMESTAMP:
            // internet timestamp
            if (optlen < 4 || optlen % 4 != 0 ||
                (ptr = buf[2]) < 5 || ptr % 4 != 1)
                return FALSE;
            break;
        }

        // move on to the next option
        buf += optlen;
        buflen -= optlen;
    }

    return TRUE;
}


IPADDR
IpReflectIpOptions(
    IfInfo* ifp,
    IpHeader* iphdr,
    IPADDR dstaddr
    )

/*++

Routine Description:

    Reflect any IP options in a received datagram

Arguments:

    ifp - Specifies the outgoing interface
    iphdr - Points to the received datagram header
    dstaddr - Specifies the final destination address

Return Value:

    New destination address

Note:

    We assume the option data in the received datagram
    has already been validated.

--*/

{
    BYTE* buf;
    BYTE opt, optlen, ptr;
    UINT buflen;
    IPADDR* paddr;

    buf = (BYTE*) iphdr + IPHDRLEN;
    buflen = GETIPHDRLEN(iphdr) - IPHDRLEN;

    while (buflen) {
        if ((opt = *buf) == IPOPT_EOL) break;
        if (opt == IPOPT_NOP) {
            buf++; buflen--;
            continue;
        }

        optlen = buf[1];

        switch (opt) {
        case IPOPT_LOOSE_SRCROUTE:
        case IPOPT_STRICT_SRCROUTE:
            //
            // We assume the record route option contains the following:
            //  G1 G2 ... Gn
            // and we'll modify it to:
            //  Gn-1 ... G2 G1 D
            // and return Gn as the new destination address
            //
            if ((ptr = buf[2]) > 4) {
                IPADDR addr;
                IPADDR* pend;

                ASSERT(optlen % 4 == 3 && ptr % 4 == 0);
                if (ptr > optlen) ptr = (BYTE) (optlen+1);

                paddr = (IPADDR*) (buf+3);
                pend = (IPADDR*) (buf+ptr-5);

                // swap Gn and D
                addr = *pend;
                
                // simple sanity check
                //  if the gateway address is bad, we'll just
                //  leave the source route option alone
                if (!XnetIsValidUnicastAddr(addr)) break;

                *pend = dstaddr;
                dstaddr = addr;
                pend--;

                // flip G1 ... Gn-1
                while (pend > paddr) {
                    addr = *pend;
                    *pend = *paddr;
                    *paddr = addr;
                    paddr++;
                    pend--;
                }
                
                // reset ptr field
                buf[2] = 4;
            }
            break;

        case IPOPT_RECORD_ROUTE:
            //
            // If there is room left, record our own IP address
            //
            if ((ptr = buf[2]) > optlen) break;
            ASSERT(optlen % 4 == 3 && ptr >= 4 && ptr % 4 == 0);

            paddr = (IPADDR*) (buf+ptr-1);
            *paddr = ifp->ipaddr;
            buf[2] += 4;
            break;
        
        case IPOPT_TIMESTAMP:
            if ((ptr = buf[2]) > optlen) {
                // increment the overflow count if we don't have room
                if ((buf[3] & 0xf0) < 0xf0) buf[3] += 0x10;
            } else {
                UINT timestamp;
                DWORD* p;

                ASSERT(optlen % 4 == 0 && optlen > 4 &&
                       ptr >= 5 && ptr % 4 == 1);

                p = (DWORD*) (buf+ptr-1);
                timestamp = IpGetMsecsSinceMidnightGMT();

                switch (buf[3] & 0xf) {
                case 3:
                    if (*p != ifp->ipaddr) break;
                    // fall through

                case 1:
                    if (optlen-ptr < 7) break;
                    *p++ = ifp->ipaddr;
                    buf[2] += 4;
                    ptr += 4;
                    // fall through

                case 0:
                    if (optlen-ptr < 3) break;
                    *p = HTONL(timestamp);
                    buf[2] += 4;
                    break;
                }
            }
            break;
        }

        buf += optlen;
        buflen -= optlen;
    }

    return dstaddr;
}



VOID
IpReceivePacket(
    Packet* pkt
    )

/*++

Routine Description:

    Receive an IP datagram
    (called by the NIC interface driver)

Arguments:

    pkt - Points to the received packet

Return Value:

    NONE

--*/

{
    IpHeader* iphdr;
    IPADDR dstaddr, srcaddr;
    UINT iphdrlen, iplen;
    IfInfo* ifp;

    ASSERT_DISPATCH_LEVEL();

    //
    // NOTE:
    // 1. We assume the received packet is at least large enough
    //    to hold the default IP header.
    // 2. It's more efficient if the interface driver can manage
    //    to place the IP header at DWORD-aligned boundary.
    //    This is NOT currently the case for EPRO100 interface driver:
    //    the Ethernet frame header starts at DWORD-aligned address;
    //    which causes the IP header to start at odd-WORD boundary.
    //
    ASSERT(pkt->datalen >= IPHDRLEN);

    // verify header and packet length
    iphdr = (IpHeader*) pkt->data;
    SETPKTIPHDR(pkt, iphdr);
    iphdrlen = VERIFY_IPVER_HDRLEN(iphdr->ver_hdrlen);
    iplen = GETIPLEN(iphdr);

    if (iphdrlen < IPHDRLEN || iphdrlen > iplen || iplen > pkt->datalen)
        goto discard;

    // if the received packet length is larger than the IP length,
    // ignore the data at the end
    pkt->datalen = iplen;

    // verify header checksum
    if (tcpipxsum(0, pkt->data, iphdrlen) != 0xffff)
        goto discard;

    //
    // Determine if the packet is addressed to us.
    //
    // NOTE:
    //
    // 1. We reject a packet if the destination address doesn't
    //    match the address of the interface it's received on
    //    (i.e. we implement the strong ES model).
    //
    // 2. We don't check if a packet with an IP broadcast/multicast
    //    destination address was received as unicast on the link-layer
    //    interface. Converse, we don't check if a packet with a unicast
    //    IP destination address was received as broadcast/multicast
    //    on the link-layer interface.
    //
    // 3. We'll receive multicast packets even before the interface
    //    has a valid IP address.
    //
    // 4. We only support the all-1's form of broadcast address.
    //    Also, we only support limited broadcasts and subnet
    //    directed broadcasts (i.e. no special case for directed
    //    broadcasts and all-subnets directed broadcasts).
    //
    // 5. We discard all datagrams whose source address is
    //    a broadcast or multicast address.
    //
    ifp = pkt->recvifp;
    dstaddr = iphdr->dstaddr;
    
    if (dstaddr == ifp->ipaddr && ifp->ipaddr != 0 ||
        IS_MCAST_IPADDR(dstaddr) && IfFindMcastGroup(ifp, dstaddr) ||
        IfBcastAddr(ifp, dstaddr) ||
        IfLoopback(ifp))
    {
        srcaddr = iphdr->srcaddr;
        if (IfBcastAddr(ifp, srcaddr) ||
            IS_MCAST_IPADDR(srcaddr) ||
            IS_LOOPBACK_IPADDR(srcaddr) && !IfLoopback(ifp))
            goto discard;

        // Check if there is fragmentation involved
        if (iphdr->fragoffset & HTONS(MORE_FRAGMENTS|FRAGOFFSET_MASK)) {
            IpReassemblePkt(pkt);
            return;
        }

        // Process options if needed
        if (iphdrlen > IPHDRLEN &&
            !IpProcessRecvOptions(pkt->data+IPHDRLEN, iphdrlen-IPHDRLEN, ifp)) {
            // NOTE: we could send a parameter problem ICMP packet here.
            TRACE_("IP datagram option error");
            goto discard;
        }

        pkt->data += iphdrlen;
        pkt->datalen -= iphdrlen;

        switch (iphdr->protocol) {
        case IPPROTOCOL_TCP:
            TcpReceivePacket(pkt);
            break;

        case IPPROTOCOL_UDP:
            UdpReceivePacket(pkt);
            break;

        case IPPROTOCOL_ICMP:
            IcmpReceivePacket(pkt);
            break;

        case IPPROTOCOL_IGMP:
            IgmpReceivePacket(pkt);
            break;

        default:
            RawReceivePacket(pkt);
            break;
        }
        return;
    }
    
discard:
    // Discard the packet and return
    XnetCompletePacket(pkt, NETERR_DISCARDED);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\ip\precomp.h ===
#include "xnetp.h"
#include "icmp.h"
#include "igmp.h"
#include "ipimpl.h"
#include "route.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\ip\iputil.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    iputil.c

Abstract:

    IP helper functions

Revision History:

    05/18/2000 davidx
        Created it.

--*/

#include "precomp.h"

//
// Maximum number of multicast groups an interface can belong to
//
UINT cfgMaxIfMcastAddrs = 32;


VOID
IfSetIpAddr(
    IfInfo* ifp,
    IPADDR ipaddr,
    IPADDR addrmask
    )

/*++

Routine Description:

    Set / clear the IP address for an interface

Arguments:

    ifp - Points to the interface structure
    ipaddr - Specifies the IP address (0 means to clear the address)
    addrmask - Specifies the subnet mask

Return Value:

    NONE

--*/

{
    KIRQL irql = RaiseToDpc();

    if (ipaddr == 0)
        addrmask = 0;
    else if (addrmask == 0 || !XnetIsValidSubnetMask(addrmask))
        addrmask = XnetGetDefaultSubnetMask(ipaddr);

    ifp->ipaddr = ipaddr;
    ifp->addrmask = addrmask;
    ifp->subnetAddr = (ipaddr & addrmask);
    ifp->subnetBcastAddr = ifp->subnetAddr | ~addrmask;

    if (ipaddr) {
        ifp->flags |= IFFLAG_RUNNING;

        // Add a host route for this interface
        if (!IfLoopback(ifp)) {

            #ifdef DEVKIT

            // BUGBUG: Spew out our IP address in the debugger
            // (even on a free build).
            if (ifp->refcount == 1) {
                DbgPrint("\n*** Xbox IP address: %s /", IPADDRSTR(ipaddr));
                DbgPrint(" %s\n\n", IPADDRSTR(addrmask));
            }

            #endif

            IpAddRTE(ifp->ipaddr,
                   0xffffffff,
                   IPADDR_LOOPBACK,
                   LoopbackIfp,
                   RTEFLAG_HOST,
                   DEFAULT_RTE_METRIC);

            DnsNotifyDefaultServers(ifp);
        }

        // Add a local subnet network route for this interface
        IpAddRTE(ifp->subnetAddr,
               ifp->addrmask,
               ifp->ipaddr,
               ifp,
               RTEFLAG_LOCAL,
               DEFAULT_RTE_METRIC);
    } else {
        // Mark the interface as inactive and clear all
        // route entries that go thru this interface.
        // Leave the broadcast route alone.
        ifp->flags &= ~IFFLAG_RUNNING;
        IpRemoveInterfaceRTE(ifp, FALSE);
    }

    LowerFromDpc(irql);
}


DWORD
IpGetBestAddress(
    IPADDR* addr
    )

/*++

Routine Description:

    Get the best available IP address for the local host

Arguments:

    addr - Returns the best IP address

Return Value:

    Flags indicating how the IP address was obtained

--*/

{
    KIRQL irql = RaiseToDpc();
    IfInfo* ifp;
    DWORD flags = 0;

    *addr = 0;

    LOOP_THRU_INTERFACE_LIST(ifp)
        if (IfRunning(ifp)) {
            *addr = ifp->ipaddr;
            if (IfLoopback(ifp)) {
                flags = XNET_ADDR_LOOPBACK;
            } else if (IfDhcpEnabled(ifp)) {
                flags = DhcpGetActiveAddressType(ifp);
            }
            break;
        }
    END_INTERFACE_LIST_LOOP()

    LowerFromDpc(irql);
    return flags;
}


NTSTATUS
IfGetDefaultDnsServers(
    IfInfo* dnsifp,
    CHAR* domainName,
    UINT namelen,
    IPADDR* serverAddrs,
    UINT* serverCnt
    )

/*++

Routine Description:

    Get the default DNS server information
    associated with the specified interface

Arguments:

    dnsifp - Points to an interface structure
    domainName - Buffer for receiving the default domain name
    namelen - Size of the domain name buffer
    serverAddrs - Buffer for receiving the default server addresses
    serverCnt - Number of default servers
        On entry, it specifies the size of the server address buffer
        On return, it contains the actual number of default servers

Return Value:

    Status code

--*/

{
    KIRQL irql = RaiseToDpc();
    IfInfo* ifp = NULL;
    NTSTATUS status;

    LOOP_THRU_INTERFACE_LIST(ifp)
        if (ifp == dnsifp) break;
    END_INTERFACE_LIST_LOOP()

    if (ifp != dnsifp) {
        status = NETERR_PARAM;
    } else if (IfDhcpEnabled(ifp)) {
        status = DhcpGetDefaultDnsServers(ifp, domainName, namelen, serverAddrs, serverCnt);
    } else {
        UINT count = *serverCnt * sizeof(IPADDR);
        status = ifp->Ioctl(ifp, IFCTL_GET_DNSSERVERS, domainName, namelen, serverAddrs, &count);
        *serverCnt = count / sizeof(IPADDR);
    }

    LowerFromDpc(irql);
    return status;
}


NTSTATUS
IfInitMcastGroup(
    IfInfo* ifp
    )

/*++

Routine Description:

    Initialize the per-interface multicast information

Arguments:

    ifp - Points to the interface structure

Return Value:

    Status code

--*/

{
    // NOTE: if ifp->mcastData is not NULL, then we must be sharing
    // the interface with the debug monitor. Since the debug monitor
    // has done the necessary initialization, we don't need to do it
    // again here.

    if (!ifp->mcastData) {
        UINT size = offsetof(IfMcastData, mcastGroups) +
                    sizeof(IfMcastGroup) * cfgMaxIfMcastAddrs;
        ifp->mcastData = (IfMcastData*) SysAlloc0(size, PTAG_MCAST);
        if (!ifp->mcastData)
            return NETERR_MEMORY;

        // Assume the querier is v1 when we start up
        ifp->mcastData->v1QuerierTimer = IGMP_V1_QUERIER_TIMER;
        ifp->mcastData->hasV1Querier = TRUE;

        // Join the all-hosts group
        IfChangeMcastGroup(ifp, IPADDR_ALLHOSTS, TRUE);
    }

    // Make this interface the default multicast interface
    return IpSetMulticastInterface(ifp);
}


BOOL
IfFindMcastGroup(
    IfInfo* ifp,
    IPADDR addr
    )

/*++

Routine Description:

    Check if an interface belongs to the specified multicast group

Arguments:

    ifp - Points to the interface structure
    addr - Specifies the multicast group address

Return Value:

    TRUE if we belong to the multicast group
    FALSE otherwise

--*/

{
    IfMcastData* ifmcast = ifp->mcastData;

    RUNS_AT_DISPATCH_LEVEL

    if (ifmcast) {
        IfMcastGroup* mcastgrp = ifmcast->mcastGroups;
        UINT count = ifmcast->groupCount;
        while (count--) {
            if (mcastgrp->mcastaddr == addr) return TRUE;
            mcastgrp++;
        }
    }

    return FALSE;
}


NTSTATUS
IfChangeMcastGroup(
    IfInfo* ifp,
    IPADDR mcastaddr,
    BOOL add
    )

/*++

Routine Description:

    Join or leave a multicast on the specified interface

Arguments:

    ifp - Points to the interface structure
    mcastaddr - Specifies the multicast group address
    add - Whether to join or leave the group

Return Value:

    Status code

--*/

{
    IfMcastData* ifmcast;
    IfMcastGroup* mcastgrp;
    UINT count;
    KIRQL irql;
    NTSTATUS status = NETERR_OK;
    BOOL notify;

    // Make sure addr is indeed a multicast address
    // and the interface supports multicast
    if (!IS_MCAST_IPADDR(mcastaddr) || (ifmcast = ifp->mcastData) == NULL)
        return NETERR_PARAM;

    irql = RaiseToDpc();
    mcastgrp = ifmcast->mcastGroups;
    count = ifmcast->groupCount;
    while (count) {
        if (mcastgrp->mcastaddr == mcastaddr) break;
        count--, mcastgrp++;
    }

    notify = FALSE;
    if (add) {
        // Joining a gruop
        if (count) {
            // The specified group already exists;
            // just increment its reference count.
            mcastgrp->refcount++;
        } else if (ifmcast->groupCount == cfgMaxIfMcastAddrs) {
            // Too many groups already
            status = NETERR(WSAEADDRNOTAVAIL);
        } else {
            // Add a new group
            ifmcast->groupCount++;
            mcastgrp->refcount = 1;
            mcastgrp->mcastaddr = mcastaddr;
            mcastgrp->reportTimer = 0;
            mcastgrp->sentLastReport = FALSE;
            notify = TRUE;
        }
    } else {
        // Leaving a group
        if (count == 0) {
            // The specified address is not found
            status = NETERR_PARAM;
        } else {
            // Remove the specified multicast group address
            IgmpSendLeave(ifp, mcastgrp);
            while (--count) {
                *mcastgrp = *(mcastgrp+1);
                mcastgrp++;
            }
            ifmcast->groupCount--;
            notify = TRUE;
        }
    }

    // Notify the NIC and inform the IGMP module
    if (notify) {
        status = ifp->Ioctl(ifp, IFCTL_SET_MCAST_ADDRS, NULL, 0, NULL, NULL);
        if (add) {
            if (NT_SUCCESS(status)) {
                // Send out an IGMP report message
                // and resend another one a short while later
                IgmpSendReport(ifp, mcastgrp);
                mcastgrp->reportTimer = IGMP_JOIN_RETRY_TIMER;
            } else {
                // If we failed to join a group, back out
                ifmcast->groupCount--;
            }
        }
    }

    LowerFromDpc(irql);
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\ip\loopback.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    loopback.c

Abstract:

    Implement the loopback interface functions

Revision History:

    05/19/2000 davidx
        Created it.

--*/

#include "precomp.h"

//
// Loopback interface structure
//
typedef struct _IfLoopback {
    // Info common to all interface types
    IfInfo;

    // DPC object
    KDPC dpc;
} IfLoopback;


PRIVATE VOID
LoopbackDpc(
    PKDPC dpc,
    IfLoopback* ifp,
    VOID* arg1,
    VOID* arg2
    )

/*++

Routine Description:

    Loopback interface DPC function:
      remove packets queued up in the sendq
      and pass it upstream for processing.

Arguments:

    dpc - Pointer to the DPC object
    ifp - Pointer to the loopback interface object
    arg1, arg2 - Unused arguments

Return Value:

    NONE

--*/

{
    Packet* pkt;
    IPADDR dstaddr;

    while (!PktQIsEmpty(&ifp->sendq)) {
        pkt = IfDequeuePacket(ifp);

        if (pkt->datalen < IPHDRLEN) {
            XnetCompletePacket(pkt, NETERR_PARAM);
            continue;
        }
        
        dstaddr = GETPKTDATA(pkt, IpHeader)->dstaddr;
        if (IfBcastAddr(ifp, dstaddr) || IS_MCAST_IPADDR(dstaddr))
            pkt->pktflags |= PKTFLAG_MCAST;
        else
            pkt->pktflags &= ~PKTFLAG_MCAST;

        pkt->recvifp = (IfInfo*) ifp;
        IpReceivePacket(pkt);
    }
}


PRIVATE VOID
LoopbackStartOutput(
    IfLoopback* ifp
    )

/*++

Routine Description:

    Send out any queued packets on the loopback interface

Arguments:

    ifp - Points to the interface structure

Return Value:

    NONE

--*/

{
    RUNS_AT_DISPATCH_LEVEL
    if (!PktQIsEmpty(&ifp->sendq)) {
        KeInsertQueueDpc(&ifp->dpc, NULL, NULL);
    }
}


NTSTATUS
IpQueueLoopbackPacket(
    Packet* pkt,
    BOOL copyflag
    )

/*++

Routine Description:

    Queue up a packet on the loopback interface

Arguments:

    pkt - Points to the packet to be queued up
    copyflag - Whether to queue up the packet directly
        or to queue up a copy of the packet

Return Value:

    Status code

--*/

{
    IfLoopback* ifp;

    ASSERT_DISPATCH_LEVEL();

    if (copyflag) {
        Packet* newpkt = XnetCopyPacket(pkt, 0);
        if (!newpkt) return NETERR_MEMORY;
        pkt = newpkt;
    }

    ifp = (IfLoopback*) LoopbackIfp;
    ASSERT(ifp != NULL);
    IfEnqueuePacket(ifp, pkt);
    KeInsertQueueDpc(&ifp->dpc, NULL, NULL);

    return NETERR_OK;
}


PRIVATE NTSTATUS
LoopbackIoctl(
    IfLoopback* ifp,
    INT ctlcode,
    VOID* inbuf,
    UINT inlen,
    VOID* outbuf,
    UINT* outlen
    )

/*++

Routine Description:

    Loopback interface I/O control function

Arguments:

    ifp - Points to the interface structure
    ctlcode - Control code
    inbuf - Points to the input buffer
    inlen - Size of the input buffer
    outbuf - Points to the output buffer
    outlen - On entry, this contains the size of the output buffer
        On return, this is the actually number of output bytes

Return Value:

    Status code

--*/

{
    // We don't support any interface IOCTLs
    return NETERR_NOTIMPL;
}

   
PRIVATE VOID
LoopbackDelete(
    IfLoopback* ifp
    )

/*++

Routine Description:

    Delete the loopback interface

Arguments:

    ifp - Points to the interface structure

Return Value:

    NONE

--*/

{
    RUNS_AT_DISPATCH_LEVEL

    ASSERT(ifp->refcount == 1);
    KeRemoveQueueDpc(&ifp->dpc);

    // Cleanup the send queue
    while (!PktQIsEmpty(&ifp->sendq)) {
        Packet* pkt = PktQRemoveHead(&ifp->sendq);
        XnetCompletePacket(pkt, NETERR_CANCELLED);
    }
    
    SysFree(ifp);
}


NTSTATUS
LoopbackInitialize(
    IfInfo** newifp
    )

/*++

Routine Description:

    Initialize the loopback interface

Arguments:

    newifp - Returns a pointer to the loopback interface

Return Value:

    Status code

--*/

{
    IfLoopback* ifp;

    ifp = (IfLoopback*) SysAlloc0(sizeof(IfLoopback), PTAG_LPBK);
    if (!ifp) return NETERR_MEMORY;

    ifp->refcount = 1;
    ifp->ifname = "Loopback";
    ifp->Delete = (IfDeleteProc) LoopbackDelete;
    ifp->StartOutput = (IfStartOutputProc) LoopbackStartOutput;
    ifp->Ioctl = (IfIoctlProc) LoopbackIoctl;

    // We pretend to have a hardware address
    // which is the same as the IP address.
    ifp->iftype = IFTYPE_LOOPBACK;
    ifp->hwaddrlen = IPADDRLEN;
    *((IPADDR*) ifp->hwaddr) = IPADDR_LOOPBACK;

    ifp->mtu = MAXIPLEN;
    ifp->framehdrlen = 0;

    KeInitializeDpc(&ifp->dpc, (PKDEFERRED_ROUTINE) LoopbackDpc, ifp);
    ifp->flags |= IFFLAG_UP;

    *newifp = (IfInfo*) ifp;
    IfSetIpAddr(*newifp, IPADDR_LOOPBACK, CLASSA_NETMASK);
    return NETERR_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\ip\ipsend.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    ipsend.c

Abstract:

    IP datagram transmission related functions

Revision History:

    05/22/2000 davidx
        Created it.

--*/

#include "precomp.h"

//
// Default type-of-service value for outgoing datagrams
//
BYTE cfgDefaultTos = 0;

//
// Default time-to-live value for outgoing datagrams
//
BYTE cfgDefaultTtl = 64;

//
// Identifier to be assigned to the next outgoing IP datagram
//
WORD IpNextDgramId;


NTSTATUS
IpSendPacket(
    Packet* pkt,
    IPADDR dstaddr,
    IfInfo* ifp,
    RTE** cachedRte
    )

/*++

Routine Description:

    Send out an IP datagram to the specified destination address

Arguments:

    pkt - Specifies the datagram to be sent
    dstaddr - Specifies the destination address
    ifp - Points to the outgoing interface, optional
    cachedRte - Address of a cached route entry pointer

Return Value:

    Status code

--*/

{
    RTE* rte;

    RUNS_AT_DISPATCH_LEVEL

    // The IP header must be completely filled out
    ASSERT(pkt->data == (BYTE*) GETPKTIPHDR(pkt));

    // Find a route and cache it
    if ((rte = *cachedRte) == NULL || IsRteOrphaned(rte)) {
        // release the orphaned route entry
        if (rte) { IpReleaseCachedRTE(rte); }

        *cachedRte = rte = IpFindRTE(dstaddr, ifp);
        if (!rte) {
            XnetCompletePacket(pkt, NETERR_UNREACHABLE);
            return NETERR_UNREACHABLE;
        }
        RteAddRef(rte);
    }

    pkt->nexthop = IsRteLocal(rte) ? dstaddr : rte->nexthop;
    ifp = rte->ifp;
    if (pkt->datalen > ifp->mtu) {
        XnetCompletePacket(pkt, NETERR_MSGSIZE);
        return NETERR_MSGSIZE;
    }

    //
    // Queue up the packet for transmission
    // We use a very crude priority mechanism here:
    // - normal packets are added to the end of the queue
    // - retransmitted packets are added to the front of the queue
    //
    if (pkt->pktflags & PKTFLAG_REXMIT) {
        PktQInsertHead(&ifp->sendq, pkt);
    } else {
        PktQInsertTail(&ifp->sendq, pkt);
    }
    ifp->StartOutput(ifp);

    return NETERR_OK;
}


VOID
IpSendPacketInternal(
    Packet* pkt,
    IPADDR srcaddr,
    IPADDR dstaddr,
    BYTE protocol,
    IfInfo* ifp
    )

/*++

Routine Description:

    Send an IP datagram out on the specified interface.
    This is called by internal clients such as ICMP and DHCP.

Arguments:

    pkt - Specifies the datagram to be sent
    srcaddr - Specifies the source address
    dstaddr - Specifies the destination address
    protocol - Specifies the protocol number
    ifp - Points to the outgoing interface

Return Value:

    NONE

Note:

    We assume the pkt->iphdr field points to where the IP header starts.

--*/

{
    RTE* rte = NULL;
    IpHeader* iphdr;
    UINT iphdrlen;
    KIRQL irql;

    //
    // Fix up the IP header
    //
    iphdr = GETPKTIPHDR(pkt);
    ASSERT((BYTE*) iphdr < pkt->data);

    iphdrlen = pkt->data - (BYTE*) iphdr;
    pkt->data -= iphdrlen;
    pkt->datalen += iphdrlen;

    FILL_IPHEADER(
        iphdr,
        iphdrlen,
        cfgDefaultTos,
        pkt->datalen,
        0,
        cfgDefaultTtl,
        protocol,
        srcaddr,
        dstaddr);

    irql = RaiseToDpc();
    IpSendPacket(pkt, dstaddr, ifp, &rte);
    if (rte) { IpReleaseCachedRTE(rte); }
    LowerFromDpc(irql);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\ip\route.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    route.c

Abstract:

    Simple IP datagram routing functionality

Revision History:

    05/22/2000 davidx
        Created it.

--*/

#include "precomp.h"

//
// Route table (actually a list)
//
LIST_ENTRY IpRouteList;
IPADDR IpLastRteAddr;
RTE* IpLastRte;

#define INVALIDATELASTRTE() (IpLastRteAddr = 0, IpLastRte = NULL)

//
// Convenience macros for loop through all route table entries
//
#define LOOP_THRU_ROUTE_LIST(_rte) { \
            RTE* _next; \
            _rte = (RTE*) IpRouteList.Flink; \
            for (; _rte != (RTE*) &IpRouteList; _rte = _next) { \
                _next = (RTE*) _rte->Flink;

#define END_ROUTE_LIST_LOOP \
            } \
        }


NTSTATUS
IpInitRouteTable()

/*++

Routine Description:

    Initialize the routing table

Arguments:

    NONE

Return Value:

    Status code

--*/

{
    INVALIDATELASTRTE();
    InitializeListHead(&IpRouteList);
    return NETERR_OK;
}


RTE*
IpFindRTE(
    IPADDR dstaddr,
    IfInfo* ifp
    )

/*++

Routine Description:

    Find a route table entry for the specified destination address

Arguments:

    dstaddr - Specifies the destination address
    ifp - Optional parameter, when present it indicates the caller
        is only interested in routes thru that particular interface.

Return Value:

    Pointer to the route table entry for the destination
    NULL if no route is found

NOTE:

    This is a very simple implementation. We're assuming that our
    route table will be very small (most likely a handful of entries +
    a default gateway).

--*/

{
    RTE* rte;
    RTE* found;

    RUNS_AT_DISPATCH_LEVEL
    if (dstaddr == 0) return NULL;

    // Fast check
    if (dstaddr == IpLastRteAddr && (!ifp || !IpLastRte || ifp == IpLastRte->ifp))
        return IpLastRte;

    found = NULL;
    LOOP_THRU_ROUTE_LIST(rte)

        if ((dstaddr & rte->addrmask) == rte->dstaddr &&
            (!ifp || ifp == rte->ifp)) {
            // Found a matching entry:
            //  since the route list is sorted by mask length,
            //  we can stop searching right away
            found = rte;
            break;
        }

    END_ROUTE_LIST_LOOP

    // Update the last route lookup information
    IpLastRteAddr = dstaddr;
    return (IpLastRte = found);
}


NTSTATUS
IpAddRTE(
    IPADDR dstaddr,
    IPADDR addrmask,
    IPADDR nexthop,
    IfInfo* ifp,
    INT flags,
    INT metric
    )

/*++

Routine Description:

    Add an entry to the route table

Arguments:

    dstaddr, addrmask - Specifies the destination address and mask
    nexthop - Specifies the next hop gateway address
    ifp - Points to the output interface for the route
    flags - Route flags
    metric - Route metrics

Return Value:

    Status code

--*/

{
    RTE* newrte;
    RTE* rte;
    KIRQL irql;

    // Validate input parameters:
    //  - address mask must be of the form 111...000
    //      be careful about the byte order
    //  - next hop address cannot be a broadcast address

    if (!XnetIsValidSubnetMask(addrmask) ||
        nexthop == 0 ||
        IfBcastAddr(ifp, nexthop) && !(flags & RTEFLAG_BCAST)) {
        WARNING_("Bad route to %s:", IPADDRSTR(dstaddr));
        WARNING_("  mask = %s", IPADDRSTR(addrmask));
        WARNING_("  nexthop = %s", IPADDRSTR(nexthop));
        return NETERR_PARAM;
    }

    // Make sure loopback address never goes outside
    ASSERT(!IS_LOOPBACK_IPADDR(dstaddr) ||
           IfLoopback(ifp) &&
           addrmask == CLASSA_NETMASK &&
           nexthop == IPADDR_LOOPBACK);

    dstaddr &= addrmask;
    irql = RaiseToDpc();

    // Find out if the specified route is already in the table

    LOOP_THRU_ROUTE_LIST(rte)

        if (rte->dstaddr == dstaddr &&
            rte->addrmask == addrmask && 
            (addrmask != 0 || rte->nexthop == nexthop)) {
            // Update the existing route information
            newrte = rte;
            RemoveEntryList(&rte->links)
            goto insert_route;
        }

    END_ROUTE_LIST_LOOP

    // Add a new route table entry
    newrte = XnetAlloc0(sizeof(RTE), PTAG_RTE);
    if (!newrte) {
        LowerFromDpc(irql);
        return NETERR_MEMORY;
    }
    newrte->refcount = 1;

insert_route:

    newrte->flags = flags;
    newrte->metric = metric;
    newrte->dstaddr = dstaddr;
    newrte->addrmask = addrmask;
    newrte->nexthop = nexthop;
    CACHE_IFP_REFERENCE(newrte->ifp, ifp);
    INVALIDATELASTRTE();

    // Insert the new route into the table
    //  sorted by the mask length and route metric

    LOOP_THRU_ROUTE_LIST(rte)

        if (addrmask > rte->addrmask || 
            addrmask == rte->addrmask && metric < rte->metric) {
            break;
        }

    END_ROUTE_LIST_LOOP

    newrte->Flink = (LIST_ENTRY*) rte;
    newrte->Blink = rte->Blink;
    rte->Blink->Flink = (LIST_ENTRY*) newrte;
    rte->Blink = (LIST_ENTRY*) newrte;

    LowerFromDpc(irql);
    return NETERR_OK;
}


PRIVATE VOID
IpDeleteRouteEntry(
    RTE* rte
    )

/*++

Routine Description:

    Delete the specified route entry

Arguments:

    rte - Points to the route entry to be deleted

Return Value:

    NONE

--*/

{
    RUNS_AT_DISPATCH_LEVEL

    INVALIDATELASTRTE();

    RemoveEntryList(&rte->links)
    if (RteDecRef(rte) == 0) {
        // no more reference to this entry, we can delete it
        XnetFree(rte);
    } else {
        // there is still cached reference to this entry,
        // mark it as orphaned and it will be deleted
        // when the last reference goes away.
        rte->flags |= RTEFLAG_ORPHAN;
        rte->ifp = NULL;
    }
}


VOID
IpRemoveInterfaceRTE(
    IfInfo* ifp,
    BOOL deleteBcastRte
    )

/*++

Routine Description:

    Remove all routes going through the specified interface

Arguments:

    ifp - Points to the interface structure
        if NULL, then all routes are removed
    deleteBcastRte - Whether to delete the broadcast routes

Return Value:

    NONE

--*/

{
    RTE* rte;

    RUNS_AT_DISPATCH_LEVEL
    if (IsListNull(&IpRouteList)) return;

    // go through the entire route table and look for
    // entries whose interface matches the specified one

    LOOP_THRU_ROUTE_LIST(rte)

        if (ifp && rte->ifp != ifp) continue;
        if (!deleteBcastRte && IsRteBcast(rte)) continue;
        IpDeleteRouteEntry(rte);

    END_ROUTE_LIST_LOOP
}


VOID
IpRemoveRTE(
    IPADDR dstaddr,
    IPADDR addrmask,
    IPADDR nexthop
    )

/*++

Routine Description:

    Delete a route going to the specified destination
    and through the specified gateway

Arguments:

    dstaddr, addrmask - Specifies the route destination
    nexthop - Specifies the next hop gateway for the route

Return Value:

    NONE

--*/

{
    RTE* rte;
    KIRQL irql = RaiseToDpc();

    LOOP_THRU_ROUTE_LIST(rte)

        if (rte->dstaddr == dstaddr &&
            rte->addrmask == addrmask &&
            rte->nexthop == nexthop) {
            IpDeleteRouteEntry(rte);
            break;
        }

    END_ROUTE_LIST_LOOP

    LowerFromDpc(irql);
}


NTSTATUS
IpSetBroadcastInterface(
    IfInfo* ifp
    )

/*++

Routine Description:

    Designate an interface for transmitting
    outgoing broadcast datagrams

Arguments:

    ifp - Specifies the new broadcast interface

Return Value:

    Status code

--*/

{
    // Remove the route entry for the previous broadcast interface
    IpRemoveRTE(IPADDR_BCAST, 0xffffffff, IPADDR_BCAST);
    if (ifp == NULL) return NETERR_OK;

    // Create an entry for the new broadcast interface
    return IpAddRTE(IPADDR_BCAST,
                  0xffffffff,
                  IPADDR_BCAST,
                  ifp,
                  RTEFLAG_BCAST|RTEFLAG_LOCAL,
                  DEFAULT_RTE_METRIC);
}


NTSTATUS
IpSetMulticastInterface(
    IfInfo* ifp
    )

/*++

Routine Description:

    Designate an interface for transmitting
    outgoing broadcast datagrams

Arguments:

    ifp - Specifies the new broadcast interface

Return Value:

    Status code

--*/

{
    // Remove the route entry for the previous broadcast interface
    IpRemoveRTE(CLASSD_NETID, CLASSD_NETMASK, CLASSD_NETID);
    if (ifp == NULL) return NETERR_OK;

    // Create an entry for the new broadcast interface
    return IpAddRTE(CLASSD_NETID,
                  CLASSD_NETMASK,
                  CLASSD_NETID,
                  ifp,
                  RTEFLAG_MCAST|RTEFLAG_LOCAL,
                  DEFAULT_RTE_METRIC);
}


VOID
IpRedirectHostRoute(
    IfInfo* ifp,
    IPADDR dstaddr,
    IPADDR oldgwaddr,
    IPADDR newgwaddr
    )

/*++

Routine Description:

    Redirect the route to a destination host

Arguments:

    ifp - Specifies the interface that received the redirect message
    dstaddr - Destination host address
    oldgwaddr - Specifies the current gateway to the destination host
    newgwaddr - Specifies the new gateway address

Return Value:

    NONE

--*/

{
    RTE* rte;

    RUNS_AT_DISPATCH_LEVEL

    // The redirected destination must be a unicast address
    if (!XnetIsValidUnicastAddr(dstaddr)) return;

    // Validate the new gateway address:
    //  must be a unicast address on the same subnet
    //  through which the redirect message arrived
    if (!XnetIsValidUnicastAddr(newgwaddr) ||
        ifp->subnetAddr != (newgwaddr & ifp->addrmask))
        return;

    // Find the current route to the destination
    // and see if the sender of the redirect message
    // is the current next-hop gateway
    rte = IpFindRTE(dstaddr, NULL);
    if (!rte || rte->nexthop != oldgwaddr) return;

    // Add a new host route
    IpAddRTE(dstaddr,
           0xffffffff,
           newgwaddr,
           ifp,
           RTEFLAG_HOST,
           DEFAULT_RTE_METRIC);
}


#if DBG

VOID
IpDumpRouteTable()

/*++

Routine Description:

    Dump the content of the route table in the debugger

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    KIRQL irql;
    RTE* rte;

    DbgPrint("\n*** Route table:\n");
    if (IsListNull(&IpRouteList)) return;

    irql = RaiseToDpc();
    LOOP_THRU_ROUTE_LIST(rte)

        DbgPrint("%s/", IPADDRSTR(rte->dstaddr));
        DbgPrint("%s/", IPADDRSTR(rte->addrmask));
        DbgPrint("%s ", IPADDRSTR(rte->nexthop));
        DbgPrint("%02x %d %d %s\n",
                 rte->flags,
                 rte->metric,
                 rte->refcount,
                 rte->ifp->ifname);

    END_ROUTE_LIST_LOOP
    LowerFromDpc(irql);
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\lib\precomp.h ===
#include "xnetp.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\lib\netpool.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    netpool.c

Abstract:

    Private pool used by the network stack

Notes:

    The private pool is used by the network stack
    when processing asynchronously received packets.
    We don't want to allocate directly out of
    the system pool because that would introduce
    unpredictable memory usage patterns.

Revision History:

    08/03/2000 davidx
        Created it.

--*/

#include "precomp.h"

//
// Pool allocation block header: We intentionally let this have
// the same size as the system pool header. But we've restructured
// the fields in such a way that if you try to free a memory block
// that was allocated out of our private pool to the system pool,
// you'd get a bugcheck.
//

typedef struct _PoolEntry {
    WORD busy;
        // Whether the block is allocated or free

    WORD tag;
        // We're only using 2 bytes for pool tag,
        // since all of our pool tags have the form NET*.

    WORD blockSize;
    WORD previousSize;
        // Size of this block and the previous block in 32-bit units

    LIST_ENTRY links;
        // A free pool entry has two additional pointer fields
        // for maintaining a doubly-linked list of free blocks.
} PoolEntry;

#define POOL_BLOCK_SHIFT 5
#define POOL_BLOCK_SIZE (1 << POOL_BLOCK_SHIFT)
#define MAX_POOL_SIZE (POOL_BLOCK_SIZE * 0xffff)
#define POOL_HEADER_SIZE offsetof(PoolEntry, links)

#define MarkPoolEntryBusy(_entry) ((_entry)->busy = 0x100)
#define MarkPoolEntryFree(_entry) ((_entry)->busy = 0)
#define IsPoolEntryBusy(_entry) ((_entry)->busy == 0x100)
#define IsPoolEntryFree(_entry) ((_entry)->busy == 0)
#define TagPoolEntry(_entry, _tag) ((_entry)->tag = (WORD) ((_tag) >> 16))

#define GetPoolEntryHeader(_ptr) \
        ((PoolEntry*) ((BYTE*) (_ptr) - POOL_HEADER_SIZE))
#define GetPoolEntryNext(_entry) \
        ((PoolEntry*) ((BYTE*) (_entry) + ((UINT) (_entry)->blockSize << POOL_BLOCK_SHIFT)))
#define GetPoolEntryPrev(_entry) \
        ((PoolEntry*) ((BYTE*) (_entry) - ((UINT) (_entry)->previousSize << POOL_BLOCK_SHIFT)))

//
// Default number of pages used for our private pool (48KB)
//
UINT cfgXnetPoolSize = 48*1024;

//
// Beginning and ending address of the entire pool
//
#define MAX_SMALL_BLOCKS 5
typedef struct _XnetPoolData {
    PoolEntry* start;
    PoolEntry* end;
    LIST_ENTRY freeLists[MAX_SMALL_BLOCKS+1];
        // List of free pool blocks:
        //  we keep a separate list for each type of small blocks
        //  and the last list is for all large blocks
} XnetPoolData;
XnetPoolData _XnetPool;

#define IsPoolEntryValid(pool,_entry) ((_entry) >= (pool)->start && (_entry) < (pool)->end)

#define InsertFreePoolEntry(pool,_entry) { \
            LIST_ENTRY* _head; \
            _head = &(pool)->freeLists[ \
                        (_entry)->blockSize <= MAX_SMALL_BLOCKS ? \
                            (_entry)->blockSize - 1 : \
                            MAX_SMALL_BLOCKS]; \
            InsertHeadList(_head, &(_entry)->links); \
        }

// Set this variable to TRUE to force a breakpoint
// when xnet pool allocation fails.
#if DBG
BOOL XnetBreakWhenPoolEmpty;
#endif


PRIVATE VOID
_XnetPoolInit(
    XnetPoolData* pool,
    VOID* bufstart,
    UINT bufsize
    )

/*++

Routine Description:

    Initialize a private memory pool

Arguments:

    pool - Points to the pool data structure
    bufstart - Starting address of the memory pool buffer
    bufsize - Size of the memory buffer

Return Value:

    NONE

--*/

{
    PoolEntry* entry;
    UINT n;

    pool->start = (PoolEntry*) bufstart;
    pool->end = (PoolEntry*) ((BYTE*) bufstart + bufsize);

    // Initialize the free lists with a single big block

    for (n=0; n <= MAX_SMALL_BLOCKS; n++) {
        InitializeListHead(&pool->freeLists[n]);
    }

    // NOTE: we reserved the very first and the very last
    // pool blocks. This saves us from a couple of extra checks
    // during alloc and free.

    entry = pool->start;
    MarkPoolEntryBusy(entry);
    TagPoolEntry(entry, PTAG_POOL);
    entry->previousSize = 0;
    entry->blockSize = 1;

    entry = GetPoolEntryNext(entry);
    n = (bufsize >> POOL_BLOCK_SHIFT) - 2;
    MarkPoolEntryFree(entry);
    TagPoolEntry(entry, PTAG_POOL);
    entry->previousSize = 1;
    entry->blockSize = (WORD) n;
    InsertFreePoolEntry(pool, entry);

    entry = GetPoolEntryNext(entry);
    MarkPoolEntryBusy(entry);
    TagPoolEntry(entry, PTAG_POOL);
    entry->previousSize = (WORD) n;
    entry->blockSize = 1;
}


#if DBG

PRIVATE VOID
_XnetPoolDump(
    XnetPoolData* pool
    )

/*++

Routine Description:

    Dump out the content of a private pool

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    PoolEntry* entry;
    PoolEntry* prev;
    UINT total = 0;

    DbgPrint("XNET pool %x: %x - %x\n", pool, pool->start, pool->end);

    prev = NULL;
    entry = pool->start;

    while (entry < pool->end) {
        BOOL isbusy = IsPoolEntryBusy(entry);
        if (isbusy) total += entry->blockSize;

        DbgPrint("%c%c%c %08x l%x\n",
            isbusy ? '*' : ' ',
            entry->tag,
            entry->tag >> 8,
            entry,
            entry->blockSize << POOL_BLOCK_SHIFT);

        if (prev) {
            ASSERT(prev->blockSize == entry->previousSize);
            prev = entry;
        }
        entry = GetPoolEntryNext(entry);
    }

    DbgPrint(" Total allocation: %d / %d\n",
        total << POOL_BLOCK_SHIFT,
        (BYTE*) pool->end - (BYTE*) pool->start);
}

#endif // DBG

PRIVATE VOID*
_XnetAlloc(
    XnetPoolData* pool,
    SIZE_T size,
    ULONG tag
    )

/*++

Routine Description:

    Allocate memory from a private pool

Arguments:

    pool - Points to the pool data structure
    size - Specifies the number of bytes needed
    tag - Specifies the memory tag for the caller

Return Value:

    Pointer to the allocated memory buffer
    NULL if we're out of memory

--*/

{
    PoolEntry* entry;
    KIRQL irql;

    ASSERT(size > 0 && size <= MAX_POOL_SIZE - POOL_HEADER_SIZE);
    size = (size + (POOL_HEADER_SIZE + POOL_BLOCK_SIZE - 1)) >> POOL_BLOCK_SHIFT;

    irql = RaiseToDpc();

    // Find a free pool block that's large enough for us.
    // Handle small block allocation with the quick lookup.
    if (size <= MAX_SMALL_BLOCKS) {
        UINT index;

        for (index=size-1; index <= MAX_SMALL_BLOCKS; index++) {
            if (!IsListEmpty(&pool->freeLists[index])) {
                entry = GetPoolEntryHeader(pool->freeLists[index].Flink);
                goto found;
            }
        }
    } else {
        LIST_ENTRY* head;
        LIST_ENTRY* list;

        head = &pool->freeLists[MAX_SMALL_BLOCKS];
        list = head->Flink;
        while (list != head) {
            entry = GetPoolEntryHeader(list);
            if ((WORD) size <= entry->blockSize) goto found;
            list = list->Flink;
        }
    }

    #if DBG

    WARNING_("Xnet%s pool allocation failed: pool %x, %d blocks",
        XnetInsideDbgmon() ? " (XBDM)" : "", pool, size);
    WARNING_("Make sure you're promptly calling recv() to receive incoming data.\n");
    WARNING_("You may also want to consider setting a larger Xnet pool size.\n");

    if (XnetBreakWhenPoolEmpty || XnetInsideDbgmon()) {
        _XnetPoolDump(pool);
        __asm int 3
    }

    #endif

    LowerFromDpc(irql);
    return NULL;

found:
    // Take it out of the free list
    RemoveEntryList(&entry->links);

    // If we didn't use up the entire free block,
    // put the remaining portion back on the free list.
    if (entry->blockSize > size) {
        UINT leftover = entry->blockSize - size;
        PoolEntry* next;

        entry->blockSize = (WORD) size;
        next = GetPoolEntryNext(entry);
        next->blockSize = (WORD) leftover;
        next->previousSize = (WORD) size;
        next->tag = entry->tag;
        MarkPoolEntryFree(next);
        InsertFreePoolEntry(pool, next);

        next = GetPoolEntryNext(next);
        ASSERT(IsPoolEntryValid(pool, next));
        next->previousSize = (WORD) leftover;
    }

    MarkPoolEntryBusy(entry);
    TagPoolEntry(entry, tag);
    LowerFromDpc(irql);

    return (BYTE*) entry + POOL_HEADER_SIZE;
}


PRIVATE VOID
_XnetFree(
    XnetPoolData* pool,
    VOID* ptr
    )

/*++

Routine Description:

    Free the memory buffer to a private pool

Arguments:

    pool - Points to the pool data structure
    ptr - Points to the memory buffer to be freed

Return Value:

    NONE

--*/

{
    PoolEntry* entry;
    PoolEntry* prev;
    PoolEntry* next;
    WORD blockSize;
    KIRQL irql;

    if (!ptr) return;
    entry = GetPoolEntryHeader(ptr);
    ASSERT(IsPoolEntryValid(pool, entry) && IsPoolEntryBusy(entry));

    irql = RaiseToDpc();
    MarkPoolEntryFree(entry);
    blockSize = entry->blockSize;

    //
    // Check to see if the block before this one is free
    // If so, collapse the two free blocks together
    //
    prev = GetPoolEntryPrev(entry);
    ASSERT(IsPoolEntryValid(pool, prev));
    if (IsPoolEntryFree(prev)) {
        RemoveEntryList(&prev->links);
        prev->blockSize = (WORD) (prev->blockSize + blockSize);
        entry = prev;
    }

    //
    // Check if the block after this one is free
    // If so, collapse the two free blocks together
    //
    next = GetPoolEntryNext(entry);
    ASSERT(IsPoolEntryValid(pool, next) && next->previousSize == blockSize);
    if (IsPoolEntryFree(next)) {
        RemoveEntryList(&next->links);
        entry->blockSize = (WORD) (entry->blockSize + next->blockSize);
    }

    //
    // If we performed any collapsing, 
    // update the previousSize field of the next block.
    //
    if (entry->blockSize != blockSize) {
        next = GetPoolEntryNext(entry);
        ASSERT(IsPoolEntryValid(pool, next));
        next->previousSize = entry->blockSize;
    }

    InsertFreePoolEntry(pool, entry);
    LowerFromDpc(irql);
}


//
// Public functions
//

NTSTATUS XnetPoolInit()
{
    VOID* p;

    // Preallocate all the memory we need
    if (cfgXnetPoolSize > MAX_POOL_SIZE)
        cfgXnetPoolSize = MAX_POOL_SIZE;

    p = SysAlloc(cfgXnetPoolSize, PTAG_POOL);
    if (!p) return NETERR_MEMORY;
    _XnetPoolInit(&_XnetPool, p, cfgXnetPoolSize);
    return NETERR_OK;
}

VOID XnetPoolCleanup()
{
    if (_XnetPool.start) {
        SysFree(_XnetPool.start);
        _XnetPool.start = _XnetPool.end = NULL;
    }
}

VOID* XnetAlloc(SIZE_T size, ULONG tag)
{
    return _XnetAlloc(&_XnetPool, size, tag);
}

VOID XnetFree(VOID* p) {
    _XnetFree(&_XnetPool, p);
}


//
// BUGBUG: temporary workaround for nv2a snooping bug
//
#ifdef DVTSNOOPBUG

#define XNET_UNCACHED_POOL_SIZE (256*1024)
XnetPoolData XnetUncachedPool;

PRIVATE VOID* XnetUncachedAlloc(SIZE_T size, ULONG tag)
{
    return _XnetAlloc(&XnetUncachedPool, size, tag);
}

PRIVATE VOID XnetUncachedFree(VOID* p)
{
    _XnetFree(&XnetUncachedPool, p);
}

NTSTATUS XnetUncachedPoolInit()
{
    VOID* p;
    
    p = XnetInsideDbgmon() ?
        MmDbgAllocateMemory(XNET_UNCACHED_POOL_SIZE, PAGE_READWRITE|PAGE_NOCACHE) :
        MmAllocateContiguousMemoryEx(
                XNET_UNCACHED_POOL_SIZE,
                0,
                MAXULONG_PTR,
                0,
                PAGE_READWRITE|PAGE_NOCACHE);
    if (!p) return NETERR_MEMORY;

    __asm wbinvd;
    XnetUncachedAllocProc = XnetUncachedAlloc;
    XnetUncachedFreeProc = XnetUncachedFree;
    
    _XnetPoolInit(&XnetUncachedPool, p, XNET_UNCACHED_POOL_SIZE);
    return NETERR_OK;
}

VOID XnetUncachedPoolCleanup()
{
    if (XnetUncachedPool.start) {
        if (XnetInsideDbgmon()) {
            MmDbgFreeMemory(XnetUncachedPool.start, 0);
        } else {
            MmFreeContiguousMemory(XnetUncachedPool.start);
        }
        XnetUncachedPool.start = XnetUncachedPool.end = NULL;
        XnetUncachedAllocProc = NULL;
        XnetUncachedFreeProc = NULL;
    }
}

#endif // DVTSNOOPBUG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\modem\globals.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

    globals.cpp

Abstract:
    
    Global variables for the USB modem.
    
Revision History:

    06-21-00    vadimg      created

--*/

#include "precomp.h"

USB_PNP_CLASS_DRIVER_DESCRIPTION gClassDescription;
USB_PNP_DEVICE_TYPE_DESCRIPTION  gDeviceDescription;

PMDL gpMdl;
URB gUrb;
BOOL gfUrbInUse;
BOOL gfRemoved;
KIRQL gIrql;

PMDL gpMdlRead;
URB gUrbRead;

URB_MEMORY gMem;

COMM_DEVICE_INFO gDevice;
READ_BUFFER gRead;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\lib\netutil.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    netutil.c

Abstract:

    Misc. utility functions used by the net code

Revision History:

    05/17/2000 davidx
        Created it.

--*/

#include "precomp.h"


Packet*
XnetAllocPacket(
    UINT size,
    UINT pktflags
    )

/*++

Routine Description:

    Allocate memory for holding a network packet

Arguments:

    size - Specifies the desired packet size (not including header)
    pktflags - Allocation flags: PKTFLAG_NETPOOL or 0

Return Value:

    Pointer to the allocated packet structure
    NULL if we ran out of memory

--*/

{
    Packet* pkt;

    size += PKTHDRLEN;

    #ifndef DVTSNOOPBUG

    if (pktflags & PKTFLAG_NETPOOL)
        pkt = (Packet*) XnetAlloc(size, PTAG_PKT);
    else 
        pkt = (Packet*) SysAlloc(size, PTAG_PKT);

    #else

    // BUGBUG: temporary hack to workaround nv2a snooping bug
    pktflags = PKTFLAG_UNCACHED;
    pkt = (Packet*) XnetUncachedAllocProc(size, PTAG_PKT);

    #endif

    if (pkt) {
        pkt->nextpkt = NULL;
        pkt->pktflags = (WORD) (pktflags | defaultPacketAllocFlag);
        pkt->data = pkt->buf;
        pkt->datalen = 0;
        pkt->completionCallback = NULL;
    } else {
        WARNING_("Couldn't allocate packet: out of memory");
    }

    return pkt;
}


Packet*
XnetCopyPacket(
    Packet* pkt,
    UINT extraHdr
    )

/*++

Routine Description:

    Make a copy of the specified packet

Arguments:

    pkt - Specifies the packet to be copied
    extraHdr - Extra space to reserve at the beginning of the copied packet

Return Value:

    Return a pointer to the copied packet
    NULL if out of memory

--*/

{
    Packet* newpkt;

    ASSERT(pkt != NULL);

    // Allocate memory space for the new packet
    newpkt = XnetAllocPacket(extraHdr + pkt->datalen, 0);
    if (!newpkt) return NULL;
    newpkt->data += extraHdr;

    // Copy data into the new packet
    if (pkt->datalen) {
        newpkt->datalen = pkt->datalen;
        CopyMem(newpkt->data, pkt->data, pkt->datalen);
    }

    return newpkt;
}


CHAR*
IpAddrToString(
    IPADDR ipaddr,
    CHAR* buf,
    INT buflen
    )

/*++

Routine Description:

    Convert an IP address to an ASCII character string

Arguments:

    ipaddr - Specifies the IP address in question
    buf - Output buffer
    buflen - Size of the output buffer

Return Value:

    Points to the converted IP address string

--*/

{
    // The longest string is xxx.xxx.xxx.xxx
    CHAR tmpbuf[16];
    INT i, j, q, r, d;
    CHAR* s;
    CHAR* p;

    // If the caller's buffer is large enough, then we'll
    // use it directly. Otherwise, we'll use a temporary
    // stack buffer first and then copy the result into
    // the caller's buffer.
    p = s = (buflen >= sizeof(tmpbuf)) ? buf : tmpbuf;

    for (i=0; i < 4; i++) {
        r = ipaddr & 0xff;
        ipaddr = ipaddr >> 8;   // assume little-endian here
        d = 100;
        for (j=0; j < 3; j++) {
            q = r / d;
            r = r % d;
            d /= 10;
            if (q || j == 2 || (p != s && p[-1] != '.'))
                *p++ = (CHAR) (q + '0');
        }
        *p++ = '.';
    }
    p[-1] = 0;

    if (s != buf) {
        CopyMem(buf, s, min(buflen, p-s));
    }
    return buf;
}


BOOL
IpAddrFromString(
    const CHAR* str,
    IPADDR* ipaddr
    )

/*++

Routine Description:

    Convert the string representation of IP address to its binary form.
    Following formats are recognized:
        a.b.c.d     8-8-8-8
        a.b.c       8-8-16
        a.b         8-24
        a           32
    Each field can be in decimal, octal, or hex format.

Arguments:

    str - Points to the IP address string to be converted
    ipaddr - Returns the binary representation of the IP address
        (in network byte order)

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    ULONG fields[4], addr;
    UINT fieldcnt = 0;
    const UCHAR* p = (const UCHAR*) str;

    // NOTE: We don't handle overflow conditions.

    while (TRUE) {
        // skip leading spaces
        while (*p == ' ') p++;
        if (fieldcnt >= 4 || *p == 0) break;
    
        addr = 0;
        if (*p == '0' && (p[1] == 'x' || p[1] == 'X')) {
            // hex number
            const UCHAR* q = (p += 2);

            while (TRUE) {
                if (*p >= '0' && *p <= '9')
                    addr = (addr << 4) + (*p - '0');
                else if (*p >= 'a' && *p <= 'f')
                    addr = (addr << 4) + 10 + (*p - 'a');
                else if (*p >= 'A' && *p <= 'F')
                    addr = (addr << 4) + 10 + (*p - 'A');
                else
                    break;
                p++;
            }

            if (q == p) return FALSE;

        } else if (*p == '0') {
            // octal number
            do {
                addr = (addr << 3) + (*p - '0');
                p++;
            } while (*p >= '0' && *p <= '7');
        } else if (*p >= '1' && *p <= '9') {
            // decimal number
            do {
                addr = addr*10 + (*p - '0');
                p++;
            } while (*p >= '0' && *p <= '9');
        } else {
            // invalid character
            break;
        }

        // skip trailing spaces and . separator
        while (*p == ' ') p++;
        if (*p == '.') p++;

        fields[fieldcnt++] = addr;
    }

    if (*p) return FALSE;

    switch (fieldcnt) {
    case 1:
        addr = fields[0];
        break;
    case 2:
        addr = ((fields[0] & 0xff) << 24) |
               (fields[1] & 0xffffff);
        break;
    case 3:
        addr = ((fields[0] & 0xff) << 24) |
               ((fields[1] & 0xff) << 16) |
               (fields[2] & 0xffff);
        break;
    case 4:
        addr = ((fields[0] & 0xff) << 24) |
               ((fields[1] & 0xff) << 16) |
               ((fields[2] & 0xff) <<  8) |
               (fields[3] & 0xff);
        break;

    default:
        addr = 0;
        break;
    }

    *ipaddr = HTONL(addr);
    return TRUE;
}


IPADDR
XnetGetDefaultSubnetMask(
    IPADDR ipaddr
    )

/*++

Routine Description:

    Return the default subnet mask for a given IP address

Arguments:

    ipaddr - Specifies the IP address

Return Value:

    Default subnet mask for the specified address

--*/

{
    IPADDR mask;

    if (IS_CLASSA_IPADDR(ipaddr))
        mask = CLASSA_NETMASK;
    else if (IS_CLASSB_IPADDR(ipaddr))
        mask = CLASSB_NETMASK;
    else if (IS_CLASSC_IPADDR(ipaddr))
        mask = CLASSC_NETMASK;
    else if (IS_CLASSD_IPADDR(ipaddr))
        mask = CLASSD_NETMASK;
    else {
        WARNING_("Invalid host IP address: %s", IPADDRSTR(ipaddr));
        mask = 0;
    }

    return mask;
}


//
// Pseudo-random number generator seed
//
ULONG XnetRandSeed;

VOID
XnetInitRandSeed()

/*++

Routine Description:

    Initialize the pseudo random number generator seed

Arguments:

    NONE

Return Value:

    NONE

Note:

    Our initial random number seed is based on processor's timestamp count
    and the system real-time clock. This will be later modified by the
    Ethernet hardware ID.

--*/

{
    LARGE_INTEGER currentTime;

    __asm {
        __emit  0x0f                // rdtsc
        __emit  0x31
        mov     XnetRandSeed, eax
    }

    KeQuerySystemTime(&currentTime);
    XnetRandSeed = (XnetRandSeed ^ currentTime.LowPart) & 0x7fffffff;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\modem\config.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

    usb.cpp

Abstract:
    
    USB code to talk to the modem.
    
Revision History:

    06-21-00    vadimg      created

--*/

#include "precomp.h"

/***************************************************************************\
* CloseEndpoints3
*
\***************************************************************************/

VOID CloseEndpoints3(PURB purb, PVOID)
{
    ASSERT_DISPATCH_LEVEL();

    if (gfRemoved) {
        gDevice.pDevice->RemoveComplete();
        gDevice.pDevice = NULL;
        gfRemoved = FALSE;
    }
}

/***************************************************************************\
* CloseEndpoints2
*
\***************************************************************************/

VOID CloseEndpoints2(PURB purb, PVOID)
{
    ASSERT_DISPATCH_LEVEL();

    if (gDevice.pIntInEndpointHandle != NULL) {

        USB_BUILD_CLOSE_ENDPOINT(
                (PURB_CLOSE_ENDPOINT)purb,
                gDevice.pIntInEndpointHandle,
                (PURB_COMPLETE_PROC)CloseEndpoints3,
                NULL);

        gDevice.pDevice->SubmitRequest((PURB)purb);

        gDevice.pIntInEndpointHandle = NULL;
    }
}

/***************************************************************************\
* CloseEndpoints1
*
\***************************************************************************/

VOID CloseEndpoints1(PURB purb, PVOID)
{
    ASSERT_DISPATCH_LEVEL();

    if (gDevice.pBulkOutEndpointHandle != NULL) {

        USB_BUILD_CLOSE_ENDPOINT(
                (PURB_CLOSE_ENDPOINT)purb,
                gDevice.pBulkOutEndpointHandle,
                (PURB_COMPLETE_PROC)CloseEndpoints2,
                NULL);

        gDevice.pDevice->SubmitRequest((PURB)purb);

        gDevice.pBulkOutEndpointHandle = NULL;
    }
}

/***************************************************************************\
* CloseEndpoints
*
\***************************************************************************/

VOID CloseEndpoints(VOID)
{
    PURB purb = &gUrb;

    ASSERT_DISPATCH_LEVEL();

    if (gDevice.pBulkInEndpointHandle != NULL) {

        USB_BUILD_CLOSE_ENDPOINT(
                (PURB_CLOSE_ENDPOINT)purb,
                gDevice.pBulkInEndpointHandle,
                (PURB_COMPLETE_PROC)CloseEndpoints1,
                NULL);

        gDevice.pDevice->SubmitRequest((PURB)purb);

        gDevice.pBulkInEndpointHandle = NULL;
    }
}

/***************************************************************************\
* OpenEndpoints
*
\***************************************************************************/

BOOL OpenEndpoints(VOID)
{
    USBD_STATUS status;
    PURB_OPEN_ENDPOINT purb = (PURB_OPEN_ENDPOINT)&gUrb;

    ASSERT_DISPATCH_LEVEL();

    if (gDevice.pBulkInEndpointHandle == NULL) {

        USB_BUILD_OPEN_ENDPOINT(
                purb,
                gDevice.bBulkInEndpointAddress,
                USB_ENDPOINT_TYPE_BULK,
                gDevice.wBulkInMaxPacket,
                2);
    
        status = gDevice.pDevice->SubmitRequest((PURB)purb);
        if (USBD_SUCCESS(status)) {
            gDevice.pBulkInEndpointHandle = purb->EndpointHandle;
        } else {
            return FALSE;
        }
    }

    if (gDevice.pBulkOutEndpointHandle == NULL) {

        USB_BUILD_OPEN_ENDPOINT(
                purb,
                gDevice.bBulkOutEndpointAddress,
                USB_ENDPOINT_TYPE_BULK,
                gDevice.wBulkOutMaxPacket,
                2);
    
        status = gDevice.pDevice->SubmitRequest((PURB)purb);
        if (USBD_SUCCESS(status)) {
            gDevice.pBulkOutEndpointHandle = purb->EndpointHandle;
        } else {
            return FALSE;
        }
    }

    if (gDevice.pIntInEndpointHandle == NULL) {

        USB_BUILD_OPEN_ENDPOINT(
                purb,
                gDevice.bIntInEndpointAddress,
                USB_ENDPOINT_TYPE_INTERRUPT,
                gDevice.wIntInMaxPacket,
                2);
    
        status = gDevice.pDevice->SubmitRequest((PURB)purb);
        if (USBD_SUCCESS(status)) {
            gDevice.pIntInEndpointHandle = purb->EndpointHandle;
        } else {
            return FALSE;
        }
    }

    return TRUE;
}

/***************************************************************************\
* EnumSetConfiguration1
*
\***************************************************************************/

VOID EnumSetConfiguration1(PURB purb, IUsbDevice *pDevice)
{
    ASSERT_DISPATCH_LEVEL();

    if (USBD_ERROR(purb->Header.Status)) {
        pDevice->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE, NULL);
        return;
    }

    gDevice.pDevice = pDevice;
    pDevice->SetClassSpecificType(0);
    pDevice->AddComplete(USBD_STATUS_SUCCESS, NULL);
}

/***************************************************************************\
* EnumGetConfiguration1
*
\***************************************************************************/

VOID EnumGetConfiguration1(PURB purb, IUsbDevice *pDevice)
{
    PUSB_COMMON_DESCRIPTOR pCommonDesc;
    PUSB_CONFIGURATION_DESCRIPTOR pConfigDesc;
    PUSB_INTERFACE_DESCRIPTOR pInterDesc;
    PUSB_ENDPOINT_DESCRIPTOR pEndDesc;
    UCHAR bType, bNumInter, bNumEnd, iInter, iEnd;
    PUCHAR pParse;
    BOOL fCommFound = FALSE;

    ASSERT_DISPATCH_LEVEL();

    if (USBD_ERROR(purb->Header.Status)) {
        pDevice->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE, NULL);
        return;
    }

    pConfigDesc = (PUSB_CONFIGURATION_DESCRIPTOR)&gMem.ConfigDesc;

    // pointer to the first interface
    pParse = (PUCHAR)pConfigDesc + pConfigDesc->bLength;
    pCommonDesc = (PUSB_COMMON_DESCRIPTOR)pParse;
    iInter = iEnd = 0;
    bNumInter = pConfigDesc->bNumInterfaces;

    while (TRUE) {

        if (pCommonDesc->bDescriptorType == USB_INTERFACE_DESCRIPTOR_TYPE) {

            pInterDesc = (PUSB_INTERFACE_DESCRIPTOR)pCommonDesc;
            bNumEnd = pInterDesc->bNumEndpoints;
            iInter++;
            iEnd = 0;

            if (pInterDesc->bInterfaceClass == USB_COMM_COMMUNICATION_CLASS_CODE) {
                gDevice.bCommInterface = pInterDesc->bInterfaceNumber;
                fCommFound = TRUE;
            }

            if ((iInter == bNumInter) && (bNumEnd == 0)) {
                break;
            }

        } else if (pCommonDesc->bDescriptorType == USB_ENDPOINT_DESCRIPTOR_TYPE) {

            pEndDesc = (PUSB_ENDPOINT_DESCRIPTOR)pCommonDesc;
            bType = (pEndDesc->bmAttributes & USB_ENDPOINT_TYPE_MASK);
            iEnd++;

            if (USB_ENDPOINT_DIRECTION_IN(pEndDesc->bEndpointAddress)) {
                if (bType == USB_ENDPOINT_TYPE_BULK) {
                    gDevice.bBulkInEndpointAddress = pEndDesc->bEndpointAddress;
                    gDevice.wBulkInMaxPacket = pEndDesc->wMaxPacketSize;
                    gDevice.pBulkInEndpointHandle = NULL;
                } else if (bType == USB_ENDPOINT_TYPE_INTERRUPT) {
                    gDevice.bIntInEndpointAddress = pEndDesc->bEndpointAddress;
                    gDevice.wIntInMaxPacket = pEndDesc->wMaxPacketSize;
                    gDevice.pIntInEndpointHandle = NULL;
                }
            } else {
                if (bType == USB_ENDPOINT_TYPE_BULK) {
                    gDevice.bBulkOutEndpointAddress = pEndDesc->bEndpointAddress;
                    gDevice.wBulkOutMaxPacket = pEndDesc->wMaxPacketSize;
                    gDevice.pBulkOutEndpointHandle = NULL;
                }
            }

            if ((iInter == bNumInter) && (iEnd == bNumEnd)) {
                break;
            }
        } 

        pParse += pCommonDesc->bLength;
        pCommonDesc = (PUSB_COMMON_DESCRIPTOR)pParse;
    }

    if (!fCommFound) {
        pDevice->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE, NULL);
        return;
    }

    USB_BUILD_SET_CONFIGURATION(
            (PURB_CONTROL_TRANSFER)purb,
            pConfigDesc->bConfigurationValue,
            (PURB_COMPLETE_PROC)EnumSetConfiguration1,
            (PVOID)pDevice);

    ((PURB_CONTROL_TRANSFER)purb)->InterruptDelay = 3;
    pDevice->SubmitRequest(purb);
}

/***************************************************************************\
* ConfigureDevice
*
\***************************************************************************/

VOID ConfigureDevice(IUsbDevice *pDevice)
{
    PURB purb = &gUrb;

    ASSERT_DISPATCH_LEVEL();

    DbgPrint("xmodem: ConfigureDevice\n");

    USB_BUILD_OPEN_DEFAULT_ENDPOINT((PURB_OPEN_ENDPOINT)purb);
    pDevice->SubmitRequest(purb);

    if (USBD_ERROR(purb->Header.Status)) {
        pDevice->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE, NULL);
        return;
    }

    MmInitializeMdl(gpMdl, &gMem, sizeof(gMem));

    USB_BUILD_GET_DESCRIPTOR(
            (PURB_CONTROL_TRANSFER)purb,
            USB_CONFIGURATION_DESCRIPTOR_TYPE,
            1,
            0,
            gpMdl,
            CONFIG_DESC_SIZE,
            (PURB_COMPLETE_PROC)EnumGetConfiguration1,
            (PVOID)pDevice);

    ((PURB_CONTROL_TRANSFER)purb)->InterruptDelay = 3;
    pDevice->SubmitRequest(purb);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\modem\ioctl.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

    ioctl.cpp

Abstract:
    
    Serial IO control for the modem.
    
Revision History:

    06-21-00    vadimg      created

--*/

#include "precomp.h"

#define CR_READ   0x00000001
#define CR_WRITE  0x00000002

/***************************************************************************\
* CompleteClassRequest
*
\***************************************************************************/

VOID CompleteClassRequest(PURB purb, PKEVENT pevent)
{
    ASSERT_DISPATCH_LEVEL();

    KeSetEvent(pevent, IO_NO_INCREMENT, FALSE);
}

/***************************************************************************\
* ClassRequest
*
\***************************************************************************/

BOOL ClassRequest(UCHAR uRequest, USHORT wValue, PVOID buffer,
        USHORT cb, ULONG flags)
{
    KEVENT event;
    PURB purb;
    UCHAR bmRequestType;
    UCHAR bTransferDirection;
    PMDL pMdl;

    ASSERT_DISPATCH_LEVEL();

    if (gfUrbInUse) {
        return FALSE;
    }
    purb = &gUrb;

    if (buffer != NULL) {
        MmInitializeMdl(gpMdl, buffer, cb);
        pMdl = gpMdl;
    } else {
        pMdl = NULL;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    bmRequestType = USB_CLASS_COMMAND | USB_COMMAND_TO_INTERFACE;
    if (flags & CR_READ) {
        bmRequestType |= USB_DEVICE_TO_HOST;
        bTransferDirection = USB_TRANSFER_DIRECTION_IN;
    } else {
        bmRequestType |= USB_HOST_TO_DEVICE;
        bTransferDirection = USB_TRANSFER_DIRECTION_OUT;
    }
    USB_BUILD_CONTROL_TRANSFER(
            (PURB_CONTROL_TRANSFER)purb,
            NULL,
            pMdl,
            cb,
            bTransferDirection,
            (PURB_COMPLETE_PROC)CompleteClassRequest,
            (PVOID)&event,
            TRUE,
            bmRequestType,
            uRequest,
            wValue,
            gDevice.bCommInterface,
            cb);

    gDevice.pDevice->SubmitRequest(purb);

    Wait(&event);

    if (USBD_SUCCESS(purb->Header.Status)) {
        return TRUE;
    } else {
        return FALSE;
    }
}

/***************************************************************************\
* GetLineCoding
*
\***************************************************************************/

BOOL GetLineCoding(PULONG pBaudRate, PUCHAR pStopBits, PUCHAR pParity,
        PUCHAR pDataBits)
{
    ASSERT_DISPATCH_LEVEL();

    if (ClassRequest(USB_COMM_GET_LINE_CODING, 0, &gMem.LineCoding,
            sizeof(USB_COMM_LINE_CODING), CR_READ)) {

        *pBaudRate = gMem.LineCoding.DTERate;
        *pStopBits = gMem.LineCoding.CharFormat;
        *pParity = gMem.LineCoding.ParityType;
        *pDataBits = gMem.LineCoding.DataBits;

        return TRUE;
    } else {
        return FALSE;
    }
}

/***************************************************************************\
* SetLineCoding
*
\***************************************************************************/

BOOL SetLineCoding(ULONG BaudRate, UCHAR StopBits, UCHAR Parity,
        UCHAR DataBits)
{
    ASSERT_DISPATCH_LEVEL();

    gMem.LineCoding.DTERate = BaudRate;
    gMem.LineCoding.CharFormat = StopBits;
    gMem.LineCoding.ParityType = Parity;
    gMem.LineCoding.DataBits = DataBits;

    return ClassRequest(USB_COMM_SET_LINE_CODING, 0, &gMem.LineCoding,
            sizeof(USB_COMM_LINE_CODING), CR_WRITE);
}

/***************************************************************************\
* GetDtrRts
*
\***************************************************************************/

BOOL GetDtrRts(USHORT *pwState)
{
    ASSERT_DISPATCH_LEVEL();

    *pwState = gDevice.wDTR_RTS;
    return TRUE;
}

/***************************************************************************\
* SetDtrRts
*
\***************************************************************************/

BOOL SetDtrRts(USHORT wState)
{
    ASSERT_DISPATCH_LEVEL();

    gDevice.wDTR_RTS = wState;

    return ClassRequest(USB_COMM_SET_CONTROL_LINE_STATE, wState, NULL, 0,
            CR_WRITE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\lib\i386\tcpipxsum.asm ===
title  "Compute TCP/IP Checksum"

;/*++
;
; Copyright (c) 1992  Microsoft Corporation
;
; Module Name:
;
;    tcpipxsum.asm
;
; Abstract:
;
;    This module implements a function to compute the checksum of a buffer.
;
; Author:
;
;    David N. Cutler (davec) 27-Jan-1992
;
; Revision History:
;
;     Who         When        What
;     --------    --------    ----------------------------------------------
;     mikeab      01-22-94    Pentium optimization
;
;--*/



LOOP_UNROLLING_BITS equ     4
LOOP_UNROLLING      equ     (1 SHL LOOP_UNROLLING_BITS)

        .386
        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include callconv.inc
        include ks386.inc
        .list

XNET    SEGMENT DWORD PUBLIC 'CODE'

;++
;
; ULONG
; tcpipxsum(
;   IN ULONG xsum,
;   IN const VOID* buf,
;   IN UINT len
;   )
;
; Routine Description:
;
;    This function computes the checksum of the specified buffer.
;    It uses Processor's prefetch instruction.
;
; Arguments:
;
;    xsum - Suppiles the initial checksum value, in 16-bit form,
;           with the high word set to 0.
;
;    buf - Supplies a pointer to the buffer to the checksum buffer.
;
;    len - Supplies the length of the buffer in bytes.
;
; Return Value:
;
;    The computed checksum in 32-bit two-partial-accumulators form, added to
;    the initial checksum, is returned as the function value.
;
;--

xsum    equ     12                      ; stack offset to initial checksum
buf     equ     16                      ; stack offset to source address
len     equ     20                      ; stack offset to length in words

to_checksum_last_word:
        jmp     checksum_last_word

to_checksum_done:
        jmp     checksum_done

to_checksum_dword_loop_done:
        jmp     checksum_dword_loop_done

cPublicProc tcpipxsum,3

        push    ebx                     ; save nonvolatile register
        push    esi                     ; save nonvolatile register

        mov     ecx,[esp + len]         ; get length in bytes
        sub     eax,eax                 ; clear computed checksum
        test    ecx,ecx                 ; any bytes to checksum at all?
        jz      short to_checksum_done  ; no bytes to checksum

;
; if the checksum buffer is not word aligned, then add the first byte of
; the buffer to the input checksum.
;

        mov     esi,[esp + buf]         ; get source address
        sub     edx,edx                 ; set up to load word into EDX below
        test    esi,1                   ; check if buffer word aligned
        jz      short checksum_word_aligned ; if zf, buffer word aligned
        mov     ah,[esi]                ; get first byte (we know we'll have
                                        ;  to swap at the end)
        inc     esi                     ; increment buffer address
        dec     ecx                     ; decrement number of bytes
        jz      short to_checksum_done  ; if zf set, no more bytes

;
; If the buffer is not an even number of of bytes, then initialize
; the computed checksum with the last byte of the buffer.
;

checksum_word_aligned:                  ;
        shr     ecx,1                   ; convert to word count
        jnc     short checksum_start    ; if nc, even number of bytes
        mov     al,[esi+ecx*2]          ; initialize the computed checksum
        jz      short to_checksum_done  ; if zf set, no more bytes

;
; Compute checksum in large blocks of dwords, with one partial word up front if
; necessary to get dword alignment, and another partial word at the end if
; needed.
;

;
; Compute checksum on the leading word, if that's necessary to get dword
; alignment.
;

checksum_start:                         ;
        test    esi,02h                 ; check if source dword aligned
        jz      short checksum_dword_aligned ; source is already dword aligned
        mov     dx,[esi]                ; get first word to checksum
        add     esi,2                   ; update source address
        add     eax,edx                 ; update partial checksum
                                        ;  (no carry is possible, because EAX
                                        ;  and EDX are both 16-bit values)
        dec     ecx                     ; count off this word (zero case gets
                                        ;  picked up below)

;
; Checksum as many words as possible by processing a dword at a time.
;

checksum_dword_aligned:
        push    ecx                     ; so we can tell if there's a trailing
                                        ;  word later
        shr     ecx,1                   ; # of dwords to checksum
        jz      short to_checksum_last_word ; no dwords to checksum

        mov     edx,[esi]               ; preload the first dword
        add     esi,4                   ; point to the next dword
        dec     ecx                     ; count off the dword we just loaded
        jz      short to_checksum_dword_loop_done
                                        ; skip the loop if that was the only dword
        mov     ebx,ecx                 ; EBX = # of dwords left to checksum
        add     ecx,LOOP_UNROLLING-1    ; round up loop count
        shr     ecx,LOOP_UNROLLING_BITS ; convert from word count to unrolled loop count
        and     ebx,LOOP_UNROLLING-1    ; # of partial dwords to do in first loop
        jz      short checksum_dword_loop ; special-case when no partial loop,
                                          ;  because fixup below doesn't work
                                          ;  in that case (carry flag is
                                          ;  cleared at this point, as required
                                          ;  at loop entry)
        lea     esi,[esi+ebx*4-(LOOP_UNROLLING*4)]
                                        ; adjust buffer pointer back to
                                        ;  compensate for hardwired displacement
                                        ;  at loop entry point
                                        ; ***doesn't change carry flag***
        jmp     loop_entry[ebx*4]       ; enter the loop to do the first,
                                        ; partial iteration, after which we can
                                        ; just do 32-word blocks
                                        ; ***doesn't change carry flag***

checksum_dword_loop:
        ; prefetch the 32-byte cache line from [esi+0]
        db 0fH
        db 18H
        db 46H
        db 00H

        ; prefetch the 32-byte cache line from [esi+20h]
        db 0fH
        db 18H
        db 46H
        db 20H

DEFLAB  macro   pre,suf
pre&suf:
        endm

TEMP=0
        REPT    LOOP_UNROLLING
        deflab  loop_entry_,%TEMP
        adc     eax,edx
        mov     edx,[esi + TEMP]
TEMP=TEMP+4
        ENDM

checksum_dword_loop_end:

        lea     esi,[esi + LOOP_UNROLLING * 4]  ; update source address
                                        ; ***doesn't change carry flag***
        dec     ecx                     ; count off unrolled loop iteration
                                        ; ***doesn't change carry flag***
        jnz     checksum_dword_loop     ; do more blocks

checksum_dword_loop_done label proc
        adc     eax,edx                 ; finish dword checksum
        mov     edx,0                   ; prepare to load trailing word
        adc     eax,edx

;
; Compute checksum on the trailing word, if there is one.
; High word of EDX = 0 at this point
; Carry flag set iff there's a trailing word to do at this point
;

checksum_last_word label proc           ; "proc" so not scoped to function
        pop     ecx                     ; get back word count
        test    ecx,1                   ; is there a trailing word?
        jz      short checksum_done     ; no trailing word
        add     ax,[esi]                ; add in the trailing word
        adc     eax,0                   ;

checksum_done label proc                ; "proc" so not scoped to function
        mov     ecx,eax                 ; fold the checksum to 16 bits
        ror     ecx,16
        add     eax,ecx
        mov     ebx,[esp + buf]
        shr     eax,16
        test    ebx,1                   ; check if buffer word aligned
        jz      short checksum_combine  ; if zf set, buffer word aligned
        ror     ax,8                    ; byte aligned--swap bytes back
checksum_combine label proc             ; "proc" so not scoped to function
        add     ax, word ptr [esp + xsum] ; combine checksums
        pop     esi                     ; restore nonvolatile register
        adc     eax,0                   ;
        pop     ebx                     ; restore nonvolatile register
        stdRET  tcpipxsum


REFLAB  macro   pre,suf
        dd      pre&suf
        endm

        align   4
loop_entry      label   dword
        dd      0
TEMP=LOOP_UNROLLING*4
        REPT    LOOP_UNROLLING-1
TEMP=TEMP-4
        reflab  loop_entry_,%TEMP
        ENDM

stdENDP tcpipxsum

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\modem\modem.h ===
#ifndef __MODEM_H__
#define __MODEM_H__

// defines
#define CONFIG_DESC_SIZE 80

#define MODEM_ENTER_CRIT() \
    gIrql = KeRaiseIrqlToDpcLevel();

#define MODEM_LEAVE_CRIT() \
    KeLowerIrql(gIrql);
    
// data classes
typedef struct _COMM_DEVICE_INFO {

    IUsbDevice *pDevice;

    UCHAR bCommInterface;

    UCHAR bBulkInEndpointAddress;
    USHORT wBulkInMaxPacket;
    PVOID pBulkInEndpointHandle;

    UCHAR bBulkOutEndpointAddress;
    USHORT wBulkOutMaxPacket;
    PVOID pBulkOutEndpointHandle;

    UCHAR bIntInEndpointAddress;
    USHORT wIntInMaxPacket;
    PVOID pIntInEndpointHandle;

    USHORT wDTR_RTS;

} COMM_DEVICE_INFO;

typedef union _URB_MEMORY {

    UCHAR ConfigDesc[CONFIG_DESC_SIZE];
    USB_DEVICE_DESCRIPTOR DevDesc;
    PUSB_INTERFACE_DESCRIPTOR InterDesc;
    USB_COMM_LINE_CODING LineCoding;

} URB_MEMORY;

typedef struct _READ_BUFFER {

    UCHAR buffer[MODEM_BUFFER_SIZE];
    ULONG iCurrent;
    ULONG cb;
    PKEVENT pevent;
    ULONG fReadPending : 1;

} READ_BUFFER;

// globals
extern USB_PNP_CLASS_DRIVER_DESCRIPTION gClassDescription;
extern USB_PNP_DEVICE_TYPE_DESCRIPTION  gDeviceDescription;

extern PMDL gpMdl;
extern URB gUrb;
extern BOOL gfUrbInUse;
extern BOOL gfRemoved;
extern KIRQL gIrql;

extern PMDL gpMdlRead;
extern URB gUrbRead;

extern URB_MEMORY gMem;

extern COMM_DEVICE_INFO gDevice;
extern READ_BUFFER gRead;

// function declarations
BOOL Modem_IsConnected(VOID);
BOOL Modem_Create(VOID);
BOOL Modem_Close(VOID);

VOID Wait(PKEVENT pevent);

VOID CloseEndpoints(VOID);
BOOL OpenEndpoints(VOID);
VOID ConfigureDevice(IUsbDevice *pDevice);

VOID ReadWorker(VOID);
BOOL ReadData(PUCHAR buffer, ULONG *pcb);
BOOL WriteData(PUCHAR buffer, ULONG *pcb);

BOOL GetLineCoding(PULONG pBaudRate, PUCHAR pStopBits, PUCHAR pParity,
        PUCHAR pDataBits);
BOOL SetLineCoding(ULONG BaudRate, UCHAR StopBits, UCHAR Parity,
        UCHAR DataBits);
BOOL GetDtrRts(USHORT *pwState);
BOOL SetDtrRts(USHORT wState);

#endif // __MODEM_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\modem\modem.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

    modem.cpp

Abstract:
    
    Driver entry points for the XBox USB modem driver.
    
Revision History:

    06-21-00    vadimg      created

--*/

#include "precomp.h"

/***************************************************************************\
* Modem_IsConnected
*
\***************************************************************************/

BOOL Modem_IsConnected(VOID)
{
    ASSERT_DISPATCH_LEVEL();

    return (gDevice.pDevice != NULL);
}

/***************************************************************************\
* Modem_Create
*
\***************************************************************************/

BOOL Modem_Create(VOID)
{
    ASSERT_DISPATCH_LEVEL();

    if (!OpenEndpoints()) {
        CloseEndpoints();
        return FALSE;
    }

    ReadWorker();

    return TRUE;
}

/***************************************************************************\
* Modem_Close
*
\***************************************************************************/

BOOL Modem_Close(VOID)
{
    ASSERT_DISPATCH_LEVEL();

    if (gRead.pevent != NULL) {
        ObDereferenceObject(gRead.pevent);
        gRead.pevent = NULL;
    }

    CloseEndpoints();
    return TRUE;
}

/***************************************************************************\
* Modem_AddDevice
*
\***************************************************************************/

VOID Modem_AddDevice(IUsbDevice *pDevice, PVOID)
{
    ASSERT_DISPATCH_LEVEL();

    if (gDevice.pDevice == NULL) {
        ConfigureDevice(pDevice);
    } else {
        pDevice->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE, NULL);
    }
}

/***************************************************************************\
* CloseDefaultEndpoint
*
\***************************************************************************/

VOID CloseDefaultEndpoint(PURB purb, IUsbDevice *pDevice)
{
    ASSERT_DISPATCH_LEVEL();

    Modem_Close();
}

/***************************************************************************\
* Modem_RemoveDevice
*
\***************************************************************************/

VOID Modem_RemoveDevice(IUsbDevice *pDevice)
{
    PURB purb;

    ASSERT_DISPATCH_LEVEL();

    gfRemoved = TRUE;

    purb = &gUrb;

    USB_BUILD_CLOSE_DEFAULT_ENDPOINT(
            (PURB_CLOSE_ENDPOINT)purb,
            (PURB_COMPLETE_PROC)CloseDefaultEndpoint,
            (PVOID)pDevice);

    pDevice->SubmitRequest(purb);
}

/***************************************************************************\
* DriverEntry
*
\***************************************************************************/

extern "C" NTSTATUS DriverEntry(IN PDRIVER_OBJECT, IN PUNICODE_STRING)
{
    gpMdl = IoAllocateMdl(&gMem, sizeof(gMem), FALSE, FALSE, NULL);
    if (gpMdl == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    gpMdlRead = IoAllocateMdl(&gRead.buffer, MODEM_BUFFER_SIZE, FALSE, FALSE, NULL);
    if (gpMdlRead == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    gDeviceDescription.ConnectorType = USBPNP_CONNECTOR_TYPE_DIRECT;
    gDeviceDescription.ControlEndpointCount = 1;
    gDeviceDescription.BulkEndpointCount = 2;
    gDeviceDescription.InterruptEndpointCount = 1;
    gDeviceDescription.IsochEndpointCount = 0;
    gDeviceDescription.MaxBulkTDperTransfer = 2;
    gDeviceDescription.MaxControlTDperTransfer = 30;
    gDeviceDescription.NumNodes = 1;
    gClassDescription.AddDevice = (PFNADD_USB_DEVICE)Modem_AddDevice;
    gClassDescription.RemoveDevice = (PFNREMOVE_USB_DEVICE)Modem_RemoveDevice;
    gClassDescription.ClassId.AsLong = USB_DEVICE_TYPE_MODEM;
    gClassDescription.DeviceTypeCount = 1;
    gClassDescription.DeviceTypes = &gDeviceDescription;
    
    USBPNP_RegisterClassDriver(1, &gClassDescription);
    
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\modem\precomp.h ===
extern "C" {
#include <ntos.h>
#include <windef.h>
#include <ntddser.h>

#include <usb.h>
#include <usbntfy.h>
#include <debug.h>
#include <xmodem.h>

#include "usbcomm.h"
}

#include "modem.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\modem\stubs.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

    stubs.cpp

Abstract:
    
    APIs for interfacing with the modem.
    
Revision History:

    06-21-00    vadimg      created

--*/

#include "precomp.h"

#define STUB_BEGIN() \
    BOOL fRet = FALSE;

#define STUB_END() \
    return fRet;
    
#define STUB_ENTER() \
    STUB_BEGIN(); \
    MODEM_ENTER_CRIT();

#define STUB_LEAVE() \
    MODEM_LEAVE_CRIT(); \
    STUB_END();

/***************************************************************************\
* Wait
*
* Helper function to wait on an event while out of the critical section.
\***************************************************************************/

VOID Wait(PKEVENT pevent)
{
    gfUrbInUse = TRUE;

    MODEM_LEAVE_CRIT();

    KeWaitForSingleObject(pevent, Suspended, KernelMode, FALSE, NULL);

    MODEM_ENTER_CRIT();

    gfUrbInUse = FALSE;
}


/***************************************************************************\
* ModemIsConnected
*
\***************************************************************************/

BOOL ModemIsConnected(VOID)
{
    STUB_ENTER();

    fRet = Modem_IsConnected();

    STUB_LEAVE();
}

/***************************************************************************\
* ModemOpen
*
\***************************************************************************/

BOOL ModemOpen(HANDLE hEvent)
{
    NTSTATUS status;
    PKEVENT pevent;

    if (hEvent != NULL) {
        status = ObReferenceObjectByHandle(hEvent, *ExEventObjectType,
            (PVOID*)&pevent);
    } else {
        pevent = NULL;
        status = STATUS_SUCCESS;
    }

    STUB_ENTER();

    if (Modem_IsConnected() && (gRead.pevent == NULL) && NT_SUCCESS(status)) {
        if (Modem_Create()) {
            gRead.pevent = pevent;
            fRet = TRUE;
        }
    }

    MODEM_LEAVE_CRIT();

    if (!fRet && pevent != NULL) {
        ObDereferenceObject(pevent);
    }

    STUB_END();
}

/***************************************************************************\
* ModemClose
*
\***************************************************************************/

BOOL ModemClose(VOID)
{
    STUB_ENTER();

    if (Modem_IsConnected()) {
        fRet = Modem_Close();
    }

    STUB_LEAVE();
}

/***************************************************************************\
* ModemWrite
*
\***************************************************************************/

BOOL ModemWrite(PUCHAR buffer, ULONG *pcb)
{
    STUB_ENTER();

    if (Modem_IsConnected()) {
        if (*pcb > MODEM_BUFFER_SIZE) {
            *pcb = MODEM_BUFFER_SIZE;
        }
        fRet = WriteData(buffer, pcb);
    }

    STUB_LEAVE();
}

/***************************************************************************\
* ModemRead
*
\***************************************************************************/

BOOL ModemRead(PUCHAR buffer, ULONG *pcb)
{
    STUB_ENTER();

    if (Modem_IsConnected()) {
        if (*pcb > MODEM_BUFFER_SIZE) {
            *pcb = MODEM_BUFFER_SIZE;
        }
        fRet = ReadData(buffer, pcb);
    }

    STUB_LEAVE();
}

/***************************************************************************\
* ModemPurge
*
\***************************************************************************/

BOOL ModemPurge(DWORD dwFlags)
{
    STUB_ENTER();

    fRet = Modem_IsConnected();

    STUB_LEAVE();
}

/***************************************************************************\
* ModemGetLineCoding
*
\***************************************************************************/

BOOL ModemGetLineCoding(PULONG pBaudRate, PUCHAR pStopBits, PUCHAR pParity,
        PUCHAR pDataBits)
{
    STUB_ENTER();

    fRet = GetLineCoding(pBaudRate, pStopBits, pParity, pDataBits);

    STUB_LEAVE();
}

/***************************************************************************\
* ModemSetLineCoding
*
\***************************************************************************/

BOOL ModemSetLineCoding(ULONG BaudRate, UCHAR StopBits, UCHAR Parity,
        UCHAR DataBits)
{
    STUB_ENTER();

    fRet = SetLineCoding(BaudRate, StopBits, Parity, DataBits);

    STUB_LEAVE();
}

/***************************************************************************\
* ModemGetDtrRts
*
\***************************************************************************/

BOOL ModemGetDtrRts(USHORT *pwState)
{
    STUB_ENTER();

    fRet = GetDtrRts(pwState);

    STUB_LEAVE();
}

/***************************************************************************\
* ModemSetDtrRts
*
\***************************************************************************/

BOOL ModemSetDtrRts(USHORT wState)
{
    STUB_ENTER();

    fRet = SetDtrRts(wState);

    STUB_LEAVE();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\modem\usbcomm.h ===
/****************************************************************************

Copyright (c) 1998  Microsoft Corporation

Module Name:

	USBCOMM.H

Abstract:

	USB Communication Class Header File

Environment:

	Kernel mode & user mode

Notes:

	THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
	KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
	IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
	PURPOSE.

	Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.

Revision History:

	12/23/97 : created

Author:

	Tom Green

****************************************************************************/


#ifndef   __USBCOMM_H__
#define   __USBCOMM_H__

#include <pshpack1.h>


// USB Communication Class Code
#define USB_COMM_COMMUNICATION_CLASS_CODE		0x0002

// USB Communication Class Code
#define USB_COMM_DATA_CLASS_CODE				0x000A

// USB Communication Class SubClass Codes
#define USB_COMM_SUBCLASS_RESERVED				0x0000
#define USB_COMM_SUBCLASS_DIRECT_LINE_CONTROL	0x0001
#define USB_COMM_SUBCLASS_ABSTRACT_CONTROL		0x0002
#define USB_COMM_SUBCLASS_TELEPHONE_CONTROL		0x0003

// USB Communication Class Control Protocol Codes
#define USB_COMM_PROTOCOL_RESERVED				0x0000
#define USB_COMM_PROTOCOL_V25TER				0x0001

// Direct Line Control Model defines
#define USB_COMM_SET_AUX_LINE_STATE				0x0010
#define USB_COMM_SET_HOOK_STATE					0x0011
#define USB_COMM_PULSE_SETUP					0x0012
#define USB_COMM_SEND_PULSE						0x0013
#define USB_COMM_SET_PULSE_TIME					0x0014
#define USB_COMM_RING_AUX_JACK					0x0015

// Direct Line Control Model Notification defines
#define USB_COMM_AUX_JACK_HOOK_STATE			0x0008
#define USB_COMM_RING_DETECT					0x0009


// Abstract Control Model defines
#define USB_COMM_SEND_ENCAPSULATED_COMMAND		0x0000
#define USB_COMM_GET_ENCAPSULATED_RESPONSE		0x0001
#define USB_COMM_SET_COMM_FEATURE				0x0002
#define USB_COMM_GET_COMM_FEATURE				0x0003
#define USB_COMM_CLEAR_COMM_FEATURE				0x0004
#define USB_COMM_SET_LINE_CODING				0x0020
#define USB_COMM_GET_LINE_CODING				0x0021
#define USB_COMM_SET_CONTROL_LINE_STATE			0x0022
#define USB_COMM_SEND_BREAK						0x0023

// Abstract Control Model Notification defines
#define USB_COMM_NETWORK_CONNECTION				0x0000
#define USB_COMM_RESPONSE_AVAILABLE				0x0001
#define USB_COMM_SERIAL_STATE					0x0020


// Telephone Control Model defines
#define USB_COMM_SET_RINGER_PARMS				0x0030
#define USB_COMM_GET_RINGER_PARMS				0x0031
#define USB_COMM_SET_OPERATION_PARMS			0x0032
#define USB_COMM_GET_OPERATION_PARMS			0x0033
#define USB_COMM_SET_LINE_PARMS					0x0034
#define USB_COMM_GET_LINE_PARMS					0x0035
#define USB_COMM_DIAL_DIGITS					0x0036

// Telephone Control Model Notification defines
#define USB_COMM_CALL_STATE_CHANGE				0x0028
#define USB_COMM_LINE_STATE_CHANGE				0x0029


// Descriptor type for Functional Descriptors
#define	USB_COMM_CS_INTERFACE					0x0024
#define USB_COMM_CS_ENDPOINT					0x0025


// Communication Feature Selector Codes
#define USB_COMM_ABSTRACT_STATE					0x0001
#define USB_COMM_COUNTRY_SETTING				0x0002

// POTS Relay Configuration Values
#define USB_COMM_ON_HOOK						0x0000
#define USB_COMM_OFF_HOOK						0x0001
#define USB_COMM_SNOOPING						0x0002


// Operation Mode Values
#define USB_COMM_SIMPLE_MODE					0x0000
#define USB_COMM_STANDALONE_MODE				0x0001
#define USB_COMM_COMPUTER_CENTRIC_MODE			0x0002


// Line State Change Values for SET_LINE_PARMS
#define USB_COMM_DROP_ACTIVE_CALL				0x0000
#define USB_COMM_START_NEW_CALL					0x0001
#define USB_COMM_APPLY_RINGING					0x0002
#define USB_COMM_REMOVE_RINGING					0x0003
#define USB_COMM_SWITCH_TO_SPECIFIC_CALL		0x0004


// Call State Values for GET_LINE_PARMS
#define USB_COMM_CALL_IDLE						0x0000
#define USB_COMM_TYPICAL_DIAL_TONE				0x0001
#define USB_COMM_INTERRUPTED_DIAL_TONE			0x0002
#define USB_COMM_DIALING_IN_PROGRESS			0x0003
#define USB_COMM_RINGBACK						0x0004
#define USB_COMM_CONNECTED						0x0005
#define USB_COMM_INCOMING_CALL					0x0006


// Call State Change values for CALL_STATE_CHANGE
#define USB_COMM_CALL_RESERVED					0x0000
#define USB_COMM_CALL_CALL_HAS_BECOME_IDLE		0x0001
#define USB_COMM_CALL_DIALING					0x0002
#define USB_COMM_CALL_RINGBACK					0x0003
#define USB_COMM_CALL_CONNECTED					0x0004
#define USB_COMM_CALL_INCOMING_CALL				0x0005


// Line State Change Values for LINE_STATE_CHANGE
#define USB_COMM_LINE_LINE_HAS_BECOME_IDLE		0x0000
#define USB_COMM_LINE_LINE_HOLD_POSITION		0x0001
#define USB_COMM_LINE_HOOK_SWITCH_OFF			0x0002
#define USB_COMM_LINE_HOOK_SWITCH_ON			0x0003

// Line Coding Stop Bits
#define USB_COMM_STOPBITS_10					0x0000
#define USB_COMM_STOPBITS_15					0x0001
#define USB_COMM_STOPBITS_20					0x0002

// Line Coding Parity Type
#define USB_COMM_PARITY_NONE					0x0000
#define USB_COMM_PARITY_ODD						0x0001
#define USB_COMM_PARITY_EVEN					0x0002
#define USB_COMM_PARITY_MARK					0x0003
#define USB_COMM_PARITY_SPACE					0x0004


// Control Line State
#define USB_COMM_DTR							0x0001
#define USB_COMM_RTS							0x0002

// Serial State Notification bits
#define USB_COMM_DCD							0x0001
#define USB_COMM_DSR							0x0002
#define USB_COMM_BREAK							0x0004
#define USB_COMM_RING							0x0008
#define USB_COMM_FRAMING_ERROR					0x0010
#define USB_COMM_PARITY_ERROR					0x0020
#define USB_COMM_OVERRUN						0x0040



// Call Management Functional Descriptor

typedef struct _USB_COMM_CALL_MANAGEMENT_FUNC_DESCR
{
	UCHAR		FunctionLength;
	UCHAR		DescriptorType;
	UCHAR		DescriptorSubType;
	UCHAR		Capabilities;
	UCHAR		DataInterface;
} USB_COMM_CALL_MANAGEMENT_FUNC_DESCR, *PUSB_COMM_CALL_MANAGEMENT_FUNC_DESCR;


// Abstract Control Management Functional Descriptor

typedef struct _USB_COMM_ABSTRACT_CONTROL_MANAGEMENT_FUNC_DESCR
{
	UCHAR		FunctionLength;
	UCHAR		DescriptorType;
	UCHAR		DescriptorSubType;
	UCHAR		Capabilities;
} USB_COMM_ABSTRACT_CONTROL_MANAGEMENT_FUNC_DESCR, *PUSB_COMM_ABSTRACT_CONTROL_MANAGEMENT_FUNC_DESCR;


// Direct Line Management Functional Descriptor

typedef struct _USB_COMM_DIRECT_LINE_MANAGEMENT_FUNC_DESCR
{
	UCHAR		FunctionLength;
	UCHAR		DescriptorType;
	UCHAR		DescriptorSubType;
	UCHAR		Capabilities;
} USB_COMM_DIRECT_LINE_MANAGEMENT_FUNC_DESCR, *PUSB_COMM_DIRECT_LINE_MANAGEMENT_FUNC_DESCR;


// Telephone Ringer Functional Descriptor

typedef struct _USB_COMM_TELEPHONE_RINGER_FUNC_DESCR
{
	UCHAR		FunctionLength;
	UCHAR		DescriptorType;
	UCHAR		DescriptorSubType;
	UCHAR		RingerVolSteps;
	UCHAR		NumRingerPatterns;
} USB_COMM_TELEPHONE_RINGER_FUNC_DESCR, *PUSB_COMM_TELEPHONE_RINGER_FUNC_DESCR;


// Telephone Operational Modes Functional Descriptor

typedef struct _USB_COMM_TELEPHONE_OPERATIONAL_MODES_FUNC_DESCR
{
	UCHAR		FunctionLength;
	UCHAR		DescriptorType;
	UCHAR		DescriptorSubType;
	UCHAR		Capabilities;
} USB_COMM_TELEPHONE_OPERATIONAL_MODES_FUNC_DESCR, *PUSB_COMM_TELEPHONE_OPERATIONAL_MODES_FUNC_DESCR;


// Telephone Call and Line State Reporting Capabilities Descriptor

typedef struct _USB_COMM_TELEPHONE_CALL_LINE_STATE_DESCR
{
	UCHAR		FunctionLength;
	UCHAR		DescriptorType;
	UCHAR		DescriptorSubType;
	UCHAR		Capabilities;
} USB_COMM_TELEPHONE_CALL_LINE_STATE_DESCR, *PUSB_COMM_TELEPHONE_CALL_LINE_STATE_DESCR;


// Union Functional Descriptor

typedef struct _USB_COMM_UNION_FUNC_DESCR
{
	UCHAR		FunctionLength;
	UCHAR		DescriptorType;
	UCHAR		DescriptorSubType;
	UCHAR		MasterInterface;
	UCHAR		SlaveInterface;
} USB_COMM_UNION_FUNC_DESCR, *PUSB_COMM_UNION_FUNC_DESCR;


// Country Selection Functional Descriptor

typedef struct _USB_COMM_COUNTRY_SELECTION_FUNC_DESCR
{
	UCHAR		FunctionLength;
	UCHAR		DescriptorType;
	UCHAR		DescriptorSubType;
	UCHAR		CountryCodeRelDate;
	UCHAR		CountryCode;
} USB_COMM_COUNTRY_SELECTION_FUNC_DESCR, *PUSB_COMM_COUNTRY_SELECTION_FUNC_DESCR;


// Class Specific Interface Descriptor

typedef struct _USB_COMM_CLASS_SPECIFIC_INTERFACE_DESCR
{
	UCHAR		FunctionLength;
	UCHAR		DescriptorType;
	UCHAR		DescriptorSubType;
	UCHAR		CDC;
} USB_COMM_CLASS_SPECIFIC_INTERFACE_DESCR, *PUSB_COMM_CLASS_SPECIFIC_INTERFACE_DESCR;


// Line Coding for GET_LINE_CODING and SET_LINE_CODING

typedef struct _USB_COMM_LINE_CODING
{
	ULONG		DTERate;
	UCHAR		CharFormat;
	UCHAR		ParityType;
	UCHAR		DataBits;
} USB_COMM_LINE_CODING, *PUSB_COMM_LINE_CODING;

// Line Status Information for GET_LINE_PARMS

typedef struct _USB_COMM_LINE_STATUS
{
	USHORT		Length;
	ULONG		RingerBitmap;
	ULONG		LineState;
	ULONG		CallState;
} USB_COMM_LINE_STATUS, *PUSB_COMM_LINE_STATUS;

// Serial Status Notification

typedef struct _USB_COMM_SERIAL_STATUS
{
	UCHAR		RequestType;
	UCHAR		Notification;
	USHORT		Value;
	USHORT		Index;
	USHORT		Length;
	USHORT		SerialState;
} USB_COMM_SERIAL_STATUS, *PUSB_COMM_SERIAL_STATUS;


#include <poppack.h>

#endif /*  __USBCOMM_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\ppp\frame.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

    frame.cpp

Abstract:

    Handle PPP framing.

Revision History:

    07-18-00    vadimg      created

--*/

#include "precomp.h"

const USHORT gCRCTable[256] = {
      0x0000, 0x1189, 0x2312, 0x329b, 0x4624, 0x57ad, 0x6536, 0x74bf,
      0x8c48, 0x9dc1, 0xaf5a, 0xbed3, 0xca6c, 0xdbe5, 0xe97e, 0xf8f7,
      0x1081, 0x0108, 0x3393, 0x221a, 0x56a5, 0x472c, 0x75b7, 0x643e,
      0x9cc9, 0x8d40, 0xbfdb, 0xae52, 0xdaed, 0xcb64, 0xf9ff, 0xe876,
      0x2102, 0x308b, 0x0210, 0x1399, 0x6726, 0x76af, 0x4434, 0x55bd,
      0xad4a, 0xbcc3, 0x8e58, 0x9fd1, 0xeb6e, 0xfae7, 0xc87c, 0xd9f5,
      0x3183, 0x200a, 0x1291, 0x0318, 0x77a7, 0x662e, 0x54b5, 0x453c,
      0xbdcb, 0xac42, 0x9ed9, 0x8f50, 0xfbef, 0xea66, 0xd8fd, 0xc974,
      0x4204, 0x538d, 0x6116, 0x709f, 0x0420, 0x15a9, 0x2732, 0x36bb,
      0xce4c, 0xdfc5, 0xed5e, 0xfcd7, 0x8868, 0x99e1, 0xab7a, 0xbaf3,
      0x5285, 0x430c, 0x7197, 0x601e, 0x14a1, 0x0528, 0x37b3, 0x263a,
      0xdecd, 0xcf44, 0xfddf, 0xec56, 0x98e9, 0x8960, 0xbbfb, 0xaa72,
      0x6306, 0x728f, 0x4014, 0x519d, 0x2522, 0x34ab, 0x0630, 0x17b9,
      0xef4e, 0xfec7, 0xcc5c, 0xddd5, 0xa96a, 0xb8e3, 0x8a78, 0x9bf1,
      0x7387, 0x620e, 0x5095, 0x411c, 0x35a3, 0x242a, 0x16b1, 0x0738,
      0xffcf, 0xee46, 0xdcdd, 0xcd54, 0xb9eb, 0xa862, 0x9af9, 0x8b70,
      0x8408, 0x9581, 0xa71a, 0xb693, 0xc22c, 0xd3a5, 0xe13e, 0xf0b7,
      0x0840, 0x19c9, 0x2b52, 0x3adb, 0x4e64, 0x5fed, 0x6d76, 0x7cff,
      0x9489, 0x8500, 0xb79b, 0xa612, 0xd2ad, 0xc324, 0xf1bf, 0xe036,
      0x18c1, 0x0948, 0x3bd3, 0x2a5a, 0x5ee5, 0x4f6c, 0x7df7, 0x6c7e,
      0xa50a, 0xb483, 0x8618, 0x9791, 0xe32e, 0xf2a7, 0xc03c, 0xd1b5,
      0x2942, 0x38cb, 0x0a50, 0x1bd9, 0x6f66, 0x7eef, 0x4c74, 0x5dfd,
      0xb58b, 0xa402, 0x9699, 0x8710, 0xf3af, 0xe226, 0xd0bd, 0xc134,
      0x39c3, 0x284a, 0x1ad1, 0x0b58, 0x7fe7, 0x6e6e, 0x5cf5, 0x4d7c,
      0xc60c, 0xd785, 0xe51e, 0xf497, 0x8028, 0x91a1, 0xa33a, 0xb2b3,
      0x4a44, 0x5bcd, 0x6956, 0x78df, 0x0c60, 0x1de9, 0x2f72, 0x3efb,
      0xd68d, 0xc704, 0xf59f, 0xe416, 0x90a9, 0x8120, 0xb3bb, 0xa232,
      0x5ac5, 0x4b4c, 0x79d7, 0x685e, 0x1ce1, 0x0d68, 0x3ff3, 0x2e7a,
      0xe70e, 0xf687, 0xc41c, 0xd595, 0xa12a, 0xb0a3, 0x8238, 0x93b1,
      0x6b46, 0x7acf, 0x4854, 0x59dd, 0x2d62, 0x3ceb, 0x0e70, 0x1ff9,
      0xf78f, 0xe606, 0xd49d, 0xc514, 0xb1ab, 0xa022, 0x92b9, 0x8330,
      0x7bc7, 0x6a4e, 0x58d5, 0x495c, 0x3de3, 0x2c6a, 0x1ef1, 0x0f78
};

/***************************************************************************\
* CalcCRC
*
\***************************************************************************/

USHORT CalcCRC(PBYTE pb, DWORD cb)
{
    USHORT crc = 0xFFFF;

    while (cb--) {
        crc = (crc >> 8) ^ gCRCTable[(crc ^ *pb++) & 0xFF];
    }

    return ~crc;
}

/***************************************************************************\
* CalcCrc
*
\***************************************************************************/

BOOL CheckCrc(PBYTE pb, DWORD cb)
{
    USHORT crc, crcCheck;

    crcCheck = CalcCRC(pb, cb - 2);
    crc = pb[cb - 2] | (pb[cb - 1] << 8);

    return (crc == crcCheck);
}

/***************************************************************************\
* DecodeFrame 
*
\***************************************************************************/

VOID DecodeFrame(PBYTE pIn, DWORD *pcb)
{
    PBYTE pEnd, pEncoded, pDecoded;
    DWORD cb;

    pEnd = pIn + (*pcb - 1);
    pDecoded = pEncoded = pIn;

    while (pEncoded <= pEnd) {

        if (*pEncoded == PPP_ESC_BYTE) {
            pEncoded++;
            *pDecoded = *pEncoded ^ 0x20;
        } else {
            *pDecoded = *pEncoded;
        }
        pEncoded++;
        pDecoded++;
    }

    cb = pDecoded - pIn;
    *pcb = cb;
}

/***************************************************************************\
* EncodeFrame
*
\***************************************************************************/

VOID EncodeFrame(PBYTE pIn, PBYTE pOut, DWORD *pcb)
{
    DWORD i;
    BYTE ch;
    PBYTE pStart = pOut;
    USHORT crc;

    crc = CalcCRC(pIn, *pcb);

    *(pIn + *pcb) = (UCHAR)crc;
    *(pIn + *pcb + 1) = (UCHAR)(crc >> 8);
    *pcb += 2;

    *pOut++ = PPP_FLAG_BYTE;

    for (i = 0; i < *pcb; i++) {

        ch = pIn[i];

        if ((ch < 0x20 && ((1 << ch) & gFraming.SendAccm)) ||
                ch == 0x7D || ch == 0x7E) {
            *pOut++ = PPP_ESC_BYTE;
            *pOut++ = ch ^ 0x20;
        } else {
            *pOut++ = ch;
        }
    }

    *pOut++ = PPP_FLAG_BYTE;

    *pcb = pOut - pStart;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\modem\transfer.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

    transfer.cpp

Abstract:
    
    Handle transfer of data to and from the modem.
    
Revision History:

    06-21-00    vadimg      created

--*/

#include "precomp.h"

/***************************************************************************\
* CompleteRead
*
\***************************************************************************/

VOID CompleteRead(PURB purb, PVOID)
{
    ASSERT_DISPATCH_LEVEL();

    gRead.fReadPending = FALSE;
    gRead.iCurrent = 0;

    if (USBD_SUCCESS(purb->Header.Status)) {
        gRead.cb = purb->BulkOrInterruptTransfer.TransferBufferLength;

        if (gRead.pevent != NULL) {
            KeSetEvent(gRead.pevent, IO_NO_INCREMENT, FALSE);
        }
    } else {
        gRead.cb = 0;
    }
}

/***************************************************************************\
* ReadWorker
*
\***************************************************************************/

VOID ReadWorker(VOID)
{
    PURB purb;

    ASSERT_DISPATCH_LEVEL();

    if (gRead.fReadPending) {
        return;
    }

    purb = &gUrbRead;

    USB_BUILD_BULK_OR_INTERRUPT_TRANSFER(
            (PURB_BULK_OR_INTERRUPT_TRANSFER)purb,
            gDevice.pBulkInEndpointHandle,
            gpMdlRead,
            MODEM_BUFFER_SIZE,
            USB_TRANSFER_DIRECTION_IN,
            (PURB_COMPLETE_PROC)CompleteRead,
            NULL,
            TRUE);

    if (USBD_SUCCESS(gDevice.pDevice->SubmitRequest(purb))) {
        gRead.fReadPending = TRUE;
    }
}

/***************************************************************************\
* ReadData
*
\***************************************************************************/

BOOL ReadData(PUCHAR buffer, ULONG *pcb)
{
    ULONG cbCopy;

    ASSERT_DISPATCH_LEVEL();

    if (gRead.cb != 0) {
        cbCopy = min(gRead.cb, *pcb);

        RtlCopyMemory(buffer, &gRead.buffer[gRead.iCurrent], cbCopy);

        gRead.iCurrent += cbCopy;
        gRead.cb -= cbCopy;
        *pcb = cbCopy;
    } else {
        *pcb = 0;
    }

    if (gRead.cb == 0) {
        ReadWorker();
    }

    return TRUE;
}

/***************************************************************************\
* CompleteWrite
*
\***************************************************************************/

VOID CompleteWrite(PURB purb, PKEVENT pevent)
{
    ASSERT_DISPATCH_LEVEL();

    KeSetEvent(pevent, IO_NO_INCREMENT, FALSE);
}

/***************************************************************************\
* WriteData
*
\***************************************************************************/

BOOL WriteData(PUCHAR buffer, ULONG *pcb)
{
    KEVENT event;    
    PURB purb;
    BOOL fRet;

    ASSERT_DISPATCH_LEVEL();

    if (gfUrbInUse) {
        return FALSE;
    }
    purb = &gUrb;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    MmInitializeMdl(gpMdl, buffer, *pcb);

    USB_BUILD_BULK_OR_INTERRUPT_TRANSFER(
            (PURB_BULK_OR_INTERRUPT_TRANSFER)purb,
            gDevice.pBulkOutEndpointHandle,
            gpMdl,
            *pcb,
            USB_TRANSFER_DIRECTION_OUT,
            (PURB_COMPLETE_PROC)CompleteWrite,
            (PVOID)&event,
            TRUE);

    gDevice.pDevice->SubmitRequest(purb);

    Wait(&event);

    if (USBD_SUCCESS(purb->Header.Status)) {
        *pcb = purb->BulkOrInterruptTransfer.TransferBufferLength;
        fRet = TRUE;
    } else {
        *pcb = 0;
        fRet = FALSE;
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\phy\precomp.h ===
#include <stddef.h>
#include <ntos.h>
#include <nturtl.h>
#include <xtl.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\ppp\globals.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

    globals.cpp

Abstract:

    PPP globals.

Revision History:

    07-11-00    vadimg      created

--*/

#include "precomp.h"

PPP_INFO gInfo;
PPP_CP_INFO gCpTable[NUM_CP];
LCP_INFO gLcp;
READ_QUEUE gQueue;
PPP_TIMER gTimer;
FRAMING_INFO gFraming;
AP_INFO gAp;
IP_INFO gIp;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\ppp\hostwire.cpp ===
#include "precomp.h"

VOID HostToWireFormat16(WORD wHostFormat, PBYTE pWireFormat)
{
    *((PBYTE)(pWireFormat)+0) = (BYTE)((DWORD)(wHostFormat) >> 8);
    *((PBYTE)(pWireFormat)+1) = (BYTE)(wHostFormat);
}

VOID HostToWireFormat32(DWORD dwHostFormat, PBYTE pWireFormat)
{
    *((PBYTE)(pWireFormat)+0) = (BYTE)((DWORD)(dwHostFormat) >> 24);
    *((PBYTE)(pWireFormat)+1) = (BYTE)((DWORD)(dwHostFormat) >> 16);
    *((PBYTE)(pWireFormat)+2) = (BYTE)((DWORD)(dwHostFormat) >>  8);
    *((PBYTE)(pWireFormat)+3) = (BYTE)(dwHostFormat);
}

WORD WireToHostFormat16(PBYTE pWireFormat)
{
    WORD wHostFormat = ((*((PBYTE)(pWireFormat)+0) << 8) +
            (*((PBYTE)(pWireFormat)+1)));
    return wHostFormat;
}

DWORD WireToHostFormat32(PBYTE pWireFormat)
{
    DWORD dwHostFormat = ((*((PBYTE)(pWireFormat)+0) << 24) +
            (*((PBYTE)(pWireFormat)+1) << 16) +
            (*((PBYTE)(pWireFormat)+2) << 8)  +
            (*((PBYTE)(pWireFormat)+3) ));

    return dwHostFormat;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\phy\phy.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    phy.c

Abstract:

    Ethernet transceiver code inside the ROM

Revision History:

    04//5/2001 davidx
        Created it.

--*/

#include "precomp.h"
#include "phy.h"
#include "nettypes.h"
#include "netutil.h"
#include "ethernet.h"
#ifdef SILVER
#include "i82558.h"
#else
#include "xnic.h"
#endif

//
// Global variables
//  NOTE: The init count persists across quick reboots.
//
DECLSPEC_STICKY DWORD PhyInitFlag;
DWORD PhyLinkState;
LONG PhyLockFlag;

#define PhyLock() InterlockedCompareExchange(&PhyLockFlag, 1, 0)
#define PhyUnlock() (PhyLockFlag = 0)

//
// Macro for spewing debug message
//
#if DBG
BOOL PhyVerboseMode = TRUE;
#define WARNING_ DbgPrint
#define VERBOSE_ !PhyVerboseMode ? (void)0 : (void)DbgPrint
#else !DBG
#define WARNING_ 1 ? (void)0 : (void)
#define VERBOSE_ 1 ? (void)0 : (void)
#endif

//
// Don't declaration private functions as static
//
#ifdef PRIVATE
#undef PRIVATE
#define PRIVATE
#endif

PRIVATE BOOL PhyWriteReg(PNIC_CSR csr, DWORD phyreg, DWORD val);
PRIVATE BOOL PhyReadReg(PNIC_CSR csr, DWORD phyreg, DWORD* val);

PRIVATE BOOL
PhyUpdateLinkState(
    PNIC_CSR csr
    )

/*++

Routine Description:

    Update PHY link state information
    (read the information from the PHY registers)

Arguments:

    csr - Points to the NIC registers

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DWORD anar, lpanar, miiStatus, state = 0;

    if (!PhyReadReg(csr, MIIREG_ANAR, &anar) ||
        !PhyReadReg(csr, MIIREG_LPANAR, &lpanar) ||
        !PhyReadReg(csr, MIIREG_STATUS, &miiStatus))
        return FALSE;

    anar &= lpanar;
    if (anar & (MII4_100BASE_T_FULL_DUPLEX | MII4_100BASE_T_HALF_DUPLEX))
        state |= XNET_LINK_100MBPS;
    else if (anar & (MII4_10BASE_T_FULL_DUPLEX | MII4_10BASE_T_HALF_DUPLEX))
        state |= XNET_LINK_10MBPS;

    if (anar & (MII4_10BASE_T_FULL_DUPLEX | MII4_100BASE_T_FULL_DUPLEX))
        state |= XNET_LINK_FULL_DUPLEX;
    else if (anar & (MII4_10BASE_T_HALF_DUPLEX | MII4_100BASE_T_HALF_DUPLEX))
        state |= XNET_LINK_HALF_DUPLEX;

    if (miiStatus & MIISTATUS_LINK_IS_UP)
        state |= XNET_LINK_IS_UP;

    PhyLinkState = state;
    return TRUE;
}


//
// Wait for up to 500ms until the link to be up.
//
INLINE DWORD PhyWaitForLinkUp(PNIC_CSR csr) {
    DWORD miiStatus = 0;
    INT timeout = 1000;
    while (timeout-- && !(miiStatus & MIISTATUS_LINK_IS_UP)) {
        KeStallExecutionProcessor(500);
        if (!PhyReadReg(csr, MIIREG_STATUS, &miiStatus)) break;
    }
    return miiStatus;
}


#ifndef SILVER

// Clear MDIOADR_LOCK bit
PRIVATE VOID PhyClearMDIOLOCK(PNIC_CSR csr)
{
    INT timeout;

    csr->mdio_adr = MDIOADR_LOCK;
    WARNING_("PHY: MDIOADR_LOCK is set\n");

    timeout = PHYRW_TIMEOUT;
    do {
        KeStallExecutionProcessor(50);
        timeout -= 50;
    } while (timeout > 0 && (csr->mdio_adr & MDIOADR_LOCK));
}


PRIVATE BOOL
PhyReadReg(
    PNIC_CSR csr,
    DWORD phyreg,
    DWORD* val
    )

/*++

Routine Description:

    Read the value of a PHY register

Arguments:

    csr - Points to the NIC registers
    phyreg - Specifies the PHY register to be read
    val - Return the PHY register value

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DWORD mdioadr;
    INT timeout;

    // The lock bit shouldn't be set.
    // Clear it just in case it's stuck.

    if (csr->mdio_adr & MDIOADR_LOCK) {
        PhyClearMDIOLOCK(csr);
    }

    // Write the PHY register address

    mdioadr = (PHY_ADDR << MDIOADR_PHYSHIFT) | (phyreg << MDIOADR_REGSHIFT);
    csr->mdio_adr = mdioadr;

    mdioadr |= MDIOADR_LOCK;
    for (timeout=PHYRW_TIMEOUT; timeout > 0 && (mdioadr & MDIOADR_LOCK); timeout -= 50) {
        KeStallExecutionProcessor(50);
        mdioadr = csr->mdio_adr;
    }

    // Read the PHY register value
    *val = csr->mdio_data;

    if (mdioadr & MDIOADR_LOCK) {
        WARNING_("PHY read failed: reg %d.\n", phyreg);
        ASSERT(FALSE);
        return FALSE;
    }

    return TRUE;
}


PRIVATE BOOL
PhyWriteReg(
    PNIC_CSR csr,
    DWORD phyreg,
    DWORD val
    )

/*++

Routine Description:

    Write the specified value to a PHY register

Arguments:

    csr - Points to the NIC registers
    phyreg - Specifies the PHY register to be written
    val - Specifies the value for the PHY register

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DWORD mdioadr;
    INT timeout;

    // The lock bit shouldn't be set.
    // Clear it just in case it's stuck.

    if (csr->mdio_adr & MDIOADR_LOCK) {
        PhyClearMDIOLOCK(csr);
    }

    // Write the data first

    csr->mdio_data = val;

    // Write the PHY register address

    mdioadr = (PHY_ADDR << MDIOADR_PHYSHIFT) | (phyreg << MDIOADR_REGSHIFT) | MDIOADR_WRITE;
    csr->mdio_adr = mdioadr;

    mdioadr |= MDIOADR_LOCK;
    for (timeout=PHYRW_TIMEOUT; timeout > 0 && (mdioadr & MDIOADR_LOCK); timeout -= 50) {
        KeStallExecutionProcessor(50);
        mdioadr = csr->mdio_adr;
    }

    if (mdioadr & MDIOADR_LOCK) {
        WARNING_("PHY write failed: reg %d.\n", phyreg);
        ASSERT(FALSE);
        return FALSE;
    }

    return TRUE;
}


NTSTATUS
PhyInitialize(
    BOOL forceReset,
    VOID* param OPTIONAL
    )

/*++

Routine Description:

    Initialize the Ethernet PHY interface

Arguments:

    forceReset - Whether to force a PHY reset
    param -optional parameters

Return Value:

    Status code

--*/

{
    PNIC_CSR csr = NicCsr;
    DWORD miiControl, miiStatus;
    INT timeout;
    NTSTATUS status = NETERR_HARDWARE;

    if (PhyLock() != 0)
        return NETERR(ERROR_BUSY);
    
    if (forceReset) {
        PhyInitFlag = 0;
        PhyLinkState = 0;

        //
        // Force the PHY to reset
        //
        miiControl = MIICONTROL_RESET;
        if (!PhyWriteReg(csr, MIIREG_CONTROL, miiControl)) goto err;

        // Wait for up to 500ms
        timeout = 1000;
        while (timeout-- && (miiControl & MIICONTROL_RESET)) {
            KeStallExecutionProcessor(500);
            if (!PhyReadReg(csr, MIIREG_CONTROL, &miiControl)) goto err;
        }

        // If the reset is still asserted, return error
        if (miiControl & MIICONTROL_RESET) goto err;
    } else if (PhyInitFlag) {
        //
        // If PHY is already initialized, just update the link state
        //
        PhyUpdateLinkState(csr);
        status = NETERR_OK;
        goto exit;
    }

    // The auto-negotiation should be started by now.
    // Wait for a max of 3 seconds for it to complete.
    timeout = 6000;
    miiStatus = 0;
    while (timeout-- && !(miiStatus & MIISTATUS_AUTO_NEGOTIATION_COMPLETE)) {
        KeStallExecutionProcessor(500);
        if (!PhyReadReg(csr, MIIREG_STATUS, &miiStatus)) goto err;
    }

    // NOTE: Workaround for ICS PHY problems with some 10base-t hubs
    //  e.g. Garret Communications Magnum Personal Hub H50
    if (XboxHardwareInfo.McpRevision != 0xa1) {
        DWORD icshack;
        // clear bit 8 of undocumented register 0x18
        if (PhyReadReg(csr, 0x18, &icshack)) {
            icshack &= ~0x0100;
            PhyWriteReg(csr, 0x18, icshack);
        }
    }

    //
    // Use auto-negotiation
    //
    if (!PhyReadReg(csr, MIIREG_CONTROL, &miiControl)) goto err;

    if (miiControl & MIICONTROL_RESTART_AUTO_NEGOTIATION) {
        // If the restart-auto-negotiation bit is set,
        // default to the highest available speed in half-duplex mode.
        WARNING_("Auto-negotiation didn't succeed.\n");

        if (miiStatus & (MIISTATUS_100MBS_T4_CAPABLE |
                         MIISTATUS_100MBS_X_HALF_DUPLEX_CAPABLE |
                         MIISTATUS_100MBS_T2_HALF_DUPLEX_CAPABLE)) {
            // We can do 100Mbps
            miiControl |=  MIICONTROL_SPEED_SELECTION_BIT1;
            miiControl &= ~MIICONTROL_SPEED_SELECTION_BIT0;
            PhyLinkState |= XNET_LINK_100MBPS;
        } else if (miiStatus & MIISTATUS_10MBS_HALF_DUPLEX_CAPABLE) {
            // We can do 10Mbps
            miiControl &= ~MIICONTROL_SPEED_SELECTION_BIT1;
            miiControl |=  MIICONTROL_SPEED_SELECTION_BIT0;
            PhyLinkState |= XNET_LINK_10MBPS;
        } else
            goto err;

        PhyLinkState |= XNET_LINK_HALF_DUPLEX;

        // Set the desired speed if the auto-negotiation never completed
        PhyWriteReg(csr, MIIREG_CONTROL, miiControl);

        miiStatus = PhyWaitForLinkUp(csr);
        if (miiStatus & MIISTATUS_LINK_IS_UP)
            PhyLinkState |= XNET_LINK_IS_UP;
    } else {
        // Auto-negotiation worked.
        PhyWaitForLinkUp(csr);
        if (!PhyUpdateLinkState(csr)) goto err;
    }

    PhyInitFlag = 1;
    status = NETERR_OK;

exit:
    PhyUnlock();
    return status;

err:
    WARNING_("Ethernet PHY initialization failed.\n");
    goto exit;
}


//
// Public function for retrieving link state information
//
DWORD PhyGetLinkState(BOOL update)
{
    if ((!PhyLinkState || update) && PhyLock() == 0) {
        PhyUpdateLinkState(NicCsr);
        PhyUnlock();
    }
    return PhyLinkState;
}

#else // !SILVER

PRIVATE BOOL
PhyReadReg(
    PNIC_CSR csr,
    DWORD phyreg,
    DWORD* val
    )

/*++

Routine Description:

    Read the value of a PHY register

Arguments:

    csr - Points to the NIC registers
    phyreg - Specifies the PHY register to be read
    val - Return the PHY register value

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DWORD mdictrl;
    INT timeout;

    if (!(csr->mdiCtrl & MDI_READY)) {
        WARNING_("PHY isn't ready.\n");
    }

    // Initiate the PHY read
    mdictrl = MDI_PHY_REG_ADDR(phyreg) | MDI_PHY_ADDR(1) | MDIOP_READ;
    csr->mdiCtrl = mdictrl;

    // Wait for max 10msecs
    for (timeout = 2000; timeout > 0 && !(mdictrl & MDI_READY); timeout -= 50) {
        KeStallExecutionProcessor(50);
        mdictrl = csr->mdiCtrl;
    }

    if (mdictrl & MDI_READY) {
        *val = (mdictrl & 0xffff);
        return TRUE;
    }
    
    WARNING_("PHY read failed: reg %d.\n", phyreg);
    return FALSE;
}


PRIVATE BOOL
PhyWriteReg(
    PNIC_CSR csr,
    DWORD phyreg,
    DWORD val
    )

/*++

Routine Description:

    Write the specified value to a PHY register

Arguments:

    csr - Points to the NIC registers
    phyreg - Specifies the PHY register to be written
    val - Specifies the value for the PHY register

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DWORD mdictrl;
    INT timeout;

    if (!(csr->mdiCtrl & MDI_READY)) {
        WARNING_("PHY isn't ready.\n");
    }

    // Initiate the PHY write
    mdictrl = MDI_PHY_REG_ADDR(phyreg) | MDI_PHY_ADDR(1) | MDIOP_WRITE | val;
    csr->mdiCtrl = mdictrl;

    // Wait for max 10msecs
    for (timeout = 2000; timeout > 0 && !(mdictrl & MDI_READY); timeout -= 50) {
        KeStallExecutionProcessor(50);
        mdictrl = csr->mdiCtrl;
    }

    if (mdictrl & MDI_READY)
        return TRUE;

    WARNING_("PHY write failed: reg %d.\n", phyreg);
    return FALSE;
}

//
// NOTE: PHY related functions are not fully implemented on the silver xdk box.
//  It's going away anyhow.
//
DWORD PhyGetLinkState(BOOL update)
{
    return PhyLinkState;
}

NTSTATUS PhyInitialize(BOOL forceReset, VOID* param)
{
    PNIC_CSR csr;

    if (PhyLock() != 0)
        return NETERR(ERROR_BUSY);
    
    // On silver xdk box, param points to the NIC CSR register space
    ASSERT(param != NULL && !forceReset);
    csr = (PNIC_CSR) param;

    // Just wait for up to half a second until the link is up
    // and then update the link status
    PhyWaitForLinkUp(csr);
    PhyUpdateLinkState(csr);
    
    PhyInitFlag = 1;
    PhyUnlock();
    return NETERR_OK;
}

#endif // !SILVER
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\ppp\auth.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

    auth.cpp

Abstract:

    Handle authentication.

Revision History:

    07-18-00    vadimg      created

--*/

#include "precomp.h"

/***************************************************************************\
* ApWork
*
\***************************************************************************/

VOID ApWork(DWORD CpIndex, PPP_CONFIG *pRecvConfig)
{
    DWORD dwRetCode;
    DWORD dwLength;
    PPP_PACKET *pSendPacket = GetSendPacket();
    PPP_CONFIG *pSendConfig = (PPP_CONFIG*)pSendPacket->Data;

    dwRetCode = gCpTable[CpIndex].CP_MakeMessage(pRecvConfig);

    if (dwRetCode != NO_ERROR) {
        gInfo.dwError = dwRetCode;
        return;
    }

    switch (gAp.Action) {
    case AP_SendWithTimeout2:
        gInfo.ConfigRetryCount++;

        // fall through

    case AP_Send:
    case AP_SendWithTimeout:
    case AP_SendAndDone:
        HostToWireFormat16((WORD)gCpTable[CpIndex].Protocol,
                (PBYTE)pSendPacket->Protocol);

        dwLength = WireToHostFormat16(pSendConfig->Length);

        SendFrame(dwLength + PPP_PACKET_HDR_LEN);

        gInfo.LastId = (BYTE)-1;
        break;

    case AP_Done:
        if (gInfo.dwError != NO_ERROR) {
            return;
        }

        gInfo.State = FSM_OPENED;
        FsmThisLayerUp(CpIndex);
        break;
    }
}

/***************************************************************************\
* ApStart
*
\***************************************************************************/

BOOL ApStart(DWORD CpIndex)
{
    if (!FsmInit(CpIndex)) {
        return FALSE;
    }

    ApWork(CpIndex, NULL);

    return TRUE;
}

/***************************************************************************\
* ApReset
*
\***************************************************************************/

VOID ApReset(VOID)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\ppp\lcp.h ===
#ifndef __LCP_H__
#define __LCP_H__

#define LCP_DEFAULT_MRU         1500

#define LCP_OPTION_MRU          0x01
#define LCP_OPTION_ACCM         0x02
#define LCP_OPTION_AUTHENT      0x03
#define LCP_OPTION_MAGIC        0x05
#define LCP_OPTION_PFC          0x07
#define LCP_OPTION_ACFC         0x08
#define LCP_OPTION_CALLBACK     0x0D
#define LCP_OPTION_MRRU         0x11
#define LCP_OPTION_SHORT_SEQ    0x12
#define LCP_OPTION_ENDPOINT     0x13
#define LCP_OPTION_LINK_DISCRIM 0x17
#define LCP_OPTION_LIMIT        0x17    // highest # we can handle

#define LCP_N_MRU               (1 << LCP_OPTION_MRU)
#define LCP_N_ACCM              (1 << LCP_OPTION_ACCM)
#define LCP_N_AUTHENT           (1 << LCP_OPTION_AUTHENT)
#define LCP_N_MAGIC             (1 << LCP_OPTION_MAGIC)
#define LCP_N_PFC               (1 << LCP_OPTION_PFC)
#define LCP_N_ACFC              (1 << LCP_OPTION_ACFC)
#define LCP_N_CALLBACK          (1 << LCP_OPTION_CALLBACK)
#define LCP_N_MRRU              (1 << LCP_OPTION_MRRU)
#define LCP_N_SHORT_SEQ         (1 << LCP_OPTION_SHORT_SEQ)
#define LCP_N_ENDPOINT          (1 << LCP_OPTION_ENDPOINT)
#define LCP_N_LINK_DISCRIM      (1 << LCP_OPTION_LINK_DISCRIM)

#define  LCP_AP_FIRST           0x00000001
#define  LCP_AP_EAP             0x00000001
#define  LCP_AP_CHAP_MS_NEW     0x00000002
#define  LCP_AP_CHAP_MS         0x00000004
#define  LCP_AP_CHAP_MD5        0x00000008
#define  LCP_AP_SPAP_NEW        0x00000010
#define  LCP_AP_SPAP_OLD        0x00000020
#define  LCP_AP_PAP             0x00000040
#define  LCP_AP_MAX             0x00000080

// Local.Want - options to request, contains desired values, only
// non-default options need to be negotiated.
// Local.WillNegotiate - options to accept in a NAK from remote.
// Local.Work - options currently being negotiated
// Remote.Want - options to suggest by NAK if not present in REQ.
// Remote.WillNegotiate - options to accept in a REQ from remote.
// Remote.Work - options currently being negotiated.

typedef struct _LCP_OPTIONS {

    DWORD Negotiate;            // negotiation flags
    DWORD MRU;                  // Maximum Receive Unit
    DWORD ACCM;                 // Async Control Char Map
    DWORD AP;                   // Authentication protocol
    DWORD APDataSize;           // Auth. protocol data size in bytes
    PBYTE pAPData;              // Pointer Auth. protocol data
    DWORD MagicNumber;          // Magic number value
    DWORD PFC;                  // Protocol field compression.
    DWORD ACFC;                 // Address and Control Field Compression.
    DWORD Callback;             // Callback
    DWORD MRRU;                 // Maximum Reconstructed Receive Unit
    DWORD ShortSequence;        // Short Sequence Number Header Format
    BYTE  EndpointDiscr[21];    // Endpoint Discriminator.
    DWORD dwEDLength;           // Length of Endpoint Discriminator
    DWORD dwLinkDiscriminator;  // Link Discriminator (for BAP/BACP)

} LCP_OPTIONS;

typedef struct _LCP_SIDE {
    DWORD WillNegotiate;
    DWORD APsAvailable;
    LCP_OPTIONS Want;
    LCP_OPTIONS Work;
} LCP_SIDE;

typedef struct _LCP_INFO {
    LCP_SIDE Local;
    LCP_SIDE Remote;
    DWORD dwMagicNumberFailureCount;
} LCP_INFO;

#endif __LCP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\ppp\lcp.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

    lcp.cpp

Abstract:

    Line Control Protocol.

Revision History:

    07-11-00    vadimg      created

--*/

#include "precomp.h"

LCP_OPTIONS gLcpDefault = {
        0,                  // Negotiation flags
        LCP_DEFAULT_MRU,    // Default value for MRU
        0xFFFFFFFF,         // Default ACCM value.
        0,                  // no authentication ( for client )
        0,                  // no authentication data ( for client )
        NULL,               // no authentication data ( for client )
        0,                  // Magic Number.
        FALSE,               // Protocol field compression.
        FALSE,               // Address and Contorl-Field Compression.
        0,                  // Callback Operation message field
        LCP_DEFAULT_MRU,    // Default value for MRRU == MRU according to RFC1717
        0,                  // No short sequencing
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // No endpoint discriminator
        0,                  // Length of Endpoint Discriminator
        0                   // Link Discriminator (for BAP/BACP)
};

DWORD gSizeOfOption[] = {
        0,                          // unused 
        PPP_OPTION_HDR_LEN + 2,     // MRU 
        PPP_OPTION_HDR_LEN + 4,     // ACCM 
        PPP_OPTION_HDR_LEN + 2,     // authentication 
        0,                          // Unused.
        PPP_OPTION_HDR_LEN + 4,     // magic number 
        0,                          // Reserved, unused
        PPP_OPTION_HDR_LEN + 0,     // Protocol compression 
        PPP_OPTION_HDR_LEN + 0,     // Address/Control compression 
        0,                          // Unused
        0,                          // Unused
        0,                          // Unused
        0,                          // Unused
        PPP_OPTION_HDR_LEN + 1,     // Callback
        0,                          // Unused
        0,                          // Unused
        0,                          // Unused
        PPP_OPTION_HDR_LEN + 2,     // MRRU
        PPP_OPTION_HDR_LEN + 0,     // Short Sequence Header Format
        PPP_OPTION_HDR_LEN,         // Endpoint Discriminator
        0,                          // Unused
        0,                          // Unused
        0,                          // Unused
        PPP_OPTION_HDR_LEN + 2      // Link Discriminator (for BAP/BACP)
};

DWORD gLcpNegotiate = LCP_N_MRU | LCP_N_ACCM | LCP_N_AUTHENT | LCP_N_MAGIC | LCP_N_PFC | LCP_N_ACFC;

/***************************************************************************\
* MakeOption
*
\***************************************************************************/

DWORD MakeOption(LCP_OPTIONS *pOption, DWORD dwOptionCode,
        PPP_OPTION *pSendOption, DWORD cbSendOption)
{
    if (cbSendOption < gSizeOfOption[dwOptionCode]) {
        return ERROR_BUFFER_TOO_SMALL;
    }

    pSendOption->Type = (BYTE)dwOptionCode;
    pSendOption->Length = (BYTE)gSizeOfOption[dwOptionCode];

    switch (dwOptionCode) {
    case LCP_OPTION_MRU:
        HostToWireFormat16((WORD)pOption->MRU, pSendOption->Data);
        break;

    case LCP_OPTION_ACCM:
        HostToWireFormat32(pOption->ACCM, pSendOption->Data);
        break;

    case LCP_OPTION_AUTHENT:
        if (cbSendOption < (gSizeOfOption[dwOptionCode] + pOption->APDataSize)) {
            return ERROR_BUFFER_TOO_SMALL;
        }
        HostToWireFormat16((WORD)pOption->AP, pSendOption->Data);
        CopyMemory(pSendOption->Data + 2, pOption->pAPData, pOption->APDataSize);
        pSendOption->Length += (BYTE)pOption->APDataSize;
        break;

    case LCP_OPTION_MAGIC:
        HostToWireFormat32(pOption->MagicNumber, pSendOption->Data);
        break;
    
    case LCP_OPTION_PFC:
        break;

    case LCP_OPTION_ACFC:
        break;

    case LCP_OPTION_MRRU:    
        HostToWireFormat16((WORD)pOption->MRRU, pSendOption->Data);
        break;

    default: 
        return ERROR_INVALID_PARAMETER;
    }

    return NO_ERROR;
}

/***************************************************************************\
* CheckOption
*
\***************************************************************************/

DWORD CheckOption(LCP_SIDE *pLcpSide, PPP_OPTION *pOption, BOOL fMakingResult)
{
    DWORD dwIndex;
    DWORD dwAPDataSize;
    DWORD dwRetCode = CONFIG_ACK;

    if (pOption->Length < gSizeOfOption[pOption->Type]) {
        return CONFIG_REJ;
    }

    // If we do not want to negotiate the option we CONFIG_REJ it.
    if (!(pLcpSide->WillNegotiate & (1 << pOption->Type))) {
        return CONFIG_REJ;
    }

    switch (pOption->Type) {
    case LCP_OPTION_MRU:
        pLcpSide->Work.MRU = WireToHostFormat16(pOption->Data);

        // Check to see if this value is appropriate
        if (fMakingResult) {

            // We cannot send packets smaller than LCP_DEFAULT_MRU
            if (pLcpSide->Work.MRU < LCP_DEFAULT_MRU) {
                pLcpSide->Work.MRU = pLcpSide->Want.MRU;
                dwRetCode = CONFIG_NAK;
            }
        } else {

            // We cannot receive bigger packets.
            if (pLcpSide->Work.MRU > pLcpSide->Want.MRU) {
                pLcpSide->Work.MRU = pLcpSide->Want.MRU;
                dwRetCode = CONFIG_NAK;
            }
        }
    break;

    case LCP_OPTION_ACCM:
        pLcpSide->Work.ACCM = WireToHostFormat32(pOption->Data);

        // If we are responding to a request, we accept it blindly, if we are
        // processing a NAK, then the remote host may ask to escape more
        // control characters than we require, but must escape at least the
        // control chars that we require.
        if (!fMakingResult) {
            if (pLcpSide->Work.ACCM !=
                    (pLcpSide->Work.ACCM | pLcpSide->Want.ACCM)) {
                pLcpSide->Work.ACCM |= pLcpSide->Want.ACCM;
                dwRetCode = CONFIG_NAK;
            }
        }
        break;

    case LCP_OPTION_AUTHENT:
        pLcpSide->Work.AP = WireToHostFormat16( pOption->Data );

        // If there was Authentication data.
        if (pOption->Length > PPP_OPTION_HDR_LEN + 2) {

            dwAPDataSize = pOption->Length - PPP_OPTION_HDR_LEN - 2;

            if (dwAPDataSize != pLcpSide->Work.APDataSize) {

                pLcpSide->Work.APDataSize = dwAPDataSize;

                if (pLcpSide->Work.pAPData != NULL) {
                    Free(pLcpSide->Work.pAPData);
                    pLcpSide->Work.pAPData = NULL;
                }

                pLcpSide->Work.pAPData = (PBYTE)Alloc(pLcpSide->Work.APDataSize);

                if (pLcpSide->Work.pAPData == NULL) {
                    pLcpSide->Work.APDataSize = 0;
                    return CONFIG_REJ;
                }
            }

            CopyMemory(pLcpSide->Work.pAPData, pOption->Data + 2,
                    pLcpSide->Work.APDataSize);

        } else {

            pLcpSide->Work.APDataSize = 0;
        }

        switch (pLcpSide->Work.AP) {
        case PPP_PAP_PROTOCOL:
            if (!(pLcpSide->APsAvailable & LCP_AP_PAP)) {
                dwRetCode = CONFIG_NAK;
            }
            break;

        default:
            dwRetCode = CONFIG_NAK;
            break;
        }
        break;

    case LCP_OPTION_MAGIC:
        pLcpSide->Work.MagicNumber = WireToHostFormat32(pOption->Data);

        if (fMakingResult) {

            // Ensure that magic numbers are different and that the remote
            // request does not contain a magic number of 0.
            if ((pLcpSide->Work.MagicNumber == gLcp.Local.Work.MagicNumber) ||
                    (pLcpSide->Work.MagicNumber == 0)) {

                if (pLcpSide->Work.MagicNumber == gLcp.Local.Work.MagicNumber) {
                    ++gLcp.dwMagicNumberFailureCount;
                }

                pLcpSide->Work.MagicNumber = GetMagicNumber();

                dwRetCode = CONFIG_NAK;
            }
        } else {

            // The remote peer NAK'ed with a magic number, check to see if
            // the magic number in the NAK is the same as what we NAK'ed last
            if (pLcpSide->Work.MagicNumber == gLcp.Remote.Work.MagicNumber) {

                ++gLcp.dwMagicNumberFailureCount;

                pLcpSide->Work.MagicNumber = GetMagicNumber();

                dwRetCode = CONFIG_NAK;
            }
        }
        break;

    case LCP_OPTION_PFC:
        pLcpSide->Work.PFC = TRUE;

        if (pLcpSide->Want.PFC == FALSE) {
            dwRetCode = CONFIG_REJ;
        }
        break;

    case LCP_OPTION_ACFC:
        pLcpSide->Work.ACFC = TRUE;

        if (pLcpSide->Want.ACFC == FALSE) {
            dwRetCode = CONFIG_REJ;
        }
        break;

    case LCP_OPTION_MRRU:    
        pLcpSide->Work.MRRU = WireToHostFormat16(pOption->Data);

        // Check to see if this value is appropriate
        if (fMakingResult) {

            // We cannot send smaller reconstructed packets.
            if (pLcpSide->Work.MRRU < pLcpSide->Want.MRRU) {
                pLcpSide->Work.MRRU = pLcpSide->Want.MRRU;
                dwRetCode = CONFIG_NAK;
            }
        } else {

            // We cannot receive bigger reconstructed packets.
            if (pLcpSide->Work.MRRU > pLcpSide->Want.MRRU) {
                pLcpSide->Work.MRRU = pLcpSide->Want.MRRU;
                dwRetCode = CONFIG_NAK;
            }
        }
        break;

    default:
        // If we do not recognize the option we CONFIG_REJ it.
        dwRetCode = CONFIG_REJ;
        break;
    }

    return dwRetCode;
}

/***************************************************************************\
* BuildOptionList
*
\***************************************************************************/

DWORD BuildOptionList(BYTE *pOptions, DWORD *pcbOptions,
        LCP_OPTIONS *LcpOptions, DWORD Negotiate)
{
    DWORD OptionType;
    DWORD dwRetCode;
    DWORD cbOptionLength = *pcbOptions;
    DWORD dwResult;

    for (OptionType = 1; OptionType <= LCP_OPTION_LIMIT; OptionType++) {
        if (Negotiate & (1 << OptionType)) {

            dwResult = MakeOption(LcpOptions, OptionType,
                    (PPP_OPTION*)pOptions, cbOptionLength);

            if (dwResult != NO_ERROR) {
                return dwResult;
            }

            cbOptionLength -= ((PPP_OPTION*)pOptions)->Length;
            pOptions += ((PPP_OPTION*)pOptions)->Length;
        }
    }
    *pcbOptions -= cbOptionLength;

    return NO_ERROR;
}

/***************************************************************************\
* LcpMakeConfigResult
*
\***************************************************************************/

DWORD LcpMakeConfigResult(PPP_CONFIG *pRecvConfig, PPP_CONFIG *pSendConfig,
        DWORD cbSendConfig, BOOL fRejectNaks)
{
    DWORD dwDesired;
    DWORD dwRetCode;
    DWORD ResultType = CONFIG_ACK;
    PPP_OPTION *pRecvOption = (PPP_OPTION*)pRecvConfig->Data;
    PPP_OPTION *pSendOption = (PPP_OPTION*)pSendConfig->Data;
    LONG lSendLength = cbSendConfig - PPP_CONFIG_HDR_LEN;
    LONG lRecvLength = WireToHostFormat16(pRecvConfig->Length) - PPP_CONFIG_HDR_LEN;

    // Clear negotiate mask
    gLcp.Remote.Work.Negotiate = 0;

    while (lRecvLength > 0) {

        if (pRecvOption->Length == 0) {
            return ERROR_PPP_INVALID_PACKET;
        }

        lRecvLength -= pRecvOption->Length;

        if (lRecvLength < 0 ) {
            return ERROR_PPP_INVALID_PACKET;
        }

        dwRetCode = CheckOption(&gLcp.Remote, pRecvOption, TRUE);

        // If we were building an ACK and we got a NAK or reject OR
        // we were building a NAK and we got a reject.
        if ((ResultType == CONFIG_ACK && dwRetCode != CONFIG_ACK) ||
                (ResultType == CONFIG_NAK && dwRetCode == CONFIG_REJ)) {
            ResultType  = dwRetCode;
            pSendOption = (PPP_OPTION*)pSendConfig->Data;
            lSendLength = cbSendConfig - PPP_CONFIG_HDR_LEN;
        }

        // Remember that we processed this option
        if (dwRetCode != CONFIG_REJ && pRecvOption->Type <= LCP_OPTION_LIMIT) {
            gLcp.Remote.Work.Negotiate |= (1 << pRecvOption->Type);
        }

        if (dwRetCode == ResultType) {

            // If this option is to be rejected, simply copy the
            // rejected option to the send buffer
            if (dwRetCode == CONFIG_REJ  ||
                    (dwRetCode == CONFIG_NAK && fRejectNaks)) {
                CopyMemory(pSendOption, pRecvOption, pRecvOption->Length);
            } else {

                dwRetCode = MakeOption(&gLcp.Remote.Work, pRecvOption->Type,
                        pSendOption, lSendLength);

                if (dwRetCode != NO_ERROR) {
                    return dwRetCode;
                }
            }

            lSendLength -= pSendOption->Length;

            pSendOption  = (PPP_OPTION*)((BYTE*)pSendOption + pSendOption->Length);
        }

        pRecvOption = (PPP_OPTION*)((BYTE*)pRecvOption + pRecvOption->Length);
    }

    // If this was an NAK and we cannot send any more NAKS then we
    // make this a REJECT packet
    if (ResultType == CONFIG_NAK && fRejectNaks) {
        pSendConfig->Code = CONFIG_REJ;
    } else {
        pSendConfig->Code = (BYTE)ResultType;
    }

    HostToWireFormat16((WORD)(cbSendConfig - lSendLength), pSendConfig->Length);

    if (ResultType == CONFIG_NAK && gLcp.dwMagicNumberFailureCount > 3) {
        return ERROR_PPP_LOOPBACK_DETECTED;
    }

    return NO_ERROR;
}

/***************************************************************************\
* LcpMakeConfigRequest
*
\***************************************************************************/

DWORD LcpMakeConfigRequest(PPP_CONFIG *pConfig, DWORD cbConfig)
{
    DWORD dwRetCode;

    cbConfig -= PPP_CONFIG_HDR_LEN;

    dwRetCode = BuildOptionList(pConfig->Data, &cbConfig, &gLcp.Local.Work,
            gLcp.Local.Work.Negotiate);

    if (dwRetCode != NO_ERROR) {
        return dwRetCode;
    }

    HostToWireFormat16((WORD)(cbConfig + PPP_CONFIG_HDR_LEN), pConfig->Length);

    return NO_ERROR;
}

/***************************************************************************\
* LcpConfigAckReceived
*
\***************************************************************************/

DWORD LcpConfigAckReceived(PPP_CONFIG *pConfig)
{
    DWORD dwRetCode;
    BYTE ConfigReqSent[LCP_DEFAULT_MRU];
    PPP_OPTION *pOption = (PPP_OPTION*)pConfig->Data;
    DWORD cbConfigReqSent = sizeof(ConfigReqSent);
    DWORD dwLength;
            
    dwLength = WireToHostFormat16(pConfig->Length) - PPP_CONFIG_HDR_LEN;

    // Get a copy of last request we sent
    dwRetCode = BuildOptionList(ConfigReqSent, &cbConfigReqSent,
            &gLcp.Local.Work, gLcp.Local.Work.Negotiate);

    if (dwRetCode != NO_ERROR) {
        return dwRetCode;
    }

    if (dwLength != cbConfigReqSent) {
        return ERROR_PPP_INVALID_PACKET;
    }

    if (memcmp(ConfigReqSent, pConfig->Data, dwLength) != 0) {
        return ERROR_PPP_INVALID_PACKET;
    }

    return NO_ERROR;
}

/***************************************************************************\
* LcpConfigNakReceived
*
\***************************************************************************/

DWORD LcpConfigNakReceived(PPP_CONFIG *pConfig)
{
    LONG cbConfig = WireToHostFormat16(pConfig->Length) - PPP_CONFIG_HDR_LEN;
    PPP_OPTION *pOption = (PPP_OPTION*)pConfig->Data;
    DWORD dwLastOption = 0;
    DWORD dwResult;

    while (cbConfig > 0) {

        if (pOption->Length == 0) {
            return ERROR_PPP_INVALID_PACKET;
        }

        cbConfig -= pOption->Length;

        if (cbConfig < 0) {
            return ERROR_PPP_INVALID_PACKET;
        }

        // If this option wasn't requested, mark it as negotiable.
        if (pOption->Type <= LCP_OPTION_LIMIT &&
                (gLcp.Local.WillNegotiate & (1 << pOption->Type)) &&
                !(gLcp.Local.Work.Negotiate & (1 << pOption->Type))) {
            gLcp.Local.Work.Negotiate |= (1 << pOption->Type);
        }

        dwLastOption = pOption->Type;

        dwResult = CheckOption(&gLcp.Local, pOption, FALSE);

        if (dwResult == CONFIG_REJ && pOption->Type <= LCP_OPTION_LIMIT) {
            gLcp.Local.Work.Negotiate &= ~(1 << pOption->Type);
        }

        pOption = (PPP_OPTION*)((BYTE*)pOption + pOption->Length);
    }

    return NO_ERROR;
}

/***************************************************************************\
* LcpConfigRejReceived
*
\***************************************************************************/

DWORD LcpConfigRejReceived(PPP_CONFIG *pConfig)
{
    LONG cbConfig = WireToHostFormat16(pConfig->Length) - PPP_CONFIG_HDR_LEN;
    PPP_OPTION *pOption = (PPP_OPTION*)pConfig->Data;
    DWORD dwLastOption = 0;
    DWORD dwResult;
    BYTE ReqOption[LCP_DEFAULT_MRU];

    while (cbConfig > 0) {

        if (pOption->Length == 0) {
            return ERROR_PPP_INVALID_PACKET;
        }

        cbConfig -= pOption->Length;

        if (cbConfig < 0) {
            return ERROR_PPP_INVALID_PACKET;
        }

        // Can't receive an option out of order or an option that wasn't
        // requested.
        if (pOption->Type <= LCP_OPTION_LIMIT &&
                (pOption->Type < dwLastOption ||
                !(gLcp.Local.Work.Negotiate & (1 << pOption->Type)))) {
            return ERROR_PPP_INVALID_PACKET;
        }

        dwResult = MakeOption(&gLcp.Local.Work, pOption->Type,
                (PPP_OPTION*)ReqOption, sizeof(ReqOption));

        if (dwResult != NO_ERROR) {
            return dwResult;
        }

        if (memcmp(ReqOption, pOption, pOption->Length) != 0) {
            return ERROR_PPP_INVALID_PACKET;
        }

        dwLastOption = pOption->Type;

        if (pOption->Type <= LCP_OPTION_LIMIT) {
            gLcp.Local.Work.Negotiate &= ~(1 << pOption->Type);
        }

        pOption = (PPP_OPTION*)((BYTE*)pOption + pOption->Length);
    }

    return NO_ERROR;
}

/***************************************************************************\
* LcpThisLayerUp
*
\***************************************************************************/

DWORD LcpThisLayerUp(VOID)
{
    if (gLcp.Local.Work.Negotiate & LCP_N_ACCM) {
        gFraming.RecvAccm = gLcp.Local.Work.ACCM;
    }
    if (gLcp.Local.Work.Negotiate & LCP_N_PFC) {
        gFraming.fRecvPfc = gLcp.Local.Work.PFC;
    }
    if (gLcp.Local.Work.Negotiate & LCP_N_ACFC) {
        gFraming.fRecvAcfc = gLcp.Local.Work.ACFC;
    }

    if (gLcp.Remote.Work.Negotiate & LCP_N_ACCM) {
        gFraming.SendAccm = gLcp.Remote.Work.ACCM;
    }
    if (gLcp.Remote.Work.Negotiate & LCP_N_PFC) {
        gFraming.fSendPfc = gLcp.Remote.Work.PFC;
    }
    if (gLcp.Remote.Work.Negotiate & LCP_N_ACFC) {
        gFraming.fSendAcfc = gLcp.Remote.Work.ACFC;
    }

    return NO_ERROR;
}

/***************************************************************************\
* LcpThisLayerDown
*
\***************************************************************************/

DWORD LcpThisLayerDown(VOID)
{
    if (gLcp.Local.Work.Negotiate & LCP_N_ACCM) {
        gFraming.RecvAccm = gLcpDefault.ACCM;
    }
    if (gLcp.Local.Work.Negotiate & LCP_N_PFC) {
        gFraming.fRecvPfc = gLcpDefault.PFC;
    }
    if (gLcp.Local.Work.Negotiate & LCP_N_ACFC) {
        gFraming.fRecvAcfc = gLcpDefault.ACFC;
    }

    if (gLcp.Remote.Work.Negotiate & LCP_N_ACCM) {
        gFraming.SendAccm = gLcpDefault.ACCM;
    }
    if (gLcp.Remote.Work.Negotiate & LCP_N_PFC) {
        gFraming.fSendPfc = gLcpDefault.PFC;
    }
    if (gLcp.Remote.Work.Negotiate & LCP_N_ACFC) {
        gFraming.fSendAcfc = gLcpDefault.ACFC;
    }

    return NO_ERROR;
}

/***************************************************************************\
* LcpEnd
*
\***************************************************************************/

DWORD LcpEnd(VOID)
{
    if (gLcp.Local.Work.pAPData != NULL) {
        Free(gLcp.Local.Work.pAPData);
    }
    if (gLcp.Remote.Work.pAPData != NULL) {
        Free(gLcp.Remote.Work.pAPData);
    }
    return NO_ERROR;
}

/***************************************************************************\
* LcpBegin
*
\***************************************************************************/

DWORD LcpBegin(VOID)
{
    CopyMemory(&gLcp.Local.Want, &gLcpDefault, sizeof(LCP_OPTIONS));
    CopyMemory(&gLcp.Remote.Want, &gLcpDefault, sizeof(LCP_OPTIONS));

    gLcp.Local.WillNegotiate = gLcpNegotiate;
    gLcp.Remote.WillNegotiate = gLcpNegotiate;

    gLcp.Remote.APsAvailable = LCP_AP_PAP;

    gLcp.Local.Want.MagicNumber = GetMagicNumber();
    gLcp.Remote.Want.MagicNumber = gLcp.Local.Want.MagicNumber + 1;

    gLcp.Local.Want.ACCM = 0;
    gLcp.Local.Want.PFC = TRUE;
    gLcp.Local.Want.ACFC = TRUE;

    gLcp.Remote.Want.ACCM = 0;
    gLcp.Remote.Want.PFC = TRUE;
    gLcp.Remote.Want.ACFC = TRUE;

    gLcp.Local.Want.Negotiate = (LCP_N_MAGIC | LCP_N_ACCM | LCP_N_PFC | LCP_N_ACFC);
    gLcp.Remote.Want.Negotiate = (LCP_N_MAGIC | LCP_N_ACCM | LCP_N_PFC | LCP_N_ACFC);

    CopyMemory(&gLcp.Local.Work, &gLcp.Local.Want, sizeof(LCP_OPTIONS));
    CopyMemory(&gLcp.Remote.Work, &gLcp.Remote.Want, sizeof(LCP_OPTIONS));

    return NO_ERROR;
}

/***************************************************************************\
* GetLcpInfo
*
\***************************************************************************/

VOID GetLcpInfo(PPP_CP_INFO *pInfo)
{
    ZeroMemory(pInfo, sizeof(PPP_CP_INFO));
    pInfo->Protocol = PPP_LCP_PROTOCOL;
    pInfo->Recognize = DISCARD_REQ;
    pInfo->CP_Begin = LcpBegin;
    pInfo->CP_End = LcpEnd;
    pInfo->CP_ThisLayerDown = LcpThisLayerDown;
    pInfo->CP_ThisLayerUp = LcpThisLayerUp;
    pInfo->CP_ConfigNakReceived = LcpConfigNakReceived;
    pInfo->CP_ConfigRejReceived = LcpConfigRejReceived;
    pInfo->CP_ConfigAckReceived = LcpConfigAckReceived;
    pInfo->CP_MakeConfigResult = LcpMakeConfigResult;
    pInfo->CP_MakeConfigRequest = LcpMakeConfigRequest;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\ppp\modem.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

    init.cpp

Abstract:

    XBox PPP initialization routines.

Revision History:

    07-11-00    vadimg      created

--*/

#include "precomp.h"

/***************************************************************************\
* ModemCommand
*
\***************************************************************************/

BOOL ModemCommand(const CHAR *pszCommand, const CHAR *pszResponse)
{
    char buffer[MODEM_BUFFER_SIZE];
    ULONG cb = strlen(pszCommand);

    if (!ModemWrite((PUCHAR)pszCommand, &cb)) {
        return FALSE;
    }

    DbgPrint("WRITE: %s\n", pszCommand);

    if (WaitForSingleObject(gQueue.hEvent, READ_TIMEOUT) != WAIT_OBJECT_0) {
        return FALSE;
    }

    cb = MODEM_BUFFER_SIZE;
    if (!ModemRead((PUCHAR)buffer, &cb) || cb == 0) {
        return FALSE;
    }
    buffer[cb] = '\0';

    DbgPrint("READ: %s\n", buffer);

    if (str_search(buffer, pszResponse) == NULL) {
        return FALSE;
    }

    DbgPrint("RESPONSE: %s\n", pszResponse);
    return TRUE;
}

/***************************************************************************\
* InitModem
*
\***************************************************************************/

BOOL InitModem(VOID)
{
    if (!ModemOpen(gQueue.hEvent)) {
        return FALSE;
    }

    if (!ModemSetLineCoding(57600, 0, 0, 8)) {
        return FALSE;
    }

    if (!ModemCommand("AT &F E0 &C1 &D2 V1 S0=0\r", "OK")) {
        return FALSE;
    }

    if (!ModemCommand("ATS7=60S30=0L0M1\\N3%C1&K3N1X4\r", "OK")) {
        return FALSE;
    }

    return TRUE;
}

/***************************************************************************\
* DialModem
*
\***************************************************************************/

BOOL DialModem(VOID)
{
    char buffer[MODEM_BUFFER_SIZE];
    char *p = buffer;

    p = str_add(p, "ATDT");
    p = str_add(p, gInfo.szNumber);
    str_add(p, "\r");

    return ModemCommand(buffer, "CONNECT");
}

/***************************************************************************\
* HangupModem
*
\***************************************************************************/

BOOL HangupModem(VOID)
{
    return ModemCommand("ATH0\r", "OK");
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\ppp\ncp.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

    ncp.cpp

Abstract:

    Network control protocol and IPCP implementation.

Revision History:

    07-27-00    vadimg      created

--*/

#include "precomp.h"

/***************************************************************************\
* NcpStart
*
\***************************************************************************/

BOOL NcpStart(DWORD CpIndex)
{
    if (!FsmInit(CpIndex)) {
        return FALSE;
    }

    FsmOpen(CpIndex);
    FsmUp(CpIndex);

    return TRUE;
}

/***************************************************************************\
* NcpReset
*
\***************************************************************************/

VOID NcpReset(VOID)
{
    gIp.IpAddrRemote = 0;
    gIp.IpAddrLocal = 0;
    gIp.IpAddrDns = 0;
}

/***************************************************************************\
* AddIpAddressOption
*
\***************************************************************************/

VOID AddIpAddressOption(BYTE *pBuf, BYTE bOption, IPADDR ipaddr)
{
    *pBuf++ = bOption;
    *pBuf++ = IPADDRESSOPTIONLEN;
    *((IPADDR*)pBuf) = ipaddr;
}

/***************************************************************************\
* RejectCheck
*
\***************************************************************************/

DWORD RejectCheck(PPP_CONFIG* pRecvBuf, PPP_CONFIG* pSendBuf, BOOL *pfRej)
{
    PPP_OPTION *pROption = (PPP_OPTION*)pRecvBuf->Data;
    PPP_OPTION *pSOption = (PPP_OPTION*)pSendBuf->Data;
    WORD cbPacket = WireToHostFormat16(pRecvBuf->Length);
    WORD cbLeft = cbPacket - PPP_CONFIG_HDR_LEN;

    *pfRej = FALSE;

    while (cbLeft > 0) {

        if (cbLeft < pROption->Length) {
            return ERROR_PPP_INVALID_PACKET;
        }

        if (pROption->Type == IPCP_IpCompression) {

            *pfRej = TRUE;
            CopyMemory((VOID*)pSOption, (VOID*)pROption, pROption->Length);
            pSOption = (PPP_OPTION*)((BYTE*)pSOption + pROption->Length);

        } else {

            IPADDR ipaddr;

            BOOL fBad = (pROption->Type != IPCP_IpAddress || 
                    pROption->Length != IPADDRESSOPTIONLEN);

            if (!fBad) {
                CopyMemory(&ipaddr, pROption->Data, sizeof(IPADDR));
            }

            if (fBad || ipaddr == 0) {

                *pfRej = TRUE;

                CopyMemory((VOID*)pSOption, (VOID*)pROption, pROption->Length);
                pSOption = (PPP_OPTION*)((BYTE*)pSOption + pROption->Length);

            } else {
                gIp.IpAddrRemote = ipaddr;
            }
        }

        if (pROption->Length && pROption->Length < cbLeft) {
            cbLeft -= pROption->Length;
        } else {
            cbLeft = 0;
        }

        pROption = (PPP_OPTION*)((BYTE*)pROption + pROption->Length);
    }

    if (*pfRej) {
        pSendBuf->Code = CONFIG_REJ;
        HostToWireFormat16((WORD)((BYTE*)pSOption - (BYTE*)pSendBuf), pSendBuf->Length);
    }

    return NO_ERROR;
}

/***************************************************************************\
* IpcpMakeConfigRequest
*
\***************************************************************************/

DWORD IpcpMakeConfigRequest(PPP_CONFIG *pSendConfig, DWORD cbSendConfig)
{
    BYTE *pb = pSendConfig->Data;
    WORD cbPacket = PPP_CONFIG_HDR_LEN;

    AddIpAddressOption(pb, IPCP_IpAddress, gIp.IpAddrLocal);
    cbPacket += IPADDRESSOPTIONLEN;
    pb += IPADDRESSOPTIONLEN;

    AddIpAddressOption(pb, IPCP_DnsIpAddress, gIp.IpAddrDns);
    cbPacket += IPADDRESSOPTIONLEN;
    pb += IPADDRESSOPTIONLEN;

    HostToWireFormat16(cbPacket, pSendConfig->Length);

    return NO_ERROR;
}

/***************************************************************************\
* IpcpMakeConfigResult
*
\***************************************************************************/

DWORD IpcpMakeConfigResult(PPP_CONFIG *pRecvBuf, PPP_CONFIG *pSendBuf,
        DWORD cbSendBuf, BOOL fRejectNaks)
{
    DWORD dwErr;
    BOOL fRej;
    WORD cbPacket;

    dwErr = RejectCheck(pRecvBuf, pSendBuf, &fRej);
    if (dwErr != 0) {
        return dwErr;
    }

    if (fRej) {
        return NO_ERROR;
    }

    cbPacket = WireToHostFormat16(pRecvBuf->Length);
    CopyMemory(pSendBuf, pRecvBuf, cbPacket);
    pSendBuf->Code = CONFIG_ACK;

    return 0;
}

/***************************************************************************\
* IpcpConfigAckReceived
*
\***************************************************************************/

DWORD IpcpConfigAckReceived(PPP_CONFIG *pRecvBuf)
{
    return NO_ERROR;
}

/***************************************************************************\
* IpcpConfigRejReceived
*
\***************************************************************************/

DWORD IpcpConfigRejReceived(PPP_CONFIG *pRecvBuf)
{
    return NO_ERROR;
}

/***************************************************************************\
* IpcpConfigNakReceived
*
\***************************************************************************/

DWORD IpcpConfigNakReceived(PPP_CONFIG* pRecvBuf)
{
    PPP_OPTION *pROption = (PPP_OPTION*)pRecvBuf->Data;
    WORD cbPacket = WireToHostFormat16(pRecvBuf->Length);
    WORD cbLeft = cbPacket - PPP_CONFIG_HDR_LEN;
    IPADDR ipaddr;

    while (cbLeft > 0) {

        if (cbLeft < pROption->Length) {
            return ERROR_PPP_INVALID_PACKET;
        }

        switch (pROption->Type) {
        case IPCP_IpAddress:
            if (pROption->Length != IPADDRESSOPTIONLEN) {
                return ERROR_PPP_INVALID_PACKET;
            }

            CopyMemory(&ipaddr, pROption->Data, sizeof(IPADDR));

            if (ipaddr == 0) {
                return ERROR_PPP_INVALID_PACKET;
            }

            gIp.IpAddrLocal = ipaddr;
            break;

        case IPCP_DnsIpAddress:
            if (pROption->Length != IPADDRESSOPTIONLEN) {
                return ERROR_PPP_INVALID_PACKET;
            }

            CopyMemory(&gIp.IpAddrDns, pROption->Data, sizeof(IPADDR));
            break;
        }

        if (pROption->Length && pROption->Length < cbLeft) {
            cbLeft -= pROption->Length;
        } else {
            cbLeft = 0;
        }

        pROption = (PPP_OPTION*)((BYTE*)pROption + pROption->Length);
    }

    return NO_ERROR;
}

/***************************************************************************\
* IpcpBegin
*
\***************************************************************************/

DWORD IpcpBegin(VOID)
{
    return NO_ERROR;
}

/***************************************************************************\
* IpcpEnd
*
\***************************************************************************/

DWORD IpcpEnd(VOID)
{
    return NO_ERROR;
}

/***************************************************************************\
* GetIpcpInfo
*
\***************************************************************************/

VOID GetIpcpInfo(PPP_CP_INFO *pInfo)
{
    ZeroMemory(pInfo, sizeof(PPP_CP_INFO));
    pInfo->Protocol = PPP_IPCP_PROTOCOL;
    pInfo->Recognize = MAX_IPCP_CODE;
    pInfo->CP_Begin = IpcpBegin;
    pInfo->CP_End = IpcpEnd;
    pInfo->CP_MakeConfigRequest = IpcpMakeConfigRequest;
    pInfo->CP_MakeConfigResult = IpcpMakeConfigResult;
    pInfo->CP_ConfigAckReceived = IpcpConfigAckReceived;
    pInfo->CP_ConfigRejReceived = IpcpConfigRejReceived;
    pInfo->CP_ConfigNakReceived = IpcpConfigNakReceived;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\ppp\init.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

    init.cpp

Abstract:

    XBox PPP initialization routines.

Revision History:

    07-11-00    vadimg      created

--*/

#include "precomp.h"

VOID (*gCpGetInfo[])(PPP_CP_INFO *pInfo) = {
    GetLcpInfo,
    GetPapInfo,
    GetIpcpInfo
};

/***************************************************************************\
* PppConnect
*
\***************************************************************************/

BOOL PppConnect(CHAR *pszUsername, CHAR *pszPassword, CHAR *pszDomain, CHAR *pszNumber)
{
    BOOL fSuccess = FALSE;
    HANDLE hThread = NULL;
    DWORD dwTid;
    ULONG i;
    PBYTE pFrame;
    
    if (strlen(pszUsername) > UNLEN) {
        return FALSE;
    }
    if (strlen(pszPassword) > PWLEN) {
        return FALSE;
    }
    if (strlen(pszDomain) > DNLEN) {
        return FALSE;
    }
    if (strlen(pszNumber) > PNLEN) {
        return FALSE;
    }

    pFrame = (PBYTE)Alloc(PPP_FRAME_MAX_LEN);
    if (pFrame != NULL) {
        gInfo.pFrame = (PPP_FRAME*)pFrame;
        gInfo.pFrame->Address = 0xFF;
        gInfo.pFrame->Control = 0x03;
    } else {
        goto Cleanup;
    }

    for (i = 0; i < NUM_CP; i++) {
        gCpGetInfo[i](&gCpTable[i]);
    }

    gQueue.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (gQueue.hEvent == NULL) {
        goto Cleanup;
    }

    if (!InitModem()) {
        goto Cleanup;
    }

    strcpy(gInfo.szUsername, pszUsername);
    strcpy(gInfo.szPassword, pszPassword);
    strcpy(gInfo.szDomain, pszDomain);
    strcpy(gInfo.szNumber, pszNumber);

    if (!DialModem()) {
        goto Cleanup;
    }

    gFraming.SendAccm = 0xFFFFFFFF;
    gFraming.RecvAccm = 0xFFFFFFFF;

    if (!FsmInit(CP_LCP)) {
        goto Cleanup;
    }

    hThread = CreateThread(NULL, 0, WorkerThread, NULL, 0, &dwTid);
    if (hThread == NULL) {
        goto Cleanup;
    }
    CloseHandle(hThread);

    FsmOpen(CP_LCP);
    FsmUp(CP_LCP);

    fSuccess = TRUE;

Cleanup:

    if (!fSuccess) {

        ModemClose();

        if (gQueue.hEvent != NULL) {
            CloseHandle(gQueue.hEvent);
            gQueue.hEvent = NULL;
        }

        if (gInfo.pFrame != NULL) {
            Free((PBYTE)gInfo.pFrame);
            gInfo.pFrame = NULL;
        }
    }

    return fSuccess;
}

/***************************************************************************\
* DllMain
*
\***************************************************************************/

BOOL WINAPI DllMain(HINSTANCE hinst, DWORD dwReason, LPVOID pvReserved)
{
    switch (dwReason) {
    case DLL_THREAD_DETACH:
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\ppp\ncp.h ===
#ifndef __NCP_H__
#define __NCP_H__

#define MAX_IPCP_CODE 7

#define IPCP_IpCompression          2
#define IPCP_IpAddress              3
#define IPCP_DnsIpAddress           129

#define IPADDRESSOPTIONLEN          6
#define IPCOMPRESSIONOPTIONLEN      6

#endif // __NCP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\ppp\net.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

    net.cpp

Abstract:

    Network stack integration code.

Revision History:

    07-27-00    vadimg      created

--*/

#include "precomp.h"

/***************************************************************************\
* PppDeleteProc
*
\***************************************************************************/

VOID PppDeleteProc(IfInfo *ifp)
{
    while (!PktQIsEmpty(&ifp->sendq)) {
        Packet* pkt = PktQRemoveHead(&ifp->sendq);
        XnetCompletePacket(pkt, NETERR_CANCELLED);
    }
    SysFree(ifp);
}

/***************************************************************************\
* PppStartOutputProc
*
\***************************************************************************/

VOID PppStartOutputProc(IfInfo *ifp)
{
    Packet *pkt;
    PPP_PACKET *pSendPacket = GetSendPacket();

    while (!PktQIsEmpty(&ifp->sendq)) {
        pkt = IfDequeuePacket(ifp);

        pSendPacket->Protocol[0] = 0x00;
        pSendPacket->Protocol[1] = 0x21;

        CopyMemory(pSendPacket->Data, pkt->data, pkt->datalen);

        SendFrame(pkt->datalen + 2);

        XnetCompletePacket(pkt, NO_ERROR);
    }
}

/***************************************************************************\
* PppIoctlProc
*
* Arguments:
*
*   ifp - Points to the interface structure
*   ctlcode - Control code
*   inbuf - Points to the input buffer
*   inlen - Size of the input buffer
*   outbuf - Points to the output buffer
*   outlen - On entry, this contains the size of the output buffer
*       On return, this is the actually number of output bytes
*
\***************************************************************************/

NTSTATUS
PppIoctlProc(
    IfInfo* ifp,
    INT ctlcode,
    VOID* inbuf,
    UINT inlen,
    VOID* outbuf,
    UINT* outlen
    )
{
    NTSTATUS status;

    switch (ctlcode) {
    case IFCTL_GET_DNSSERVERS:
        if (!inbuf || !inlen || !outbuf || !outlen || *outlen < sizeof(IPADDR)) {
            status = NETERR_PARAM;
        } else {
            //
            // NOTE: we're using the inbuf to return the default domain name string.
            // outbuf is used to return the default DNS server addresses.
            //
            *((CHAR*) inbuf) = 0;
            *outlen = sizeof(IPADDR);
            *((IPADDR*) outbuf) = gIp.IpAddrDns;
            status = NETERR_OK;
        }
        break;

    default:
        status = NETERR_NOTIMPL;
        break;
    }

    return status;
}

/***************************************************************************\
* InitNet
*
\***************************************************************************/

BOOL InitNet(VOID)
{
    DbgPrint("PPP: setting IP and DNS\n");

    gIp.ifp = (IfInfo*) SysAlloc0(sizeof(IfInfo), 'PPP0');
    if (gIp.ifp == NULL) {
        return FALSE;
    }

    gIp.ifp->refcount = 1;
    gIp.ifp->ifname = "Dialup";
    gIp.ifp->flags = IFFLAG_UP;
    gIp.ifp->Delete = PppDeleteProc;
    gIp.ifp->StartOutput = PppStartOutputProc;
    gIp.ifp->Ioctl = PppIoctlProc;

    IfSetIpAddr(gIp.ifp, gIp.IpAddrLocal, 0);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\ppp\misc.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

    misc.cpp

Abstract:

    Misc support functions.

Revision History:

    07-17-00    vadimg      created

--*/

#include "precomp.h"

/***************************************************************************\
* InitRestartCounters
*
\***************************************************************************/

VOID InitRestartCounters(VOID)
{
    gInfo.ConfigRetryCount = PPP_MAX_FAILURE;
    gInfo.TermRetryCount   = PPP_MAX_FAILURE;
}

/***************************************************************************\
* GetCpIndexFromProtocol
*
\***************************************************************************/

DWORD GetCpIndexFromProtocol(DWORD dwProtocol)
{
    DWORD i;

    for (i = 0; i < NUM_CP; i++) {
        if (gCpTable[i].Protocol == dwProtocol) {
            return i;
        }
    }

    return (DWORD)-1;
}

/***************************************************************************\
* ReverseString
*
\***************************************************************************/

VOID ReverseString(CHAR *psz)
{
    CHAR *pchBegin, *pchEnd, ch;

    pchBegin = psz;
    pchEnd = psz + strlen(psz) - 1;

    while (pchBegin < pchEnd) {

        ch = *pchBegin;
        *pchBegin = *pchEnd;
        *pchEnd = ch;

        ++pchBegin;
        --pchEnd;
    }
}

/***************************************************************************\
* EncodePw
*
\***************************************************************************/

#define PASSWORDMAGIC 0xA5

VOID EncodePw(CHAR* pszPassword)
{
    CHAR *pch;

    ReverseString(pszPassword);

    for (pch = pszPassword; *pch != '\0'; ++pch) {
        if (*pch != (CHAR)PASSWORDMAGIC) {
            *pch ^= PASSWORDMAGIC;
        }
    }
}

/***************************************************************************\
* DecodePw
*
\***************************************************************************/

VOID DecodePw(CHAR* pszPassword)
{
    EncodePw(pszPassword);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\ppp\precomp.h ===
#include <xnetp.h>

extern "C" {
#include <lmcons.h>
#include <xmodem.h>
#include <xppp.h>
}

#include "ppp.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\ppp\pap.h ===
#ifndef __PAP_H__
#define __PAP_H__

// PAP packet codes from PAP spec.
#define PAPCODE_Req 1
#define PAPCODE_Ack 2
#define PAPCODE_Nak 3

#define MAX_PAP_CODE  3

typedef enum _PAP_STATE {
    PS_Initial,
    PS_RequestSent,
    PS_WaitForRequest,
    PS_WaitForAuthenticationToComplete,
    PS_Done
} PAP_STATE;

#endif // __PAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\ppp\receive.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

    receive.cpp

Abstract:

    Handle received packets.

Revision History:

    07-18-00    vadimg      created

--*/

#include "precomp.h"

VOID (*gReceive[])(DWORD CpIndex, PPP_CONFIG *pRecvConfig) = {
        NULL,
        ReceiveConfigReq,
        ReceiveConfigAck,
        ReceiveConfigNakRej,
        ReceiveConfigNakRej,
        ReceiveTermReq,
        ReceiveTermAck,
        ReceiveCodeRej,
        NULL,
        ReceiveEchoReq,
        ReceiveEchoReply,
        ReceiveDiscardReq
};

/***************************************************************************\
* ReceiveConfigReq
*
\***************************************************************************/

VOID ReceiveConfigReq(DWORD CpIndex, PPP_CONFIG *pRecvConfig)
{
    PPP_PACKET *pSendPacket = GetSendPacket();
    PPP_CONFIG *pSendConfig = (PPP_CONFIG*)pSendPacket->Data;
    BOOL fAcked;

    switch (gInfo.State) {
    case FSM_OPENED:            
        if (!FsmThisLayerDown(CpIndex)) {
            return;
        }
        if (!FsmSendConfigReq(CpIndex)) {
            return;
        }
        if (!FsmSendConfigResult(CpIndex, pRecvConfig, &fAcked)) {
            return;
        }

        gInfo.State = fAcked ? FSM_ACK_SENT : FSM_REQ_SENT;
        break;

    case FSM_STOPPED:

        InitRestartCounters();

        if (!FsmSendConfigReq(CpIndex)) {
            return;
        }

        // fall through

    case FSM_REQ_SENT:
    case FSM_ACK_SENT:          
        if (!FsmSendConfigResult(CpIndex, pRecvConfig, &fAcked)) {
            return;
        }

        gInfo.State = fAcked ? FSM_ACK_SENT : FSM_REQ_SENT;
        break;

    case FSM_ACK_RCVD:
        if (!FsmSendConfigResult(CpIndex, pRecvConfig, &fAcked)) {
            return;
        }

        if (fAcked) {
            gInfo.State = FSM_OPENED;
            FsmThisLayerUp(CpIndex);
        }
        break;

    case FSM_CLOSED:
        FsmSendTermAck(CpIndex, pRecvConfig);
        break;

    case FSM_CLOSING:
    case FSM_STOPPING:
        break;
    }
}

/***************************************************************************\
* ReceiveConfigAck
*
\***************************************************************************/

VOID ReceiveConfigAck(DWORD CpIndex, PPP_CONFIG *pRecvConfig)
{
    // The Id of the Ack HAS to match the Id of the last request sent
    // If it is different, then we should silently discard it.
    if (pRecvConfig->Id != gInfo.LastId) {
        return;
    }

    ClearTimeout();

    switch (gInfo.State) {
    case FSM_REQ_SENT:
        if (!FsmConfigResultReceived(CpIndex, pRecvConfig)) {
            return;
        }

        InitRestartCounters();
        gInfo.State = FSM_ACK_RCVD;
        break;

    case FSM_ACK_SENT:
        if (!FsmConfigResultReceived(CpIndex, pRecvConfig)) {
            return;
        }

        InitRestartCounters();
        gInfo.State = FSM_OPENED;
        FsmThisLayerUp(CpIndex);
        break;

    case FSM_OPENED:            
        if (!FsmThisLayerDown(CpIndex)) {
            return;
        }

        // fall through

    case FSM_ACK_RCVD:  
        if (!FsmSendConfigReq(CpIndex)) {
            return;
        }

        gInfo.State = FSM_REQ_SENT;
        break;

    case FSM_CLOSED:
    case FSM_STOPPED:
        // Out of Sync; kill the remote 
        FsmSendTermAck(CpIndex, pRecvConfig);
        break;

    case FSM_CLOSING:
    case FSM_STOPPING:
        break;
    }
}

/***************************************************************************\
* ReceiveConfigNakRej
*
\***************************************************************************/

VOID ReceiveConfigNakRej(DWORD CpIndex, PPP_CONFIG *pRecvConfig)
{
    // The Id of the Nak/Rej HAS to match the Id of the last request sent
    // If it is different, then we should silently discard it.
    if (pRecvConfig->Id != gInfo.LastId) {
        return;
    }

    ClearTimeout();

    switch (gInfo.State) {
    case FSM_REQ_SENT:
    case FSM_ACK_SENT:
        if (!FsmConfigResultReceived(CpIndex, pRecvConfig)) {
            return;
        }

        InitRestartCounters();

        if (!FsmSendConfigReq(CpIndex)) {
            return;
        }
        break;

    case FSM_OPENED:            
        if (!FsmThisLayerDown(CpIndex)) {
            return;
        }

        // fall through

    case FSM_ACK_RCVD:          
        if (!FsmSendConfigReq(CpIndex)) {
            return;
        }

        gInfo.State = FSM_REQ_SENT;
        break;

    case FSM_CLOSED:
    case FSM_STOPPED:
        // Out of Sync; kill the remote 
        FsmSendTermAck(CpIndex, pRecvConfig);
        break;

    case FSM_CLOSING:
    case FSM_STOPPING:
        break;
    }
}

/***************************************************************************\
* ReceiveTermReq
*
\***************************************************************************/

VOID ReceiveTermReq(DWORD CpIndex, PPP_CONFIG *pConfig)
{
    switch (gInfo.State) {
    case FSM_OPENED:
        if (!FsmThisLayerDown(CpIndex)) {
            return;
        }

        FsmSendTermAck(CpIndex, pConfig);
        gInfo.State = FSM_STOPPING;
        break;

    case FSM_ACK_RCVD:
    case FSM_ACK_SENT:
    case FSM_REQ_SENT:
        FsmSendTermAck(CpIndex, pConfig);
        gInfo.State = FSM_REQ_SENT;
        break;

    case FSM_CLOSED:
    case FSM_CLOSING:
    case FSM_STOPPED:
    case FSM_STOPPING:
        FsmSendTermAck(CpIndex, pConfig);
        break;
    }

    FsmThisLayerFinished(CpIndex);
}

/***************************************************************************\
* ReceiveTermAck
*
\***************************************************************************/

VOID ReceiveTermAck(DWORD CpIndex, PPP_CONFIG *pRecvConfig)
{
    // The Id of the Term Ack HAS to match the Id of the last request sent
    // If it is different, then we should silently discard it.
    if (pRecvConfig->Id != gInfo.LastId) {
        return;
    }

    switch (gInfo.State) {
    case FSM_OPENED:
        if (!FsmThisLayerDown(CpIndex)) {
            return;
        }

        if (!FsmSendConfigReq(CpIndex)) {
            return;
        }

        gInfo.State = FSM_REQ_SENT;
        break;

    case FSM_ACK_RCVD:
        gInfo.State = FSM_REQ_SENT;
        break;

    case FSM_CLOSING:
    case FSM_STOPPING:
        if (!FsmThisLayerFinished(CpIndex)) {
            return;
        }

        gInfo.State = (gInfo.State == FSM_CLOSING) ? FSM_CLOSED : FSM_STOPPED;
        break;

    case FSM_REQ_SENT:
    case FSM_ACK_SENT:
    case FSM_CLOSED:
    case FSM_STOPPED:
        break;
    }
}

/***************************************************************************\
* ReceiveUnknownCode 
*
\***************************************************************************/

VOID ReceiveUnknownCode(DWORD CpIndex, PPP_CONFIG *pConfig)
{
    switch (gInfo.State) {
    case FSM_STOPPED:
    case FSM_STOPPING:
    case FSM_OPENED:
    case FSM_ACK_SENT:
    case FSM_ACK_RCVD:
    case FSM_REQ_SENT:
    case FSM_CLOSING:
    case FSM_CLOSED:
        FsmSendCodeReject(CpIndex, pConfig);
        break;
    }
}

/***************************************************************************\
* ReceiveDiscardReq
*
\***************************************************************************/

VOID ReceiveDiscardReq(DWORD CpIndex, PPP_CONFIG *pConfig)
{
}

/***************************************************************************\
* ReceiveEchoReq
*
\***************************************************************************/

VOID ReceiveEchoReq(DWORD CpIndex, PPP_CONFIG *pConfig)
{
    // Silently discard this packet if LCP is not in an opened state
    if (!IsLcpOpened()) {
        return;
    }

    switch (gInfo.State) {
    case FSM_STOPPED:
    case FSM_STOPPING:
    case FSM_ACK_SENT:
    case FSM_ACK_RCVD:
    case FSM_REQ_SENT:
    case FSM_CLOSING:
    case FSM_CLOSED:
    case FSM_STARTING:
    case FSM_INITIAL:
        break;

    case FSM_OPENED:
        FsmSendEchoReply(CpIndex, pConfig);
        break;
    }
}

/***************************************************************************\
* ReceiveEchoReply
*
\***************************************************************************/

VOID ReceiveEchoReply(DWORD CpIndex, PPP_CONFIG *pConfig)
{
}

/***************************************************************************\
* ReceiveCodeRej
*
\***************************************************************************/

VOID ReceiveCodeRej(DWORD CpIndex, PPP_CONFIG *pConfig)
{
    pConfig = (PPP_CONFIG*)pConfig->Data;

    // First check to see if these codes may be rejected without 
    // affecting implementation. Permitted code rejects
    if (CpIndex == CP_LCP) {
        switch (pConfig->Code) {
        case CONFIG_REQ:
        case CONFIG_ACK:
        case CONFIG_NAK:
        case CONFIG_REJ:
        case TERM_REQ:
        case TERM_ACK:
        case CODE_REJ:
        case PROT_REJ:
        case ECHO_REQ:
        case ECHO_REPLY:
        case DISCARD_REQ:
            // Unpermitted code rejects.
            break;

        default:
            // Permitted code rejects, we can still work.
            switch (gInfo.State) {
            case FSM_ACK_RCVD:
                gInfo.State = FSM_REQ_SENT;
                break;
            }

            return;
        }
    }
    // Actually the remote side did not reject the protocol, it rejected
    // the code. But for all practical purposes we cannot talk with
    // the corresponding CP on the remote side. This is actually an
    // implementation error in the remote side.
    gInfo.dwError = ERROR_PPP_NOT_CONVERGING;

    switch (gInfo.State) {
    case FSM_CLOSING:
        if (!FsmThisLayerFinished(CpIndex)) {
            return;
        }
        gInfo.State = FSM_CLOSED;
        break;

    case FSM_REQ_SENT:
    case FSM_ACK_RCVD:
    case FSM_ACK_SENT:
    case FSM_STOPPING:
        if (!FsmThisLayerFinished(CpIndex)) {
            return;
        }
        gInfo.State = FSM_STOPPED;
        break;

    case FSM_OPENED:
        if (!FsmThisLayerDown(CpIndex)) {
            return;
        }

        InitRestartCounters();
        FsmSendTermReq(CpIndex);
        gInfo.State = FSM_STOPPING;
        break;

    case FSM_CLOSED:
    case FSM_STOPPED:
        break;
    }
}

/***************************************************************************\
* ReceiveProtocolRej
*
\***************************************************************************/

VOID ReceiveProtocolRej(PPP_PACKET *pPacket)
{
    PPP_CONFIG *pRecvConfig = (PPP_CONFIG*)pPacket->Data;
    DWORD dwProtocol  = WireToHostFormat16(pRecvConfig->Data);
    DWORD CpIndex;

    CpIndex = GetCpIndexFromProtocol(dwProtocol);

    if (CpIndex == (DWORD)-1) {
        return;
    }

    if (CpIndex == CP_LCP) {
        gInfo.dwError = ERROR_PPP_NOT_CONVERGING;
        return;
    }

    // If LCP is not in the opened state we silently discard this packet 
    if (!IsLcpOpened()) {
        return;
    }

    gInfo.dwError = ERROR_PPP_CP_REJECTED;

    switch (gInfo.State) {
    case FSM_CLOSING:
        if (!FsmThisLayerFinished(CpIndex)) {
            return;
        }

        gInfo.State = FSM_CLOSED;
        break;

    case FSM_REQ_SENT:
    case FSM_ACK_RCVD:
    case FSM_ACK_SENT:
    case FSM_STOPPING:
        if (!FsmThisLayerFinished(CpIndex)) {
            return;
        }

        gInfo.State = FSM_STOPPED;
        break;

    case FSM_OPENED:
        if (!FsmThisLayerDown(CpIndex)) {
            return;
        }

        InitRestartCounters();
        FsmSendTermReq(CpIndex);
        gInfo.State = FSM_STOPPING;
        break;

    case FSM_CLOSED:
    case FSM_STOPPED:
        break;
    }
}

/***************************************************************************\
* FsmConfigResultReceived
*
\***************************************************************************/

BOOL FsmConfigResultReceived(DWORD CpIndex, PPP_CONFIG *pRecvConfig)
{
    DWORD dwRetCode; 

    switch (pRecvConfig->Code) {
    case CONFIG_NAK:
        dwRetCode = gCpTable[CpIndex].CP_ConfigNakReceived(pRecvConfig);
        break;

    case CONFIG_ACK:
        dwRetCode = gCpTable[CpIndex].CP_ConfigAckReceived(pRecvConfig);
        break;

    case CONFIG_REJ:
        dwRetCode = gCpTable[CpIndex].CP_ConfigRejReceived(pRecvConfig);
        break;

    default:
        return FALSE;
    }

    if (dwRetCode != NO_ERROR) {
        if (dwRetCode == ERROR_PPP_INVALID_PACKET) {
            return TRUE;
        } else {
            FsmClose(CpIndex);
            return FALSE;
        }
    }

    return TRUE;
}

/***************************************************************************\
* FsmReceive
*
\***************************************************************************/

VOID FsmReceive(PPP_PACKET *pPacket, DWORD dwPacketLength)
{
    DWORD dwProtocol;
    DWORD CpIndex;
    PPP_CONFIG *pRecvConfig;
    DWORD dwLength;
    BOOL fAuth = FALSE;
    
    // Validate length of packet
    if (dwPacketLength < (PPP_PACKET_HDR_LEN + PPP_CONFIG_HDR_LEN)) {
        return;
    }

    dwProtocol = WireToHostFormat16(pPacket->Protocol);
    CpIndex = GetCpIndexFromProtocol(dwProtocol);
    if (CpIndex == (DWORD)-1) {
        DbgPrint("Unknown protocol in PPP packet\n");
        return;
    }

    switch (gInfo.Phase) {
    case PPP_AP:
        if (CpIndex == GetCpIndexFromProtocol(gLcp.Remote.Work.AP)) {
            fAuth = TRUE;
            break;
        }

        // fall through

    case PPP_LCP:
        if (CpIndex == CP_LCP) {
            break;
        }

        return;
    }

    pRecvConfig = (PPP_CONFIG*)pPacket->Data;

    dwLength = WireToHostFormat16(pRecvConfig->Length);

    if (dwLength > (dwPacketLength - PPP_PACKET_HDR_LEN) || 
            (dwLength < PPP_CONFIG_HDR_LEN)) {
        return;
    }

    // Not in ProcessPacket table since parameters to this are different.
    if (CpIndex == CP_LCP && pRecvConfig->Code == PROT_REJ) {
        ReceiveProtocolRej(pPacket);
        return;
    }

    // Make sure that the protocol can handle the config code sent.
    if (pRecvConfig->Code == 0 || 
            pRecvConfig->Code > gCpTable[CpIndex].Recognize) {
        ReceiveUnknownCode(CpIndex, pRecvConfig);
        return;
    }

    if (fAuth) {
        ApWork(CpIndex, pRecvConfig);
    } else {
        gReceive[pRecvConfig->Code](CpIndex, pRecvConfig);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\ppp\smaction.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

    smaction.cpp

Abstract:

    Handle actions that occur during state transitions.

Revision History:

    07-14-00    vadimg      created

--*/

#include "precomp.h"

/***************************************************************************\
* FsmSendConfigReq
*
\***************************************************************************/

BOOL FsmSendConfigReq(DWORD CpIndex)
{
    DWORD dwRetCode;
    PPP_PACKET *pSendPacket = GetSendPacket();
    PPP_CONFIG *pSendConfig = (PPP_CONFIG*)pSendPacket->Data;
    DWORD dwLength;

    dwRetCode = (gCpTable[CpIndex].CP_MakeConfigRequest)(pSendConfig,
            LCP_DEFAULT_MRU - PPP_PACKET_HDR_LEN);

    if (dwRetCode != NO_ERROR) {
        gInfo.dwError = dwRetCode;
        FsmClose(CpIndex);
        return FALSE;
    }

    HostToWireFormat16((WORD)gCpTable[CpIndex].Protocol,
            (PBYTE)pSendPacket->Protocol);

    pSendConfig->Code = CONFIG_REQ;

    //
    // If we are resending a configure request because of a timeout, we do not
    // use the id of the previous configure request, instead we get a new Id.
    // Id we do not, then the wrong Config-Req's and Config-Acks may be matched
    // up and we start getting crossed connections.
    //

    pSendConfig->Id = GetId();

    dwLength = WireToHostFormat16(pSendConfig->Length);

    SendFrame(dwLength + PPP_PACKET_HDR_LEN);

    gInfo.LastId = pSendConfig->Id;

    SetTimeout();

    return TRUE;
}

/***************************************************************************\
* FsmSendTermReq
*
\***************************************************************************/

BOOL FsmSendTermReq(DWORD CpIndex)
{
    PPP_PACKET *pSendPacket = GetSendPacket();
    PPP_CONFIG *pSendConfig = (PPP_CONFIG*)pSendPacket->Data;

    HostToWireFormat16((WORD)gCpTable[CpIndex].Protocol,
                    (PBYTE)pSendPacket->Protocol);

    pSendConfig->Code = TERM_REQ;
    pSendConfig->Id = GetId();

    HostToWireFormat16((WORD)((PPP_CONFIG_HDR_LEN)+(sizeof(DWORD)*3)),
            (PBYTE)pSendConfig->Length);

    HostToWireFormat32(gLcp.Local.Work.MagicNumber, (PBYTE)pSendConfig->Data);
    HostToWireFormat32(777, (PBYTE)(pSendConfig->Data+4));
    HostToWireFormat32(gInfo.dwError, (PBYTE)(pSendConfig->Data+8));

    SendFrame(PPP_PACKET_HDR_LEN + PPP_CONFIG_HDR_LEN + sizeof(DWORD) * 3);

    gInfo.LastId = pSendConfig->Id;
    return TRUE;
}

/***************************************************************************\
* FsmSendTermAck
*
\***************************************************************************/

BOOL FsmSendTermAck(DWORD CpIndex, PPP_CONFIG *pRecvConfig)
{
    PPP_PACKET *pSendPacket = GetSendPacket();
    PPP_CONFIG *pSendConfig = (PPP_CONFIG*)pSendPacket->Data;
    DWORD dwLength;

    dwLength = PPP_PACKET_HDR_LEN + WireToHostFormat16(pRecvConfig->Length);
    if (dwLength > LCP_DEFAULT_MRU) {
        dwLength = LCP_DEFAULT_MRU;
    }

    HostToWireFormat16((WORD)gCpTable[CpIndex].Protocol,
            (PBYTE)pSendPacket->Protocol);

    pSendConfig->Code = TERM_ACK;
    pSendConfig->Id = pRecvConfig->Id;

    HostToWireFormat16((WORD)(dwLength - PPP_PACKET_HDR_LEN),
            (PBYTE)pSendConfig->Length);

    CopyMemory(pSendConfig->Data, pRecvConfig->Data,
            dwLength - PPP_CONFIG_HDR_LEN - PPP_PACKET_HDR_LEN);

    SendFrame(dwLength);

    return TRUE;
}

/***************************************************************************\
* FsmSendConfigResult
*
\***************************************************************************/

BOOL FsmSendConfigResult(DWORD CpIndex, PPP_CONFIG *pRecvConfig, BOOL *pfAcked)
{
    PPP_PACKET *pSendPacket = GetSendPacket();
    PPP_CONFIG *pSendConfig = (PPP_CONFIG*)pSendPacket->Data;
    DWORD dwLength;
    DWORD dwRetCode;

    *pfAcked = FALSE;

    ZeroMemory(pSendConfig, 30);

    pSendConfig->Id = pRecvConfig->Id;

    dwRetCode = (gCpTable[CpIndex].CP_MakeConfigResult)(pRecvConfig, pSendConfig,
            LCP_DEFAULT_MRU - PPP_PACKET_HDR_LEN, (gInfo.NakRetryCount == 0));

    if (dwRetCode == ERROR_PPP_INVALID_PACKET) {

        return FALSE;

    } else if (dwRetCode != NO_ERROR) {

        gInfo.dwError = dwRetCode;
        FsmClose(CpIndex);
        return FALSE;
    }

    switch (pSendConfig->Code) {
    case CONFIG_ACK:
        *pfAcked = TRUE;
        break;

    case CONFIG_NAK:
        if (gInfo.NakRetryCount > 0) {
            gInfo.NakRetryCount--;
        } else {

            gInfo.dwError = ERROR_PPP_NOT_CONVERGING;
            FsmClose(CP_LCP);
            return FALSE;
        }
        break;

    case CONFIG_REJ:
        if (gInfo.RejRetryCount > 0) {
            gInfo.RejRetryCount--;
        } else {
    
            gInfo.dwError = ERROR_PPP_NOT_CONVERGING;
            FsmClose(CP_LCP);
            return FALSE;
        }
        break;
    }

    HostToWireFormat16((WORD)gCpTable[CpIndex].Protocol,
            (PBYTE)pSendPacket->Protocol);

    pSendConfig->Id = pRecvConfig->Id;
    dwLength = WireToHostFormat16(pSendConfig->Length);

    SendFrame(dwLength + PPP_PACKET_HDR_LEN);

    return TRUE;
}

/***************************************************************************\
* FsmSendEchoReply
*
\***************************************************************************/

BOOL FsmSendEchoReply(DWORD CpIndex, PPP_CONFIG *pRecvConfig)
{
    PPP_PACKET *pSendPacket = GetSendPacket();
    PPP_CONFIG *pSendConfig = (PPP_CONFIG*)pSendPacket->Data;
    DWORD dwLength;

    dwLength =  PPP_PACKET_HDR_LEN + WireToHostFormat16(pRecvConfig->Length);
    if (dwLength > LCP_DEFAULT_MRU) {
        dwLength = LCP_DEFAULT_MRU;
    }

    if (dwLength < PPP_PACKET_HDR_LEN + PPP_CONFIG_HDR_LEN + 4) {
        return FALSE;
    }

    HostToWireFormat16((WORD)gCpTable[CpIndex].Protocol,
            (PBYTE)pSendPacket->Protocol);

    pSendConfig->Code = ECHO_REPLY;
    pSendConfig->Id = pRecvConfig->Id;

    HostToWireFormat16((WORD)(dwLength - PPP_PACKET_HDR_LEN),
            (PBYTE)pSendConfig->Length);

    HostToWireFormat32(gLcp.Local.Work.MagicNumber, (PBYTE)pSendConfig->Data);

    CopyMemory(pSendConfig->Data + 4, pRecvConfig->Data + 4,
            dwLength - PPP_CONFIG_HDR_LEN - PPP_PACKET_HDR_LEN - 4);

    SendFrame(dwLength);

    return TRUE;
}

/***************************************************************************\
* FsmSendCodeReject
*
\***************************************************************************/

BOOL FsmSendCodeReject(DWORD CpIndex, PPP_CONFIG *pRecvConfig)
{
    PPP_PACKET *pSendPacket = GetSendPacket();
    PPP_CONFIG *pSendConfig = (PPP_CONFIG*)pSendPacket->Data;
    DWORD dwLength;
        
    dwLength = PPP_PACKET_HDR_LEN + PPP_CONFIG_HDR_LEN +
            WireToHostFormat16(pRecvConfig->Length);

    if (dwLength > LCP_DEFAULT_MRU) {
        dwLength = LCP_DEFAULT_MRU;
    }

    HostToWireFormat16((WORD)gCpTable[CpIndex].Protocol,
            (PBYTE)pSendPacket->Protocol);

    pSendConfig->Code = CODE_REJ;
    pSendConfig->Id = GetId();

    HostToWireFormat16((WORD)(dwLength - PPP_PACKET_HDR_LEN),
            (PBYTE)pSendConfig->Length);

    CopyMemory( pSendConfig->Data,
                pRecvConfig,
                dwLength - PPP_CONFIG_HDR_LEN - PPP_PACKET_HDR_LEN );

    SendFrame(dwLength);

    return TRUE;
}

/***************************************************************************\
* FsmSendProtocolRej
*
\***************************************************************************/

BOOL FsmSendProtocolRej(PPP_PACKET *pPacket, DWORD dwPacketLength)
{
    PPP_PACKET *pSendPacket = GetSendPacket();
    PPP_CONFIG *pSendConfig = (PPP_CONFIG*)pSendPacket->Data;
    PPP_CONFIG *pRecvConfig = (PPP_CONFIG*)pPacket->Data;
    DWORD dwLength;

    // If LCP isn't in the opened state we can't send a protocol reject packet
    if (!IsLcpOpened()) {
        return ERROR_UNKNOWN;
    }

    dwLength = PPP_PACKET_HDR_LEN + PPP_CONFIG_HDR_LEN + dwPacketLength;

    if (dwLength > LCP_DEFAULT_MRU) {
        dwLength = LCP_DEFAULT_MRU;
    }

    HostToWireFormat16((WORD)gCpTable[CP_LCP].Protocol,
            (PBYTE)pSendPacket->Protocol);

    pSendConfig->Code = PROT_REJ;
    pSendConfig->Id = GetId();

    HostToWireFormat16((WORD)(dwLength - PPP_PACKET_HDR_LEN),
            (PBYTE)pSendConfig->Length);

    CopyMemory(pSendConfig->Data, pPacket,
                dwLength - PPP_CONFIG_HDR_LEN - PPP_PACKET_HDR_LEN);

    SendFrame(dwLength);

    return TRUE;
}

/***************************************************************************\
* FsmInit
*
\***************************************************************************/

BOOL FsmInit(DWORD CpIndex)
{
    DWORD dwRetCode;

    gInfo.dwError = NO_ERROR;
    gInfo.State = FSM_INITIAL;

    if (!FsmReset(CpIndex)) {
        return FALSE;
    }

    dwRetCode = gCpTable[CpIndex].CP_Begin();
    if (dwRetCode != NO_ERROR) {
        gInfo.dwError = dwRetCode;
        return FALSE;
    }

    return TRUE;
}

/***************************************************************************\
* FsmReset
*
\***************************************************************************/

BOOL FsmReset(DWORD CpIndex)
{
    InitRestartCounters();

    gInfo.NakRetryCount = PPP_MAX_FAILURE;
    gInfo.RejRetryCount = PPP_MAX_FAILURE;

    gInfo.LastId = 0;
    return TRUE;
}

/***************************************************************************\
* FsmThisLayerUp
*
\***************************************************************************/

BOOL FsmThisLayerUp(DWORD CpIndex)
{
    DWORD dwRetCode;

    DbgPrint("LcpThisLayerUp %4X\n", gCpTable[CpIndex].Protocol);

    if (gCpTable[CpIndex].CP_ThisLayerUp != NULL) {

        dwRetCode = gCpTable[CpIndex].CP_ThisLayerUp();
        if (dwRetCode != NO_ERROR) {
            gInfo.dwError = dwRetCode;
            FsmClose(CpIndex);
            return FALSE;
        }
    }

    switch (gInfo.Phase) {
    case PPP_LCP:
        gInfo.Phase = PPP_AP;
        CpIndex = GetCpIndexFromProtocol(gLcp.Remote.Work.AP);
        ApStart(CpIndex);
        break;

    case PPP_AP:
        gInfo.Phase = PPP_NCP;
        CpIndex = CP_IPCP;
        NcpStart(CpIndex);
        break;

    case PPP_NCP:
        InitNet();
        break;
    }

    return TRUE;
}

/***************************************************************************\
* FsmThisLayerDown
*
\***************************************************************************/

BOOL FsmThisLayerDown(DWORD CpIndex)
{
    DWORD dwRetCode;

    DbgPrint("LcpThisLayerDown %4X\n", gCpTable[CpIndex].Protocol);

    if (gCpTable[CpIndex].CP_ThisLayerDown != NULL) {
        dwRetCode = gCpTable[CpIndex].CP_ThisLayerDown();
        if (dwRetCode != NO_ERROR) {
            gInfo.dwError = dwRetCode;
            FsmClose(CpIndex);
            return FALSE;
        }
    }

    if (CpIndex == CP_LCP) {
        // bring down all NCPs
        // bring down AP
    }
    return TRUE;
}

/***************************************************************************\
* FsmThisLayerStarted
*
\***************************************************************************/

BOOL FsmThisLayerStarted(DWORD CpIndex)
{
    DWORD dwRetCode;

    if (gCpTable[CpIndex].CP_ThisLayerStarted != NULL) {
        dwRetCode = gCpTable[CpIndex].CP_ThisLayerStarted();
        if (dwRetCode != NO_ERROR) {
            gInfo.dwError = dwRetCode;
            FsmClose(CpIndex);
            return FALSE;
        }
    }
    return TRUE;
}

/***************************************************************************\
* FsmThisLayerFinished
*
\***************************************************************************/

BOOL FsmThisLayerFinished(DWORD CpIndex)
{
    DWORD dwRetCode;

    if (gCpTable[CpIndex].CP_ThisLayerFinished != NULL) {
        dwRetCode = gCpTable[CpIndex].CP_ThisLayerFinished();
        if (dwRetCode != NO_ERROR) {
            gInfo.dwError = dwRetCode;
            return FALSE;
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\ppp\string.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

    string.cpp

Abstract:

    String functions, so we don't need to include msvcrt.

Revision History:

    07-11-00    vadimg      created

--*/

#include "precomp.h"

char* str_search(const char *str1, const char *str2)
{
    char *cp = (char*)str1;
    char *s1, *s2;

    while (*cp) {
        s1 = cp;
        s2 = (char*)str2;

        while (*s1 && *s2 && !(*s1-*s2)) {
            s1++, s2++;
        }

        if (!*s2) {
            return cp;
        }

        cp++;
    }

    return NULL;
}

char* str_add(char *s1, const char *s2)
{
    while (*s2) {
        *s1 = *s2;
        s1++, s2++;
    }

    *s1 = '\0';

    return s1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\ppp\smevents.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

    smevents.cpp

Abstract:

    Handle event processing for the state machine.

Revision History:

    07-17-00    vadimg      created

--*/

#include "precomp.h"

/***************************************************************************\
* FsmUp
*
\***************************************************************************/

VOID FsmUp(DWORD CpIndex)
{
    if (CpIndex == CP_LCP) {
        gInfo.Phase = PPP_LCP;
    }

    switch (gInfo.State) {
    case FSM_INITIAL:
        gInfo.State = FSM_CLOSED;
        break;

    case FSM_STARTING:
        InitRestartCounters();

        if (!FsmSendConfigReq(CpIndex)) {
            return;
        }

        gInfo.State = FSM_REQ_SENT;
        break;
    }
}

/***************************************************************************\
* FsmOpen
*
\***************************************************************************/

VOID FsmOpen(DWORD CpIndex)
{
    switch (gInfo.State) {
    case FSM_INITIAL:
        if (!FsmThisLayerStarted(CpIndex)) {
            return;
        }

        gInfo.State = FSM_STARTING;
        break;

    case FSM_STARTING:
    case FSM_REQ_SENT:
    case FSM_ACK_RCVD:
    case FSM_ACK_SENT:
        break;

    case FSM_CLOSING:
        gInfo.State = FSM_STOPPING;
        break;

    case FSM_OPENED:
    case FSM_STOPPED:
    case FSM_STOPPING:
        break;

    case FSM_CLOSED:
        InitRestartCounters();

        if (!FsmSendConfigReq(CpIndex)) {
            return;
        }

        gInfo.State = FSM_REQ_SENT;
        break;
    }
}

/***************************************************************************\
* FsmDown
*
\***************************************************************************/

VOID FsmDown(DWORD CpIndex)
{
    switch (gInfo.State) {
    case FSM_CLOSED:
    case FSM_CLOSING:
        gInfo.State = FSM_INITIAL;
        break;

    case FSM_OPENED:

        if (!FsmThisLayerDown(CpIndex)) {
            return;
        }

        // fall through

    case FSM_REQ_SENT:
    case FSM_ACK_RCVD:
    case FSM_ACK_SENT:
    case FSM_STOPPING:
        if (!FsmReset(CpIndex)) {
            return;
        }

        gInfo.State = FSM_STARTING;
        break;

    case FSM_STOPPED:

        if (!FsmThisLayerStarted(CpIndex)) {
            return;
        }

        if (!FsmReset(CpIndex)) {
            return;
        }

        gInfo.State = FSM_STARTING;
        break;

    }

    if (CpIndex == CP_LCP) {
        gInfo.Phase = PPP_LCP;
    }
}

/***************************************************************************\
* FsmClose
*
\***************************************************************************/

VOID FsmClose(DWORD CpIndex)
{
    if (CpIndex == CP_LCP) {
        gInfo.Phase = PPP_LCP;
    }

    switch (gInfo.State) {
    case FSM_STARTING:
        gInfo.State = FSM_INITIAL;

        if (!FsmThisLayerFinished(CpIndex)) {
            return;
        }
        break;

    case FSM_STOPPED:
        gInfo.State = FSM_CLOSED;

        if (!FsmThisLayerFinished(CpIndex)) {
            return;
        }
        break;

    case FSM_STOPPING:
        gInfo.State = FSM_CLOSING;

        if (!FsmThisLayerFinished(CpIndex)) {
            return;
        }
        break;

    case FSM_REQ_SENT:
    case FSM_OPENED:
        if (!FsmThisLayerDown(CpIndex)) {
            return;
        }

        // fall through

    case FSM_ACK_RCVD:
    case FSM_ACK_SENT:
        gInfo.State = FSM_CLOSING;
        InitRestartCounters();
        FsmSendTermReq(CpIndex);
        break;

    case FSM_CLOSING:
    case FSM_CLOSED:
    case FSM_INITIAL:
        FsmThisLayerFinished(CpIndex);
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\ppp\pap.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

    pap.cpp

Abstract:

    Password authentication protocol.

Revision History:

    07-26-00    vadimg      created

--*/

#include "precomp.h"

/***************************************************************************\
* PapBegin
*
\***************************************************************************/

DWORD PapBegin(VOID)
{
    gAp.State = PS_Initial;
    return NO_ERROR;
}

/***************************************************************************\
* PapEnd
*
\***************************************************************************/

DWORD PapEnd(VOID)
{
    return NO_ERROR;
}

/***************************************************************************\
* PapMakeRequestMessage
*
\***************************************************************************/

VOID PapMakeRequestMessage(PPP_CONFIG *pSendBuf)
{
    BYTE *pcbPeerId;
    BYTE *pcbPassword;
    WORD wLength;
    CHAR szAccount[DNLEN + 1 + UNLEN + 1];
    char *p = szAccount;

    if (gInfo.szDomain[0] != '\0') {
        p = str_add(p, gInfo.szDomain);
        p = str_add(p, "\\");
    }
    str_add(p, gInfo.szUsername);

    pcbPeerId = pSendBuf->Data;
    *pcbPeerId = (BYTE)strlen(szAccount);
    strcpy((char*)(pcbPeerId + 1), szAccount);

    pcbPassword = pcbPeerId + 1 + *pcbPeerId;
    *pcbPassword = (BYTE)strlen(gInfo.szPassword);
    strcpy((char*)(pcbPassword + 1), gInfo.szPassword);

    pSendBuf->Code = (BYTE)PAPCODE_Req;
    pSendBuf->Id = GetId();

    wLength = (WORD)(PPP_CONFIG_HDR_LEN + 1 + *pcbPeerId + 1 + *pcbPassword);
    HostToWireFormat16(wLength, pSendBuf->Length);
}

/***************************************************************************\
* PapMakeMessage
*
\***************************************************************************/

DWORD PapMakeMessage(PPP_CONFIG *pRecvBuf)
{
    PPP_PACKET *pSendPacket = GetSendPacket();
    PPP_CONFIG *pSendConfig = (PPP_CONFIG*)pSendPacket->Data;

    if (pRecvBuf == NULL && gAp.State != PS_Initial) {
        gAp.State = PS_Initial;
    }

    switch (gAp.State) {
    case PS_Initial:
        PapMakeRequestMessage(pSendConfig);
        gAp.Action = AP_SendWithTimeout;
        gAp.State = PS_RequestSent;
        break;

    case PS_RequestSent:
        if (pRecvBuf->Code == PAPCODE_Ack) {
            gInfo.dwError = 0;
            gAp.Action = AP_Done;
            gAp.State = PS_Done;
        } else if (pRecvBuf->Code == PAPCODE_Nak) {
            gInfo.dwError = ERROR_AUTHENTICATION_FAILURE;
            gAp.Action = AP_Done;
            gAp.State = PS_Done;
        } else {
            gAp.Action = AP_NoAction;
        }
    }

    return NO_ERROR;
}

/***************************************************************************\
* GetPapInfo
*
\***************************************************************************/

VOID GetPapInfo(PPP_CP_INFO *pInfo)
{
    ZeroMemory(pInfo, sizeof(PPP_CP_INFO));
    pInfo->Protocol = PPP_PAP_PROTOCOL;
    pInfo->Recognize = MAX_PAP_CODE;
    pInfo->CP_Begin = PapBegin;
    pInfo->CP_End = PapEnd;
    pInfo->CP_MakeMessage = PapMakeMessage;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\ppp\ppp.h ===
#ifndef __PPP_H__
#define __PPP_H__

#include "lcp.h"
#include "pap.h"
#include "ncp.h"

typedef DWORD IPADDR;

/*
 * DEFINES
 */
#define PPP_FLAG_BYTE           0x7E
#define PPP_ESC_BYTE            0x7D

#define READ_TIMEOUT (3 * 60 * 1000)

// Maximum length used for the phone number
#define PNLEN                   56

// these constants are used as indecies into the PPP_CP_INFO array
#define CP_LCP                  0
#define CP_PAP                  1
#define CP_IPCP                 2
#define NUM_CP                  3

#define PPP_MAX_FAILURE         5

// Add 4 bytes for protocol (1), control (1), and CRC (2)
#define PPP_FRAME_MAX_LEN (LCP_DEFAULT_MRU + 4)

/*
 * Framing options
 */
#define PPP_MULTILINK_FRAMING           0x00000010
#define PPP_SHORT_SEQUENCE_HDR_FORMAT   0x00000020
#define PPP_MC_MULTILINK_FRAMING        0x00000040
#define PPP_FRAMING                     0x00000100
#define PPP_COMPRESS_ADDRESS_CONTROL    0x00000200
#define PPP_COMPRESS_PROTOCOL_FIELD     0x00000400
#define PPP_ACCM_SUPPORTED              0x00000800

// Various control protocol IDs
#define PPP_LCP_PROTOCOL        0xC021  // Link Control Protocol 
#define PPP_PAP_PROTOCOL        0xC023  // Password Authentication Protocol 
#define PPP_CBCP_PROTOCOL       0xC029  // Callback Control Protocol
#define PPP_BACP_PROTOCOL       0xC02B  // Bandwidth Allocation Control Protocol
#define PPP_BAP_PROTOCOL        0xC02D  // Bandwidth Allocation Protocol
#define PPP_CHAP_PROTOCOL       0xC223  // Challenge Handshake Auth. Protocol
#define PPP_IPCP_PROTOCOL       0x8021  // Internet Protocol Control Protocol 
#define PPP_ATCP_PROTOCOL       0x8029  // Appletalk Control Protocol 
#define PPP_IPXCP_PROTOCOL      0x802B  // Novel IPX Control Procotol 
#define PPP_NBFCP_PROTOCOL      0x803F  // NetBIOS Framing Control Protocol 
#define PPP_CCP_PROTOCOL        0x80FD  // Compression Control Protocol
#define PPP_SPAP_NEW_PROTOCOL   0xC027  // Shiva PAP new protocol
#define PPP_EAP_PROTOCOL        0xC227  // Extensible Authentication Protocol

// CHAP Digest codes
#define PPP_CHAP_DIGEST_MD5        0x05 // PPP standard MD5
#define PPP_CHAP_DIGEST_MSEXT      0x80 // Microsoft extended CHAP (nonstandard)
#define PPP_CHAP_DIGEST_MSEXT_NEW  0x81 // Microsoft extended CHAP (nonstandard)

// Config Codes
#define CONFIG_REQ              1
#define CONFIG_ACK              2
#define CONFIG_NAK              3
#define CONFIG_REJ              4
#define TERM_REQ                5
#define TERM_ACK                6
#define CODE_REJ                7
#define PROT_REJ                8
#define ECHO_REQ                9
#define ECHO_REPLY              10
#define DISCARD_REQ             11
#define IDENTIFICATION          12
#define TIME_REMAINING          13

typedef enum _PPP_PHASE {
    PPP_LCP,
    PPP_AP,
    PPP_NCP
} PPP_PHASE;

typedef enum _FSM_STATE {
    FSM_INITIAL,
    FSM_STARTING,
    FSM_CLOSED,
    FSM_STOPPED,
    FSM_CLOSING,
    FSM_STOPPING,
    FSM_REQ_SENT,
    FSM_ACK_RCVD,
    FSM_ACK_SENT,
    FSM_OPENED
} FSM_STATE;

typedef enum _AP_ACTION {

    AP_NoAction,        // Be passive, i.e. listen without timeout (default)
    AP_Done,            // End authentication session, dwError gives result
    AP_SendAndDone,     // As above but send message without timeout first
    AP_Send,            // Send message, don't timeout waiting for reply
    AP_SendWithTimeout, // Send message, timeout if reply not received
    AP_SendWithTimeout2,// As above, but don't increment retry count
    AP_Authenticate     // Authenticate using specified credentials.

} AP_ACTION;

/*
 * STRUCTURES
 */
typedef struct _PPP_FRAME {
    BYTE Address;
    BYTE Control;
    BYTE Data[1];
} PPP_FRAME;

#define PPP_FRAME_HDR_LEN (sizeof(PPP_FRAME) - 1)

typedef struct _PPP_PACKET {
    BYTE Protocol[2];   // Protocol Number
    BYTE Data[1];       // Data
} PPP_PACKET;

#define PPP_PACKET_HDR_LEN (sizeof(PPP_PACKET) - 1)

typedef struct _PPP_CONFIG {
    BYTE Code;          // Config code
    BYTE Id;            // ID of this config packet
    BYTE Length[2];     // Length of this packet
    BYTE Data[1];       // Data
} PPP_CONFIG;

#define PPP_CONFIG_HDR_LEN (sizeof(PPP_CONFIG) - 1)

typedef struct _PPP_OPTION {
    BYTE Type;          // Option Code
    BYTE Length;		// Length of this option packet
    BYTE Data[1];       // Data
} PPP_OPTION;

#define PPP_OPTION_HDR_LEN (sizeof(PPP_OPTION) - 1)

typedef struct _PPP_RECEIVED PPP_RECEIVED;
typedef struct _PPP_RECEIVED {

    PPP_RECEIVED *pNext;
    PPP_RECEIVED *pPrev;

    DWORD iCrc;
    DWORD cb;

    Packet *pkt;

} PPP_RECEIVED;

typedef struct _PPP_CP_INFO {
    
    // Protocol number for this CP
    DWORD Protocol;

    // Recognize options up to this number.
    DWORD Recognize;

    // Initialize all work values.
    DWORD (*CP_Begin)(VOID);

    // Free any allocated data.
    DWORD (*CP_End)(VOID);

    // When leaving Initial or Stopped states. May be NULL.
    DWORD (*CP_ThisLayerStarted)(VOID);

    // When entering Closed or Stopped states. May be NULL
    DWORD (*CP_ThisLayerFinished)(VOID);

    // When entering the Opened state. May be NULL. 
    DWORD (*CP_ThisLayerUp)(VOID);

    // When leaving the Opened state. May be NULL. 
    DWORD (*CP_ThisLayerDown)(VOID);
 
    // Called to make a configure request.
    DWORD (*CP_MakeConfigRequest)(PPP_CONFIG *pRequestBuf, DWORD cbRequestBuf);

    // Called when configure request is received and a result packet 
    // Ack/Nak/Reject needs to be sent
    DWORD (*CP_MakeConfigResult)(PPP_CONFIG *pReceiveBuf, PPP_CONFIG *pResultBuf,
            DWORD cbResultBuf, BOOL fRejectNaks);

    // Called to process an Ack that was received.
    DWORD (*CP_ConfigAckReceived)(PPP_CONFIG *pReceiveBuf);

    // Called to process a Nak that was received.
    DWORD (*CP_ConfigNakReceived)(PPP_CONFIG *pReceiveBuf);

    // Called to process a Rej that was received.
    DWORD (*CP_ConfigRejReceived)(PPP_CONFIG *pReceiveBuf);

    DWORD (*CP_MakeMessage)(PPP_CONFIG *pReceiveBuf);

} PPP_CP_INFO;

typedef struct _AP_INFO {
    AP_ACTION Action;
    PAP_STATE State;
} AP_INFO;

typedef struct _PPP_INFO {
    CHAR szUsername[UNLEN + 1];
    CHAR szPassword[PWLEN + 1];
    CHAR szDomain[DNLEN + 1];
    CHAR szNumber[PNLEN + 1];
    
    PPP_PHASE Phase;
    FSM_STATE State;
    DWORD dwError;

    BYTE Id;
    BYTE LastId;

    DWORD NakRetryCount;
    DWORD RejRetryCount;

    DWORD ConfigRetryCount;
    DWORD TermRetryCount;

    PPP_FRAME *pFrame;

} PPP_INFO;

typedef struct _READ_QUEUE {

    HANDLE hEvent;

    DWORD nHdr;
    DWORD nCrc;
    DWORD nOk;

    PPP_RECEIVED *pReceived;
    PPP_RECEIVED *pReceivedFirst;
    PPP_RECEIVED *pReceivedLast;

} READ_QUEUE;

typedef struct _PPP_TIMER {
    DWORD Expire;
    DWORD Timeout;
} PPP_TIMER;

typedef struct _FRAMING_INFO {
    DWORD SendAccm;
    DWORD RecvAccm;

    UINT fSendPfc : 1;
    UINT fSendAcfc : 1;
    UINT fRecvPfc : 1;
    UINT fRecvAcfc : 1;
} FRAMING_INFO;

typedef struct _IP_INFO {
    IfInfo *ifp;
    IPADDR IpAddrRemote;
    IPADDR IpAddrLocal;
    IPADDR IpAddrDns;
} IP_INFO;

// auth.cpp
BOOL ApStart(DWORD CpIndex);
VOID ApReset(VOID);
VOID ApWork(DWORD CpIndex, PPP_CONFIG *pRecvConfig);

// pap.cpp
VOID GetPapInfo(PPP_CP_INFO *pInfo);

// lcp.cpp
VOID GetLcpInfo(PPP_CP_INFO *pInfo);

// worker.cpp
DWORD WorkerThread(LPVOID pThreadParameter);
BOOL SendFrame(DWORD dwLength);
VOID SetTimeout(VOID);
VOID ClearTimeout(VOID);

// hostwire.cpp
VOID HostToWireFormat16(WORD wHostFormat, PBYTE pWireFormat);
VOID HostToWireFormat32(DWORD dwHostFormat, PBYTE pWireFormat);
WORD WireToHostFormat16(PBYTE pWireFormat);
DWORD WireToHostFormat32(PBYTE pWireFormat);

// string.cpp
char* str_search(const char *str1, const char *str2);
char* str_add(char *s1, const char *s2);

// modem.cpp
BOOL InitModem(VOID);
BOOL DialModem(VOID);
BOOL HangupModem(VOID);

// misc.cpp
VOID InitRestartCounters(VOID);
DWORD GetCpIndexFromProtocol(DWORD dwProtocol);
VOID EncodePw(CHAR* pszPassword);
VOID DecodePw(CHAR* pszPassword);

// smaction.cpp
BOOL FsmSendConfigReq(DWORD CpIndex);
BOOL FsmSendTermReq(DWORD CpIndex);
BOOL FsmSendTermAck(DWORD CpIndex, PPP_CONFIG *pRecvConfig);
BOOL FsmSendConfigResult(DWORD CpIndex, PPP_CONFIG *pRecvConfig, BOOL *pfAcked);
BOOL FsmSendEchoReply(DWORD CpIndex, PPP_CONFIG *pRecvConfig);
BOOL FsmSendCodeReject(DWORD CpIndex, PPP_CONFIG *pRecvConfig);
BOOL FsmSendProtocolRej(PPP_PACKET *pPacket, DWORD dwPacketLength);
BOOL FsmInit(DWORD CpIndex);
BOOL FsmReset(DWORD CpIndex);
BOOL FsmThisLayerUp(DWORD CpIndex);
BOOL FsmThisLayerDown(DWORD CpIndex);
BOOL FsmThisLayerStarted(DWORD CpIndex);
BOOL FsmThisLayerFinished(DWORD CpIndex);

/// smevents.cpp
VOID FsmUp(DWORD CpIndex);
VOID FsmOpen(DWORD CpIndex);
VOID FsmDown(DWORD CpIndex);
VOID FsmClose(DWORD CpIndex);

// ncp.cpp
VOID GetIpcpInfo(PPP_CP_INFO *pInfo);
BOOL NcpStart(DWORD CpIndex);
VOID NcpReset(VOID);

// net.cpp
BOOL InitNet(VOID);

// receive.cpp
VOID ReceiveConfigReq(DWORD CpIndex, PPP_CONFIG *pRecvConfig);
VOID ReceiveConfigAck(DWORD CpIndex, PPP_CONFIG *pRecvConfig);
VOID ReceiveConfigNakRej(DWORD CpIndex, PPP_CONFIG *pRecvConfig);
VOID ReceiveTermReq(DWORD CpIndex, PPP_CONFIG *pConfig);
VOID ReceiveTermAck(DWORD CpIndex, PPP_CONFIG *pRecvConfig);
VOID ReceiveUnknownCode(DWORD CpIndex, PPP_CONFIG *pConfig);
VOID ReceiveDiscardReq(DWORD CpIndex, PPP_CONFIG *pConfig);
VOID ReceiveEchoReq(DWORD CpIndex, PPP_CONFIG *pConfig);
VOID ReceiveEchoReply(DWORD CpIndex, PPP_CONFIG *pConfig);
VOID ReceiveCodeRej(DWORD CpIndex, PPP_CONFIG *pConfig);
VOID ReceiveProtocolRej(PPP_PACKET *pPacket);
VOID FsmReceive(PPP_PACKET *pPacket, DWORD dwPacketLength);
BOOL FsmConfigResultReceived(DWORD CpIndex, PPP_CONFIG *pRecvConfig);

// frame.cpp
VOID DecodeFrame(PBYTE pIn, DWORD *pcb);
VOID EncodeFrame(PBYTE pIn, PBYTE pOut, DWORD *pcb);
BOOL CheckCrc(PBYTE pb, DWORD cb);

/*
 * GLOBALS
 */
extern PPP_INFO gInfo;
extern PPP_CP_INFO gCpTable[NUM_CP];
extern LCP_INFO gLcp;
extern READ_QUEUE gQueue;
extern PPP_TIMER gTimer;
extern FRAMING_INFO gFraming;
extern AP_INFO gAp;
extern IP_INFO gIp;

/*
 * INLINES
 */

// Allocate from the process heap
inline PVOID Alloc(SIZE_T size)
{
    return (PVOID)LocalAlloc(LPTR, size);
}

// Free to the process heap
inline VOID Free(PVOID p)
{
    LocalFree((HLOCAL)p);
}

inline BYTE GetId(VOID)
{
    return ++gInfo.Id;
}

inline BOOL IsLcpOpened(VOID)
{
    return (gInfo.Phase == PPP_LCP);
}

inline PPP_PACKET* GetSendPacket(VOID)
{
    return (PPP_PACKET*)(gInfo.pFrame->Data);
}

inline DWORD GetMagicNumber(VOID)
{
    DWORD dwMagic = XnetRand();
    if (dwMagic == 0) {
        dwMagic = 29;
    }
    return dwMagic;
}

#endif // __PPP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\ppp\worker.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

    worker.cpp

Abstract:

    PPP worker thread.

Revision History:

    07-11-00    vadimg      created

--*/

#include "precomp.h"

/***************************************************************************\
* TimerProc
*
\***************************************************************************/

VOID TimerProc(VOID)
{
    if (gInfo.Phase != PPP_LCP && gInfo.Phase != PPP_NCP) {
        return;
    }

    switch (gInfo.State) {
    case FSM_REQ_SENT:
    case FSM_ACK_RCVD:
    case FSM_ACK_SENT:
        FsmSendConfigReq(gInfo.Phase);

        if (gInfo.State != FSM_ACK_SENT) {
            gInfo.State = FSM_REQ_SENT;
        }
        break;
    }
}

/***************************************************************************\
* SetTimeout
*
\***************************************************************************/

VOID SetTimeout(VOID)
{
    gTimer.Timeout = 4000;
    gTimer.Expire = GetTickCount() + gTimer.Timeout;
}

/***************************************************************************\
* ClearTimeout
*
\***************************************************************************/

VOID ClearTimeout(VOID)
{
    gTimer.Timeout = 0;
}

/***************************************************************************\
* ProcessTimer
*
\***************************************************************************/

VOID ProcessTimer(VOID)
{
    if (gTimer.Timeout == 0) {
        return;
    }

    if (GetTickCount() >= gTimer.Expire) {
        TimerProc();

        gTimer.Expire = GetTickCount() + gTimer.Timeout;
    }
}

/***************************************************************************\
* DumpFrame
*
\***************************************************************************/

VOID DumpFrame(PBYTE pBuffer, DWORD cb)
{
    DWORD i;

    for (i = 0; i < cb; i++) {

        if ((i % 16) == 0) {
            DbgPrint("\n");
        }

        DbgPrint("%02x ", pBuffer[i]);
    }

    DbgPrint("\n\n");
}

/***************************************************************************\
* SendFrame
*
\***************************************************************************/

BOOL SendFrame(DWORD dwLength)
{
    DWORD cb, i = 0;
    BYTE frame[PPP_FRAME_MAX_LEN];
    
    dwLength += 2;

    DbgPrint("s:");
    DumpFrame((PBYTE)gInfo.pFrame, dwLength);

    EncodeFrame((PBYTE)gInfo.pFrame, frame, &dwLength);

    while (dwLength > 0) {

        cb = min(dwLength, MODEM_BUFFER_SIZE);
        if (!ModemWrite(&frame[i], &cb)) {
            return FALSE;
        }

        dwLength -= cb;
        i += cb;
    }

    return TRUE;
}

/***************************************************************************\
* UnlinkReceived
*
\***************************************************************************/

VOID UnlinkReceived(PPP_RECEIVED *p)
{
    if (gQueue.pReceivedFirst == p && gQueue.pReceivedLast == p) {
        gQueue.pReceivedFirst = NULL;
        gQueue.pReceivedLast = NULL;
    } else if (gQueue.pReceivedFirst == p) {
        gQueue.pReceivedFirst = p->pNext;
        gQueue.pReceivedFirst->pPrev = NULL;
    } else if (gQueue.pReceivedLast == p) {
        gQueue.pReceivedLast = p->pPrev;
        gQueue.pReceivedLast->pNext = NULL;
    } else {
        p->pPrev->pNext = p->pNext;
        p->pNext->pPrev = p->pPrev;
    }
}

/***************************************************************************\
* LinkReceived
*
\***************************************************************************/

VOID LinkReceived(PPP_RECEIVED *p)
{
    if (gQueue.pReceivedFirst == NULL) {
        gQueue.pReceivedFirst = p;
        gQueue.pReceivedLast = p;
    } else {
        p->pPrev = gQueue.pReceivedLast;
        gQueue.pReceivedLast->pNext = p;
        gQueue.pReceivedLast = p;
    }
}

/***************************************************************************\
* DumpReceived
*
\***************************************************************************/

VOID ProcessReceived(VOID)
{
    PPP_RECEIVED *pNext;
    PPP_RECEIVED *p = gQueue.pReceivedFirst;
    PPP_PACKET *pPacket;
    DWORD dwProtocol;

    while (p != NULL) {

        DbgPrint("r:");
        DumpFrame(p->pkt->buf, p->cb);

        pPacket = (PPP_PACKET*)((PPP_FRAME*)p->pkt->buf)->Data;
        dwProtocol = WireToHostFormat16(pPacket->Protocol);

        if (dwProtocol == (PPP_IPCP_PROTOCOL - 0x8000)) {
            KIRQL irql = KeRaiseIrqlToDpcLevel();
            IpReceivePacket(p->pkt);
            KeLowerIrql(irql);
        } else {
            FsmReceive(pPacket, p->cb - PPP_FRAME_HDR_LEN);
            XnetFreePacket(p->pkt);
        }

        pNext = p->pNext;

        UnlinkReceived(p);
        Free(p);

        p = pNext;
    }
}

/***************************************************************************\
* AddFrameData
*
\***************************************************************************/

VOID AddFrameData(PBYTE frame, DWORD cb, BOOL fComplete)
{
    PPP_RECEIVED *p;
    DWORD i, iFrame;
    DWORD iCopy, iCrc;

    p = gQueue.pReceived;
    if (p != NULL) {

        // add to the end of this frame
        if (frame != NULL) {
            for (i = 0, iFrame = p->cb; i < cb; i++, iFrame++) {
                p->pkt->buf[iFrame] = frame[i];
            }
            p->cb = p->cb + cb;
        }
    } else if (frame != NULL) {

        DecodeFrame(frame, &cb);

        if (cb < 4) {
            gQueue.nHdr++;
            return;
        }

        // handle address and control field compression
        if (frame[0] == 0xFF && frame[1] == 0x03) {
            iCopy = 2;
            iCrc = 0;
        } else if (gFraming.fRecvAcfc) {
            iCopy = 0;
            iCrc = 2;
        } else {
            gQueue.nHdr++;
            return;
        }

        // allocate new frame
        PPP_RECEIVED *p = (PPP_RECEIVED*)Alloc(sizeof(PPP_RECEIVED));
        if (p == NULL) {
            DbgPrint("AddFrameData: out of memory\n");
            return;
        }
        p->pkt = XnetAllocPacket(PPP_FRAME_MAX_LEN, 0);
        if (p->pkt == NULL) {
            DbgPrint("AddFrameData: out of memory\n");
            Free(p);
            return;
        }

        p->pkt->recvifp = gIp.ifp;
        p->pkt->data = &p->pkt->buf[4];
        p->pkt->datalen = p->cb - 6; // 4 (hdr) + 2 (crc)
        p->pkt->buf[0] = 0xFF;
        p->pkt->buf[1] = 0x03;

        // handle protocol field compression
        if (frame[iCopy] & 0x01) {
            if (gFraming.fRecvPfc) {
                p->pkt->buf[2] = 0x00;
                iCrc += 1;
            } else {
                XnetFreePacket(p->pkt);
                Free(p);
                gQueue.nHdr++;
                return;
            }
        } else {
            p->pkt->buf[2] = frame[iCopy];
            iCopy += 1;
        }

        CopyMemory(&p->pkt->buf[3], &frame[iCopy], cb - iCopy);
        p->iCrc = iCrc;
        p->cb = cb;

        gQueue.pReceived = p;
    }

    if (p != NULL && fComplete) {
        if (CheckCrc(&p->pkt->buf[p->iCrc], p->cb)) {
            gQueue.nOk++;
            p->cb += p->iCrc;
            LinkReceived(p);
        } else {
            gQueue.nCrc++;
            XnetFreePacket(p->pkt);
            Free(p);
        }
        gQueue.pReceived = NULL;
    }
}

/***************************************************************************\
* ReadModemData
*
\***************************************************************************/

VOID ReadModemData(VOID)
{
    BYTE buffer[MODEM_BUFFER_SIZE + 1];
    DWORD cbBuffer, iBuffer;
    BYTE frame[PPP_FRAME_MAX_LEN];
    DWORD iFrame;

    iFrame = 0;

    while (TRUE) {

        iBuffer = 0;
        cbBuffer = MODEM_BUFFER_SIZE;
        if (!ModemRead((PUCHAR)buffer, &cbBuffer) || cbBuffer == 0) {

            if (iFrame > 0) {
                AddFrameData(frame, iFrame, FALSE);
            }

            return;
        }

        buffer[cbBuffer] = '\0';
        if (str_search((const char*)buffer, "NO CARRIER") != NULL) {
            AddFrameData(NULL, 0, TRUE);
            DbgPrint("%d ok, %d hdr, %d crc\n", gQueue.nOk, gQueue.nHdr, gQueue.nCrc);
            return;
        }

        while (iBuffer < cbBuffer) {

            if (buffer[iBuffer] == PPP_FLAG_BYTE) {

                if (iFrame == 0) {
                    AddFrameData(NULL, 0, TRUE);
                } else {
                    AddFrameData(frame, iFrame, TRUE);
                    iFrame = 0;
                }

            } else {
                frame[iFrame++] = buffer[iBuffer];
            }

            iBuffer++;
        }

        Sleep(5);
    }
}

/***************************************************************************\
* WorkerThread
*
\***************************************************************************/

DWORD WorkerThread(LPVOID pThreadParameter)
{
    DWORD dwWait;

    while (TRUE) {
        
        dwWait = WaitForSingleObject(gQueue.hEvent, 1000);

        if (dwWait == WAIT_OBJECT_0) {
            ReadModemData();
            ProcessReceived();
        }

        ProcessTimer();
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\tcp\tcpconn.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    tcpconn.c

Abstract:

    TCP connection management functions

Revision History:

    06/05/2000 davidx
        Created it.

--*/

#include "precomp.h"


//
// Maximum segment lifetime (30 seconds)
//
UINT cfgMSL = 30 * SLOW_TCP_TIMER_FREQ;

//
// Timeout period for active connection requests
// NOTE: Non-standard behavior!!!
//  Our connection timeout value of 20sec is much shorter
//  than the usual value of 75sec.
//
UINT cfgConnectTimeout = 20 * SLOW_TCP_TIMER_FREQ;

//
// Maximum backlogs for a listening socket
//
INT cfgMaxListenBacklog = 5;

//
// Default linger time when a connection is gracefully closed (2 minutes)
//
USHORT cfgDefaultLingerTime = 2*60;

//
// Default retransmission timeout (3 seconds)
//
UINT cfgDefaultRTO = 3*SLOW_TCP_TIMER_FREQ;

//
// List of TCP connections that has been reset but not yet closed
//
LIST_ENTRY DeadTcbList;


VOID
TcbInit(
    TCB* tcb
    )

/*++

Routine Description:

    Initialize a TCP control block

Arguments:

    tcb - Points to a newly allocated TCB structure

Return Value:

    NONE

Note:

    We assume all fields have been zero-initialized
    when this function is called.

--*/

{
    InitializeListHead(&tcb->listenq);
    tcb->linger.l_linger = cfgDefaultLingerTime;

    tcb->snd_mss = tcb->rcv_mss = TCP_DEFAULT_MSS;
    tcb->snd_cwnd = tcb->snd_ssthresh = MAX_TCP_WNDSIZE;
    tcb->srtt_8 = 0;
    tcb->rttvar_4 = tcb->RTO = cfgDefaultRTO;

    tcb->sendbufNext = TcbSendbufNil(tcb);
}


//
// Disassociate a child socket (i.e. pending connection
// request for a listening socket) from its parent
//
PRIVATE VOID TcbDisassociateChild(TCB* childTcb)
{
    RemoveEntryList(&childTcb->listenq);
    InitializeListHead(&childTcb->listenq);
    childTcb->parent->backlog--;
    childTcb->parent = NULL;
}


//
// Trim the backlog of pending connection requests
//
INLINE VOID TcbTrimConnReqBacklog(TCB* tcb, UINT maxBacklog) {
    while (tcb->backlog > maxBacklog) {
        TCB* childTcb = CONTAINING_RECORD(tcb->listenq.Blink, TCB, listenq);
        TcbDisassociateChild(childTcb);
        TcbDelete(childTcb);
    }
}


BOOL
TcbClose(
    TCB* tcb,
    BOOL forceful
    )

/*++

Routine Description:

    Close a TCP connection

Arguments:

    tcb - Points to the TCB structure
    forceful - Forceful close, always succeed and no wait

Return Value:

    TRUE if the TCB structure can be deleted immediately.
    FALSE if the connection is being gracefully closed
    and the TCB structure should be kept around until
    the connection is really closed.

--*/

{
    NTSTATUS status;

    //
    // Try to gracefully close the socket if requested by the caller
    //
    if (!forceful && (tcb->tcpstate >= TCPST_SYN_RECEIVED) &&
        (!tcb->linger.l_onoff || tcb->linger.l_linger > 0)) {
        status = TcbShutdown(tcb, PCBFLAG_BOTH_SHUTDOWN, FALSE);
        if (NT_SUCCESS(status)) {
            UINT linger = tcb->linger.l_onoff ?
                            tcb->linger.l_linger :
                            cfgDefaultLingerTime;

            // TIME-WAIT and linger timers are the same
            TcbSetTimeWaitTimer(tcb, linger * SLOW_TCP_TIMER_FREQ);
            return FALSE;
        }
    }

    if (tcb->parent) {
        // This was a pending connection request
        // for a listening socket.
        TcbDisassociateChild(tcb);
    } else {
        // Clear all pending connection requests
        TcbTrimConnReqBacklog(tcb, 0);
    }

    return TRUE;
}


NTSTATUS
TcbShutdown(
    TCB* tcb,
    BYTE flags,
    BOOL apicall
    )

/*++

Routine Description:

    Gracefully shutdown a TCP connection

Arguments:

    tcb - Points to the TCP control block
    flags - Shutdown flags: PCBFLAG_SEND_SHUTDOWN and/or PCBFLAG_RECV_SHUTDOWN
    apicall - Whether this is called by shutdown API

Return Value:

    Status code

--*/

{
    NTSTATUS status = NETERR_OK;
    KIRQL irql = RaiseToDpc();

    if ((flags & PCBFLAG_RECV_SHUTDOWN) && !IsPcbRecvShutdown(tcb)) {
        tcb->flags |= PCBFLAG_RECV_SHUTDOWN;
        if (!IsTcpRecvBufEmpty(tcb)) {
            //
            // If the receive buffer is not empty,
            // we'll send a RST to the connection peer
            // and reset the connection.
            //
            TcbResetPeer(tcb);
            status = apicall ? NETERR_OK : NETERR_CONNRESET;
            tcb = TcbReset(tcb, NETERR_CONNRESET);
            ASSERT(tcb != NULL);
        } else {
            // Cancel any pending overlapped receive requests
            PcbClearOverlappedRecvs(tcb, NETERR(WSAESHUTDOWN));
        }
    }

    if ((flags & PCBFLAG_SEND_SHUTDOWN) && !IsPcbSendShutdown(tcb)) {
        // Cancel any pending overlapped send requests
        PcbClearOverlappedSends(tcb, NETERR(WSAESHUTDOWN));

        switch (tcb->tcpstate) {
        case TCPST_SYN_RECEIVED:
        case TCPST_ESTABLISHED:
            status = TcbEmitFIN(tcb);
            if (NT_SUCCESS(status)) {
                TcbSetState(tcb, TCPST_FIN_WAIT_1, "Shutdown");
                tcb->flags |= PCBFLAG_SEND_SHUTDOWN;
            }
            break;

        case TCPST_CLOSE_WAIT:
            status = TcbEmitFIN(tcb);
            if (NT_SUCCESS(status)) {
                TcbSetState(tcb, TCPST_LAST_ACK, "Shutdown");
                tcb->flags |= PCBFLAG_SEND_SHUTDOWN;
            }
            break;

        default:
            ASSERT(tcb->tcpstate < TCPST_SYN_RECEIVED);
            status = NETERR(WSAENOTCONN);
            break;
        }
    }

    flags &= ~PCBFLAG_REVIVABLE;
    LowerFromDpc(irql);
    return status;
}


TCB*
TcbReset(
    TCB* tcb,
    NTSTATUS status
    )

/*++

Routine Description:

    Reset a TCP connection

Arguments:

    tcb - Points to the TCP control block
    status - Specifies the cause of the reset

Return Value:

    NULL if the specified TCB was deleted inside this call.
    Otherwise, just return the input tcb parameter.

--*/

{
    BOOL revivable;

    ASSERT(!IsTcpIdleState(tcb));
    
    if (IsPendingConnReqTcb(tcb) || TcbIsLingering(tcb)) {
        TcbDelete(tcb);
        return NULL;
    }

    // Remove the TCB from the active list
    // and move it to the zombie list.

    ASSERT(!IsListNull(&tcb->links));
    RemoveEntryList(&tcb->links);
    InsertHeadList(&DeadTcbList, &tcb->links);

    tcb->errStatus = (status != NETERR_CONNRESET || IsTcpSyncState(tcb)) ?
                            status :
                            NETERR(WSAECONNREFUSED);

    revivable = !IsTcpSyncState(tcb) &&
                (tcb->flags & PCBFLAG_BOTH_SHUTDOWN) == 0;

    tcb->flags |= PCBFLAG_BOTH_SHUTDOWN;
    TcbSetState(tcb, TCPST_CLOSED, "Reset");

    // Stop various timers
    // NOTE: This is a little hacky - we're clearing all the fields
    // from delayedAcks to rtt_tick in one shot. Be careful when you
    // add or remove fields from the TCB structure.

    ZeroMem(
        &tcb->delayedAcks,
        offsetof(TCB, rtt_tick) + sizeof(tcb->rtt_tick) - offsetof(TCB, delayedAcks));

    TcbInit(tcb);

    PcbSignalEvent(tcb, PCBEVENT_ALL);
    PcbCleanup((PCB*) tcb, revivable);
    return tcb;
}


TCB*
TcbCloneChild(
    TCB* tcb
    )

/*++

Routine Description:

    Add a pending connection request to a listening socket

Arguments:

    tcb - Points to the listening socket

Return Value:

    Pointer to the child socket
    NULL if there is an error

--*/

{
    TCB* childTcb;

    // Fail if the backlog is full
    ASSERT(tcb->tcpstate == TCPST_LISTEN);
    if (tcb->backlog >= tcb->maxBacklog)
        return NULL;
    
    // Allocate memory for the child socket
    childTcb = (TCB*) PcbCreate(SOCK_STREAM, IPPROTOCOL_TCP, PCBFLAG_NETPOOL);
    if (!childTcb) return NULL;

    // Associate the child socket with its parent
    childTcb->parent = tcb;
    tcb->backlog++;
    InsertTailList(&tcb->listenq, &childTcb->listenq);

    // Copy the local address bindings
    childTcb->flags |= PCBFLAG_BOUND;
    childTcb->bindSrcAddr = tcb->bindSrcAddr;
    childTcb->srcaddr = tcb->srcaddr;
    childTcb->srcport = tcb->srcport;
    if (tcb->bindIfp) {
        CACHE_IFP_REFERENCE(childTcb->bindIfp, tcb->bindIfp);
    }

    // Copy socket options
    childTcb->options = tcb->options;
    if (tcb->ipoptlen) {
        PcbSetIpOpts((PCB*) childTcb, tcb->ipopts, tcb->ipoptlen);
    } else {
        ASSERT(childTcb->ipopts == NULL);
    }

    return childTcb;
}


NTSTATUS
TcbListen(
    TCB* tcb,
    INT backlog
    )

/*++

Routine Description:

    Switch a TCP socket into listening state

Arguments:

    tcb - Points to the TCP control block
    backlog - Maximum number of pending connections

Return Value:

    Status code

--*/

{
    KIRQL irql;
    NTSTATUS status;

    if (!IsTcpIdleState(tcb))
        return NETERR(WSAEISCONN);

    irql = RaiseToDpc();

    status = PcbGetErrStatus(tcb);
    if (NT_SUCCESS(status)) {
        TcbSetState(tcb, TCPST_LISTEN, "Listen");
        tcb->maxBacklog = (backlog < 1) ? 1 :
                          (backlog > cfgMaxListenBacklog) ?
                            cfgMaxListenBacklog :
                            backlog;

        // Trim down the backlog of pending connections if needed
        TcbTrimConnReqBacklog(tcb, tcb->maxBacklog);
        status = NETERR_OK;
    }

    LowerFromDpc(irql);
    return status;
}


NTSTATUS
TcbAccept(
    TCB* tcb,
    TCB** newtcb
    )

/*++

Routine Description:

    Accept an incoming TCP connection request

Arguments:

    tcb - Points to the TCP control block
    newtcb - Returns a pointer to the newly accepted connection block

Return Value:

    Status code

--*/

{
    KIRQL irql;
    LIST_ENTRY* entry;
    NTSTATUS status = NETERR_CONNRESET;

    irql = RaiseToDpc();

    entry = tcb->listenq.Flink;
    while (entry != &tcb->listenq) {
        TCB* childTcb = CONTAINING_RECORD(entry, TCB, listenq);
        if (IsPcbConnected(childTcb)) {
            TcbDisassociateChild(childTcb);
            *newtcb = childTcb;
            status = NETERR_OK;
            break;
        }
        entry = entry->Flink;
    }

    LowerFromDpc(irql);
    return status;
}


BOOL
TcbHasConnectedPendingConnReq(
    TCB* tcb
    )

/*++

Routine Description:

    Check to see if a listening socket has pending connection
    requests that are in ESTABLISHED state.

Arguments:

    TCB - Points to the TCP control block

Return Value:

    TRUE if there is pending connections ready to be accepted
    FALSE otherwise

--*/

{
    KIRQL irql;
    LIST_ENTRY* entry;
    BOOL result = FALSE;

    irql = RaiseToDpc();

    entry = tcb->listenq.Flink;
    while (entry != &tcb->listenq) {
        TCB* childTcb = CONTAINING_RECORD(entry, TCB, listenq);
        if (IsPcbConnected(childTcb)) {
            result = TRUE;
            break;
        }
        entry = entry->Flink;
    }

    LowerFromDpc(irql);

    return result;
}


NTSTATUS
TcbConnect(
    TCB* tcb,
    IPADDR dstaddr,
    IPPORT dstport,
    BOOL synAck
    )

/*++

Routine Description:

    Make a TCP connection to the specified foreign address

Arguments:

    tcb - Points to the TCP control block
    dstaddr, dstport - Specifies the foreign address to connect to
    synAck - Whether we're acknowledging a received SYN request

Return Value:

    Status code

--*/

{
    NTSTATUS status;
    KIRQL irql;
    RTE* rte;

    if (dstport == 0 ||
        dstaddr == 0 ||
        IS_BCAST_IPADDR(dstaddr) ||
        IS_MCAST_IPADDR(dstaddr))
        return NETERR(WSAEADDRNOTAVAIL);

    if (IsTcpListenState(tcb))
        return NETERR_PARAM;

    // Bind to a local address if necessary
    if (!IsPcbBound(tcb)) {
        status = PcbBind((PCB*) tcb, 0, 0);
        if (!NT_SUCCESS(status)) return status;
    }

    irql = RaiseToDpc();

    if (tcb->flags & PCBFLAG_REVIVABLE) {
        // Revive a TCB that has been reset
        tcb->connectSelected = 0;
        tcb->flags &= ~(PCBFLAG_REVIVABLE|PCBFLAG_BOTH_SHUTDOWN);
        tcb->eventFlags = 0;
        KeClearEvent(GetPcbWaitEvent(tcb));
        tcb->errStatus = NETERR_OK;

        ASSERT(IsListEmpty(&tcb->listenq));
        TcbInit(tcb);

        // Move the TCB structure from the dead list
        // back to the active list.
        RemoveEntryList(&tcb->links);
        InsertHeadList(&PcbList, &tcb->links);
    } else {
        status = PcbGetErrStatus(tcb);
        if (!NT_SUCCESS(status)) goto exit;
    }

    if (!IsTcpIdleState(tcb) && !synAck) {
        status = NETERR(WSAEALREADY);
        goto exit;
    }

    // Find a route to the connected destination.
    ASSERT(tcb->rte == NULL);
    rte = tcb->rte = IpFindRTE(dstaddr, NULL);
    if (!rte) {
        status = NETERR_UNREACHABLE;
        goto exit;
    }

    RteAddRef(rte);
    if (tcb->bindSrcAddr == 0) {
        tcb->srcaddr = PcbGetDefaultSrcAddr(rte);
    }

    // If this is an active open, go to SYN-SENT state.
    // Otherwise, we should already be in SYN-RECEIVED state.
    if (!synAck) {
        TcbSetState(tcb, TCPST_SYN_SENT, "Connect");
    }

    // Set up MSS to make sure we don't have to
    // fragment on the first hop. We assume the first hop
    // interface won't change during the life of the connection.
    tcb->rcv_mss = rte->ifp->mtu - IPHDRLEN - TCPHDRLEN;
    tcb->maxRecvBufsize = 
        ((tcb->maxRecvBufsize + tcb->rcv_mss - 1) / tcb->rcv_mss) * tcb->rcv_mss;
    if (tcb->maxRecvBufsize > cfgMaxSendRecvBufsize)
        tcb->maxRecvBufsize = cfgMaxSendRecvBufsize;

    tcb->dstaddr = dstaddr;
    tcb->dstport = dstport;

    tcb->snd_isn = TcbGetIsn();
    tcb->rcv_wnd = tcb->maxRecvBufsize;
    ASSERT(IsTcpRecvBufEmpty(tcb));

    // send out a SYN or SYN/ACK segment
    status = TcbEmitSYN(tcb, synAck);

exit:
    LowerFromDpc(irql);
    return status;
}


#if DBG

extern ULONG XDebugOutLevel;

VOID
TcbSetState(
    TCB* tcb,
    BYTE state,
    const CHAR* caller
    )

/*++

Routine Description:

    Change the TCP connection state

Arguments:

    tcb - Points to the TCP control block
    state - Specifies the new connectio state
    caller - Name of the calling function

Return Value:

    NONE

--*/

{
    static const CHAR* stateNames[] = {
        "CLOSED",
        "LISTEN",
        "SYN_SENT",
        "SYN_RECEIVED",
        "ESTABLISHED",
        "FIN_WAIT_1",
        "FIN_WAIT_2",
        "CLOSING",
        "TIME_WAIT",
        "CLOSE_WAIT",
        "LAST_ACK"
    };

    BYTE oldstate = tcb->tcpstate;
    tcb->tcpstate = state;

    // Debug spew...

    if (XDebugOutLevel < XDBG_TRACE) return;

    DbgPrint("%s ", caller);
    DbgPrint("%s:%d - ", IPADDRSTR(tcb->srcaddr), NTOHS(tcb->srcport));
    DbgPrint("%s:%d: ", IPADDRSTR(tcb->dstaddr), NTOHS(tcb->dstport));
    DbgPrint("%s => %s\n", stateNames[oldstate], stateNames[state]);
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\tcp\mcast.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    mcast.c

Abstract:

    Implement multicast support on UDP and RAW sockets

Revision History:

    07/07/2000 davidx
        Created it.

--*/

#include "precomp.h"

//
// Maximum of multicast groups that can be joined from a single socket
//
UINT cfgMaxSocketMcastGroups = 16;


VOID
PcbCleanupMcastData(
    PCB* pcb
    )

/*++

Routine Description:

    Cleanup multicast group membership data associated with the PCB

Arguments:

    pcb - Points to the protocol control block

Return Value:

    NONE

--*/

{
    PcbMcastData* pcbmcast;
    PcbMcastGroup* mcastgrp;
    UINT count;

    RUNS_AT_DISPATCH_LEVEL
    if ((pcbmcast = pcb->mcastData) == NULL) return;
    pcb->mcastData = NULL;

    // Drop all multicast groups that this socket belongs to
    mcastgrp = pcbmcast->mcastGroups;
    count = pcbmcast->groupCount;
    while (count--) {
        IfChangeMcastGroup(mcastgrp->ifp, mcastgrp->mcastaddr, FALSE);
        mcastgrp++;
    }

    SysFree(pcbmcast);
}


INLINE PcbMcastData*
PcbGetMcastData(
    PCB* pcb
    )

/*++

Routine Description:

    Allocate per-socket multicast group membership information

Arguments:

    pcb - Points to the protocol control block

Return Value:

    Points to the per-socket multicast information
    NULL if out of memory

--*/

{
    if (pcb->mcastData == NULL) {
        UINT size = offsetof(PcbMcastData, mcastGroups) +
                    sizeof(PcbMcastGroup) * cfgMaxSocketMcastGroups;
        pcb->mcastData = (PcbMcastData*) SysAlloc0(size, PTAG_MCAST);
    }

    return pcb->mcastData;
}


NTSTATUS
PcbSetMcastIf(
    PCB* pcb,
    IPADDR ifaddr
    )

/*++

Routine Description:

    Specifies the default interface for sending out multicast datagrams

Arguments:

    pcb - Points to the protocol control block
    ifaddr - Specifies the address of the interface designated
        for sending out multicast datagrams by default;
        use 0 to unset any existing multicast interface

Return Value:

    Status code

--*/

{
    NTSTATUS status;
    KIRQL irql;
    IfInfo* ifp;
    PcbMcastData* pcbmcast;

    irql = RaiseToDpc();

    if ((pcbmcast = PcbGetMcastData(pcb)) != NULL) {
        if (ifaddr == 0) {
            RTE* rte = IpFindRTE(CLASSD_NETID, NULL);
            ifp = rte ? rte->ifp : NULL;
        } else {
            ifp = IfFindInterface(ifaddr);
        }

        if (ifp && IfMcastEnabled(ifp)) {
            CACHE_IFP_REFERENCE(pcbmcast->mcastIfp, ifp);
            pcbmcast->mcastIfAddr = ifaddr;
            status = NETERR_OK;
        } else {
            status = NETERR(WSAEADDRNOTAVAIL);
        }
    } else {
        status = NETERR_MEMORY;
    }

    LowerFromDpc(irql);
    return status;
}


IfInfo*
PcbGetMcastIf(
    PCB* pcb
    )

/*++

Routine Description:

    Return the default multicast interface for a socket

Arguments:

    pcb - Points to the protocol control block

Return Value:

    Status code

--*/

{
    NTSTATUS status;
    if (!pcb->mcastData || !pcb->mcastData->mcastIfp) {
        ASSERT(!pcb->mcastData || pcb->mcastData->mcastIfAddr == 0);
        status = PcbSetMcastIf(pcb, 0);
        if (!NT_SUCCESS(status))
            return NULL;
    }

    return pcb->mcastData->mcastIfp;
}


NTSTATUS
PcbChangeMcastGroup(
    PCB* pcb,
    IPADDR mcastaddr,
    IPADDR ifaddr,
    BOOL add
    )

/*++

Routine Description:

    Join or leave a multicast group

Arguments:

    pcb - Points to the protocol control block
    mcastaddr - Specifies the multicast group address
    ifaddr - Specifies the interface address (0 means any)
    add - Whether to join or leave the group

Return Value:

    Status code

--*/

{
    NTSTATUS status;
    PcbMcastData* pcbmcast;
    KIRQL irql = RaiseToDpc();

    pcbmcast = PcbGetMcastData(pcb);
    if (pcbmcast) {
        PcbMcastGroup* mcastgrp;
        UINT index;
        BOOL existing;

        // Check to see if the socket is already joined into
        // the specified group/interface combination.
        mcastgrp = pcbmcast->mcastGroups;
        for (index=0; index < pcbmcast->groupCount; index++, mcastgrp++) {
            if (mcastgrp->mcastaddr == mcastaddr &&
                mcastgrp->ifaddr == ifaddr)
                break;
        }

        existing = (index < pcbmcast->groupCount);
        if (add) {
            // Joining a group
            if (existing) {
                // The socket already belong to the specified group
                status = NETERR(WSAEADDRINUSE);
            } else if (pcbmcast->groupCount == cfgMaxSocketMcastGroups) {
                // Socket belongs to too many groups
                status = NETERR(WSAEADDRNOTAVAIL);
            } else {
                IfInfo* ifp;

                ifp = ifaddr ? IfFindInterface(ifaddr) : PcbGetMcastIf(pcb);
                if (ifp) {
                    status = IfChangeMcastGroup(ifp, mcastaddr, TRUE);
                    if (NT_SUCCESS(status)) {
                        mcastgrp->mcastaddr = mcastaddr;
                        mcastgrp->ifaddr = ifaddr;
                        CACHE_IFP_REFERENCE(mcastgrp->ifp, ifp);
                        pcbmcast->groupCount++;
                    }
                } else {
                    status = NETERR_UNREACHABLE;
                }
            }
        } else {
            // Leaving a group
            if (existing) {
                status = IfChangeMcastGroup(mcastgrp->ifp, mcastgrp->mcastaddr, FALSE);
                pcbmcast->groupCount--;
                while (index++ < pcbmcast->groupCount) {
                    *mcastgrp = *(mcastgrp+1);
                    mcastgrp++;
                }
            } else {
                status = NETERR_PARAM;
            }
        }
    } else {
        status = NETERR_MEMORY;
    }

    LowerFromDpc(irql);
    return status;
}


BOOL
PcbCheckMcastGroup(
    PCB* pcb,
    IPADDR mcastaddr
    )

/*++

Routine Description:

    Check if the socket is joined into the specified multicast group

Arguments:

    pcb - Points to the protocol control block
    mcastaddr - Specifies the multicast group address

Return Value:

    TRUE if the socket belongs to the specified multicast group
    FALSE otherwise

Note:

    We're not checking the receiving interface here.
    In theory, we could redundantly deliver a multicast
    datagram received from one interface to a socket that 
    belongs to the same multicast group on another interface.
    But such practice is discouraged. Besides, we'll only have
    one active interface other than the loopback interface.

--*/

{
    PcbMcastData* pcbmcast = pcb->mcastData;
    PcbMcastGroup* mcastgrp;
    UINT count;

    if (!pcbmcast) return FALSE;
    mcastgrp = pcbmcast->mcastGroups;
    count = pcbmcast->groupCount;
    while (count--) {
        if (mcastgrp->mcastaddr == mcastaddr) return TRUE;
        mcastgrp++;
    }

    return FALSE;
}


NTSTATUS
PcbSendMcastDgram(
    PCB* pcb,
    Packet* pkt,
    IPADDR dstaddr
    )

/*++

Routine Description:

    Send out a multicast datagram

Arguments:

    pcb - Points to the protocol control block
    pkt - Points to the packet to be sent
    dstaddr - Specifies the destination multicast address

Return Value:

    Status code

--*/

{
    IfInfo* ifp;

    RUNS_AT_DISPATCH_LEVEL

    // Send a copy of the multicast datagram to ourselves if needed
    if (!pcb->noMcastLoopback) {
        IpQueueLoopbackPacket(pkt, TRUE);
    }

    // Choose the outgoing interface if we have done so already
    if ((pcb->mcastData  == NULL || (ifp = pcb->mcastData->mcastIfp) == NULL) &&
        (ifp = PcbGetMcastIf(pcb)) == NULL) {
        XnetCompletePacket(pkt, NETERR_UNREACHABLE);
        return NETERR_UNREACHABLE;
    }

    // Check to see if the datagram size is too large
    if (pkt->datalen > ifp->mtu) {
        XnetCompletePacket(pkt, NETERR_MSGSIZE);
        return NETERR_MSGSIZE;
    }

    // Queue up the packet for transmission
    pkt->nexthop = dstaddr;
    IfEnqueuePacket(ifp, pkt);
    ifp->StartOutput(ifp);
    return NETERR_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\tcp\tcpimpl.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    tcpimpl.h

Abstract:

    TCP implementation header file

Revision History:

    05/31/2000 davidx
        Created it.

--*/

#ifndef _TCPIMPL_H
#define _TCPIMPL_H

//
// Sequence number related functions and macros
//
INLINE TCPSEQ TcbGetIsn() {
    // Get the initial sequence number for a new TCP connection.
    // The return value is a 32-bit integer bound to
    // a real-time clock and whose value is incremented
    // every 4 microseconds.
    LARGE_INTEGER time;

    KeQuerySystemTime(&time);
    return (TCPSEQ) (time.QuadPart / 40);
}

#define SEQ_LT(a, b)    ((INT) ((a) - (b)) < 0)
#define SEQ_LE(a, b)    ((INT) ((a) - (b)) <= 0)
#define SEQ_GT(a, b)    ((INT) ((a) - (b)) > 0)
#define SEQ_GE(a, b)    ((INT) ((a) - (b)) >= 0)

// Return the sequence numbers in a TCP segment (in host byte order)
#define SEG_SEQ(_tcphdr) NTOHL((_tcphdr)->seqnum)
#define SEG_ACK(_tcphdr) NTOHL((_tcphdr)->acknum)
#define SEG_WIN(_tcphdr) NTOHS((_tcphdr)->window)
#define SEG_URG(_tcphdr) NTOHS((_tcphdr)->urgent)

// Return the length of a TCP segment (counting SYN and FIN)
#define SEG_LEN(_tcphdr, _datalen) \
        ((_datalen) + \
         (((_tcphdr)->flags & TCP_SYN) ? 1 : 0) + \
         (((_tcphdr)->flags & TCP_FIN) ? 1 : 0))

//
// Internal function prototypes
//
VOID PcbCleanup(PCB* pcb, BOOL revivable);
VOID PcbSetupIpHeader(PCB* pcb, Packet* pkt, IpAddrPair* addrpair);
PCB* PcbFindMatch(IPADDR, IPPORT, IPADDR, IPPORT, BYTE, BYTE);
VOID TcbInit(TCB* tcb);
BOOL TcbClose(TCB* tcb, BOOL force);
BOOL TcbStartOutput(TCB* tcb);
TCB* TcbReset(TCB* tcb, NTSTATUS status);
TCB* TcbCloneChild(TCB* tcb);
TCB* TcbXmitTimeout(TCB* tcb);
VOID TcbDoFastRexmit(TCB* tcb);

VOID TcbSendSegment(TCB* tcb, TCPSENDBUF* sendbuf);
NTSTATUS TcbEmitSYN(TCB* tcb, BOOL synAck);
NTSTATUS TcbEmitFIN(TCB* tcb);
VOID TcbEmitACK(TCB* tcb);
VOID TcbEmitRST(IfInfo*, IpAddrPair*, TCPSEQ, TCPSEQ, BYTE);

// Return the effective snd_nxt value for a TCP connection
// NOTE: we cannot use TCB.snd_nxt field directly here
// because the way we're doing persisting causes snd_nxt
// to go past the send window.
INLINE TCPSEQ TcbSndNxt(TCB* tcb) {
    TCPSEQ sndmax = tcb->snd_wl2 + tcb->snd_wnd;
    return (IsTcpSyncState(tcb) && SEQ_GT(tcb->snd_nxt, sndmax)) ?
                sndmax :
                tcb->snd_nxt;
}

// Send a RST segment to the TCP connection peer
INLINE VOID TcbResetPeer(TCB* tcb) {
    TcbEmitRST(tcb->bindIfp,
               &tcb->addrpair,
               TcbSndNxt(tcb),
               tcb->rcv_nxt,
               TCP_ACK);
}

// Multicast related functions
VOID PcbCleanupMcastData(PCB* pcb);
BOOL PcbCheckMcastGroup(PCB* pcb, IPADDR mcastaddr);
IfInfo* PcbGetMcastIf(PCB* pcb);
NTSTATUS PcbSendMcastDgram(PCB* pcb, Packet* pkt, IPADDR dstaddr);

// Forcefully delete PCB and TCB
#define PcbDelete(_pcb) PcbClose(_pcb, TRUE)
#define TcbDelete(_tcb) PcbClose((PCB*) (_tcb), TRUE)

// Is this a TCP socket lingering after being closed?
#define TcbIsLingering(_tcb) ((_tcb)->magicCookie == CLOSED_PCB_COOKIE)

// Calculate the checksum for an outgoing TCP/UDP packet
#define CALC_TCPUDP_CHECKSUM(_pkt, _addrpair, _protocol, _checksum) { \
            PseudoHeader _pseudohdr; \
            _pseudohdr.srcaddr = (_addrpair)->srcaddr; \
            _pseudohdr.dstaddr = (_addrpair)->dstaddr; \
            _pseudohdr.zero = 0; \
            _pseudohdr.protocol = (_protocol); \
            _pseudohdr.length = HTONS((_pkt)->datalen); \
            _checksum = tcpipxsum(0, &_pseudohdr, sizeof(_pseudohdr)); \
            _checksum = ~tcpipxsum(_checksum, (_pkt)->data, (_pkt)->datalen); \
        }

// Set up the TCP header information in an outgoing TCB segment
INLINE VOID
FILL_TCPHEADER(
    Packet* pkt,
    IpAddrPair* addrpair,
    TCPSEQ seq,
    TCPSEQ ack,
    BYTE hdrlen,
    BYTE flags,
    WORD wnd
    )
{
    TcpHeader* tcphdr;
    UINT checksum;
    tcphdr = GETPKTDATA(pkt, TcpHeader);
    tcphdr->srcport = addrpair->srcport;
    tcphdr->dstport = addrpair->dstport;
    tcphdr->seqnum = HTONL(seq);
    tcphdr->acknum = HTONL(ack);
    SETTCPHDRLEN(tcphdr, hdrlen);
    tcphdr->flags = flags;
    tcphdr->window = HTONS(wnd);
    tcphdr->checksum = tcphdr->urgent = 0;
    CALC_TCPUDP_CHECKSUM(pkt, addrpair, IPPROTOCOL_TCP, checksum);
    tcphdr->checksum = (WORD) checksum;
}

// Set up the UDP header information in an outgoing UDP datagram
INLINE VOID FILL_UDPHEADER(Packet* pkt, IpAddrPair* addrpair) {
    UdpHeader* udphdr;
    UINT checksum;
    udphdr = GETPKTDATA(pkt, UdpHeader);
    udphdr->srcport = addrpair->srcport;
    udphdr->dstport = addrpair->dstport;
    udphdr->length = (WORD) HTONS(pkt->datalen);
    udphdr->checksum = 0;
    CALC_TCPUDP_CHECKSUM(pkt, addrpair, IPPROTOCOL_UDP, checksum);
    udphdr->checksum = (WORD) (checksum ? checksum : ~checksum);
}

// Signal PCB events
#define PcbSignalEvent(_pcb, _eventMask) { \
            if ((_pcb)->eventFlags & (_eventMask)) { \
                SetKernelEvent(GetPcbWaitEvent(_pcb)); \
            } \
        }

// Queue up a receive user request on a socket
NTSTATUS PcbQueueOverlappedRecv(PCB* pcb, RECVREQ* recvreq);

//
// Change TCP connection state:
//
#if DBG
VOID TcbSetState(TCB* tcb, BYTE state, const CHAR* caller);
#else
#define TcbSetState(_tcb, _state, _caller) \
        (_tcb)->tcpstate = (_state)
#endif

//
// Global variable declarations
//
extern UINT cfgMSL;
extern UINT cfgMaxDelayedAcks;
extern UINT cfgConnectTimeout;
extern UINT cfgMaxXmitRetries;
extern UINT cfgMinRexmitTimeout;
extern UINT cfgMaxRexmitTimeout;
extern LIST_ENTRY DeadTcbList;

//
// Setting various TCP timers
//
INLINE VOID TcbSetSynTimer(TCB* tcb, UINT ticks) {
    tcb->synTimer = ticks;
}

INLINE VOID TcbSetTimeWaitTimer(TCB* tcb, UINT ticks) {
    if (tcb->timeWaitTimer == 0 || tcb->timeWaitTimer > ticks)
        tcb->timeWaitTimer = ticks;
}

//
// Stop TCP fast retransmit/recovery mode
//
INLINE VOID TcbStopFastRexmitMode(TCB* tcb) {
    tcb->fastRexmitFlag = 0;
    tcb->dupacks = 0;
}

//
// TCP statistics
//
typedef struct _TCPSTATS {
    UINT rexmitTimeouts;
    UINT fastRexmits;
    UINT persists;
    UINT misordered;
} TCPSTATS;

extern TCPSTATS TcpStats;

//
// Figure out the default source address that we should
// use for a TCP or UDP connection, given the outgoing route.
//
INLINE IPADDR PcbGetDefaultSrcAddr(RTE* rte) {
    return ((rte->flags & RTEFLAG_HOST) &&
            (rte->nexthop == IPADDR_LOOPBACK)) ?
                rte->dstaddr :
                rte->ifp->ipaddr;
}

#endif // !_TCPIMPL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\tcp\pcb.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    pcb.h

Abstract:

    Protocol control blocks

Revision History:

    06/01/2000 davidx
        Created it.

--*/

#ifndef _PCB_H
#define _PCB_H

//------------------------------------------------------------------------
// Protocol control block for TCP/UDP/RAW sockets
//------------------------------------------------------------------------

typedef struct _RECVREQ RECVREQ;
typedef struct _RECVBUF RECVBUF;
typedef struct _SENDREQ SENDREQ;
typedef struct _SENDBUF SENDBUF;
typedef struct _TCPSENDBUF TCPSENDBUF;
typedef struct _PCBOPT PCBOPT;
typedef struct _PCB PCB;
typedef struct _TCB TCB;

// Socket options

typedef struct _PCBOPT {
    UINT sendTimeout;
    UINT recvTimeout;
    UINT maxSendBufsize;
    UINT maxRecvBufsize;
    BYTE ipTtl;
    BYTE ipTos;
    BYTE mcastTtl;
    BYTE unused;
    UINT ipoptlen;
    BYTE* ipopts;
    LINGER linger;

    struct {
        UINT nonblocking:1;
        UINT broadcast:1;
        UINT reuseAddr:1;
        UINT exclusiveAddr:1;
        UINT noNagle:1;
        UINT ipDontFrag:1;
        UINT ipHdrIncl:1;
        UINT noMcastLoopback:1;
        UINT connectSelected:1;
    };
};

// Per-socket multicast group membership information

typedef struct _PcbMcastGroup {
    IPADDR mcastaddr;
    IPADDR ifaddr;
    IfInfo* ifp;
} PcbMcastGroup;

typedef struct _PcbMcastData {
    IPADDR mcastIfAddr;     // outgoing multicast interface address
    IfInfo* mcastIfp;       // and pointer

    // Variable number of multicast groups
    UINT groupCount;
    PcbMcastGroup mcastGroups[1];
} PcbMcastData;

// Protocol control block for TCP/UDP/RAW sockets

typedef struct _PCB {
    //
    // Doubly-linked list pointers
    //  must be the first field!
    //
    LIST_ENTRY links;

    //
    // Magic cookie for debugging purposes and to indicate
    // whether the PCB is being exclusively accessed.
    //
    LONG magicCookie;

    #define ACTIVE_PCB_COOKIE '+BCP'
    #define BUSY_PCB_COOKIE   '*BCP'
    #define CLOSED_PCB_COOKIE '-bcp'

    //
    // PCB type (SOCK_STREAM/SOCK_DGRAM/SOCK_RAW) and protocol number
    //
    BYTE type;
    BYTE protocol;

    //
    // Current TCP connection state
    //
    BYTE tcpstate;

    //
    // PCB flags
    //
    BYTE flags;

    #define PCBFLAG_SEND_SHUTDOWN   0x01    // cannot send data
    #define PCBFLAG_RECV_SHUTDOWN   0x02    // cannot receive data
    #define PCBFLAG_BOUND           0x04    // bound to local address
    #define PCBFLAG_CONNECTED       0x08    // connected to remote address
    #define PCBFLAG_NETPOOL         0x10    // allocated from our private pool
    #define PCBFLAG_REVIVABLE       0x20    // a revivable TCP connection
    #define PCBFLAG_BOTH_SHUTDOWN   (PCBFLAG_SEND_SHUTDOWN|PCBFLAG_RECV_SHUTDOWN)

    #define IsPcbSendShutdown(_pcb) ((_pcb)->flags & PCBFLAG_SEND_SHUTDOWN)
    #define IsPcbRecvShutdown(_pcb) ((_pcb)->flags & PCBFLAG_RECV_SHUTDOWN)
    #define IsPcbBound(_pcb)        ((_pcb)->flags & PCBFLAG_BOUND)
    #define IsPcbConnected(_pcb)    ((_pcb)->flags & PCBFLAG_CONNECTED)

    //
    // Socket wait event flags
    //
    #define PCBEVENT_READ       0x0001  // = FD_READ
    #define PCBEVENT_WRITE      0x0002  // = FD_WRITE
    #define PCBEVENT_ACCEPT     0x0008  // = FD_ACCEPT
    #define PCBEVENT_CONNECT    0x0010  // = FD_CONNECT
    #define PCBEVENT_CLOSE      0x0020  // = FD_CLOSE
    #define PCBEVENT_CONNRESET  0x8000
    #define PCBEVENT_ALL        (-1)

    INT eventFlags;

    //
    // Socket notification event object
    //
    KEVENT blockEvent;

    #define GetPcbWaitEvent(_pcb) (&(_pcb)->blockEvent)

    //
    // Protocol flags (see XP1_* constants in winsock2.h)
    //
    INT protocolFlags;

    // Check if a PCB is for a datagram socket
    #define IsDgramPcb(_pcb) ((_pcb)->protocolFlags & XP1_CONNECTIONLESS)
    #define IsTcb(_pcb) (!IsDgramPcb(_pcb))

    //
    // Pending receive I/O request and receive buffers
    //
    RECVREQ* overlappedRecvs;
    LIST_ENTRY recvbuf;
    ULONG recvbufSize;

    #define HasOverlappedRecv(_pcb) ((_pcb)->overlappedRecvs != NULL)
    #define PcbGetOverlappedRecv(_pcb) ((_pcb)->overlappedRecvs)
    
    #define IsPcbRecvBufFull(_pcb) ((_pcb)->recvbufSize >= (_pcb)->maxRecvBufsize)
    #define IsDgramRecvBufEmpty(_pcb) IsListEmpty(&(_pcb)->recvbuf)
    #define IsTcpRecvBufEmpty(_tcb) ((_tcb)->recvbufSize == 0)
    #define IsPcbRecvBufEmpty(_pcb) \
            (IsDgramPcb(_pcb) ? IsDgramRecvBufEmpty(_pcb) : IsTcpRecvBufEmpty(_pcb))

    //
    // Pending send I/O request and send buffers
    //
    SENDREQ* overlappedSends;
    LIST_ENTRY sendbuf;
    ULONG sendbufSize;

    #define HasOverlappedSend(_pcb) ((_pcb)->overlappedSends != NULL)

    #define IsPcbSendBufEmpty(_pcb) IsListEmpty(&(_pcb)->sendbuf)
    #define IsPcbSendBufFull(_pcb) ((_pcb)->sendbufSize >= (_pcb)->maxSendBufsize)

    //
    // Socket address pairs: dstaddr, srcaddr, dstport, srcport
    //
    union {
        IpAddrPair addrpair;
        IpAddrPair;
    };
    IPADDR bindSrcAddr;

    //
    // Cached route table entry
    // Interface that the socket was explicitly bound to
    //
    RTE* rte;
    IfInfo* bindIfp;

    //
    // Multicast group membership information
    //  (for UDP and RAW sockets only)
    //
    PcbMcastData* mcastData;

    // 
    // Socket error status
    // For TCP socket, this indicates whether the connection
    // has been reset and; and if so, how the connection got reset.
    //
    NTSTATUS errStatus;

    #define PcbGetErrStatus(_pcb) ((_pcb)->errStatus)

    //
    // Socket options
    //
    union {
        PCBOPT options;
        PCBOPT;
    };
};

//
// Allocate and free a PCB structure
//
PCB* PcbCreate(INT type, INT protocol, BYTE allocFlag);
NTSTATUS PcbClose(PCB* pcb, BOOL force);
VOID PcbCloseAll();

//
// Allocate and free socket IP options
//
INLINE VOID PcbFreeIpOpts(PCB* pcb) {
    if (pcb->flags & PCBFLAG_NETPOOL) {
        XnetFree(pcb->ipopts);
    } else {
        SysFree(pcb->ipopts);
    }
    pcb->ipopts = NULL;
    pcb->ipoptlen = 0;
}

INLINE BYTE* PcbSetIpOpts(PCB* pcb, const VOID* opts, UINT optlen) {
    if (pcb->flags & PCBFLAG_NETPOOL) {
        pcb->ipopts = (BYTE*) XnetAlloc0(optlen, PTAG_SOPTS);
    } else {
        pcb->ipopts = (BYTE*) SysAlloc0(optlen, PTAG_SOPTS);
    }

    if (pcb->ipopts) {
        pcb->ipoptlen = optlen;
        CopyMem(pcb->ipopts, opts, optlen);
    }
    return pcb->ipopts;
}

//
// TCP connection block
//
typedef DWORD TCPSEQ;
typedef struct _TCB {
    //
    // Common protocol control block
    //  must be the first field!
    PCB;

    //
    // Pending connection requests
    //
    TCB* parent;
    LIST_ENTRY listenq;
    UINT backlog, maxBacklog;

    #define IsPendingConnReqTcb(_tcb) ((_tcb)->parent != NULL)
    #define TcbHasPendingConnReq(_tcb) \
            ((_tcb)->backlog ? TcbHasConnectedPendingConnReq(_tcb) : FALSE)
    
    //
    // TCP timers
    //  delayedAcks is the number of delay-acked segments;
    //  all other timers are measured in 500ms ticks.
    //
    // NOTE: Be careful when you add or remove fields between
    // delayedAcks and rtt_tick (inclusive). See comments in
    // function TcbReset().
    //
    UINT delayedAcks;
    UINT synTimer;          // connection establishment timer
    UINT xmitTimer;         // retransmission & persist timer
    UINT timeWaitTimer;     // TIME-WAIT & linger timer

    //
    // Send/receive state information
    //
    TCPSEQ snd_isn;         // initial send sequence number
    TCPSEQ snd_una;         // sent but not yet acknowledged
    TCPSEQ snd_nxt;         // buffered but not yet sent
    TCPSEQ snd_end;         // not yet buffered
    TCPSEQ snd_wl1;         // seq and ack numbers of the last ACK 
    TCPSEQ snd_wl2;         // that was used to update snd_wnd
    UINT snd_wnd;           // send window
    UINT snd_cwnd;          // congestion window
    UINT snd_ssthresh;      // slow-start threshold
    UINT snd_mss;           // send MSS
    WORD dupacks;           // number of duplicate ACKs received
    BYTE persistFlag;       // are we probing send window?
    BYTE fastRexmitFlag;    // in fast retransmit / fast recovery mode?

    TCPSEQ rcv_isn;         // initial receive sequence number
    TCPSEQ rcv_nxt;         // next expected receive sequence number
    UINT rcv_wnd;           // receive window
    UINT rcv_mss;           // receive MSS
    UINT rcv_swsthresh;     // receive SWS avoidance threshold

    //
    // Round-trip time measurements
    //
    INT srtt_8;             // smoothed round-trip time, in 1/8 ticks
    INT rttvar_4;           // round-trip time variance, in 1/4 ticks
    UINT RTO;               // retransmission timeout, in ticks
    TCPSEQ rtt_seq;         // the seqno of the segment being timed
    UINT rtt_tick;          // when the timed segment was sent

    #define SRTT_SHIFT      3
    #define SRTT_SCALE      (1 << SRTT_SHIFT)
    #define RTTVAR_SHIFT    2
    #define RTTVAR_SCALE    (1 << RTTVAR_SHIFT)

    //
    // This points to the next send buffer that has been
    // queued up but has yet to be sent
    //
    TCPSENDBUF* sendbufNext;
};

//
// TCP states
//
#define TCPST_CLOSED            0
#define TCPST_LISTEN            1
#define TCPST_SYN_SENT          2
#define TCPST_SYN_RECEIVED      3
#define TCPST_ESTABLISHED       4
#define TCPST_FIN_WAIT_1        5
#define TCPST_FIN_WAIT_2        6
#define TCPST_CLOSING           7
#define TCPST_TIME_WAIT         8
#define TCPST_CLOSE_WAIT        9
#define TCPST_LAST_ACK          10

// Idle states:
//  CLOSED, LISTEN
#define IsTcpIdleState(_tcb) ((_tcb)->tcpstate <= TCPST_LISTEN)
#define IsTcpListenState(_tcb) ((_tcb)->tcpstate == TCPST_LISTEN)

// Synchronized states:
//  ESTABLISHED, FIN_WAIT_1, FIN_WAIT_2, CLOSING
//  TIME_WAIT, CLOSE_WAIT, LAST_ACK
#define IsTcpSyncState(_tcb) ((_tcb)->tcpstate >= TCPST_ESTABLISHED)

// FIN has been received from the peer, no more incoming data
#define IsFINReceived(_tcb) ((_tcb)->tcpstate >= TCPST_CLOSING)

// FIN has been sent to the peer, no more outgoing data
#define IsFINSent(_tcb) ((_tcb)->tcpstate >= TCPST_FIN_WAIT_1 && \
                         (_tcb)->tcpstate != TCPST_CLOSE_WAIT)

// Maximum TCP window size (no window scaling option)
#define MAX_TCP_WNDSIZE 0xffff

// Increment the congestion window size for a TCP connection
INLINE VOID TcbIncrementCwnd(TCB* tcb, UINT incr) {
    if ((tcb->snd_cwnd += incr) > MAX_TCP_WNDSIZE)
        tcb->snd_cwnd = MAX_TCP_WNDSIZE;
}

// Reset the slow-start threshold for a TCP connection
INLINE VOID TcbResetSsthresh(TCB* tcb) {
    // NOTE: unsigned arithmetic
    tcb->snd_ssthresh = (tcb->snd_nxt - tcb->snd_una) >> 1;
    if (tcb->snd_ssthresh < 2*tcb->snd_mss)
        tcb->snd_ssthresh = 2*tcb->snd_mss;
}

//------------------------------------------------------------------------
// Data structures for transmitting and receiving data
//------------------------------------------------------------------------

//
// We use WSAOVERLAPPED structure to keep track of
// the status of an overlapped I/O request. When
// the request is pending, the fields are interpreted
// as follows:
//  Internal - pointer to the I/O request structure
//  InternalHigh - unused
//  Offset - unused
//  OffsetHigh - status code = NETERR_PENDING
//
// After a request is completed, the fields are
// interpreted differently:
//  Internal - unused
//  InternalHigh - I/O request completion flags
//  Offset - number of bytes actually transferred
//  OffsetHigh - status code != NETERR_PENDING
//
#define _ioreq      Internal
#define _ioflags    InternalHigh
#define _ioxfercnt  Offset
#define _iostatus   OffsetHigh

// A pending receive request

typedef struct _PcbOverlappedReq {
    PCB* pcb;
    PRKEVENT overlappedEvent;
    WSAOVERLAPPED* overlapped;
} PcbOverlappedReq;

typedef struct _RECVREQ {
    PcbOverlappedReq;   // must be the first field
    DWORD flags;
    DWORD* bytesRecv;
    BYTE* buf;
    UINT buflen;
    struct sockaddr_in* fromaddr;
};

// Complete an overlapped receive request
VOID PcbCompleteOverlappedSendRecv(PcbOverlappedReq* req, NTSTATUS status);

#define PcbCompleteOverlappedRecv(_recvreq, _status) \
        PcbCompleteOverlappedSendRecv((PcbOverlappedReq*) (_recvreq), _status)

// Clear all overlapped receive requests
#define PcbClearOverlappedRecvs(_pcb, _status) { \
            if ((_pcb)->overlappedRecvs) { \
                PcbCompleteOverlappedRecv((_pcb)->overlappedRecvs, _status); \
            } \
        }

// Set the sender's address for received data packet
#define SetRecvReqFromAddr(_recvreq, _fromaddr, _fromport) { \
            if ((_recvreq)->fromaddr) { \
                (_recvreq)->fromaddr->sin_port = (_fromport); \
                (_recvreq)->fromaddr->sin_addr.s_addr = (_fromaddr); \
            } \
        }

// Buffered incoming data

typedef struct _RECVBUF {
    LIST_ENTRY links;   // !! must be the first field
    UINT datalen;
    union {
        // For TCP sockets, points to the start of
        // the remaining data in this buffer.
        struct {
            TCPSEQ seqnext;
            WORD dataoffset;
            BYTE tcpflags;
        };

        // For UDP/RAW sockets, remembers the sender
        // of the datagram.
        struct {
            IPADDR fromaddr;
            IPPORT fromport;
        };
    };
};

// A send request

typedef struct _SENDREQ {
    PcbOverlappedReq;   // must be the first field
    WSABUF* bufs;
    UINT bufcnt;
    UINT sendtotal;
    struct sockaddr_in* toaddr;
};

// Queue up an overlapped send request
NTSTATUS PcbQueueOverlappedSend(PCB* pcb, SENDREQ* sendreq);

// Complete an overlapped send request
#define PcbCompleteOverlappedSend(_sendreq, _status) \
        PcbCompleteOverlappedSendRecv((PcbOverlappedReq*) (_sendreq), _status)

// Clear all overlapped send requests
#define PcbClearOverlappedSends(_pcb, _status) { \
            if ((_pcb)->overlappedSends) { \
                PcbCompleteOverlappedSend((_pcb)->overlappedSends, _status); \
            } \
        }

// Dequeue the overlapped send request
INLINE SENDREQ* PcbGetOverlappedSend(PCB* pcb) {
    SENDREQ* sendreq = pcb->overlappedSends;
    pcb->overlappedSends = NULL;
    return sendreq;
}

// Buffer outgoing data (common to UDP and TCP)

typedef struct _SENDBUF {
    LIST_ENTRY links;   // !! must be the first field
    LONG refcount;
    UINT datalen;
    PCB* pcb;
};

// Get the pointer to the Packet that contains a SENDBUF. For our
// outgoing packets (either UDP/RAW datagrams or TCP segments), we
// store a SENDBUF structure right after the packet header.
#define GetSendbufPkt(_sendbuf) \
        ((Packet*) ((BYTE*) (_sendbuf) - PKTHDRLEN))

#define IsSendbufActive(_sendbuf) ((_sendbuf)->refcount > 1)
#define SendbufIncRef(_sendbuf) ((_sendbuf)->refcount += 1)
#define SendbufDecRef(_sendbuf) ((_sendbuf)->refcount -= 1)
#define SendbufRelease(_sendbuf) { \
            if (SendbufDecRef(_sendbuf) == 0) { \
                XnetFreePacket(GetSendbufPkt(_sendbuf)); \
            } \
        }

// TCP send buffers

typedef struct _TCPSENDBUF {
    SENDBUF;
    BYTE* pktdata;      // saved packet data pointer and length
    UINT pktdatalen;    //
    TCPSEQ seq;         // starting sequence number for this TCP segment
    TCPSEQ seqnext;     // the first seqno after this segment
    WORD retries;       // number of times this segment has been rexmitted
    BYTE tcpflags;      // TCP segment flags
    BYTE tcphdrlen;     // TCP segment header length
    UINT firstSendTime; // the time this segment was first sent
};

#define TcbSendbufNil(_tcb) ((TCPSENDBUF*) &(_tcb)->sendbuf)
#define TcbFirstSendbuf(_tcb) ((TCPSENDBUF*) (_tcb)->sendbuf.Flink)
#define TcbSendbufFlink(_sendbuf) ((TCPSENDBUF*) (_sendbuf)->links.Flink)
#define TcbHasPendingSend(_tcb) ((_tcb)->sendbufNext != TcbSendbufNil(_tcb))

// Loop through all transmission buffers for a TCP connection block

#define LOOP_THRU_TCB_SENDBUF(_tcb, _sendbuf) { \
            TCPSENDBUF* _next; \
            _sendbuf = TcbFirstSendbuf(_tcb); \
            for (; _sendbuf != TcbSendbufNil(_tcb); _sendbuf = _next) { \
                _next = TcbSendbufFlink(_sendbuf);

#define END_TCB_SENDBUF_LOOP \
            } \
        }

#define TcbRecvbufNil(_tcb) ((RECVBUF*) &(_tcb)->recvbuf)
#define TcbLastRecvbuf(_tcb) ((RECVBUF*) (_tcb)->recvbuf.Blink)
#define TcbRecvbufBlink(_recvbuf) ((RECVBUF*) (_recvbuf)->links.Blink)
#define TcbRecvbufFlink(_recvbuf) ((RECVBUF*) (_recvbuf)->links.Flink)

//------------------------------------------------------------------------
// Global PCB list
//------------------------------------------------------------------------

extern LIST_ENTRY PcbList;
extern ULONG PcbCount;

#define LOOP_THRU_PCB_LIST(_pcb) { \
            PCB* _next; \
            _pcb = (PCB*) PcbList.Flink; \
            for (; _pcb != (PCB*) &PcbList; _pcb = _next) { \
                _next = (PCB*) _pcb->links.Flink;

#define END_PCB_LIST_LOOP \
            } \
        }
//
// Insert a PCB into the global list
//
INLINE VOID PcbInsertToList(PCB* pcb) {
    KIRQL irql = RaiseToDpc();
    InsertHeadList(&PcbList, &pcb->links);
    LowerFromDpc(irql);
}

#define IsPcbListEmpty() IsListEmpty(&PcbList)

//
// Block the current thread until the specified
// socket event is signalled
//
NTSTATUS PcbWaitForEvent(PCB* pcb, INT eventMask, UINT timeout);
INT PcbCheckSelectEvents(PCB* pcb, INT eventMasks, INT setwait);
INLINE VOID PcbClearSelectEvents(PCB* pcb) {
    pcb->eventFlags = 0;
}

//
// Flush a socket's receive buffers
//
INLINE VOID PcbFlushRecvBuffers(PCB* pcb) {
    while (!IsListEmpty(&pcb->recvbuf)) {
        VOID* head = RemoveHeadList(&pcb->recvbuf);
        XnetFree(head);
    }
    pcb->recvbufSize = 0;
}

//
// Public PCB functions
//
NTSTATUS PcbBind(PCB* pcb, IPADDR srcaddr, IPPORT srcport);
NTSTATUS PcbConnectDgram(PCB* pcb, IPADDR dstaddr, IPPORT dstport);
NTSTATUS PcbSendDgram(PCB* tcb, SENDREQ* sendreq);
NTSTATUS PcbRecvDgram(PCB* pcb, RECVREQ* recvreq);
NTSTATUS PcbShutdownDgram(PCB* pcb, BYTE flags);
NTSTATUS PcbUpdateBufferSize(PCB* pcb, INT sendBufsize, INT recvBufsize);
NTSTATUS PcbSetMcastIf(PCB* pcb, IPADDR ifaddr);
NTSTATUS PcbChangeMcastGroup(PCB* pcb, IPADDR mcastaddr, IPADDR ifaddr, BOOL add);

NTSTATUS TcbConnect(TCB* tcb, IPADDR dstaddr, IPPORT dstport, BOOL synAck);
NTSTATUS TcbListen(TCB* tcb, INT backlog);
NTSTATUS TcbAccept(TCB* tcb, TCB** newtcb);
NTSTATUS TcbSend(TCB* tcb, SENDREQ* sendreq);
NTSTATUS TcbRecv(TCB* tcb, RECVREQ* recvreq);
NTSTATUS TcbShutdown(TCB* tcb, BYTE flags, BOOL apicall);
BOOL TcbHasConnectedPendingConnReq(TCB* tcb);

#endif // !_PCB_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\tcp\precomp.h ===
#include "xnetp.h"
#include "icmp.h"
#include "pcb.h"
#include "route.h"
#include "tcpimpl.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\tcp\pcb.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    pcb.c

Abstract:

    Functions for dealing with PCBs (protocol control blocks)

Revision History:

    06/01/2000 davidx
        Created it.

--*/

#include "precomp.h"

//
// Global PCB lists
//
LIST_ENTRY PcbList;
ULONG PcbCount;

//
// Default and max send and receive buffer sizes
// Since we don't do TCP window scaling option, the max
// receive buffer size cannot exceed 16-bit (65535).
//
UINT cfgDefaultSendBufsize = 16*1024;
UINT cfgDefaultRecvBufsize = 16*1024;
UINT cfgMinSendRecvBufsize = 1;
UINT cfgMaxSendRecvBufsize = 0xffff;

//
// Maximum number of sockets
//
UINT cfgMaxSockets = 64;


PCB*
PcbCreate(
    INT type,
    INT protocol,
    BYTE allocFlag
    )

/*++

Routine Description:

    Create a new PCB for the specified socket type and protocol

Arguments:

    type - Socket type: SOCK_STREAM, SOCK_DGRAM, or SOCK_RAW
    protocol - Protocol number
    allocFlag - Whether to allocate memory from our private pool
        PCBFLAG_NETPOOL or 0

Return Value:

    Pointer to the newly created PCB structure
    NULL if there is an error

--*/

{
    PCB* pcb;

    if (PcbCount >= cfgMaxSockets) {
        WARNING_("Too many sockets");
        return NULL;
    }

    //
    // Allocate memory out of the system pool or
    // our private pool based on the caller specified flag
    //
    if (allocFlag & PCBFLAG_NETPOOL) {
        pcb = (PCB*) ((type == SOCK_STREAM) ?
                        XnetAlloc0(sizeof(TCB), PTAG_TCB) :
                        XnetAlloc0(sizeof(PCB), PTAG_PCB));
    } else {
        pcb = (PCB*) ((type == SOCK_STREAM) ?
                        SysAlloc0(sizeof(TCB), PTAG_TCB) :
                        SysAlloc0(sizeof(PCB), PTAG_PCB));
    }

    if (!pcb) return NULL;

    pcb->magicCookie = ACTIVE_PCB_COOKIE;
    pcb->flags = allocFlag;
    pcb->type = (BYTE) type;
    pcb->protocol = (BYTE) protocol;
    pcb->maxSendBufsize = cfgDefaultSendBufsize;
    pcb->maxRecvBufsize = cfgDefaultRecvBufsize;
    pcb->ipTtl = cfgDefaultTtl;
    pcb->ipTos = cfgDefaultTos;
    pcb->mcastTtl = 1;

    InitializeListHead(&pcb->recvbuf);
    InitializeListHead(&pcb->sendbuf);
    KeInitializeEvent(GetPcbWaitEvent(pcb), NotificationEvent, FALSE);

    if (type == SOCK_STREAM) {
        TcbInit((TCB*) pcb);
    }

    InterlockedIncrement(&PcbCount);
    return pcb;
}


NTSTATUS
PcbClose(
    PCB* pcb,
    BOOL force
    )

/*++

Routine Description:

    Close a PCB structure

Arguments:

    pcb - Points to the PCB structure to be disposed of
    force - Forceful close, always succeed

Return Value:

    Status code

--*/

{
    KIRQL irql = RaiseToDpc();

    // If a TCP is being gracefully closed, then we'll
    // leave the the PCB structure in the global list
    // until the connection is really gone.
    if (IsTcb(pcb) && !TcbClose((TCB*) pcb, force)) {
        pcb->magicCookie = CLOSED_PCB_COOKIE;
        pcb->flags |= PCBFLAG_BOTH_SHUTDOWN;
        LowerFromDpc(irql);
        return NETERR_OK;
    }

    // Mark the PCB structure as invalid for simple protection
    // against bad apps trying to access closed socket handles.
    pcb->magicCookie = CLOSED_PCB_COOKIE;

    if (!IsListNull(&pcb->links)) {
        RemoveEntryList(&pcb->links);
    }

    // Clean up the information associated with the PCB
    PcbCleanup(pcb, FALSE);

    LowerFromDpc(irql);

    if (pcb->flags & PCBFLAG_NETPOOL) {
        XnetFree(pcb);
    } else {
        SysFree(pcb);
    }

    InterlockedDecrement(&PcbCount);
    return NETERR_OK;
}


VOID
PcbCleanup(
    PCB* pcb,
    BOOL revivable
    )

/*++

Routine Description:

    Clean up the information associated with a PCB

Arguments:

    pcb - Points to the protocol control block
    revivable - Only significant for a TCP socket;
        if TRUE we leave the socket in a revivable state

Return Value:

    NONE

--*/

{
    NTSTATUS status;
    RUNS_AT_DISPATCH_LEVEL

    status = NT_SUCCESS(pcb->errStatus) ? NETERR_CANCELLED : pcb->errStatus;
    PcbClearOverlappedRecvs(pcb, status);
    PcbClearOverlappedSends(pcb, status);

    // Flush send and receive buffers
    PcbFlushRecvBuffers(pcb);

    while (!IsPcbSendBufEmpty(pcb)) {
        SENDBUF* sendbuf = (SENDBUF*) RemoveHeadList(&pcb->sendbuf);
        SendbufRelease(sendbuf);
    }
    pcb->sendbufSize = 0;

    if (pcb->rte) {
        IpReleaseCachedRTE(pcb->rte);
        pcb->rte = NULL;
    }

    if (revivable) {
        pcb->flags |= PCBFLAG_REVIVABLE;
    } else {
        if (pcb->bindIfp)
            pcb->bindIfp = NULL;

        PcbCleanupMcastData(pcb);
        PcbFreeIpOpts(pcb);
    }
}


VOID
PcbCloseAll()

/*++

Routine Description:

    Forcefully close all sockets

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    PCB* pcb;

    if (IsListNull(&PcbList)) return;
    while (!IsPcbListEmpty()) {
        pcb = (PCB*) PcbList.Flink;
        PcbDelete(pcb);
    }

    if (IsListNull(&DeadTcbList)) return;
    while (!IsListEmpty(&DeadTcbList)) {
        pcb = (PCB*) DeadTcbList.Flink;
        PcbDelete(pcb);
    }
}


PCB*
PcbFindMatch(
    IPADDR toaddr,
    IPPORT toport,
    IPADDR fromaddr,
    IPPORT fromport,
    BYTE type,
    BYTE protocol
    )

/*++

Routine Description:

    Find the matching socket for a received datagarm

Arguments:

    toaddr, toport - The destination address of the datagram
    fromaddr, fromport - The sender's address
    type - Specifies the socket type (SOCK_DGRAM or SOCK_RAW)
    protocol - Specifies the protocol number

Return Value:

    Points to the best socket to receive the datagram
    NULL if no matching socket is found

--*/

{
    PCB* pcb;
    PCB* found;
    UINT wildcard, minWildcard;

    RUNS_AT_DISPATCH_LEVEL
    found = NULL;
    minWildcard = 4;

    LOOP_THRU_PCB_LIST(pcb)

        if (pcb->type != type ||
            pcb->protocol != protocol && pcb->protocol != 0 ||
            pcb->srcport != toport)
            continue;

        wildcard = 0;
        if (pcb->srcaddr != toaddr) {
            if (pcb->srcaddr) continue;
            wildcard++;
        }

        if (pcb->dstaddr != fromaddr) {
            if (pcb->dstaddr) continue;
            wildcard++;
        }

        if (pcb->dstport != fromport) {
            if (pcb->dstport) continue;
            wildcard++;
        }

        if (wildcard == 0) return pcb;
        if (wildcard < minWildcard) {
            found = pcb;
            minWildcard = wildcard;
        }

    END_PCB_LIST_LOOP
    return found;
}


NTSTATUS
PcbUpdateBufferSize(
    PCB* pcb,
    INT sendBufsize,
    INT recvBufsize
    )

/*++

Routine Description:

    Update the send and receive buffer sizes

Arguments:

    pcb - Points to the PCB structure
    sendBufsize, recvBufsize - 
        Specifies the new send and receive buffer sizes

Return Value:

    Status code

--*/

{
    KIRQL irql;
    NTSTATUS status;

    if (sendBufsize > (INT) cfgMaxSendRecvBufsize)
        sendBufsize = (INT) cfgMaxSendRecvBufsize;
    else if (sendBufsize <= 0) {
        // NOTE: we never set actual send buffer size to 0
        // because we don't support the no-buffering option.
        sendBufsize = 1;
    }

    if (recvBufsize > (INT) cfgMaxSendRecvBufsize)
        recvBufsize = (INT) cfgMaxSendRecvBufsize;
    else if (recvBufsize <= 0)
        recvBufsize = 0;

    status = NETERR_OK;
    irql = RaiseToDpc();

    if (IsDgramPcb(pcb)) {
        // For datagram sockets, we'll just update the send and
        // receive buffers sizes. If the current buffers are bigger
        // than the specified limits, we'll leave the current data alone.
        pcb->maxSendBufsize = sendBufsize;
        pcb->maxRecvBufsize = recvBufsize;
    } else {
        TCB* tcb = (TCB*) pcb;

        // Set the send buffer size. If the current send buffer size
        // is larger than the specified limit, leave the current data untouched.
        tcb->maxSendBufsize = sendBufsize;
        
        // If the TCP socket is already connected,
        // don't allow the app to reduce the receive buffer size.
        if (!IsTcpIdleState(tcb) && recvBufsize < (INT) tcb->maxRecvBufsize) {
            status = NETERR_PARAM;
        } else {
            // NOTE: we don't update receive window to the connection peer
            // right away. The new window information will be sent
            // in the next outgoing ACK segment.
            tcb->maxRecvBufsize = recvBufsize;
        }
    }

    // NOTE: If the send buffer has just opened up,
    // we don't check to see if there is any pending
    // overlapped send request that can be started.
    // Rather the overlapped send request will be started
    // by the normal process.

    LowerFromDpc(irql);
    return status;
}


//
// Temporary port numbers are between 1024 and 4999 (inclusive)
// We're not using port number 5000 just as a safety precaution.
//
#define MIN_TEMP_PORT 1024
#define MAX_TEMP_PORT 4999
#define TEMP_PORT_COUNT (MAX_TEMP_PORT-MIN_TEMP_PORT+1)

INLINE IPPORT GenerateTempPort() {
    static USHORT nextTempPort = MAX_TEMP_PORT;
    if (++nextTempPort > MAX_TEMP_PORT)
        nextTempPort = MIN_TEMP_PORT;
    return HTONS(nextTempPort);
}


NTSTATUS
PcbBind(
    PCB* pcb,
    IPADDR srcaddr,
    IPPORT srcport
    )

/*++

Routine Description:

    Bind a socket to the specified local address

Arguments:

    pcb - Points to the protocol control block
    srcaddr, srcport - Specifies the local socket address

Return Value:

    Status code

--*/

{
    NTSTATUS status;
    INT retries = 1;
    KIRQL irql = RaiseToDpc();

    ASSERT(!IsPcbBound(pcb));

    if (pcb->type == SOCK_RAW) {
        // Port number is meaningless for raw sockets
        // and we always set it to 0.
        srcport = 0;
    } else if (srcport == 0) {
        // We're picking a randomly-generated port number.
        retries = min(cfgMaxSockets, TEMP_PORT_COUNT);
        srcport = GenerateTempPort();
    }

    while (TRUE) {
        PCB* cur;

        status = NETERR_OK;
        LOOP_THRU_PCB_LIST(cur)

            if (cur == pcb || !IsPcbBound(cur)) continue;

            // NOTE: Different raw sockets can bind to
            // the same address/protocol pair. This is
            // to follow win2k behavior.

            if ((pcb->type != SOCK_RAW) &&
                (cur->protocol == pcb->protocol) &&
                (cur->srcport == srcport) &&    // conflicting port number?
                (cur->bindSrcAddr == srcaddr || // conflicting address?
                 cur->bindSrcAddr == 0 ||
                 srcaddr == 0) &&
                (cur->exclusiveAddr ||          // address reuse disallowed?
                 pcb->exclusiveAddr ||
                 !pcb->reuseAddr)) {
                status = NETERR_ADDRINUSE;
                break;
            }

        END_PCB_LIST_LOOP

        if (status == NETERR_OK) {
            // If we're binding to a specific IP address,
            // loop through all the interfaces and
            // select the one with the matching address.
            if (srcaddr != 0) {
                IfInfo* ifp;

                ifp = IfFindInterface(srcaddr);
                if (ifp == NULL) {
                    status = NETERR(WSAEADDRNOTAVAIL);
                    break;
                }

                ASSERT(pcb->bindIfp == NULL);
                CACHE_IFP_REFERENCE(pcb->bindIfp, ifp);
            }
    
            pcb->srcaddr = pcb->bindSrcAddr = srcaddr;
            pcb->srcport = srcport;
            pcb->flags |= PCBFLAG_BOUND;
        } else {
            // The selected port is not available.
            // Check to see if we should try another one.
            if (--retries) {
                srcport = GenerateTempPort();
                continue;
            }
        }

        break;
    }

    LowerFromDpc(irql);
    return status;
}


NTSTATUS
PcbConnectDgram(
    PCB* pcb,
    IPADDR dstaddr,
    IPPORT dstport
    )

/*++

Routine Description:

    Connect a datagram socket to the specified foreign address

Arguments:

    pcb - Points to the protocol control block
    dstaddr, dstport - Specifies the foreign socket address

Return Value:

    Status code

--*/

{
    KIRQL irql;
    NTSTATUS status;

    if (pcb->type == SOCK_RAW) {
        // Port number for raw sockets is meaningless
        dstport = 0;
    } else {
        if (dstaddr == 0 && dstport != 0 ||
            dstaddr != 0 && dstport == 0)
            return NETERR(WSAEADDRNOTAVAIL);
    }

    // Destination hasn't changed, no need to do anything
    if (dstaddr == pcb->dstaddr && dstport == pcb->dstport)
        return NETERR_OK;

    // Is this socket allowed to send broadcast
    // datagrams on this socket?
    if (IS_BCAST_IPADDR(dstaddr) && !pcb->broadcast)
        return NETERR(WSAEACCES);

    irql = RaiseToDpc();

    // If the socket is currently connected,
    // we need to disconnect it first.
    if (IsPcbConnected(pcb)) {
        pcb->flags &= ~PCBFLAG_CONNECTED;
        pcb->dstaddr = 0;
        pcb->dstport = 0;
        pcb->srcaddr = pcb->bindSrcAddr;
        if (pcb->rte) {
            IpReleaseCachedRTE(pcb->rte);
            pcb->rte = NULL;
        }
    }

    // Discard any received packets that have been
    // queued up but not yet processed
    PcbFlushRecvBuffers(pcb);

    if (dstaddr != 0) {
        // Bind to a local address if necessary
        if (!IsPcbBound(pcb)) {
            status = PcbBind(pcb, 0, 0);
            if (!NT_SUCCESS(status)) {
                LowerFromDpc(irql);
                return status;
            }
        }
        
        if (!IS_MCAST_IPADDR(dstaddr)) {
            // Find a route to the connected destination.
            // And if we're bound to a wildcard source address,
            // then we'll pick a specific source address here
            // based on the route.

            ASSERT(pcb->rte == NULL);
            pcb->rte = IpFindRTE(dstaddr, NULL);
            if (!pcb->rte) {
                LowerFromDpc(irql);
                return NETERR_UNREACHABLE;
            }

            RteAddRef(pcb->rte);
            if (pcb->bindSrcAddr == 0) {
                pcb->srcaddr = PcbGetDefaultSrcAddr(pcb->rte);
            }
        }

        pcb->flags |= PCBFLAG_CONNECTED;
        pcb->dstaddr = dstaddr;
        pcb->dstport = dstport;
    }

    LowerFromDpc(irql);
    return NETERR_OK;
}


VOID
PcbSetupIpHeader(
    PCB* pcb,
    Packet* pkt,
    IpAddrPair* addrpair
    )

/*++

Routine Description:

    Prepare the IP header information in an outgoing packet
    using the connection information from the PCB.

Arguments:

    pcb - Points to a connected PCB
    pkt - Points to the outgoing packet
    addrpair - Specifies the source and destination address pair

Return Value:

    NONE

Note:

    This function really belong to the ..\ip\ipsend.c.
    We duplicate the code here to save a function call (with
    large number of parameters).

--*/

{
    UINT iphdrlen;
    IpHeader* iphdr;

    iphdrlen = IPHDRLEN + ROUNDUP4(pcb->ipoptlen);
    pkt->data -= iphdrlen;
    iphdr = (IpHeader*) pkt->data;
    SETPKTIPHDR(pkt, iphdr);
    pkt->datalen += iphdrlen;

    if (pcb->ipoptlen) {
        ZeroMem(iphdr+1, iphdrlen-IPHDRLEN);
        CopyMem(iphdr+1, pcb->ipopts, pcb->ipoptlen);
    }

    FILL_IPHEADER(
        iphdr,
        iphdrlen,
        pcb->ipTos,
        pkt->datalen,
        pcb->ipDontFrag ? HTONS(DONT_FRAGMENT) : 0,
        IS_BCAST_IPADDR(addrpair->dstaddr) ? 1 :
            IS_MCAST_IPADDR(addrpair->dstaddr) ? pcb->mcastTtl : pcb->ipTtl,
        pcb->protocol,
        addrpair->srcaddr,
        addrpair->dstaddr);
}


NTSTATUS
PcbWaitForEvent(
    PCB* pcb,
    INT eventMask,
    UINT timeout
    )

/*++

Routine Description:

    Block the current thread until the specified PCB event is signalled

Arguments:

    pcb - Points to the protocol control block
    eventMask - Flag bit to indicate which event to block on
    timeout - Specifies the wait timeout (in milliseconds, 0 means forever)

Return Value:

    Status code

--*/

{
    INT readyMask;
    NTSTATUS status = NETERR_OK;

    //
    // Check if the specified event is already available
    // or if the socket connection has been reset.
    //
    readyMask = PcbCheckSelectEvents(pcb, eventMask, 1);
    if (readyMask & PCBEVENT_CONNRESET) goto exit;
    if (readyMask != 0) return NETERR_OK;

    status = WaitKernelEventObject(GetPcbWaitEvent(pcb), timeout);
    PcbClearSelectEvents(pcb);

exit:
    return NT_SUCCESS(status) ? PcbGetErrStatus(pcb) : status;
}


INT
PcbCheckSelectEvents(
    PCB* pcb,
    INT eventMasks,
    INT setwait
    )

/*++

Routine Description:

    Check if the specified socket events are available
    and optionally set up the socket to wait for them

Arguments:

    pcb - Points to the protocol control block
    eventMasks - Specifies the socket events the caller is interested in
    setwait - Whether to set up the sockets to wait if 
        none of the specified events are avaiable

Return Value:

    Set of event flags that are already available

--*/

{
    NTSTATUS status;
    INT readyMasks;
    KIRQL irql = RaiseToDpc();

    // Check to see if the specified event is already available
    // Since our checks are trivial, it's faster to check
    // everything instead of trying to check selectively
    // based on the flags specified by the caller.
    
    if (IsTcb(pcb)) {
        // If the connection was reset, return reset status
        status = PcbGetErrStatus(pcb);
        if (!NT_SUCCESS(status)) {
            // Note: If we already told the app that the socket was connected
            // and then the socket got resetted, we don't need to set the socket
            // in the exceptfds again to tell the app the connection has failed.
            if (eventMasks != PCBEVENT_CONNRESET || !pcb->connectSelected) {
                LowerFromDpc(irql);
                return PCBEVENT_CONNRESET;
            }
        }

        readyMasks = (IsTcpRecvBufEmpty(pcb) ? 0 : PCBEVENT_READ) |
                     (TcbHasPendingConnReq((TCB*) pcb) ? PCBEVENT_ACCEPT : 0) |
                     (IsFINReceived(pcb) ? PCBEVENT_READ|PCBEVENT_CLOSE : 0);

        if (IsPcbConnected(pcb)) {
            if (!IsPcbSendBufFull(pcb)) readyMasks |= PCBEVENT_WRITE;

            // NOTE: we only signal the connect event exactly once
            if ((eventMasks & PCBEVENT_CONNECT) && !pcb->connectSelected) {
                readyMasks |= PCBEVENT_CONNECT;
                if (setwait >= 0) pcb->connectSelected = 1;
            }
        }
    } else {
        readyMasks = (IsDgramRecvBufEmpty(pcb) ? 0 : PCBEVENT_READ) |
                     (IsPcbSendBufFull(pcb) ? 0 : PCBEVENT_WRITE);
    }

    if ((readyMasks &= eventMasks) == 0 && setwait) {
        // Indicate that we're interested in the specified event
        // and prepare to wait
        pcb->eventFlags = eventMasks;
        KeClearEvent(GetPcbWaitEvent(pcb));
    }

    LowerFromDpc(irql);
    return readyMasks;
}


VOID
PcbCompleteOverlappedSendRecv(
    PcbOverlappedReq* req,
    NTSTATUS status
    )

/*++

Routine Description:

    Complete an overlapped send/receive request

Arguments:

    req - Points to the overlapped send/receive request
    status - Specifies the completion status

Return Value:

    NONE

--*/

{
    PCB* pcb = req->pcb;

    // NOTE: we can have at most 1 overlapped send/receive request
    if ((RECVREQ*) req == pcb->overlappedRecvs) {
        pcb->overlappedRecvs = NULL;
    } else if ((SENDREQ*) req == pcb->overlappedSends) {
        pcb->overlappedSends = NULL;
    }

    req->overlapped->_iostatus = status;
    SetKernelEvent(req->overlappedEvent);

    // If the wait event is our internal per-PCB event,
    // then this is a special case for implementing the
    // blocking recv call. See comments in PcbQueueOverlappedRecv.

    if (req->overlappedEvent != GetPcbWaitEvent(req->pcb)) {
        ObDereferenceObject(req->overlappedEvent);
        SysFree(req);
    }
}


NTSTATUS
PcbQueueOverlappedRecv(
    PCB* pcb,
    RECVREQ* recvreq
    )

/*++

Routine Description:

    Queue up an overlapped receive request

Arguments:

    pcb - Points to the protocol control block
    recvreq - Points to the receive request

Return Value:

    Status code

--*/

{
    RECVREQ* newreq;

    // Queue up an overlapped receive request.
    // We only support 1 outstanding overlapped receive request.
    if (HasOverlappedRecv(pcb) || !recvreq->overlappedEvent)
        return NETERR_WOULDBLOCK;

    if (recvreq->overlappedEvent == GetPcbWaitEvent(pcb)) {
        // If the wait event is our internal per-PCB event,
        // then this is a special case for implementing the
        // blocking recv call.
        //
        // In this case, we avoid an allocation by directly
        // queuing up the RECVREQ structure that was passed
        // in from the caller (winsock layer). This works because
        // the caller will wait for the recv to complete after
        // this function returns.

        newreq = recvreq;
    } else {
        newreq = (RECVREQ*) SysAlloc(sizeof(RECVREQ), PTAG_RREQ);
        if (!newreq) return NETERR_MEMORY;
        *newreq = *recvreq;
    }

    pcb->overlappedRecvs = newreq;
    newreq->pcb = pcb;
    newreq->overlapped->_ioxfercnt = 0;
    newreq->overlapped->_ioflags = 0;
    newreq->overlapped->_ioreq = (UINT_PTR) newreq;
    newreq->overlapped->_iostatus = (DWORD) NETERR_PENDING;
    return NETERR_PENDING;
}


NTSTATUS
PcbQueueOverlappedSend(
    PCB* pcb,
    SENDREQ* sendreq
    )

/*++

Routine Description:

    Queue up an overlapped send request

Arguments:

    pcb - Points to the protocol control block
    sendreq - Points to the overlapped send request

Return Value:

    Status code:
        NETERR_PENDING - the request was successfully queued up
        NETERR_OK - if the send buffer has opened up and
            there is no need to queue up the request
        otherwise - the request was not queued up due to an error

--*/

{
    NTSTATUS status;
    KIRQL irql = RaiseToDpc();

    if (HasOverlappedSend(pcb)) {
        // We only support 1 outstanding overlapped send request.
        status = NETERR_WOULDBLOCK;
    } else if (!IsPcbSendBufFull(pcb)) {
        // The send buffer opened up just as
        // we were raising to DPC level
        status = NETERR_OK;
    } else {
        SENDREQ* newreq;
        UINT size = sizeof(SENDREQ) +
                    (sendreq->toaddr ? sizeof(*sendreq->toaddr) : 0) +
                    sizeof(WSABUF) * sendreq->bufcnt;

        newreq = (SENDREQ*) SysAlloc(size, PTAG_RREQ);
        if (!newreq) {
            // Out of memory
            status = NETERR_MEMORY;
        } else {
            VOID* bufs;

            pcb->overlappedSends = newreq;
            *newreq = *sendreq;
            bufs = newreq+1;
            if (sendreq->toaddr) {
                newreq->toaddr = (struct sockaddr_in*) bufs;
                *newreq->toaddr = *sendreq->toaddr;
                bufs = newreq->toaddr + 1;
            }

            newreq->bufs = (WSABUF*) bufs;
            CopyMem(bufs, sendreq->bufs, sizeof(WSABUF) * sendreq->bufcnt);

            newreq->pcb = pcb;
            newreq->overlapped->_ioxfercnt = 0;
            newreq->overlapped->_ioflags = 0;
            newreq->overlapped->_ioreq = (UINT_PTR) newreq;
            newreq->overlapped->_iostatus = status = NETERR_PENDING;
        }
    }

    LowerFromDpc(irql);
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\tcp\tcpinit.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    tcpinit.c

Abstract:

    TCP/UDP initialization and cleanup related functions.

Revision History:

    05/24/2000 davidx
        Created it.

    06/30/2000 davidx
        Added TCP timer functions here.

--*/

#include "precomp.h"

//
// TCP timer objects and function
//
PRIVATE KTIMER TcpFastTimer;
PRIVATE KDPC TcpFastTimerDpc;
PRIVATE UINT TcpTimerFlag;

// TCP slow timer tick count (incremented every 500ms)
UINT TcpTickCount;

// Fast TCP timer fires every 200ms
#define FAST_TCP_TIMER_FREQ 5


PRIVATE VOID
TcpFastTimerProc(
    PKDPC dpc,
    VOID* context,
    VOID* param1,
    VOID* param2
    )

/*++

Routine Description:

    TCP fast (200ms cycle) timer routine

Arguments:

    dpc, context, param1, param2 - DPC function parameters

Return Value:

    NONE

--*/

{
    PCB* pcb;
    TCB* tcb;
    UINT isSlowTick;

    TcpTimerFlag = TcpTimerFlag << 1;

    // The slow timer has 500ms cycle.
    // NOTE: 500 is not an exact multiple of 200. So we end up firing
    // once after 400ms and again after 600ms. The approximation should
    // be good enough for our purpose. It saves us from having two timers.
    isSlowTick = (TcpTimerFlag & 0x24);
    if (isSlowTick) TcpTickCount++;

    LOOP_THRU_PCB_LIST(pcb)

        if (!IsTcb(pcb)) continue;
        tcb = (TCB*) pcb;

        // The fast timer is used to implement the TCP delayed-ACK feature
        if (tcb->delayedAcks) {
            TcbEmitACK(tcb);
        }

        if (isSlowTick) {
            // Connection establishment timer expired
            if (tcb->synTimer && --tcb->synTimer == 0) {
                if (TcbReset(tcb, NETERR_TIMEOUT) == NULL) continue;
            }

            // Transmission timer expired
            if (tcb->xmitTimer && --tcb->xmitTimer == 0) {
                if (TcbXmitTimeout(tcb) == NULL) continue;
            }

            // Time-wait period expired or linger period expired
            if (tcb->timeWaitTimer && --tcb->timeWaitTimer == 0) {
                ASSERT(TcbIsLingering(tcb));
                TcbDelete(tcb);
            }
        }

    END_PCB_LIST_LOOP

    // IP timer fires once every second
    if (TcpTimerFlag == (1 << FAST_TCP_TIMER_FREQ)) {
        TcpTimerFlag = 1;
        IpTimerProc();
    }
}


NTSTATUS
TcpInitialize()

/*++

Routine Description:

    Initialize TCP/UDP protocol module

Arguments:

    NONE

Return Value:

    Status code

--*/

{
    LARGE_INTEGER dueTime;
    UINT period;
    NTSTATUS status;

    InitializeListHead(&PcbList);
    InitializeListHead(&DeadTcbList);
    PcbCount = 0;

    // Initialize the TCP timers:
    //  fast timer has a 200ms cycle
    //  initial due time is 1sec

    TcpTickCount = 1;
    dueTime.QuadPart = -10000000;

    period = 1000 / FAST_TCP_TIMER_FREQ;
    KeInitializeDpc(&TcpFastTimerDpc, TcpFastTimerProc, NULL);
    KeInitializeTimer(&TcpFastTimer);
    KeSetTimerEx(&TcpFastTimer, dueTime, period, &TcpFastTimerDpc);

    // Initialize the IP module
    status = IpInitialize();
    TcpTimerFlag = 1;
    return status;
}


VOID
TcpCleanup()

/*++

Routine Description:

    Clean up TCP/UDP protocol module

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    RUNS_AT_DISPATCH_LEVEL

    if (!TcpTimerFlag) return;
    TcpTimerFlag = 0;

    // Cancel TCP timers
    KeCancelTimer(&TcpFastTimer);

    // Clean up the IP module
    IpCleanup();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\test\gethost\precomp.h ===
#include "xnetp.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\test\sources.inc ===
TARGETPATH=obj
TARGETTYPE=PROGRAM
UMTYPE=xboxapp

INCLUDES=$(INCLUDES);$(PRIVATE_INC_PATH);$(SDK_INC_PATH);..\lib

TARGETLIBS= \
    ..\lib\$(O)\xnettest.lib \
    $(LIBRARY_PATH)\xnet$(D).lib
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\test\filexfer\filexfer.c ===
// File transfer program using a TCP connection

#include "precomp.h"

#define TESTPORT 600
#define RCVTIMEOUT 15000
#define RCVBUFSIZE 4096

INT testFlag = 1;
INT err;
ULONG total;
CHAR filename[MAX_PATH];
CHAR recvbuf[RCVBUFSIZE];
BOOL noWrite;


VOID
DoGetFile(
    SOCKET s,
    CHAR* filename
    )
{
    SeqFile* file;
    DWORD timer = GetTickCount();
    DWORD buflen, count;

    file = _CreateFile(filename, GENERIC_READ);
    if (!file) {
        WARNFAIL(CreateFile);
        return;
    }

    total = 0;
    do {
        CHAR* p;
        count = cfgSeqFileBufSize;
        if (!_ReadFile(file, &p, &count)) {
            WARNFAIL(ReadFile); goto exit;
        }

        total += count;
        buflen = count;
        while (buflen) {
            DWORD n = buflen;
            err = _send(s, p, &n);
            if (err != NO_ERROR) {
                WARNFAIL(send); goto exit;
            }

            p += n;
            buflen -= n;
        }
    } while (count == cfgSeqFileBufSize);

    timer = GetTickCount() - timer;
    if (timer == 0) timer = 1;
    DbgPrint("  total bytes transferred: %d\n", total);
    DbgPrint("  time: %dmsec, rate: %d bytes/sec\n", timer, MulDiv(total, 1000, timer));

exit:
    _CloseFile(file);
}


VOID
DoPutFile(
    SOCKET s,
    CHAR* filename
    )
{
    SeqFile* file;
    DWORD timer = GetTickCount();
    DWORD count;

    file = _CreateFile(filename, GENERIC_WRITE);
    if (!file) {
        WARNFAIL(CreateFile);
        return;
    }

    total = 0;
    while (TRUE) {
        count = RCVBUFSIZE;
        err = _recv(s, recvbuf, &count);
        if (err != NO_ERROR) {
            WARNFAIL(recv); goto exit;
        }

        if (count == 0) break;
        total += count;
        if (count && !noWrite) {
            if (!_WriteFile(file, recvbuf, count)) {
                WARNFAIL(WriteFile); goto exit;
            }
        }
    }

    timer = GetTickCount() - timer;
    if (timer == 0) timer = 1;
    DbgPrint("  total bytes transferred: %d\n", total);
    DbgPrint("  time: %dmsec, rate: %d bytes/sec\n", timer, MulDiv(total, 1000, timer));

exit:
    _CloseFile(file);
}


BOOL
GetXferRequest(
    IN SOCKET s,
    OUT BOOL* getFile,
    OUT CHAR* filename
    )
{
    DWORD buflen = RCVBUFSIZE;

    err = _recv(s, recvbuf, &buflen);
    if (err != NO_ERROR) {
        WARNFAIL(recv);
        return FALSE;
    }

    if (buflen <= 4 || buflen >= 4+MAX_PATH) goto badreq;

    if (strncmp(recvbuf, "GET ", 4) == 0)
        *getFile = TRUE;
    else if (strncmp(recvbuf, "PUT ", 4) == 0)
        *getFile = FALSE;
    else
        goto badreq;
    
    CopyMem(filename, &recvbuf[4], buflen-4);
    filename[buflen-4] = 0;

    DbgPrint("%s %s\n", *getFile ? "GET" : "PUT", filename);
    return TRUE;

badreq:
    DbgPrint("Bad file transfer request\n");
    return FALSE;
}


VOID
FileXfer()
{
    SOCKET sock, s;
    struct sockaddr_in sockname;
    INT total;
    DWORD timer;
    BOOL getFile;

    s = INVALID_SOCKET;
    sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock == INVALID_SOCKET) {
        WARNFAIL(socket); goto exit;
    }

    ZeroMem(&sockname, sizeof(sockname));
    sockname.sin_family = AF_INET;
    sockname.sin_port = htons(TESTPORT);
    sockname.sin_addr.s_addr = INADDR_ANY;

    err = _bind(sock, &sockname);
    if (err != NO_ERROR) {
        WARNFAIL(bind); goto exit;
    }

    err = listen(sock, 3);
    if (err != NO_ERROR) {
        WARNFAIL(listen); goto exit;
    }

    err = _getsockname(sock, &sockname);
    if (err != NO_ERROR) {
        WARNFAIL(getsockname); goto exit;
    }

    DbgPrint("Listening on: %s:%d\n",
             inet_ntoa(sockname.sin_addr),
             ntohs(sockname.sin_port));

    s = _accept(sock, &sockname);
    if (s == INVALID_SOCKET) {
        WARNFAIL(accept); goto exit;
    }

    err = _setrcvtimeout(s, RCVTIMEOUT);
    if (err != NO_ERROR) {
        WARNFAIL(setrcvtimeout); goto exit;
    }

    DbgPrint("Connected to: %s:%d\n",
             inet_ntoa(sockname.sin_addr),
             ntohs(sockname.sin_port));

    if (GetXferRequest(s, &getFile, filename)) {
        if (getFile) {
            DoGetFile(s, filename);
        } else {
            DoPutFile(s, filename);
        }
    }

exit:
    if (s != INVALID_SOCKET) { closesocket(s); }
    if (sock != INVALID_SOCKET) { closesocket(sock); }
}


void __cdecl main()
{
    WSADATA wsadata;

    DbgPrint("Loading XBox network stack...\n");
    err = XnetInitialize(NULL, TRUE);
    if (err != NO_ERROR) {
        WARNFAIL(XnetInitialize); goto stop;
    }

    DbgPrint("*** Test started, press 'g' to continue...\n");

    while (TRUE) {
        DbgPrint("*** To quit, press CTRL-C and type: ed %x 0;g\n", &testFlag);
        Sleep(1000);
        BREAK_INTO_DEBUGGER

        if (testFlag <= 0) break;
        err = WSAStartup(WINSOCK_VERSION, &wsadata);
        if (err != NO_ERROR) {
            WARNFAIL(WSAStartup); goto unload;
        }

        if (testFlag == 1) {
            FileXfer();
        }
        WSACleanup();
    }

unload:
    DbgPrint("Unloading XBox network stack...\n");
    XnetCleanup();

stop:
    if (testFlag == 0)
        HalReturnToFirmware(HalRebootRoutine);
    else
        Sleep(INFINITE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\tcp\tcprecv.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    tcprecv.c

Abstract:

    TCP input processing functions

Revision History:

    05/31/2000 davidx
        Created it.

--*/

#include "precomp.h"


//
// Update the receive window information after accepting
// the specified amount data from the connection peer.
//
INLINE VOID
TcbSlideRecvWindow(
    TCB* tcb,
    UINT datalen
    )
{
    UINT newwnd = tcb->maxRecvBufsize - tcb->recvbufSize;

    // Here datalen must be <= rcv_wnd.
    ASSERT(datalen <= tcb->rcv_wnd);
    tcb->rcv_nxt += datalen;

    if ((datalen + newwnd) - tcb->rcv_wnd >= tcb->rcv_swsthresh) {
        // Enough space has freed up. Move the right edge of the receive window.
        tcb->rcv_wnd = newwnd;
    } else {
        // Implement receive side silly window avoidance:
        //  keep the right edge of the receive window unchanged.
        tcb->rcv_wnd -= datalen;
    }
}


//
// Copy data from the TCB receive buffer to the user's receive buffer
//
PRIVATE UINT
TcbCopyRecvData(
    TCB* tcb,
    RECVREQ* recvreq
    )
{
    RECVBUF* recvbuf;
    UINT copycnt, total = 0;
    BYTE tcpflags = 0;

    do {
        recvbuf = (RECVBUF*) tcb->recvbuf.Flink;
        ASSERT(SEQ_LE(recvbuf->seqnext, tcb->rcv_nxt));

        copycnt = min(recvbuf->datalen, recvreq->buflen);
        CopyMem(recvreq->buf, (BYTE*) recvbuf + recvbuf->dataoffset, copycnt);
        total += copycnt;
        tcb->recvbufSize -= copycnt;
        recvreq->buf += copycnt;
        recvreq->buflen -= copycnt;

        tcpflags |= recvbuf->tcpflags;
        if (copycnt == recvbuf->datalen) {
            RemoveEntryList(&recvbuf->links);
            XnetFree(recvbuf);
        } else {
            recvbuf->dataoffset = (WORD) (recvbuf->dataoffset + copycnt);
            recvbuf->datalen -= copycnt;
        }
    } while (recvreq->buflen && !IsTcpRecvBufEmpty(tcb));

    if (tcpflags & (TCP_PSH|TCP_URG))
        recvreq->buflen = 0;

    return total;
}


NTSTATUS
TcbRecv(
    TCB* tcb,
    RECVREQ* recvreq
    )

/*++

Routine Description:

    Handle a user request to receive data from a TCP socket

Arguments:

    tcb - Points to the TCP control block
    recvreq - Points to the receive request information

Return Value:

    Status code

--*/

{
    NTSTATUS status;
    UINT oldrcvwnd;
    KIRQL irql = RaiseToDpc();

    // Only segments from the connection peer are accepted
    SetRecvReqFromAddr(recvreq, tcb->dstaddr, tcb->dstport);
    *recvreq->bytesRecv = 0;

    if (!IsTcpRecvBufEmpty(tcb)) {

        // If the receive buffer is not empty, return as much data
        // as possible from the receive buffer.

        (*recvreq->bytesRecv) += TcbCopyRecvData(tcb, recvreq);
        status = NETERR_OK;

        // If the receive window was closed and there is
        // now enough free spce in the receive buffer,
        // then we'll send out a gratuitous ACK here.

        oldrcvwnd = tcb->rcv_wnd;
        TcbSlideRecvWindow(tcb, 0);
        if (oldrcvwnd < tcb->rcv_swsthresh &&
            tcb->rcv_wnd >= tcb->rcv_swsthresh) {
            TcbEmitACK(tcb);
        }
    } else if (IsFINReceived(tcb)) {
        // The connection has been gracefully closed
        status = NETERR_OK;
    } else {
        status = PcbGetErrStatus(tcb);
        if (NT_SUCCESS(status)) {
            status = PcbQueueOverlappedRecv((PCB*) tcb, recvreq);
        }
    }

    LowerFromDpc(irql);
    return status;
}


PRIVATE VOID
TcbUpdateRTO(
    TCB* tcb
    )

/*++

Routine Description:

    Update the round-trip time measurements for a TCP connection

Arguments:

    tcb - Points to the TCP control block

Return Value:

    NONE

--*/

{
    INT nticks, delta;

    // The computation is based on the following formula:
    //  delta = nticks - srtt
    //  srtt = srtt + delta / 8
    //  rttvar = rttvar + (|delta| - rttvar) / 4
    //  RTO = srtt + 4 * rttvar

    nticks = TcpTickCount - tcb->rtt_tick;
    tcb->rtt_tick = 0;

    if (tcb->srtt_8 != 0) {
        delta = nticks - (tcb->srtt_8 >> SRTT_SHIFT);
        if ((tcb->srtt_8 += delta) <= 0)
            tcb->srtt_8 = 1;

        if (delta < 0) delta = -delta;
        delta -= (tcb->rttvar_4 >> RTTVAR_SHIFT);
        if ((tcb->rttvar_4 += delta) <= 0)
            tcb->rttvar_4 = 1;
    } else {
        // The very first measurement - use the unsmoothed data
        if (nticks == 0) {
            tcb->srtt_8 = tcb->rttvar_4 = 1;
        } else {
            tcb->srtt_8 = nticks << SRTT_SHIFT;
            tcb->rttvar_4 = nticks << (RTTVAR_SHIFT-1);
        }
    }

    tcb->RTO = (tcb->srtt_8 >> SRTT_SHIFT) + tcb->rttvar_4;
    if (tcb->RTO < cfgMinRexmitTimeout)
        tcb->RTO = cfgMinRexmitTimeout;
}


PRIVATE BOOL
TcbUpdatePersistFlag(
    TCB* tcb
    )

/*++

Routine Description:

    This function is called after the send window information is updated.
    If we're currently sending out window probing segments, then
    we'll stop doing so if the send window has opened up.

Arguments:

    tcb - Points to the TCP control block

Return Value:

    FALSE if we got out of persist mode
    TRUE otherwise

--*/

{
    TCPSENDBUF* sendbuf = TcbFirstSendbuf(tcb);
    ASSERT(!IsPcbSendBufEmpty(tcb));

    if (sendbuf->datalen <= tcb->snd_wnd) {
        tcb->persistFlag = 0;
        if (sendbuf->retries) {
            TRACE_("Retransmit persisting segment...");
            sendbuf->retries = 0;
            TcbSendSegment(tcb, sendbuf);
        } else {
            tcb->xmitTimer = 0;
        }
        return FALSE;
    }
    return TRUE;
}


PRIVATE VOID
TcbUpdateSndUna(
    TCB* tcb,
    TCPSEQ ack
    )

/*++

Routine Description:

    Update the snd.una variable for a TCP connection

Arguments:

    tcb - Points to the TCP connection block
    ack - The acknowledged sequence number

Return Value:

    NONE

--*/

{
    TCPSENDBUF* sendbuf;
    UINT ackedSends = 0;

    if (SEQ_GT(ack, tcb->snd_una)) {
        tcb->snd_una = ack;

        // Update round-trip time measurements
        if (tcb->rtt_tick && SEQ_GT(ack, tcb->rtt_seq)) {
            TcbUpdateRTO(tcb);
        }

        // Complete fully acknowledged send user requests

        LOOP_THRU_TCB_SENDBUF(tcb, sendbuf)

            if (sendbuf->retries && SEQ_GE(ack, sendbuf->seqnext)) {
                RemoveEntryList(&sendbuf->links);
                tcb->sendbufSize -= sendbuf->datalen;
                ackedSends++;
                SendbufRelease(sendbuf);
            } else {
                break;
            }

        END_TCB_SENDBUF_LOOP
    }

    // Update congestion window
    if (tcb->fastRexmitFlag) {
        if (ackedSends) {
            //
            // Getting out of fast retransmit / fast recovery mode:
            //  "deflate" the congestion window
            //
            tcb->snd_cwnd = tcb->snd_ssthresh;
        } else {
            //
            // In fast recovery mode:
            //  increment the congestion window by SMSS
            //  for every duplicate ACK received.
            //
            TcbIncrementCwnd(tcb, tcb->snd_mss);
        }
    } else {
        if (tcb->snd_cwnd < tcb->snd_ssthresh) {
            //
            // Slow-start mode:
            //  increment the congestion window by SMSS
            //
            TcbIncrementCwnd(tcb, tcb->snd_mss);
        } else {
            //
            // Congestion avoidance mode:
            //  increment the congestion window by ~SMSS per RTT
            //
            // NOTE: Overflow is not possible here because snd_mss
            // and snd_cwnd are 16-bit numbers. Also snd_cwnd is never 0.
            //
            UINT inc = tcb->snd_mss * tcb->snd_mss / tcb->snd_cwnd;
            TcbIncrementCwnd(tcb, max(1, inc));
        }
    }

    if (ackedSends) {
        if (!IsPcbSendBufFull(tcb)) {
            if (HasOverlappedSend(tcb)) {
                SENDREQ* sendreq = PcbGetOverlappedSend((PCB*) tcb);
                NTSTATUS status = TcbSend(tcb, sendreq);

                sendreq->overlapped->_ioxfercnt = sendreq->sendtotal;
                PcbCompleteOverlappedSend(sendreq, status);
            } else {
                PcbSignalEvent(tcb, PCBEVENT_WRITE);
            }
        }
        tcb->persistFlag = 0;
        TcbStopFastRexmitMode(tcb);

        // Reset retransmission timer
        if (tcb->snd_una == tcb->snd_nxt)
            tcb->xmitTimer = 0;
        else {
            sendbuf = TcbFirstSendbuf(tcb);
            if (sendbuf->firstSendTime + tcb->RTO <= TcpTickCount) {
                TcbXmitTimeout(tcb);
            } else {
                tcb->xmitTimer = sendbuf->firstSendTime + tcb->RTO - TcpTickCount;
            }
        }

    } else if (tcb->persistFlag) {

        // If we're probing the send window and the ack was for
        // the probe segment, then make sure we continue to probe
        // without timing out.

        sendbuf = TcbFirstSendbuf(tcb);
        if (SEQ_GE(ack, sendbuf->seq) &&
            sendbuf->retries >= cfgMaxXmitRetries-1) {
            sendbuf->retries--;
        }

    } else {
        if (tcb->snd_una != tcb->snd_nxt &&
            !tcb->fastRexmitFlag &&
            ++tcb->dupacks >= 4) {
            //
            // Too many duplicate ACK received:
            //  do fast retransmit / recovery
            //
            TcbDoFastRexmit(tcb);
        }
    }

    // If the send window has opened up and
    // we have pending data to sent, try to do it now.
    if (!tcb->persistFlag || !TcbUpdatePersistFlag(tcb)) {
        while (TcbHasPendingSend(tcb) && TcbStartOutput(tcb))
            NULL;
    }
}


// 
// Check if an acknowledged sequence number is valid for a TCP connection
//
#define IsValidACK(_tcb, _ack) \
        (SEQ_GT((_ack), (_tcb)->snd_una) && \
         SEQ_LE((_ack), (_tcb)->snd_nxt))

//
// Indicate whether we should send out an ACK immediately
// in response to an incoming segment.
//
#define NeedSendACKNow(_tcb) ((_tcb)->delayedAcks += 0x20000)

//
// Save the send window information from the connection peer
//
#define TcbUpdateSndWnd(_tcb, _wnd, _seq, _ack) { \
            (_tcb)->snd_wnd = (_wnd); \
            (_tcb)->snd_wl1 = (_seq); \
            (_tcb)->snd_wl2 = (_ack); \
        }


PRIVATE BOOL
TcbValidateSeqs(
    TCB* tcb,
    TCPSEQ oldseq0,
    TCPSEQ oldseq1,
    TCPSEQ* newseq0,
    TCPSEQ* newseq1
    )

/*++

Routine Description:

    Check if the received sequence number is valid for a TCP connection

Arguments:

    tcb - Points to TCP control block
    oldseq0 - Starting sequence number from the received segment
    oldseq1 - Ending sequence number from the received segment (oldseq+seglen)
    newseq0 - Returns the effective starting sequence number inside the receive window
    newseq1 - Returns the effective ending sequence number

Return Value:

    FALSE if none of the received segment is inside the receive window,
    TRUE otherwise. In the latter case, seq0 and seq1 will return updated
    sequence numbers.

--*/

{
    TCPSEQ rcv_last;

    rcv_last = tcb->rcv_nxt + tcb->rcv_wnd;
    *newseq0 = SEQ_LT(oldseq0, tcb->rcv_nxt) ? tcb->rcv_nxt : oldseq0;
    *newseq1 = SEQ_GT(oldseq1, rcv_last) ? rcv_last : oldseq1;

    return SEQ_LT(*newseq0, *newseq1) ||
           (*newseq0 == *newseq1 && oldseq0 == oldseq1);
}


#if DBG

PRIVATE BOOL
TcbVerifyRecvBuf(
    TCB* tcb
    )

/*++

Routine Description:

    Verify the current receive buffers for a TCB is good

Arguments:

    tcb - Points to the TCP control block

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    RECVBUF* buf0 = (RECVBUF*) tcb->recvbuf.Flink;
    RECVBUF* buf1;

    if (buf0 == TcbRecvbufNil(tcb)) return TRUE;
    while (TRUE) {
        buf1 = TcbRecvbufFlink(buf0);
        if (buf1 == TcbRecvbufNil(tcb)) return TRUE;
        if (SEQ_GT(buf0->seqnext, buf1->seqnext-buf1->datalen)) return FALSE;
        buf0 = buf1;
    }
}

#endif // DBG


PRIVATE UINT
TcbCorrectMisorderedSegments(
    TCB* tcb,
    TCPSEQ seq,
    RECVBUF* recvbuf
    )

/*++

Routine Description:

    This function is called when we receive a segment
    whose starting sequence number matches rcv_nxt and
    there are buffered out-of-order segments after this one.

Arguments:

    tcb - Points to TCP control block
    seq - Specifies the starting sequence number for this segment
    recvbuf - Points to the received data buffer

Return Value:

    Number of continuous bytes that can be acknowledged

--*/

{
    RECVBUF* buf0 = TcbLastRecvbuf(tcb);
    RECVBUF* buf1;
    UINT count;

    do {
        buf0 = TcbRecvbufBlink(buf0);
    } while (buf0 != TcbRecvbufNil(tcb) && buf0->seqnext != seq);

    buf1 = TcbRecvbufFlink(buf0);
    if (SEQ_GT(recvbuf->seqnext, buf1->seqnext - buf1->datalen)) {
        // Weird case: data in this segment overlapps with
        // data in the buffered out-of-order segments.
        // Chop off the overlapped data in the current receive buffer.
        TRACE_("TcbCorrectMisorderedSegments: overlapping segment");

        count = recvbuf->seqnext - (buf1->seqnext - buf1->datalen);
        ASSERT(count < recvbuf->datalen);

        recvbuf->datalen -= count;
        recvbuf->seqnext -= count;
    }

    // Insert recvbuf after buf0 and before buf1
    buf0->links.Flink = buf1->links.Blink = (LIST_ENTRY*) recvbuf;
    recvbuf->links.Flink = (LIST_ENTRY*) buf1;
    recvbuf->links.Blink = (LIST_ENTRY*) buf0;

    count = recvbuf->datalen;
    buf0 = recvbuf;
    while (buf1 != TcbRecvbufNil(tcb) &&
           buf0->seqnext == buf1->seqnext - buf1->datalen) {
        count += buf1->datalen;
        buf0 = buf1;
        buf1 = TcbRecvbufFlink(buf1);
    }

    // If we filled up a hole, emit an ACK immediately
    if (count > recvbuf->datalen) {
        NeedSendACKNow(tcb);
    }

    // ASSERT(TcbVerifyRecvBuf(tcb));
    return count;
}


PRIVATE VOID
TcbBufferMisorderedSegment(
    TCB* tcb,
    UINT seq,
    RECVBUF* recvbuf
    )


/*++

Routine Description:

    This function is called when we receive an out-of-order segment.

Arguments:

    tcb - Points to TCP control block
    seq - Specifies the starting sequence number for this segment
    recvbuf - Points to the received data buffer

Return Value:

    NONE

--*/

{
    RECVBUF* buf0 = TcbLastRecvbuf(tcb);
    RECVBUF* buf1;
    UINT count;

    if (buf0 == TcbRecvbufNil(tcb) || SEQ_GE(seq, buf0->seqnext)) {
        // The sequence number for this segment is larger
        // than everything in the receive buffer.
        InsertTailList(&tcb->recvbuf, &recvbuf->links);
        return;
    }

    do {
        buf0 = TcbRecvbufBlink(buf0);
    } while (buf0 != TcbRecvbufNil(tcb) && SEQ_LT(seq, buf0->seqnext));

    // recvbuf should go in between buf0 and buf1

    buf1 = TcbRecvbufFlink(buf0);
    if (SEQ_GT(recvbuf->seqnext, buf1->seqnext - buf1->datalen)) {
        // Data in this segment overlapps with
        // data in the buffered out-of-order segments.
        TRACE_("TcbBufferMisorderedSegment: overlapping segment");
        
        count= recvbuf->seqnext - (buf1->seqnext - buf1->datalen);
        if (count >= recvbuf->datalen) {
            XnetFree(recvbuf);
            return;
        }

        recvbuf->datalen -= count;
        recvbuf->seqnext -= count;
    }

    buf0->links.Flink = buf1->links.Blink = (LIST_ENTRY*) recvbuf;
    recvbuf->links.Flink = (LIST_ENTRY*) buf1;
    recvbuf->links.Blink = (LIST_ENTRY*) buf0;

    // ASSERT(TcbVerifyRecvBuf(tcb));
}


PRIVATE UINT
TcbCompletePendingRecvReqFast(
    TCB* tcb,
    Packet* pkt,
    BYTE tcpflags
    )

/*++

Routine Description:

    This function is called when we received data from a TCP connection
    and there is a pending overlapped receive request
    and there is currently no data in the receive buffer.
    In this case we can satisfy the request right away without
    allocating memory to store data in the receive buffer.

Arguments:

    tcb - Points to the TCP control block
    pkt - Points to the received packet
    tcpflags - TCP segment flags

Return Value:

    Number of bytes used up in this call

--*/

{
    UINT copycnt;
    RECVREQ* recvreq = PcbGetOverlappedRecv(tcb);

    copycnt = min(pkt->datalen, recvreq->buflen);
    CopyMem(recvreq->buf, pkt->data, copycnt);
    recvreq->overlapped->_ioxfercnt += copycnt;
    recvreq->buf += copycnt;
    recvreq->buflen -= copycnt;

    if ((recvreq->buflen == 0) || (tcpflags & TCP_PSH|TCP_URG)) {
        PcbCompleteOverlappedRecv(recvreq, NETERR_OK);
    }

    TcbSlideRecvWindow(tcb, copycnt);
    return copycnt;
}


PRIVATE TCB*
TcbProcessDataAck(
    TCB* tcb,
    Packet* pkt,
    TcpHeader* tcphdr
    )

/*++

Routine Description:

    Process a received TCP data segment.
    And we assume the connection is in a synchronized state.

Arguments:

    tcb - Points to the TCP connection block
    pkt - Points to the received packet
    tcphdr - Points to the TCP segment header information

Return Value:

    NULL if the TCB was deleted as a result of the incoming segment;
    Otherwise, just return the input tcb parameter

--*/

{
    TCPSEQ seq, ack, seq0, seq1;
    RECVBUF* recvbuf;

    seq = SEG_SEQ(tcphdr);

    // Process ACK if it's present
    if (ISTCPSEG(tcphdr, ACK)) {
        ack = SEG_ACK(tcphdr);
        if (SEQ_LT(ack, tcb->snd_una)) {
            // ACK is an old duplicate, ignore it
        } else if (SEQ_GT(ack, tcb->snd_nxt)) {
            // ACKing something that hasn't been sent.
            // Emit an ACK, drop the segment
            NeedSendACKNow(tcb);
            return tcb;
        } else {
            // update the send window information
            if (SEQ_LT(tcb->snd_wl1, seq) ||
                tcb->snd_wl1 == seq && SEQ_LE(tcb->snd_wl2, ack)) {
                TcbUpdateSndWnd(tcb, SEG_WIN(tcphdr), seq, ack);
            }

            TcbUpdateSndUna(tcb, ack);

            // If we already sent FIN, check to see if FIN has been acknowledged
            if (IsFINSent(tcb) && IsPcbSendBufEmpty(tcb)) {
                switch (tcb->tcpstate) {
                case TCPST_FIN_WAIT_1:
                    TcbSetState(tcb, TCPST_FIN_WAIT_2, "FinAck");
                    break;

                case TCPST_CLOSING:
                    TcbSetState(tcb, TCPST_TIME_WAIT, "FinAck");
                    TcbSetTimeWaitTimer(tcb, 2*cfgMSL);
                    return NULL;

                case TCPST_LAST_ACK:
                    TcbDelete(tcb);
                    return NULL;
                }
            }
        }
    }

    // If we already receive FIN from the peer,
    // we'll just ignore incoming data.
    if (IsFINReceived(tcb) || pkt->datalen == 0) return tcb;

    tcb->delayedAcks += pkt->datalen;

    // Quick check to see if the data from incoming segment
    // fits entirely within the current receive window.
    if (seq != tcb->rcv_nxt || pkt->datalen > tcb->rcv_wnd) {
        // If the receive sequence number is outside of
        // the current receive window, send an ACK right away.
        if (!TcbValidateSeqs(tcb, seq, seq+pkt->datalen, &seq0, &seq1)) {
            TRACE_("Sequence number out-of-range: %u %u %d",
                   seq, tcb->rcv_nxt, tcb->rcv_wnd);
            NeedSendACKNow(tcb);
            return tcb;
        }

        pkt->data += (seq0 - seq);
        pkt->datalen = (seq1 - seq0);
        ASSERT((INT) pkt->datalen > 0);
        seq = seq0;
    }

    if (IsPcbRecvShutdown(tcb)) {
        TcbResetPeer(tcb);
        TcbReset(tcb, NETERR_CONNRESET);
        return NULL;
    }

    // Special fast path: there is a pending overlapped receive request
    // and there is no data in the receive buffer.
    if (HasOverlappedRecv(tcb) &&
        seq == tcb->rcv_nxt &&
        IsListEmpty(&tcb->recvbuf)) {
        UINT copied = TcbCompletePendingRecvReqFast(tcb, pkt, tcphdr->flags);
        if (copied == pkt->datalen) return tcb;

        pkt->data += copied;
        pkt->datalen -= copied;
        seq += copied;
    }

    // Make a copy of the incoming segment and buffer it up
    recvbuf = (RECVBUF*) XnetAlloc(sizeof(RECVBUF) + pkt->datalen, PTAG_RBUF);
    if (!recvbuf) {
        WARNING_("Received TCP data discarded because of no memory");
        WARNING_("  local = %d, remote = %s:%d",
            NTOHS(tcb->srcport),
            IPADDRSTR(tcb->dstaddr),
            NTOHS(tcb->dstport));
        return tcb;
    }

    recvbuf->seqnext = seq + pkt->datalen;
    recvbuf->dataoffset = sizeof(RECVBUF);
    recvbuf->tcpflags = tcphdr->flags;
    recvbuf->datalen = pkt->datalen;
    CopyMem(recvbuf+1, pkt->data, pkt->datalen);

    // Fast case: the receive segment is in sequence
    if (seq == tcb->rcv_nxt) {
        UINT datarun;
        RECVBUF* lastbuf = TcbLastRecvbuf(tcb);

        if (lastbuf == TcbRecvbufNil(tcb) || lastbuf->seqnext == seq) {
            // We haven't buffered any out-of-order segments behind this one.
            datarun = pkt->datalen;
            InsertTailList(&tcb->recvbuf, &recvbuf->links);
        } else {
            // Figure out if this segment fills out holes
            // in the receive buffer.
            ASSERT(SEQ_LT(seq, lastbuf->seqnext));
            datarun = TcbCorrectMisorderedSegments(tcb, seq, recvbuf);
        }
        tcb->recvbufSize += datarun;
        TcbSlideRecvWindow(tcb, datarun);

        if (HasOverlappedRecv(tcb)) {
            // If we have a pending overlapped receive request, satisfy it now
            RECVREQ* recvreq = PcbGetOverlappedRecv(tcb);

            recvreq->overlapped->_ioxfercnt += TcbCopyRecvData(tcb, recvreq);
            if (recvreq->buflen == 0) {
                PcbCompleteOverlappedRecv(recvreq, NETERR_OK);
            }

            TcbSlideRecvWindow(tcb, 0);
        } else {
            PcbSignalEvent(tcb, PCBEVENT_READ);
        }
    } else {
        // Slow case: a segment arrived out of order.
        // Buffer up this segment for later processing.
        TRACE_("Out-of-order segment: %u %u", SEG_SEQ(tcphdr), tcb->rcv_nxt);
        TcpStats.misordered++;

        NeedSendACKNow(tcb);
        TcbBufferMisorderedSegment(tcb, seq, recvbuf);
    }

    return tcb;
}


PRIVATE VOID
TcbProcessFIN(
    TCB* tcb,
    TcpHeader* tcphdr,
    TCPSEQ seqfin
    )

/*++

Routine Description:

    Process an incoming TCP FIN segment

Arguments:

    tcb - Points to the TCP control block
    tcphdr - Points to the TCP segment header
    seqfin - Sequence number for the FIN

Return Value:

    NONE

--*/

{
    if (seqfin != tcb->rcv_nxt) return;

    tcb->rcv_nxt = seqfin+1;
    NeedSendACKNow(tcb);
    PcbSignalEvent(tcb, PCBEVENT_CLOSE);

    switch (tcb->tcpstate) {
    case TCPST_SYN_RECEIVED:
    case TCPST_ESTABLISHED:
        PcbClearOverlappedRecvs(tcb, NETERR_OK);
        PcbSignalEvent(tcb, PCBEVENT_READ);
        TcbSetState(tcb, TCPST_CLOSE_WAIT, "FinRecv");
        break;

    case TCPST_FIN_WAIT_1:
        if (IsPcbSendBufEmpty(tcb)) {
            TcbSetState(tcb, TCPST_CLOSING, "FinRecv");
            break;
        }

        // If our FIN has been acknowledged,
        // fall through and change to TIME-WAIT state.

    case TCPST_FIN_WAIT_2:
        TcbSetState(tcb, TCPST_TIME_WAIT, "FinRecv");

        // Fall through

    case TCPST_TIME_WAIT:
        TcbSetTimeWaitTimer(tcb, 2*cfgMSL);
        break;
    }
}


//
// Structure for storing TCP option parameters
// from an incoming SYN segment
//
typedef struct _TcpOptions {
    UINT mss;
    // other TCP option parameters ...
} TcpOptions;

PRIVATE BOOL
TcpParseOptions(
    Packet* pkt,
    TcpHeader* tcphdr,
    TcpOptions* opts
    )

/*++

Routine Description:

    Parse the option information in an incoming TCP SYN segment

Arguments:

    pkt - Points to the received packet
    tcphdr - Points to the TCP segment header
    opts - Returns the parsed option information

Return Value:

    TRUE if successful, FALSE if the TCP options are not well-formed

--*/

#define TCP_MINIMUM_MSS (MAXIPHDRLEN+MAXTCPHDRLEN+8-IPHDRLEN-TCPHDRLEN)

{
    const BYTE* buf;
    UINT buflen;

    // We ignore any data that's sent in the initial SYN segment.
    // Not sure if this case actually happens in real-life.
    // In any case, the sender should retransmit the data.
    if (ISTCPSEG(tcphdr, SYN) && pkt->datalen > 0) {
        WARNING_("Ignoring data in SYN segment.");
    }

    // Use default values if no options are present
    opts->mss = TCP_DEFAULT_MSS;

    buflen = GETTCPHDRLEN(tcphdr) - TCPHDRLEN;
    buf = (const BYTE*) (tcphdr+1);

    while (buflen) {
        BYTE opt, optlen;

        if ((opt = *buf) == TCPOPT_EOL) break;
        if (opt == TCPOPT_NOP) {
            buf++; buflen--; 
            continue;
        }

        // Verify option length field
        if (buflen < 2 || (optlen = buf[1]) < 2 || optlen > buflen)
            return FALSE;

        switch (opt) {
        case TCPOPT_MAX_SEGSIZE:
            if (optlen != 4) return FALSE;
            opts->mss = ((UINT) buf[2] << 8) | buf[3];
            if (opts->mss < TCP_MINIMUM_MSS)
                opts->mss = TCP_DEFAULT_MSS;
            break;

        default:
            TRACE_("TCP option ignored: %d", opt);
            break;
        }

        buf += optlen;
        buflen -= optlen;
    }
    return TRUE;
}


//
// Save the relevant information in an incoming connection request
//
#define TcpSaveConnReqParams(_tcb, _tcphdr, _opts) { \
            (_tcb)->rcv_isn = SEG_SEQ(_tcphdr); \
            (_tcb)->rcv_nxt = (_tcb)->rcv_isn+1; \
            (_tcb)->snd_mss = (_opts)->mss; \
        }

PRIVATE BOOL
TcbAcceptConnReqPassive(
    TCB* tcb,
    Packet* pkt,
    TcpHeader* tcphdr
    )

/*++

Routine Description:

    Process an incoming TCP connection request
    that was made to a listening (passively opened) socket

Arguments:

    tcb - TCP control block
    pkt - Points to the incoming packet
    tcphdr - Points to the TCP segment header

Return Value:

    FALSE if the incoming connection request is bad and
    the caller should send out a RST in response; TRUE otherwise

--*/

{
    NTSTATUS status;
    TCB* tcbChild;
    TcpOptions opts;

    // Parse TCP options
    if (!TcpParseOptions(pkt, tcphdr, &opts)) return FALSE;

    tcbChild = TcbCloneChild(tcb);
    if (!tcbChild) return TRUE;

    TcbSetState(tcbChild, TCPST_SYN_RECEIVED, "Connection request");
    TcpSaveConnReqParams(tcbChild, tcphdr, &opts);

    status = TcbConnect(tcbChild, GETPKTIPHDR(pkt)->srcaddr, tcphdr->srcport, TRUE);
    if (!NT_SUCCESS(status)) {
        TcbDelete(tcbChild);
        return TRUE;
    }

    InsertHeadList(&PcbList, &tcbChild->links);
    return TRUE;
}


PRIVATE VOID
TcbConnectionEstablished(
    TCB* tcb,
    TcpHeader* tcphdr
    )

/*++

Routine Description:

    Change a TCP connection to established state

Arguments:

    tcb - Points to the TCP control block
    tcphdr - Points to the incoming SYN/ACK segment

Return Value:

    NONE

--*/

{
    TCPSEQ ack;
    TCPSENDBUF* sendbuf;

    TRACE_("Connection established: %s:%d ", IPADDRSTR(tcb->srcaddr), NTOHS(tcb->srcport));
    TRACE_("to %s:%d", IPADDRSTR(tcb->dstaddr), NTOHS(tcb->dstport));

    //
    // The incoming segment must acknowledge our SYN
    //
    sendbuf = TcbFirstSendbuf(tcb);
    ack = SEG_ACK(tcphdr);
    ASSERT(sendbuf->tcpflags & TCP_SYN);
    ASSERT(ISTCPSEG(tcphdr, ACK));
    ASSERT(ack == tcb->snd_nxt);

    tcb->snd_una = ack;
    TcbUpdateSndWnd(tcb, SEG_WIN(tcphdr), SEG_SEQ(tcphdr), ack);

    if (tcb->rtt_tick) {
        TcbUpdateRTO(tcb);
    }
    RemoveEntryList(&sendbuf->links);
    SendbufRelease(sendbuf);
    tcb->xmitTimer = tcb->synTimer = 0;

    // NOTE: Since we don't fragment outgoing IP datagrams, we need
    // to limit snd_mss to be less than the first-hop interface MTU
    // minus the TCP and IP headers.
    if (tcb->snd_mss > tcb->rcv_mss)
        tcb->snd_mss = tcb->rcv_mss;

    tcb->snd_cwnd = 2*tcb->snd_mss;
    tcb->snd_ssthresh = max(tcb->snd_wnd, tcb->snd_cwnd);
    tcb->rcv_swsthresh = min(tcb->maxRecvBufsize>>1, tcb->snd_mss);

    TcbSetState(tcb, TCPST_ESTABLISHED, "Connected");
    tcb->flags |= PCBFLAG_CONNECTED;
    PcbSignalEvent(tcb, PCBEVENT_CONNECT);

    if (IsPendingConnReqTcb(tcb)) {
        // Signal the connection request is ready for acceptance
        PcbSignalEvent(tcb->parent, PCBEVENT_ACCEPT);
    }
}


PRIVATE BOOL
TcbAcceptConnReqActive(
    TCB* tcb,
    Packet* pkt,
    TcpHeader* tcphdr
    )

/*++

Routine Description:

    Process an incoming TCP connection request
    that was made to an actively opened socket

Arguments:

    tcb - TCP control block
    pkt - Points to the incoming packet
    tcphdr - Points to the TCP segment header

Return Value:

    FALSE if the incoming connection request is bad and
    the caller should send out a RST in response; TRUE otherwise

--*/

{
    TcpOptions opts;
    NTSTATUS status;

    // Parse TCP options and save connection request information
    if (!TcpParseOptions(pkt, tcphdr, &opts)) return FALSE;
    TcpSaveConnReqParams(tcb, tcphdr, &opts);

    if (ISTCPSEG(tcphdr, ACK)) {
        TcbConnectionEstablished(tcb, tcphdr);
        NeedSendACKNow(tcb);
        status = NETERR_OK;
    } else {
        TcbSetState(tcb, TCPST_SYN_RECEIVED, "Simultaneous open");
        status = TcbEmitSYN(tcb, TRUE);
    }

    return NT_SUCCESS(status);
}


VOID
TcpReceivePacket(
    Packet* pkt
    )

/*++

Routine Description:

    Receive a TCP segment

Arguments:

    pkt - Points to the received TCP segment

Return Value:

    NONE

--*/

{
    IpHeader* iphdr;
    PseudoHeader pseudohdr;
    TcpHeader* tcphdr;
    UINT tcphdrlen;
    UINT checksum;
    TCB* tcb;
    BOOL isAck;
    TCPSEQ ack;

    // Verify TCP segment header
    if (pkt->datalen < TCPHDRLEN) goto discard;

    iphdr = GETPKTIPHDR(pkt);
    pseudohdr.srcaddr = iphdr->srcaddr;
    pseudohdr.dstaddr = iphdr->dstaddr;
    pseudohdr.zero = 0;
    pseudohdr.protocol = IPPROTOCOL_TCP;
    pseudohdr.length = (WORD) HTONS(pkt->datalen);

    tcphdr = GETPKTDATA(pkt, TcpHeader);
    tcphdrlen = GETTCPHDRLEN(tcphdr);
    if (tcphdrlen < TCPHDRLEN || tcphdrlen > pkt->datalen)
        goto discard;

    // Verify checksum
    checksum = tcpipxsum(0, &pseudohdr, sizeof(pseudohdr));
    if (tcpipxsum(checksum, tcphdr, pkt->datalen) != 0xffff)
        goto discard;

    pkt->data += tcphdrlen;
    pkt->datalen -= tcphdrlen;

    // Find the socket that the segment is addressed to
    tcb = (TCB*) PcbFindMatch(
                    pseudohdr.dstaddr,
                    tcphdr->dstport,
                    pseudohdr.srcaddr,
                    tcphdr->srcport,
                    SOCK_STREAM,
                    IPPROTOCOL_TCP);

    if (!tcb) goto sendrst;

    if (IsTcpSyncState(tcb) && (tcphdr->flags & TCP_CONTROLS) == 0) {
        // Quick check for special case:
        //  we're in a synchronized state and
        //  the segment has no control flags.
        tcb = TcbProcessDataAck(tcb, pkt, tcphdr);

rcvdone:
        // NOTE: We return the interface driver's buffer first
        // before trying to send out the ACK segment.

        XnetCompletePacket(pkt, NETERR_OK);
        if (tcb && tcb->delayedAcks >= (tcb->rcv_mss << 1)) {
            TcbEmitACK(tcb);
        }
        return;
    }
    
    // If the connection is closed, send RST
    if (tcb->tcpstate == TCPST_CLOSED) goto sendrst;

    // Discard packets with broadcast/multicast destination address.
    // We assume that packets with broadcast/multicast source address
    // are already discarded by the IP layer.
    if (IfBcastAddr(pkt->recvifp, pseudohdr.dstaddr) || 
        IS_MCAST_IPADDR(pseudohdr.dstaddr))
        goto discard;

    isAck = ISTCPSEG(tcphdr, ACK);

    switch (tcb->tcpstate) {
    case TCPST_LISTEN:

        // Ignore RST segment in listen state
        if (ISTCPSEG(tcphdr, RST)) goto discard;

        // If ACK is on, send RST
        if (isAck) goto sendrst;

        // If there is no SYN, discard the segment
        if (!ISTCPSEG(tcphdr, SYN)) goto discard;

        // Process an incoming connection request on a listening socket
        if (!TcbAcceptConnReqPassive(tcb, pkt, tcphdr)) goto sendrst;
        break;
    
    case TCPST_SYN_SENT:

        // If ACK is on and the acknowledgement number is bad, send RST
        if (isAck) {
            ack = SEG_ACK(tcphdr);
            if (!IsValidACK(tcb, ack)) goto sendrst;
        }

        if (ISTCPSEG(tcphdr, RST)) {
            // If RST is on and ACK is good, reset the connection.
            // Otherwise, discard the RST segment.
            if (isAck) { TcbReset(tcb, NETERR_CONNRESET); }
            goto discard;
        }

        // If there is no SYN, just discard the segment
        if (!ISTCPSEG(tcphdr, SYN)) goto discard;

        // Simultaneous active open
        if (!TcbAcceptConnReqActive(tcb, pkt, tcphdr)) goto sendrst;
        break;
    
    default: {
        TCPSEQ oldseq0 = SEG_SEQ(tcphdr);
        TCPSEQ oldseq1 = oldseq0 + SEG_LEN(tcphdr, pkt->datalen);
        TCPSEQ seq0, seq1;

        // Make sure the sequence number is correct.
        // If not and the incoming segment is not RST, we'll emit an ACK.
        if (!TcbValidateSeqs(tcb, oldseq0, oldseq1, &seq0, &seq1)) {
            if (!ISTCPSEG(tcphdr, RST)) {
                NeedSendACKNow(tcb);
            }
            break;
        }

        // If RST is on, then we'll reset the connection:
        //  - if the socket corresponds to a pending connection
        //    request, then we'll just close it and destroy the TCB.
        if (ISTCPSEG(tcphdr, RST)) {
            TcbReset(tcb, NETERR_CONNRESET);
            goto discard;
        }

        // If SYN is set, there is an error.
        // We send out a RST as well as reset the connection.
        if (ISTCPSEG(tcphdr, SYN)) {
            if (oldseq0 == seq0) {
                TcbReset(tcb, NETERR_CONNRESET);
                goto sendrst;
            }
            goto discard;
        }

        if (!ISTCPSEG(tcphdr, ACK)) goto discard;

        if (tcb->tcpstate == TCPST_SYN_RECEIVED) {
            ack = SEG_ACK(tcphdr);
            if (!IsValidACK(tcb, ack)) {
                // The acknowledgement number is bad, emit an RST
                goto sendrst;
            }

            // NOTE: The ACK for our SYN will be processed
            // inside the TcbProcessDataAck call below.
            TcbConnectionEstablished(tcb, tcphdr);
        }

        // Process the data and acknowledgement information
        // and continue to process the FIN flag if necessary
        tcb = TcbProcessDataAck(tcb, pkt, tcphdr);
        if (tcb && ISTCPSEG(tcphdr, FIN)) {
            TcbProcessFIN(tcb, tcphdr, seq1-1);
        }
        }
        break;
    }
    goto rcvdone;

sendrst:

    // If the received segment is a RST, do nothing
    if ((tcphdr->flags & TCP_RST) == 0) {
        TCPSEQ seq;
        BYTE flags;
        IpAddrPair addrpair;
        IfInfo* ifp;

        if (ISTCPSEG(tcphdr, ACK)) {
            ack = 0;
            seq = SEG_ACK(tcphdr);
            flags = 0;
        } else {
            ack = SEG_SEQ(tcphdr) + SEG_LEN(tcphdr, pkt->datalen);
            seq = 0;
            flags  = TCP_ACK;
        }

        addrpair.dstaddr = iphdr->srcaddr;
        addrpair.srcaddr = iphdr->dstaddr;
        addrpair.dstport = tcphdr->srcport;
        addrpair.srcport = tcphdr->dstport;
        ifp = pkt->recvifp;

        // NOTE: We return the interface driver's buffer first
        // before trying to send out the RST segment.

        XnetCompletePacket(pkt, NETERR_DISCARDED);
        TcbEmitRST(ifp, &addrpair, seq, ack, flags);
        return;
    }

discard:
    XnetCompletePacket(pkt, NETERR_DISCARDED);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\tcp\udp.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    udp.c

Abstract:

    UDP protocol related functions

Revision History:

    05/27/2000 davidx
        Created it.

--*/

#include "precomp.h"
#include "..\dhcp\dhcp.h"


PRIVATE VOID
PcbDeliverDgram(
    PCB* pcb,
    Packet* pkt,
    IPADDR fromaddr,
    IPPORT fromport
    )

/*++

Routine Description:

    Deliver a received datagram to the specified socket

Arguments:

    pcb - Points to the protcol control block
    pkt - Points to the received datagram
    fromaddr, fromport - The sender's address

Return Value:

    NONE

--*/

{
    RECVBUF* recvbuf;

    //
    // If there are datagrams queued up on this socket
    // that haven't been processed, then we must not
    // have any pending recv requests.
    //
    // Otherwise, check if there is a pending recv request
    // that can be satisfied with the incoming datagram.
    //
    if (HasOverlappedRecv(pcb)) {
        WSAOVERLAPPED* overlapped;
        RECVREQ* recvreq;
        UINT copycnt;
        NTSTATUS status;

        ASSERT(IsDgramRecvBufEmpty(pcb));
        recvreq = PcbGetOverlappedRecv(pcb);
        overlapped = recvreq->overlapped;

        SetRecvReqFromAddr(recvreq, fromaddr, fromport);

        copycnt = min(pkt->datalen, recvreq->buflen);
        CopyMem(recvreq->buf, pkt->data, copycnt);

        overlapped->_ioxfercnt = copycnt;
        if (copycnt < pkt->datalen) {
            overlapped->_ioflags = MSG_PARTIAL;
            status = NETERR_MSGSIZE;
        } else {
            overlapped->_ioflags = 0;
            status = NETERR_OK;
        }

        PcbCompleteOverlappedRecv(recvreq, status);
        return;
    }

    //
    // If the unprocessed receive queue is full,
    // we'll drop the incoming packet. The alternative
    // is to drop the oldest packet.
    //
    if (IsPcbRecvBufFull(pcb)) return;

    // Make a copy of the incoming datagram
    // NOTE: we're not copying protocol header data here.

    recvbuf = (RECVBUF*) XnetAlloc(sizeof(RECVBUF) + pkt->datalen, PTAG_RBUF);
    if (!recvbuf) {
        WARNING_("Received datagram discarded because of no memory");
        WARNING_("  local = %d, remote = %s:%d",
            NTOHS(pcb->srcport),
            IPADDRSTR(fromaddr),
            NTOHS(fromport));
        return;
    }

    CopyMem(recvbuf+1, pkt->data, pkt->datalen);
    recvbuf->datalen = pkt->datalen;
    pcb->recvbufSize += pkt->datalen;
    recvbuf->fromaddr = fromaddr;
    recvbuf->fromport = fromport;

    InsertTailList(&pcb->recvbuf, &recvbuf->links);
    PcbSignalEvent(pcb, PCBEVENT_READ);
}


UINT
PcbDeliverRecvDgramMulti(
    Packet* pkt,
    IPADDR toaddr,
    IPPORT toport,
    IPADDR fromaddr,
    IPPORT fromport,
    BYTE type,
    BYTE protocol
    )

/*++

Routine Description:

    Deliver a received datagram to all applicable socket(s)

Arguments:

    pkt - Points to the received datagram
    toaddr, toport - The destination address of the datagram
    fromaddr, fromport - The sender's address
    type - Specifies the socket type (SOCK_DGRAM or SOCK_RAW)
    protocol - Specifies the protocol number

Return Value:

    Number of sockets this datagram was delivered to

--*/

{
    PCB* pcb;
    UINT delivered = 0;

    LOOP_THRU_PCB_LIST(pcb)

        if (pcb->type != type ||
            pcb->protocol != protocol && pcb->protocol ||
            pcb->srcport != toport ||
            IS_MCAST_IPADDR(toaddr) && !PcbCheckMcastGroup(pcb, toaddr) ||
            pcb->dstaddr != fromaddr && pcb->dstaddr ||
            pcb->dstport != fromport && pcb->dstport ||
            !IsPcbBound(pcb) ||
            IsPcbRecvShutdown(pcb))
            continue;

        PcbDeliverDgram(pcb, pkt, fromaddr, fromport);
        delivered++;

    END_PCB_LIST_LOOP

    return delivered;
}


NTSTATUS
PcbRecvDgram(
    PCB* pcb,
    RECVREQ* recvreq
    )

/*++

Routine Description:

    Handle a user request to receive data from a datagram socket

Arguments:

    pcb - Points to the protocol control block
    recvreq - Points to the receive request information

Return Value:

    Status code

Note:

    This call always return immediately. For blocking calls,
    we assume the caller has done the necessary wait.

--*/

{
    NTSTATUS status;
    KIRQL irql = RaiseToDpc();

    if (!IsDgramRecvBufEmpty(pcb)) {
        //
        // If there is unprocessed datagram,
        // we must not have any pending recv requests.
        // So we can satisfy the request immediately.
        //
        RECVBUF* recvbuf;
        DWORD copycnt;

        recvbuf = (RECVBUF*) RemoveHeadList(&pcb->recvbuf);
        pcb->recvbufSize -= recvbuf->datalen;
        LowerFromDpc(irql);

        SetRecvReqFromAddr(recvreq, recvbuf->fromaddr, recvbuf->fromport);

        if (recvbuf->datalen <= recvreq->buflen) {
            copycnt = recvbuf->datalen;
            recvreq->flags = 0;
            status = NETERR_OK;
        } else {
            copycnt = recvreq->buflen;
            recvreq->flags = MSG_PARTIAL;
            status = NETERR_MSGSIZE;
        }

        *recvreq->bytesRecv = copycnt;
        CopyMem(recvreq->buf, recvbuf+1, copycnt);
        XnetFree(recvbuf);
        return status;
    }

    status = PcbQueueOverlappedRecv(pcb, recvreq);
    LowerFromDpc(irql);
    return status;
}


VOID
UdpReceivePacket(
    Packet* pkt
    )

/*++

Routine Description:

    Receive a UDP datagram

Arguments:

    pkt - Points to the received UDP datagram

Return Value:

    NONE

--*/

{
    IpHeader* iphdr;
    PseudoHeader pseudohdr;
    UdpHeader* udphdr;
    UINT udplen;
    INT delivered;
    IPADDR dstaddr;

    RUNS_AT_DISPATCH_LEVEL

    // Validate header length field
    if (pkt->datalen < UDPHDRLEN) goto discard;

    iphdr = GETPKTIPHDR(pkt);
    pseudohdr.srcaddr = iphdr->srcaddr;
    pseudohdr.dstaddr = dstaddr = iphdr->dstaddr;
    pseudohdr.zero = 0;
    pseudohdr.protocol = IPPROTOCOL_UDP;

    udphdr = GETPKTDATA(pkt, UdpHeader);
    udplen = NTOHS(udphdr->length);
    pseudohdr.length = udphdr->length;

    if (udplen < UDPHDRLEN || udplen > pkt->datalen)
        goto discard;

    // Validate checksum if it's present

    if (udphdr->checksum) {
        UINT checksum;
        checksum = tcpipxsum(0, &pseudohdr, sizeof(pseudohdr));
        if (tcpipxsum(checksum, udphdr, udplen) != 0xffff)
            goto discard;
    }

    pkt->data += UDPHDRLEN;
    pkt->datalen = udplen - UDPHDRLEN;

    if (udphdr->dstport == 0)
        goto discard;

    delivered = 0;

    //
    // Hardwired hooks to the DHCP client
    //
    if (udphdr->dstport == DHCP_CLIENT_PORT &&
        IfDhcpEnabled(pkt->recvifp)) {
        // NOTE: we retain ownership of the packet here,
        //  i.e. DhcpReceivePacket must not call XnetCompletePacket.
        DhcpReceivePacket(pkt->recvifp, pkt);
        delivered++;
    }

    //
    // If this is a unicast datagram, then we'll deliver it
    // to at most one matching socket. Broadcast or unicast
    // datagrams are delivered to all matching datagrams.
    //
    if (!IS_MCAST_IPADDR(dstaddr) && !IfBcastAddr(pkt->recvifp, dstaddr)) {
        PCB* pcb = PcbFindMatch(
                    dstaddr,
                    udphdr->dstport,
                    pseudohdr.srcaddr,
                    udphdr->srcport,
                    SOCK_DGRAM,
                    IPPROTOCOL_UDP);

        if (pcb && IsPcbBound(pcb) && !IsPcbRecvShutdown(pcb)) {
            PcbDeliverDgram(pcb, pkt, pseudohdr.srcaddr, udphdr->srcport);
            delivered++;
        }
    } else {
        delivered += PcbDeliverRecvDgramMulti(
                        pkt,
                        dstaddr,
                        udphdr->dstport,
                        pseudohdr.srcaddr,
                        udphdr->srcport,
                        SOCK_DGRAM,
                        IPPROTOCOL_UDP);
    }

    if (delivered) {
        XnetCompletePacket(pkt, NETERR_OK);
        return;
    }

    // If the datagram wasn't delivered,
    // send out a port-unreachable ICMP message.
    IcmpSendError(
        pkt,
        ICMPTYPE_DESTINATION_UNREACHABLE,
        ICMPCODE_PORT_UNREACHABLE);

discard:
    XnetCompletePacket(pkt, NETERR_DISCARDED);
}


VOID
RawReceivePacket(
    Packet* pkt
    )

/*++

Routine Description:

    Receive a raw IP datagram

Arguments:

    pkt - Points to the received datagram

Return Value:

    NONE

--*/

{
    UINT delivered;
    BYTE protocol;
    IpHeader* iphdr;

    RUNS_AT_DISPATCH_LEVEL

    // Since pkt->data points to after the IP header,
    // we need to fix it here.
    iphdr = GETPKTIPHDR(pkt);
    pkt->datalen += (pkt->data - (BYTE*) iphdr);
    pkt->data = (BYTE*) iphdr;

    if ((protocol = iphdr->protocol) != 0) {
        //
        // The same datagram could be delivered to
        // multiple sockets. This is to follow w2k behavior.
        //
        delivered = PcbDeliverRecvDgramMulti(
                        pkt,
                        iphdr->dstaddr,
                        0,
                        iphdr->srcaddr,
                        0,
                        SOCK_RAW,
                        protocol);
        
        if (delivered) {
            XnetCompletePacket(pkt, NETERR_OK);
            return;
        }

        if (protocol != IPPROTOCOL_IGMP &&
            protocol != IPPROTOCOL_ICMP) {
            IcmpSendError(
                pkt,
                ICMPTYPE_DESTINATION_UNREACHABLE,
                ICMPCODE_PROTOCOL_UNREACHABLE);
        }
    }

    XnetCompletePacket(pkt, NETERR_DISCARDED);
}


VOID
UdpSendPacketInternal(
    Packet* pkt,
    IpAddrPair* addrpair,
    IfInfo* ifp
    )

/*++

Routine Description:

    Send out a UDP datagram (used internally by DHCP client)

Arguments:

    pkt - Points to the packet to be sent
    addrpair - Specifies source & destination addresses and ports
    ifp - Specifies the outgoing interface

Return Value:

    NONE

--*/

{
    // Compose UDP header
    pkt->data -= UDPHDRLEN;
    pkt->datalen += UDPHDRLEN;
    FILL_UDPHEADER(pkt, addrpair);

    // Call the IP layer to send out the packet
    IpSendPacketInternal(pkt, addrpair->srcaddr, addrpair->dstaddr, IPPROTOCOL_UDP, ifp);
}


PRIVATE NTSTATUS
PcbPrepareSendto(
    PCB* pcb,
    IpAddrPair* addrpair,
    RTE** cachedRte
    )

/*++

Routine Description:

    Choose the proper source address for a sendto call

Arguments:

    pcb - Points to the protocol control block
    addrpair - Specifies source & destination addresses and ports
    cachedRte - Stored the cached route entry

Return Value:

    NONE

--*/

{
    NTSTATUS status = NETERR_OK;
    KIRQL irql = RaiseToDpc();

    if (IS_MCAST_IPADDR(addrpair->dstaddr)) {
        // Sendto is called with a multicast destination address.
        // We'll choose the outgoing interface and source address
        // based on the setting of IP_MULTICAST_IF option.
        IfInfo* ifp = PcbGetMcastIf(pcb);
        if (ifp != NULL)
            addrpair->srcaddr = ifp->ipaddr;
        else
            status = NETERR_UNREACHABLE;
    } else {
        // Trying to find a route to the sendto destination.
        // And use that interface's address as our source address.
        RTE* rte = IpFindRTE(addrpair->dstaddr, NULL);
        if (rte != NULL) {
            *cachedRte = rte;
            RteAddRef(rte);
            addrpair->srcaddr = PcbGetDefaultSrcAddr(rte);
        } else {
            status = NETERR_UNREACHABLE;
        }
    }
    
    LowerFromDpc(irql);
    return status;
}


//
// Completion routine that's called when an outgoing datagram is sent
// 
PRIVATE VOID DgramSendCompletionProc(Packet* pkt, NTSTATUS status) {
    SENDBUF* sendbuf = GETPKTBUF(pkt, SENDBUF);
    KIRQL irql = RaiseToDpc();
    LONG refcount;
    PCB* pcb;

    if ((refcount = SendbufDecRef(sendbuf)) > 0) {
        pcb = sendbuf->pcb;
        RemoveEntryList(&sendbuf->links);
        pcb->sendbufSize -= sendbuf->datalen;

        if (!IsPcbSendBufFull(pcb)) {
            if (HasOverlappedSend(pcb)) {
                SENDREQ* sendreq = PcbGetOverlappedSend(pcb);

                status = PcbSendDgram(pcb, sendreq);
                sendreq->overlapped->_ioxfercnt = sendreq->sendtotal;
                PcbCompleteOverlappedSend(sendreq, status);
            } else {
                PcbSignalEvent(pcb, PCBEVENT_WRITE);
            }
        }
    }

    LowerFromDpc(irql);
    XnetFreePacket(pkt);
}


NTSTATUS
PcbSendDgram(
    PCB* pcb,
    SENDREQ* sendreq
    )

/*++

Routine Description:

    Send out a datagram from a UDP or raw socket

Arguments:

    pcb - Points to the protocol control block
    sendreq - Points to send request information

Return Value:

    Status code

Note:

    This function always return immediately. For blocking operation,
    we assume the caller has taken care of any necessary wait.

    The winsock layer checks to see if the send buffer is full before
    calling this function. In the case that:
        old sendbuf size + the datagram size > max sendbuf size
    we'll temporarily go over the send buffer size limit.

--*/

{
    SENDBUF* sendbuf;
    Packet* pkt;
    UINT hdrsize;
    KIRQL irql;
    IpAddrPair* addrpair;
    IpAddrPair sendtoAddr;
    RTE** cachedRte;
    RTE* sendtoRte = NULL;
    NTSTATUS status;

    hdrsize = sizeof(SENDBUF) +
              MAXLINKHDRLEN +
              IPHDRLEN + pcb->ipoptlen +
              UDPHDRLEN;
                
    pkt = XnetAllocPacket(hdrsize + sendreq->sendtotal, 0);
    if (!pkt) return NETERR_MEMORY;
    pkt->data += hdrsize;
    pkt->datalen = sendreq->sendtotal;

    // Make a copy of the user data that's passed in
    if (sendreq->bufcnt == 1) {
        CopyMem(pkt->data, sendreq->bufs->buf, sendreq->sendtotal);
    } else {
        BYTE* p = pkt->data;
        WSABUF* bufs = sendreq->bufs;
        UINT bufcnt = sendreq->bufcnt;

        while (bufcnt--) {
            CopyMem(p, bufs->buf, bufs->len);
            p += bufs->len;
            bufs++;
        }
    }

    if (!sendreq->toaddr && !IS_MCAST_IPADDR(pcb->dstaddr)) {
        // Normal send request
        addrpair = &pcb->addrpair;
        cachedRte = &pcb->rte;
    } else {
        // This is a sendto request.
        addrpair = &sendtoAddr;
        cachedRte = &sendtoRte;
        if (sendreq->toaddr) {
            addrpair->dstport = sendreq->toaddr->sin_port;
            addrpair->dstaddr = sendreq->toaddr->sin_addr.s_addr;
        } else {
            addrpair->dstport = pcb->dstport;
            addrpair->dstaddr = pcb->dstaddr;
        }
        addrpair->srcport = pcb->srcport;
        addrpair->srcaddr = pcb->bindSrcAddr;

        if (addrpair->srcaddr == 0) {
            status = PcbPrepareSendto(pcb, addrpair, cachedRte);
            if (!NT_SUCCESS(status)) {
                XnetFreePacket(pkt);
                return status;
            }
        }
    }

    if (pcb->type == SOCK_DGRAM) {
        // Sending UDP datagram
        pkt->data -= UDPHDRLEN;
        pkt->datalen += UDPHDRLEN;
        FILL_UDPHEADER(pkt, addrpair);
        PcbSetupIpHeader(pcb, pkt, addrpair);
    } else {
        // Sending raw IP datagram
        if (pcb->ipHdrIncl) {
            if (pkt->datalen < IPHDRLEN) {
                XnetFreePacket(pkt);
                status = NETERR_PARAM;
                goto exit;
            }
            SETPKTIPHDR(pkt, pkt->data);
        } else {
            PcbSetupIpHeader(pcb, pkt, addrpair);
        }
    }

    // Set up the packet completion routine to
    // decrement the send buffer size when the packet is sent.

    sendbuf = GETPKTBUF(pkt, SENDBUF);
    sendbuf->refcount = 2;
    sendbuf->datalen = sendreq->sendtotal;
    sendbuf->pcb = pcb;
    XnetSetPacketCompletion(pkt, DgramSendCompletionProc);

    irql = RaiseToDpc();
    pcb->sendbufSize += sendreq->sendtotal;
    InsertTailList(&pcb->sendbuf, &sendbuf->links);

    if (IS_MCAST_IPADDR(addrpair->dstaddr)) {
        // Send a copy of the multicast datagram to ourselves if needed
        status = PcbSendMcastDgram(pcb, pkt, addrpair->dstaddr);
    } else {
        // If this is a broadcast datagram, send a copy to ourselves
        // NOTE: subnet directed broadcast isn't handled correctly.
        if (IS_BCAST_IPADDR(addrpair->dstaddr)) {
            IpQueueLoopbackPacket(pkt, TRUE);
        }

        status = IpSendPacket(pkt, addrpair->dstaddr, NULL, cachedRte);
    }
    LowerFromDpc(irql);

exit:
    if (sendtoRte) { IpReleaseCachedRTE(sendtoRte); }
    return status;
}


NTSTATUS
PcbShutdownDgram(
    PCB* pcb,
    BYTE flags
    )

/*++

Routine Description:

    Shutdown a datagram socket

Arguments:

    pcb - Points to the protocol control block
    flags - Shutdown flags: PCBFLAG_SEND_SHUTDOWN and/or PCBFLAG_RECV_SHUTDOWN

Return Value:

    Status code

--*/

{
    KIRQL irql = RaiseToDpc();

    if (flags & PCBFLAG_RECV_SHUTDOWN) {
        PcbClearOverlappedRecvs(pcb, NETERR(WSAESHUTDOWN));
        PcbFlushRecvBuffers(pcb);
    }

    if (flags & PCBFLAG_SEND_SHUTDOWN) {
        PcbClearOverlappedSends(pcb, NETERR(WSAESHUTDOWN));
    }

    pcb->flags |= flags;
    LowerFromDpc(irql);
    return NETERR_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\test\filexfer\precomp.h ===
#include "xnetp.h"
#include "xnettest.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\test\gethost\gethost.c ===
// Simple DNS client test program

#include "precomp.h"
#include <stdlib.h>

#ifdef TEST_PPP
#include <xppp.h>
#endif // TEST_PPP

INT testFlag = 1;
INT err;


#define BREAK_INTO_DEBUGGER __asm int 3
#define WARNFAIL(_apiname) \
        DbgPrint(#_apiname " failed: %d %d\n", err, GetLastError())


CHAR* testnames[] = {
    "davidxu",
    "davidxu.ntdev.microsoft.com",
    "foobar",
    "www.msn.com."
};

struct {
    BYTE addr[4];
} testaddrs[] = {
    { 157, 56, 11, 44 },
    { 192, 55, 34, 25 }
};


VOID
PrintHostent(
    struct hostent* host
    )
{
    CHAR** p;
    if (host == NULL) {
        DbgPrint("  failed: %d\n", GetLastError());
    } else {
        DbgPrint("  %s\n", host->h_name);
        p = host->h_aliases;
        while (*p) {
            DbgPrint("  %s\n", *p);
            p++;
        }

        p = host->h_addr_list;
        while (*p) {
            DbgPrint("  %s\n", inet_ntoa(*((struct in_addr*) *p)));
            p++;
        }
    }
}

VOID
DnsTest()
{
    INT index, count;
    struct hostent* host;
    CHAR localhost[32];

    err = gethostname(localhost, 32);
    if (err != NO_ERROR) {
        WARNFAIL(gethostname);
    } else {
        DbgPrint("Lookup hostname: %s...\n", localhost);
        host = gethostbyname(localhost);
        PrintHostent(host);
    }

    count = ARRAYCOUNT(testnames);
    for (index=0; index < count; index++) {
        DbgPrint("Lookup hostname: %s...\n", testnames[index]);
        host = gethostbyname(testnames[index]);
        PrintHostent(host);
    }

    count = ARRAYCOUNT(testaddrs);
    for (index=0; index < count; index++) {
        struct in_addr* addr = (struct in_addr*) &testaddrs[index];
        DbgPrint("Lookup address: %s\n", inet_ntoa(*addr));
        host = gethostbyaddr((char*) addr, sizeof(*addr), AF_INET);
        PrintHostent(host);
    }
}


void __cdecl main()
{
    WSADATA wsadata;

    DbgPrint("Loading XBox network stack...\n");
    err = XnetInitialize(NULL, TRUE);
    if (err != NO_ERROR) {
        WARNFAIL(XnetInitialize); goto stop;
    }

#ifdef TEST_PPP
    PppConnect("guest", "password", "", "9-786-1000");
//    PppConnect("004vgorok@spinway", "Ob4seBa5", "", "9-827-3261");
    Sleep(90000);
#endif // TEST_PPP

    err = WSAStartup(WINSOCK_VERSION, &wsadata);
    if (err != NO_ERROR) {
        WARNFAIL(WSAStartup); goto unload;
    }

    DbgPrint("*** Test started, press 'g' to continue...\n");
    BREAK_INTO_DEBUGGER

    while (testFlag > 0) {
        Sleep(1000);
        DnsTest();
        DbgPrint("*** To quit, press CTRL-C and type: ed %x 0;g\n", &testFlag);
        BREAK_INTO_DEBUGGER
    }

    WSACleanup();

unload:
    DbgPrint("Unloading XBox network stack...\n");
    XnetCleanup();

stop:
    if (testFlag == 0)
        HalReturnToFirmware(HalRebootRoutine);
    else
        Sleep(INFINITE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\tcp\tcpsend.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    tcpsend.c

Abstract:

    TCP data transmission related functions

Revision History:

    06/06/2000 davidx
        Created it.

--*/

#include "precomp.h"

//
// Maximum number of transmission retries
//
UINT cfgMaxXmitRetries = 5;

//
// Maximum and minimum retransmission timeout (in ticks)
// NOTE: Non-standard behavior!!!
//  Our maximum timeout between retries is 8sec, much shorter
//  than the usual value of 60sec. This is ok for our first
//  release since we only support LAN play.
//
UINT cfgMinRexmitTimeout = SLOW_TCP_TIMER_FREQ;
UINT cfgMaxRexmitTimeout = 8 * SLOW_TCP_TIMER_FREQ;

//
// Minimum zero-window-probe timeout (in ticks)
//
UINT cfgMinPersistTimeout = 5*SLOW_TCP_TIMER_FREQ;

//
// TCP statistics
//
TCPSTATS TcpStats;


VOID
TcbSendSegment(
    TCB* tcb,
    TCPSENDBUF* sendbuf
    )

/*++

Routine Description:

    Send a TCP segment out

Arguments:

    tcb - Points to the TCP control block
    sendbuf - Points to the segment to be sent

Return Value:

    NONE

--*/

{
    Packet* pkt = GetSendbufPkt(sendbuf);

    if (!IsSendbufActive(sendbuf)) {
        tcb->delayedAcks = 0;
        SendbufIncRef(sendbuf);

        ASSERT(SEQ_LE(sendbuf->seq, TcbSndNxt(tcb)) || (sendbuf->tcpflags & TCP_FIN));

        FILL_TCPHEADER(
            pkt,
            &tcb->addrpair,
            sendbuf->seq,
            tcb->rcv_nxt,
            sendbuf->tcphdrlen,
            sendbuf->tcpflags,
            (WORD) tcb->rcv_wnd);

        if (sendbuf->retries)
            pkt->pktflags |= PKTFLAG_REXMIT;

        PcbSetupIpHeader((PCB*) tcb, pkt, &tcb->addrpair);
        IpSendPacket(pkt, tcb->dstaddr, NULL, &tcb->rte);
    }

    if (sendbuf == TcbFirstSendbuf(tcb)) {
        // Set up the retransmisssion or persist timer

        UINT minTimeout = tcb->persistFlag ?
                            cfgMinPersistTimeout :
                            cfgMinRexmitTimeout;

        tcb->xmitTimer = (tcb->RTO << sendbuf->retries);
        if (tcb->xmitTimer < minTimeout)
            tcb->xmitTimer = minTimeout;
        else if (tcb->xmitTimer > cfgMaxRexmitTimeout)
            tcb->xmitTimer = cfgMaxRexmitTimeout;
    }

    sendbuf->retries++;
}


BOOL
TcbStartOutput(
    TCB* tcb
    )

/*++

Routine Description:

    Called when we have buffered data to send on a TCP socket. 

Arguments:

    tcb - Points to the TCP control block
    sendbuf - Specifies the segment to be sent

Return Value:

    TRUE if a segment was sent; FALSE otherwise.

--*/

{
    INT sndwndAvail;
    TCPSENDBUF* sendbuf;
    TCPSEQ cwndmax, swndmax;

    RUNS_AT_DISPATCH_LEVEL

    sendbuf = tcb->sendbufNext;
    ASSERT(tcb->snd_nxt == sendbuf->seq);
    ASSERT(sendbuf->retries == 0);

    // We always send SYN or FIN segments without delay
    if (sendbuf->datalen == 0) goto sendnow;

    // NOTE: We're using signed integer here in case
    // the send window was shrunk by the receiver.
    swndmax = tcb->snd_wl2 + tcb->snd_wnd;
    cwndmax = tcb->snd_una + tcb->snd_cwnd;
    sndwndAvail = (SEQ_LE(swndmax, cwndmax) ? swndmax : cwndmax) - tcb->snd_nxt;

    if ((INT) sendbuf->datalen <= sndwndAvail) {
        // Send window is large enough. Perform send-side
        // SWS avoidance. Note that if the PSH flag is not set,
        // then we must be sending a full-sized data segment.
        // Check the logic in TcbSend().

        // BUGBUG: Since we don't yet combine data from
        // multiple send calls into a single segment, it's
        // meaningless to delay the send.
        goto sendnow;
    }

    // Cannot send due to window constraints
    //  set up persist timers
    if (tcb->snd_nxt == tcb->snd_una) {
        TRACE_("Setting persist timer...");
        TcpStats.persists++;
        tcb->persistFlag = 1;
        tcb->xmitTimer = max(tcb->RTO, cfgMinPersistTimeout);
    }
    return FALSE;

sendnow:

    // Use this segment to measure round-trip time if possible
    tcb->persistFlag = 0;
    if (tcb->rtt_tick == 0) {
        tcb->rtt_tick = TcpTickCount;
        tcb->rtt_seq = sendbuf->seq;
    }
    
    sendbuf->firstSendTime = TcpTickCount;
    TcbSendSegment(tcb, sendbuf);
    tcb->snd_nxt = sendbuf->seqnext;
    tcb->sendbufNext = TcbSendbufFlink(sendbuf);
    return TRUE;
}


TCB*
TcbXmitTimeout(
    TCB* tcb
    )

/*++

Routine Description:

    This function is called when the TCP retransmission timer expires.

Arguments:

    tcb - Points to the TCP control block

Return Value:

    NULL if the specified TCB was deleted inside this call.
    Otherwise, just return the input tcb parameter.

--*/

{
    TCPSENDBUF* sendbuf;

    if (IsPcbSendBufEmpty(tcb)) return tcb;
    sendbuf = TcbFirstSendbuf(tcb);

    if (sendbuf->retries >= cfgMaxXmitRetries) {
        TcbResetPeer(tcb);
        return TcbReset(tcb, NETERR_TIMEOUT);
    }

    // Stop round-trip time measurement if there is retransmission
    tcb->rtt_tick = 0;

    // Retransmit the first segment
    if (tcb->persistFlag) {
        if (sendbuf->retries == 0) {
            // Send out the window probe segment for the first time.
            // BUGBUG: we always send out the whole segment instead
            // of just a single byte of data.

            ASSERT(sendbuf == tcb->sendbufNext);
            TcbSendSegment(tcb, sendbuf);
            tcb->snd_nxt = sendbuf->seqnext;
            tcb->sendbufNext = TcbSendbufFlink(sendbuf);
            return tcb;
        }
    } else {
        TRACE_("Retransmission timeout: %u, %d", sendbuf->seq, sendbuf->retries);
        ASSERT(sendbuf->retries != 0);
        TcpStats.rexmitTimeouts++;

        // Congestion control:
        //  set the slow-start threshold to be half the flight size
        //  and set the congestion window to be 1 SMSS
        TcbResetSsthresh(tcb);
        tcb->snd_cwnd = tcb->snd_mss;
        TcbStopFastRexmitMode(tcb);
    }

    TcbSendSegment(tcb, sendbuf);
    return tcb;
}


VOID
TcpSourceQuench(
    const IpHeader* iphdr
    )

/*++

Routine Description:

    Process ICMP source quench error message
    for a TCP connection

Arguments:

    iphdr - Points to the original IP header + at least 8 bytes of data

Return Value:

    NONE

--*/

{
    const TcpHeader* tcphdr;
    TCB* tcb;

    tcphdr = (const TcpHeader*) ((const BYTE*) iphdr + GETIPHDRLEN(iphdr));
    tcb = (TCB*) PcbFindMatch(
                    iphdr->srcaddr,
                    tcphdr->srcport,
                    iphdr->dstaddr,
                    tcphdr->dstport,
                    SOCK_STREAM,
                    IPPROTOCOL_TCP);

    if (tcb && IsTcpSyncState(tcb)) {
        // Treat source quench the same way as a retransmission timeout:
        //  reset the slow-start threshold
        //  and set the cwnd to 1 SMSS
        TcbResetSsthresh(tcb);
        tcb->snd_cwnd = tcb->snd_mss;
        TcbStopFastRexmitMode(tcb);
    }
}


VOID
TcbDoFastRexmit(
    TCB* tcb
    )

/*++

Routine Description:

    Initiate the TCP fast retransmit / recovery procedure

Arguments:

    tcb - Points to the TCP control block

Return Value:

    NONE

--*/

{
    TCPSENDBUF* sendbuf;

    TRACE_("Fast rexmit mode: %u", tcb->snd_una);
    TcpStats.fastRexmits++;

    // Reset the slow-start threshold
    // and set the congestion window to be that plus 3*SMSS
    TcbResetSsthresh(tcb);
    tcb->snd_cwnd = tcb->snd_ssthresh + 3*tcb->snd_mss;
    tcb->fastRexmitFlag = 1;
    tcb->dupacks = 0;

    // Retransmit the "lost" segment immediately
    sendbuf = TcbFirstSendbuf(tcb);
    ASSERT(sendbuf != TcbSendbufNil(tcb) && sendbuf->retries);
    TcbSendSegment(tcb, sendbuf);
}


VOID
TcbQueueSegment(
    TCB* tcb,
    Packet* pkt,
    BYTE tcpflags
    )

/*++

Routine Description:

    Initialize the header information for an outgoing TCP packet

Arguments:

    tcb - Points to the TCP control block
    pkt - Points to the outgoing TCP packet
    tcpflags - Specifies the TCP segment flags

Return Value:

    NONE

--*/

// TCP option length in our SYN segment
#define SYNTCPOPTLEN 4

{
    TCPSENDBUF* sendbuf;

    RUNS_AT_DISPATCH_LEVEL

    sendbuf = GETPKTBUF(pkt, TCPSENDBUF);
    sendbuf->refcount = 1;
    sendbuf->retries = 0;
    sendbuf->tcpflags = tcpflags;
    sendbuf->tcphdrlen = (BYTE) ((tcpflags & TCP_SYN) ?
                                    TCPHDRLEN+SYNTCPOPTLEN :
                                    TCPHDRLEN);
    sendbuf->seq = tcb->snd_end;

    if (tcpflags & (TCP_SYN|TCP_FIN)) {
        sendbuf->datalen = 0;
        sendbuf->seqnext = sendbuf->seq + 1;
    } else {
        sendbuf->datalen = pkt->datalen - TCPHDRLEN;
        sendbuf->seqnext = sendbuf->seq + sendbuf->datalen;
    }
    tcb->snd_end = sendbuf->seqnext;

    tcb->sendbufSize += sendbuf->datalen;
    InsertTailList(&tcb->sendbuf, &sendbuf->links);

    if (!TcbHasPendingSend(tcb)) {
        tcb->sendbufNext = sendbuf;
        TcbStartOutput(tcb);
    }
}


//
// TCP segment packet completion routine
//
PRIVATE VOID TcbSendCompletionProc(Packet* pkt, NTSTATUS status) {
    TCPSENDBUF* sendbuf = GETPKTBUF(pkt, TCPSENDBUF);
    pkt->data = sendbuf->pktdata;
    pkt->datalen = sendbuf->pktdatalen;
    SendbufRelease(sendbuf);
}

//
// Allocate packet buffer for sending a TCP segment
// (that could be retransmitted)
//
PRIVATE Packet*
TcbAllocSendbuf(
    UINT datalen,
    UINT pktflags
    )
{
    UINT hdrlen;
    Packet* pkt;
    TCPSENDBUF* sendbuf;

    hdrlen = sizeof(TCPSENDBUF) + MAXLINKHDRLEN + MAXIPHDRLEN;
    datalen += TCPHDRLEN;
    pkt = XnetAllocPacket(hdrlen + datalen, pktflags);
    if (!pkt) return NULL;

    pkt->data += hdrlen;
    pkt->datalen = datalen;
    sendbuf = GETPKTBUF(pkt, TCPSENDBUF);
    sendbuf->pktdata = pkt->data;
    sendbuf->pktdatalen = pkt->datalen;

    XnetSetPacketCompletion(pkt, TcbSendCompletionProc);
    return pkt;
}


NTSTATUS
TcbSend(
    TCB* tcb,
    SENDREQ* sendreq
    )

/*++

Routine Description:

    Handle a user request to send data from a TCP socket

Arguments:

    tcb - Points to the TCP control block
    sendreq - Points to the send request information

Return Value:

    Status code

Note:

    This function always return immediately. For blocking operation,
    we assume the caller has taken care of any necessary wait.

--*/

{
    NTSTATUS status = NETERR_OK;
    Packet* pkt = NULL;
    WSABUF* bufs = sendreq->bufs;
    UINT bytesToSend = sendreq->sendtotal;
    UINT mss = tcb->snd_mss - tcb->ipoptlen;
    UINT n, datalen;
    BYTE* data;
    KIRQL irql;

    // Make sure we don't overflow the send buffer too much.
    // In the following case:
    //  old sendbuf size + the datagram size > max sendbuf size
    // we'll temporarily exceed the send buffer size limit a little bit.
    ASSERT(!IsPcbSendBufFull(tcb));
    n = tcb->maxSendBufsize - tcb->sendbufSize;
    if (bytesToSend > max(n, mss))
        sendreq->sendtotal = bytesToSend = mss;

    data = bufs->buf;
    datalen = bufs->len;

    while (bytesToSend > 0) {
        UINT segsize = min(mss, bytesToSend);
        BYTE* p;

        pkt = TcbAllocSendbuf(segsize, 0);
        if (!pkt) {
            if ((sendreq->sendtotal -= bytesToSend) == 0) {
                // If we've already send out some data,
                // then return success with partial byte count.
                // Otherwise, return error code.
                status = NETERR_MEMORY;
            }
            break;
        }

        bytesToSend -= segsize;
        p = pkt->data + TCPHDRLEN;
        if (segsize <= datalen) {
            // Fast case: all the data for this segment
            // comes from the same user buffer.
            CopyMem(p, data, segsize);
            data += segsize;
            datalen -= segsize;
        } else {
            // Slow case: need to gather data for this segment
            // from multiple user buffers.
            while (segsize) {
                while (datalen == 0) {
                    bufs++;
                    data = bufs->buf;
                    datalen = bufs->len;
                }
                n = min(segsize, datalen);
                CopyMem(p, data, n);
                p += n;
                data += n;
                datalen -= n;
                segsize -= n;
            }
        }

        irql = RaiseToDpc();
        status = PcbGetErrStatus(tcb);
        if (NT_SUCCESS(status)) {
            TcbQueueSegment(tcb, pkt, (BYTE) (bytesToSend ? TCP_ACK : (TCP_ACK|TCP_PSH)));
            LowerFromDpc(irql);
        } else {
            XnetFreePacket(pkt);
            LowerFromDpc(irql);
            break;
        }
    }

    // If the app calls connect() on a non-blocking socket, and then calls send()
    // without calling select(), then we need to reset the connectSelected flag
    // so future select() calls will ignore PCBEVENT_CONNECT.
    tcb->connectSelected = 1;

    return status;
}


VOID
TcbEmitRST(
    IfInfo* ifp,
    IpAddrPair* addrpair,
    TCPSEQ seq,
    TCPSEQ ack,
    BYTE flags
    )

/*++

Routine Description:

    Send out a TCP RST segment in response to a received packet

Arguments:

    ifp - Points the interface involved
    addrpair - Specifies the source and destination
    seq, ack - Specifies the sequence and acknowledgement number
    flag - Specifies the TCP segment flags

Return Value:

    NONE

--*/

{
    Packet* pkt;

    pkt = XnetAllocIpPacket(0, TCPHDRLEN);
    if (!pkt) return;

    FILL_TCPHEADER(
        pkt,
        addrpair,
        seq,
        ack,
        TCPHDRLEN,
        (BYTE) (TCP_RST|flags),
        0);

    IpSendPacketInternal(pkt, addrpair->srcaddr, addrpair->dstaddr, IPPROTOCOL_TCP, ifp);
}


NTSTATUS
TcbEmitSYN(
    TCB* tcb,
    BOOL synAck
    )

/*++

Routine Description:

    Emit a TCP SYN segment

Arguments:

    tcb - Points to the TCP control block
    synAck - Whether to send ACK as well

Return Value:

    Status code

--*/

{
    Packet* pkt;
    BYTE* opt;
    TCPSENDBUF* sendbuf;

    // Check if we're already trying to send out a SYN segment
    if (!IsPcbSendBufEmpty(tcb)) {
        sendbuf = (TCPSENDBUF*) RemoveHeadList(&tcb->sendbuf);
        SendbufRelease(sendbuf);
        ASSERT(IsPcbSendBufEmpty(tcb));
        ASSERT(!TcbHasPendingSend(tcb));
    }

    tcb->snd_una = tcb->snd_nxt = tcb->snd_end = tcb->snd_isn;

    // Allocate a TCP send buffer for possible retransmission
    pkt = TcbAllocSendbuf(SYNTCPOPTLEN, synAck ? PKTFLAG_NETPOOL : 0);
    if (!pkt) {
        // This is very bad - we failed to allocate memory
        // for the SYN segment. We'll mark the TCB as dead
        // and return an error code.
        TcbReset(tcb, NETERR_MEMORY);
        return NETERR_MEMORY;
    }

    TcbSetSynTimer(tcb, cfgConnectTimeout);

    opt = pkt->data + TCPHDRLEN;
    opt[0] = TCPOPT_MAX_SEGSIZE;
    opt[1] = SYNTCPOPTLEN;
    opt[2] = (BYTE) (tcb->rcv_mss >> 8);
    opt[3] = (BYTE) tcb->rcv_mss;

    TcbQueueSegment(tcb, pkt, (BYTE) (synAck ? TCP_SYN|TCP_ACK : TCP_SYN));
    return NETERR_OK;
}


VOID
TcbEmitACK(
    TCB* tcb
    )

/*++

Routine Description:

    Send out an ACK segment on a TCP connection

Arguments:

    tcb - Points to the TCP control block

Return Value:

    NONE

--*/

{
    TCPSEQ seq;
    Packet* pkt = XnetAllocPacket(MAXLINKHDRLEN + MAXIPHDRLEN + TCPHDRLEN, PKTFLAG_NETPOOL);
    if (!pkt) return;

    pkt->data += MAXLINKHDRLEN + MAXIPHDRLEN;
    pkt->datalen = TCPHDRLEN;

    seq = TcbSndNxt(tcb);
    FILL_TCPHEADER(
        pkt,
        &tcb->addrpair,
        seq,
        tcb->rcv_nxt,
        TCPHDRLEN,
        TCP_ACK,
        (WORD) tcb->rcv_wnd);

    tcb->delayedAcks = 0;
    PcbSetupIpHeader((PCB*) tcb, pkt, &tcb->addrpair);
    IpSendPacket(pkt, tcb->dstaddr, NULL, &tcb->rte);
}


NTSTATUS
TcbEmitFIN(
    TCB* tcb
    )

/*++

Routine Description:

    Send out a FIN segment on a TCP connection

Arguments:

    tcb - Points to the TCP control block

Return Value:

    Status code

--*/

{
    Packet* pkt = TcbAllocSendbuf(0, 0);
    if (!pkt) return NETERR_MEMORY;
    TcbQueueSegment(tcb, pkt, TCP_ACK|TCP_FIN);
    return NETERR_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\test\lib\precomp.h ===
#include "xnetp.h"
#include "xnettest.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\test\tcptest\precomp.h ===
#include "xnetp.h"
#include "xnettest.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\test\tftp\precomp.h ===
#include "xnetp.h"
#include "xnettest.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\test\httptest\precomp.h ===
#include "xnetp.h"
#include "xnettest.h"
#include <wininet.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\test\lib\seqfile.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    seqfile.c

Abstract:

    Sequential file I/O functions

Revision History:

    08/07/2000 davidx
        Created it.

--*/

#include "precomp.h"

//
// File buffer size (must be a multiple of 512, default = 4KB)
//
UINT cfgSeqFileBufSize = 4*1024;

//
// Sequential file object
//
typedef struct _SeqFile {
    HANDLE handle;
    DWORD accessMode;
    UINT writeTotal;
    UINT bufsize;
    UINT bufptr;
    CHAR* buf;
} SeqFile;

//
// Forward function declarations
//
PRIVATE BOOL WriteDataToDisk(SeqFile* file);
PRIVATE BOOL FixupFileSize(SeqFile* file);


SeqFile*
_CreateFile(
    const CHAR* filename,
    DWORD accessMode
    )

/*++

Routine Description:

    Open a file for sequential read or write access

Arguments:

    filename - Specifies the filename
    accessMode - Access mode: GENERIC_READ or GENERIC_WRITE

Return Value:

    Pointer to the open file object
    NULL if there is an error

--*/

{
    SeqFile* file;
    OBJECT_STRING str;
    CHAR filenamebuf[MAX_PATH];
    const CHAR* prefix;
    CHAR* p;
    INT prefixlen, filenamelen;
    HANDLE handle;
    IO_STATUS_BLOCK iostatusBlock;
    OBJECT_ATTRIBUTES objAttrs;
    NTSTATUS status;

    ASSERT(filename != NULL);
    ASSERT(accessMode == GENERIC_READ || accessMode == GENERIC_WRITE);

    // HACK: munge the input filename:
    //  convert from ASCII to unicode
    //  map drive letters to prefix strings

    filenamelen = strlen(filename);
    if (filenamelen >= 3 && filename[1] == ':' && filename[2] == '\\') {
        if (filename[0] == 'c' || filename[0] == 'C') {
            filename += 3;
            filenamelen -= 3;
            prefix = "\\Device\\Harddisk0\\Partition1\\";
        } else {
            prefix = "\\??\\";
        }
    } else {
        prefix = "";
    }

    prefixlen = strlen(prefix);
    if (filenamelen == 0 || (filenamelen += prefixlen) >= MAX_PATH) {
        SetLastError(ERROR_INVALID_NAME);
        return NULL;
    }

    p = filenamebuf;
    CopyMem(p, prefix, prefixlen);

    p += prefixlen;
    strcpy(p, filename);

    // Prepare parameters to call NtCreateFile

    str.Buffer = filenamebuf;
    str.Length = (USHORT) filenamelen;
    str.MaximumLength = str.Length + 1;
    InitializeObjectAttributes(&objAttrs, &str, OBJ_CASE_INSENSITIVE, NULL, NULL);

    // Allocate memory for the file object

    file = MAlloc0(sizeof(SeqFile));
    if (!file) return NULL;
    file->handle = INVALID_HANDLE_VALUE;
    file->accessMode = accessMode;

    file->buf = VirtualAlloc(NULL, cfgSeqFileBufSize, MEM_COMMIT|MEM_RESERVE, PAGE_READWRITE);
    if (!file->buf) {
        Free(file);
        return NULL;
    }

    // Open the file
    //  Notice that we always set the "no buffering" flag

    status = NtCreateFile(
               &file->handle,
               accessMode|SYNCHRONIZE|FILE_READ_ATTRIBUTES,
               &objAttrs,
               &iostatusBlock,
               NULL,
               FILE_ATTRIBUTE_NORMAL,
               (accessMode == GENERIC_READ) ? FILE_SHARE_READ : 0,
               (accessMode == GENERIC_READ) ? FILE_OPEN : FILE_OVERWRITE_IF,
               FILE_SYNCHRONOUS_IO_NONALERT |
                   FILE_SEQUENTIAL_ONLY |
                   FILE_NO_INTERMEDIATE_BUFFERING);

    if (!NT_SUCCESS(status)) {
        WARNING_("NtCreateFile failed: 0x%x", status);
        SetLastError(RtlNtStatusToDosError(status));
        _CloseFile(file);
        return NULL;
    }

    return file;
}


VOID
_CloseFile(
    SeqFile* file
    )

/*++

Routine Description:

    Close a file object returned by _CreateFile

Arguments:

    file - Points to the file object to be closed

Return Value:

    NONE

--*/

{
    if (!file) return;

    //
    // If the file was opened for writing, we to update
    // the correct file size before closing the file.
    //
    if (file->accessMode == GENERIC_WRITE) {
        FixupFileSize(file);
    }

    //
    // Close the file handle and
    // dispose of the file object
    //
    if (file->handle != INVALID_HANDLE_VALUE) {
        NTSTATUS status = NtClose(file->handle);
        if (!NT_SUCCESS(status)) {
            WARNING_("NtClose failed: 0x%x", status);
        }
    }

    if (file->buf && !VirtualFree(file->buf, 0, MEM_RELEASE)) {
        WARNING_("VirtualFree failed: %d", GetLastError());
    }
    Free(file);
}


BOOL
_ReadFile(
    SeqFile* file,
    CHAR** buf,
    UINT* buflen
    )

/*++

Routine Description:

    Read data from a file

Arguments:

    file - Points to the file object
    buf - Returns a pointer to the buffered data
    buflen - On input, contain the maximum buffer size;
        On exit, contain the actual number of bytes read

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    ASSERT(file != NULL && file->accessMode == GENERIC_READ);

    //
    // Check if we still have data left in our internal buffer
    // If not, read more data from the disk into our buffer
    //
    if (file->bufptr == file->bufsize) {
        NTSTATUS status;
        IO_STATUS_BLOCK iostatusBlock;

        file->bufptr = file->bufsize = 0;
        status = NtReadFile(
                    file->handle,
                    NULL,
                    NULL,
                    NULL,
                    &iostatusBlock,
                    file->buf,
                    cfgSeqFileBufSize,
                    NULL);

        if (status == STATUS_PENDING) {
            status = NtWaitForSingleObject(file->handle, FALSE, NULL);
            if (NT_SUCCESS(status))
                status = iostatusBlock.Status;
        }

        if (NT_SUCCESS(status)) {
            file->bufsize = iostatusBlock.Information;
        } else if (status != STATUS_END_OF_FILE) {
            WARNING_("NtReadFile failed: 0x%x", status);
            SetLastError(RtlNtStatusToDosError(status));
            return FALSE;
        }
    }

    //
    // Copy data from our internal buffer to
    // the caller-supplied output buffer
    //
    if (*buflen > file->bufsize - file->bufptr)
        *buflen = file->bufsize - file->bufptr;

    *buf = file->buf + file->bufptr;
    file->bufptr += *buflen;
    return TRUE;
}


BOOL
_WriteFile(
    SeqFile* file,
    const VOID* buf,
    UINT buflen
    )

/*++

Routine Description:

    Write data to a file

Arguments:

    file - Points to the file object
    buf - Points to the data buffer
    buflen - Specifies the buffer size

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    const CHAR* srcbuf = (const CHAR*) buf;
    ASSERT(file != NULL && file->accessMode == GENERIC_WRITE);

    while (buflen) {
        UINT count;

        // Copy data from the caller's buffer to our internal buffer
        count = min(cfgSeqFileBufSize - file->bufptr, buflen);
        CopyMem(file->buf + file->bufptr, srcbuf, count);
        srcbuf += count;
        file->bufptr += count;
        file->writeTotal += count;

        // If our buffer is full, write data out to the disk
        if (file->bufptr == cfgSeqFileBufSize && !WriteDataToDisk(file))
            return FALSE;

        buflen -= count;
    }

    return TRUE;
}


PRIVATE BOOL
FixupFileSize(
    SeqFile* file
    )

/*++

Routine Description:

    Fix up the correct file size information. This is called
    when a file that was opened for write is closed.

Arguments:

    file - Points to the file object

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    NTSTATUS status;
    IO_STATUS_BLOCK iostatusBlock;
    FILE_END_OF_FILE_INFORMATION endOfFile;
    FILE_ALLOCATION_INFORMATION allocation;

    ASSERT(file->accessMode == GENERIC_WRITE);
    if (file->bufptr == 0) return TRUE;

    //
    // Write the last unfinished sector to disk
    //
    if (!WriteDataToDisk(file)) return FALSE;

    //
    // Set the end-of-file pointer
    //
    endOfFile.EndOfFile.QuadPart = file->writeTotal;
    status = NtSetInformationFile(
                file->handle,
                &iostatusBlock,
                &endOfFile,
                sizeof(endOfFile),
                FileEndOfFileInformation);

    if (NT_SUCCESS(status)) {
        //
        // Set the allocation based on the file size
        //
        allocation.AllocationSize.QuadPart = file->writeTotal;
        status = NtSetInformationFile(
                    file->handle,
                    &iostatusBlock,
                    &allocation,
                    sizeof(allocation),
                    FileAllocationInformation);
    }

    if (!NT_SUCCESS(status)) {
        WARNING_("Failed to set file size: 0x%x", status);
        SetLastError(RtlNtStatusToDosError(status));
        return FALSE;
    }

    return TRUE;
}


PRIVATE BOOL
WriteDataToDisk(
    SeqFile* file
    )

/*++

Routine Description:

    Write data from the file buffer to the disk

Arguments:

    file - Points to the file object

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    NTSTATUS status;
    IO_STATUS_BLOCK iostatusBlock;
    UINT count;

    // Always write in 512-byte blocks
    count = (file->bufptr + 511) & ~511;
    file->bufptr = 0;

    status = NtWriteFile(
                file->handle,
                NULL,
                NULL,
                NULL,
                &iostatusBlock,
                file->buf,
                count,
                NULL);

    if (status == STATUS_PENDING) {
        status = NtWaitForSingleObject(file->handle, FALSE, NULL);
        if (NT_SUCCESS(status))
            status = iostatusBlock.Status;
    }

    if (NT_SUCCESS(status) && count == iostatusBlock.Information)
        return TRUE;

    WARNING_("NtWriteFile failed: 0x%x", status);
    SetLastError(RtlNtStatusToDosError(status));
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\test\mcping\mcping.c ===
// This is a simple program for testing the following functionality:
//  multicast send and receive
//  RAW socket
//  Winsock select API

#include "precomp.h"
#include <stdlib.h>

UINT WINAPI tcpipxsum(UINT xsum, const VOID* buf, UINT buflen);

#define RCVTIMEOUT  3
#define PINGBUFSIZE 2048
#define TESTADDR    "229.0.0.1"

INT testFlag = 2;
INT err;
CHAR databuf[PINGBUFSIZE];
INT rcvlen;
WORD id, seqno;
CHAR pingdata[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";


VOID
SendIcmpMessage(
    SOCKET s,
    struct sockaddr_in* toaddr,
    IcmpMessage* icmpmsg,
    UINT msglen
    )
{
    icmpmsg->checksum = 0;
    icmpmsg->checksum = (WORD) ~tcpipxsum(0, icmpmsg, msglen);

    err = _sendto(s, (CHAR*) icmpmsg, &msglen, toaddr);
    if (err != NO_ERROR) {
        WARNFAIL(sendto);
    }
}


BOOL
RecvIcmpMessage(
    SOCKET s,
    struct sockaddr_in* fromaddr
    )
{
    TIMEVAL timeout;
    fd_set readfds;
    DWORD len;

    // Wait until there is data to be read

    timeout.tv_sec = RCVTIMEOUT;
    timeout.tv_usec = 0;

    FD_ZERO(&readfds);
    FD_SET(s, &readfds);

    err = select(1, &readfds, NULL, NULL, &timeout);
    if (err == SOCKET_ERROR) {
        WARNFAIL(select); return FALSE;
    }

    if (err == 0) return FALSE;

    len = PINGBUFSIZE;
    err = _recvfrom(s, databuf, &len, fromaddr);
    if (err != NO_ERROR) {
        WARNFAIL(recvfrom); return FALSE;
    }

    rcvlen = len;
    return TRUE;
}


VOID
McastPing()
{
    SOCKET sock;
    struct sockaddr_in sockname;
    IcmpMessage* icmpmsg;
    struct in_addr mcastif;
    struct ip_mreq mcastreq;

    sock = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);
    if (sock == INVALID_SOCKET) {
        WARNFAIL(socket); return;
    }

    ZeroMem(&sockname, sizeof(sockname));
    sockname.sin_family = AF_INET;
    sockname.sin_port = 0;
    sockname.sin_addr.s_addr = INADDR_ANY;

    err = _bind(sock, &sockname);
    if (err != NO_ERROR) {
        WARNFAIL(bind); goto exit;
    }

    mcastif.s_addr = INADDR_ANY;
    err = setsockopt(sock, IPPROTO_IP, IP_MULTICAST_IF, (char*) &mcastif, sizeof(mcastif));
    if (err != NO_ERROR) {
        WARNFAIL(setmcastif); goto exit;
    }

    mcastreq.imr_multiaddr.s_addr = inet_addr(TESTADDR);
    mcastreq.imr_interface.s_addr = INADDR_ANY;
    err = setsockopt(sock, IPPROTO_IP, IP_ADD_MEMBERSHIP, (char*) &mcastreq, sizeof(mcastreq));
    if (err != NO_ERROR) {
        WARNFAIL(addmember); goto exit;
    }

    do {
        DbgPrint(".");
        if (testFlag == 2) {
            icmpmsg = (IcmpMessage*) databuf;
            icmpmsg->type = ICMPTYPE_ECHO_REQUEST;
            icmpmsg->code = 0;
            icmpmsg->id = id++;
            icmpmsg->seqno = seqno++;
            CopyMem(icmpmsg->origdata, pingdata, sizeof(pingdata));
            sockname.sin_addr.s_addr = inet_addr(TESTADDR);

            DbgPrint("Sending out ICMP echo request...\n");
            DbgPrint("  id = %d, seqno = %d\n", icmpmsg->id, icmpmsg->seqno);

            SendIcmpMessage(
                sock,
                &sockname,
                icmpmsg,
                ICMPHDRLEN + sizeof(pingdata));

            testFlag = 1;
        }

        if (RecvIcmpMessage(sock, &sockname)) {
            IpHeader* iphdr = (IpHeader*) databuf;
            INT iphdrlen, iplen;

            DbgPrint("Received ICMP message from %s:\n", inet_ntoa(sockname.sin_addr));

            if (rcvlen < IPHDRLEN ||
                (iphdrlen = GETIPHDRLEN(iphdr)) == 0 ||
                iphdrlen > rcvlen ||
                (iplen = GETIPLEN(iphdr)) > rcvlen ||
                iphdrlen > iplen) {
                DbgPrint("  Bad IP header!\n");
                continue;
            }

            rcvlen = iplen - iphdrlen;
            icmpmsg = (IcmpMessage*) &databuf[iphdrlen];
            
            if (rcvlen < ICMPHDRLEN ||
                tcpipxsum(0, icmpmsg, rcvlen) != 0xffff) {
                DbgPrint("  Bad ICMP header!\n");
            }
            
            DbgPrint("  type = %d, code = %d\n", icmpmsg->type, icmpmsg->code);
            DbgPrint("  id = %d, seqno = %d\n", icmpmsg->id, icmpmsg->seqno);
            DbgPrint("  %d bytes of data: %s\n", rcvlen - ICMPHDRLEN, icmpmsg->origdata);

            if (icmpmsg->type == ICMPTYPE_ECHO_REQUEST) {
                DbgPrint("Sending out ICMP echo reply...\n");
                icmpmsg->type = ICMPTYPE_ECHO_REPLY;
                SendIcmpMessage(sock, &sockname, icmpmsg, rcvlen);
            }
        }
    } while (testFlag > 0);

    err = setsockopt(sock, IPPROTO_IP, IP_DROP_MEMBERSHIP, (char*) &mcastreq, sizeof(mcastreq));
    if (err != NO_ERROR) {
        WARNFAIL(dropmember); goto exit;
    }

exit:
    closesocket(sock);
}


void __cdecl main()
{
    WSADATA wsadata;

    DbgPrint("Loading XBox network stack...\n");
    err = XnetInitialize(NULL, TRUE);
    if (err != NO_ERROR) {
        WARNFAIL(XnetInitialize); goto stop;
    }

    err = WSAStartup(WINSOCK_VERSION, &wsadata);
    if (err != NO_ERROR) {
        WARNFAIL(WSAStartup); goto unload;
    }

    DbgPrint("*** Test started, press 'g' to continue...\n");
    DbgPrint("*** To quit, press CTRL-C and type: ed %x 0;g\n", &testFlag);
    BREAK_INTO_DEBUGGER

    id = (WORD) (GetTickCount() >> 16);
    seqno = (WORD) (GetTickCount() & 0xffff);

    McastPing();
    WSACleanup();
    
unload:
    DbgPrint("Unloading XBox network stack...\n");
    XnetCleanup();

stop:
    if (testFlag == 0)
        HalReturnToFirmware(HalRebootRoutine);
    else
        Sleep(INFINITE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\test\httptest\httptest.cxx ===
// HTTP Client Library test program

#include "precomp.h"

INT testFlag = 1;
INT err;

#define BUFSIZE 4096
CHAR buf[BUFSIZE];
LPCWSTR acceptTypes[] = { L"*/*", NULL };

//
// Use our own new/delete operators
//
VOID* __cdecl operator new(size_t size) {
    return MAlloc(size);
}

VOID __cdecl operator delete(VOID* p) {
    Free(p);
}


//
// Dump the HTTP response headers
//
#define HTTPQUERYINFO(_infolevel, _buf, _len, _barf) \
        len = (_len); \
        ok = HttpQueryInfo(hRequest, _infolevel, &(_buf), &len, NULL); \
        if (!ok && _barf) { \
            WARNFAIL(HttpQueryInfo); return; \
        }


VOID
DumpResponseHeaders(
    HINTERNET hRequest
    )
{
    #define _FIELD(x) { x, #x }
    static const struct {
        DWORD index;
        CHAR* name;
    } infoLevels[] = {
        _FIELD(HTTP_QUERY_CONTENT_TYPE),
        _FIELD(HTTP_QUERY_CONTENT_LENGTH),
        _FIELD(HTTP_QUERY_DATE),
        _FIELD(HTTP_QUERY_EXPIRES),
        _FIELD(HTTP_QUERY_LAST_MODIFIED),
        _FIELD(HTTP_QUERY_VERSION),
        _FIELD(HTTP_QUERY_STATUS_CODE),
        _FIELD(HTTP_QUERY_STATUS_TEXT),
        _FIELD(HTTP_QUERY_ACCEPT),
    };

    DWORD statusCode;
    DWORD len;
    WCHAR buf[1024];
    UINT i, count;
    BOOL ok;

    HTTPQUERYINFO(
        HTTP_QUERY_STATUS_CODE|HTTP_QUERY_FLAG_NUMBER,
        statusCode,
        sizeof(statusCode),
        TRUE);
    DbgPrint("Response status code: %d\n", statusCode);

    switch (testFlag) {
    case 1: {
        SYSTEMTIME systime;
        HTTPQUERYINFO(
            HTTP_QUERY_DATE|HTTP_QUERY_FLAG_SYSTEMTIME,
            systime,
            sizeof(systime),
            TRUE);

        DbgPrint("Date: %04d/%02d/%02d %d %02d:%02d:%02d\n",
            systime.wYear,
            systime.wMonth,
            systime.wDay,
            systime.wDayOfWeek,
            systime.wHour,
            systime.wMinute,
            systime.wSecond);
        }

    case 2: {
        
        i = (testFlag == 1) ?
                HTTP_QUERY_RAW_HEADERS :
                HTTP_QUERY_RAW_HEADERS_CRLF;

        len = 0;
        if (HttpQueryInfo(hRequest, i, NULL, &len, NULL) ||
            GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
            WARNFAIL(HttpQueryInfo); return;
        }

        WCHAR* hdrbuf = (WCHAR*) MAlloc(len);
        if (!hdrbuf) {
            WARNFAIL(MAlloc); return;
        }

        len /= sizeof(WCHAR);
        if (!HttpQueryInfo(hRequest, i, hdrbuf, &len, NULL)) {
            WARNFAIL(HttpQueryInfo);
            Free(hdrbuf);
            return;
        }

        WCHAR* p = hdrbuf;
        if (i == HTTP_QUERY_RAW_HEADERS_CRLF) {
            while (*p) {
                if (p[0] == L'\r' && p[1] == L'\n') {
                    *p++ = L' ';
                    *p++ = 0;
                } else
                    p++;
            }
            p = hdrbuf;
        }

        while (*p) {
            DbgPrint("%ws\n", p);
            p += wcslen(p) + 1;
        }

        Free(hdrbuf);
        }
        break;

    case 3:

        count = ARRAYCOUNT(infoLevels);
        for (i=0; i < count; i++) {
            HTTPQUERYINFO(infoLevels[i].index, buf, ARRAYCOUNT(buf), FALSE);
            DbgPrint("%3s: ", infoLevels[i].name);
            if (ok) {
                DbgPrint("%ws\n", buf);
            } else {
                DbgPrint("*** error - %d\n", GetLastError());
            }
        }

        wcscpy(buf, L"Server");
        HTTPQUERYINFO(HTTP_QUERY_CUSTOM, buf, ARRAYCOUNT(buf), FALSE);
        DbgPrint("Server: ");
        if (ok) {
            DbgPrint("%ws\n", buf);
        } else {
            DbgPrint("*** error - %d\n", GetLastError());
        }
        break;
    }
}


//
// Dump the HTTP response message in response to a request
//
VOID
DumpGetResponse(
    HINTERNET hRequest
    )
{
    DumpResponseHeaders(hRequest);

    DWORD size, total = 0;

    do {
        if (!InternetReadFile(hRequest, buf, BUFSIZE, &size)) {
            WARNFAIL(InternetReadFile); return;
        }
        total += size;
    } while (size != 0);

    DbgPrint("Response data: %d bytes\n\n", total);
}


//
// HTTP GET without using a proxy server
//
VOID
GetTestDirect()
{
    HINTERNET hInternet;
    HINTERNET hRequest;

    hInternet = InternetOpen(NULL, INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);
    if (!hInternet) {
        WARNFAIL(InternetOpen); return;
    }

    hRequest = InternetOpenUrl(hInternet, L"http://davidx3", NULL, 0, 0, 0);
    if (!hRequest) {
        WARNFAIL(InternetOpenUrl);
    } else {
        DumpGetResponse(hRequest);
        InternetCloseHandle(hRequest);
    }

    InternetCloseHandle(hInternet);
}


//
// HTTP GET through a proxy server
//
VOID
GetTestProxied()
{
    HINTERNET hInternet;
    HINTERNET hConnect = NULL;
    HINTERNET hRequest = NULL;

    hInternet = InternetOpen(NULL, INTERNET_OPEN_TYPE_PROXY, L"itgproxy", NULL, 0);
    if (!hInternet) {
        WARNFAIL(InternetOpen); return;
    }

    // Use InternetConnect/HttpOpenRequest/HttpSendRequest
    // instead of InternetOpenUrl for this test

    hConnect = InternetConnect(
                    hInternet,
                    L"www.xbox.com",
                    INTERNET_DEFAULT_HTTP_PORT,
                    NULL,
                    NULL,
                    INTERNET_SERVICE_HTTP,
                    0,
                    0);

    if (!hConnect) {
        WARNFAIL(InternetConnect); goto exit;
    }

    hRequest = HttpOpenRequest(
                    hConnect,
                    L"GET",
                    L"/xbox/flash/home.asp",
                    NULL,
                    NULL,
                    acceptTypes,
                    0,
                    0);

    if (!hRequest) {
        WARNFAIL(HttpOpenRequest); goto exit;
    }

    if (HttpSendRequest(hRequest, NULL, 0, NULL, 0)) {
        DumpGetResponse(hRequest);
    }

exit:
    if (hRequest) { InternetCloseHandle(hRequest); }
    if (hConnect) { InternetCloseHandle(hConnect); }
    InternetCloseHandle(hInternet);
}


//
// HTTP POST without using a proxy server
//
VOID
PostTestDirect()
{
    static const WCHAR extraHeaders[] =
        L"From: foo@bar.com\r\n"
        L"Content-Type: application/x-www-form-urlencoded\r\n";

    HINTERNET hInternet;
    HINTERNET hConnect = NULL;
    HINTERNET hRequest = NULL;

    hInternet = InternetOpen(NULL, INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);
    if (!hInternet) {
        WARNFAIL(InternetOpen); return;
    }

    hConnect = InternetConnect(
                    hInternet,
                    L"davidx3",
                    INTERNET_DEFAULT_HTTP_PORT,
                    NULL,
                    NULL,
                    INTERNET_SERVICE_HTTP,
                    0,
                    0);

    if (!hConnect) {
        WARNFAIL(InternetConnect); goto exit;
    }

    hRequest = HttpOpenRequest(
                    hConnect,
                    L"POST",
                    L"/test",
                    NULL,
                    NULL,
                    acceptTypes,
                    0,
                    0);

    if (!hRequest) {
        WARNFAIL(HttpOpenRequest); goto exit;
    }

    // Send additional header fields
    // and send the content of a file as optional data

    if (HttpSendRequest(
            hRequest,
            extraHeaders,
            -1, 
            L"T:\\test",
            -1)) {
        DumpGetResponse(hRequest);
    }

exit:
    if (hRequest) { InternetCloseHandle(hRequest); }
    if (hConnect) { InternetCloseHandle(hConnect); }
    InternetCloseHandle(hInternet);
}


void __cdecl main()
{
    DbgPrint("Loading XBox network stack...\n");
    err = XnetInitialize(NULL, TRUE);
    if (err != NO_ERROR) {
        WARNFAIL(XnetInitialize);
        BREAK_INTO_DEBUGGER
    }

    DbgPrint("*** Test started, press 'g' to continue...\n");

    while (TRUE) {
        DbgPrint("*** To quit, press CTRL-C and type: ed %x 0;g\n", &testFlag);
        BREAK_INTO_DEBUGGER

        if (testFlag <= 0) break;
        switch (testFlag) {
        case 1:
            GetTestDirect();
            break;

        case 2:
            GetTestProxied();
            break;

        case 3:
            PostTestDirect();
            break;
        }
    }

    XnetCleanup();

    if (testFlag == 0)
        HalReturnToFirmware(HalRebootRoutine);
    else
        Sleep(INFINITE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\test\mcping\precomp.h ===
#include "xnetp.h"
#include "xnettest.h"
#include "icmp.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\test\tftpd\precomp.h ===
#include "xnetp.h"
#include "xnettest.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\test\lib\xnettest.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    xnettest.h

Abstract:

    XBox network test shared header file

Revision History:

    08/07/2000 davidx
        Created it.

--*/

#ifndef _XNETTEST_H
#define _XNETTEST_H

//
// Wrap function for Winsock API
//
INLINE INT _send(SOCKET s, CHAR* buf, DWORD* buflen) {
    WSABUF wsabuf = { *buflen, buf };
    return WSASend(s, &wsabuf, 1, buflen, 0, 0, 0);
}

INLINE INT _sendto(SOCKET s, CHAR* buf, DWORD* buflen, struct sockaddr_in* to) {
    WSABUF wsabuf = { *buflen, buf };
    return WSASendTo(s, &wsabuf, 1, buflen, 0, (struct sockaddr*) to, sizeof(*to), 0, 0);
}

INLINE INT _recv(SOCKET s, CHAR* buf, DWORD* buflen) {
    WSABUF wsabuf = { *buflen, buf };
    DWORD flags = 0;
    return WSARecv(s, &wsabuf, 1, buflen, &flags, 0, 0);
}

INLINE INT _recvfrom(SOCKET s, CHAR* buf, DWORD* buflen, struct sockaddr_in* from) {
    WSABUF wsabuf = { *buflen, buf };
    INT fromlen = sizeof(*from);
    DWORD flags = 0;
    return WSARecvFrom(s, &wsabuf, 1, buflen, &flags, (struct sockaddr*) from, &fromlen, 0, 0);
}

INLINE INT _bind(SOCKET s, struct sockaddr_in* addr) {
    return bind(s, (struct sockaddr*) addr, sizeof(*addr));
}

INLINE INT _getsockname(SOCKET s, struct sockaddr_in* addr) {
    INT addrlen = sizeof(*addr);
    return getsockname(s, (struct sockaddr*) addr, &addrlen);
}

INLINE _connect(SOCKET s, struct sockaddr_in* addr) {
    return connect(s, (struct sockaddr*) addr, sizeof(*addr));
}

INLINE INT _accept(SOCKET s, struct sockaddr_in* addr) {
    INT addrlen = sizeof(*addr);
    return accept(s, (struct sockaddr*) addr, &addrlen);
}

INLINE INT _setrcvtimeout(SOCKET s, INT timeout) {
    return setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, (CHAR*) &timeout, sizeof(timeout));
}

//
// Sequential file I/O functions
//
typedef struct _SeqFile SeqFile;
extern UINT cfgSeqFileBufSize;

SeqFile* _CreateFile(const CHAR* filename, DWORD accessMode);
VOID _CloseFile(SeqFile* file);
BOOL _ReadFile(SeqFile* file, CHAR** buf, UINT* buflen);
BOOL _WriteFile(SeqFile* file, const VOID* buf, UINT buflen);

//
// Debugging macros
//
#define BREAK_INTO_DEBUGGER __asm int 3
#define WARNFAIL(_apiname) \
        DbgPrint(#_apiname " failed: %d %d\n", err, GetLastError())

#endif // !_XNETTEST_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\test\tcptest\tcptest.c ===
#include "precomp.h"
#include <stdlib.h>

#define MAXBUFSIZE      4096
#define MAXXFERCNT      0x100
#define TESTPORT        600
#define TESTADDR        "157.56.11.44"
//#define TESTADDR        "157.56.10.166"

CHAR buf[MAXBUFSIZE];
INT maxxfercnt = MAXXFERCNT;
INT fixxfersize = 0;
INT testFlag = 1;
INT err;
struct sockaddr_in sockname;


VOID
ServerTest()
{
    WSADATA wsadata;
    SOCKET sock, s;
    INT index, total;
    ULONG randSeed = GetTickCount();
    DWORD timer;

    err = WSAStartup(WINSOCK_VERSION, &wsadata);
    if (err != NO_ERROR) {
        WARNFAIL(WSAStartup); return;
    }

    sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock == INVALID_SOCKET) {
        WARNFAIL(socket);
        WSACleanup();
        return;
    }

    sockname.sin_family = AF_INET;
    sockname.sin_port = htons(TESTPORT);
    sockname.sin_addr.s_addr = INADDR_ANY;

    err = _bind(sock, &sockname);
    if (err != NO_ERROR) {
        WARNFAIL(bind); goto exit;
    }

    err = listen(sock, 1);
    if (err != NO_ERROR) {
        WARNFAIL(listen); goto exit;
    }

    err = _getsockname(sock, &sockname);
    if (err != NO_ERROR) {
        WARNFAIL(getsockname); goto exit;
    }

    DbgPrint("Listening on: %s:%d\n",
             inet_ntoa(sockname.sin_addr),
             ntohs(sockname.sin_port));

    s = _accept(sock, &sockname);
    if (s == INVALID_SOCKET) {
        WARNFAIL(accept); goto exit;
    }

    DbgPrint("Connected to: %s:%d\n",
             inet_ntoa(sockname.sin_addr),
             ntohs(sockname.sin_port));

    timer = GetTickCount();
    total = 0;
    for (index=0; index < maxxfercnt; index++) {
        INT count;

        if ((index & 0x3ff) == 0) DbgPrint(".");
        count = fixxfersize ? fixxfersize : RtlRandom(&randSeed) % MAXBUFSIZE + 1;

        count = send(s, buf, count, 0);
        if (count == SOCKET_ERROR) {
            WARNFAIL(send); break;
        }

        total += count;
    }

    closesocket(s);
    timer = GetTickCount() - timer;
    if (timer == 0) timer = 1;
    DbgPrint("Closing connection: %d total bytes transferred\n", total);
    DbgPrint("  time: %dmsec, rate: %d bytes/sec\n", timer, MulDiv(total, 1000, timer));
    Sleep(1000);

exit:
    closesocket(sock);
    WSACleanup();
}


VOID
ClientTest()
{
    WSADATA wsadata;
    SOCKET s;
    INT total, count;
    DWORD timer;

    err = WSAStartup(WINSOCK_VERSION, &wsadata);
    if (err != NO_ERROR) {
        WARNFAIL(WSAStartup); return;
    }

    s = socket(AF_INET, SOCK_STREAM, 0);
    if (s == INVALID_SOCKET) {
        WARNFAIL(socket);
        WSACleanup();
        return;
    }

    sockname.sin_family = AF_INET;
    sockname.sin_port = htons(TESTPORT);
    sockname.sin_addr.s_addr = inet_addr(TESTADDR);

    DbgPrint("Connecting to: %s:%d\n",
             inet_ntoa(sockname.sin_addr),
             ntohs(sockname.sin_port));

    timer = GetTickCount();
    err = _connect(s, &sockname);
    if (err != NO_ERROR) {
        WARNFAIL(connect); goto exit;
    }

    err = _getsockname(s, &sockname);
    if (err != NO_ERROR) {
        WARNFAIL(getsockname); goto exit;
    }

    DbgPrint("Local address: %s:%d\n",
             inet_ntoa(sockname.sin_addr),
             ntohs(sockname.sin_port));

    total = 0;
    do {
        count = recv(s, buf, MAXBUFSIZE, 0);
        if (count == SOCKET_ERROR) {
            WARNFAIL(recv); goto exit;
        }

        total += count;
    } while (count > 0);

    timer = GetTickCount() - timer;
    if (timer == 0) timer = 1;
    DbgPrint("Connection closed: %d total bytes transferred\n", total);
    DbgPrint("  time: %dmsec, rate: %d bytes/sec\n", timer, MulDiv(total, 1000, timer));

exit:
    closesocket(s);
    WSACleanup();
}


void __cdecl main()
{
    DbgPrint("Loading XBox network stack...\n");
    err = XnetInitialize(NULL, TRUE);
    if (err != NO_ERROR) {
        WARNFAIL(XnetInitialize); goto stop;
    }

    DbgPrint("*** Test started, press 'g' to continue...\n");

    while (TRUE) {
        DbgPrint("*** To quit, press CTRL-C and type: ed %x 0;g\n", &testFlag);
        BREAK_INTO_DEBUGGER

        if (testFlag <= 0) break;
        if (testFlag == 1) {
            ClientTest();
        } else {
            ServerTest();
        }
    }

    DbgPrint("Unloading XBox network stack...\n");
    XnetCleanup();

stop:
    if (testFlag == 0)
        HalReturnToFirmware(HalRebootRoutine);
    else
        Sleep(INFINITE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\test\tftp\tftp.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    tftp.h

Abstract:

    Simple TFTP client implementation for XBox

Revision History:

    04/19/2000 davidx
        Created it.

--*/

#ifndef _TFTP_H
#define _TFTP_H

//
// TFTP server UDP port number
//

#define TFTP_SERVER_PORT 69

//
// TFTP opcodes
//

#define TFTPOP_RRQ      1
#define TFTPOP_WRQ      2
#define TFTPOP_DATA     3
#define TFTPOP_ACK      4
#define TFTPOP_ERROR    5
#define TFTPOP_OACK     6

//
// Max TFTP packet size: 4 bytes header + 512 bytes data
//

#define TFTP_DATAPACKET_HEADERSIZE  4
#define TFTP_DATAPACKET_BLOCKSIZE   512
#define TFTP_PACKET_BUFSIZE         (4+512)

//
// Error codes
//

#define TFTPERR_UNKNOWN         0
#define TFTPERR_FILE_NOT_FOUND  1
#define TFTPERR_ACCESS_DENIED   2
#define TFTPERR_DISK_FULL       3
#define TFTPERR_INVALID_OPCODE  4
#define TFTPERR_INVALID_ID      5
#define TFTPERR_FILE_EXISTS     6
#define TFTPERR_INVALID_USER    7
#define TFTPERR_INVALID_OACK    8

//
// Timeout and retry values
//
#define TFTP_MAX_RETRIES        3
#define TFTP_RECV_TIMEOUT       2000

//
// Extract a u_short field out of an incoming TFTP message
// NOTE:
//  we assume we're on a little-endian machine and
//  take care of byte swapping here.
//
#define GETUSHORTFIELD(_var) do { \
            if (buflen < 2) goto failed; \
            _var = ((UINT) ((BYTE*) buf)[0] << 8 | \
                    (UINT) ((BYTE*) buf)[1]); \
            buf += 2; \
            buflen -= 2; \
        } while (0)

//
// Extract a string field out of an incoming TFTP message
//
#define GETSTRINGFIELD(_var) do { \
            CHAR* _p = buf; \
            CHAR* _q = _p + buflen; \
            INT _n; \
            while (_p < _q && *_p) _p++; \
            if (_p == _q) goto failed; \
            _var = buf; \
            _n = (_p - buf) + 1; \
            buf += _n; \
            buflen -= _n; \
        } while (0)

//
// Insert a u_short field into an outgoing TFTP message
// NOTE:
//  we assume we're on a little-endian machine and
//  take care of byte swapping here.
//
#define ADDUSHORTFIELD(_var) do { \
            buf[0] = (CHAR) ((_var) >> 8); \
            buf[1] = (CHAR) (_var); \
            buf += 2; \
        } while (0)

//
// Insert a string field into an outgoing TFTP message
//
#define ADDSTRINGFIELD(_var) do { \
            INT _n = strlen(_var) + 1; \
            memcpy(buf, _var, _n); \
            buf += _n; \
        } while (0)

#endif // !_TFTP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\test\tftpd\tftpd.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    tftpd.h

Abstract:

    Simple TFTP server implementation for XBox

Revision History:

    04/19/2000 davidx
        Created it.

--*/

#ifndef _TFTPD_H
#define _TFTPD_H

//
// TFTP server UDP port number
//

#define TFTP_SERVER_PORT 69

//
// TFTP opcodes
//

#define TFTPOP_RRQ      1
#define TFTPOP_WRQ      2
#define TFTPOP_DATA     3
#define TFTPOP_ACK      4
#define TFTPOP_ERROR    5
#define TFTPOP_OACK     6

//
// Max TFTP packet size: 4 bytes header + 512 bytes data
//

#define TFTP_DATAPACKET_HEADERSIZE  4
#define TFTP_DATAPACKET_BLOCKSIZE   512
#define TFTP_PACKET_BUFSIZE         (4+512)

//
// Error codes
//

#define TFTPERR_UNKNOWN         0
#define TFTPERR_FILE_NOT_FOUND  1
#define TFTPERR_ACCESS_DENIED   2
#define TFTPERR_DISK_FULL       3
#define TFTPERR_INVALID_OPCODE  4
#define TFTPERR_INVALID_ID      5
#define TFTPERR_FILE_EXISTS     6
#define TFTPERR_INVALID_USER    7
#define TFTPERR_INVALID_OACK    8

//
// Timeout and retry values
//
#define TFTP_MAX_RETRIES        3
#define TFTP_RECV_TIMEOUT       2000

//
// Extract a u_short field out of an incoming TFTP message
// NOTE:
//  we assume we're on a little-endian machine and
//  take care of byte swapping here.
//
#define GETUSHORTFIELD(_var) do { \
            if (buflen < 2) goto failed; \
            _var = ((UINT) ((BYTE*) buf)[0] << 8 | \
                    (UINT) ((BYTE*) buf)[1]); \
            buf += 2; \
            buflen -= 2; \
        } while (0)

//
// Extract a string field out of an incoming TFTP message
//
#define GETSTRINGFIELD(_var) do { \
            CHAR* _p = buf; \
            CHAR* _q = _p + buflen; \
            INT _n; \
            while (_p < _q && *_p) _p++; \
            if (_p == _q) goto failed; \
            _var = buf; \
            _n = (_p - buf) + 1; \
            buf += _n; \
            buflen -= _n; \
        } while (0)

//
// Insert a u_short field into an outgoing TFTP message
// NOTE:
//  we assume we're on a little-endian machine and
//  take care of byte swapping here.
//
#define ADDUSHORTFIELD(_var) do { \
            buf[0] = (CHAR) ((_var) >> 8); \
            buf[1] = (CHAR) (_var); \
            buf += 2; \
        } while (0)

//
// Insert a string field into an outgoing TFTP message
//
#define ADDSTRINGFIELD(_var) do { \
            INT _n = strlen(_var) + 1; \
            memcpy(buf, _var, _n); \
            buf += _n; \
        } while (0)

//
// Function prototypes
//

DWORD WINAPI
TftpStartService();

DWORD WINAPI
TftpStopService();

VOID
TftpCleanup();

BOOL
TftpSetDefaultDirectory();

BOOL
TftpOpenServerSocket();

BOOL
TftpHandleRequest(
    CHAR* buf,
    DWORD buflen,
    struct sockaddr_in* from
    );

BOOL
TftpSendAckPacket(
    SOCKET s,
    UINT blocknum
    );

BOOL
TftpVerifyPacketHeader(
    CHAR* buf,
    DWORD buflen,
    UINT opcode,
    UINT blocknum
    );

BOOL
TftpSendErrorPacket(
    SOCKET s,
    DWORD err
    );

BOOL
TftpReadFile(
    SOCKET s,
    const CHAR* filename
    );

BOOL
TftpWriteFile(
    SOCKET s,
    const CHAR* filename
    );

#if DBG

VOID
TftpDumpPacket(
    CHAR* buf,
    DWORD buflen
    );

#else

#define TftpDumpPacket(buf, buflen)

#endif

#endif // !_TFTPD_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\winsock\connect.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    connect.c

Abstract:

    Implementation of connection related Winsock APIs:
        bind
        connect
        listen
        accept
        getsockname
        getpeername

Revision History:

    06/02/2000 davidx
        Created it.

--*/

#include "precomp.h"


int WSAAPI
bind(
    SOCKET s,                          
    const struct sockaddr* name,   
    int namelen                        
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    const struct sockaddr_in* sin = (const struct sockaddr_in*) name;
    WinsockApiPrologSockLock_(bind, SOCKET_ERROR);

    WinsockApiParamCheck_(
        name != NULL &&
        namelen >= SOCKADDRLEN &&
        sin->sin_family == AF_INET &&
        !IS_BCAST_IPADDR(sin->sin_addr.s_addr) &&
        !IS_MCAST_IPADDR(sin->sin_addr.s_addr));

    if (IsPcbBound(pcb)) {
        WinsockApiGotoExit_(WSAEINVAL);
    }

    err = PcbBind(pcb, sin->sin_addr.s_addr, sin->sin_port);
    MapNtStatusToWinsockError_(err);

    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}


int WSAAPI
connect(
    SOCKET s,                          
    const struct sockaddr* name,  
    int namelen                        
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    const struct sockaddr_in* sin = (const struct sockaddr_in*) name;
    IPADDR dstaddr;
    IPPORT dstport;
    WinsockApiPrologSockLock_(connect, SOCKET_ERROR);

    WinsockApiParamCheck_(
        name != NULL &&
        namelen >= SOCKADDRLEN &&
        sin->sin_family == AF_INET);

    if (IsPcbConnected(pcb) && IsTcb(pcb)) {
        WinsockApiGotoExit_(WSAEISCONN);
    }

    dstaddr = sin->sin_addr.s_addr;
    dstport = sin->sin_port;
    if (IsDgramPcb(pcb)) {
        err = PcbConnectDgram(pcb, dstaddr, dstport);
    } else if (pcb->nonblocking) {
        err = TcbConnect((TCB*) pcb, dstaddr, dstport, FALSE);

        // For nonblocking socket, we'll return WSAEWOULDBLOCK
        // error code but the operation proceeds.
        if (NT_SUCCESS(err)) err = NETERR_WOULDBLOCK;
    } else {
        err = TcbConnect((TCB*) pcb, dstaddr, dstport, FALSE);
        if (NT_SUCCESS(err)) {
            // For blocking socket, we need to wait here for
            // the operation to complete.
            err = PcbWaitForEvent(pcb, PCBEVENT_CONNECT, 0);
            pcb->connectSelected = 1;
        }
    }

    MapNtStatusToWinsockError_(err);

    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}


int WSAAPI
listen(
    SOCKET s,    
    int backlog  
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    WinsockApiPrologSockLock_(listen, SOCKET_ERROR);

    WinsockApiParamCheck_(IsTcb(pcb));

    if (IsPcbConnected(pcb)) {
        WinsockApiGotoExit_(WSAEISCONN);
    }

    if (!IsPcbBound(pcb)) {
        WinsockApiGotoExit_(WSAEINVAL);
    }

    err = TcbListen((TCB*) pcb, backlog);
    MapNtStatusToWinsockError_(err);

    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}


SOCKET WSAAPI
accept(
    SOCKET s, 
    struct sockaddr* addr,  
    int* addrlen  
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    TCB* tcb;
    TCB* newtcb = NULL;
    WinsockApiPrologSockLock_(accept, INVALID_SOCKET);

    WinsockApiParamCheck_(
        IsTcb(pcb) &&
        (addr == NULL ||
         addrlen != NULL && *addrlen >= SOCKADDRLEN));

    if (!IsTcpListenState(pcb)) {
        WinsockApiGotoExit_(WSAEINVAL);
    }

    // Check if we have any pending connection requests
    tcb = (TCB*) pcb;
    if (!TcbHasPendingConnReq(tcb)) {
        // For nonblocking socket, return an error code
        // if we don't have any pending connection requests.
        if (tcb->nonblocking) {
            WinsockApiGotoExit_(WSAEWOULDBLOCK);
        }

        // For blocking sockets, wait until there
        // is a connection request.
        err = PcbWaitForEvent(pcb, PCBEVENT_ACCEPT, 0);
    }

    err = TcbAccept(tcb, &newtcb);
    MapNtStatusToWinsockError_(err);

    if (newtcb && addr && addrlen) {
        struct sockaddr_in* sin;

        sin = (struct sockaddr_in*) addr;
        sin->sin_family = AF_INET;
        sin->sin_port = newtcb->dstport;
        sin->sin_addr.s_addr = newtcb->dstaddr;
        ZeroMem(sin->sin_zero, sizeof(sin->sin_zero));
        *addrlen = SOCKADDRLEN;
    }

    WinsockApiExitSockUnlock_((SOCKET) newtcb, INVALID_SOCKET);
}


int WSAAPI
getsockname(
    SOCKET s,                    
    struct sockaddr* name,  
    int* namelen            
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    struct sockaddr_in* sin;
    WinsockApiPrologSockLock_(getsockname, SOCKET_ERROR);

    WinsockApiParamCheck_(
        name != NULL &&
        namelen != NULL &&
        *namelen >= SOCKADDRLEN);

    if (!IsPcbBound(pcb)) {
        WinsockApiGotoExit_(WSAEINVAL);
    }

    sin = (struct sockaddr_in*) name;
    ZeroMem(sin, SOCKADDRLEN);
    sin->sin_family = AF_INET;
    sin->sin_port = pcb->srcport;
    sin->sin_addr.s_addr = pcb->srcaddr;

    *namelen = SOCKADDRLEN;
    err = NO_ERROR;

    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}


int WSAAPI
getpeername(
    SOCKET s,                    
    struct sockaddr* name,  
    int* namelen            
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    struct sockaddr_in* sin;
    WinsockApiPrologSockLock_(getpeername, SOCKET_ERROR);

    WinsockApiParamCheck_(
        name != NULL &&
        namelen != NULL &&
        *namelen >= SOCKADDRLEN);

    if (!IsPcbConnected(pcb)) {
        WinsockApiGotoExit_(WSAENOTCONN);
    }

    sin = (struct sockaddr_in*) name;
    sin->sin_family = AF_INET;
    sin->sin_port = pcb->dstport;
    sin->sin_addr.s_addr = pcb->dstaddr;
    ZeroMem(sin->sin_zero, sizeof(sin->sin_zero));

    *namelen = SOCKADDRLEN;
    err = NO_ERROR;

    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\test\tftp\tftp.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    tftp.c

Abstract:

    XBox TFTP client program

Revision History:

    06/30/2000 davidx
        Created it.

--*/

#include "precomp.h"
#include "tftp.h"

CHAR TftpRecvBuf[TFTP_PACKET_BUFSIZE];
CHAR TftpSendBuf[TFTP_PACKET_BUFSIZE];
DWORD TftpSendBufsize;
DWORD TftpRecvBufsize;

CHAR* TftpMode = "octet";
CHAR* TftpServerAddr = "157.56.10.165";
CHAR* SrcFilename = "c:\\temp\\data2";
CHAR* DstFilename = "c:\\temp\\test";
INT testFlag = 1;
INT err;
struct sockaddr_in sockname;

#define VERIFY(cond, _apiname) \
        if (!(cond)) { \
            DbgPrint(#_apiname " failed: %d %d\n", err, GetLastError()); \
            goto failed; \
        }

SOCKET
ConnectTftpServer()
{
    SOCKET sock = INVALID_SOCKET;

    sock = socket(AF_INET, SOCK_DGRAM, 0);
    VERIFY(sock != INVALID_SOCKET, socket);

    ZeroMem(&sockname, sizeof(sockname));
    sockname.sin_family = AF_INET;
    err = _bind(sock, &sockname);
    VERIFY(err == NO_ERROR, bind);

    err = _setrcvtimeout(sock, TFTP_RECV_TIMEOUT);
    VERIFY(err == NO_ERROR, setrcvtimeout);

    return sock;

failed:
    if (sock != INVALID_SOCKET) {
        closesocket(sock);
    }
    return INVALID_SOCKET;
}


//
// Send initial request to the server and wait for response
//
BOOL
SendRequestAndWait(
    SOCKET sock,
    UINT opcode,
    UINT blocknum
    )
{
    INT retries = TFTP_MAX_RETRIES;
    UINT buflen;

    ZeroMem(&sockname, sizeof(sockname));
    sockname.sin_family = AF_INET;
    
    while (TRUE) {
        if (retries-- == 0) {
            WARNING_("Server doesn't appear to be responding...");
            goto failed;
        }

        sockname.sin_port = htons(TFTP_SERVER_PORT);
        sockname.sin_addr.s_addr = inet_addr(TftpServerAddr);

        DbgPrint("Sending request to TFTP server: %s:%d\n",
                 inet_ntoa(sockname.sin_addr),
                 ntohs(sockname.sin_port));

        buflen = TftpSendBufsize;
        err = _sendto(sock, TftpSendBuf, &buflen, &sockname);
        VERIFY(err == NO_ERROR, sendto);

        TftpRecvBufsize = sizeof(TftpRecvBuf);
        if (_recvfrom(sock, TftpRecvBuf, &TftpRecvBufsize, &sockname) == NO_ERROR) {
            UINT op, blk, buflen = TftpRecvBufsize;
            CHAR* buf = TftpRecvBuf;

            GETUSHORTFIELD(op);
            GETUSHORTFIELD(blk);
            if (op == opcode && blocknum == blk) break;

            if (op == TFTPOP_ERROR) {
                WARNING_("Received ERROR packet: %d", blk);
                return FALSE;
            }
        }
    }

    DbgPrint("Connecting to TFTP server: %s:%d\n",
             inet_ntoa(sockname.sin_addr),
             ntohs(sockname.sin_port));

    err = _connect(sock, &sockname);
    VERIFY(err == NO_ERROR, connect);

    err = _getsockname(sock, &sockname);
    VERIFY(err == NO_ERROR, getsockname);

    DbgPrint("Local address: %s:%d\n",
             inet_ntoa(sockname.sin_addr),
             ntohs(sockname.sin_port));

    return TRUE;

failed:
    return FALSE;
}


//
// Send data to the server and wait for response
//
BOOL
SendAndWait(
    SOCKET sock,
    UINT opcode,
    UINT blocknum
    )
{
    INT retries = TFTP_MAX_RETRIES;
    UINT buflen;

    while (retries--) {
        buflen = TftpSendBufsize;
        err = _send(sock, TftpSendBuf, &buflen);
        VERIFY(err == NO_ERROR, send);

        TftpRecvBufsize = sizeof(TftpRecvBuf);
        if (_recv(sock, TftpRecvBuf, &TftpRecvBufsize) == NO_ERROR) {
            UINT op, blk, buflen = TftpRecvBufsize;
            CHAR* buf = TftpRecvBuf;

            GETUSHORTFIELD(op);
            GETUSHORTFIELD(blk);
            if (op == opcode && blocknum == blk) return TRUE;

            if (op == TFTPOP_ERROR) {
                WARNING_("Received ERROR packet: %d", blk);
                return FALSE;
            }
        }
    }
    SetLastError(ERROR_TIMEOUT);

failed:
    return FALSE;
}

//
// Send file to the TFTP server
//
VOID
PutTest()
{
    SeqFile* file;
    SOCKET sock = INVALID_SOCKET;
    CHAR* buf;
    DWORD buflen, timer, total = 0;
    UINT blocknum = 0;

    DbgPrint("Opening local file %s for reading...\n", SrcFilename);
    file = _CreateFile(SrcFilename, GENERIC_READ);
    VERIFY(file != NULL, CreateFile);

    timer = GetTickCount();

    sock = ConnectTftpServer();
    VERIFY(sock != INVALID_SOCKET, ConnectTftpServer);

    DbgPrint("Writing remote file %s...\n", DstFilename);

    buf = TftpSendBuf;
    ADDUSHORTFIELD(TFTPOP_WRQ);
    ADDSTRINGFIELD(DstFilename);
    ADDSTRINGFIELD(TftpMode);

    TftpSendBufsize = buf-TftpSendBuf;
    VERIFY(SendRequestAndWait(sock, TFTPOP_ACK, blocknum), WaitWRQAck);

    ASSERT(cfgSeqFileBufSize % TFTP_DATAPACKET_BLOCKSIZE == 0);

    do {
        //
        // Read a block of data from the file
        //
        buflen = TFTP_DATAPACKET_BLOCKSIZE;
        VERIFY(_ReadFile(file, &buf, &buflen), ReadFile);
        CopyMem(&TftpSendBuf[TFTP_DATAPACKET_HEADERSIZE], buf, buflen);

        //
        // Munge data packet header
        //
        blocknum++;
        buf = TftpSendBuf;
        ADDUSHORTFIELD(TFTPOP_DATA);
        ADDUSHORTFIELD(blocknum);

        TftpSendBufsize = TFTP_DATAPACKET_HEADERSIZE+buflen;
        VERIFY(SendAndWait(sock, TFTPOP_ACK, blocknum), WaitDataAck);

        total += buflen;
    } while (buflen == TFTP_DATAPACKET_BLOCKSIZE);

    timer = GetTickCount() - timer;
    if (timer == 0) timer = 1;
    DbgPrint("Total transfer: %d bytes in %d msecs\n", total, timer);
    DbgPrint("Transfer speed: %d bytes /sec\n", MulDiv(total, 1000, timer));

failed:
    _CloseFile(file);
    if (sock != INVALID_SOCKET) {
        closesocket(sock);
    }
}


//
// Retrieve file from the TFTP server
//
VOID
GetTest()
{
    SeqFile* file;
    SOCKET sock = INVALID_SOCKET;
    CHAR* buf;
    DWORD buflen, timer, total = 0;
    UINT blocknum = 1;

    DbgPrint("Opening local file %s for writing...\n", DstFilename);
    file = _CreateFile(DstFilename, GENERIC_WRITE);
    VERIFY(file != NULL, CreateFile);

    timer = GetTickCount();

    sock = ConnectTftpServer();
    VERIFY(sock != INVALID_SOCKET, ConnectTftpServer);

    DbgPrint("Reading remote file %s...\n", SrcFilename);

    buf = TftpSendBuf;
    ADDUSHORTFIELD(TFTPOP_RRQ);
    ADDSTRINGFIELD(SrcFilename);
    ADDSTRINGFIELD(TftpMode);

    TftpSendBufsize = buf-TftpSendBuf;
    VERIFY(SendRequestAndWait(sock, TFTPOP_DATA, blocknum), WaitRRQAck);

    ASSERT(cfgSeqFileBufSize % TFTP_DATAPACKET_BLOCKSIZE == 0);

    while (TRUE) {
        buf = &TftpRecvBuf[TFTP_DATAPACKET_HEADERSIZE];
        buflen = TftpRecvBufsize - TFTP_DATAPACKET_HEADERSIZE;
        if (buflen > 0) {
            total += buflen;
            VERIFY(_WriteFile(file, buf, buflen), WriteFile);
        }

        // Prepare ACK packet
        buf = TftpSendBuf;
        ADDUSHORTFIELD(TFTPOP_ACK);
        ADDUSHORTFIELD(blocknum);
        TftpSendBufsize = buf-TftpSendBuf;

        if (buflen != TFTP_DATAPACKET_BLOCKSIZE) {
            VERIFY(_send(sock, TftpSendBuf, &TftpSendBufsize) == NO_ERROR, send);
            break;
        }

        blocknum++;
        VERIFY(SendAndWait(sock, TFTPOP_DATA, blocknum), WaitData);
    }

    timer = GetTickCount() - timer;
    if (timer == 0) timer = 1;
    DbgPrint("Total transfer: %d bytes in %d msecs\n", total, timer);
    DbgPrint("Transfer speed: %d bytes /sec\n", MulDiv(total, 1000, timer));

failed:
    _CloseFile(file);
    if (sock != INVALID_SOCKET) {
        closesocket(sock);
    }
}


#define BREAK_INTO_DEBUGGER __asm int 3

void __cdecl main()
{
    WSADATA wsadata;

    DbgPrint("Loading XBox network stack...\n");
    err = XnetInitialize(NULL, TRUE);
    if (err != NO_ERROR) {
        WARNFAIL(XnetInitialize); goto stop;
    }

    err = WSAStartup(WINSOCK_VERSION, &wsadata);
    if (err != NO_ERROR) {
        WARNFAIL(WSAStartup); goto unload;
    }

    DbgPrint("*** Test started, press 'g' to continue...\n");

    while (TRUE) {
        DbgPrint("*** To quit, press CTRL-C and type: ed %x 0;g\n", &testFlag);
        BREAK_INTO_DEBUGGER

        if (testFlag <= 0) break;
        if (testFlag == 1) {
            PutTest();
        } else {
            GetTest();
        }
    }
    WSACleanup();

unload:
    DbgPrint("Unloading XBox network stack...\n");
    XnetCleanup();

stop:
    if (testFlag == 0)
        HalReturnToFirmware(HalRebootRoutine);
    else
        Sleep(INFINITE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\test\udptest\udptest.cpp ===
#include <xtl.h>
#include <xdbg.h>

#define TESTPORT 6000
#define SENDCOUNT 1024
#define BUFSIZE 4

#define SERVERADDR "157.56.11.44"
//#define SERVERADDR "157.56.10.166"

volatile INT testFlag = 1;
INT err;
SOCKET s;
static union {
    CHAR buf[BUFSIZE];
    UINT seqno;
};
static union {
    struct sockaddr sockname;
    struct sockaddr_in sockin;
};

VOID UdpSendTest()
{
    LARGE_INTEGER counter0, counter1, freq;
    BOOL ok;

    s = socket(AF_INET, SOCK_DGRAM, 0);
    ASSERT(s != INVALID_SOCKET);

    memset(&sockname, 0, sizeof(sockname));
    sockin.sin_family = AF_INET;
    sockin.sin_port = htons(TESTPORT);
    err = bind(s, &sockname, sizeof(sockname));
    ASSERT(err == NO_ERROR);

    sockin.sin_addr.s_addr = inet_addr(SERVERADDR);
    err = connect(s, &sockname, sizeof(sockname));
    ASSERT(err == NO_ERROR);

    DWORD tick = GetTickCount();

    for (seqno=0; seqno < SENDCOUNT; seqno++) {
        err = send(s, buf, BUFSIZE, 0);
        ASSERT(err == BUFSIZE);
    }

    tick = GetTickCount() - tick;
    DbgPrint("%d packets sent in %d msecs\n", SENDCOUNT, tick);
    Sleep(2000);
    closesocket(s);
}

VOID UdpRecvTest()
{
    s = socket(AF_INET, SOCK_DGRAM, 0);
    ASSERT(s != INVALID_SOCKET);

    memset(&sockname, 0, sizeof(sockname));
    sockin.sin_family = AF_INET;
    sockin.sin_port = htons(TESTPORT);
    err = bind(s, &sockname, sizeof(sockname));
    ASSERT(err == NO_ERROR);

    INT timeout = 2000;
    err = setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, (CHAR*) &timeout, sizeof(timeout));
    ASSERT(err == NO_ERROR);

    DbgPrint("Listening on UDP port %d...\n", TESTPORT);

    INT count = 0;
    while (TRUE) {
        err = recv(s, buf, BUFSIZE, 0);
        if (err == SOCKET_ERROR) {
            ASSERT(WSAGetLastError() == WSAETIMEDOUT);
            if (count) break;
        } else {
            count++;
        }
    }

    closesocket(s);
    DbgPrint("%d packets received\n", count);
}

VOID __cdecl main()
{
    DbgPrint("Loading XBox network stack...\n");
    err = XnetInitialize(NULL, TRUE);
    ASSERT(err == NO_ERROR);

    WSADATA wsadata;
    err = WSAStartup(WINSOCK_VERSION, &wsadata);
    ASSERT(err == NO_ERROR);

    while (TRUE) {
        DbgPrint("*** To quit, type: ed %x 0;g\n", &testFlag);
        __asm int 3
        if (testFlag == 0) break;
        if (testFlag == 1)
            UdpSendTest();
        else
            UdpRecvTest();
    }

    DbgPrint("Unloading XBox network stack...\n");
    WSACleanup();
    XnetCleanup();

    DbgPrint("Test finished.\n");
    Sleep(INFINITE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\winsock\enumprot.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    enumprot.c

Abstract:

    Implement the Winsock WSAEnumProtocols API

Revision History:

    06/01/2000 davidx
        Created it.

--*/

#include "precomp.h"


//
// Hard-coded TCP/IP protocol information
//
#define NUM_TCPIP_PROTOCOLS 3
#define MAX_UDP_MSGSIZE (MAXIPLEN-MAXIPHDRLEN-UDPHDRLEN)

const WSAPROTOCOL_INFOW TcpIpProtocols[NUM_TCPIP_PROTOCOLS] = {
    //
    // TCP
    //
    {
        XP1_GUARANTEED_DELIVERY     // dwServiceFlags1
            | XP1_GUARANTEED_ORDER
            | XP1_GRACEFUL_CLOSE,
        0,                          // dwServiceFlags2
        0,                          // dwServiceFlags3
        0,                          // dwServiceFlags4
        PFL_MATCHES_PROTOCOL_ZERO,  // dwProviderFlags
        {                           // ProviderId
            0xe70f1aa0,
            0xab8b,
            0x11cf,
            { 0x8c, 0xa3, 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x92 }
        },
        1001,                       // dwCatalogEntryId
        { BASE_PROTOCOL, },         // ProtocolChain
        2,                          // iVersion
        AF_INET,                    // iAddressFamily
        SOCKADDRLEN,                // iMaxSockAddr
        SOCKADDRLEN,                // iMinSockAddr
        SOCK_STREAM,                // iSocketType
        IPPROTO_TCP,                // iProtocol
        0,                          // iProtocolMaxOffset
        BIGENDIAN,                  // iNetworkByteOrder
        SECURITY_PROTOCOL_NONE,     // iSecurityScheme
        0,                          // dwMessageSize
        0,                          // dwProviderReserved
        L"MSAFD Tcpip [TCP/IP]"     // szProtocol
    },

    //
    // UDP
    //
    {
        XP1_CONNECTIONLESS          // dwServiceFlags1
            | XP1_MESSAGE_ORIENTED
            | XP1_SUPPORT_BROADCAST,
        0,                          // dwServiceFlags2
        0,                          // dwServiceFlags3
        0,                          // dwServiceFlags4
        PFL_MATCHES_PROTOCOL_ZERO,  // dwProviderFlags
        {                           // ProviderId
            0xe70f1aa0,
            0xab8b,
            0x11cf,
            { 0x8c, 0xa3, 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x92 }
        },
        1002,                       // dwCatalogEntryId
        { BASE_PROTOCOL, },         // ProtocolChain
        2,                          // iVersion
        AF_INET,                    // iAddressFamily
        SOCKADDRLEN,                // iMaxSockAddr
        SOCKADDRLEN,                // iMinSockAddr
        SOCK_DGRAM,                 // iSocketType
        IPPROTO_UDP,                // iProtocol
        0,                          // iProtocolMaxOffset
        BIGENDIAN,                  // iNetworkByteOrder
        SECURITY_PROTOCOL_NONE,     // iSecurityScheme
        MAX_UDP_MSGSIZE,            // dwMessageSize
        0,                          // dwProviderReserved
        L"MSAFD Tcpip [UDP/IP]"     // szProtocol
    },

    //
    // Raw IP
    //
    {
        XP1_CONNECTIONLESS          // dwServiceFlags1
            | XP1_MESSAGE_ORIENTED
            | XP1_SUPPORT_BROADCAST,
        0,                          // dwServiceFlags2
        0,                          // dwServiceFlags3
        0,                          // dwServiceFlags4
        PFL_MATCHES_PROTOCOL_ZERO,  // dwProviderFlags
        {                           // ProviderId
            0xe70f1aa0,
            0xab8b,
            0x11cf,
            { 0x8c, 0xa3, 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x92 }
        },
        1003,                       // dwCatalogEntryId
        { BASE_PROTOCOL, },         // ProtocolChain
        2,                          // iVersion
        AF_INET,                    // iAddressFamily
        SOCKADDRLEN,                // iMaxSockAddr
        SOCKADDRLEN,                // iMinSockAddr
        SOCK_RAW,                   // iSocketType
        0,                          // iProtocol
        255,                        // iProtocolMaxOffset
        BIGENDIAN,                  // iNetworkByteOrder
        SECURITY_PROTOCOL_NONE,     // iSecurityScheme
        MAX_UDP_MSGSIZE,            // dwMessageSize
        0,                          // dwProviderReserved
        L"MSAFD Tcpip [RAW/IP]"     // szProtocol
    }
};


INT
MatchTcpipProtocol(
    IN INT af,
    IN INT type,
    IN INT protocol,
    OUT const WSAPROTOCOL_INFOW** protoinfo
    )

/*++

Routine Description:

    Match the specified parameters to a TCP/IP protocol

Arguments:

    af - Supplies an address family specification
    type - Supplies a socket type specification
    protocol - Supplies an address family specific identification of a
        protocol to be used with a socket, or 0 if the caller does
        not wish to specify a protocol.
    protoinfo - Returns the matched protocol information

Return Value:

    Error code

--*/

#define MATCHED_NONE 0
#define MATCHED_TYPE 1
#define MATCHED_TYPE_FAMILY 2
#define MATCHED_TYPE_FAMILY_PROTOCOL 3

#define PROTOCOL_IN_RANGE(_info, _proto) \
        ((_proto) >= (_info)->iProtocol && \
         (_proto) <= (_info)->iProtocol + (_info)->iProtocolMaxOffset)

{
    const WSAPROTOCOL_INFOW* p = TcpIpProtocols;
    const WSAPROTOCOL_INFOW* matched_proto = NULL;
    INT match = MATCHED_NONE;
    INT count = NUM_TCPIP_PROTOCOLS;
    INT err;

    // Either address family or protocol must be specified
    *protoinfo = NULL;
    if (af == 0 && protocol == 0) return WSAEINVAL;

    while (count-- && match < MATCHED_TYPE_FAMILY_PROTOCOL) {
        // Does the socket type match?

        if ((p->iSocketType == type) || (type == 0)) {
            if (match < MATCHED_TYPE) {
                match = MATCHED_TYPE;
                matched_proto = p;
            }

            // Can it support the requested address family?
            // Or is the wildcard family specified?

            if ((p->iAddressFamily == af) || (af == 0)) {
                if (match < MATCHED_TYPE_FAMILY) {
                    match = MATCHED_TYPE_FAMILY;
                    matched_proto = p;
                }

                // Is the requested protcol in range? Or is the requested
                // protocol 0 and entry supports protocol 0?

                if (PROTOCOL_IN_RANGE(p, protocol) || protocol == 0) {
                    match = MATCHED_TYPE_FAMILY_PROTOCOL;
                    matched_proto = p;
                }
            }
        }

        p++;
    }

    // Select an appropriate error code for "no match" cases,
    // or success code to proceed.

    switch (match) {
    case MATCHED_NONE:
        err = WSAESOCKTNOSUPPORT;
        break;

    case MATCHED_TYPE:
        err = WSAEAFNOSUPPORT;
        break;

    case MATCHED_TYPE_FAMILY_PROTOCOL:
        // NOTE: we don't allow raw sockets with TCP or UDP protocol
        if (type != SOCK_RAW ||
            protocol != IPPROTO_TCP && protocol != IPPROTO_UDP) {
            err = NO_ERROR;
            break;
        }

        // fall through

    case MATCHED_TYPE_FAMILY:
        err = WSAEPROTONOSUPPORT;
        break;

    default:
        err = WSASYSCALLFAILURE;
        break;
    }

    *protoinfo = (LPWSAPROTOCOL_INFOW) matched_proto;
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\test\tftpd\tftpd.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    tftpd.c

Abstract:

    Simple TFTP server implementation for XBox

Revision History:

    04/19/2000 davidx
        Created it.

Notes:

    Please refer to RFC1350 and RFC2347.

--*/

#include "precomp.h"
#include "tftpd.h"

//
// Global variable definitions
//
BOOL WinsockStarted;
SOCKET TftpSock = INVALID_SOCKET;
BOOL TftpServiceRunning;
INT err;
CHAR TftpRecvBuf[TFTP_PACKET_BUFSIZE];
CHAR TftpSendBuf[TFTP_PACKET_BUFSIZE];
INT tftpdTraceFlag;


BOOL
TftpSendErrorPacket(
    SOCKET s,
    DWORD err
    )

/*++

Routine Description:

    Send a TFTP error packet

Arguments:

    s - Specifies the socket to send to
    err - Specifies the TFTP error code

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

#define ARRAYCOUNT(a) (sizeof(a) / sizeof(a[0]))

{
    //
    // TFTP error message strings
    //
    static const PCSTR errorMessages[] = {
        "Undefined error code.",
        "File not found.",
        "Access violation.",
        "Disk full or allocation exceeded.",
        "Illegal TFTP operation.",
        "Unknown transfer ID.",
        "File already exists.",
        "No such user.",
        "Illegal OACK packet.\n"
    };

    CHAR* buf = TftpSendBuf;
    PCSTR str;
    UINT buflen;

    ADDUSHORTFIELD(TFTPOP_ERROR);
    ADDUSHORTFIELD(err);

    if (err >= ARRAYCOUNT(errorMessages)) err = 0;
    str = errorMessages[err];
    ADDSTRINGFIELD(str);

    buflen = buf - TftpSendBuf;
    return _send(s, TftpSendBuf, &buflen) == NO_ERROR;
}


BOOL
TftpSendAckPacket(
    SOCKET s,
    UINT blocknum
    )

/*++

Routine Description:

    Send a TFTP ACK packet

Arguments:

    s - Specifies the socket handle
    blocknum - Specifies the acknowledged block number

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    CHAR* buf = TftpSendBuf;
    UINT buflen;

    ADDUSHORTFIELD(TFTPOP_ACK);
    ADDUSHORTFIELD(blocknum);

    buflen = buf - TftpSendBuf;
    return _send(s, TftpSendBuf, &buflen) == NO_ERROR;
}


INLINE BOOL
TftpVerifyPacketHeader(
    CHAR* buf,
    DWORD buflen,
    UINT opcode,
    UINT blocknum
    )

/*++

Routine Description:

    Verify a received packet matches what we're expecting
    (the packet can be either ACK or DATA packets)

Arguments:

    buf - Points to the data buffer
    buflen - Length of the data buffer
    opcode - Expected opcode
    blocknum - Expected block number

Return Value:

    TRUE if the received packet is as expected
    FALSE otherwise

--*/

{
    UINT op, blk;

    GETUSHORTFIELD(op);
    GETUSHORTFIELD(blk);

    TRACE_("Received: opcode %d, block %d", op, blk);

    if (opcode == op && blocknum == blk)
        return TRUE;

failed:
    WARNING_("Invalid packet received: expecting %d", blocknum);
    return FALSE;
}


BOOL
TftpIsErrorPacket(
    CHAR* buf,
    DWORD buflen
    )

/*++

Routine Description:

    Determine if a received packet is an ERROR packet

Arguments:

    buf - Points to the data buffer
    buflen - Data buffer length

Return Value:

    TRUE if the packet is a well-formed ERROR packet
    FALSE otherwise

--*/

{
    UINT opcode, errcode;
    CHAR* errmsg;

    GETUSHORTFIELD(opcode);
    GETUSHORTFIELD(errcode);
    GETSTRINGFIELD(errmsg);

    if (opcode == TFTPOP_ERROR) {
        WARNING_("Received ERROR packet: %d, %s", errcode, errmsg);
        return TRUE;
    }

failed:
    return FALSE;
}


BOOL
TftpReadFile(
    SOCKET s,
    const CHAR* filename
    )

/*++

Routine Description:

    Read a file from the disk and send it to a client

Arguments:

    s - Specifies the socket handle
    filename - Specifies the filename

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    UINT blocknum = 1;
    CHAR* buf;
    DWORD buflen, total = 0;
    INT retries;
    SeqFile* file;
    BOOL retval = FALSE;

    VERBOSE_("Read file: %s", filename);

    //
    // Open the file for reading
    //
    file = _CreateFile(filename, GENERIC_READ);
    if (!file) {
        WARNFAIL(CreateFile); return FALSE;
    }
    ASSERT(cfgSeqFileBufSize % TFTP_DATAPACKET_BLOCKSIZE == 0);

    do {
        //
        // Read a block of data from the file
        //
        buflen = TFTP_DATAPACKET_BLOCKSIZE;
        if (!_ReadFile(file, &buf, &buflen)) {
            WARNFAIL(ReadFile); goto failed;
        }
        CopyMem(&TftpSendBuf[TFTP_DATAPACKET_HEADERSIZE], buf, buflen);

        // NOTE: If EOF is reached and buflen is 0,
        // we'll send an empty data packet.

        //
        // Munge data packet header
        //
        buf = TftpSendBuf;
        ADDUSHORTFIELD(TFTPOP_DATA);
        ADDUSHORTFIELD(blocknum);

        TRACE_("Send DATA packet: block %d", blocknum);

        for (retries=0; retries < TFTP_MAX_RETRIES; retries++) {
            //
            // Send the data packet to the client
            //
            DWORD count = TFTP_DATAPACKET_HEADERSIZE+buflen;

            err = _send(s, TftpSendBuf, &count);
            if (err != NO_ERROR) {
                WARNFAIL(send); goto failed;
            }
            
            //
            // Now wait to receive the ACK from the client or
            // until the timeout expires
            //
            count = sizeof(TftpRecvBuf);
            if (_recv(s, TftpRecvBuf, &count) == NO_ERROR) {
                //
                // Did we receive an ACK of correct block number?
                // If so, move on to the next block.
                //
                if (TftpVerifyPacketHeader(TftpRecvBuf, count, TFTPOP_ACK, blocknum)) {
                    total += buflen;
                    blocknum++;
                    break;
                }

                //
                // Did we get an error packet?
                // If so, abort. Otherwise, continue retry.
                //
                if (TftpIsErrorPacket(TftpRecvBuf, count)) goto failed;
            } else {
                //
                // Is the service shutting down?
                //
                if (!TftpServiceRunning) goto failed;
            }
        }

        //
        // Did we exceed our retry count? Give up if we did.
        //
        if (retries == TFTP_MAX_RETRIES) {
            WARNING_("Timed out while waiting for ACK");
            SetLastError(ERROR_TIMEOUT);
            goto failed;
        }

    } while (buflen == TFTP_DATAPACKET_BLOCKSIZE);

    VERBOSE_("Total number of bytes transferred: %d", total);
    retval = TRUE;

failed:
    _CloseFile(file);
    return retval;
}


BOOL
TftpWriteFile(
    SOCKET s,
    const CHAR* filename
    )

/*++

Routine Description:

    Receive a file from a client and write it to the disk

Arguments:

    s - Specifies the socket handle
    filename - Specifies the filename

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    UINT blocknum = 0;
    SeqFile* file;
    INT retries;
    CHAR* buf;
    DWORD buflen, total = 0;
    BOOL retval = FALSE;

    VERBOSE_("Write file: %s", filename);

    //
    // Open the file for writing
    //
    file = _CreateFile(filename, GENERIC_WRITE);
    if (!file) {
        WARNFAIL(CreateFile); return FALSE;
    }
    ASSERT(cfgSeqFileBufSize % TFTP_DATAPACKET_BLOCKSIZE == 0);

    do {
        for (retries=0; retries < TFTP_MAX_RETRIES; retries++) {
            //
            // Send the current ACK packet
            //
            TRACE_("Send ACK packet: block %d", blocknum);
            if (!TftpSendAckPacket(s, blocknum)) goto failed;

            //
            // Wait for the next data packet
            //
            buflen = sizeof(TftpRecvBuf);
            if (_recv(s, TftpRecvBuf, &buflen) == NO_ERROR) {
                //
                // Got a data packet: verify header information
                //
                if (TftpVerifyPacketHeader(TftpRecvBuf, buflen, TFTPOP_DATA, blocknum+1))
                    break;

                //
                // Did we get an error packet?
                // If so, abort. Otherwise, continue retry.
                //
                if (TftpIsErrorPacket(TftpRecvBuf, buflen)) goto failed;
            } else {
                //
                // We failed to receive a data packet.
                // If the service is shutting down, give up.
                // Otherwise, resend the ACK and wait again.
                //
                if (!TftpServiceRunning) goto failed;
            }
        }

        if (retries == TFTP_MAX_RETRIES) {
            WARNING_("Timed out waiting for data packet");
            SetLastError(ERROR_TIMEOUT);
            goto failed;
        }

        //
        // Write the received data to file
        //
        blocknum++;
        buf = &TftpRecvBuf[TFTP_DATAPACKET_HEADERSIZE];
        buflen -= TFTP_DATAPACKET_HEADERSIZE;
        total += buflen;

        if (buflen > 0) {
            if (!_WriteFile(file, buf, buflen)) {
                WARNFAIL(WriteFile); goto failed;
            }
        }
    } while (buflen == TFTP_DATAPACKET_BLOCKSIZE);

    //
    // Send the final ACK packet, ignore error
    //
    TftpSendAckPacket(s, blocknum);
    
    VERBOSE_("Total number of bytes transferred: %d", total);
    retval = TRUE;

failed:
    _CloseFile(file);
    return retval;
}


BOOL
TftpHandleRequest(
    CHAR* buf,
    DWORD buflen,
    struct sockaddr_in* from
    )

/*++

Routine Description:

    Handle a TFTP request packet

Arguments:

    buf - Points to the received data buffer
    buflen - Buffer length
    from - Specifies the requester's address and port

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

#define WAITREAD_TIMEOUT 2000

{
    UINT opcode;
    CHAR* filename;
    CHAR* mode;
    SOCKET s;
    struct sockaddr_in addr;
    INT err = TFTPERR_INVALID_OPCODE;

    TRACE_("Received request: %s %d", inet_ntoa(from->sin_addr), ntohs(from->sin_port));
    TftpDumpPacket(buf, buflen);

    //
    // Open a new socket to handle the request
    //
    s = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if (s == INVALID_SOCKET) goto sockfailed;

    //
    // Bind to local port and connect to remote client
    //
    ZeroMem(&addr, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = INADDR_ANY;

    if (_bind(s, &addr) != 0 ||
        _connect(s, from) != 0 ||
        _setrcvtimeout(s, WAITREAD_TIMEOUT) != 0)
        goto sockfailed;

    if (_getsockname(s, &addr) == NO_ERROR) {
        TRACE_("Local socket: %s %d", inet_ntoa(addr.sin_addr), ntohs(addr.sin_port));
    }

    //
    // Extract the opcode
    //
    GETUSHORTFIELD(opcode);
    if (opcode != TFTPOP_RRQ && opcode != TFTPOP_WRQ) goto failed;
    
    //
    // Extract the filename and transfer mode field
    // NOTE: we treat octet and netascii mode as the same
    //
    GETSTRINGFIELD(filename);
    GETSTRINGFIELD(mode);

    if (_stricmp(mode, "octet") != 0 && _stricmp(mode, "netascii") != 0) {
        WARNING_("Only octet and netascii mode are supported");
        goto failed;
    }

    // NOTE: Options are ignored

    //
    // Execute the read or write request
    //
    if (((opcode == TFTPOP_RRQ) ? TftpReadFile : TftpWriteFile)(s, filename)) {
        closesocket(s);
        return TRUE;
    }
    
    //
    // Map Win32 error code to TFTP error code
    //
    switch (GetLastError()) {

    case ERROR_FILE_NOT_FOUND:
    case ERROR_PATH_NOT_FOUND:
        err = TFTPERR_FILE_NOT_FOUND;
        break;
    
    case ERROR_ACCESS_DENIED:
        err = TFTPERR_ACCESS_DENIED;
        break;

    case ERROR_HANDLE_DISK_FULL:
        err = TFTPERR_DISK_FULL;
        break;

    case ERROR_FILE_EXISTS:
        err = TFTPERR_FILE_EXISTS;
        break;
    
    case ERROR_NO_SUCH_USER:
        err = TFTPERR_INVALID_USER;
        break;

    default:
        err = TFTPERR_UNKNOWN;
        break;
    }

failed:
    //
    // Failed to handle the TFTP request
    //
    WARNING_("TftpHandleRequest failed: %d", err);

    TftpSendErrorPacket(s, err);
    closesocket(s);
    return FALSE;

sockfailed:
    //
    // Failed to open a socket to handle the request
    //
    WARNING_("Failed to open response socket: %d", GetLastError());
    if (s != INVALID_SOCKET) closesocket(s);
    return FALSE;

}


VOID
TftpCleanup()

/*++

Routine Description:

    Cleanup the resources used by the TFTP service 

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    if (TftpServiceRunning) {
        //
        // The TFTP service is still running when cleanup is called
        //
        WARNING_("TftpCleanup: the service thread is still running");
        TftpStopService();
        return;
    }

    //
    // Close the server socket
    //
    if (TftpSock != INVALID_SOCKET) {
        closesocket(TftpSock);
        TftpSock = INVALID_SOCKET;
    }

    //
    // Uninitialize Winsock
    //
    if (WinsockStarted) {
        WSACleanup();
        WinsockStarted = FALSE;
    }
}


BOOL
TftpSetDefaultDirectory()

/*++

Routine Description:

    Set the default directory for the TFTP service

Arguments:

    NONE

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    // _XBOX_BUGBUG: Do nothing for now
    return TRUE;
}


BOOL
TftpOpenServerSocket()

/*++

Routine Description:

    Open the TFTP server socket

Arguments:

    NONE

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

#define WAITREQ_TIMEOUT 2000

{
    struct sockaddr_in addr;

    //
    // Open the socket
    //
    TftpSock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

    if (TftpSock == INVALID_SOCKET) {
        WARNING_("socket failed: %d\n", GetLastError());
        return FALSE;
    }

    //
    // Bind the socket to the TFTP server port
    // and set the receive timeout option
    //
    ZeroMemory(&addr, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = INADDR_ANY;
    addr.sin_port = htons(TFTP_SERVER_PORT);

    if (_bind(TftpSock, &addr) != 0 ||
        _setrcvtimeout(TftpSock, WAITREQ_TIMEOUT) != 0) {
        WARNING_("bind failed: %d", GetLastError());
        return FALSE;
    }

    return TRUE;
}


DWORD
TftpServiceThread(
    VOID* param
    )
{
    DWORD byteCount;
    struct sockaddr_in from;

    VERBOSE_("Waiting for the next request...");
    while (TftpServiceRunning) {
        //
        // Wait to receive the next request and then handle it
        //
        byteCount = sizeof(TftpRecvBuf);
        if (_recvfrom(TftpSock, TftpRecvBuf, &byteCount, &from) == NO_ERROR) {
            TftpHandleRequest(TftpRecvBuf, byteCount, &from);
            VERBOSE_("Waiting for the next request...");
        }
    }

    TftpCleanup();
    TRACE_("TFTP service stopped");
    return 0;
}


DWORD WINAPI
TftpStartService()

/*++

Routine Description:

    Start the TFTP service

Arguments:

    NONE

Return Value:

    Win32 error code

--*/

{
    HANDLE threadHandle;
    DWORD threadId;
    WSADATA wsadata;
    DWORD err;

    //
    // Initialize Winsock
    //
    if (WSAStartup(WINSOCK_VERSION, &wsadata) != 0) goto failed;
    WinsockStarted = TRUE;

    //
    // Set default directory
    //
    if (!TftpSetDefaultDirectory()) goto failed;

    //
    // Open TFTP server socket
    //
    if (!TftpOpenServerSocket()) goto failed;

    //
    // Create the TFTP server thread
    //
    TftpServiceRunning = TRUE;
    threadHandle = CreateThread(NULL, 0, TftpServiceThread, NULL, 0, &threadId);
    if (!threadHandle) goto failed;

    TRACE_("TFTP service started");
    return NO_ERROR;

failed:

    //
    // Cleanup and return error
    //
    TftpServiceRunning = FALSE;
    TftpCleanup();

    err = GetLastError();
    WARNING_("TftpStartService failed: %d", err);
    return err;
}


DWORD WINAPI
TftpStopService()
{
    if (TftpServiceRunning) {
        //
        // Signal the TFTP service thread to stop
        //
        TftpServiceRunning = FALSE;
        while (WinsockStarted) {
            Sleep(500);
        }
    } else {
        WARNING_("TFTP service already stopped");
    }

    return NO_ERROR;
}


#if DBG

VOID
TftpDumpPacket(
    CHAR* buf,
    DWORD buflen
    )

/*++

Routine Description:

    Dump a TFTP packet

Arguments:

    buf - Points to the packet data
    buflen - Specifies the packet length

Return Value:

    NONE

--*/

{
    //
    // Opcode strings
    //
    static const PCSTR opcodeStrings[] = {
        "RRQ",
        "WRQ",
        "DATA",
        "ACK",
        "ERROR",
        "OACK"
    };

    DWORD status;
    UINT opcode, blocknum, errcode;
    CHAR* s;

    if (!tftpdTraceFlag) return;

    GETUSHORTFIELD(opcode);

    DbgPrint("TFTP packet type: ");
    if (opcode > 0 && opcode <= ARRAYCOUNT(opcodeStrings))
        DbgPrint("%s\n", opcodeStrings[opcode-1]);
    else
        DbgPrint("unknown (%d)\n", opcode);

    switch (opcode) {
    case TFTPOP_RRQ:
    case TFTPOP_WRQ:
    case TFTPOP_OACK:
        while (buflen) {
            GETSTRINGFIELD(s);
            DbgPrint("  %s\n", s);
        }
        break;
    
    case TFTPOP_DATA:
        GETUSHORTFIELD(blocknum);
        DbgPrint("  block %d, %d bytes\n", blocknum, buflen);
        break;
        
    case TFTPOP_ACK:
        GETUSHORTFIELD(blocknum);
        DbgPrint("  block %d\n", blocknum);
        break;

    case TFTPOP_ERROR:
        GETUSHORTFIELD(errcode);
        GETSTRINGFIELD(s);
        DbgPrint("  code %d, %s\n", errcode, s);
        break;
    }
    
    return;

failed:
    DbgPrint("Ill-formed TFTP packet\n");
}

#endif // DBG


#ifndef BUILD_DLL

volatile INT testFlag = 1;

void __cdecl main()
{
    DbgPrint("Loading XBox network stack...\n");
    err = XnetInitialize(NULL, TRUE);
    if (err != NO_ERROR) {
        WARNFAIL(XnetInitialize); goto stop;
    }

    DbgPrint("Starting TFTP service...\n");
    err = TftpStartService();
    if (err != NO_ERROR) {
        WARNFAIL(TftpStartService); goto unload;
    }

    DbgPrint("*** Test started, press 'g' to continue...\n");
    DbgPrint("*** To quit, press CTRL-C and type: ed %x 0;g\n", &testFlag);
    BREAK_INTO_DEBUGGER

    while (testFlag > 0) {
        Sleep(1000);
    }

    DbgPrint("Stopping TFTP service...\n");
    TftpStopService();

unload:
    DbgPrint("Unloading XBox network stack...\n");
    XnetCleanup();

stop:
    if (testFlag == 0)
        HalReturnToFirmware(HalRebootRoutine);
    else
        Sleep(INFINITE);
}

#else // BUILD_DLL

BOOL WINAPI
DllMain(
    HINSTANCE hInstance,
    DWORD fdwReason,
    LPVOID lpReserved
    )
{
    UNREFERENCED_PARAMETER( hInstance );
    UNREFERENCED_PARAMETER( fdwReason );
    UNREFERENCED_PARAMETER( lpReserved );
    return TRUE;
}

#endif // BUILD_DLL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\winsock\precomp.h ===
#define WINSOCK_API_LINKAGE

#ifdef BUILD_FOR_DEBUGGER
#define _KERNEL32_
#define _USER32_
#define _XAPI_
#include "ntos.h"
#include "dm.h"
#endif

#include "xnetp.h"

#include "pcb.h"
#include "xdbg.h"
#include "sockp.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\winsock\getxbyy.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    getxbyy.c

Abstract:

    Implementation of the following Winsock APIs:
        gethostbyaddr
        gethostbyname
        gethostname
        getservbyname
        getservbyport
        getprotobynumber
        getprotobyname
        XnetGetIpAddress

Revision History:

    03/30/2000 davidx
        Created it.

--*/

#include "precomp.h"

PRIVATE INT
SockGetLocalHostName(
    OUT CHAR* buf,
    IN UINT bufsize
    )

/*++

Routine Description:

    Return the name of the local host

Arguments:

    buf - Output buffer
    bufsize - Output buffer size

Return Value:

    Winsock error code

Note:

    For now, our local hostname will just be our Ethernet
    address in hexdecimal format.

--*/

{
    static const CHAR hexDigits[] = "0123456789abcdef";
    IfInfo* ifp = LanIfp;
    BYTE* hwaddr;
    UINT count;

    if (!ifp) return WSAENETDOWN;
    hwaddr = ifp->hwaddr;
    count = ifp->hwaddrlen;
    if (bufsize < 2 + count * 2) return WSAENOBUFS;

    *buf++ = '_';
    while (count--) {
        *buf++ = hexDigits[*hwaddr >> 4];
        *buf++ = hexDigits[*hwaddr & 15];
        hwaddr++;
    }

    *buf = 0;
    return NO_ERROR;
}


PRIVATE BOOL
SockIsLocalHostName(
    IN const CHAR* name,
    OUT CHAR* buf,
    IN UINT bufsize
    )

/*++

Routine Description:

    Check if the specified hostname matches the local hostname

Arguments:

    name - Specified the hostname in question
    buf - Output buffer for returning the local hostname
    bufsize - Output buffer size

Return Value:

    TRUE if the specified hostname is the same as the local hostname
    FALSE otherwise

--*/

{
    return (name[0] == '_' &&
            SockGetLocalHostName(buf, bufsize) == NO_ERROR &&
            strcmp(name, buf) == 0);
}


//
// hostent structure with 1 host name and 1 host address
//
typedef struct _HostEnt1 {
    struct hostent;
    CHAR* alias_array[1];
    CHAR* addr_array[2];
    IPADDR ipaddr;
    CHAR namebuf[1];
} HostEnt1;

PRIVATE INT
SockReturnLocalHostent(
    WinsockThreadbuf* hostentbuf,
    CHAR* localhost
    )

/*++

Routine Description:

    Return the local host address

Arguments:

    hostentbuf - Points to the per-thread temporary data buffer
    localhost - Local hostname

Return Value:

    Winsock error code

--*/

{
    UINT namesize, size;
    HostEnt1* host;

    //
    // Get the best available IP address
    //
    IPADDR ipaddr;
    if (IpGetBestAddress(&ipaddr) == XNET_ADDR_NONE)
        return WSAENETDOWN;

    //
    // Assemble the return information into a HOSTENT structure
    //
    namesize = SizeofSTR(localhost);
    size = offsetof(HostEnt1, namebuf) + namesize;
    if (!SockAllocThreadbuf(hostentbuf, size))
        return WSAENOBUFS;

    host = (HostEnt1*) hostentbuf->data;
    host->h_name = host->namebuf;
    host->h_aliases = host->alias_array;
    host->h_addrtype = AF_INET;
    host->h_length = IPADDRLEN;
    host->h_addr_list = host->addr_array;
    host->alias_array[0] = NULL;
    host->addr_array[0] = (CHAR*) &host->ipaddr;
    host->addr_array[1] = NULL;
    host->ipaddr = ipaddr;
    CopyMem(host->namebuf, localhost, namesize);

    return NO_ERROR;
}


//
// Callback function passed to DnsLookupBy___.  It's called to
// allocate memory buffer to store the hostent information.
//
PRIVATE struct hostent*
SockAllocHostentCallback(
    UINT size,
    VOID* param
    )
{
    return (struct hostent*) SockAllocThreadbuf((WinsockThreadbuf*) param, size);
}


struct hostent* WSAAPI
gethostbyaddr(
    IN const char* addr,
    IN int len,
    IN int type
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    WinsockThreadbuf* hostentbuf;
    IPADDR ipaddr;
    WinsockApiProlog_(gethostbyaddr, NULL);

    WinsockApiParamCheck_(
        addr != NULL &&
        len >= (INT) sizeof(struct in_addr) &&
        type == AF_INET);

    ipaddr = ((struct in_addr*) addr)->s_addr;
    hostentbuf = &tlsData->hostentbuf;
    err = DnsLookupByAddr(ipaddr, SockAllocHostentCallback, hostentbuf);
    MapNtStatusToWinsockError_(err);

    WinsockApiCheckError_(NULL);
    return (struct hostent*) hostentbuf->data;
}


struct hostent* WSAAPI
gethostbyname(
    IN const char* name
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    WinsockThreadbuf* hostentbuf;
    CHAR localhost[32];
    WinsockApiProlog_(gethostbyname, NULL);

    WinsockApiParamCheck_(name != NULL);

    hostentbuf = &tlsData->hostentbuf;
    if (SockIsLocalHostName(name, localhost, 32)) {
        err = SockReturnLocalHostent(hostentbuf, localhost);
    } else {
        err = DnsLookupByName(name, SockAllocHostentCallback, hostentbuf);
        MapNtStatusToWinsockError_(err);
    }

    WinsockApiCheckError_(NULL);
    return (struct hostent*) hostentbuf->data;
}


int WSAAPI
gethostname(
    OUT char* name,
    IN int namelen
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    WinsockApiProlog_(gethostname, SOCKET_ERROR);
    WinsockApiParamCheck_(name != NULL);

    if (namelen <= 0) {
        err = WSAEFAULT;
    } else {
        err = SockGetLocalHostName(name, namelen);
        if (err == WSAENOBUFS)
            err = WSAEFAULT;
    }

    WinsockApiCheckError_(SOCKET_ERROR);
    return NO_ERROR;
}



//
// !!! _XBOX_NOTE
//  Hard-coded services database
//

typedef struct {
    WORD port;
    WORD type;
    const CHAR* names;
} ServiceEntry;

#define SVCTYPE_TCP    1
#define SVCTYPE_UDP    2
#define SVCTYPE_ALL   (SVCTYPE_TCP|SVCTYPE_UDP)
#define SVCENTRYTCP(_port, _names) { HTONS(_port), SVCTYPE_TCP, _names }
#define SVCENTRYUDP(_port, _names) { HTONS(_port), SVCTYPE_UDP, _names }
#define SVCENTRYALL(_port, _names) { HTONS(_port), SVCTYPE_ALL, _names }
    
PRIVATE const ServiceEntry Services[] = {
    SVCENTRYTCP(20, "ftp-data\0"),
    SVCENTRYTCP(21, "ftp\0"),
    SVCENTRYTCP(23, "telnet\0"),
    SVCENTRYTCP(25, "smtp\0mail\0"),
    SVCENTRYALL(53, "domain\0"),
    SVCENTRYUDP(67, "bootps\0dhcps\0"),
    SVCENTRYUDP(68, "bootpc\0dhcpc\0"),
    SVCENTRYUDP(69, "tftp\0"),
    SVCENTRYTCP(70, "gopher\0"),
    SVCENTRYTCP(80, "http\0www\0www-http\0"),
    SVCENTRYTCP(110, "pop3\0"),
    SVCENTRYTCP(143, "imap\0imap4\0"),
    SVCENTRYUDP(161, "snmp\0"),
    SVCENTRYTCP(194, "irc\0"),
    SVCENTRYALL(443, "https\0MCom\0"),
    { 0, }
};


//
// Structure for storing the SERVENT information
// we return from the getservbyXxx APIs.
//

struct myservent {
    struct servent;
    CHAR* aliases[3];
};

PRIVATE struct servent*
SockComposeServentBuf(
    const ServiceEntry* service,
    WORD type
    )

/*++

Routine Description:

    Generate a SERVENT structure based on the specified service database entry

Arguments:

    service - Pointer to the service database entry
    type - Determine whether to use TCP or UDP protocol

Return Value:

    Points to the resulting SERVENT structure
    NULL if there is an error

--*/

{
    struct myservent* buf;
    INT bufsize, namelen, protolen, alias1len, alias2len;
    const CHAR* names = service->names;
    const CHAR* proto = (type & SVCTYPE_TCP) ? "tcp" : "udp";

    WinsockApiProlog_(getservby_, NULL);

    // Figure out how large a buffer we need

    protolen = SizeofSTR(proto);
    namelen = SizeofSTR(names);
    names += namelen;
    alias1len = *names ? SizeofSTR(names) : 0;
    names += alias1len;
    alias2len = *names ? SizeofSTR(names) : 0;

    bufsize = ROUNDUP8(sizeof(*buf) + protolen + namelen + alias1len + alias2len);

    // Allocate per-thread temporary buffer
    buf = (struct myservent*) SockAllocThreadbuf(&tlsData->serventbuf, bufsize);
    if (buf == NULL) {
        WinsockApiReturnError_(WSAENOBUFS, NULL);
    }

    // Fill out the SERVENT structure
    buf->s_port = service->port;
    buf->s_proto = (CHAR*) (buf+1);
    buf->s_name = buf->s_proto + protolen;
    buf->s_aliases = buf->aliases;
    buf->aliases[0] = buf->aliases[1] = buf->aliases[2] = NULL;

    if (alias1len) {
        buf->aliases[0] = buf->s_name + namelen;
        if (alias2len) buf->aliases[1] = buf->aliases[0] + alias1len;
    }

    CopyMem(buf->s_proto, proto, protolen);
    CopyMem(buf->s_name, service->names, namelen+alias1len+alias2len);

    return (struct servent*) buf;
}


//
// Map protocol name string to our internal service type flag
//
INLINE WORD
SockParseProtocolType(
    const CHAR* proto
    )
{
    return
     (WORD) ((proto == NULL) ? SVCTYPE_ALL :
             (_stricmp(proto, "tcp") == 0) ? SVCTYPE_TCP :
             (_stricmp(proto, "udp") == 0) ? SVCTYPE_UDP : 0);
}

struct servent* WSAAPI
getservbyport(
    IN int port,
    IN const char* proto
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    const ServiceEntry* service = Services;
    WORD type;

    WinsockApiPrologLight_(getservbyport);

    type = SockParseProtocolType(proto);
    while (service->type) {
        if ((port == service->port) && (type & service->type)) {
            return SockComposeServentBuf(service, type);
        }
        service++;
    }

    WARNING_("getservbyport: not found");
    SetLastError(WSANO_DATA);
    return NULL;
}


struct servent* WSAAPI
getservbyname(
    IN const char* name,
    IN const char* proto
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    const ServiceEntry* service = Services;
    WORD type;

    WinsockApiPrologLight_(getservbyname);
    WinsockApiParamCheck_(name != NULL);

    type = SockParseProtocolType(proto);
    while (service->type) {
        if ((type & service->type) && _stricmp(name, service->names) == 0) {
            return SockComposeServentBuf(service, type);
        }
        service++;
    }

    WARNING_("getservbyname: not found");
    SetLastError(WSANO_DATA);
    return NULL;
}



//
// !!! _XBOX_NOTE:
//  Hard-coded protocol database
//

typedef struct {
    const CHAR* name;
    const CHAR* alias;
    INT protocol;
} ProtocolEntry;

PRIVATE const ProtocolEntry Protocols[] = {
    { "ip", "IP", 0 },
    { "icmp", "ICMP", IPPROTOCOL_ICMP },
    { "igmp", "IGMP", IPPROTOCOL_IGMP },
    { "tcp", "TCP", IPPROTOCOL_TCP },
    { "udp", "UDP", IPPROTOCOL_UDP },
    { NULL, }
};

//
// Structure for storing the PROTOENT information
// we return from the getprotobyX APIs.
//

struct myprotoent {
    struct protoent;
    CHAR* aliases[2];
};

PRIVATE struct protoent*
SockComposeProtoentBuf(
    const ProtocolEntry* proto
    )

/*++

Routine Description:

    Generate a PROTOENT structure based on the specified protocol database entry

Arguments:

    proto - Pointer to the protocol database entry

Return Value:

    Points to the resulting PROTOENT structure
    NULL if there is an error

--*/

{
    struct myprotoent* buf;
    INT bufsize, namelen, aliaslen;

    WinsockApiProlog_(getprotoby_, NULL);

    // Figure out how big a buffer we need
    namelen = SizeofSTR(proto->name);
    aliaslen = SizeofSTR(proto->alias);
    bufsize = ROUNDUP8(sizeof(*buf) + namelen + aliaslen);

    // Allocate per-thread temporary buffer
    buf = (struct myprotoent*) SockAllocThreadbuf(&tlsData->protoentbuf, bufsize); 
    if (!buf) {
        WinsockApiReturnError_(WSAENOBUFS, NULL);
    }

    buf->p_proto = (short) proto->protocol;
    buf->p_name = (CHAR*) (buf+1);
    buf->p_aliases = buf->aliases;
    buf->aliases[0] = buf->p_name + namelen;
    buf->aliases[1] = NULL;

    CopyMem(buf->p_name, proto->name, namelen);
    CopyMem(buf->aliases[0], proto->alias, aliaslen);

    return (struct protoent*) buf;
}


struct protoent* WSAAPI
getprotobynumber(
    IN int number
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    const ProtocolEntry* proto = Protocols;
    WinsockApiPrologLight_(getprotobynumber);

    while (proto->name) {
        if (proto->protocol == number)
            return SockComposeProtoentBuf(proto);
        proto++;
    }

    WARNING_("getprotobynumber: not found");
    SetLastError(WSANO_DATA);
    return NULL;
}


struct protoent* WSAAPI
getprotobyname(
    IN const char* name
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    const ProtocolEntry* proto = Protocols;

    WinsockApiPrologLight_(getprotobyname);
    WinsockApiParamCheck_(name != NULL);

    while (proto->name) {
        if (_stricmp(proto->name, name) == 0)
            return SockComposeProtoentBuf(proto);
        proto++;
    }

    WARNING_("getprotobyname: not found");
    SetLastError(WSANO_DATA);
    return NULL;
}


DWORD WSAAPI
XnetGetIpAddress(
    OUT struct in_addr* addr
    )

/*++

Routine Description:

    Get the active IP address that's currently in use

Arguments:

    addr - Return the active IP address

Return Value:

    Flags indicating how the address was obtained

--*/

{
    IPADDR ipaddr;
    DWORD flags;
    WinsockApiPrologLight_(XnetGetIpAddress);
    WinsockApiParamCheck_(addr != NULL);

    flags = IpGetBestAddress(&ipaddr);
    addr->s_addr = ipaddr;
    return flags;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\winsock\recv.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    recv.c

Abstract:

    Implementation of data reception related Winsock APIs:
        recv
        recvfrom
        WSARecv
        WSARecvFrom

Revision History:

    06/02/2000 davidx
        Created it.

--*/

#include "precomp.h"

// Disable unreference label warning
#pragma warning(disable:4102)


PRIVATE NTSTATUS
SockRecv(
    PCB* pcb,
    RECVREQ* recvreq
    )

/*++

Routine Description:

    Internal function for receiving data from a socket

Arguments:

    pcb - Points to the protocol control block
    recvreq - Describes the receive user request

Return Value:

    Status code

--*/

{
    NTSTATUS status;
    WSAOVERLAPPED* overlapped;
    WSAOVERLAPPED overlappedTemp;

    if (IsTcb(pcb)) {
        if (!IsPcbConnected(pcb)) {
            return NETERR(WSAENOTCONN);
        }
    } else {
        if (!IsPcbBound(pcb)) {
            return NETERR(WSAEINVAL);
        }
    }

    if (IsPcbRecvShutdown(pcb)) {
        return !NT_SUCCESS(PcbGetErrStatus(pcb)) ?
                    PcbGetErrStatus(pcb) :
                    NETERR(WSAESHUTDOWN);
    }

    // Since all our sockets are overlapped, we don't
    // enforce the Win32 behavior that the input socket
    // must be a non-overlapped socket.

    if ((overlapped = recvreq->overlapped) != NULL) {
        recvreq->overlappedEvent = GetKernelEventObject(overlapped->hEvent);
        if (!recvreq->overlappedEvent)
            return NETERR(WSASYSCALLFAILURE);
    } else
        recvreq->overlappedEvent = NULL;

    // Check if we have any buffered data waiting to be read
    if (IsPcbRecvBufEmpty(pcb)) {
        if (overlapped) {
            // Overlapped call
            KeClearEvent(recvreq->overlappedEvent);
        } else if (pcb->nonblocking) {
            // Nonoverlapped call and socket is nonblocking:
            // just return WOULDBLOCK error code.
            //
            // Note: For TCP socket, if FIN has been received
            // we should return success with bytesRecv set to 0.
            if (IsDgramPcb(pcb) || !IsFINReceived(pcb))
                return NETERR(WSAEWOULDBLOCK);
        } else {
            // Blocking call - prepare to wait
            recvreq->overlapped = &overlappedTemp;
            recvreq->overlappedEvent = GetPcbWaitEvent(pcb);
            KeClearEvent(recvreq->overlappedEvent);
        }
    }

    status = IsDgramPcb(pcb) ?
                PcbRecvDgram(pcb, recvreq) :
                TcbRecv((TCB*) pcb, recvreq);

    if (status == NETERR_PENDING) {
        if (!overlapped) {
            // A blocking call is still in progress
            WaitKernelEventObject(recvreq->overlappedEvent, pcb->recvTimeout);

            if (overlappedTemp._iostatus == NETERR_PENDING) {
                KIRQL irql = RaiseToDpc();
                if (overlappedTemp._iostatus == NETERR_PENDING) {
                    // We can use recvreq directly here because
                    // blocking recv call is treated as a special case
                    // in PcbQueueOverlappedRecv (in tcp\pcb.c).
                    PcbCompleteOverlappedRecv(recvreq, NETERR_TIMEOUT);
                }
                LowerFromDpc(irql);
            }

            *recvreq->bytesRecv = overlappedTemp._ioxfercnt;
            recvreq->flags = overlappedTemp._ioflags;
            status = overlappedTemp._iostatus;
        }
    } else {
        if (overlapped) {
            // An overlapped call was completed immediately
            overlapped->_ioflags = recvreq->flags;
            overlapped->_ioxfercnt = *recvreq->bytesRecv;
            overlapped->_iostatus = status;

            // It would seem to be a waste to signal the event here.
            // But that's win2k behavior.
            KeSetEvent(recvreq->overlappedEvent, 0, FALSE);
            ObDereferenceObject(recvreq->overlappedEvent);
        }
    }

    return status;
}


int WSAAPI
recv(
    SOCKET s,       
    char* buf,  
    int len,        
    int flags       
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    RECVREQ recvreq;
    DWORD count;
    WinsockApiPrologSockLock_(recv, SOCKET_ERROR);

    WinsockApiParamCheck_(
        (len > 0 && buf != NULL || len == 0) &&
        flags == 0);

    recvreq.buf = (BYTE*) buf;
    recvreq.buflen = len;
    recvreq.flags = flags;
    recvreq.bytesRecv = &count;
    recvreq.fromaddr = NULL;
    recvreq.overlapped = NULL;

    err = SockRecv(pcb, &recvreq);
    MapNtStatusToWinsockError_(err);
    WinsockApiExitSockUnlock_(count, SOCKET_ERROR);
}


//
// Verify buffers passed to WSARecv API
// NOTE: we do not support more than 1 receive buffers.
//
INLINE BOOL CheckRecvWsaBuf(WSABUF* bufs, UINT bufcnt) {
    return (bufcnt == 1 &&
            bufs != NULL &&
            (bufs->len > 0 && bufs->buf != NULL || bufs->len == 0));
}


int WSAAPI
WSARecv(
    SOCKET s,                                               
    LPWSABUF bufs,                                     
    DWORD bufcnt,                                    
    LPDWORD bytesRecv,                           
    LPDWORD flags,                                        
    LPWSAOVERLAPPED overlapped,                           
    LPWSAOVERLAPPED_COMPLETION_ROUTINE completionproc  
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    RECVREQ recvreq;
    WinsockApiPrologSockLock_(WSARecv, SOCKET_ERROR);

    WinsockApiParamCheck_(
        CheckRecvWsaBuf(bufs, bufcnt) &&
        bytesRecv != NULL &&
        flags != NULL && *flags == 0 &&
        completionproc == NULL);

    recvreq.buf = (BYTE*) bufs->buf;
    recvreq.buflen = bufs->len;
    recvreq.flags = *flags;
    recvreq.bytesRecv = bytesRecv;
    recvreq.fromaddr = NULL;
    recvreq.overlapped = overlapped;

    err = SockRecv(pcb, &recvreq);
    *flags = recvreq.flags;
    MapNtStatusToWinsockError_(err);
    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}


int WSAAPI
recvfrom(
    SOCKET s,                   
    char FAR* buf,              
    int len,                    
    int flags,                  
    struct sockaddr* from,  
    int* fromlen            
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    DWORD count;
    INT err;
    WSABUF wsabuf;

    WinsockApiPrologLight_(recvfrom);
    WinsockApiParamCheck_(
        (len > 0 && buf != NULL || len == 0) &&
        (from == NULL ||
         fromlen != NULL && *fromlen >= SOCKADDRLEN));

    wsabuf.len = len;
    wsabuf.buf = buf;
    err = WSARecvFrom(s, &wsabuf, 1, &count, (DWORD*) &flags, from, fromlen, NULL, NULL);
    return (err == NO_ERROR) ? count : SOCKET_ERROR;
}


int WSAAPI
WSARecvFrom(
    SOCKET s,
    LPWSABUF bufs,
    DWORD bufcnt,
    LPDWORD bytesRecv,
    LPDWORD flags,
    struct sockaddr* fromaddr,
    LPINT fromlen,                                        
    LPWSAOVERLAPPED overlapped,                           
    LPWSAOVERLAPPED_COMPLETION_ROUTINE completionproc  
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    RECVREQ recvreq;
    WinsockApiPrologSockLock_(WSARecvFrom, SOCKET_ERROR);

    WinsockApiParamCheck_(
        CheckRecvWsaBuf(bufs, bufcnt) &&
        bytesRecv != NULL &&
        (fromaddr == NULL ||
         fromlen != NULL && *fromlen >= SOCKADDRLEN) &&
        flags != NULL && *flags == 0 &&
        completionproc == NULL);

    // Winsock documentation on this call is extremely confusing
    // regarding the correct behavior for connection-oriented sockets
    // Here I've taken the liberty to treat WSARecvFrom the same way
    // as WSARecv for such cases.
    if (IsTcb(pcb)) {
        VERBOSE_("WSARecvFrom called on stream socket!");
    }

    recvreq.buf = (BYTE*) bufs->buf;
    recvreq.buflen = bufs->len;
    recvreq.flags = *flags;
    recvreq.bytesRecv = bytesRecv;
    recvreq.overlapped = overlapped;
    recvreq.fromaddr = (struct sockaddr_in*) fromaddr;

    if (fromaddr) {
        ZeroMem(fromaddr, SOCKADDRLEN);
        *fromlen = SOCKADDRLEN;
        recvreq.fromaddr->sin_family = AF_INET;
    }

    err = SockRecv(pcb, &recvreq);
    *flags = recvreq.flags;
    MapNtStatusToWinsockError_(err);
    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\winsock\send.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    send.c

Abstract:

    Implementation of data transmission related Winsock APIs:
        send
        sendto
        WSASend
        WSASendTo

Revision History:

    06/02/2000 davidx
        Created it.

--*/

#include "precomp.h"

// Disable unreferenced label warning
#pragma warning(disable: 4102)


PRIVATE NTSTATUS
SockSend(
    PCB* pcb,
    SENDREQ* sendreq
    )

/*++

Routine Description:

    Internal function for sending out data from a socket

Arguments:

    pcb - Points to the protocol control block
    sendreq - Points to send user request information

Return Value:

    Status code

--*/

{
    NTSTATUS status;
    WSAOVERLAPPED* overlapped;

    if (!IsPcbConnected(pcb) && !sendreq->toaddr)
        return NETERR(WSAENOTCONN);

    if (IsPcbSendShutdown(pcb)) {
        return !NT_SUCCESS(PcbGetErrStatus(pcb)) ?
                    PcbGetErrStatus(pcb) :
                    NETERR(WSAESHUTDOWN);
    }

    if ((overlapped = sendreq->overlapped) != NULL) {
        sendreq->overlappedEvent = GetKernelEventObject(overlapped->hEvent);
        if (!sendreq->overlappedEvent)
            return NETERR(WSASYSCALLFAILURE);
    }

    // Check if we have room in the send buffer
    if (IsPcbSendBufFull(pcb)) {
        if (overlapped) {
            // Queue the overlapped send request.
            KeClearEvent(sendreq->overlappedEvent);
            status = PcbQueueOverlappedSend(pcb, sendreq);

            // The overlapped request was successfully queued up
            if (status == NETERR_PENDING)
                return status;

            // The overlapped send request wasn't queued
            // because of an error.
            if (!NT_SUCCESS(status)) goto exit;

            // The send buffer has opened up and
            // the overlapped send request wasn't queued.
        } else if (pcb->nonblocking || HasOverlappedSend(pcb)) {
            return NETERR_WOULDBLOCK;
        } else {
            status = PcbWaitForEvent(pcb, PCBEVENT_WRITE, pcb->sendTimeout);
            if (!NT_SUCCESS(status)) return status;
        }
    }

    status = IsDgramPcb(pcb) ?
                PcbSendDgram(pcb, sendreq) :
                TcbSend((TCB*) pcb, sendreq);

exit:
    if (overlapped) {
        // An overlapped call was completed immediately
        overlapped->_ioflags = 0;
        overlapped->_ioxfercnt = sendreq->sendtotal;
        overlapped->_iostatus = status;

        // It would seem to be a waste to signal the event here.
        // But that's win2k behavior.
        KeSetEvent(sendreq->overlappedEvent, 0, FALSE);
        ObDereferenceObject(sendreq->overlappedEvent);
    }

    return status;
}


int WSAAPI
send(
    SOCKET s,              
    const char* buf,  
    int len,               
    int flags              
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    WSABUF wsabuf;
    SENDREQ sendreq;
    WinsockApiPrologSockLock_(send, SOCKET_ERROR);

    WinsockApiParamCheck_(
        (len > 0 && buf != NULL || len == 0) &&
        (flags  == 0));

    wsabuf.len = len;
    wsabuf.buf = (char*) buf;
    sendreq.overlapped = NULL;
    sendreq.bufs = &wsabuf;
    sendreq.bufcnt = 1;
    sendreq.sendtotal = len;
    sendreq.toaddr = NULL;

    err = SockSend(pcb, &sendreq);
    MapNtStatusToWinsockError_(err);
    WinsockApiExitSockUnlock_(sendreq.sendtotal, SOCKET_ERROR);
}


//
// Count the total number of bytes to send
//
INLINE UINT SockCountSendTotal(WSABUF* bufs, UINT bufcnt) {
    UINT total = 0;
    while (bufcnt--) {
        total += bufs->len;
        bufs++;
    }
    return total;
}

INLINE BOOL SockCheckSendWsaBuf(WSABUF* bufs, UINT bufcnt) {
    if (bufs == NULL || bufcnt == 0)
        return FALSE;

    while (bufcnt--) {
        if (bufs->len && bufs->buf == NULL)
            return FALSE;
        bufs++;
    }
    return TRUE;
}

int WSAAPI
WSASend(
    SOCKET s,
    LPWSABUF bufs,
    DWORD bufcnt,
    LPDWORD bytesSent,
    DWORD flags, 
    LPWSAOVERLAPPED overlapped,                           
    LPWSAOVERLAPPED_COMPLETION_ROUTINE completionproc  
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    SENDREQ sendreq;
    WinsockApiPrologSockLock_(WSASend, SOCKET_ERROR);

    WinsockApiParamCheck_(
        SockCheckSendWsaBuf(bufs, bufcnt) &&
        bytesSent != NULL &&
        flags == 0 &&
        completionproc == NULL);

    sendreq.overlapped = overlapped;
    sendreq.bufs = bufs;
    sendreq.bufcnt = bufcnt;
    sendreq.sendtotal = SockCountSendTotal(bufs, bufcnt);
    sendreq.toaddr = NULL;

    err = SockSend(pcb, &sendreq);
    if (NT_SUCCESS(err)) *bytesSent = sendreq.sendtotal;
    MapNtStatusToWinsockError_(err);
    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}


int WSAAPI
sendto(
    SOCKET s,                        
    const char* buf,            
    int len,                         
    int flags,                       
    const struct sockaddr* to,  
    int tolen                        
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    DWORD count;
    INT err;
    WSABUF wsabuf;

    WinsockApiPrologLight_(sendto);
    WinsockApiParamCheck_(len > 0 && buf != NULL || len == 0);

    wsabuf.len = len;
    wsabuf.buf = (char*) buf;
    err = WSASendTo(s, &wsabuf, 1, &count, flags, to, tolen, NULL, NULL);
    return (err == NO_ERROR) ? count : SOCKET_ERROR;
}


int WSAAPI
WSASendTo(
    SOCKET s,                   
    LPWSABUF bufs,           
    DWORD bufcnt,       
    LPDWORD bytesSent, 
    DWORD flags,             
    const struct sockaddr* toaddr,               
    int tolen,              
    LPWSAOVERLAPPED overlapped,        
    LPWSAOVERLAPPED_COMPLETION_ROUTINE completionproc  
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    struct sockaddr_in* sin = (struct sockaddr_in*) toaddr;
    SENDREQ sendreq;
    WinsockApiPrologSockLock_(WSASendTo, SOCKET_ERROR);

    WinsockApiParamCheck_(
        SockCheckSendWsaBuf(bufs, bufcnt) &&
        bytesSent != NULL &&
        flags == 0 &&
        (toaddr == NULL ||
         tolen >= SOCKADDRLEN && sin->sin_family == AF_INET) &&
        completionproc == NULL);

    sendreq.overlapped = overlapped;
    sendreq.bufs = bufs;
    sendreq.bufcnt = bufcnt;
    sendreq.sendtotal = SockCountSendTotal(bufs, bufcnt);

    if (IsTcb(pcb) || toaddr == NULL) {
        // For TCP sockets, WSASendTo is equivalent to WSASend.
        // We simply ignore lpTo and iToLen parameters.
        //
        // Also, if toaddr parameter is NULL, we treat WSASendTo
        // the same way as WSASend.

        sendreq.toaddr = NULL;
        err = SockSend(pcb, &sendreq);
    } else {
        // Must do this check because downstream code
        // doesn't expect the destination address to be 0.
        // Also, we consider sending to UDP port 0 an error.
        if (sin->sin_addr.s_addr == 0 ||
            sin->sin_port == 0 && pcb->type == SOCK_DGRAM) {
            WinsockApiGotoExit_(WSAEADDRNOTAVAIL);
        }

        // Is this socket allowed to send broadcast
        // datagrams on this socket?
        if (IS_BCAST_IPADDR(sin->sin_addr.s_addr) && !pcb->broadcast) {
            WinsockApiGotoExit_(WSAEACCES);
        }

        // If the socket is not bound, bind it here
        if (!IsPcbBound(pcb)) {
            err = PcbBind(pcb, 0, 0);
            if (!NT_SUCCESS(err)) {
                MapNtStatusToWinsockError_(err);
                goto exit;
            }
        }

        // Send to the new destination
        sendreq.toaddr = sin;
        err = SockSend(pcb, &sendreq);
    }
        
    if (NT_SUCCESS(err)) *bytesSent = sendreq.sendtotal;
    MapNtStatusToWinsockError_(err);
    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\winsock\select.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    select.c

Abstract:

    Implementation of asynchronous notification related Winsock APIs:
        select
        WSAGetOverlappedResult
        WSACancelOverlappedIO

Revision History:

    06/02/2000 davidx
        Created it.

--*/

#include "precomp.h"

//
// Count the total number of socket handles
//
#define SOCKETS_IN_SET(_set) ((_set) ? ((_set)->fd_count & 0xffff) : 0)

//
// Information about sockets that was passed to the select calls
//
typedef struct _SELECTINFO {
    SOCKET s;
    fd_set* fdset;
    INT eventMasks;
    PCB* pcb;
    INT pcbMasks;
} SELECTINFO;

//
// Select event masks
//
#define SELECT_READ_EVENTS (PCBEVENT_READ|PCBEVENT_ACCEPT|PCBEVENT_CLOSE|PCBEVENT_CONNRESET)
#define SELECT_WRITE_EVENTS (PCBEVENT_WRITE|PCBEVENT_CONNECT)
#define SELECT_EXCEPT_EVENTS (PCBEVENT_CONNRESET)

//
// Number of KWAIT_BLOCKs allocated on the stack for select() calls.
//
#define SELECT_STACK_KWAIT_BLOCKS 3


PRIVATE INT
SockLockSelectSockets(
    fd_set* fdset,
    SELECTINFO* selinfo,
    INT offset,
    INT eventMasks
    )

/*++

Routine Description:

    Lock the socket handles that was passed to the select API

Arguments:

    fdset - Points to the socket set
    selinfo - Points to an array of SELECTINFO structures
        for storing the locked socket information
    eventMasks - Specifies the interested events

Return Value:

    Winsock error code

--*/

{
    INT i, count;

    // Nothing to do if the set is empty
    count = SOCKETS_IN_SET(fdset);

    for (i=0; i < count; i++) {
        SOCKET s = fdset->fd_array[i];
        INT j, k = offset + i;

        selinfo[k].s = s;
        selinfo[k].fdset = fdset;
        selinfo[k].eventMasks = eventMasks;

        // Check to see if the socket is already used
        // in the same select call
        for (j=0; j < k && selinfo[j].s != s; j++)
            ;

        if (j == k) {
            //
            // The socket isn't seen already
            //
            selinfo[k].pcbMasks = eventMasks;
            selinfo[k].pcb = SockLock(s);
            if (!selinfo[k].pcb)
                return GetLastError();
        } else {
            //
            // The socket is already seen
            //
            selinfo[j].pcbMasks |= eventMasks;
            selinfo[k].pcbMasks = 0;
            selinfo[k].pcb = selinfo[j].pcb;
        }
    }

    return NO_ERROR;
}


int WSAAPI
select(
    int nfds,
    fd_set* readfds,
    fd_set* writefds,
    fd_set* exceptfds,
    const struct timeval* timeout  
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    SELECTINFO tempinfo;
    PRKEVENT tempevent;
    KWAIT_BLOCK tempWaitBlocks[SELECT_STACK_KWAIT_BLOCKS];
    SELECTINFO* selinfo;
    PRKEVENT* events;
    INT index, rdcnt, rwcnt, selcnt = 0;
    PCB* pcb;
    LARGE_INTEGER waittime;
    LARGE_INTEGER* pwait;
    PKWAIT_BLOCK waitBlockArray = tempWaitBlocks;

    WinsockApiProlog_(select, SOCKET_ERROR);

    // Count the total number of sockets
    // (ignore the input nfds parameter)
    rdcnt = SOCKETS_IN_SET(readfds);
    rwcnt = rdcnt + SOCKETS_IN_SET(writefds);
    nfds = rwcnt + SOCKETS_IN_SET(exceptfds);

    if (nfds == 0) {
        WinsockApiReturnError_(WSAEINVAL, SOCKET_ERROR);
    }

    if (nfds == 1) {
        // Use temporary stack buffers for the special case
        // where there is only one socket. This saves us from
        // two extra memory allocations.
        events = &tempevent;
        selinfo = &tempinfo;
        ZeroMem(selinfo, sizeof(SELECTINFO));
    } else {
        selinfo = (SELECTINFO*) MAlloc0(nfds*sizeof(SELECTINFO));
        events = (PRKEVENT*) MAlloc(nfds*sizeof(PRKEVENT));
        if (!selinfo || !events) {
            nfds = 0;
            WinsockApiGotoExit_(WSAENOBUFS);
        }
    }

    // Lock all the socket handles
    if ((err = SockLockSelectSockets(readfds, selinfo, 0, SELECT_READ_EVENTS)) != 0 ||
        (err = SockLockSelectSockets(writefds, selinfo, rdcnt, SELECT_WRITE_EVENTS)) != 0 ||
        (err = SockLockSelectSockets(exceptfds, selinfo, rwcnt, SELECT_EXCEPT_EVENTS)) != 0) {
        goto exit;
    }

    // Compute the wait time in 100ns unit
    if (timeout) {
        pwait = &waittime;
        waittime.QuadPart = Int32x32To64(timeout->tv_sec, -10000000) +
                            Int32x32To64(timeout->tv_usec, -10);
    } else {
        pwait = NULL;
    }

    // Check if we to wait:
    // if we do, set up the socket event flags
    if (!pwait || pwait->QuadPart) {
        INT waitCount = 0;
        for (index=0; index < nfds; index++) {
            pcb = selinfo[index].pcb;
            if (selinfo[index].pcbMasks) {
                if (PcbCheckSelectEvents(pcb, selinfo[index].pcbMasks, -1)) break;
                events[waitCount++] = GetPcbWaitEvent(pcb);
            }
        }

        if (index == nfds) {
            if (waitCount > SELECT_STACK_KWAIT_BLOCKS) {
                waitBlockArray = (PKWAIT_BLOCK) MAlloc0(waitCount * sizeof(KWAIT_BLOCK));
                if (!waitBlockArray) {
                    WinsockApiGotoExit_(WSAENOBUFS);
                }
            }

            err = KeWaitForMultipleObjects(
                        waitCount,
                        events,
                        WaitAny,
                        UserRequest,
                        UserMode,
                        FALSE,
                        pwait,
                        waitBlockArray);

            if ((err < 0 || err >= waitCount) && err != STATUS_TIMEOUT) {
                WinsockApiGotoExit_(WSAEFAULT);
            }
        }
    }

    // Determine which socket events are ready
    // and return appropriate information

    if (readfds) { FD_ZERO(readfds); }
    if (writefds) { FD_ZERO(writefds); }
    if (exceptfds) { FD_ZERO(exceptfds); }

    for (index=selcnt=0; index < nfds; index++) {
        if (PcbCheckSelectEvents(
                    selinfo[index].pcb,
                    selinfo[index].eventMasks,
                    0)) {
            FD_SET(selinfo[index].s, selinfo[index].fdset);
            selcnt++;
        }
    }

    err = NO_ERROR;

exit:
    for (index=0; index < nfds; index++) {
        pcb = selinfo[index].pcb;
        if (pcb && selinfo[index].pcbMasks) {
            PcbClearSelectEvents(pcb);
            SockUnlock(pcb);
        }
    }
    if (waitBlockArray != tempWaitBlocks) { Free(waitBlockArray); }
    if (selinfo != &tempinfo) { Free(selinfo); }
    if (events != &tempevent) { Free(events); }

    WinsockApiCheckError_(SOCKET_ERROR);
    return selcnt;
}


BOOL WSAAPI
WSAGetOverlappedResult(
    SOCKET s,                      
    LPWSAOVERLAPPED overlapped,  
    LPDWORD byteCount,          
    BOOL fWait,                    
    LPDWORD flags              
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    WinsockApiPrologSockLock_(WSAGetOverlappedResult, FALSE);

    WinsockApiParamCheck_(
        overlapped != NULL &&
        overlapped->hEvent != NULL &&
        byteCount != NULL &&
        flags != NULL);

    //
    // Check if we need to wait for the I/O request to complete
    //
    if (overlapped->_iostatus == NETERR_PENDING && fWait) {
        KIRQL irql;
        WaitForSingleObject(overlapped->hEvent, INFINITE);

        irql = RaiseToDpc();
        if (overlapped->_iostatus == NETERR_PENDING) {
            err = overlapped->_ioxfercnt ? NETERR_OK : NETERR_CANCELLED;
            PcbCompleteOverlappedSendRecv(
                (PcbOverlappedReq*) overlapped->_ioreq,
                err);
        }
        LowerFromDpc(irql);
    }

    //
    // If the I/O request was completed,
    // return the completion status information
    //
    if ((err = overlapped->_iostatus) != NETERR_PENDING && NT_SUCCESS(err)) {
        *byteCount = overlapped->_ioxfercnt;
        *flags = overlapped->_ioflags;
    }

    if (err == NETERR_PENDING) {
        WinsockApiGotoExit_(WSA_IO_INCOMPLETE);
    } else {
        MapNtStatusToWinsockError_(err);
    }
    
    WinsockApiExitSockUnlock_(TRUE, FALSE);
}


INT WSAAPI
WSACancelOverlappedIO(
    SOCKET s
    )

/*++

Routine Description:

    Cancel out any outstanding overlapped I/O requests on a socket

Arguments:

    s - Specifies the socket handle

Return Value:

    0 if successful, SOCKET_ERROR if there is an error

--*/

{
    KIRQL irql;
    WinsockApiPrologSockLock_(WSACancelOverlappedIO, SOCKET_ERROR);

    irql = RaiseToDpc();
    PcbClearOverlappedRecvs(pcb, NETERR_CANCELLED);
    PcbClearOverlappedSends(pcb, NETERR_CANCELLED);
    LowerFromDpc(irql);
    WinsockApiGotoExit_(NO_ERROR);

    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\winsock\xnet\makefile.inc ===
$(XDK_LIB_PATH)\$(TARGETNAME).lib: $(SDK_LIB_PATH)\$(TARGETNAME).lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\winsock\sockopt.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    sockopt.c

Abstract:

    Implement the following Winsock APIs
        setsockopt
        getsockopt
        ioctlsocket
        WSAIoctl

Revision History:

    06/01/2000 davidx
        Created it.

--*/

#include "precomp.h"


int WSAAPI
setsockopt(
    SOCKET s,                 
    int level,                
    int optname,              
    const char* optval,  
    int optlen                
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    INT val;
    WinsockApiPrologSockLock_(setsockopt, SOCKET_ERROR);
    WinsockApiParamCheck_(optval != NULL && optlen > 0);

    if (optlen < (INT) sizeof(INT))
        val = (UCHAR) *optval;
    else
        val = *((INT*) optval);

    switch (level) {
    case SOL_SOCKET:

        // NOTE: Some options may not be applicable to datagram sockets,
        // while others may not be applicable to stream sockets. But
        // we'll let apps set those options here anyway (to avoid extra
        // checking code). Downstream code just won't use those options.

        switch (optname) {
        case SO_BROADCAST:
            if (IsTcb(pcb)) goto noopt;
            pcb->broadcast = val;
            break;

        case SO_DONTLINGER:
            pcb->linger.l_onoff = (u_short) !val;
            break;

        case SO_LINGER:
            WinsockApiParamCheck_(optlen >= sizeof(LINGER));
            CopyMem(&pcb->linger, optval, sizeof(LINGER));
            break;

        case SO_REUSEADDR:
            if (pcb->exclusiveAddr && val != 0) goto inval;
            pcb->reuseAddr = val;
            break;

        case SO_EXCLUSIVEADDRUSE:
            if (pcb->reuseAddr && val != 0) goto inval;
            pcb->exclusiveAddr = val;
            break;
        
        case SO_RCVTIMEO:
            // Timeout value is in milliseconds
            WinsockApiParamCheck_(optlen >= sizeof(INT));
            pcb->recvTimeout = val;
            break;

        case SO_SNDTIMEO:
            // Timeout value is in milliseconds
            WinsockApiParamCheck_(optlen >= sizeof(INT));
            pcb->sendTimeout = val;
            break;

        case SO_RCVBUF:
            WinsockApiParamCheck_(optlen >= sizeof(INT));
            err = PcbUpdateBufferSize(pcb, pcb->maxSendBufsize, val);
            if (!NT_SUCCESS(err)) goto inval;
            break;

        case SO_SNDBUF:
            WinsockApiParamCheck_(optlen >= sizeof(INT));
            err = PcbUpdateBufferSize(pcb, val, pcb->maxRecvBufsize);
            if (!NT_SUCCESS(err)) goto inval;
            break;

        // case SO_OOBINLINE:
        // case SO_KEEPALIVE:
        // case SO_DONTROUTE:
        // case SO_RCVLOWAT:
        // case SO_SNDLOWAT:
        default:
            goto noopt;
        }
        break;

    case IPPROTO_TCP:
        if (IsDgramPcb(pcb)) goto noopt;

        switch (optname) {
        case TCP_NODELAY:
            pcb->noNagle = val;
            break;

        default:
            goto noopt;
        }
        break;

    case IPPROTO_IP:
        switch (optname) {
        case IP_DONTFRAGMENT:
            // NOTE: For TCP sockets, DF bit is controlled
            // by the path MTU discovery mechanism. So
            // we don't allow apps to muck with it.
            if (IsTcb(pcb)) goto inval;
            pcb->ipDontFrag = val;
            break;

        case IP_TTL:
            if (val < 0 || val > 255) goto inval;
            pcb->ipTtl = (BYTE) val;
            break;

        case IP_TOS:
            if (val < 0 || val > 255) goto inval;
            pcb->ipTos = (BYTE) val;
            break;

        case IP_OPTIONS:
            // NOTE:
            // - We allocate pool memory for holding the option data.
            // - We are not validating the IP option data here.
            if (optlen > MAXIPHDRLEN-IPHDRLEN) goto inval;
            PcbFreeIpOpts(pcb);
            if (optlen) {
                PcbSetIpOpts(pcb, optval, optlen);
            }
            break;

        case IP_HDRINCL:
            if (pcb->type != SOCK_RAW) goto noopt;
            pcb->ipHdrIncl = val;
            break;

        case IP_MULTICAST_TTL:
            if (IsTcb(pcb)) goto noopt;
            if (val < 0 || val > 255) goto inval;
            pcb->mcastTtl = (BYTE) val;
            break;

        case IP_MULTICAST_LOOP:
            if (IsTcb(pcb)) goto noopt;
            pcb->noMcastLoopback = !val;
            break;

        case IP_MULTICAST_IF:
            WinsockApiParamCheck_(optlen >= sizeof(struct in_addr));
            if (IsTcb(pcb)) goto noopt;

            err = PcbSetMcastIf(pcb, ((struct in_addr*) optval)->s_addr);
            MapNtStatusToWinsockError_(err);
            break;

        case IP_ADD_MEMBERSHIP:
        case IP_DROP_MEMBERSHIP: {
            struct ip_mreq* mreq;

            WinsockApiParamCheck_(optlen >= sizeof(struct ip_mreq));
            if (IsTcb(pcb)) goto noopt;

            mreq = (struct ip_mreq*) optval;
            err = PcbChangeMcastGroup(
                    pcb,
                    mreq->imr_multiaddr.s_addr,
                    mreq->imr_interface.s_addr,
                    optname == IP_ADD_MEMBERSHIP);

            MapNtStatusToWinsockError_(err);
            }
            break;

        default:
            goto noopt;
        }
        break;

    default:
        goto inval;
    }

    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);

inval:
    err = WSAEINVAL;
    goto exit;

noopt:
    err = WSAENOPROTOOPT;
    goto exit;
}


int WSAAPI
getsockopt(
    SOCKET s,         
    int level,        
    int optname,      
    char* optval, 
    int* optlen  
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    INT val;
    WinsockApiPrologSockLock_(getsockopt, SOCKET_ERROR);

    WinsockApiParamCheck_(
        optval != NULL &&
        optlen != NULL &&
        *optlen > 0);

    ZeroMem(optval, *optlen);

    switch (level) {
    case SOL_SOCKET:

        switch (optname) {
        case SO_BROADCAST:
            if (IsTcb(pcb)) goto noopt;
            val = pcb->broadcast;
            break;

        case SO_DONTLINGER:
            val = !pcb->linger.l_onoff;
            break;

        case SO_LINGER:
            WinsockApiParamCheck_(*optlen >= sizeof(LINGER));
            CopyMem(optval, &pcb->linger, sizeof(LINGER));
            *optlen = sizeof(LINGER);
            goto exit;

        case SO_REUSEADDR:
            val = pcb->reuseAddr;
            break;

        case SO_EXCLUSIVEADDRUSE:
            val = pcb->exclusiveAddr;
            break;

        case SO_RCVTIMEO:
            WinsockApiParamCheck_(*optlen >= sizeof(INT));
            val = pcb->recvTimeout;
            break;

        case SO_SNDTIMEO:
            WinsockApiParamCheck_(*optlen >= sizeof(INT));
            val = pcb->sendTimeout;
            break;

        case SO_RCVBUF:
            WinsockApiParamCheck_(*optlen >= sizeof(INT));
            val = pcb->maxRecvBufsize;
            break;

        case SO_SNDBUF:
            WinsockApiParamCheck_(*optlen >= sizeof(INT));
            val = pcb->maxSendBufsize;
            break;

        case SO_TYPE:
            val = pcb->type;
            break;

        case SO_ACCEPTCONN:
            if (IsDgramPcb(pcb)) goto noopt;
            val = IsTcpListenState(pcb);
            break;

        // case SO_MAXDG:
        // case SO_MAXPATHDG:
        // case SO_OOBINLINE:
        // case SO_KEEPALIVE:
        // case SO_DONTROUTE:
        // case SO_RCVLOWAT:
        // case SO_SNDLOWAT:
        default:
            goto noopt;
        }
        break;

    case IPPROTO_TCP:
        if (IsDgramPcb(pcb)) goto noopt;

        switch (optname) {
        case TCP_NODELAY:
            val = pcb->noNagle;
            break;

        default:
            goto noopt;
        }
        break;

    case IPPROTO_IP:
        switch (optname) {
        case IP_DONTFRAGMENT:
            val = pcb->ipDontFrag;
            break;

        case IP_TTL:
            val = pcb->ipTtl;
            break;

        case IP_TOS:
            val = pcb->ipTos;
            break;

        case IP_OPTIONS:
            if (*optlen < (INT) pcb->ipoptlen)  {
                err = WSAEFAULT;
            } else if (pcb->ipopts) {
                CopyMem(optval, pcb->ipopts, pcb->ipoptlen);
            }
            *optlen = pcb->ipoptlen;
            goto exit;

        case IP_HDRINCL:
            if (pcb->type != SOCK_RAW) goto noopt;
            val = pcb->ipHdrIncl;
            break;

        case IP_MULTICAST_TTL:
            if (IsTcb(pcb)) goto noopt;
            val = pcb->mcastTtl;
            break;

        case IP_MULTICAST_LOOP:
            if (IsTcb(pcb)) goto noopt;
            val = !pcb->noMcastLoopback;
            break;

        case IP_MULTICAST_IF:
            WinsockApiParamCheck_(*optlen >= IPADDRLEN);
            if (IsTcb(pcb)) goto noopt;
            val = pcb->mcastData ? pcb->mcastData->mcastIfAddr : 0;
            break;

        // case IP_ADD_MEMBERSHIP:
        // case IP_DROP_MEMBERSHIP:
        default:
            goto noopt;
        }
        break;

    default:
        err = WSAEINVAL;
        goto exit;
    }

    if (*optlen < sizeof(INT)) {
        *optval = (CHAR) val;
        *optlen = 1;
    } else {
        *((INT*) optval) = val;
        *optlen = sizeof(INT);
    }

    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);

noopt:
    err = WSAENOPROTOOPT;
    goto exit;
}


//
// NOTE: Special ioctlsocket command for enabling and disabling
// IP source address filtering on datagram sockets.
//
#define FIOFILTER _IOW('x', 1, u_long)


int WSAAPI
ioctlsocket(
    SOCKET s,         
    long cmd,         
    u_long* argp  
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    KIRQL irql;
    UINT bytesReady;

    WinsockApiPrologSockLock_(ioctlsocket, SOCKET_ERROR);
    WinsockApiParamCheck_(argp != NULL);

    switch (cmd) {
    case FIONBIO:
        pcb->nonblocking = *argp;
        break;

    case FIONREAD:
        irql = RaiseToDpc();
        if (IsDgramPcb(pcb)) {
            // For UDP/RAW sockets, return the size of the first buffered datagram
            // NOTE: For compatibility with win2k behavior, if the first datagram
            // is 0-sized, we'll return 1.
            if (IsDgramRecvBufEmpty(pcb)) {
                bytesReady = 0;
            } else {
                bytesReady = ((RECVBUF*) pcb->recvbuf.Flink)->datalen;
                if (bytesReady == 0) bytesReady = 1;
            }
        } else {
            // For TCP sockets, return the total number of bytes
            // available for reading.
            bytesReady = pcb->recvbufSize;
        }
        LowerFromDpc(irql);
        *argp = bytesReady;
        break;
    
    // case SIOCATMARK:
    default:
        WinsockApiGotoExit_(WSAENOPROTOOPT);
        break;
    }

    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\winsock\sockmisc.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    sockmisc.c

Abstract:

    Miscellaneous Winsock functions:
        htonl
        htons
        ntohl
        ntohs
        inet_addr
        inet_ntoa
        WSAGetLastError
        WSASetLastError
        WSACreateEvent
        WSACloseEvent
        WSASetEvent
        WSAResetEvent
        WSAWaitForMultipleEvents
        __WSAFDIsSet

Revision History:

    05/30/2000 davidx
        Created it.

--*/

#include "precomp.h"


//
// Converts a u_long from host to network byte order
//
u_long WSAAPI htonl(IN u_long hostlong) {
    return HTONL(hostlong);
}

//
// Converts a u_short from host to network byte order 
//
u_short WSAAPI htons(IN u_short hostshort) {
    return HTONS(hostshort);
}

// 
// Converts a u_long from network order to host byte order 
//
u_long WSAAPI ntohl(IN u_long netlong) {
    return NTOHL(netlong);
}

//
// Converts a u_short from network byte order to host byte order
//
u_short WSAAPI ntohs(IN u_short netshort) {
    return NTOHS(netshort);
}

//
// Converts a string containing an (Ipv4) Internet Protocol
// dotted address into a proper address for the IN_ADDR structure.
//
unsigned long WSAAPI inet_addr(IN const char* cp) {
    IPADDR addr;

    WinsockApiPrologLight_(inet_addr);
    WinsockApiParamCheck_(cp != NULL);

    return IpAddrFromString(cp, &addr) ? addr : INADDR_NONE;
}

//
// Converts an (Ipv4) Internet network address into
// a string in Internet standard dotted format.
//
char* WSAAPI inet_ntoa(IN struct in_addr in) {
    WinsockApiProlog_(inet_ntoa, NULL);

    if (!SockAllocThreadbuf(&tlsData->strbuf, 16)) {
        WinsockApiReturnError_(WSAENOBUFS, NULL);
    }

    return IpAddrToString(in.s_addr, tlsData->strbuf.data, tlsData->strbuf.size);
}

//
// Gets the error status for the last operation that failed
//
int WSAAPI WSAGetLastError() {
    return GetLastError();
}

//
// Sets the error code that can be retrieved
// through the WSAGetLastError function
//
void WSAAPI WSASetLastError(IN int error) {
    SetLastError(error);
}

//
// Creates a new event object
//
WSAEVENT WSAAPI WSACreateEvent() {
    return CreateEvent(NULL, TRUE, FALSE, NULL);
}

//
// Closes an open event object handle
//
BOOL WSAAPI WSACloseEvent(IN WSAEVENT hEvent) {
    return CloseHandle(hEvent);
}

//
// Sets the state of the specified event object to signaled
//
BOOL WSAAPI WSASetEvent(IN WSAEVENT hEvent) {
    return SetEvent(hEvent);
}

//
// Resets the state of the specified event object to nonsignaled
//
BOOL WSAAPI WSAResetEvent(IN WSAEVENT hEvent) {
    return ResetEvent(hEvent);
}

//
// Returns either when one or all of the specified event objects
// are in the signaled state, or when the time-out interval expires
//
DWORD WSAAPI
WSAWaitForMultipleEvents(
    IN DWORD cEvents,
    IN const WSAEVENT* lphEvents,
    IN BOOL fWaitAll,
    IN DWORD dwTimeout,
    IN BOOL fAlertable
    )
{
    return WaitForMultipleObjectsEx(
                cEvents,
                lphEvents,
                fWaitAll,
                dwTimeout,
                fAlertable);
}

//
// Determines if a specific socket is a contained in an FD_SET
//
int WSAAPI __WSAFDIsSet(SOCKET fd, fd_set* set) {
    int i = (set->fd_count & 0xffff);
    while (i--){
        if (set->fd_array[i] == fd) return 1;
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\winsock\socket.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    socket.c

Abstract:

    Implement the following Winsock APIs:
        socket
        closesocket
        shutdown

Revision History:

    06/01/2000 davidx
        Created it.

--*/

#include "precomp.h"

SOCKET WSAAPI
socket(
    IN int af,
    IN int type,
    IN int protocol
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    const WSAPROTOCOL_INFOW* protoinfo;
    PCB* pcb;

    WinsockApiProlog_(socket, INVALID_SOCKET);

    err = MatchTcpipProtocol(af, type, protocol, &protoinfo);
    WinsockApiCheckError_(INVALID_SOCKET);

    if (type == 0) type = protoinfo->iSocketType;
    if (protocol == 0) protocol = protoinfo->iProtocol;

    pcb = PcbCreate(type, protocol, 0);
    if (!pcb) {
        WinsockApiReturnError_(WSAENOBUFS, INVALID_SOCKET);
    }

    // Initialize socket information here
    pcb->protocolFlags = protoinfo->dwServiceFlags1;

    PcbInsertToList(pcb);
    return (SOCKET) pcb;
}


int WSAAPI
closesocket(
    IN SOCKET s
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    WinsockApiPrologSockLock_(closesocket, SOCKET_ERROR);

    err = pcb ? PcbClose(pcb, FALSE) : NETERR_PARAM;
    MapNtStatusToWinsockError_(err);

    // NOTE: PcbClose will always close the socket.
    // So there is no need for us to call SockUnlock here.

    WinsockApiCheckError_(SOCKET_ERROR);
    return NO_ERROR;
}


int WSAAPI
shutdown(
    IN SOCKET s,
    IN int how
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    BYTE flags;
    WinsockApiPrologSockLock_(shutdown, SOCKET_ERROR);

    WinsockApiParamCheck_(
        how == SD_SEND ||
        how == SD_RECEIVE ||
        how == SD_BOTH);

    switch (how) {
    case SD_SEND:
        flags = PCBFLAG_SEND_SHUTDOWN;
        break;

    case SD_RECEIVE:
        flags = PCBFLAG_RECV_SHUTDOWN;
        break;

    default:
        flags = PCBFLAG_SEND_SHUTDOWN|PCBFLAG_RECV_SHUTDOWN;
        break;
    }

    if (IsDgramPcb(pcb)) {
        err = PcbShutdownDgram(pcb, flags);
    } else {
        if (!IsPcbConnected(pcb)) {
            WinsockApiGotoExit_(WSAENOTCONN);
        }
        err = TcbShutdown((TCB*) pcb, flags, TRUE);
    }

    MapNtStatusToWinsockError_(err);
    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\winsock\sources.inc ===
!include ..\..\sources.inc

SYNCHRONIZE_DRAIN=1
C_DEFINES=$(C_DEFINES) -D_XNET_SERVICE

INCLUDES=..; \
    $(INCLUDES); \
    ..\..\tcp

PRECOMPILED_INCLUDE=..\precomp.h

SOURCES=\
    ..\sockinit.c \
    ..\socket.c \
    ..\sockopt.c \
    ..\recv.c \
    ..\send.c \
    ..\connect.c \
    ..\select.c \
    ..\sockmisc.c \
    ..\enumprot.c \
    ..\getxbyy.c

USE_NOLIBS=1
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\winsock\sockp.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    sockp.h

Abstract:

    Declarations internal to Winsock implementation

Revision History:

    05/30/2000 davidx
        Created it.

--*/

#ifndef _SOCKP_H
#define _SOCKP_H

//------------------------------------------------------------------------
// Per-thread Winsock data
//------------------------------------------------------------------------

typedef struct _WinsockThreadbuf {
    CHAR* data;
    UINT size;
} WinsockThreadbuf;

typedef struct _WinsockTlsData {
    WinsockThreadbuf strbuf;
    WinsockThreadbuf hostentbuf;
    WinsockThreadbuf serventbuf;
    WinsockThreadbuf protoentbuf;
} WinsockTlsData;

WinsockTlsData* SockAllocThreadData();
VOID SockFreeThreadData(WinsockTlsData* tlsData);

#if defined(BUILD_FOR_DEBUGGER)

INLINE WinsockTlsData* SockGetThreadData() {
    return (WinsockTlsData*) DmGetCurrentDmtd()->WinSockData;
}

INLINE VOID SockSetThreadData(WinsockTlsData* tlsData) {
    DmGetCurrentDmtd()->WinSockData = tlsData;
}

#else // !BUILD_FOR_DEBUGGER

extern __declspec(thread) WinsockTlsData* WinsockTlsDataPtr;

INLINE WinsockTlsData* SockGetThreadData() {
    return WinsockTlsDataPtr;
}

INLINE VOID SockSetThreadData(WinsockTlsData* tlsData) {
    WinsockTlsDataPtr = tlsData;
}

#endif // !BUILD_FOR_DEBUGGER

// Allocate per-thread temporary buffer
VOID* SockAllocThreadbuf(WinsockThreadbuf* buf, UINT size);

//------------------------------------------------------------------------
// Map an API-level socket handle to
// a pointer to our internal socket data structure
//------------------------------------------------------------------------

INLINE PCB* SockLock(SOCKET s) {
    PCB* pcb;
    INT err;
    LONG cookie;

    // NOTE: We don't allow multiple threads to access the same
    // socket simultaneously. If the app tries to do that, the first
    // thread will succeed and other threads will get an error return.

    if (s == 0 || s == INVALID_SOCKET) {
        err = WSAENOTSOCK;
    } else {
        pcb = (PCB*) s;
        cookie = InterlockedCompareExchange(
                    &pcb->magicCookie,
                    BUSY_PCB_COOKIE,
                    ACTIVE_PCB_COOKIE);

        if (cookie == ACTIVE_PCB_COOKIE) return pcb;
        err = (cookie == BUSY_PCB_COOKIE) ? WSAEINPROGRESS : WSAENOTSOCK;
    }

    #if DBG
    #if !defined(BUILD_FOR_DEBUGGER)
    if (err == WSAEINPROGRESS) {
        WARNING_("Thread contention on socket handle: tid = %x, socket = %x",
                 GetCurrentThreadId(), s);
    } else
    #endif
    {
        WARNING_("Invalid socket handle: socket = %x, error = %d", s, err);
    }
    #endif

    SetLastError(err);
    return NULL;
}

INLINE VOID SockUnlock(PCB* pcb) {
    pcb->magicCookie = ACTIVE_PCB_COOKIE;
}

//
// Socket address length
//
#define SOCKADDRLEN ((INT) sizeof(SOCKADDR_IN))

//
// Network stack initialization state
//
extern LONG XnetInitState;

#define XNETSTATE_INVALID   0   // not initialized
#define XNETSTATE_READY     1   // successfully initialized

//
// Find a supported protocol that matches the specified parameters
//
INT
MatchTcpipProtocol(
    IN INT af,
    IN INT type,
    IN INT protocol,
    OUT const WSAPROTOCOL_INFOW** protoinfo
    );

//------------------------------------------------------------------------
// Prolog and epilog code for Winsock API functions
//------------------------------------------------------------------------

INT SockEnterApiSlow(WinsockTlsData** tlsData);

#if DBG

#define SOCKTRACE_WSAStartup                BIT(0)
#define SOCKTRACE_WSACleanup                BIT(0)
#define SOCKTRACE_socket                    BIT(1)
#define SOCKTRACE_closesocket               BIT(1)
#define SOCKTRACE_shutdown                  BIT(1)
#define SOCKTRACE_setsockopt                BIT(2)
#define SOCKTRACE_getsockopt                BIT(2)
#define SOCKTRACE_ioctlsocket               BIT(2)
#define SOCKTRACE_WSARecv                   BIT(3)
#define SOCKTRACE_WSARecvFrom               BIT(3)
#define SOCKTRACE_recv                      BIT(3)
#define SOCKTRACE_recvfrom                  BIT(3)
#define SOCKTRACE_WSASend                   BIT(4)
#define SOCKTRACE_WSASendTo                 BIT(4)
#define SOCKTRACE_send                      BIT(4)
#define SOCKTRACE_sendto                    BIT(4)
#define SOCKTRACE_bind                      BIT(5)
#define SOCKTRACE_connect                   BIT(5)
#define SOCKTRACE_listen                    BIT(5)
#define SOCKTRACE_accept                    BIT(5)
#define SOCKTRACE_getsockname               BIT(5)
#define SOCKTRACE_getpeername               BIT(5)
#define SOCKTRACE_select                    BIT(6)
#define SOCKTRACE_WSAGetOverlappedResult    BIT(6)
#define SOCKTRACE_WSACancelOverlappedIO     BIT(6)
#define SOCKTRACE_inet_addr                 BIT(7)
#define SOCKTRACE_inet_ntoa                 BIT(7)
#define SOCKTRACE_gethostbyaddr             BIT(7)
#define SOCKTRACE_gethostbyname             BIT(7)
#define SOCKTRACE_gethostname               BIT(7)
#define SOCKTRACE_getprotoby_               BIT(7)
#define SOCKTRACE_getprotobyname            BIT(7)
#define SOCKTRACE_getprotobynumber          BIT(7)
#define SOCKTRACE_getservby_                BIT(7)
#define SOCKTRACE_getservbyname             BIT(7)
#define SOCKTRACE_getservbyport             BIT(7)
#define SOCKTRACE_WSAEnumProtocols          BIT(7)
#define SOCKTRACE_XnetInitialize            BIT(8)
#define SOCKTRACE_XnetCleanup               BIT(8)
#define SOCKTRACE_XnetGetIpAddress          BIT(8)

extern INT _winsockTraceFlag;

#define WinsockApiProlog_(_apiname, _result) \
        static const CHAR* fname_ = #_apiname; \
        WinsockTlsData* tlsData; \
        INT err; \
        if (_winsockTraceFlag & SOCKTRACE_##_apiname) { \
            DbgPrint("Entering %s...\n", fname_); \
        } \
        err = (XnetInitState == XNETSTATE_INVALID) ? WSASYSNOTREADY : \
              ((tlsData = SockGetThreadData()) != NULL) ? NO_ERROR : \
              SockEnterApiSlow(&tlsData); \
        WinsockApiCheckError_(_result)

#define WinsockApiPrologLight_(_apiname) \
        static const CHAR* fname_ = #_apiname; \
        if (_winsockTraceFlag & SOCKTRACE_##_apiname) { \
            DbgPrint("Entering %s...\n", fname_); \
        }

#define WinsockApiWarnError_(_err) { \
            if ((_err) != WSA_IO_PENDING && \
                (_err) != WSA_IO_INCOMPLETE && \
                (_err) != WSAETIMEDOUT && \
                (_err) != WSAEWOULDBLOCK) { \
                WARNING_("%s failed: %d", fname_, _err); \
            } \
        }

#define WinsockApiParamCheck_(_exp) { \
            if (!(_exp)) { \
                DbgPrint("%s: %s\n", fname_, #_exp); \
                RIP("bad winsock parameters\n"); \
            } \
        }

#else // !DBG

#define WinsockApiProlog_(_apiname, _result) \
        WinsockTlsData* tlsData; \
        INT err; \
        err = (XnetInitState == XNETSTATE_INVALID) ? WSASYSNOTREADY : \
              ((tlsData = SockGetThreadData()) != NULL) ? NO_ERROR : \
              SockEnterApiSlow(&tlsData); \
        WinsockApiCheckError_(_result)

#define WinsockApiPrologLight_(_apiname)
#define WinsockApiWarnError_(_err)
#define WinsockApiParamCheck_(_exp)

#endif // !DBG

#define WinsockApiReturnError_(_err, _result) { \
            WinsockApiWarnError_(_err); \
            SetLastError(_err); \
            return (_result); \
        }

#define WinsockApiCheckError_(_result) { \
            if (err != NO_ERROR) { \
                WinsockApiReturnError_(err, _result); \
            } \
        }

#define WinsockApiPrologSockLock_(_apiname, _result) \
        PCB* pcb; \
        WinsockApiProlog_(_apiname, _result); \
        pcb = SockLock(s); \
        if (!pcb) return (_result)

#define WinsockApiExitSockUnlock_(_resultOk, _resultErr) \
        exit: SockUnlock(pcb); \
        WinsockApiCheckError_(_resultErr); \
        return (_resultOk)

#define WinsockApiGotoExit_(_err) \
        { err = (_err); goto exit; }

#define MapNtStatusToWinsockError_(_err) \
        ((_err) = NT_SUCCESS(_err) ? NO_ERROR : RtlNtStatusToDosError(_err))

#endif // !_SOCKP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xnet\winsock\sockinit.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    sockinit.c

Abstract:

    Winsock initialization and cleanup related functions

Revision History:

    05/24/2000 davidx
        Created it.

--*/

#include "precomp.h"
#include "phy.h"
#include <xboxverp.h>

#pragma comment(linker, "/include:_XnetBuildNumber")
#pragma data_seg(".XBLD$V")

#if DBG
unsigned short XnetBuildNumber[8] =
        { 'X' | ('N' << 8), 'E' | ('T' << 8), 'D', 0, VER_PRODUCTVERSION | 0x8000 };
#else
unsigned short XnetBuildNumber[8] =
        { 'X' | ('N' << 8), 'E' | ('T' << 8),   0, 0, VER_PRODUCTVERSION };
#endif

#pragma data_seg()

//
// Linker directive to merge XNET_RD section into XNET section
//
#pragma comment(linker, "/merge:XNET_RD=XNET")

//
// Global variable definitions
//
LONG XnetInitCount = 0;
LONG WsaStartupCount = 0;
WORD WinsockVersion = WINSOCK_VERSION;
LONG XnetInitState = XNETSTATE_INVALID;
INITIALIZED_CRITICAL_SECTION(WinsockInitLock);
UINT cfgXnetConfigFlags;

// BUGBUG: temporary workaround for nv2a snooping bug
VOID* (*XnetUncachedAllocProc)(SIZE_T, ULONG);
VOID (*XnetUncachedFreeProc)(VOID*);

#if DBG
INT _winsockTraceFlag = 0;
#endif

#ifdef BUILD_FOR_DEBUGGER
UINT defaultPacketAllocFlag = PKTFLAG_DBGMON;
#else
UINT defaultPacketAllocFlag = 0;
__declspec(thread) WinsockTlsData* WinsockTlsDataPtr;
#endif

//
// Stuff we need to cleanup our per-thread data
// when a thread is deleted.
//
VOID WinsockThreadDetach();

#ifndef BUILD_FOR_DEBUGGER
PRIVATE XTHREAD_NOTIFICATION WinsockThreadNotification;
PRIVATE BOOL WinsockThreadNotifyRegistered;
PRIVATE VOID WINAPI WinsockThreadNotifyProc(BOOL Create) {
    if (!Create) WinsockThreadDetach();
}
#endif

//
// Acquire and release global initialization lock
//
INLINE LONG AcquireWinsockInitLock() {
    EnterCriticalSection(&WinsockInitLock);
    return XnetInitState;
}

INLINE VOID ReleaseWinsockInitLock(LONG state) {
    XnetInitState = state;
    LeaveCriticalSection(&WinsockInitLock);
}


PRIVATE VOID
XnetCleanupInternal()

/*++

Routine Description:

    Internal function to unload the XBox network stack

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    KIRQL irql;

    DnsCleanup();

    // Forcefully close all open sockets
    PcbCloseAll();

    // Clean up the TCP/IP stack
    irql = RaiseToDpc();
    TcpCleanup();
    XnetPoolCleanup();
    #ifdef DVTSNOOPBUG
    XnetUncachedPoolCleanup();
    #endif
    LowerFromDpc(irql);

    WinsockThreadDetach();

    #ifndef BUILD_FOR_DEBUGGER

    if (WinsockThreadNotifyRegistered) {
        XRegisterThreadNotifyRoutine(&WinsockThreadNotification, FALSE);
        WinsockThreadNotifyRegistered = FALSE;
    }

    #endif // !BUILD_FOR_DEBUGGER
}


INT WSAAPI
XnetInitialize(
    const XnetInitParams* initParams,
    BOOL wait
    )

/*++

Routine Description:

    Load XBox network stack

Arguments:

    initParams - Optional initialization parameters
    wait - Whether to wait for the initialization to complete

Return Value:

    Winsock error code

--*/

{
    NTSTATUS status;
    LONG xnetstate;

    xnetstate = AcquireWinsockInitLock();

    // If this is the first XnetInitialize call,
    // initialize the network stack now.

    if (xnetstate == XNETSTATE_INVALID) {
        ASSERT(XnetInitCount == 0);

        #ifndef BUILD_FOR_DEBUGGER

        WinsockThreadNotification.pfnNotifyRoutine = WinsockThreadNotifyProc;
        XRegisterThreadNotifyRoutine(&WinsockThreadNotification, TRUE);
        WinsockThreadNotifyRegistered = TRUE;

        #endif // !BUILD_FOR_DEBUGGER

        // Use the specified configuration parameters
        if (initParams && initParams->structSize == sizeof(XnetInitParams)) {
            // private pool size
            if (initParams->privatePoolSize)
                cfgXnetPoolSize = initParams->privatePoolSize;

            // Ethernet receive queue length
            if (initParams->enetRecvQLength)
                cfgRecvQLength = initParams->enetRecvQLength;

            // max IP reassembly size
            if (initParams->maxIPReassemblySize &&
                initParams->maxIPReassemblySize <= (MAXIPLEN-MAXIPHDRLEN))
                cfgMaxReassemblySize = initParams->maxIPReassemblySize;

            // max IP reassembly datagrams
            if (initParams->maxIPReassemblyDgrams)
                cfgMaxReassemblyDgrams = initParams->maxIPReassemblyDgrams;

            // default send/recv buffer sizes
            if (initParams->defaultSocketRecvBufSize > 0 &&
                initParams->defaultSocketRecvBufSize <= cfgMaxSendRecvBufsize)
                cfgDefaultRecvBufsize = initParams->defaultSocketRecvBufSize;

            if (initParams->defaultSocketSendBufSize > 0 &&
                initParams->defaultSocketSendBufSize <= cfgMaxSendRecvBufsize)
                cfgDefaultSendBufsize = initParams->defaultSocketSendBufSize;

            // default IP datagram TTL and TOS
            cfgDefaultTtl = initParams->defaultIpTTL;
            cfgDefaultTos = initParams->defaultIpTOS;

            // max number of sockets
            if (initParams->maxSockets)
                cfgMaxSockets = initParams->maxSockets;

            // configuration flags
            if (initParams->configFlags)
                cfgXnetConfigFlags = initParams->configFlags;
        }

        XnetInitRandSeed();

        // Initialize our private pool
        status = XnetPoolInit();
        if (!NT_SUCCESS(status)) goto failed;

        // Initialize the DNS client
        status = DnsInitialize();
        if (!NT_SUCCESS(status)) goto failed;

        // Initialize the TCP/IP stack
        status = TcpInitialize();
        if (!NT_SUCCESS(status)) goto failed;

        xnetstate = XNETSTATE_READY;
    }

    XnetInitCount++;
    ReleaseWinsockInitLock(xnetstate);

    // Wait for the initialization to complete if necessary
    if (wait) {
        IfInfo* ifp;
        status = NETERR(WSASYSNOTREADY);
        LOOP_THRU_INTERFACE_LIST(ifp)
            if (IfDhcpEnabled(ifp)) {
                status = DhcpWaitForAddress(ifp);
                break;
            }
        END_INTERFACE_LIST_LOOP()

        if (!NT_SUCCESS(status)) {
            XnetCleanup();
            return RtlNtStatusToDosError(status);
        }
    }

    return NO_ERROR;

failed:
    // Fail to initialize the network stack.
    // Cleanup before returning error.

    XnetCleanupInternal();
    ReleaseWinsockInitLock(xnetstate);
    return RtlNtStatusToDosError(status);
}


INT WSAAPI
XnetCleanup()

/*++

Routine Description:

    Public API function to unload the XBox network stack

Arguments:

    NONE

Return Value:

    Winsock error code

--*/

{
    INT err;
    LONG xnetstate;

    xnetstate = AcquireWinsockInitLock();

    if (xnetstate == XNETSTATE_INVALID) {
        ASSERT(XnetInitCount == 0);
        err = WSASYSNOTREADY;
    } else {
        if (XnetInitCount <= 0) {
            err = WSANOTINITIALISED;
        } else {
            if (--XnetInitCount == 0) {
                ASSERT(WsaStartupCount == 0);
                XnetCleanupInternal();
                xnetstate = XNETSTATE_INVALID;
            }
            err = NO_ERROR;
        }
    }

    ReleaseWinsockInitLock(xnetstate);
    return err;
}


VOID
WinsockThreadDetach()

/*++

Routine Description:

    This is called when a thread dies and we use the chance
    to clean up any per-thread Winsock data we may have allocated.

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    WinsockTlsData* tlsData;
    if ((tlsData = SockGetThreadData()) != NULL) {
        SockSetThreadData(NULL);
        SockFreeThreadData(tlsData);
    }
}


int WSAAPI
WSAStartup(
    IN WORD wVersionRequired,
    OUT LPWSADATA lpWSAData
    )

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    BYTE majorVersion = LOBYTE(wVersionRequired);
    BYTE minorVersion = HIBYTE(wVersionRequired);
    WinsockTlsData* tlsData;
    LONG xnetstate;
    INT err;

    WinsockApiPrologLight_(WSAStartup);
    WinsockApiParamCheck_(lpWSAData != NULL);

    xnetstate = AcquireWinsockInitLock();
    if (xnetstate == XNETSTATE_INVALID) {
        WinsockApiGotoExit_(WSASYSNOTREADY);
    }

    //
    // Version checks
    //
    switch (majorVersion) {
    case 0:
        WinsockApiGotoExit_(WSAVERNOTSUPPORTED);
        break;

    case 1:
        if (minorVersion > 1) minorVersion = 1;
        break;

    case 2:
        if (minorVersion > 2) minorVersion = 2;
        break;

    default:
        majorVersion = minorVersion = 2;
        break;
    }

    WinsockVersion = MAKEWORD(majorVersion, minorVersion);
    TRACE_("WSAStartup: version = %d.%d", majorVersion, minorVersion);

    //
    // Fill in the user structure
    //
    ZeroMem(lpWSAData, sizeof(WSADATA));
    lpWSAData->wVersion = WinsockVersion;
    lpWSAData->wHighVersion = WINSOCK_VERSION;

    if (majorVersion == 1) {
        // Hack for Winsock 1.1
        lpWSAData->iMaxSockets = 0x7fff;
        lpWSAData->iMaxUdpDg = MAXIPLEN-MAXIPHDRLEN-UDPHDRLEN;
    }

    strcpy(lpWSAData->szDescription, "WinSock 2.0");
    strcpy(lpWSAData->szSystemStatus, "Running");

    //
    // Initialize per-thread information
    //
    if ((tlsData = SockGetThreadData()) == NULL &&
        (tlsData = SockAllocThreadData()) == NULL) {
        WinsockApiGotoExit_(WSAENOBUFS);
    }

    SockSetThreadData(tlsData);
    WsaStartupCount++;
    err =  NO_ERROR;

exit:
    ReleaseWinsockInitLock(xnetstate);
    return err;
}


int WSAAPI
WSACleanup()

/*++

Routine Description:

    Refer to XAPI SDK documentation.

--*/

{
    LONG xnetstate;
    INT err;

    xnetstate = AcquireWinsockInitLock();

    if (xnetstate == XNETSTATE_INVALID) {
        err = WSASYSNOTREADY;
    } else {
        if (WsaStartupCount <= 0) {
            err = WSANOTINITIALISED;
        } else {
            if (--WsaStartupCount == 0) {
                // Last call to WSACleanup
                //  perform any necessary cleanup work
                PcbCloseAll();
                WinsockThreadDetach();
            }
            err = NO_ERROR;
        }
    }

    ReleaseWinsockInitLock(xnetstate);

    if (err != NO_ERROR) {
        WARNING_("WSACleanup failed: %d", err);
        SetLastError(err);
        err = SOCKET_ERROR;
    }
    return err;
}


INT
SockEnterApiSlow(
    OUT WinsockTlsData** tlsData
    )

/*++

Routine Description:

    Initialize per-thread Winsock data

Arguments:

    tlsData - Returns a pointer to the per-thread Winsock data

Return Value:

    Error code

--*/

{
    WinsockTlsData* data;

    if (WsaStartupCount <= 0)
        return WSANOTINITIALISED;

    //
    // If this thread has not been initialized, do it now.
    //
    if ((data = SockAllocThreadData()) == NULL)
        return WSAENOBUFS;

    SockSetThreadData(data);
    *tlsData = data;
    return NO_ERROR;
}


WinsockTlsData*
SockAllocThreadData()

/*++

Routine Description:

    Allocate memory for per-thread Winsock data

Arguments:

    NONE

Return Value:

    Pointer to newly created per-thread data structure
    NULL if there is an error

--*/

{
    WinsockTlsData* tlsData;

    tlsData = MAlloc0(sizeof(*tlsData));
    if (!tlsData) return NULL;

    // Perform additional initialization here
    return tlsData;
}


VOID
SockFreeThreadData(
    WinsockTlsData* tlsData
    )

/*++

Routine Description:

    Dispose of per-thread Winsock data

Arguments:

    tlsData - Points to the per-thread data structure to be disposed

Return Value:

    NONE

--*/

{
    if (tlsData) {
        SockSetThreadData(NULL);
        Free(tlsData->strbuf.data);
        Free(tlsData->hostentbuf.data);
        Free(tlsData->serventbuf.data);
        Free(tlsData->protoentbuf.data);
        Free(tlsData);
    }
}


VOID*
SockAllocThreadbuf(
    WinsockThreadbuf* buf,
    UINT size
    )

/*++

Routine Description:

    Allocate (or grow) a temporary per-thread memory buffer

Arguments:

    buf - Points to the buffer structure
    size - Specifies the desired size of the buffer

Return Value:

    Pointer to the buffer data if successful
    NULL if there is an error

--*/

{
    VOID* data;

    // Check if the existing buffer is already ok
    if (size <= buf->size) return buf->data;

    data = MAlloc(size);
    if (data) {
        Free(buf->data);
        buf->data = (CHAR*) data;
        buf->size = size;
    }
    return data;
}


//
// Debug spew functions
//
#if DBG

VOID XnetDbgWarn(CHAR* format, ...) {
    va_list args;
    va_start(args, format);
    vXDebugPrint(XDBG_WARNING, "XNET", format, args);
    va_end(args);
}

VOID XnetDbgVerbose(CHAR* format, ...) {
    va_list args;
    va_start(args, format);
    vXDebugPrint(XDBG_TRACE, "XNET", format, args);
    va_end(args);
}

VOID XnetDbgTrace(CHAR* format, ...) {
    va_list args;
    va_start(args, format);
    vXDebugPrint(XDBG_ENTRY, "XNET", format, args);
    va_end(args);
}

#endif // DBG


//
// NOTE: XnetGetEthernetLinkStatus is placed in the default .text code section.
// This is so that it can be called before XNET code section is loaded.
//
#pragma code_seg(".text")

DWORD WSAAPI
XnetGetEthernetLinkStatus()

/*++

Routine Description:

    Get Ethernet link status

Arguments:

    NONE

Return Value:

    TRUE if Ethernet port is connected to the network
    FALSE otherwise

--*/

{
    // If Xnet is not yet initialized, we may need to
    // initialize the PHY first.
    #ifndef SILVER
    if (XnetInitCount == 0) {
        PhyInitialize(FALSE, NULL);
    }
    #endif

    return PhyGetLinkState(FALSE);
}

#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\xprof\bbtirt.h ===
/***********************************************************************
* Microsoft BBT
*
* Microsoft Confidential.  Copyright 1994-2000 Microsoft Corporation.
*
* Component:
*
* File: bbtirt.h
*
* File Comments:
*
*
***********************************************************************/


//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//                                                                         !
//                                                                         !
//                                                                         !
// Please note that this file is being shared with the NT group for kernel !
// instrumentation since they are generating their own IDF files for BBT.  !
// So please notify one of us JohnLef/HoiV/BobFitz before changing any     !
// data structures that has to do with the IDFHDR or IRTP.                 !
//                                                                         !
//                                                                         !
//                                                                         !
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


struct IRTP                            // Instrumentation Run Time Parameters
{
   DWORD       dwVersion;              // Version of this structure
   DWORD       dwId;                   // Id of database
   DWORD       dwGeneration;           // Database generation
   void        *pvImageBase;           // Base address of this module
   DWORD       cmsTimer;               // Timer interval in milliseconds
   DWORD       fMultipleInstance;      // Instrument multiple instances together
   DWORD       fSweepable;             // Sweeping is supported
   DWORD       fNtVdm;                 // This is NTVDM.EXE or WOW32.DLL
   DWORD       tov;                    // Variety of time order instrumentation
   DWORD       *rgpfnCallback;         // Pointer to array of callback pointers
   void        *pfnNopCallback;        // Pointer to nop thunk
#ifdef  POGO
   DWORD       pfnNopCallback2;        // Pointer to nop thunk for switch probe
#endif
   void        **rgpvResource;         // Pointer to array of resource addresses
   DWORD       cbIdfMax;               // User requested maximum IDF size
   DWORD       cbrc;                   // Count of static branches
   DWORD       cibs;                   // Count of indirect branch sources
   DWORD       cibd;                   // Count of indirect branch targets
   DWORD       cfun;                   // Count of functions
   DWORD       crsc;                   // Count of resources
#ifdef  POGO
   DWORD       csbr;                   // Count of switches
#endif
   DWORD       ifunEndBoot;            // Last function of boot; 0xFFFFFFFF if none

   char        *szIdfPath;             // UNDONE: Remove when new IRT complete
   char        *szIdfKeyPath;          // UNDONE: Remove when new IRT complete
   DWORD       dwDynProbeCount;        // Number of TOB Probes to execute to increment time.
   DWORD       fFourBitTobs;           // Are we using 4-bit tobs?
};

// This is a copy of IRTP with all the pointer fields
// replaced by DWORDLONG so that we can get 64 bit values
// to pass over to IRT.
//
struct IRTPIA64                        // Instrumentation Run Time Parameters
{
   DWORD       dwVersion;              // Version of this structure
   DWORD       dwId;                   // Id of database
   DWORD       dwGeneration;           // Database generation
   DWORDLONG   pvImageBase;            // Base address of this module
   DWORD       cmsTimer;               // Timer interval in milliseconds
   DWORD       fMultipleInstance;      // Instrument multiple instances together
   DWORD       fSweepable;             // Sweeping is supported
   DWORD       fNtVdm;                 // This is NTVDM.EXE or WOW32.DLL
   DWORD       tov;                    // Variety of time order instrumentation
   DWORDLONG   rgpfnCallback;          // Pointer to array of callback pointers
   DWORDLONG   pfnNopCallback;         // Pointer to nop thunk
#ifdef  POGO
   DWORD       pfnNopCallback2;        // Pointer to nop thunk for switch probe
#endif
   DWORDLONG   rgpvResource;           // Pointer to array of resource addresses
   DWORD       cbIdfMax;               // User requested maximum IDF size
   DWORD       cbrc;                   // Count of static branches
   DWORD       cibs;                   // Count of indirect branch sources
   DWORD       cibd;                   // Count of indirect branch targets
   DWORD       cfun;                   // Count of functions
   DWORD       crsc;                   // Count of resources
#ifdef  POGO
   DWORD       csbr;                   // Count of switches
#endif
   DWORD       ifunEndBoot;            // Last function of boot; 0xFFFFFFFF if none

   DWORDLONG   szIdfPath;             // UNDONE: Remove when new IRT complete
   DWORDLONG   szIdfKeyPath;          // UNDONE: Remove when new IRT complete
   DWORD       dwDynProbeCount;        // Number of TOB Probes to execute to increment time.
   DWORD       fFourBitTobs;           // Are we using 4-bit tobs?
};


#ifdef POGO

const DWORD dwIrtVerCurrent = 0x8000100b;

#else   // !POGO

const DWORD dwIrtVerCurrent = 0x00001010; // This also much be changed in idf.h

#endif  // !POGO


enum IIFN                              // Index into IRTP.rpfnCallback array
{
#ifdef POGO
   iifnInit,                           // UNDONE: remove when complier updated
#endif
   iifnBranch,                         // Direct branch
   iifnIndirectSource,                 // Indirect branch source
   iifnIndirectTarget,                 // Indirect branch target
   iifnFunction,                       // Function entry
#ifdef POGO
   iifnSwitch,                         // Switch statement
#endif
   iifnMax
};

struct FASTRTPARAM
{
   ch