ms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSPECIFYPROJECTDESIGNERPAGES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSPECIFYPROJECTDESIGNERPAGES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSpecifyProjectDesignerPagesNotImpl :
	public IVsSpecifyProjectDesignerPages
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSpecifyProjectDesignerPagesNotImpl)

public:

	typedef IVsSpecifyProjectDesignerPages Interface;

	STDMETHOD(GetProjectDesignerPages)(
		/*[out]*/ CAUUID* /*pPages*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSpecifyProjectDesignerPagesMockImpl :
	public IVsSpecifyProjectDesignerPages,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSpecifyProjectDesignerPagesMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSpecifyProjectDesignerPagesMockImpl)

	typedef IVsSpecifyProjectDesignerPages Interface;
	struct GetProjectDesignerPagesValidValues
	{
		/*[out]*/ CAUUID* pPages;
		HRESULT retValue;
	};

	STDMETHOD(GetProjectDesignerPages)(
		/*[out]*/ CAUUID* pPages)
	{
		VSL_DEFINE_MOCK_METHOD(GetProjectDesignerPages)

		VSL_SET_VALIDVALUE(pPages);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSPECIFYPROJECTDESIGNERPAGES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSplitPane.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSPLITPANE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSPLITPANE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSplitPaneNotImpl :
	public IVsSplitPane
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSplitPaneNotImpl)

public:

	typedef IVsSplitPane Interface;

	STDMETHOD(SetParentSplitter)(
		/*[in]*/ IVsSplitter* /*pSplitter*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetParentSplitter)(
		/*[out]*/ IVsSplitter** /*ppSplitter*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetFocus)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetPosition)(
		/*[in]*/ long /*iLeft*/,
		/*[in]*/ long /*iTop*/,
		/*[in]*/ long /*iRight*/,
		/*[in]*/ long /*iBottom*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPosition)(
		/*[out]*/ long* /*piLeft*/,
		/*[out]*/ long* /*piTop*/,
		/*[out]*/ long* /*piRight*/,
		/*[out]*/ long* /*piBottom*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSizeExtents)(
		/*[out]*/ long* /*piMinHorz*/,
		/*[out]*/ long* /*piMaxHorz*/,
		/*[out]*/ long* /*piMinVert*/,
		/*[out]*/ long* /*piMaxVert*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetParentWindow)(
		/*[out]*/ HWND* /*phwndParent*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPaneFlags)(
		/*[out]*/ DWORD* /*pdwPaneFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ClosePane)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(NotifyPane)(
		/*[in]*/ SPLITNOTIFYCODE /*iCode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DetachPane)()VSL_STDMETHOD_NOTIMPL
};

class IVsSplitPaneMockImpl :
	public IVsSplitPane,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSplitPaneMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSplitPaneMockImpl)

	typedef IVsSplitPane Interface;
	struct SetParentSplitterValidValues
	{
		/*[in]*/ IVsSplitter* pSplitter;
		HRESULT retValue;
	};

	STDMETHOD(SetParentSplitter)(
		/*[in]*/ IVsSplitter* pSplitter)
	{
		VSL_DEFINE_MOCK_METHOD(SetParentSplitter)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSplitter);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetParentSplitterValidValues
	{
		/*[out]*/ IVsSplitter** ppSplitter;
		HRESULT retValue;
	};

	STDMETHOD(GetParentSplitter)(
		/*[out]*/ IVsSplitter** ppSplitter)
	{
		VSL_DEFINE_MOCK_METHOD(GetParentSplitter)

		VSL_SET_VALIDVALUE_INTERFACE(ppSplitter);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetFocusValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(SetFocus)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(SetFocus)

		VSL_RETURN_VALIDVALUES();
	}
	struct SetPositionValidValues
	{
		/*[in]*/ long iLeft;
		/*[in]*/ long iTop;
		/*[in]*/ long iRight;
		/*[in]*/ long iBottom;
		HRESULT retValue;
	};

	STDMETHOD(SetPosition)(
		/*[in]*/ long iLeft,
		/*[in]*/ long iTop,
		/*[in]*/ long iRight,
		/*[in]*/ long iBottom)
	{
		VSL_DEFINE_MOCK_METHOD(SetPosition)

		VSL_CHECK_VALIDVALUE(iLeft);

		VSL_CHECK_VALIDVALUE(iTop);

		VSL_CHECK_VALIDVALUE(iRight);

		VSL_CHECK_VALIDVALUE(iBottom);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPositionValidValues
	{
		/*[out]*/ long* piLeft;
		/*[out]*/ long* piTop;
		/*[out]*/ long* piRight;
		/*[out]*/ long* piBottom;
		HRESULT retValue;
	};

	STDMETHOD(GetPosition)(
		/*[out]*/ long* piLeft,
		/*[out]*/ long* piTop,
		/*[out]*/ long* piRight,
		/*[out]*/ long* piBottom)
	{
		VSL_DEFINE_MOCK_METHOD(GetPosition)

		VSL_SET_VALIDVALUE(piLeft);

		VSL_SET_VALIDVALUE(piTop);

		VSL_SET_VALIDVALUE(piRight);

		VSL_SET_VALIDVALUE(piBottom);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSizeExtentsValidValues
	{
		/*[out]*/ long* piMinHorz;
		/*[out]*/ long* piMaxHorz;
		/*[out]*/ long* piMinVert;
		/*[out]*/ long* piMaxVert;
		HRESULT retValue;
	};

	STDMETHOD(GetSizeExtents)(
		/*[out]*/ long* piMinHorz,
		/*[out]*/ long* piMaxHorz,
		/*[out]*/ long* piMinVert,
		/*[out]*/ long* piMaxVert)
	{
		VSL_DEFINE_MOCK_METHOD(GetSizeExtents)

		VSL_SET_VALIDVALUE(piMinHorz);

		VSL_SET_VALIDVALUE(piMaxHorz);

		VSL_SET_VALIDVALUE(piMinVert);

		VSL_SET_VALIDVALUE(piMaxVert);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetParentWindowValidValues
	{
		/*[out]*/ HWND* phwndParent;
		HRESULT retValue;
	};

	STDMETHOD(GetParentWindow)(
		/*[out]*/ HWND* phwndParent)
	{
		VSL_DEFINE_MOCK_METHOD(GetParentWindow)

		VSL_SET_VALIDVALUE(phwndParent);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPaneFlagsValidValues
	{
		/*[out]*/ DWORD* pdwPaneFlags;
		HRESULT retValue;
	};

	STDMETHOD(GetPaneFlags)(
		/*[out]*/ DWORD* pdwPaneFlags)
	{
		VSL_DEFINE_MOCK_METHOD(GetPaneFlags)

		VSL_SET_VALIDVALUE(pdwPaneFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct ClosePaneValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(ClosePane)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(ClosePane)

		VSL_RETURN_VALIDVALUES();
	}
	struct NotifyPaneValidValues
	{
		/*[in]*/ SPLITNOTIFYCODE iCode;
		HRESULT retValue;
	};

	STDMETHOD(NotifyPane)(
		/*[in]*/ SPLITNOTIFYCODE iCode)
	{
		VSL_DEFINE_MOCK_METHOD(NotifyPane)

		VSL_CHECK_VALIDVALUE(iCode);

		VSL_RETURN_VALIDVALUES();
	}
	struct DetachPaneValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(DetachPane)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(DetachPane)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSPLITPANE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSolutionSecurityOptions.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSOLUTIONSECURITYOPTIONS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSOLUTIONSECURITYOPTIONS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSolutionSecurityOptionsNotImpl :
	public IVsSolutionSecurityOptions
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSolutionSecurityOptionsNotImpl)

public:

	typedef IVsSolutionSecurityOptions Interface;

	STDMETHOD(get_SignCabinets)(
		/*[out]*/ BOOL* /*pfSignCabinets*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_UseTestCertificate)(
		/*[out]*/ BOOL* /*pfUseTestCertificate*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_UseCertificateFile)(
		/*[out]*/ BOOL* /*pfUseCertificateFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CertificateFile)(
		/*[out]*/ BSTR* /*pbstrCertificateFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_PrivateKeyFile)(
		/*[out]*/ BSTR* /*pbstrPrivateKeyFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_TimestampServerURL)(
		/*[out]*/ BSTR* /*pbstrTimestampServerURL*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSolutionSecurityOptionsMockImpl :
	public IVsSolutionSecurityOptions,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSolutionSecurityOptionsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSolutionSecurityOptionsMockImpl)

	typedef IVsSolutionSecurityOptions Interface;
	struct get_SignCabinetsValidValues
	{
		/*[out]*/ BOOL* pfSignCabinets;
		HRESULT retValue;
	};

	STDMETHOD(get_SignCabinets)(
		/*[out]*/ BOOL* pfSignCabinets)
	{
		VSL_DEFINE_MOCK_METHOD(get_SignCabinets)

		VSL_SET_VALIDVALUE(pfSignCabinets);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_UseTestCertificateValidValues
	{
		/*[out]*/ BOOL* pfUseTestCertificate;
		HRESULT retValue;
	};

	STDMETHOD(get_UseTestCertificate)(
		/*[out]*/ BOOL* pfUseTestCertificate)
	{
		VSL_DEFINE_MOCK_METHOD(get_UseTestCertificate)

		VSL_SET_VALIDVALUE(pfUseTestCertificate);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_UseCertificateFileValidValues
	{
		/*[out]*/ BOOL* pfUseCertificateFile;
		HRESULT retValue;
	};

	STDMETHOD(get_UseCertificateFile)(
		/*[out]*/ BOOL* pfUseCertificateFile)
	{
		VSL_DEFINE_MOCK_METHOD(get_UseCertificateFile)

		VSL_SET_VALIDVALUE(pfUseCertificateFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CertificateFileValidValues
	{
		/*[out]*/ BSTR* pbstrCertificateFile;
		HRESULT retValue;
	};

	STDMETHOD(get_CertificateFile)(
		/*[out]*/ BSTR* pbstrCertificateFile)
	{
		VSL_DEFINE_MOCK_METHOD(get_CertificateFile)

		VSL_SET_VALIDVALUE_BSTR(pbstrCertificateFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_PrivateKeyFileValidValues
	{
		/*[out]*/ BSTR* pbstrPrivateKeyFile;
		HRESULT retValue;
	};

	STDMETHOD(get_PrivateKeyFile)(
		/*[out]*/ BSTR* pbstrPrivateKeyFile)
	{
		VSL_DEFINE_MOCK_METHOD(get_PrivateKeyFile)

		VSL_SET_VALIDVALUE_BSTR(pbstrPrivateKeyFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_TimestampServerURLValidValues
	{
		/*[out]*/ BSTR* pbstrTimestampServerURL;
		HRESULT retValue;
	};

	STDMETHOD(get_TimestampServerURL)(
		/*[out]*/ BSTR* pbstrTimestampServerURL)
	{
		VSL_DEFINE_MOCK_METHOD(get_TimestampServerURL)

		VSL_SET_VALIDVALUE_BSTR(pbstrTimestampServerURL);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSOLUTIONSECURITYOPTIONS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSQLCLRReferences.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSQLCLRREFERENCES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSQLCLRREFERENCES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "compsvcspkg80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSQLCLRReferencesNotImpl :
	public IVsSQLCLRReferences
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSQLCLRReferencesNotImpl)

public:

	typedef IVsSQLCLRReferences Interface;

	STDMETHOD(InvokeNewReferencesDlg)(
		/*[in]*/ IUnknown* /*pConnection*/,
		/*[in]*/ IUnknown* /*pAssemblySupport*/,
		/*[in]*/ SqlAddNewReferenceFlags /*dwAddNewReferenceFlags*/,
		/*[in]*/ LPCWSTR /*szLocalCache*/,
		/*[in]*/ DWORD /*dwProjectPermisionLevel*/,
		/*[in]*/ IVsComponentUser* /*pComponentUserCallback*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UpdateReferences)(
		/*[in]*/ IUnknown* /*pConnection*/,
		/*[in]*/ IUnknown* /*pAssemblySupport*/,
		/*[in]*/ SqlReferenceUpdateFlags /*dwReferenceUpdateFlags*/,
		/*[in]*/ ULONG /*cAssemblyCount*/,
		/*[in,size_is(cAssemblyCount)]*/ LPCWSTR[] /*rgszAssemblies*/,
		/*[in]*/ LPCWSTR /*szLocalCache*/,
		/*[in]*/ DWORD /*dwProjectPermisionLevel*/,
		/*[in]*/ IVsSQLCLRReferencesUpdateCallback* /*pCallBack*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSQLCLRReferencesMockImpl :
	public IVsSQLCLRReferences,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSQLCLRReferencesMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSQLCLRReferencesMockImpl)

	typedef IVsSQLCLRReferences Interface;
	struct InvokeNewReferencesDlgValidValues
	{
		/*[in]*/ IUnknown* pConnection;
		/*[in]*/ IUnknown* pAssemblySupport;
		/*[in]*/ SqlAddNewReferenceFlags dwAddNewReferenceFlags;
		/*[in]*/ LPCWSTR szLocalCache;
		/*[in]*/ DWORD dwProjectPermisionLevel;
		/*[in]*/ IVsComponentUser* pComponentUserCallback;
		HRESULT retValue;
	};

	STDMETHOD(InvokeNewReferencesDlg)(
		/*[in]*/ IUnknown* pConnection,
		/*[in]*/ IUnknown* pAssemblySupport,
		/*[in]*/ SqlAddNewReferenceFlags dwAddNewReferenceFlags,
		/*[in]*/ LPCWSTR szLocalCache,
		/*[in]*/ DWORD dwProjectPermisionLevel,
		/*[in]*/ IVsComponentUser* pComponentUserCallback)
	{
		VSL_DEFINE_MOCK_METHOD(InvokeNewReferencesDlg)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pConnection);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pAssemblySupport);

		VSL_CHECK_VALIDVALUE(dwAddNewReferenceFlags);

		VSL_CHECK_VALIDVALUE_STRINGW(szLocalCache);

		VSL_CHECK_VALIDVALUE(dwProjectPermisionLevel);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pComponentUserCallback);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateReferencesValidValues
	{
		/*[in]*/ IUnknown* pConnection;
		/*[in]*/ IUnknown* pAssemblySupport;
		/*[in]*/ SqlReferenceUpdateFlags dwReferenceUpdateFlags;
		/*[in]*/ ULONG cAssemblyCount;
		/*[in,size_is(cAssemblyCount)]*/ LPCWSTR* rgszAssemblies;
		/*[in]*/ LPCWSTR szLocalCache;
		/*[in]*/ DWORD dwProjectPermisionLevel;
		/*[in]*/ IVsSQLCLRReferencesUpdateCallback* pCallBack;
		HRESULT retValue;
	};

	STDMETHOD(UpdateReferences)(
		/*[in]*/ IUnknown* pConnection,
		/*[in]*/ IUnknown* pAssemblySupport,
		/*[in]*/ SqlReferenceUpdateFlags dwReferenceUpdateFlags,
		/*[in]*/ ULONG cAssemblyCount,
		/*[in,size_is(cAssemblyCount)]*/ LPCWSTR rgszAssemblies[],
		/*[in]*/ LPCWSTR szLocalCache,
		/*[in]*/ DWORD dwProjectPermisionLevel,
		/*[in]*/ IVsSQLCLRReferencesUpdateCallback* pCallBack)
	{
		VSL_DEFINE_MOCK_METHOD(UpdateReferences)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pConnection);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pAssemblySupport);

		VSL_CHECK_VALIDVALUE(dwReferenceUpdateFlags);

		VSL_CHECK_VALIDVALUE(cAssemblyCount);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszAssemblies, cAssemblyCount*sizeof(rgszAssemblies[0]), validValues.cAssemblyCount*sizeof(validValues.rgszAssemblies[0]));

		VSL_CHECK_VALIDVALUE_STRINGW(szLocalCache);

		VSL_CHECK_VALIDVALUE(dwProjectPermisionLevel);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCallBack);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSQLCLRREFERENCES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSplitter.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSPLITTER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSPLITTER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSplitterNotImpl :
	public IVsSplitter
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSplitterNotImpl)

public:

	typedef IVsSplitter Interface;

	STDMETHOD(GetPane)(
		/*[in]*/ long /*iIndex*/,
		/*[out]*/ IVsSplitPane** /*ppPane*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(NotifySplitter)(
		/*[in]*/ IVsSplitPane* /*pPane*/,
		/*[in]*/ PANEEVENTS /*iEvent*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsPanePrimary)(
		/*[in]*/ IVsSplitPane* /*pPane*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(HandleMessage)(
		/*[in]*/ UINT /*iMsg*/,
		/*[in]*/ WPARAM /*wParam*/,
		/*[in]*/ LPARAM /*lParam*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SplitPane)(
		/*[in]*/ IVsSplitPane* /*pNewPane*/,
		/*[in]*/ long /*iIndex*/,
		/*[in]*/ long /*iSize*/,
		/*[in]*/ DWORD /*dwFlags*/,
		/*[out]*/ IVsSplitter** /*ppSplitter*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetParentSplitter)(
		/*[in]*/ IVsSplitter* /*pSplitter*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetParentSplitter)(
		/*[out]*/ IVsSplitter** /*ppSplitter*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetFocus)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetPosition)(
		/*[in]*/ long /*iLeft*/,
		/*[in]*/ long /*iTop*/,
		/*[in]*/ long /*iRight*/,
		/*[in]*/ long /*iBottom*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPosition)(
		/*[out]*/ long* /*piLeft*/,
		/*[out]*/ long* /*piTop*/,
		/*[out]*/ long* /*piRight*/,
		/*[out]*/ long* /*piBottom*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSizeExtents)(
		/*[out]*/ long* /*piMinHorz*/,
		/*[out]*/ long* /*piMaxHorz*/,
		/*[out]*/ long* /*piMinVert*/,
		/*[out]*/ long* /*piMaxVert*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetParentWindow)(
		/*[out]*/ HWND* /*phwndParent*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPaneFlags)(
		/*[out]*/ DWORD* /*pdwPaneFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ClosePane)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(NotifyPane)(
		/*[in]*/ SPLITNOTIFYCODE /*iCode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DetachPane)()VSL_STDMETHOD_NOTIMPL
};

class IVsSplitterMockImpl :
	public IVsSplitter,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSplitterMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSplitterMockImpl)

	typedef IVsSplitter Interface;
	struct GetPaneValidValues
	{
		/*[in]*/ long iIndex;
		/*[out]*/ IVsSplitPane** ppPane;
		HRESULT retValue;
	};

	STDMETHOD(GetPane)(
		/*[in]*/ long iIndex,
		/*[out]*/ IVsSplitPane** ppPane)
	{
		VSL_DEFINE_MOCK_METHOD(GetPane)

		VSL_CHECK_VALIDVALUE(iIndex);

		VSL_SET_VALIDVALUE_INTERFACE(ppPane);

		VSL_RETURN_VALIDVALUES();
	}
	struct NotifySplitterValidValues
	{
		/*[in]*/ IVsSplitPane* pPane;
		/*[in]*/ PANEEVENTS iEvent;
		HRESULT retValue;
	};

	STDMETHOD(NotifySplitter)(
		/*[in]*/ IVsSplitPane* pPane,
		/*[in]*/ PANEEVENTS iEvent)
	{
		VSL_DEFINE_MOCK_METHOD(NotifySplitter)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pPane);

		VSL_CHECK_VALIDVALUE(iEvent);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsPanePrimaryValidValues
	{
		/*[in]*/ IVsSplitPane* pPane;
		HRESULT retValue;
	};

	STDMETHOD(IsPanePrimary)(
		/*[in]*/ IVsSplitPane* pPane)
	{
		VSL_DEFINE_MOCK_METHOD(IsPanePrimary)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pPane);

		VSL_RETURN_VALIDVALUES();
	}
	struct HandleMessageValidValues
	{
		/*[in]*/ UINT iMsg;
		/*[in]*/ WPARAM wParam;
		/*[in]*/ LPARAM lParam;
		HRESULT retValue;
	};

	STDMETHOD(HandleMessage)(
		/*[in]*/ UINT iMsg,
		/*[in]*/ WPARAM wParam,
		/*[in]*/ LPARAM lParam)
	{
		VSL_DEFINE_MOCK_METHOD(HandleMessage)

		VSL_CHECK_VALIDVALUE(iMsg);

		VSL_CHECK_VALIDVALUE(wParam);

		VSL_CHECK_VALIDVALUE(lParam);

		VSL_RETURN_VALIDVALUES();
	}
	struct SplitPaneValidValues
	{
		/*[in]*/ IVsSplitPane* pNewPane;
		/*[in]*/ long iIndex;
		/*[in]*/ long iSize;
		/*[in]*/ DWORD dwFlags;
		/*[out]*/ IVsSplitter** ppSplitter;
		HRESULT retValue;
	};

	STDMETHOD(SplitPane)(
		/*[in]*/ IVsSplitPane* pNewPane,
		/*[in]*/ long iIndex,
		/*[in]*/ long iSize,
		/*[in]*/ DWORD dwFlags,
		/*[out]*/ IVsSplitter** ppSplitter)
	{
		VSL_DEFINE_MOCK_METHOD(SplitPane)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pNewPane);

		VSL_CHECK_VALIDVALUE(iIndex);

		VSL_CHECK_VALIDVALUE(iSize);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_SET_VALIDVALUE_INTERFACE(ppSplitter);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetParentSplitterValidValues
	{
		/*[in]*/ IVsSplitter* pSplitter;
		HRESULT retValue;
	};

	STDMETHOD(SetParentSplitter)(
		/*[in]*/ IVsSplitter* pSplitter)
	{
		VSL_DEFINE_MOCK_METHOD(SetParentSplitter)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSplitter);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetParentSplitterValidValues
	{
		/*[out]*/ IVsSplitter** ppSplitter;
		HRESULT retValue;
	};

	STDMETHOD(GetParentSplitter)(
		/*[out]*/ IVsSplitter** ppSplitter)
	{
		VSL_DEFINE_MOCK_METHOD(GetParentSplitter)

		VSL_SET_VALIDVALUE_INTERFACE(ppSplitter);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetFocusValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(SetFocus)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(SetFocus)

		VSL_RETURN_VALIDVALUES();
	}
	struct SetPositionValidValues
	{
		/*[in]*/ long iLeft;
		/*[in]*/ long iTop;
		/*[in]*/ long iRight;
		/*[in]*/ long iBottom;
		HRESULT retValue;
	};

	STDMETHOD(SetPosition)(
		/*[in]*/ long iLeft,
		/*[in]*/ long iTop,
		/*[in]*/ long iRight,
		/*[in]*/ long iBottom)
	{
		VSL_DEFINE_MOCK_METHOD(SetPosition)

		VSL_CHECK_VALIDVALUE(iLeft);

		VSL_CHECK_VALIDVALUE(iTop);

		VSL_CHECK_VALIDVALUE(iRight);

		VSL_CHECK_VALIDVALUE(iBottom);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPositionValidValues
	{
		/*[out]*/ long* piLeft;
		/*[out]*/ long* piTop;
		/*[out]*/ long* piRight;
		/*[out]*/ long* piBottom;
		HRESULT retValue;
	};

	STDMETHOD(GetPosition)(
		/*[out]*/ long* piLeft,
		/*[out]*/ long* piTop,
		/*[out]*/ long* piRight,
		/*[out]*/ long* piBottom)
	{
		VSL_DEFINE_MOCK_METHOD(GetPosition)

		VSL_SET_VALIDVALUE(piLeft);

		VSL_SET_VALIDVALUE(piTop);

		VSL_SET_VALIDVALUE(piRight);

		VSL_SET_VALIDVALUE(piBottom);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSizeExtentsValidValues
	{
		/*[out]*/ long* piMinHorz;
		/*[out]*/ long* piMaxHorz;
		/*[out]*/ long* piMinVert;
		/*[out]*/ long* piMaxVert;
		HRESULT retValue;
	};

	STDMETHOD(GetSizeExtents)(
		/*[out]*/ long* piMinHorz,
		/*[out]*/ long* piMaxHorz,
		/*[out]*/ long* piMinVert,
		/*[out]*/ long* piMaxVert)
	{
		VSL_DEFINE_MOCK_METHOD(GetSizeExtents)

		VSL_SET_VALIDVALUE(piMinHorz);

		VSL_SET_VALIDVALUE(piMaxHorz);

		VSL_SET_VALIDVALUE(piMinVert);

		VSL_SET_VALIDVALUE(piMaxVert);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetParentWindowValidValues
	{
		/*[out]*/ HWND* phwndParent;
		HRESULT retValue;
	};

	STDMETHOD(GetParentWindow)(
		/*[out]*/ HWND* phwndParent)
	{
		VSL_DEFINE_MOCK_METHOD(GetParentWindow)

		VSL_SET_VALIDVALUE(phwndParent);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPaneFlagsValidValues
	{
		/*[out]*/ DWORD* pdwPaneFlags;
		HRESULT retValue;
	};

	STDMETHOD(GetPaneFlags)(
		/*[out]*/ DWORD* pdwPaneFlags)
	{
		VSL_DEFINE_MOCK_METHOD(GetPaneFlags)

		VSL_SET_VALIDVALUE(pdwPaneFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct ClosePaneValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(ClosePane)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(ClosePane)

		VSL_RETURN_VALIDVALUES();
	}
	struct NotifyPaneValidValues
	{
		/*[in]*/ SPLITNOTIFYCODE iCode;
		HRESULT retValue;
	};

	STDMETHOD(NotifyPane)(
		/*[in]*/ SPLITNOTIFYCODE iCode)
	{
		VSL_DEFINE_MOCK_METHOD(NotifyPane)

		VSL_CHECK_VALIDVALUE(iCode);

		VSL_RETURN_VALIDVALUES();
	}
	struct DetachPaneValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(DetachPane)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(DetachPane)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSPLITTER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSQLCLRReferencesUpdateCallback.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSQLCLRREFERENCESUPDATECALLBACK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSQLCLRREFERENCESUPDATECALLBACK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "compsvcspkg80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSQLCLRReferencesUpdateCallbackNotImpl :
	public IVsSQLCLRReferencesUpdateCallback
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSQLCLRReferencesUpdateCallbackNotImpl)

public:

	typedef IVsSQLCLRReferencesUpdateCallback Interface;

	STDMETHOD(UpdateResult)(
		/*[in]*/ LPCWSTR /*szAssembly*/,
		/*[in]*/ DWORD /*dwPermisionLevel*/,
		/*[in]*/ HRESULT /*hrUpdateResult*/,
		/*[in]*/ IErrorInfo* /*pErrorInfo*/,
		/*[in]*/ SqlReferenceUpdateAction /*updateAction*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSQLCLRReferencesUpdateCallbackMockImpl :
	public IVsSQLCLRReferencesUpdateCallback,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSQLCLRReferencesUpdateCallbackMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSQLCLRReferencesUpdateCallbackMockImpl)

	typedef IVsSQLCLRReferencesUpdateCallback Interface;
	struct UpdateResultValidValues
	{
		/*[in]*/ LPCWSTR szAssembly;
		/*[in]*/ DWORD dwPermisionLevel;
		/*[in]*/ HRESULT hrUpdateResult;
		/*[in]*/ IErrorInfo* pErrorInfo;
		/*[in]*/ SqlReferenceUpdateAction updateAction;
		HRESULT retValue;
	};

	STDMETHOD(UpdateResult)(
		/*[in]*/ LPCWSTR szAssembly,
		/*[in]*/ DWORD dwPermisionLevel,
		/*[in]*/ HRESULT hrUpdateResult,
		/*[in]*/ IErrorInfo* pErrorInfo,
		/*[in]*/ SqlReferenceUpdateAction updateAction)
	{
		VSL_DEFINE_MOCK_METHOD(UpdateResult)

		VSL_CHECK_VALIDVALUE_STRINGW(szAssembly);

		VSL_CHECK_VALIDVALUE(dwPermisionLevel);

		VSL_CHECK_VALIDVALUE(hrUpdateResult);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pErrorInfo);

		VSL_CHECK_VALIDVALUE(updateAction);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSQLCLRREFERENCESUPDATECALLBACK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsStatusbarUser.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSTATUSBARUSER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSTATUSBARUSER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsStatusbarUserNotImpl :
	public IVsStatusbarUser
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsStatusbarUserNotImpl)

public:

	typedef IVsStatusbarUser Interface;

	STDMETHOD(SetInfo)()VSL_STDMETHOD_NOTIMPL
};

class IVsStatusbarUserMockImpl :
	public IVsStatusbarUser,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsStatusbarUserMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsStatusbarUserMockImpl)

	typedef IVsStatusbarUser Interface;
	struct SetInfoValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(SetInfo)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(SetInfo)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSTATUSBARUSER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsStatusbar.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSTATUSBAR_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSTATUSBAR_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsStatusbarNotImpl :
	public IVsStatusbar
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsStatusbarNotImpl)

public:

	typedef IVsStatusbar Interface;

	STDMETHOD(Clear)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetText)(
		/*[in]*/ LPCOLESTR /*pszText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Progress)(
		/*[in,out]*/ VSCOOKIE* /*pdwCookie*/,
		/*[in]*/ BOOL /*fInProgress*/,
		/*[in]*/ LPCOLESTR /*pwszLabel*/,
		/*[in]*/ ULONG /*nComplete*/,
		/*[in]*/ ULONG /*nTotal*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Animation)(
		/*[in]*/ BOOL /*fOnOff*/,
		/*[in]*/ VARIANT* /*pvIcon*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetSelMode)(
		/*[in]*/ VARIANT* /*pvSelMode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetInsMode)(
		/*[in]*/ VARIANT* /*pvInsMode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetLineChar)(
		/*[in]*/ VARIANT* /*pvLine*/,
		/*[in]*/ VARIANT* /*pvChar*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetXYWH)(
		/*[in]*/ VARIANT* /*pvX*/,
		/*[in]*/ VARIANT* /*pvY*/,
		/*[in]*/ VARIANT* /*pvW*/,
		/*[in]*/ VARIANT* /*pvH*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetLineColChar)(
		/*[in]*/ VARIANT* /*pvLine*/,
		/*[in]*/ VARIANT* /*pvCol*/,
		/*[in]*/ VARIANT* /*pvChar*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsCurrentUser)(
		/*[in]*/ IVsStatusbarUser* /*pUser*/,
		/*[in]*/ BOOL* /*pfCurrent*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetColorText)(
		/*[in]*/ LPCOLESTR /*pszText*/,
		/*[in]*/ COLORREF /*crForeColor*/,
		/*[in]*/ COLORREF /*crBackColor*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetText)(
		/*[out]*/ BSTR* /*pszText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FreezeOutput)(
		/*[in]*/ BOOL /*fFreeze*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsFrozen)(
		/*[out]*/ BOOL* /*pfFrozen*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetFreezeCount)(
		/*[out]*/ long* /*plCount*/)VSL_STDMETHOD_NOTIMPL
};

class IVsStatusbarMockImpl :
	public IVsStatusbar,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsStatusbarMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsStatusbarMockImpl)

	typedef IVsStatusbar Interface;
	struct ClearValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Clear)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Clear)

		VSL_RETURN_VALIDVALUES();
	}
	struct SetTextValidValues
	{
		/*[in]*/ LPCOLESTR pszText;
		HRESULT retValue;
	};

	STDMETHOD(SetText)(
		/*[in]*/ LPCOLESTR pszText)
	{
		VSL_DEFINE_MOCK_METHOD(SetText)

		VSL_CHECK_VALIDVALUE_STRINGW(pszText);

		VSL_RETURN_VALIDVALUES();
	}
	struct ProgressValidValues
	{
		/*[in,out]*/ VSCOOKIE* pdwCookie;
		/*[in]*/ BOOL fInProgress;
		/*[in]*/ LPCOLESTR pwszLabel;
		/*[in]*/ ULONG nComplete;
		/*[in]*/ ULONG nTotal;
		HRESULT retValue;
	};

	STDMETHOD(Progress)(
		/*[in,out]*/ VSCOOKIE* pdwCookie,
		/*[in]*/ BOOL fInProgress,
		/*[in]*/ LPCOLESTR pwszLabel,
		/*[in]*/ ULONG nComplete,
		/*[in]*/ ULONG nTotal)
	{
		VSL_DEFINE_MOCK_METHOD(Progress)

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_CHECK_VALIDVALUE(fInProgress);

		VSL_CHECK_VALIDVALUE_STRINGW(pwszLabel);

		VSL_CHECK_VALIDVALUE(nComplete);

		VSL_CHECK_VALIDVALUE(nTotal);

		VSL_RETURN_VALIDVALUES();
	}
	struct AnimationValidValues
	{
		/*[in]*/ BOOL fOnOff;
		/*[in]*/ VARIANT* pvIcon;
		HRESULT retValue;
	};

	STDMETHOD(Animation)(
		/*[in]*/ BOOL fOnOff,
		/*[in]*/ VARIANT* pvIcon)
	{
		VSL_DEFINE_MOCK_METHOD(Animation)

		VSL_CHECK_VALIDVALUE(fOnOff);

		VSL_CHECK_VALIDVALUE_POINTER(pvIcon);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetSelModeValidValues
	{
		/*[in]*/ VARIANT* pvSelMode;
		HRESULT retValue;
	};

	STDMETHOD(SetSelMode)(
		/*[in]*/ VARIANT* pvSelMode)
	{
		VSL_DEFINE_MOCK_METHOD(SetSelMode)

		VSL_CHECK_VALIDVALUE_POINTER(pvSelMode);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetInsModeValidValues
	{
		/*[in]*/ VARIANT* pvInsMode;
		HRESULT retValue;
	};

	STDMETHOD(SetInsMode)(
		/*[in]*/ VARIANT* pvInsMode)
	{
		VSL_DEFINE_MOCK_METHOD(SetInsMode)

		VSL_CHECK_VALIDVALUE_POINTER(pvInsMode);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetLineCharValidValues
	{
		/*[in]*/ VARIANT* pvLine;
		/*[in]*/ VARIANT* pvChar;
		HRESULT retValue;
	};

	STDMETHOD(SetLineChar)(
		/*[in]*/ VARIANT* pvLine,
		/*[in]*/ VARIANT* pvChar)
	{
		VSL_DEFINE_MOCK_METHOD(SetLineChar)

		VSL_CHECK_VALIDVALUE_POINTER(pvLine);

		VSL_CHECK_VALIDVALUE_POINTER(pvChar);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetXYWHValidValues
	{
		/*[in]*/ VARIANT* pvX;
		/*[in]*/ VARIANT* pvY;
		/*[in]*/ VARIANT* pvW;
		/*[in]*/ VARIANT* pvH;
		HRESULT retValue;
	};

	STDMETHOD(SetXYWH)(
		/*[in]*/ VARIANT* pvX,
		/*[in]*/ VARIANT* pvY,
		/*[in]*/ VARIANT* pvW,
		/*[in]*/ VARIANT* pvH)
	{
		VSL_DEFINE_MOCK_METHOD(SetXYWH)

		VSL_CHECK_VALIDVALUE_POINTER(pvX);

		VSL_CHECK_VALIDVALUE_POINTER(pvY);

		VSL_CHECK_VALIDVALUE_POINTER(pvW);

		VSL_CHECK_VALIDVALUE_POINTER(pvH);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetLineColCharValidValues
	{
		/*[in]*/ VARIANT* pvLine;
		/*[in]*/ VARIANT* pvCol;
		/*[in]*/ VARIANT* pvChar;
		HRESULT retValue;
	};

	STDMETHOD(SetLineColChar)(
		/*[in]*/ VARIANT* pvLine,
		/*[in]*/ VARIANT* pvCol,
		/*[in]*/ VARIANT* pvChar)
	{
		VSL_DEFINE_MOCK_METHOD(SetLineColChar)

		VSL_CHECK_VALIDVALUE_POINTER(pvLine);

		VSL_CHECK_VALIDVALUE_POINTER(pvCol);

		VSL_CHECK_VALIDVALUE_POINTER(pvChar);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsCurrentUserValidValues
	{
		/*[in]*/ IVsStatusbarUser* pUser;
		/*[in]*/ BOOL* pfCurrent;
		HRESULT retValue;
	};

	STDMETHOD(IsCurrentUser)(
		/*[in]*/ IVsStatusbarUser* pUser,
		/*[in]*/ BOOL* pfCurrent)
	{
		VSL_DEFINE_MOCK_METHOD(IsCurrentUser)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUser);

		VSL_CHECK_VALIDVALUE_POINTER(pfCurrent);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetColorTextValidValues
	{
		/*[in]*/ LPCOLESTR pszText;
		/*[in]*/ COLORREF crForeColor;
		/*[in]*/ COLORREF crBackColor;
		HRESULT retValue;
	};

	STDMETHOD(SetColorText)(
		/*[in]*/ LPCOLESTR pszText,
		/*[in]*/ COLORREF crForeColor,
		/*[in]*/ COLORREF crBackColor)
	{
		VSL_DEFINE_MOCK_METHOD(SetColorText)

		VSL_CHECK_VALIDVALUE_STRINGW(pszText);

		VSL_CHECK_VALIDVALUE(crForeColor);

		VSL_CHECK_VALIDVALUE(crBackColor);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTextValidValues
	{
		/*[out]*/ BSTR* pszText;
		HRESULT retValue;
	};

	STDMETHOD(GetText)(
		/*[out]*/ BSTR* pszText)
	{
		VSL_DEFINE_MOCK_METHOD(GetText)

		VSL_SET_VALIDVALUE_BSTR(pszText);

		VSL_RETURN_VALIDVALUES();
	}
	struct FreezeOutputValidValues
	{
		/*[in]*/ BOOL fFreeze;
		HRESULT retValue;
	};

	STDMETHOD(FreezeOutput)(
		/*[in]*/ BOOL fFreeze)
	{
		VSL_DEFINE_MOCK_METHOD(FreezeOutput)

		VSL_CHECK_VALIDVALUE(fFreeze);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsFrozenValidValues
	{
		/*[out]*/ BOOL* pfFrozen;
		HRESULT retValue;
	};

	STDMETHOD(IsFrozen)(
		/*[out]*/ BOOL* pfFrozen)
	{
		VSL_DEFINE_MOCK_METHOD(IsFrozen)

		VSL_SET_VALIDVALUE(pfFrozen);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetFreezeCountValidValues
	{
		/*[out]*/ long* plCount;
		HRESULT retValue;
	};

	STDMETHOD(GetFreezeCount)(
		/*[out]*/ long* plCount)
	{
		VSL_DEFINE_MOCK_METHOD(GetFreezeCount)

		VSL_SET_VALIDVALUE(plCount);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSTATUSBAR_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsStrongNameKeys.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSTRONGNAMEKEYS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSTRONGNAMEKEYS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "compsvcspkg80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsStrongNameKeysNotImpl :
	public IVsStrongNameKeys
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsStrongNameKeysNotImpl)

public:

	typedef IVsStrongNameKeys Interface;

	STDMETHOD(EnumProviders)(
		/*[out]*/ IVsEnumCryptoProviders** /*ppEnumProviders*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumContainers)(
		/*[in]*/ LPCOLESTR /*szProvider*/,
		/*[out]*/ IVsEnumCryptoProviderContainers** /*ppEnumContainers*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateNewKey)(
		/*[in]*/ LPCOLESTR /*szFileLocation*/,
		/*[out]*/ BSTR* /*pbstrFileName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateNewKeyNoUI)(
		/*[in]*/ LPCOLESTR /*szFile*/,
		/*[in]*/ LPCOLESTR /*szPassword*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateNewKeyWithName)(
		/*[in]*/ LPCOLESTR /*szFile*/,
		/*[in]*/ LPCOLESTR /*szPassword*/,
		/*[in]*/ LPCOLESTR /*szSubjectName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ImportKeyFromPFX)(
		/*[in]*/ LPCOLESTR /*szFile*/,
		/*[out]*/ BSTR* /*pbstrContainerName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ChangePassword)(
		/*[in]*/ LPCOLESTR /*szPfxFile*/,
		/*[in]*/ LPCOLESTR /*szOldPassword*/,
		/*[in]*/ LPCOLESTR /*szNewPassword*/)VSL_STDMETHOD_NOTIMPL
};

class IVsStrongNameKeysMockImpl :
	public IVsStrongNameKeys,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsStrongNameKeysMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsStrongNameKeysMockImpl)

	typedef IVsStrongNameKeys Interface;
	struct EnumProvidersValidValues
	{
		/*[out]*/ IVsEnumCryptoProviders** ppEnumProviders;
		HRESULT retValue;
	};

	STDMETHOD(EnumProviders)(
		/*[out]*/ IVsEnumCryptoProviders** ppEnumProviders)
	{
		VSL_DEFINE_MOCK_METHOD(EnumProviders)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnumProviders);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumContainersValidValues
	{
		/*[in]*/ LPCOLESTR szProvider;
		/*[out]*/ IVsEnumCryptoProviderContainers** ppEnumContainers;
		HRESULT retValue;
	};

	STDMETHOD(EnumContainers)(
		/*[in]*/ LPCOLESTR szProvider,
		/*[out]*/ IVsEnumCryptoProviderContainers** ppEnumContainers)
	{
		VSL_DEFINE_MOCK_METHOD(EnumContainers)

		VSL_CHECK_VALIDVALUE_STRINGW(szProvider);

		VSL_SET_VALIDVALUE_INTERFACE(ppEnumContainers);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateNewKeyValidValues
	{
		/*[in]*/ LPCOLESTR szFileLocation;
		/*[out]*/ BSTR* pbstrFileName;
		HRESULT retValue;
	};

	STDMETHOD(CreateNewKey)(
		/*[in]*/ LPCOLESTR szFileLocation,
		/*[out]*/ BSTR* pbstrFileName)
	{
		VSL_DEFINE_MOCK_METHOD(CreateNewKey)

		VSL_CHECK_VALIDVALUE_STRINGW(szFileLocation);

		VSL_SET_VALIDVALUE_BSTR(pbstrFileName);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateNewKeyNoUIValidValues
	{
		/*[in]*/ LPCOLESTR szFile;
		/*[in]*/ LPCOLESTR szPassword;
		HRESULT retValue;
	};

	STDMETHOD(CreateNewKeyNoUI)(
		/*[in]*/ LPCOLESTR szFile,
		/*[in]*/ LPCOLESTR szPassword)
	{
		VSL_DEFINE_MOCK_METHOD(CreateNewKeyNoUI)

		VSL_CHECK_VALIDVALUE_STRINGW(szFile);

		VSL_CHECK_VALIDVALUE_STRINGW(szPassword);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateNewKeyWithNameValidValues
	{
		/*[in]*/ LPCOLESTR szFile;
		/*[in]*/ LPCOLESTR szPassword;
		/*[in]*/ LPCOLESTR szSubjectName;
		HRESULT retValue;
	};

	STDMETHOD(CreateNewKeyWithName)(
		/*[in]*/ LPCOLESTR szFile,
		/*[in]*/ LPCOLESTR szPassword,
		/*[in]*/ LPCOLESTR szSubjectName)
	{
		VSL_DEFINE_MOCK_METHOD(CreateNewKeyWithName)

		VSL_CHECK_VALIDVALUE_STRINGW(szFile);

		VSL_CHECK_VALIDVALUE_STRINGW(szPassword);

		VSL_CHECK_VALIDVALUE_STRINGW(szSubjectName);

		VSL_RETURN_VALIDVALUES();
	}
	struct ImportKeyFromPFXValidValues
	{
		/*[in]*/ LPCOLESTR szFile;
		/*[out]*/ BSTR* pbstrContainerName;
		HRESULT retValue;
	};

	STDMETHOD(ImportKeyFromPFX)(
		/*[in]*/ LPCOLESTR szFile,
		/*[out]*/ BSTR* pbstrContainerName)
	{
		VSL_DEFINE_MOCK_METHOD(ImportKeyFromPFX)

		VSL_CHECK_VALIDVALUE_STRINGW(szFile);

		VSL_SET_VALIDVALUE_BSTR(pbstrContainerName);

		VSL_RETURN_VALIDVALUES();
	}
	struct ChangePasswordValidValues
	{
		/*[in]*/ LPCOLESTR szPfxFile;
		/*[in]*/ LPCOLESTR szOldPassword;
		/*[in]*/ LPCOLESTR szNewPassword;
		HRESULT retValue;
	};

	STDMETHOD(ChangePassword)(
		/*[in]*/ LPCOLESTR szPfxFile,
		/*[in]*/ LPCOLESTR szOldPassword,
		/*[in]*/ LPCOLESTR szNewPassword)
	{
		VSL_DEFINE_MOCK_METHOD(ChangePassword)

		VSL_CHECK_VALIDVALUE_STRINGW(szPfxFile);

		VSL_CHECK_VALIDVALUE_STRINGW(szOldPassword);

		VSL_CHECK_VALIDVALUE_STRINGW(szNewPassword);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSTRONGNAMEKEYS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsStructuredFileIO.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSTRUCTUREDFILEIO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSTRUCTUREDFILEIO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsStructuredFileIONotImpl :
	public IVsStructuredFileIO
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsStructuredFileIONotImpl)

public:

	typedef IVsStructuredFileIO Interface;

	STDMETHOD(CreateNew)(
		/*[in]*/ LPCOLESTR /*szFileName*/,
		/*[in]*/ ULONG /*nFormatIndex*/,
		/*[in]*/ DWORD /*dwShareMode*/,
		/*[in]*/ DWORD /*dwCreationDisposition*/,
		/*[in]*/ DWORD /*dwFlagsAndAttributes*/,
		/*[in]*/ IVsStructuredFileIOHelper* /*pIVsStructuredFileIOHelper*/,
		/*[in]*/ LPCOLESTR /*szFormatVersion*/,
		/*[in]*/ LPCOLESTR /*szDescription*/,
		/*[out]*/ IVsPropertyFileOut** /*ppIVsPropertyFileOut*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OpenExisting)(
		/*[in]*/ LPCOLESTR /*szFileName*/,
		/*[in]*/ DWORD /*dwShareMode*/,
		/*[in]*/ DWORD /*dwCreationDisposition*/,
		/*[in]*/ DWORD /*dwFlagsAndAttributes*/,
		/*[in]*/ IVsStructuredFileIOHelper* /*pIVsStructuredFileIOHelper*/,
		/*[out]*/ ULONG* /*pnFormatIndex*/,
		/*[out]*/ IVsPropertyFileIn** /*ppIVsPropertyFileIn*/,
		/*[out,optional]*/ BSTR* /*pbstrFormatVersion*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetFormatList)(
		/*[in]*/ LPCOLESTR /*szEntityName*/,
		/*[in]*/ LPCOLESTR /*szFileTypes*/,
		/*[out]*/ LPOLESTR* /*ppszFormatList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetFormatInfo)(
		/*[in]*/ ULONG /*nFormatIndex*/,
		/*[out,optional]*/ UINT* /*puiCodePage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FindFormatIndex)(
		/*[in]*/ UINT /*uiCodePage*/,
		/*[out,optional]*/ ULONG* /*pnFormatIndex*/)VSL_STDMETHOD_NOTIMPL
};

class IVsStructuredFileIOMockImpl :
	public IVsStructuredFileIO,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsStructuredFileIOMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsStructuredFileIOMockImpl)

	typedef IVsStructuredFileIO Interface;
	struct CreateNewValidValues
	{
		/*[in]*/ LPCOLESTR szFileName;
		/*[in]*/ ULONG nFormatIndex;
		/*[in]*/ DWORD dwShareMode;
		/*[in]*/ DWORD dwCreationDisposition;
		/*[in]*/ DWORD dwFlagsAndAttributes;
		/*[in]*/ IVsStructuredFileIOHelper* pIVsStructuredFileIOHelper;
		/*[in]*/ LPCOLESTR szFormatVersion;
		/*[in]*/ LPCOLESTR szDescription;
		/*[out]*/ IVsPropertyFileOut** ppIVsPropertyFileOut;
		HRESULT retValue;
	};

	STDMETHOD(CreateNew)(
		/*[in]*/ LPCOLESTR szFileName,
		/*[in]*/ ULONG nFormatIndex,
		/*[in]*/ DWORD dwShareMode,
		/*[in]*/ DWORD dwCreationDisposition,
		/*[in]*/ DWORD dwFlagsAndAttributes,
		/*[in]*/ IVsStructuredFileIOHelper* pIVsStructuredFileIOHelper,
		/*[in]*/ LPCOLESTR szFormatVersion,
		/*[in]*/ LPCOLESTR szDescription,
		/*[out]*/ IVsPropertyFileOut** ppIVsPropertyFileOut)
	{
		VSL_DEFINE_MOCK_METHOD(CreateNew)

		VSL_CHECK_VALIDVALUE_STRINGW(szFileName);

		VSL_CHECK_VALIDVALUE(nFormatIndex);

		VSL_CHECK_VALIDVALUE(dwShareMode);

		VSL_CHECK_VALIDVALUE(dwCreationDisposition);

		VSL_CHECK_VALIDVALUE(dwFlagsAndAttributes);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIVsStructuredFileIOHelper);

		VSL_CHECK_VALIDVALUE_STRINGW(szFormatVersion);

		VSL_CHECK_VALIDVALUE_STRINGW(szDescription);

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsPropertyFileOut);

		VSL_RETURN_VALIDVALUES();
	}
	struct OpenExistingValidValues
	{
		/*[in]*/ LPCOLESTR szFileName;
		/*[in]*/ DWORD dwShareMode;
		/*[in]*/ DWORD dwCreationDisposition;
		/*[in]*/ DWORD dwFlagsAndAttributes;
		/*[in]*/ IVsStructuredFileIOHelper* pIVsStructuredFileIOHelper;
		/*[out]*/ ULONG* pnFormatIndex;
		/*[out]*/ IVsPropertyFileIn** ppIVsPropertyFileIn;
		/*[out,optional]*/ BSTR* pbstrFormatVersion;
		HRESULT retValue;
	};

	STDMETHOD(OpenExisting)(
		/*[in]*/ LPCOLESTR szFileName,
		/*[in]*/ DWORD dwShareMode,
		/*[in]*/ DWORD dwCreationDisposition,
		/*[in]*/ DWORD dwFlagsAndAttributes,
		/*[in]*/ IVsStructuredFileIOHelper* pIVsStructuredFileIOHelper,
		/*[out]*/ ULONG* pnFormatIndex,
		/*[out]*/ IVsPropertyFileIn** ppIVsPropertyFileIn,
		/*[out,optional]*/ BSTR* pbstrFormatVersion)
	{
		VSL_DEFINE_MOCK_METHOD(OpenExisting)

		VSL_CHECK_VALIDVALUE_STRINGW(szFileName);

		VSL_CHECK_VALIDVALUE(dwShareMode);

		VSL_CHECK_VALIDVALUE(dwCreationDisposition);

		VSL_CHECK_VALIDVALUE(dwFlagsAndAttributes);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIVsStructuredFileIOHelper);

		VSL_SET_VALIDVALUE(pnFormatIndex);

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsPropertyFileIn);

		VSL_SET_VALIDVALUE_BSTR(pbstrFormatVersion);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetFormatListValidValues
	{
		/*[in]*/ LPCOLESTR szEntityName;
		/*[in]*/ LPCOLESTR szFileTypes;
		/*[out]*/ LPOLESTR* ppszFormatList;
		HRESULT retValue;
	};

	STDMETHOD(GetFormatList)(
		/*[in]*/ LPCOLESTR szEntityName,
		/*[in]*/ LPCOLESTR szFileTypes,
		/*[out]*/ LPOLESTR* ppszFormatList)
	{
		VSL_DEFINE_MOCK_METHOD(GetFormatList)

		VSL_CHECK_VALIDVALUE_STRINGW(szEntityName);

		VSL_CHECK_VALIDVALUE_STRINGW(szFileTypes);

		VSL_SET_VALIDVALUE(ppszFormatList);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetFormatInfoValidValues
	{
		/*[in]*/ ULONG nFormatIndex;
		/*[out,optional]*/ UINT* puiCodePage;
		HRESULT retValue;
	};

	STDMETHOD(GetFormatInfo)(
		/*[in]*/ ULONG nFormatIndex,
		/*[out,optional]*/ UINT* puiCodePage)
	{
		VSL_DEFINE_MOCK_METHOD(GetFormatInfo)

		VSL_CHECK_VALIDVALUE(nFormatIndex);

		VSL_SET_VALIDVALUE(puiCodePage);

		VSL_RETURN_VALIDVALUES();
	}
	struct FindFormatIndexValidValues
	{
		/*[in]*/ UINT uiCodePage;
		/*[out,optional]*/ ULONG* pnFormatIndex;
		HRESULT retValue;
	};

	STDMETHOD(FindFormatIndex)(
		/*[in]*/ UINT uiCodePage,
		/*[out,optional]*/ ULONG* pnFormatIndex)
	{
		VSL_DEFINE_MOCK_METHOD(FindFormatIndex)

		VSL_CHECK_VALIDVALUE(uiCodePage);

		VSL_SET_VALIDVALUE(pnFormatIndex);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSTRUCTUREDFILEIO_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsStructuredFileIOHelper.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSTRUCTUREDFILEIOHELPER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSTRUCTUREDFILEIOHELPER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsStructuredFileIOHelperNotImpl :
	public IVsStructuredFileIOHelper
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsStructuredFileIOHelperNotImpl)

public:

	typedef IVsStructuredFileIOHelper Interface;

	STDMETHOD(LoadLocalizedString)(
		/*[in]*/ ULONG /*ulStringID*/,
		/*[in]*/ BSTR* /*pbstr*/)VSL_STDMETHOD_NOTIMPL
};

class IVsStructuredFileIOHelperMockImpl :
	public IVsStructuredFileIOHelper,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsStructuredFileIOHelperMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsStructuredFileIOHelperMockImpl)

	typedef IVsStructuredFileIOHelper Interface;
	struct LoadLocalizedStringValidValues
	{
		/*[in]*/ ULONG ulStringID;
		/*[in]*/ BSTR* pbstr;
		HRESULT retValue;
	};

	STDMETHOD(LoadLocalizedString)(
		/*[in]*/ ULONG ulStringID,
		/*[in]*/ BSTR* pbstr)
	{
		VSL_DEFINE_MOCK_METHOD(LoadLocalizedString)

		VSL_CHECK_VALIDVALUE(ulStringID);

		VSL_CHECK_VALIDVALUE_POINTER(pbstr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSTRUCTUREDFILEIOHELPER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsStartPageDownload.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSTARTPAGEDOWNLOAD_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSTARTPAGEDOWNLOAD_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsStartPageDownloadNotImpl :
	public IVsStartPageDownload
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsStartPageDownloadNotImpl)

public:

	typedef IVsStartPageDownload Interface;

	STDMETHOD(StartDownloadService)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(StopDownloadService)()VSL_STDMETHOD_NOTIMPL
};

class IVsStartPageDownloadMockImpl :
	public IVsStartPageDownload,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsStartPageDownloadMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsStartPageDownloadMockImpl)

	typedef IVsStartPageDownload Interface;
	struct StartDownloadServiceValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(StartDownloadService)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(StartDownloadService)

		VSL_RETURN_VALIDVALUES();
	}
	struct StopDownloadServiceValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(StopDownloadService)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(StopDownloadService)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSTARTPAGEDOWNLOAD_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSupportItemHandoff.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSUPPORTITEMHANDOFF_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSUPPORTITEMHANDOFF_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSupportItemHandoffNotImpl :
	public IVsSupportItemHandoff
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSupportItemHandoffNotImpl)

public:

	typedef IVsSupportItemHandoff Interface;

	STDMETHOD(HandoffItem)(
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ IVsProject3* /*pProjDest*/,
		/*[in]*/ LPCOLESTR /*pszMkDocumentOld*/,
		/*[in]*/ LPCOLESTR /*pszMkDocumentNew*/,
		/*[in]*/ IVsWindowFrame* /*punkWindowFrame*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSupportItemHandoffMockImpl :
	public IVsSupportItemHandoff,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSupportItemHandoffMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSupportItemHandoffMockImpl)

	typedef IVsSupportItemHandoff Interface;
	struct HandoffItemValidValues
	{
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ IVsProject3* pProjDest;
		/*[in]*/ LPCOLESTR pszMkDocumentOld;
		/*[in]*/ LPCOLESTR pszMkDocumentNew;
		/*[in]*/ IVsWindowFrame* punkWindowFrame;
		HRESULT retValue;
	};

	STDMETHOD(HandoffItem)(
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ IVsProject3* pProjDest,
		/*[in]*/ LPCOLESTR pszMkDocumentOld,
		/*[in]*/ LPCOLESTR pszMkDocumentNew,
		/*[in]*/ IVsWindowFrame* punkWindowFrame)
	{
		VSL_DEFINE_MOCK_METHOD(HandoffItem)

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProjDest);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocumentOld);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocumentNew);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkWindowFrame);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSUPPORTITEMHANDOFF_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSyntheticTextManager.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSYNTHETICTEXTMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSYNTHETICTEXTMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSyntheticTextManagerNotImpl :
	public IVsSyntheticTextManager
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSyntheticTextManagerNotImpl)

public:

	typedef IVsSyntheticTextManager Interface;

	STDMETHOD(GetSyntheticTextSession)(
		/*[in]*/ IUnknown* /*pOwningObject*/,
		/*[out]*/ IVsSyntheticTextSession** /*ppSession*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateSyntheticTextSession)(
		/*[in]*/ DWORD /*dwFlags*/,
		/*[in]*/ IUnknown* /*pOwningObject*/,
		/*[in]*/ IVsSyntheticTextClient* /*pClient*/,
		/*[out]*/ IVsSyntheticTextSession** /*ppState*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSyntheticTextManagerMockImpl :
	public IVsSyntheticTextManager,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSyntheticTextManagerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSyntheticTextManagerMockImpl)

	typedef IVsSyntheticTextManager Interface;
	struct GetSyntheticTextSessionValidValues
	{
		/*[in]*/ IUnknown* pOwningObject;
		/*[out]*/ IVsSyntheticTextSession** ppSession;
		HRESULT retValue;
	};

	STDMETHOD(GetSyntheticTextSession)(
		/*[in]*/ IUnknown* pOwningObject,
		/*[out]*/ IVsSyntheticTextSession** ppSession)
	{
		VSL_DEFINE_MOCK_METHOD(GetSyntheticTextSession)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pOwningObject);

		VSL_SET_VALIDVALUE_INTERFACE(ppSession);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateSyntheticTextSessionValidValues
	{
		/*[in]*/ DWORD dwFlags;
		/*[in]*/ IUnknown* pOwningObject;
		/*[in]*/ IVsSyntheticTextClient* pClient;
		/*[out]*/ IVsSyntheticTextSession** ppState;
		HRESULT retValue;
	};

	STDMETHOD(CreateSyntheticTextSession)(
		/*[in]*/ DWORD dwFlags,
		/*[in]*/ IUnknown* pOwningObject,
		/*[in]*/ IVsSyntheticTextClient* pClient,
		/*[out]*/ IVsSyntheticTextSession** ppState)
	{
		VSL_DEFINE_MOCK_METHOD(CreateSyntheticTextSession)

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pOwningObject);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pClient);

		VSL_SET_VALIDVALUE_INTERFACE(ppState);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSYNTHETICTEXTMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSwatchClient.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSWATCHCLIENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSWATCHCLIENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSwatchClientNotImpl :
	public IVsSwatchClient
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSwatchClientNotImpl)

public:

	typedef IVsSwatchClient Interface;

	STDMETHOD(GetMetrics)(
		/*[in,out]*/ VSSWATCHMETRICS* /*psm*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSelection)(
		/*[in,out]*/ int* /*pxCur*/,
		/*[in,out]*/ int* /*pyCur*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SelectionUpdate)(
		/*[in,out]*/ int* /*pxCur*/,
		/*[in,out]*/ int* /*pyCur*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RenderCell)(
		/*[in]*/ VSSWATCHRENDER* /*pRender*/,
		/*[in,out]*/ int* /*ptcidRet*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SelectCell)(
		/*[in]*/ int /*x*/,
		/*[in]*/ int /*y*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCellTooltip)(
		/*[in]*/ int /*x*/,
		/*[in]*/ int /*y*/,
		/*[out,retval]*/ BSTR* /*pbstrTooltip*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetEnabledCount)(
		/*[in,out]*/ int* /*pcEnabled*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RealizePalette)(
		/*[in]*/ HDC /*hdc*/,
		/*[out,retval]*/ HPALETTE* /*phpalOld*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSwatchClientMockImpl :
	public IVsSwatchClient,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSwatchClientMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSwatchClientMockImpl)

	typedef IVsSwatchClient Interface;
	struct GetMetricsValidValues
	{
		/*[in,out]*/ VSSWATCHMETRICS* psm;
		HRESULT retValue;
	};

	STDMETHOD(GetMetrics)(
		/*[in,out]*/ VSSWATCHMETRICS* psm)
	{
		VSL_DEFINE_MOCK_METHOD(GetMetrics)

		VSL_SET_VALIDVALUE(psm);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSelectionValidValues
	{
		/*[in,out]*/ int* pxCur;
		/*[in,out]*/ int* pyCur;
		HRESULT retValue;
	};

	STDMETHOD(GetSelection)(
		/*[in,out]*/ int* pxCur,
		/*[in,out]*/ int* pyCur)
	{
		VSL_DEFINE_MOCK_METHOD(GetSelection)

		VSL_SET_VALIDVALUE(pxCur);

		VSL_SET_VALIDVALUE(pyCur);

		VSL_RETURN_VALIDVALUES();
	}
	struct SelectionUpdateValidValues
	{
		/*[in,out]*/ int* pxCur;
		/*[in,out]*/ int* pyCur;
		HRESULT retValue;
	};

	STDMETHOD(SelectionUpdate)(
		/*[in,out]*/ int* pxCur,
		/*[in,out]*/ int* pyCur)
	{
		VSL_DEFINE_MOCK_METHOD(SelectionUpdate)

		VSL_SET_VALIDVALUE(pxCur);

		VSL_SET_VALIDVALUE(pyCur);

		VSL_RETURN_VALIDVALUES();
	}
	struct RenderCellValidValues
	{
		/*[in]*/ VSSWATCHRENDER* pRender;
		/*[in,out]*/ int* ptcidRet;
		HRESULT retValue;
	};

	STDMETHOD(RenderCell)(
		/*[in]*/ VSSWATCHRENDER* pRender,
		/*[in,out]*/ int* ptcidRet)
	{
		VSL_DEFINE_MOCK_METHOD(RenderCell)

		VSL_CHECK_VALIDVALUE_POINTER(pRender);

		VSL_SET_VALIDVALUE(ptcidRet);

		VSL_RETURN_VALIDVALUES();
	}
	struct SelectCellValidValues
	{
		/*[in]*/ int x;
		/*[in]*/ int y;
		HRESULT retValue;
	};

	STDMETHOD(SelectCell)(
		/*[in]*/ int x,
		/*[in]*/ int y)
	{
		VSL_DEFINE_MOCK_METHOD(SelectCell)

		VSL_CHECK_VALIDVALUE(x);

		VSL_CHECK_VALIDVALUE(y);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCellTooltipValidValues
	{
		/*[in]*/ int x;
		/*[in]*/ int y;
		/*[out,retval]*/ BSTR* pbstrTooltip;
		HRESULT retValue;
	};

	STDMETHOD(GetCellTooltip)(
		/*[in]*/ int x,
		/*[in]*/ int y,
		/*[out,retval]*/ BSTR* pbstrTooltip)
	{
		VSL_DEFINE_MOCK_METHOD(GetCellTooltip)

		VSL_CHECK_VALIDVALUE(x);

		VSL_CHECK_VALIDVALUE(y);

		VSL_SET_VALIDVALUE_BSTR(pbstrTooltip);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetEnabledCountValidValues
	{
		/*[in,out]*/ int* pcEnabled;
		HRESULT retValue;
	};

	STDMETHOD(GetEnabledCount)(
		/*[in,out]*/ int* pcEnabled)
	{
		VSL_DEFINE_MOCK_METHOD(GetEnabledCount)

		VSL_SET_VALIDVALUE(pcEnabled);

		VSL_RETURN_VALIDVALUES();
	}
	struct RealizePaletteValidValues
	{
		/*[in]*/ HDC hdc;
		/*[out,retval]*/ HPALETTE* phpalOld;
		HRESULT retValue;
	};

	STDMETHOD(RealizePalette)(
		/*[in]*/ HDC hdc,
		/*[out,retval]*/ HPALETTE* phpalOld)
	{
		VSL_DEFINE_MOCK_METHOD(RealizePalette)

		VSL_CHECK_VALIDVALUE(hdc);

		VSL_SET_VALIDVALUE(phpalOld);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSWATCHCLIENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSyntheticRegion.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSYNTHETICREGION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSYNTHETICREGION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSyntheticRegionNotImpl :
	public IVsSyntheticRegion
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSyntheticRegionNotImpl)

public:

	typedef IVsSyntheticRegion Interface;

	STDMETHOD(GetMarkerType)(
		/*[out]*/ long* /*piMarkerType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetBehavior)(
		/*[out]*/ DWORD* /*pdwBehavior*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetText)(
		/*[out]*/ BSTR* /*pbstrText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetText)(
		/*[in]*/ LPCWSTR /*pszText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetBaseBufferAnchor)(
		/*[out]*/ long* /*piAnchorLine*/,
		/*[out]*/ long* /*piAnchorIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetBaseBufferAnchor)(
		/*[in]*/ long /*iAnchorLine*/,
		/*[in]*/ long /*iAnchorIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetClientData)(
		/*[out]*/ DWORD_PTR* /*pdwData*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetClientData)(
		/*[in]*/ DWORD_PTR /*dwData*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invalidate)(
		/*[in]*/ DWORD /*dwUpdate*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsValid)(
		/*[out]*/ BOOL* /*pfValid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTextLayer)(
		/*[out]*/ IVsTextLayer** /*ppLayer*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSyntheticLayerSpan)(
		/*[out]*/ TextSpan* /*pSpan*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTextImage)(
		/*[out]*/ IVsTextImage** /*ppImage*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSyntheticRegionMockImpl :
	public IVsSyntheticRegion,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSyntheticRegionMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSyntheticRegionMockImpl)

	typedef IVsSyntheticRegion Interface;
	struct GetMarkerTypeValidValues
	{
		/*[out]*/ long* piMarkerType;
		HRESULT retValue;
	};

	STDMETHOD(GetMarkerType)(
		/*[out]*/ long* piMarkerType)
	{
		VSL_DEFINE_MOCK_METHOD(GetMarkerType)

		VSL_SET_VALIDVALUE(piMarkerType);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetBehaviorValidValues
	{
		/*[out]*/ DWORD* pdwBehavior;
		HRESULT retValue;
	};

	STDMETHOD(GetBehavior)(
		/*[out]*/ DWORD* pdwBehavior)
	{
		VSL_DEFINE_MOCK_METHOD(GetBehavior)

		VSL_SET_VALIDVALUE(pdwBehavior);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTextValidValues
	{
		/*[out]*/ BSTR* pbstrText;
		HRESULT retValue;
	};

	STDMETHOD(GetText)(
		/*[out]*/ BSTR* pbstrText)
	{
		VSL_DEFINE_MOCK_METHOD(GetText)

		VSL_SET_VALIDVALUE_BSTR(pbstrText);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetTextValidValues
	{
		/*[in]*/ LPCWSTR pszText;
		HRESULT retValue;
	};

	STDMETHOD(SetText)(
		/*[in]*/ LPCWSTR pszText)
	{
		VSL_DEFINE_MOCK_METHOD(SetText)

		VSL_CHECK_VALIDVALUE_STRINGW(pszText);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetBaseBufferAnchorValidValues
	{
		/*[out]*/ long* piAnchorLine;
		/*[out]*/ long* piAnchorIndex;
		HRESULT retValue;
	};

	STDMETHOD(GetBaseBufferAnchor)(
		/*[out]*/ long* piAnchorLine,
		/*[out]*/ long* piAnchorIndex)
	{
		VSL_DEFINE_MOCK_METHOD(GetBaseBufferAnchor)

		VSL_SET_VALIDVALUE(piAnchorLine);

		VSL_SET_VALIDVALUE(piAnchorIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetBaseBufferAnchorValidValues
	{
		/*[in]*/ long iAnchorLine;
		/*[in]*/ long iAnchorIndex;
		HRESULT retValue;
	};

	STDMETHOD(SetBaseBufferAnchor)(
		/*[in]*/ long iAnchorLine,
		/*[in]*/ long iAnchorIndex)
	{
		VSL_DEFINE_MOCK_METHOD(SetBaseBufferAnchor)

		VSL_CHECK_VALIDVALUE(iAnchorLine);

		VSL_CHECK_VALIDVALUE(iAnchorIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetClientDataValidValues
	{
		/*[out]*/ DWORD_PTR* pdwData;
		HRESULT retValue;
	};

	STDMETHOD(GetClientData)(
		/*[out]*/ DWORD_PTR* pdwData)
	{
		VSL_DEFINE_MOCK_METHOD(GetClientData)

		VSL_SET_VALIDVALUE(pdwData);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetClientDataValidValues
	{
		/*[in]*/ DWORD_PTR dwData;
		HRESULT retValue;
	};

	STDMETHOD(SetClientData)(
		/*[in]*/ DWORD_PTR dwData)
	{
		VSL_DEFINE_MOCK_METHOD(SetClientData)

		VSL_CHECK_VALIDVALUE(dwData);

		VSL_RETURN_VALIDVALUES();
	}
	struct InvalidateValidValues
	{
		/*[in]*/ DWORD dwUpdate;
		HRESULT retValue;
	};

	STDMETHOD(Invalidate)(
		/*[in]*/ DWORD dwUpdate)
	{
		VSL_DEFINE_MOCK_METHOD(Invalidate)

		VSL_CHECK_VALIDVALUE(dwUpdate);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsValidValidValues
	{
		/*[out]*/ BOOL* pfValid;
		HRESULT retValue;
	};

	STDMETHOD(IsValid)(
		/*[out]*/ BOOL* pfValid)
	{
		VSL_DEFINE_MOCK_METHOD(IsValid)

		VSL_SET_VALIDVALUE(pfValid);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTextLayerValidValues
	{
		/*[out]*/ IVsTextLayer** ppLayer;
		HRESULT retValue;
	};

	STDMETHOD(GetTextLayer)(
		/*[out]*/ IVsTextLayer** ppLayer)
	{
		VSL_DEFINE_MOCK_METHOD(GetTextLayer)

		VSL_SET_VALIDVALUE_INTERFACE(ppLayer);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSyntheticLayerSpanValidValues
	{
		/*[out]*/ TextSpan* pSpan;
		HRESULT retValue;
	};

	STDMETHOD(GetSyntheticLayerSpan)(
		/*[out]*/ TextSpan* pSpan)
	{
		VSL_DEFINE_MOCK_METHOD(GetSyntheticLayerSpan)

		VSL_SET_VALIDVALUE(pSpan);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTextImageValidValues
	{
		/*[out]*/ IVsTextImage** ppImage;
		HRESULT retValue;
	};

	STDMETHOD(GetTextImage)(
		/*[out]*/ IVsTextImage** ppImage)
	{
		VSL_DEFINE_MOCK_METHOD(GetTextImage)

		VSL_SET_VALIDVALUE_INTERFACE(ppImage);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSYNTHETICREGION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSupportItemHandoff2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSUPPORTITEMHANDOFF2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSUPPORTITEMHANDOFF2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSupportItemHandoff2NotImpl :
	public IVsSupportItemHandoff2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSupportItemHandoff2NotImpl)

public:

	typedef IVsSupportItemHandoff2 Interface;

	STDMETHOD(OnBeforeHandoffItem)(
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ IVsProject3* /*pProjDest*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSupportItemHandoff2MockImpl :
	public IVsSupportItemHandoff2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSupportItemHandoff2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSupportItemHandoff2MockImpl)

	typedef IVsSupportItemHandoff2 Interface;
	struct OnBeforeHandoffItemValidValues
	{
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ IVsProject3* pProjDest;
		HRESULT retValue;
	};

	STDMETHOD(OnBeforeHandoffItem)(
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ IVsProject3* pProjDest)
	{
		VSL_DEFINE_MOCK_METHOD(OnBeforeHandoffItem)

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProjDest);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSUPPORTITEMHANDOFF2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSyntheticTextSession.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSYNTHETICTEXTSESSION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSYNTHETICTEXTSESSION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSyntheticTextSessionNotImpl :
	public IVsSyntheticTextSession
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSyntheticTextSessionNotImpl)

public:

	typedef IVsSyntheticTextSession Interface;

	STDMETHOD(AddSyntheticRegions)(
		/*[in]*/ DWORD /*dwUpdateFlags*/,
		/*[in]*/ long /*cRegions*/,
		/*[in,size_is(cRegions)]*/ NewSyntheticRegion* /*rgSynthReg*/,
		/*[out]*/ IVsEnumSyntheticRegions** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumSyntheticRegions)(
		/*[in]*/ DWORD /*dwFindFlags*/,
		/*[in]*/ DWORD_PTR /*dwCookie*/,
		/*[in]*/ TextSpan* /*ptsRange*/,
		/*[out]*/ IVsEnumSyntheticRegions** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnadviseClient)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Terminate)()VSL_STDMETHOD_NOTIMPL
};

class IVsSyntheticTextSessionMockImpl :
	public IVsSyntheticTextSession,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSyntheticTextSessionMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSyntheticTextSessionMockImpl)

	typedef IVsSyntheticTextSession Interface;
	struct AddSyntheticRegionsValidValues
	{
		/*[in]*/ DWORD dwUpdateFlags;
		/*[in]*/ long cRegions;
		/*[in,size_is(cRegions)]*/ NewSyntheticRegion* rgSynthReg;
		/*[out]*/ IVsEnumSyntheticRegions** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(AddSyntheticRegions)(
		/*[in]*/ DWORD dwUpdateFlags,
		/*[in]*/ long cRegions,
		/*[in,size_is(cRegions)]*/ NewSyntheticRegion* rgSynthReg,
		/*[out]*/ IVsEnumSyntheticRegions** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(AddSyntheticRegions)

		VSL_CHECK_VALIDVALUE(dwUpdateFlags);

		VSL_CHECK_VALIDVALUE(cRegions);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgSynthReg, cRegions*sizeof(rgSynthReg[0]), validValues.cRegions*sizeof(validValues.rgSynthReg[0]));

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumSyntheticRegionsValidValues
	{
		/*[in]*/ DWORD dwFindFlags;
		/*[in]*/ DWORD_PTR dwCookie;
		/*[in]*/ TextSpan* ptsRange;
		/*[out]*/ IVsEnumSyntheticRegions** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumSyntheticRegions)(
		/*[in]*/ DWORD dwFindFlags,
		/*[in]*/ DWORD_PTR dwCookie,
		/*[in]*/ TextSpan* ptsRange,
		/*[out]*/ IVsEnumSyntheticRegions** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumSyntheticRegions)

		VSL_CHECK_VALIDVALUE(dwFindFlags);

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_CHECK_VALIDVALUE_POINTER(ptsRange);

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnadviseClientValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(UnadviseClient)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(UnadviseClient)

		VSL_RETURN_VALIDVALUES();
	}
	struct TerminateValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Terminate)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Terminate)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSYNTHETICTEXTSESSION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsSwitchToolWindow.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSSWITCHTOOLWINDOW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSSWITCHTOOLWINDOW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsSwitchToolWindowNotImpl :
	public IVsSwitchToolWindow
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSwitchToolWindowNotImpl)

public:

	typedef IVsSwitchToolWindow Interface;

	STDMETHOD(QueryToolWindow)(
		/*[in]*/ REFGUID /*guidToolWindow*/,
		/*[out]*/ GUID* /*guidToolSwitch*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSwitchedPane)(
		/*[in]*/ REFGUID /*guidToolSwitch*/,
		/*[in]*/ IVsWindowFrame* /*pFrame*/,
		/*[out]*/ IVsWindowPane** /*pPane*/)VSL_STDMETHOD_NOTIMPL
};

class IVsSwitchToolWindowMockImpl :
	public IVsSwitchToolWindow,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsSwitchToolWindowMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsSwitchToolWindowMockImpl)

	typedef IVsSwitchToolWindow Interface;
	struct QueryToolWindowValidValues
	{
		/*[in]*/ REFGUID guidToolWindow;
		/*[out]*/ GUID* guidToolSwitch;
		HRESULT retValue;
	};

	STDMETHOD(QueryToolWindow)(
		/*[in]*/ REFGUID guidToolWindow,
		/*[out]*/ GUID* guidToolSwitch)
	{
		VSL_DEFINE_MOCK_METHOD(QueryToolWindow)

		VSL_CHECK_VALIDVALUE(guidToolWindow);

		VSL_SET_VALIDVALUE(guidToolSwitch);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSwitchedPaneValidValues
	{
		/*[in]*/ REFGUID guidToolSwitch;
		/*[in]*/ IVsWindowFrame* pFrame;
		/*[out]*/ IVsWindowPane** pPane;
		HRESULT retValue;
	};

	STDMETHOD(GetSwitchedPane)(
		/*[in]*/ REFGUID guidToolSwitch,
		/*[in]*/ IVsWindowFrame* pFrame,
		/*[out]*/ IVsWindowPane** pPane)
	{
		VSL_DEFINE_MOCK_METHOD(GetSwitchedPane)

		VSL_CHECK_VALIDVALUE(guidToolSwitch);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pFrame);

		VSL_SET_VALIDVALUE_INTERFACE(pPane);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSSWITCHTOOLWINDOW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTaskItem.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTASKITEM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTASKITEM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTaskItemNotImpl :
	public IVsTaskItem
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTaskItemNotImpl)

public:

	typedef IVsTaskItem Interface;

	STDMETHOD(get_Priority)(
		/*[out,retval]*/ VSTASKPRIORITY* /*ptpPriority*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_Priority)(
		/*[in]*/ VSTASKPRIORITY /*tpPriority*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Category)(
		/*[out,retval]*/ VSTASKCATEGORY* /*pCat*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_SubcategoryIndex)(
		/*[out,retval]*/ long* /*pIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ImageListIndex)(
		/*[out,retval]*/ long* /*pIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Checked)(
		/*[out,retval]*/ BOOL* /*pfChecked*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_Checked)(
		/*[in]*/ BOOL /*fChecked*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Text)(
		/*[out,retval]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_Text)(
		/*[in]*/ BSTR /*bstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Document)(
		/*[out,retval]*/ BSTR* /*pbstrMkDocument*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Line)(
		/*[out,retval]*/ long* /*piLine*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Column)(
		/*[out,retval]*/ long* /*piCol*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CanDelete)(
		/*[out,retval]*/ BOOL* /*pfCanDelete*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_IsReadOnly)(
		/*[in]*/ VSTASKFIELD /*field*/,
		/*[out,retval]*/ BOOL* /*pfReadOnly*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_HasHelp)(
		/*[out,retval]*/ BOOL* /*pfHasHelp*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(NavigateTo)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(NavigateToHelp)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnFilterTask)(
		/*[in]*/ BOOL /*fVisible*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnDeleteTask)()VSL_STDMETHOD_NOTIMPL
};

class IVsTaskItemMockImpl :
	public IVsTaskItem,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTaskItemMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTaskItemMockImpl)

	typedef IVsTaskItem Interface;
	struct get_PriorityValidValues
	{
		/*[out,retval]*/ VSTASKPRIORITY* ptpPriority;
		HRESULT retValue;
	};

	STDMETHOD(get_Priority)(
		/*[out,retval]*/ VSTASKPRIORITY* ptpPriority)
	{
		VSL_DEFINE_MOCK_METHOD(get_Priority)

		VSL_SET_VALIDVALUE(ptpPriority);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_PriorityValidValues
	{
		/*[in]*/ VSTASKPRIORITY tpPriority;
		HRESULT retValue;
	};

	STDMETHOD(put_Priority)(
		/*[in]*/ VSTASKPRIORITY tpPriority)
	{
		VSL_DEFINE_MOCK_METHOD(put_Priority)

		VSL_CHECK_VALIDVALUE(tpPriority);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CategoryValidValues
	{
		/*[out,retval]*/ VSTASKCATEGORY* pCat;
		HRESULT retValue;
	};

	STDMETHOD(get_Category)(
		/*[out,retval]*/ VSTASKCATEGORY* pCat)
	{
		VSL_DEFINE_MOCK_METHOD(get_Category)

		VSL_SET_VALIDVALUE(pCat);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_SubcategoryIndexValidValues
	{
		/*[out,retval]*/ long* pIndex;
		HRESULT retValue;
	};

	STDMETHOD(get_SubcategoryIndex)(
		/*[out,retval]*/ long* pIndex)
	{
		VSL_DEFINE_MOCK_METHOD(get_SubcategoryIndex)

		VSL_SET_VALIDVALUE(pIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ImageListIndexValidValues
	{
		/*[out,retval]*/ long* pIndex;
		HRESULT retValue;
	};

	STDMETHOD(get_ImageListIndex)(
		/*[out,retval]*/ long* pIndex)
	{
		VSL_DEFINE_MOCK_METHOD(get_ImageListIndex)

		VSL_SET_VALIDVALUE(pIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CheckedValidValues
	{
		/*[out,retval]*/ BOOL* pfChecked;
		HRESULT retValue;
	};

	STDMETHOD(get_Checked)(
		/*[out,retval]*/ BOOL* pfChecked)
	{
		VSL_DEFINE_MOCK_METHOD(get_Checked)

		VSL_SET_VALIDVALUE(pfChecked);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_CheckedValidValues
	{
		/*[in]*/ BOOL fChecked;
		HRESULT retValue;
	};

	STDMETHOD(put_Checked)(
		/*[in]*/ BOOL fChecked)
	{
		VSL_DEFINE_MOCK_METHOD(put_Checked)

		VSL_CHECK_VALIDVALUE(fChecked);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_TextValidValues
	{
		/*[out,retval]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(get_Text)(
		/*[out,retval]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(get_Text)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_TextValidValues
	{
		/*[in]*/ BSTR bstrName;
		HRESULT retValue;
	};

	STDMETHOD(put_Text)(
		/*[in]*/ BSTR bstrName)
	{
		VSL_DEFINE_MOCK_METHOD(put_Text)

		VSL_CHECK_VALIDVALUE_BSTR(bstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DocumentValidValues
	{
		/*[out,retval]*/ BSTR* pbstrMkDocument;
		HRESULT retValue;
	};

	STDMETHOD(get_Document)(
		/*[out,retval]*/ BSTR* pbstrMkDocument)
	{
		VSL_DEFINE_MOCK_METHOD(get_Document)

		VSL_SET_VALIDVALUE_BSTR(pbstrMkDocument);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_LineValidValues
	{
		/*[out,retval]*/ long* piLine;
		HRESULT retValue;
	};

	STDMETHOD(get_Line)(
		/*[out,retval]*/ long* piLine)
	{
		VSL_DEFINE_MOCK_METHOD(get_Line)

		VSL_SET_VALIDVALUE(piLine);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ColumnValidValues
	{
		/*[out,retval]*/ long* piCol;
		HRESULT retValue;
	};

	STDMETHOD(get_Column)(
		/*[out,retval]*/ long* piCol)
	{
		VSL_DEFINE_MOCK_METHOD(get_Column)

		VSL_SET_VALIDVALUE(piCol);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CanDeleteValidValues
	{
		/*[out,retval]*/ BOOL* pfCanDelete;
		HRESULT retValue;
	};

	STDMETHOD(get_CanDelete)(
		/*[out,retval]*/ BOOL* pfCanDelete)
	{
		VSL_DEFINE_MOCK_METHOD(get_CanDelete)

		VSL_SET_VALIDVALUE(pfCanDelete);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IsReadOnlyValidValues
	{
		/*[in]*/ VSTASKFIELD field;
		/*[out,retval]*/ BOOL* pfReadOnly;
		HRESULT retValue;
	};

	STDMETHOD(get_IsReadOnly)(
		/*[in]*/ VSTASKFIELD field,
		/*[out,retval]*/ BOOL* pfReadOnly)
	{
		VSL_DEFINE_MOCK_METHOD(get_IsReadOnly)

		VSL_CHECK_VALIDVALUE(field);

		VSL_SET_VALIDVALUE(pfReadOnly);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_HasHelpValidValues
	{
		/*[out,retval]*/ BOOL* pfHasHelp;
		HRESULT retValue;
	};

	STDMETHOD(get_HasHelp)(
		/*[out,retval]*/ BOOL* pfHasHelp)
	{
		VSL_DEFINE_MOCK_METHOD(get_HasHelp)

		VSL_SET_VALIDVALUE(pfHasHelp);

		VSL_RETURN_VALIDVALUES();
	}
	struct NavigateToValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(NavigateTo)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(NavigateTo)

		VSL_RETURN_VALIDVALUES();
	}
	struct NavigateToHelpValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(NavigateToHelp)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(NavigateToHelp)

		VSL_RETURN_VALIDVALUES();
	}
	struct OnFilterTaskValidValues
	{
		/*[in]*/ BOOL fVisible;
		HRESULT retValue;
	};

	STDMETHOD(OnFilterTask)(
		/*[in]*/ BOOL fVisible)
	{
		VSL_DEFINE_MOCK_METHOD(OnFilterTask)

		VSL_CHECK_VALIDVALUE(fVisible);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnDeleteTaskValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(OnDeleteTask)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(OnDeleteTask)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTASKITEM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTaskList2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTASKLIST2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTASKLIST2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTaskList2NotImpl :
	public IVsTaskList2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTaskList2NotImpl)

public:

	typedef IVsTaskList2 Interface;

	STDMETHOD(GetSelectionCount)(
		/*[out]*/ int* /*pnItems*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCaretPos)(
		/*[out]*/ IVsTaskItem** /*ppItem*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumSelectedItems)(
		/*[out]*/ IVsEnumTaskItems** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SelectItems)(
		/*[in]*/ int /*nItems*/,
		/*[in,size_is(nItems)]*/ IVsTaskItem*[] /*pItems*/,
		/*[in]*/ VSTASKLISTSELECTIONTYPE /*tsfSelType*/,
		/*[in]*/ VSTASKLISTSELECTIONSCROLLPOS /*tsspScrollPos*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(BeginTaskEdit)(
		/*[in]*/ IVsTaskItem* /*pItem*/,
		/*[in]*/ int /*iFocusField*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetActiveProvider)(
		/*[out]*/ IVsTaskProvider** /*ppProvider*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetActiveProvider)(
		/*[in]*/ REFGUID /*rguidProvider*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RefreshOrAddTasks)(
		/*[in]*/ VSCOOKIE /*vsProviderCookie*/,
		/*[in]*/ int /*nTasks*/,
		/*[in,size_is(nTasks)]*/ IVsTaskItem*[] /*prgTasks*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveTasks)(
		/*[in]*/ VSCOOKIE /*vsProviderCookie*/,
		/*[in]*/ int /*nTasks*/,
		/*[in,size_is(nTasks)]*/ IVsTaskItem*[] /*prgTasks*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RefreshAllProviders)()VSL_STDMETHOD_NOTIMPL
};

class IVsTaskList2MockImpl :
	public IVsTaskList2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTaskList2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTaskList2MockImpl)

	typedef IVsTaskList2 Interface;
	struct GetSelectionCountValidValues
	{
		/*[out]*/ int* pnItems;
		HRESULT retValue;
	};

	STDMETHOD(GetSelectionCount)(
		/*[out]*/ int* pnItems)
	{
		VSL_DEFINE_MOCK_METHOD(GetSelectionCount)

		VSL_SET_VALIDVALUE(pnItems);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCaretPosValidValues
	{
		/*[out]*/ IVsTaskItem** ppItem;
		HRESULT retValue;
	};

	STDMETHOD(GetCaretPos)(
		/*[out]*/ IVsTaskItem** ppItem)
	{
		VSL_DEFINE_MOCK_METHOD(GetCaretPos)

		VSL_SET_VALIDVALUE_INTERFACE(ppItem);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumSelectedItemsValidValues
	{
		/*[out]*/ IVsEnumTaskItems** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumSelectedItems)(
		/*[out]*/ IVsEnumTaskItems** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumSelectedItems)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct SelectItemsValidValues
	{
		/*[in]*/ int nItems;
		/*[in,size_is(nItems)]*/ IVsTaskItem** pItems;
		/*[in]*/ VSTASKLISTSELECTIONTYPE tsfSelType;
		/*[in]*/ VSTASKLISTSELECTIONSCROLLPOS tsspScrollPos;
		HRESULT retValue;
	};

	STDMETHOD(SelectItems)(
		/*[in]*/ int nItems,
		/*[in,size_is(nItems)]*/ IVsTaskItem* pItems[],
		/*[in]*/ VSTASKLISTSELECTIONTYPE tsfSelType,
		/*[in]*/ VSTASKLISTSELECTIONSCROLLPOS tsspScrollPos)
	{
		VSL_DEFINE_MOCK_METHOD(SelectItems)

		VSL_CHECK_VALIDVALUE(nItems);

		VSL_CHECK_VALIDVALUE_ARRAY(pItems, nItems, validValues.nItems);

		VSL_CHECK_VALIDVALUE(tsfSelType);

		VSL_CHECK_VALIDVALUE(tsspScrollPos);

		VSL_RETURN_VALIDVALUES();
	}
	struct BeginTaskEditValidValues
	{
		/*[in]*/ IVsTaskItem* pItem;
		/*[in]*/ int iFocusField;
		HRESULT retValue;
	};

	STDMETHOD(BeginTaskEdit)(
		/*[in]*/ IVsTaskItem* pItem,
		/*[in]*/ int iFocusField)
	{
		VSL_DEFINE_MOCK_METHOD(BeginTaskEdit)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pItem);

		VSL_CHECK_VALIDVALUE(iFocusField);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetActiveProviderValidValues
	{
		/*[out]*/ IVsTaskProvider** ppProvider;
		HRESULT retValue;
	};

	STDMETHOD(GetActiveProvider)(
		/*[out]*/ IVsTaskProvider** ppProvider)
	{
		VSL_DEFINE_MOCK_METHOD(GetActiveProvider)

		VSL_SET_VALIDVALUE_INTERFACE(ppProvider);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetActiveProviderValidValues
	{
		/*[in]*/ REFGUID rguidProvider;
		HRESULT retValue;
	};

	STDMETHOD(SetActiveProvider)(
		/*[in]*/ REFGUID rguidProvider)
	{
		VSL_DEFINE_MOCK_METHOD(SetActiveProvider)

		VSL_CHECK_VALIDVALUE(rguidProvider);

		VSL_RETURN_VALIDVALUES();
	}
	struct RefreshOrAddTasksValidValues
	{
		/*[in]*/ VSCOOKIE vsProviderCookie;
		/*[in]*/ int nTasks;
		/*[in,size_is(nTasks)]*/ IVsTaskItem** prgTasks;
		HRESULT retValue;
	};

	STDMETHOD(RefreshOrAddTasks)(
		/*[in]*/ VSCOOKIE vsProviderCookie,
		/*[in]*/ int nTasks,
		/*[in,size_is(nTasks)]*/ IVsTaskItem* prgTasks[])
	{
		VSL_DEFINE_MOCK_METHOD(RefreshOrAddTasks)

		VSL_CHECK_VALIDVALUE(vsProviderCookie);

		VSL_CHECK_VALIDVALUE(nTasks);

		VSL_CHECK_VALIDVALUE_ARRAY(prgTasks, nTasks, validValues.nTasks);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveTasksValidValues
	{
		/*[in]*/ VSCOOKIE vsProviderCookie;
		/*[in]*/ int nTasks;
		/*[in,size_is(nTasks)]*/ IVsTaskItem** prgTasks;
		HRESULT retValue;
	};

	STDMETHOD(RemoveTasks)(
		/*[in]*/ VSCOOKIE vsProviderCookie,
		/*[in]*/ int nTasks,
		/*[in,size_is(nTasks)]*/ IVsTaskItem* prgTasks[])
	{
		VSL_DEFINE_MOCK_METHOD(RemoveTasks)

		VSL_CHECK_VALIDVALUE(vsProviderCookie);

		VSL_CHECK_VALIDVALUE(nTasks);

		VSL_CHECK_VALIDVALUE_ARRAY(prgTasks, nTasks, validValues.nTasks);

		VSL_RETURN_VALIDVALUES();
	}
	struct RefreshAllProvidersValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(RefreshAllProviders)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(RefreshAllProviders)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTASKLIST2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTaskItem3.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTASKITEM3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTASKITEM3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTaskItem3NotImpl :
	public IVsTaskItem3
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTaskItem3NotImpl)

public:

	typedef IVsTaskItem3 Interface;

	STDMETHOD(GetTaskProvider)(
		/*[out]*/ IVsTaskProvider3** /*ppProvider*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTaskName)(
		/*[out]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetColumnValue)(
		/*[in]*/ int /*iField*/,
		/*[out]*/ VSTASKVALUETYPE* /*ptvtType*/,
		/*[out]*/ VSTASKVALUEFLAGS* /*ptvfFlags*/,
		/*[out]*/ VARIANT* /*pvarValue*/,
		/*[out]*/ BSTR* /*pbstrAccessibilityName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTipText)(
		/*[in]*/ int /*iField*/,
		/*[out]*/ BSTR* /*pbstrTipText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetColumnValue)(
		/*[in]*/ int /*iField*/,
		/*[in]*/ VARIANT* /*pvarValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsDirty)(
		/*[out]*/ BOOL* /*pfDirty*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetEnumCount)(
		/*[in]*/ int /*iField*/,
		/*[out]*/ int* /*pnValues*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetEnumValue)(
		/*[in]*/ int /*iField*/,
		/*[in]*/ int /*iValue*/,
		/*[out]*/ VARIANT* /*pvarValue*/,
		/*[out]*/ BSTR* /*pbstrAccessibilityName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnLinkClicked)(
		/*[in]*/ int /*iField*/,
		/*[in]*/ int /*iLinkIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetNavigationStatusText)(
		/*[out]*/ BSTR* /*pbstrText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDefaultEditField)(
		/*[out]*/ int* /*piField*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSurrogateProviderGuid)(
		/*[out]*/ GUID* /*pguidProvider*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTaskItem3MockImpl :
	public IVsTaskItem3,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTaskItem3MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTaskItem3MockImpl)

	typedef IVsTaskItem3 Interface;
	struct GetTaskProviderValidValues
	{
		/*[out]*/ IVsTaskProvider3** ppProvider;
		HRESULT retValue;
	};

	STDMETHOD(GetTaskProvider)(
		/*[out]*/ IVsTaskProvider3** ppProvider)
	{
		VSL_DEFINE_MOCK_METHOD(GetTaskProvider)

		VSL_SET_VALIDVALUE_INTERFACE(ppProvider);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTaskNameValidValues
	{
		/*[out]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(GetTaskName)(
		/*[out]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(GetTaskName)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetColumnValueValidValues
	{
		/*[in]*/ int iField;
		/*[out]*/ VSTASKVALUETYPE* ptvtType;
		/*[out]*/ VSTASKVALUEFLAGS* ptvfFlags;
		/*[out]*/ VARIANT* pvarValue;
		/*[out]*/ BSTR* pbstrAccessibilityName;
		HRESULT retValue;
	};

	STDMETHOD(GetColumnValue)(
		/*[in]*/ int iField,
		/*[out]*/ VSTASKVALUETYPE* ptvtType,
		/*[out]*/ VSTASKVALUEFLAGS* ptvfFlags,
		/*[out]*/ VARIANT* pvarValue,
		/*[out]*/ BSTR* pbstrAccessibilityName)
	{
		VSL_DEFINE_MOCK_METHOD(GetColumnValue)

		VSL_CHECK_VALIDVALUE(iField);

		VSL_SET_VALIDVALUE(ptvtType);

		VSL_SET_VALIDVALUE(ptvfFlags);

		VSL_SET_VALIDVALUE_VARIANT(pvarValue);

		VSL_SET_VALIDVALUE_BSTR(pbstrAccessibilityName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTipTextValidValues
	{
		/*[in]*/ int iField;
		/*[out]*/ BSTR* pbstrTipText;
		HRESULT retValue;
	};

	STDMETHOD(GetTipText)(
		/*[in]*/ int iField,
		/*[out]*/ BSTR* pbstrTipText)
	{
		VSL_DEFINE_MOCK_METHOD(GetTipText)

		VSL_CHECK_VALIDVALUE(iField);

		VSL_SET_VALIDVALUE_BSTR(pbstrTipText);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetColumnValueValidValues
	{
		/*[in]*/ int iField;
		/*[in]*/ VARIANT* pvarValue;
		HRESULT retValue;
	};

	STDMETHOD(SetColumnValue)(
		/*[in]*/ int iField,
		/*[in]*/ VARIANT* pvarValue)
	{
		VSL_DEFINE_MOCK_METHOD(SetColumnValue)

		VSL_CHECK_VALIDVALUE(iField);

		VSL_CHECK_VALIDVALUE_POINTER(pvarValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsDirtyValidValues
	{
		/*[out]*/ BOOL* pfDirty;
		HRESULT retValue;
	};

	STDMETHOD(IsDirty)(
		/*[out]*/ BOOL* pfDirty)
	{
		VSL_DEFINE_MOCK_METHOD(IsDirty)

		VSL_SET_VALIDVALUE(pfDirty);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetEnumCountValidValues
	{
		/*[in]*/ int iField;
		/*[out]*/ int* pnValues;
		HRESULT retValue;
	};

	STDMETHOD(GetEnumCount)(
		/*[in]*/ int iField,
		/*[out]*/ int* pnValues)
	{
		VSL_DEFINE_MOCK_METHOD(GetEnumCount)

		VSL_CHECK_VALIDVALUE(iField);

		VSL_SET_VALIDVALUE(pnValues);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetEnumValueValidValues
	{
		/*[in]*/ int iField;
		/*[in]*/ int iValue;
		/*[out]*/ VARIANT* pvarValue;
		/*[out]*/ BSTR* pbstrAccessibilityName;
		HRESULT retValue;
	};

	STDMETHOD(GetEnumValue)(
		/*[in]*/ int iField,
		/*[in]*/ int iValue,
		/*[out]*/ VARIANT* pvarValue,
		/*[out]*/ BSTR* pbstrAccessibilityName)
	{
		VSL_DEFINE_MOCK_METHOD(GetEnumValue)

		VSL_CHECK_VALIDVALUE(iField);

		VSL_CHECK_VALIDVALUE(iValue);

		VSL_SET_VALIDVALUE_VARIANT(pvarValue);

		VSL_SET_VALIDVALUE_BSTR(pbstrAccessibilityName);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnLinkClickedValidValues
	{
		/*[in]*/ int iField;
		/*[in]*/ int iLinkIndex;
		HRESULT retValue;
	};

	STDMETHOD(OnLinkClicked)(
		/*[in]*/ int iField,
		/*[in]*/ int iLinkIndex)
	{
		VSL_DEFINE_MOCK_METHOD(OnLinkClicked)

		VSL_CHECK_VALIDVALUE(iField);

		VSL_CHECK_VALIDVALUE(iLinkIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetNavigationStatusTextValidValues
	{
		/*[out]*/ BSTR* pbstrText;
		HRESULT retValue;
	};

	STDMETHOD(GetNavigationStatusText)(
		/*[out]*/ BSTR* pbstrText)
	{
		VSL_DEFINE_MOCK_METHOD(GetNavigationStatusText)

		VSL_SET_VALIDVALUE_BSTR(pbstrText);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDefaultEditFieldValidValues
	{
		/*[out]*/ int* piField;
		HRESULT retValue;
	};

	STDMETHOD(GetDefaultEditField)(
		/*[out]*/ int* piField)
	{
		VSL_DEFINE_MOCK_METHOD(GetDefaultEditField)

		VSL_SET_VALIDVALUE(piField);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSurrogateProviderGuidValidValues
	{
		/*[out]*/ GUID* pguidProvider;
		HRESULT retValue;
	};

	STDMETHOD(GetSurrogateProviderGuid)(
		/*[out]*/ GUID* pguidProvider)
	{
		VSL_DEFINE_MOCK_METHOD(GetSurrogateProviderGuid)

		VSL_SET_VALIDVALUE(pguidProvider);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTASKITEM3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTaskListEvents.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTASKLISTEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTASKLISTEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTaskListEventsNotImpl :
	public IVsTaskListEvents
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTaskListEventsNotImpl)

public:

	typedef IVsTaskListEvents Interface;

	STDMETHOD(OnCommentTaskInfoChanged)()VSL_STDMETHOD_NOTIMPL
};

class IVsTaskListEventsMockImpl :
	public IVsTaskListEvents,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTaskListEventsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTaskListEventsMockImpl)

	typedef IVsTaskListEvents Interface;
	struct OnCommentTaskInfoChangedValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(OnCommentTaskInfoChanged)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(OnCommentTaskInfoChanged)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTASKLISTEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTaskProvider.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTASKPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTASKPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTaskProviderNotImpl :
	public IVsTaskProvider
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTaskProviderNotImpl)

public:

	typedef IVsTaskProvider Interface;

	STDMETHOD(EnumTaskItems)(
		/*[out]*/ IVsEnumTaskItems** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ImageList)(
		/*[out,retval]*/ HANDLE* /*phImageList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_SubcategoryList)(
		/*[in]*/ ULONG /*cbstr*/,
		/*[out,size_is(cbstr)]*/ BSTR[] /*rgbstr*/,
		/*[out]*/ ULONG* /*pcActual*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ReRegistrationKey)(
		/*[out]*/ BSTR* /*pbstrKey*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnTaskListFinalRelease)(
		/*[in]*/ IVsTaskList* /*pTaskList*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTaskProviderMockImpl :
	public IVsTaskProvider,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTaskProviderMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTaskProviderMockImpl)

	typedef IVsTaskProvider Interface;
	struct EnumTaskItemsValidValues
	{
		/*[out]*/ IVsEnumTaskItems** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumTaskItems)(
		/*[out]*/ IVsEnumTaskItems** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumTaskItems)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ImageListValidValues
	{
		/*[out,retval]*/ HANDLE* phImageList;
		HRESULT retValue;
	};

	STDMETHOD(get_ImageList)(
		/*[out,retval]*/ HANDLE* phImageList)
	{
		VSL_DEFINE_MOCK_METHOD(get_ImageList)

		VSL_SET_VALIDVALUE(phImageList);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_SubcategoryListValidValues
	{
		/*[in]*/ ULONG cbstr;
		/*[out,size_is(cbstr)]*/ BSTR* rgbstr;
		/*[out]*/ ULONG* pcActual;
		HRESULT retValue;
	};

	STDMETHOD(get_SubcategoryList)(
		/*[in]*/ ULONG cbstr,
		/*[out,size_is(cbstr)]*/ BSTR rgbstr[],
		/*[out]*/ ULONG* pcActual)
	{
		VSL_DEFINE_MOCK_METHOD(get_SubcategoryList)

		VSL_CHECK_VALIDVALUE(cbstr);

		VSL_SET_VALIDVALUE_MEMCPY(rgbstr, cbstr*sizeof(rgbstr[0]), validValues.cbstr*sizeof(validValues.rgbstr[0]));

		VSL_SET_VALIDVALUE(pcActual);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ReRegistrationKeyValidValues
	{
		/*[out]*/ BSTR* pbstrKey;
		HRESULT retValue;
	};

	STDMETHOD(get_ReRegistrationKey)(
		/*[out]*/ BSTR* pbstrKey)
	{
		VSL_DEFINE_MOCK_METHOD(get_ReRegistrationKey)

		VSL_SET_VALIDVALUE_BSTR(pbstrKey);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnTaskListFinalReleaseValidValues
	{
		/*[in]*/ IVsTaskList* pTaskList;
		HRESULT retValue;
	};

	STDMETHOD(OnTaskListFinalRelease)(
		/*[in]*/ IVsTaskList* pTaskList)
	{
		VSL_DEFINE_MOCK_METHOD(OnTaskListFinalRelease)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pTaskList);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTASKPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTaskItem2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTASKITEM2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTASKITEM2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTaskItem2NotImpl :
	public IVsTaskItem2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTaskItem2NotImpl)

public:

	typedef IVsTaskItem2 Interface;

	STDMETHOD(get_BrowseObject)(
		/*[out,retval]*/ IDispatch** /*ppObj*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CustomColumnText)(
		/*[in]*/ REFGUID /*guidView*/,
		/*[in]*/ ULONG /*iCustomColumnIndex*/,
		/*[out,retval]*/ BSTR* /*pbstrText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_CustomColumnText)(
		/*[in]*/ REFGUID /*guidView*/,
		/*[in]*/ ULONG /*iCustomColumnIndex*/,
		/*[in]*/ BSTR /*bstrText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_IsCustomColumnReadOnly)(
		/*[in]*/ REFGUID /*guidView*/,
		/*[in]*/ ULONG /*iCustomColumnIndex*/,
		/*[out,retval]*/ BOOL* /*pfReadOnly*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Priority)(
		/*[out,retval]*/ VSTASKPRIORITY* /*ptpPriority*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_Priority)(
		/*[in]*/ VSTASKPRIORITY /*tpPriority*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Category)(
		/*[out,retval]*/ VSTASKCATEGORY* /*pCat*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_SubcategoryIndex)(
		/*[out,retval]*/ long* /*pIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ImageListIndex)(
		/*[out,retval]*/ long* /*pIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Checked)(
		/*[out,retval]*/ BOOL* /*pfChecked*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_Checked)(
		/*[in]*/ BOOL /*fChecked*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Text)(
		/*[out,retval]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_Text)(
		/*[in]*/ BSTR /*bstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Document)(
		/*[out,retval]*/ BSTR* /*pbstrMkDocument*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Line)(
		/*[out,retval]*/ long* /*piLine*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Column)(
		/*[out,retval]*/ long* /*piCol*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CanDelete)(
		/*[out,retval]*/ BOOL* /*pfCanDelete*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_IsReadOnly)(
		/*[in]*/ VSTASKFIELD /*field*/,
		/*[out,retval]*/ BOOL* /*pfReadOnly*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_HasHelp)(
		/*[out,retval]*/ BOOL* /*pfHasHelp*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(NavigateTo)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(NavigateToHelp)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnFilterTask)(
		/*[in]*/ BOOL /*fVisible*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnDeleteTask)()VSL_STDMETHOD_NOTIMPL
};

class IVsTaskItem2MockImpl :
	public IVsTaskItem2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTaskItem2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTaskItem2MockImpl)

	typedef IVsTaskItem2 Interface;
	struct get_BrowseObjectValidValues
	{
		/*[out,retval]*/ IDispatch** ppObj;
		HRESULT retValue;
	};

	STDMETHOD(get_BrowseObject)(
		/*[out,retval]*/ IDispatch** ppObj)
	{
		VSL_DEFINE_MOCK_METHOD(get_BrowseObject)

		VSL_SET_VALIDVALUE_INTERFACE(ppObj);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CustomColumnTextValidValues
	{
		/*[in]*/ REFGUID guidView;
		/*[in]*/ ULONG iCustomColumnIndex;
		/*[out,retval]*/ BSTR* pbstrText;
		HRESULT retValue;
	};

	STDMETHOD(get_CustomColumnText)(
		/*[in]*/ REFGUID guidView,
		/*[in]*/ ULONG iCustomColumnIndex,
		/*[out,retval]*/ BSTR* pbstrText)
	{
		VSL_DEFINE_MOCK_METHOD(get_CustomColumnText)

		VSL_CHECK_VALIDVALUE(guidView);

		VSL_CHECK_VALIDVALUE(iCustomColumnIndex);

		VSL_SET_VALIDVALUE_BSTR(pbstrText);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_CustomColumnTextValidValues
	{
		/*[in]*/ REFGUID guidView;
		/*[in]*/ ULONG iCustomColumnIndex;
		/*[in]*/ BSTR bstrText;
		HRESULT retValue;
	};

	STDMETHOD(put_CustomColumnText)(
		/*[in]*/ REFGUID guidView,
		/*[in]*/ ULONG iCustomColumnIndex,
		/*[in]*/ BSTR bstrText)
	{
		VSL_DEFINE_MOCK_METHOD(put_CustomColumnText)

		VSL_CHECK_VALIDVALUE(guidView);

		VSL_CHECK_VALIDVALUE(iCustomColumnIndex);

		VSL_CHECK_VALIDVALUE_BSTR(bstrText);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IsCustomColumnReadOnlyValidValues
	{
		/*[in]*/ REFGUID guidView;
		/*[in]*/ ULONG iCustomColumnIndex;
		/*[out,retval]*/ BOOL* pfReadOnly;
		HRESULT retValue;
	};

	STDMETHOD(get_IsCustomColumnReadOnly)(
		/*[in]*/ REFGUID guidView,
		/*[in]*/ ULONG iCustomColumnIndex,
		/*[out,retval]*/ BOOL* pfReadOnly)
	{
		VSL_DEFINE_MOCK_METHOD(get_IsCustomColumnReadOnly)

		VSL_CHECK_VALIDVALUE(guidView);

		VSL_CHECK_VALIDVALUE(iCustomColumnIndex);

		VSL_SET_VALIDVALUE(pfReadOnly);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_PriorityValidValues
	{
		/*[out,retval]*/ VSTASKPRIORITY* ptpPriority;
		HRESULT retValue;
	};

	STDMETHOD(get_Priority)(
		/*[out,retval]*/ VSTASKPRIORITY* ptpPriority)
	{
		VSL_DEFINE_MOCK_METHOD(get_Priority)

		VSL_SET_VALIDVALUE(ptpPriority);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_PriorityValidValues
	{
		/*[in]*/ VSTASKPRIORITY tpPriority;
		HRESULT retValue;
	};

	STDMETHOD(put_Priority)(
		/*[in]*/ VSTASKPRIORITY tpPriority)
	{
		VSL_DEFINE_MOCK_METHOD(put_Priority)

		VSL_CHECK_VALIDVALUE(tpPriority);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CategoryValidValues
	{
		/*[out,retval]*/ VSTASKCATEGORY* pCat;
		HRESULT retValue;
	};

	STDMETHOD(get_Category)(
		/*[out,retval]*/ VSTASKCATEGORY* pCat)
	{
		VSL_DEFINE_MOCK_METHOD(get_Category)

		VSL_SET_VALIDVALUE(pCat);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_SubcategoryIndexValidValues
	{
		/*[out,retval]*/ long* pIndex;
		HRESULT retValue;
	};

	STDMETHOD(get_SubcategoryIndex)(
		/*[out,retval]*/ long* pIndex)
	{
		VSL_DEFINE_MOCK_METHOD(get_SubcategoryIndex)

		VSL_SET_VALIDVALUE(pIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ImageListIndexValidValues
	{
		/*[out,retval]*/ long* pIndex;
		HRESULT retValue;
	};

	STDMETHOD(get_ImageListIndex)(
		/*[out,retval]*/ long* pIndex)
	{
		VSL_DEFINE_MOCK_METHOD(get_ImageListIndex)

		VSL_SET_VALIDVALUE(pIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CheckedValidValues
	{
		/*[out,retval]*/ BOOL* pfChecked;
		HRESULT retValue;
	};

	STDMETHOD(get_Checked)(
		/*[out,retval]*/ BOOL* pfChecked)
	{
		VSL_DEFINE_MOCK_METHOD(get_Checked)

		VSL_SET_VALIDVALUE(pfChecked);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_CheckedValidValues
	{
		/*[in]*/ BOOL fChecked;
		HRESULT retValue;
	};

	STDMETHOD(put_Checked)(
		/*[in]*/ BOOL fChecked)
	{
		VSL_DEFINE_MOCK_METHOD(put_Checked)

		VSL_CHECK_VALIDVALUE(fChecked);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_TextValidValues
	{
		/*[out,retval]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(get_Text)(
		/*[out,retval]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(get_Text)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_TextValidValues
	{
		/*[in]*/ BSTR bstrName;
		HRESULT retValue;
	};

	STDMETHOD(put_Text)(
		/*[in]*/ BSTR bstrName)
	{
		VSL_DEFINE_MOCK_METHOD(put_Text)

		VSL_CHECK_VALIDVALUE_BSTR(bstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DocumentValidValues
	{
		/*[out,retval]*/ BSTR* pbstrMkDocument;
		HRESULT retValue;
	};

	STDMETHOD(get_Document)(
		/*[out,retval]*/ BSTR* pbstrMkDocument)
	{
		VSL_DEFINE_MOCK_METHOD(get_Document)

		VSL_SET_VALIDVALUE_BSTR(pbstrMkDocument);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_LineValidValues
	{
		/*[out,retval]*/ long* piLine;
		HRESULT retValue;
	};

	STDMETHOD(get_Line)(
		/*[out,retval]*/ long* piLine)
	{
		VSL_DEFINE_MOCK_METHOD(get_Line)

		VSL_SET_VALIDVALUE(piLine);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ColumnValidValues
	{
		/*[out,retval]*/ long* piCol;
		HRESULT retValue;
	};

	STDMETHOD(get_Column)(
		/*[out,retval]*/ long* piCol)
	{
		VSL_DEFINE_MOCK_METHOD(get_Column)

		VSL_SET_VALIDVALUE(piCol);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CanDeleteValidValues
	{
		/*[out,retval]*/ BOOL* pfCanDelete;
		HRESULT retValue;
	};

	STDMETHOD(get_CanDelete)(
		/*[out,retval]*/ BOOL* pfCanDelete)
	{
		VSL_DEFINE_MOCK_METHOD(get_CanDelete)

		VSL_SET_VALIDVALUE(pfCanDelete);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IsReadOnlyValidValues
	{
		/*[in]*/ VSTASKFIELD field;
		/*[out,retval]*/ BOOL* pfReadOnly;
		HRESULT retValue;
	};

	STDMETHOD(get_IsReadOnly)(
		/*[in]*/ VSTASKFIELD field,
		/*[out,retval]*/ BOOL* pfReadOnly)
	{
		VSL_DEFINE_MOCK_METHOD(get_IsReadOnly)

		VSL_CHECK_VALIDVALUE(field);

		VSL_SET_VALIDVALUE(pfReadOnly);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_HasHelpValidValues
	{
		/*[out,retval]*/ BOOL* pfHasHelp;
		HRESULT retValue;
	};

	STDMETHOD(get_HasHelp)(
		/*[out,retval]*/ BOOL* pfHasHelp)
	{
		VSL_DEFINE_MOCK_METHOD(get_HasHelp)

		VSL_SET_VALIDVALUE(pfHasHelp);

		VSL_RETURN_VALIDVALUES();
	}
	struct NavigateToValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(NavigateTo)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(NavigateTo)

		VSL_RETURN_VALIDVALUES();
	}
	struct NavigateToHelpValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(NavigateToHelp)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(NavigateToHelp)

		VSL_RETURN_VALIDVALUES();
	}
	struct OnFilterTaskValidValues
	{
		/*[in]*/ BOOL fVisible;
		HRESULT retValue;
	};

	STDMETHOD(OnFilterTask)(
		/*[in]*/ BOOL fVisible)
	{
		VSL_DEFINE_MOCK_METHOD(OnFilterTask)

		VSL_CHECK_VALIDVALUE(fVisible);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnDeleteTaskValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(OnDeleteTask)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(OnDeleteTask)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTASKITEM2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTaskList.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTASKLIST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTASKLIST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTaskListNotImpl :
	public IVsTaskList
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTaskListNotImpl)

public:

	typedef IVsTaskList Interface;

	STDMETHOD(RegisterTaskProvider)(
		/*[in]*/ IVsTaskProvider* /*pProvider*/,
		/*[out]*/ VSCOOKIE* /*pdwProviderCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnregisterTaskProvider)(
		/*[in]*/ VSCOOKIE /*dwProviderCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RefreshTasks)(
		/*[in]*/ VSCOOKIE /*dwProviderCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumTaskItems)(
		/*[out]*/ IVsEnumTaskItems** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AutoFilter)(
		/*[in]*/ VSTASKCATEGORY /*cat*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UpdateProviderInfo)(
		/*[in]*/ VSCOOKIE /*dwProviderCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetSilentOutputMode)(
		/*[in]*/ BOOL /*fSilent*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DumpOutput)(
		/*[in]*/ DWORD /*dwReserved*/,
		/*[in]*/ VSTASKCATEGORY /*cat*/,
		/*[in]*/ IStream* /*pstmOutput*/,
		/*[out]*/ BOOL* /*pfOutputWritten*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RegisterCustomCategory)(
		/*[in]*/ REFGUID /*guidCat*/,
		/*[in]*/ DWORD /*dwSortOrder*/,
		/*[out]*/ VSTASKCATEGORY* /*pCat*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnregisterCustomCategory)(
		/*[in]*/ VSTASKCATEGORY /*catAssigned*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AutoFilter2)(
		/*[in]*/ REFGUID /*guidCustomView*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTaskListMockImpl :
	public IVsTaskList,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTaskListMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTaskListMockImpl)

	typedef IVsTaskList Interface;
	struct RegisterTaskProviderValidValues
	{
		/*[in]*/ IVsTaskProvider* pProvider;
		/*[out]*/ VSCOOKIE* pdwProviderCookie;
		HRESULT retValue;
	};

	STDMETHOD(RegisterTaskProvider)(
		/*[in]*/ IVsTaskProvider* pProvider,
		/*[out]*/ VSCOOKIE* pdwProviderCookie)
	{
		VSL_DEFINE_MOCK_METHOD(RegisterTaskProvider)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProvider);

		VSL_SET_VALIDVALUE(pdwProviderCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnregisterTaskProviderValidValues
	{
		/*[in]*/ VSCOOKIE dwProviderCookie;
		HRESULT retValue;
	};

	STDMETHOD(UnregisterTaskProvider)(
		/*[in]*/ VSCOOKIE dwProviderCookie)
	{
		VSL_DEFINE_MOCK_METHOD(UnregisterTaskProvider)

		VSL_CHECK_VALIDVALUE(dwProviderCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct RefreshTasksValidValues
	{
		/*[in]*/ VSCOOKIE dwProviderCookie;
		HRESULT retValue;
	};

	STDMETHOD(RefreshTasks)(
		/*[in]*/ VSCOOKIE dwProviderCookie)
	{
		VSL_DEFINE_MOCK_METHOD(RefreshTasks)

		VSL_CHECK_VALIDVALUE(dwProviderCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumTaskItemsValidValues
	{
		/*[out]*/ IVsEnumTaskItems** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumTaskItems)(
		/*[out]*/ IVsEnumTaskItems** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumTaskItems)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct AutoFilterValidValues
	{
		/*[in]*/ VSTASKCATEGORY cat;
		HRESULT retValue;
	};

	STDMETHOD(AutoFilter)(
		/*[in]*/ VSTASKCATEGORY cat)
	{
		VSL_DEFINE_MOCK_METHOD(AutoFilter)

		VSL_CHECK_VALIDVALUE(cat);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateProviderInfoValidValues
	{
		/*[in]*/ VSCOOKIE dwProviderCookie;
		HRESULT retValue;
	};

	STDMETHOD(UpdateProviderInfo)(
		/*[in]*/ VSCOOKIE dwProviderCookie)
	{
		VSL_DEFINE_MOCK_METHOD(UpdateProviderInfo)

		VSL_CHECK_VALIDVALUE(dwProviderCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetSilentOutputModeValidValues
	{
		/*[in]*/ BOOL fSilent;
		HRESULT retValue;
	};

	STDMETHOD(SetSilentOutputMode)(
		/*[in]*/ BOOL fSilent)
	{
		VSL_DEFINE_MOCK_METHOD(SetSilentOutputMode)

		VSL_CHECK_VALIDVALUE(fSilent);

		VSL_RETURN_VALIDVALUES();
	}
	struct DumpOutputValidValues
	{
		/*[in]*/ DWORD dwReserved;
		/*[in]*/ VSTASKCATEGORY cat;
		/*[in]*/ IStream* pstmOutput;
		/*[out]*/ BOOL* pfOutputWritten;
		HRESULT retValue;
	};

	STDMETHOD(DumpOutput)(
		/*[in]*/ DWORD dwReserved,
		/*[in]*/ VSTASKCATEGORY cat,
		/*[in]*/ IStream* pstmOutput,
		/*[out]*/ BOOL* pfOutputWritten)
	{
		VSL_DEFINE_MOCK_METHOD(DumpOutput)

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_CHECK_VALIDVALUE(cat);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pstmOutput);

		VSL_SET_VALIDVALUE(pfOutputWritten);

		VSL_RETURN_VALIDVALUES();
	}
	struct RegisterCustomCategoryValidValues
	{
		/*[in]*/ REFGUID guidCat;
		/*[in]*/ DWORD dwSortOrder;
		/*[out]*/ VSTASKCATEGORY* pCat;
		HRESULT retValue;
	};

	STDMETHOD(RegisterCustomCategory)(
		/*[in]*/ REFGUID guidCat,
		/*[in]*/ DWORD dwSortOrder,
		/*[out]*/ VSTASKCATEGORY* pCat)
	{
		VSL_DEFINE_MOCK_METHOD(RegisterCustomCategory)

		VSL_CHECK_VALIDVALUE(guidCat);

		VSL_CHECK_VALIDVALUE(dwSortOrder);

		VSL_SET_VALIDVALUE(pCat);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnregisterCustomCategoryValidValues
	{
		/*[in]*/ VSTASKCATEGORY catAssigned;
		HRESULT retValue;
	};

	STDMETHOD(UnregisterCustomCategory)(
		/*[in]*/ VSTASKCATEGORY catAssigned)
	{
		VSL_DEFINE_MOCK_METHOD(UnregisterCustomCategory)

		VSL_CHECK_VALIDVALUE(catAssigned);

		VSL_RETURN_VALIDVALUES();
	}
	struct AutoFilter2ValidValues
	{
		/*[in]*/ REFGUID guidCustomView;
		HRESULT retValue;
	};

	STDMETHOD(AutoFilter2)(
		/*[in]*/ REFGUID guidCustomView)
	{
		VSL_DEFINE_MOCK_METHOD(AutoFilter2)

		VSL_CHECK_VALIDVALUE(guidCustomView);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTASKLIST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTaskProvider2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTASKPROVIDER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTASKPROVIDER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTaskProvider2NotImpl :
	public IVsTaskProvider2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTaskProvider2NotImpl)

public:

	typedef IVsTaskProvider2 Interface;

	STDMETHOD(get_MaintainInitialTaskOrder)(
		/*[out,retval]*/ BOOL* /*bMaintainOrder*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumTaskItems)(
		/*[out]*/ IVsEnumTaskItems** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ImageList)(
		/*[out,retval]*/ HANDLE* /*phImageList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_SubcategoryList)(
		/*[in]*/ ULONG /*cbstr*/,
		/*[out,size_is(cbstr)]*/ BSTR[] /*rgbstr*/,
		/*[out]*/ ULONG* /*pcActual*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ReRegistrationKey)(
		/*[out]*/ BSTR* /*pbstrKey*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnTaskListFinalRelease)(
		/*[in]*/ IVsTaskList* /*pTaskList*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTaskProvider2MockImpl :
	public IVsTaskProvider2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTaskProvider2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTaskProvider2MockImpl)

	typedef IVsTaskProvider2 Interface;
	struct get_MaintainInitialTaskOrderValidValues
	{
		/*[out,retval]*/ BOOL* bMaintainOrder;
		HRESULT retValue;
	};

	STDMETHOD(get_MaintainInitialTaskOrder)(
		/*[out,retval]*/ BOOL* bMaintainOrder)
	{
		VSL_DEFINE_MOCK_METHOD(get_MaintainInitialTaskOrder)

		VSL_SET_VALIDVALUE(bMaintainOrder);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumTaskItemsValidValues
	{
		/*[out]*/ IVsEnumTaskItems** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumTaskItems)(
		/*[out]*/ IVsEnumTaskItems** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumTaskItems)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ImageListValidValues
	{
		/*[out,retval]*/ HANDLE* phImageList;
		HRESULT retValue;
	};

	STDMETHOD(get_ImageList)(
		/*[out,retval]*/ HANDLE* phImageList)
	{
		VSL_DEFINE_MOCK_METHOD(get_ImageList)

		VSL_SET_VALIDVALUE(phImageList);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_SubcategoryListValidValues
	{
		/*[in]*/ ULONG cbstr;
		/*[out,size_is(cbstr)]*/ BSTR* rgbstr;
		/*[out]*/ ULONG* pcActual;
		HRESULT retValue;
	};

	STDMETHOD(get_SubcategoryList)(
		/*[in]*/ ULONG cbstr,
		/*[out,size_is(cbstr)]*/ BSTR rgbstr[],
		/*[out]*/ ULONG* pcActual)
	{
		VSL_DEFINE_MOCK_METHOD(get_SubcategoryList)

		VSL_CHECK_VALIDVALUE(cbstr);

		VSL_SET_VALIDVALUE_MEMCPY(rgbstr, cbstr*sizeof(rgbstr[0]), validValues.cbstr*sizeof(validValues.rgbstr[0]));

		VSL_SET_VALIDVALUE(pcActual);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ReRegistrationKeyValidValues
	{
		/*[out]*/ BSTR* pbstrKey;
		HRESULT retValue;
	};

	STDMETHOD(get_ReRegistrationKey)(
		/*[out]*/ BSTR* pbstrKey)
	{
		VSL_DEFINE_MOCK_METHOD(get_ReRegistrationKey)

		VSL_SET_VALIDVALUE_BSTR(pbstrKey);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnTaskListFinalReleaseValidValues
	{
		/*[in]*/ IVsTaskList* pTaskList;
		HRESULT retValue;
	};

	STDMETHOD(OnTaskListFinalRelease)(
		/*[in]*/ IVsTaskList* pTaskList)
	{
		VSL_DEFINE_MOCK_METHOD(OnTaskListFinalRelease)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pTaskList);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTASKPROVIDER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTaskProvider3.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTASKPROVIDER3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTASKPROVIDER3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTaskProvider3NotImpl :
	public IVsTaskProvider3
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTaskProvider3NotImpl)

public:

	typedef IVsTaskProvider3 Interface;

	STDMETHOD(GetProviderFlags)(
		/*[out]*/ VSTASKPROVIDERFLAGS* /*tpfFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProviderName)(
		/*[out]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProviderGuid)(
		/*[out]*/ GUID* /*pguidProvider*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSurrogateProviderGuid)(
		/*[out]*/ GUID* /*pguidProvider*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProviderToolbar)(
		/*[out]*/ GUID* /*pguidGroup*/,
		/*[out]*/ DWORD* /*pdwID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetColumnCount)(
		/*[out]*/ int* /*pnColumns*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetColumn)(
		/*[in]*/ int /*iColumn*/,
		/*[out]*/ VSTASKCOLUMN* /*pColumn*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnBeginTaskEdit)(
		/*[in]*/ IVsTaskItem* /*pItem*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnEndTaskEdit)(
		/*[in]*/ IVsTaskItem* /*pItem*/,
		/*[in]*/ BOOL /*fCommitChanges*/,
		/*[out]*/ BOOL* /*pfAllowChanges*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTaskProvider3MockImpl :
	public IVsTaskProvider3,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTaskProvider3MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTaskProvider3MockImpl)

	typedef IVsTaskProvider3 Interface;
	struct GetProviderFlagsValidValues
	{
		/*[out]*/ VSTASKPROVIDERFLAGS* tpfFlags;
		HRESULT retValue;
	};

	STDMETHOD(GetProviderFlags)(
		/*[out]*/ VSTASKPROVIDERFLAGS* tpfFlags)
	{
		VSL_DEFINE_MOCK_METHOD(GetProviderFlags)

		VSL_SET_VALIDVALUE(tpfFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetProviderNameValidValues
	{
		/*[out]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(GetProviderName)(
		/*[out]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(GetProviderName)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetProviderGuidValidValues
	{
		/*[out]*/ GUID* pguidProvider;
		HRESULT retValue;
	};

	STDMETHOD(GetProviderGuid)(
		/*[out]*/ GUID* pguidProvider)
	{
		VSL_DEFINE_MOCK_METHOD(GetProviderGuid)

		VSL_SET_VALIDVALUE(pguidProvider);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSurrogateProviderGuidValidValues
	{
		/*[out]*/ GUID* pguidProvider;
		HRESULT retValue;
	};

	STDMETHOD(GetSurrogateProviderGuid)(
		/*[out]*/ GUID* pguidProvider)
	{
		VSL_DEFINE_MOCK_METHOD(GetSurrogateProviderGuid)

		VSL_SET_VALIDVALUE(pguidProvider);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetProviderToolbarValidValues
	{
		/*[out]*/ GUID* pguidGroup;
		/*[out]*/ DWORD* pdwID;
		HRESULT retValue;
	};

	STDMETHOD(GetProviderToolbar)(
		/*[out]*/ GUID* pguidGroup,
		/*[out]*/ DWORD* pdwID)
	{
		VSL_DEFINE_MOCK_METHOD(GetProviderToolbar)

		VSL_SET_VALIDVALUE(pguidGroup);

		VSL_SET_VALIDVALUE(pdwID);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetColumnCountValidValues
	{
		/*[out]*/ int* pnColumns;
		HRESULT retValue;
	};

	STDMETHOD(GetColumnCount)(
		/*[out]*/ int* pnColumns)
	{
		VSL_DEFINE_MOCK_METHOD(GetColumnCount)

		VSL_SET_VALIDVALUE(pnColumns);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetColumnValidValues
	{
		/*[in]*/ int iColumn;
		/*[out]*/ VSTASKCOLUMN* pColumn;
		HRESULT retValue;
	};

	STDMETHOD(GetColumn)(
		/*[in]*/ int iColumn,
		/*[out]*/ VSTASKCOLUMN* pColumn)
	{
		VSL_DEFINE_MOCK_METHOD(GetColumn)

		VSL_CHECK_VALIDVALUE(iColumn);

		VSL_SET_VALIDVALUE(pColumn);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnBeginTaskEditValidValues
	{
		/*[in]*/ IVsTaskItem* pItem;
		HRESULT retValue;
	};

	STDMETHOD(OnBeginTaskEdit)(
		/*[in]*/ IVsTaskItem* pItem)
	{
		VSL_DEFINE_MOCK_METHOD(OnBeginTaskEdit)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pItem);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnEndTaskEditValidValues
	{
		/*[in]*/ IVsTaskItem* pItem;
		/*[in]*/ BOOL fCommitChanges;
		/*[out]*/ BOOL* pfAllowChanges;
		HRESULT retValue;
	};

	STDMETHOD(OnEndTaskEdit)(
		/*[in]*/ IVsTaskItem* pItem,
		/*[in]*/ BOOL fCommitChanges,
		/*[out]*/ BOOL* pfAllowChanges)
	{
		VSL_DEFINE_MOCK_METHOD(OnEndTaskEdit)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pItem);

		VSL_CHECK_VALIDVALUE(fCommitChanges);

		VSL_SET_VALIDVALUE(pfAllowChanges);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTASKPROVIDER3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTextBufferCoordinator.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTEXTBUFFERCOORDINATOR_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTEXTBUFFERCOORDINATOR_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "singlefileeditor.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTextBufferCoordinatorNotImpl :
	public IVsTextBufferCoordinator
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextBufferCoordinatorNotImpl)

public:

	typedef IVsTextBufferCoordinator Interface;

	STDMETHOD(SetBuffers)(
		/*[in]*/ IVsTextLines* /*pPrimaryBuffer*/,
		/*[in]*/ IVsTextLines* /*pSecondaryBuffer*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetSpanMappings)(
		/*[in]*/ long /*cSpans*/,
		/*[in,size_is(cSpans)]*/ NewSpanMapping* /*rgSpans*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(MapPrimaryToSecondarySpan)(
		/*[in]*/ TextSpan /*tsPrimary*/,
		/*[out]*/ TextSpan* /*ptsSecondary*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(MapSecondaryToPrimarySpan)(
		/*[in]*/ TextSpan /*tsSecondary*/,
		/*[out]*/ TextSpan* /*ptsPrimary*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPrimaryBuffer)(
		/*[out]*/ IVsTextLines** /*ppBuffer*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSecondaryBuffer)(
		/*[out]*/ IVsTextLines** /*ppBuffer*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnableReplication)(
		/*[in]*/ DWORD /*bcrd*/,
		/*[in]*/ BOOL /*fEnable*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMappingOfPrimaryPosition)(
		/*[in]*/ long /*lPosition*/,
		/*[out]*/ TextSpan* /*ptsPrimary*/,
		/*[out]*/ TextSpan* /*ptsSecondary*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetBufferMappingModes)(
		/*[in]*/ DWORD /*bcmmPrimary*/,
		/*[in]*/ DWORD /*bcmmSecondary*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumSpans)(
		/*[in]*/ IVsEnumBufferCoordinatorSpans** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTextBufferCoordinatorMockImpl :
	public IVsTextBufferCoordinator,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextBufferCoordinatorMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTextBufferCoordinatorMockImpl)

	typedef IVsTextBufferCoordinator Interface;
	struct SetBuffersValidValues
	{
		/*[in]*/ IVsTextLines* pPrimaryBuffer;
		/*[in]*/ IVsTextLines* pSecondaryBuffer;
		HRESULT retValue;
	};

	STDMETHOD(SetBuffers)(
		/*[in]*/ IVsTextLines* pPrimaryBuffer,
		/*[in]*/ IVsTextLines* pSecondaryBuffer)
	{
		VSL_DEFINE_MOCK_METHOD(SetBuffers)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pPrimaryBuffer);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSecondaryBuffer);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetSpanMappingsValidValues
	{
		/*[in]*/ long cSpans;
		/*[in,size_is(cSpans)]*/ NewSpanMapping* rgSpans;
		HRESULT retValue;
	};

	STDMETHOD(SetSpanMappings)(
		/*[in]*/ long cSpans,
		/*[in,size_is(cSpans)]*/ NewSpanMapping* rgSpans)
	{
		VSL_DEFINE_MOCK_METHOD(SetSpanMappings)

		VSL_CHECK_VALIDVALUE(cSpans);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgSpans, cSpans*sizeof(rgSpans[0]), validValues.cSpans*sizeof(validValues.rgSpans[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct MapPrimaryToSecondarySpanValidValues
	{
		/*[in]*/ TextSpan tsPrimary;
		/*[out]*/ TextSpan* ptsSecondary;
		HRESULT retValue;
	};

	STDMETHOD(MapPrimaryToSecondarySpan)(
		/*[in]*/ TextSpan tsPrimary,
		/*[out]*/ TextSpan* ptsSecondary)
	{
		VSL_DEFINE_MOCK_METHOD(MapPrimaryToSecondarySpan)

		VSL_CHECK_VALIDVALUE(tsPrimary);

		VSL_SET_VALIDVALUE(ptsSecondary);

		VSL_RETURN_VALIDVALUES();
	}
	struct MapSecondaryToPrimarySpanValidValues
	{
		/*[in]*/ TextSpan tsSecondary;
		/*[out]*/ TextSpan* ptsPrimary;
		HRESULT retValue;
	};

	STDMETHOD(MapSecondaryToPrimarySpan)(
		/*[in]*/ TextSpan tsSecondary,
		/*[out]*/ TextSpan* ptsPrimary)
	{
		VSL_DEFINE_MOCK_METHOD(MapSecondaryToPrimarySpan)

		VSL_CHECK_VALIDVALUE(tsSecondary);

		VSL_SET_VALIDVALUE(ptsPrimary);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPrimaryBufferValidValues
	{
		/*[out]*/ IVsTextLines** ppBuffer;
		HRESULT retValue;
	};

	STDMETHOD(GetPrimaryBuffer)(
		/*[out]*/ IVsTextLines** ppBuffer)
	{
		VSL_DEFINE_MOCK_METHOD(GetPrimaryBuffer)

		VSL_SET_VALIDVALUE_INTERFACE(ppBuffer);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSecondaryBufferValidValues
	{
		/*[out]*/ IVsTextLines** ppBuffer;
		HRESULT retValue;
	};

	STDMETHOD(GetSecondaryBuffer)(
		/*[out]*/ IVsTextLines** ppBuffer)
	{
		VSL_DEFINE_MOCK_METHOD(GetSecondaryBuffer)

		VSL_SET_VALIDVALUE_INTERFACE(ppBuffer);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnableReplicationValidValues
	{
		/*[in]*/ DWORD bcrd;
		/*[in]*/ BOOL fEnable;
		HRESULT retValue;
	};

	STDMETHOD(EnableReplication)(
		/*[in]*/ DWORD bcrd,
		/*[in]*/ BOOL fEnable)
	{
		VSL_DEFINE_MOCK_METHOD(EnableReplication)

		VSL_CHECK_VALIDVALUE(bcrd);

		VSL_CHECK_VALIDVALUE(fEnable);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMappingOfPrimaryPositionValidValues
	{
		/*[in]*/ long lPosition;
		/*[out]*/ TextSpan* ptsPrimary;
		/*[out]*/ TextSpan* ptsSecondary;
		HRESULT retValue;
	};

	STDMETHOD(GetMappingOfPrimaryPosition)(
		/*[in]*/ long lPosition,
		/*[out]*/ TextSpan* ptsPrimary,
		/*[out]*/ TextSpan* ptsSecondary)
	{
		VSL_DEFINE_MOCK_METHOD(GetMappingOfPrimaryPosition)

		VSL_CHECK_VALIDVALUE(lPosition);

		VSL_SET_VALIDVALUE(ptsPrimary);

		VSL_SET_VALIDVALUE(ptsSecondary);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetBufferMappingModesValidValues
	{
		/*[in]*/ DWORD bcmmPrimary;
		/*[in]*/ DWORD bcmmSecondary;
		HRESULT retValue;
	};

	STDMETHOD(SetBufferMappingModes)(
		/*[in]*/ DWORD bcmmPrimary,
		/*[in]*/ DWORD bcmmSecondary)
	{
		VSL_DEFINE_MOCK_METHOD(SetBufferMappingModes)

		VSL_CHECK_VALIDVALUE(bcmmPrimary);

		VSL_CHECK_VALIDVALUE(bcmmSecondary);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumSpansValidValues
	{
		/*[in]*/ IVsEnumBufferCoordinatorSpans** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumSpans)(
		/*[in]*/ IVsEnumBufferCoordinatorSpans** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumSpans)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTEXTBUFFERCOORDINATOR_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTextBufferEx.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTEXTBUFFEREX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTEXTBUFFEREX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTextBufferExNotImpl :
	public IVsTextBufferEx
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextBufferExNotImpl)

public:

	typedef IVsTextBufferEx Interface;

	STDMETHOD(GetTrackChanges)(
		/*[out]*/ BOOL* /*pfIsTracking*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetTrackChangesSuppression)(
		/*[in]*/ BOOL /*fSupress*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTextBufferExMockImpl :
	public IVsTextBufferEx,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextBufferExMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTextBufferExMockImpl)

	typedef IVsTextBufferEx Interface;
	struct GetTrackChangesValidValues
	{
		/*[out]*/ BOOL* pfIsTracking;
		HRESULT retValue;
	};

	STDMETHOD(GetTrackChanges)(
		/*[out]*/ BOOL* pfIsTracking)
	{
		VSL_DEFINE_MOCK_METHOD(GetTrackChanges)

		VSL_SET_VALIDVALUE(pfIsTracking);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetTrackChangesSuppressionValidValues
	{
		/*[in]*/ BOOL fSupress;
		HRESULT retValue;
	};

	STDMETHOD(SetTrackChangesSuppression)(
		/*[in]*/ BOOL fSupress)
	{
		VSL_DEFINE_MOCK_METHOD(SetTrackChangesSuppression)

		VSL_CHECK_VALIDVALUE(fSupress);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTEXTBUFFEREX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTestLog.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTESTLOG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTESTLOG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTestLogNotImpl :
	public IVsTestLog
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTestLogNotImpl)

public:

	typedef IVsTestLog Interface;

	STDMETHOD(LogIdleTime)(
		/*[in]*/ LPSTR /*pszIdle*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTestLogMockImpl :
	public IVsTestLog,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTestLogMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTestLogMockImpl)

	typedef IVsTestLog Interface;
	struct LogIdleTimeValidValues
	{
		/*[in]*/ LPSTR pszIdle;
		HRESULT retValue;
	};

	STDMETHOD(LogIdleTime)(
		/*[in]*/ LPSTR pszIdle)
	{
		VSL_DEFINE_MOCK_METHOD(LogIdleTime)

		VSL_CHECK_VALIDVALUE_STRINGA(pszIdle);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTESTLOG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTextColorState.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTEXTCOLORSTATE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTEXTCOLORSTATE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTextColorStateNotImpl :
	public IVsTextColorState
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextColorStateNotImpl)

public:

	typedef IVsTextColorState Interface;

	STDMETHOD(ReColorizeLines)(
		/*[in]*/ long /*iTopLine*/,
		/*[in]*/ long /*iBottomLine*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetColorStateAtStartOfLine)(
		/*[in]*/ long /*iLine*/,
		/*[out]*/ long* /*piState*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTextColorStateMockImpl :
	public IVsTextColorState,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextColorStateMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTextColorStateMockImpl)

	typedef IVsTextColorState Interface;
	struct ReColorizeLinesValidValues
	{
		/*[in]*/ long iTopLine;
		/*[in]*/ long iBottomLine;
		HRESULT retValue;
	};

	STDMETHOD(ReColorizeLines)(
		/*[in]*/ long iTopLine,
		/*[in]*/ long iBottomLine)
	{
		VSL_DEFINE_MOCK_METHOD(ReColorizeLines)

		VSL_CHECK_VALIDVALUE(iTopLine);

		VSL_CHECK_VALIDVALUE(iBottomLine);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetColorStateAtStartOfLineValidValues
	{
		/*[in]*/ long iLine;
		/*[out]*/ long* piState;
		HRESULT retValue;
	};

	STDMETHOD(GetColorStateAtStartOfLine)(
		/*[in]*/ long iLine,
		/*[out]*/ long* piState)
	{
		VSL_DEFINE_MOCK_METHOD(GetColorStateAtStartOfLine)

		VSL_CHECK_VALIDVALUE(iLine);

		VSL_SET_VALIDVALUE(piState);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTEXTCOLORSTATE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTextBuffer.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTEXTBUFFER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTEXTBUFFER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTextBufferNotImpl :
	public IVsTextBuffer
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextBufferNotImpl)

public:

	typedef IVsTextBuffer Interface;

	STDMETHOD(LockBuffer)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnlockBuffer)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(InitializeContent)(
		/*[in]*/ const WCHAR* /*pszText*/,
		/*[in]*/ long /*iLength*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetStateFlags)(
		/*[out]*/ DWORD* /*pdwReadOnlyFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetStateFlags)(
		/*[in]*/ DWORD /*dwReadOnlyFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPositionOfLine)(
		/*[in]*/ long /*iLine*/,
		/*[out]*/ long* /*piPosition*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPositionOfLineIndex)(
		/*[in]*/ long /*iLine*/,
		/*[in]*/ CharIndex /*iIndex*/,
		/*[out]*/ long* /*piPosition*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLineIndexOfPosition)(
		/*[in]*/ long /*iPosition*/,
		/*[out]*/ long* /*piLine*/,
		/*[out]*/ CharIndex* /*piColumn*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLengthOfLine)(
		/*[in]*/ long /*iLine*/,
		/*[out]*/ long* /*piLength*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLineCount)(
		/*[out]*/ long* /*piLineCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSize)(
		/*[out]*/ long* /*piLength*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLanguageServiceID)(
		/*[out]*/ GUID* /*pguidLangService*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetLanguageServiceID)(
		/*[in]*/ REFGUID /*guidLangService*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetUndoManager)(
		/*[out]*/ IOleUndoManager** /*ppUndoManager*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reserved1)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reserved2)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reserved3)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reserved4)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reload)(
		/*[in]*/ BOOL /*fUndoable*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LockBufferEx)(
		/*[in]*/ DWORD /*dwFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnlockBufferEx)(
		/*[in]*/ DWORD /*dwFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLastLineIndex)(
		/*[out]*/ long* /*piLine*/,
		/*[out]*/ long* /*piIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reserved5)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reserved6)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reserved7)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reserved8)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reserved9)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reserved10)()VSL_STDMETHOD_NOTIMPL
};

class IVsTextBufferMockImpl :
	public IVsTextBuffer,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextBufferMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTextBufferMockImpl)

	typedef IVsTextBuffer Interface;
	struct LockBufferValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(LockBuffer)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(LockBuffer)

		VSL_RETURN_VALIDVALUES();
	}
	struct UnlockBufferValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(UnlockBuffer)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(UnlockBuffer)

		VSL_RETURN_VALIDVALUES();
	}
	struct InitializeContentValidValues
	{
		/*[in]*/ WCHAR* pszText;
		/*[in]*/ long iLength;
		HRESULT retValue;
	};

	STDMETHOD(InitializeContent)(
		/*[in]*/ const WCHAR* pszText,
		/*[in]*/ long iLength)
	{
		VSL_DEFINE_MOCK_METHOD(InitializeContent)

		VSL_CHECK_VALIDVALUE_STRINGW(pszText);

		VSL_CHECK_VALIDVALUE(iLength);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetStateFlagsValidValues
	{
		/*[out]*/ DWORD* pdwReadOnlyFlags;
		HRESULT retValue;
	};

	STDMETHOD(GetStateFlags)(
		/*[out]*/ DWORD* pdwReadOnlyFlags)
	{
		VSL_DEFINE_MOCK_METHOD(GetStateFlags)

		VSL_SET_VALIDVALUE(pdwReadOnlyFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetStateFlagsValidValues
	{
		/*[in]*/ DWORD dwReadOnlyFlags;
		HRESULT retValue;
	};

	STDMETHOD(SetStateFlags)(
		/*[in]*/ DWORD dwReadOnlyFlags)
	{
		VSL_DEFINE_MOCK_METHOD(SetStateFlags)

		VSL_CHECK_VALIDVALUE(dwReadOnlyFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPositionOfLineValidValues
	{
		/*[in]*/ long iLine;
		/*[out]*/ long* piPosition;
		HRESULT retValue;
	};

	STDMETHOD(GetPositionOfLine)(
		/*[in]*/ long iLine,
		/*[out]*/ long* piPosition)
	{
		VSL_DEFINE_MOCK_METHOD(GetPositionOfLine)

		VSL_CHECK_VALIDVALUE(iLine);

		VSL_SET_VALIDVALUE(piPosition);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPositionOfLineIndexValidValues
	{
		/*[in]*/ long iLine;
		/*[in]*/ CharIndex iIndex;
		/*[out]*/ long* piPosition;
		HRESULT retValue;
	};

	STDMETHOD(GetPositionOfLineIndex)(
		/*[in]*/ long iLine,
		/*[in]*/ CharIndex iIndex,
		/*[out]*/ long* piPosition)
	{
		VSL_DEFINE_MOCK_METHOD(GetPositionOfLineIndex)

		VSL_CHECK_VALIDVALUE(iLine);

		VSL_CHECK_VALIDVALUE(iIndex);

		VSL_SET_VALIDVALUE(piPosition);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLineIndexOfPositionValidValues
	{
		/*[in]*/ long iPosition;
		/*[out]*/ long* piLine;
		/*[out]*/ CharIndex* piColumn;
		HRESULT retValue;
	};

	STDMETHOD(GetLineIndexOfPosition)(
		/*[in]*/ long iPosition,
		/*[out]*/ long* piLine,
		/*[out]*/ CharIndex* piColumn)
	{
		VSL_DEFINE_MOCK_METHOD(GetLineIndexOfPosition)

		VSL_CHECK_VALIDVALUE(iPosition);

		VSL_SET_VALIDVALUE(piLine);

		VSL_SET_VALIDVALUE(piColumn);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLengthOfLineValidValues
	{
		/*[in]*/ long iLine;
		/*[out]*/ long* piLength;
		HRESULT retValue;
	};

	STDMETHOD(GetLengthOfLine)(
		/*[in]*/ long iLine,
		/*[out]*/ long* piLength)
	{
		VSL_DEFINE_MOCK_METHOD(GetLengthOfLine)

		VSL_CHECK_VALIDVALUE(iLine);

		VSL_SET_VALIDVALUE(piLength);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLineCountValidValues
	{
		/*[out]*/ long* piLineCount;
		HRESULT retValue;
	};

	STDMETHOD(GetLineCount)(
		/*[out]*/ long* piLineCount)
	{
		VSL_DEFINE_MOCK_METHOD(GetLineCount)

		VSL_SET_VALIDVALUE(piLineCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSizeValidValues
	{
		/*[out]*/ long* piLength;
		HRESULT retValue;
	};

	STDMETHOD(GetSize)(
		/*[out]*/ long* piLength)
	{
		VSL_DEFINE_MOCK_METHOD(GetSize)

		VSL_SET_VALIDVALUE(piLength);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLanguageServiceIDValidValues
	{
		/*[out]*/ GUID* pguidLangService;
		HRESULT retValue;
	};

	STDMETHOD(GetLanguageServiceID)(
		/*[out]*/ GUID* pguidLangService)
	{
		VSL_DEFINE_MOCK_METHOD(GetLanguageServiceID)

		VSL_SET_VALIDVALUE(pguidLangService);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetLanguageServiceIDValidValues
	{
		/*[in]*/ REFGUID guidLangService;
		HRESULT retValue;
	};

	STDMETHOD(SetLanguageServiceID)(
		/*[in]*/ REFGUID guidLangService)
	{
		VSL_DEFINE_MOCK_METHOD(SetLanguageServiceID)

		VSL_CHECK_VALIDVALUE(guidLangService);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetUndoManagerValidValues
	{
		/*[out]*/ IOleUndoManager** ppUndoManager;
		HRESULT retValue;
	};

	STDMETHOD(GetUndoManager)(
		/*[out]*/ IOleUndoManager** ppUndoManager)
	{
		VSL_DEFINE_MOCK_METHOD(GetUndoManager)

		VSL_SET_VALIDVALUE_INTERFACE(ppUndoManager);

		VSL_RETURN_VALIDVALUES();
	}
	struct Reserved1ValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reserved1)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reserved1)

		VSL_RETURN_VALIDVALUES();
	}
	struct Reserved2ValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reserved2)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reserved2)

		VSL_RETURN_VALIDVALUES();
	}
	struct Reserved3ValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reserved3)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reserved3)

		VSL_RETURN_VALIDVALUES();
	}
	struct Reserved4ValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reserved4)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reserved4)

		VSL_RETURN_VALIDVALUES();
	}
	struct ReloadValidValues
	{
		/*[in]*/ BOOL fUndoable;
		HRESULT retValue;
	};

	STDMETHOD(Reload)(
		/*[in]*/ BOOL fUndoable)
	{
		VSL_DEFINE_MOCK_METHOD(Reload)

		VSL_CHECK_VALIDVALUE(fUndoable);

		VSL_RETURN_VALIDVALUES();
	}
	struct LockBufferExValidValues
	{
		/*[in]*/ DWORD dwFlags;
		HRESULT retValue;
	};

	STDMETHOD(LockBufferEx)(
		/*[in]*/ DWORD dwFlags)
	{
		VSL_DEFINE_MOCK_METHOD(LockBufferEx)

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnlockBufferExValidValues
	{
		/*[in]*/ DWORD dwFlags;
		HRESULT retValue;
	};

	STDMETHOD(UnlockBufferEx)(
		/*[in]*/ DWORD dwFlags)
	{
		VSL_DEFINE_MOCK_METHOD(UnlockBufferEx)

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLastLineIndexValidValues
	{
		/*[out]*/ long* piLine;
		/*[out]*/ long* piIndex;
		HRESULT retValue;
	};

	STDMETHOD(GetLastLineIndex)(
		/*[out]*/ long* piLine,
		/*[out]*/ long* piIndex)
	{
		VSL_DEFINE_MOCK_METHOD(GetLastLineIndex)

		VSL_SET_VALIDVALUE(piLine);

		VSL_SET_VALIDVALUE(piIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct Reserved5ValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reserved5)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reserved5)

		VSL_RETURN_VALIDVALUES();
	}
	struct Reserved6ValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reserved6)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reserved6)

		VSL_RETURN_VALIDVALUES();
	}
	struct Reserved7ValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reserved7)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reserved7)

		VSL_RETURN_VALIDVALUES();
	}
	struct Reserved8ValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reserved8)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reserved8)

		VSL_RETURN_VALIDVALUES();
	}
	struct Reserved9ValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reserved9)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reserved9)

		VSL_RETURN_VALIDVALUES();
	}
	struct Reserved10ValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reserved10)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reserved10)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTEXTBUFFER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTextBufferProvider.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTEXTBUFFERPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTEXTBUFFERPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTextBufferProviderNotImpl :
	public IVsTextBufferProvider
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextBufferProviderNotImpl)

public:

	typedef IVsTextBufferProvider Interface;

	STDMETHOD(GetTextBuffer)(
		/*[out]*/ IVsTextLines** /*ppTextBuffer*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetTextBuffer)(
		/*[in]*/ IVsTextLines* /*pTextBuffer*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LockTextBuffer)(
		/*[in]*/ BOOL /*fLock*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTextBufferProviderMockImpl :
	public IVsTextBufferProvider,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextBufferProviderMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTextBufferProviderMockImpl)

	typedef IVsTextBufferProvider Interface;
	struct GetTextBufferValidValues
	{
		/*[out]*/ IVsTextLines** ppTextBuffer;
		HRESULT retValue;
	};

	STDMETHOD(GetTextBuffer)(
		/*[out]*/ IVsTextLines** ppTextBuffer)
	{
		VSL_DEFINE_MOCK_METHOD(GetTextBuffer)

		VSL_SET_VALIDVALUE_INTERFACE(ppTextBuffer);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetTextBufferValidValues
	{
		/*[in]*/ IVsTextLines* pTextBuffer;
		HRESULT retValue;
	};

	STDMETHOD(SetTextBuffer)(
		/*[in]*/ IVsTextLines* pTextBuffer)
	{
		VSL_DEFINE_MOCK_METHOD(SetTextBuffer)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pTextBuffer);

		VSL_RETURN_VALIDVALUES();
	}
	struct LockTextBufferValidValues
	{
		/*[in]*/ BOOL fLock;
		HRESULT retValue;
	};

	STDMETHOD(LockTextBuffer)(
		/*[in]*/ BOOL fLock)
	{
		VSL_DEFINE_MOCK_METHOD(LockTextBuffer)

		VSL_CHECK_VALIDVALUE(fLock);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTEXTBUFFERPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTextBufferTempInit.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTEXTBUFFERTEMPINIT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTEXTBUFFERTEMPINIT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTextBufferTempInitNotImpl :
	public IVsTextBufferTempInit
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextBufferTempInitNotImpl)

public:

	typedef IVsTextBufferTempInit Interface;

	STDMETHOD(InitializeContentEx)(
		/*[in]*/ BUFFERINITEX* /*pInit*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTextBufferTempInitMockImpl :
	public IVsTextBufferTempInit,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextBufferTempInitMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTextBufferTempInitMockImpl)

	typedef IVsTextBufferTempInit Interface;
	struct InitializeContentExValidValues
	{
		/*[in]*/ BUFFERINITEX* pInit;
		HRESULT retValue;
	};

	STDMETHOD(InitializeContentEx)(
		/*[in]*/ BUFFERINITEX* pInit)
	{
		VSL_DEFINE_MOCK_METHOD(InitializeContentEx)

		VSL_CHECK_VALIDVALUE_POINTER(pInit);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTEXTBUFFERTEMPINIT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTextEditorPropertyCategoryContainer.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTEXTEDITORPROPERTYCATEGORYCONTAINER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTEXTEDITORPROPERTYCATEGORYCONTAINER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTextEditorPropertyCategoryContainerNotImpl :
	public IVsTextEditorPropertyCategoryContainer
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextEditorPropertyCategoryContainerNotImpl)

public:

	typedef IVsTextEditorPropertyCategoryContainer Interface;

	STDMETHOD(GetPropertyCategory)(
		/*[in]*/ REFGUID /*rguidCategory*/,
		/*[out]*/ IVsTextEditorPropertyContainer** /*ppProp*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTextEditorPropertyCategoryContainerMockImpl :
	public IVsTextEditorPropertyCategoryContainer,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextEditorPropertyCategoryContainerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTextEditorPropertyCategoryContainerMockImpl)

	typedef IVsTextEditorPropertyCategoryContainer Interface;
	struct GetPropertyCategoryValidValues
	{
		/*[in]*/ REFGUID rguidCategory;
		/*[out]*/ IVsTextEditorPropertyContainer** ppProp;
		HRESULT retValue;
	};

	STDMETHOD(GetPropertyCategory)(
		/*[in]*/ REFGUID rguidCategory,
		/*[out]*/ IVsTextEditorPropertyContainer** ppProp)
	{
		VSL_DEFINE_MOCK_METHOD(GetPropertyCategory)

		VSL_CHECK_VALIDVALUE(rguidCategory);

		VSL_SET_VALIDVALUE_INTERFACE(ppProp);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTEXTEDITORPROPERTYCATEGORYCONTAINER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTextEditorPropertyContainer.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTEXTEDITORPROPERTYCONTAINER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTEXTEDITORPROPERTYCONTAINER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTextEditorPropertyContainerNotImpl :
	public IVsTextEditorPropertyContainer
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextEditorPropertyContainerNotImpl)

public:

	typedef IVsTextEditorPropertyContainer Interface;

	STDMETHOD(GetProperty)(
		/*[in]*/ VSEDITPROPID /*idProp*/,
		/*[out]*/ VARIANT* /*pvar*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetProperty)(
		/*[in]*/ VSEDITPROPID /*idProp*/,
		/*[in]*/ VARIANT /*var*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveProperty)(
		/*[in]*/ VSEDITPROPID /*idProp*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTextEditorPropertyContainerMockImpl :
	public IVsTextEditorPropertyContainer,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextEditorPropertyContainerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTextEditorPropertyContainerMockImpl)

	typedef IVsTextEditorPropertyContainer Interface;
	struct GetPropertyValidValues
	{
		/*[in]*/ VSEDITPROPID idProp;
		/*[out]*/ VARIANT* pvar;
		HRESULT retValue;
	};

	STDMETHOD(GetProperty)(
		/*[in]*/ VSEDITPROPID idProp,
		/*[out]*/ VARIANT* pvar)
	{
		VSL_DEFINE_MOCK_METHOD(GetProperty)

		VSL_CHECK_VALIDVALUE(idProp);

		VSL_SET_VALIDVALUE_VARIANT(pvar);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetPropertyValidValues
	{
		/*[in]*/ VSEDITPROPID idProp;
		/*[in]*/ VARIANT var;
		HRESULT retValue;
	};

	STDMETHOD(SetProperty)(
		/*[in]*/ VSEDITPROPID idProp,
		/*[in]*/ VARIANT var)
	{
		VSL_DEFINE_MOCK_METHOD(SetProperty)

		VSL_CHECK_VALIDVALUE(idProp);

		VSL_CHECK_VALIDVALUE(var);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemovePropertyValidValues
	{
		/*[in]*/ VSEDITPROPID idProp;
		HRESULT retValue;
	};

	STDMETHOD(RemoveProperty)(
		/*[in]*/ VSEDITPROPID idProp)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveProperty)

		VSL_CHECK_VALIDVALUE(idProp);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTEXTEDITORPROPERTYCONTAINER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTextFind.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTEXTFIND_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTEXTFIND_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTextFindNotImpl :
	public IVsTextFind
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextFindNotImpl)

public:

	typedef IVsTextFind Interface;

	STDMETHOD(Find)(
		/*[in]*/ const WCHAR* /*pszText*/,
		/*[in]*/ long /*iStartLine*/,
		/*[in]*/ CharIndex /*iStartIndex*/,
		/*[in]*/ long /*iEndLine*/,
		/*[in]*/ CharIndex /*iEndIndex*/,
		/*[in]*/ long /*iFlags*/,
		/*[out]*/ long* /*piLine*/,
		/*[out]*/ long* /*piCol*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTextFindMockImpl :
	public IVsTextFind,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextFindMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTextFindMockImpl)

	typedef IVsTextFind Interface;
	struct FindValidValues
	{
		/*[in]*/ WCHAR* pszText;
		/*[in]*/ long iStartLine;
		/*[in]*/ CharIndex iStartIndex;
		/*[in]*/ long iEndLine;
		/*[in]*/ CharIndex iEndIndex;
		/*[in]*/ long iFlags;
		/*[out]*/ long* piLine;
		/*[out]*/ long* piCol;
		HRESULT retValue;
	};

	STDMETHOD(Find)(
		/*[in]*/ const WCHAR* pszText,
		/*[in]*/ long iStartLine,
		/*[in]*/ CharIndex iStartIndex,
		/*[in]*/ long iEndLine,
		/*[in]*/ CharIndex iEndIndex,
		/*[in]*/ long iFlags,
		/*[out]*/ long* piLine,
		/*[out]*/ long* piCol)
	{
		VSL_DEFINE_MOCK_METHOD(Find)

		VSL_CHECK_VALIDVALUE_STRINGW(pszText);

		VSL_CHECK_VALIDVALUE(iStartLine);

		VSL_CHECK_VALIDVALUE(iStartIndex);

		VSL_CHECK_VALIDVALUE(iEndLine);

		VSL_CHECK_VALIDVALUE(iEndIndex);

		VSL_CHECK_VALIDVALUE(iFlags);

		VSL_SET_VALIDVALUE(piLine);

		VSL_SET_VALIDVALUE(piCol);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTEXTFIND_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTextHidingLayerModule.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTEXTHIDINGLAYERMODULE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTEXTHIDINGLAYERMODULE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTextHidingLayerModuleNotImpl :
	public IVsTextHidingLayerModule
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextHidingLayerModuleNotImpl)

public:

	typedef IVsTextHidingLayerModule Interface;

	STDMETHOD(MakeBaseSpanVisible)(
		/*[in]*/ TextSpan* /*pBaseSpan*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTextHidingLayerModuleMockImpl :
	public IVsTextHidingLayerModule,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextHidingLayerModuleMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTextHidingLayerModuleMockImpl)

	typedef IVsTextHidingLayerModule Interface;
	struct MakeBaseSpanVisibleValidValues
	{
		/*[in]*/ TextSpan* pBaseSpan;
		HRESULT retValue;
	};

	STDMETHOD(MakeBaseSpanVisible)(
		/*[in]*/ TextSpan* pBaseSpan)
	{
		VSL_DEFINE_MOCK_METHOD(MakeBaseSpanVisible)

		VSL_CHECK_VALIDVALUE_POINTER(pBaseSpan);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTEXTHIDINGLAYERMODULE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTextImage.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTEXTIMAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTEXTIMAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTextImageNotImpl :
	public IVsTextImage
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextImageNotImpl)

public:

	typedef IVsTextImage Interface;

	STDMETHOD(GetCharSize)(
		/*[out,retval]*/ LONG* /*pcch*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLineSize)(
		/*[out,retval]*/ LONG* /*pcLines*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetOffsetOfTextAddress)(
		/*[in]*/ TextAddress /*ta*/,
		/*[out,retval]*/ LONG* /*piOffset*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTextAddressOfOffset)(
		/*[in]*/ LONG /*iOffset*/,
		/*[out,retval]*/ TextAddress* /*pta*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Replace)(
		/*[in]*/ DWORD /*dwFlags*/,
		/*[in]*/ const TextSpan* /*pts*/,
		/*[in]*/ LONG /*cch*/,
		/*[in,size_is(cch)]*/ LPCOLESTR /*pchText*/,
		/*[out,retval]*/ TextSpan* /*ptsChanged*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSpanLength)(
		/*[in]*/ const TextSpan* /*pts*/,
		/*[out,retval]*/ LONG* /*pcch*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTextBSTR)(
		/*[in]*/ const TextSpan* /*pts*/,
		/*[out,retval]*/ BSTR* /*pbstrText*/)VSL_STDMETHOD_NOTIMPL

#pragma warning(push)
#pragma warning(disable:4100) // unreferenced formal parameter(cch). It is needed for sal annotation.
	STDMETHOD(GetText)(
		/*[in]*/ const TextSpan* /*pts*/,
		/*[in]*/ LONG cch /*cch*/,
		/*[out,size_is(cch)]*/ _Out_cap_(cch) LPOLESTR /*psz*/)VSL_STDMETHOD_NOTIMPL
#pragma warning(pop)

	STDMETHOD(GetLineLength)(
		/*[in]*/ LONG /*iLine*/,
		/*[out,retval]*/ LONG* /*piLength*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLine)(
		/*[in]*/ DWORD /*grfGet*/,
		/*[in]*/ LONG /*iLine*/,
		/*[in]*/ LONG /*iStartIndex*/,
		/*[in]*/ LONG /*iEndIndex*/,
		/*[out,retval]*/ LINEDATAEX* /*pLineData*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReleaseLine)(
		/*[in]*/ LINEDATAEX* /*pLineData*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AdviseTextImageEvents)(
		/*[in]*/ IVsTextImageEvents* /*pSink*/,
		/*[out,retval]*/ DWORD* /*pCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnadviseTextImageEvents)(
		/*[in]*/ DWORD /*Cookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LockImage)(
		/*[in]*/ DWORD /*grfLock*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnlockImage)(
		/*[in]*/ DWORD /*grfLock*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTextImageMockImpl :
	public IVsTextImage,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextImageMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTextImageMockImpl)

	typedef IVsTextImage Interface;
	struct GetCharSizeValidValues
	{
		/*[out,retval]*/ LONG* pcch;
		HRESULT retValue;
	};

	STDMETHOD(GetCharSize)(
		/*[out,retval]*/ LONG* pcch)
	{
		VSL_DEFINE_MOCK_METHOD(GetCharSize)

		VSL_SET_VALIDVALUE(pcch);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLineSizeValidValues
	{
		/*[out,retval]*/ LONG* pcLines;
		HRESULT retValue;
	};

	STDMETHOD(GetLineSize)(
		/*[out,retval]*/ LONG* pcLines)
	{
		VSL_DEFINE_MOCK_METHOD(GetLineSize)

		VSL_SET_VALIDVALUE(pcLines);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetOffsetOfTextAddressValidValues
	{
		/*[in]*/ TextAddress ta;
		/*[out,retval]*/ LONG* piOffset;
		HRESULT retValue;
	};

	STDMETHOD(GetOffsetOfTextAddress)(
		/*[in]*/ TextAddress ta,
		/*[out,retval]*/ LONG* piOffset)
	{
		VSL_DEFINE_MOCK_METHOD(GetOffsetOfTextAddress)

		VSL_CHECK_VALIDVALUE(ta);

		VSL_SET_VALIDVALUE(piOffset);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTextAddressOfOffsetValidValues
	{
		/*[in]*/ LONG iOffset;
		/*[out,retval]*/ TextAddress* pta;
		HRESULT retValue;
	};

	STDMETHOD(GetTextAddressOfOffset)(
		/*[in]*/ LONG iOffset,
		/*[out,retval]*/ TextAddress* pta)
	{
		VSL_DEFINE_MOCK_METHOD(GetTextAddressOfOffset)

		VSL_CHECK_VALIDVALUE(iOffset);

		VSL_SET_VALIDVALUE(pta);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReplaceValidValues
	{
		/*[in]*/ DWORD dwFlags;
		/*[in]*/ TextSpan* pts;
		/*[in]*/ LONG cch;
		/*[in,size_is(cch)]*/ LPCOLESTR pchText;
		/*[out,retval]*/ TextSpan* ptsChanged;
		HRESULT retValue;
	};

	STDMETHOD(Replace)(
		/*[in]*/ DWORD dwFlags,
		/*[in]*/ const TextSpan* pts,
		/*[in]*/ LONG cch,
		/*[in,size_is(cch)]*/ LPCOLESTR pchText,
		/*[out,retval]*/ TextSpan* ptsChanged)
	{
		VSL_DEFINE_MOCK_METHOD(Replace)

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_CHECK_VALIDVALUE_POINTER(pts);

		VSL_CHECK_VALIDVALUE(cch);

		VSL_CHECK_VALIDVALUE_STRINGW(pchText);

		VSL_SET_VALIDVALUE(ptsChanged);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSpanLengthValidValues
	{
		/*[in]*/ TextSpan* pts;
		/*[out,retval]*/ LONG* pcch;
		HRESULT retValue;
	};

	STDMETHOD(GetSpanLength)(
		/*[in]*/ const TextSpan* pts,
		/*[out,retval]*/ LONG* pcch)
	{
		VSL_DEFINE_MOCK_METHOD(GetSpanLength)

		VSL_CHECK_VALIDVALUE_POINTER(pts);

		VSL_SET_VALIDVALUE(pcch);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTextBSTRValidValues
	{
		/*[in]*/ TextSpan* pts;
		/*[out,retval]*/ BSTR* pbstrText;
		HRESULT retValue;
	};

	STDMETHOD(GetTextBSTR)(
		/*[in]*/ const TextSpan* pts,
		/*[out,retval]*/ BSTR* pbstrText)
	{
		VSL_DEFINE_MOCK_METHOD(GetTextBSTR)

		VSL_CHECK_VALIDVALUE_POINTER(pts);

		VSL_SET_VALIDVALUE_BSTR(pbstrText);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTextValidValues
	{
		/*[in]*/ TextSpan* pts;
		/*[in]*/ LONG cch;
		/*[out,size_is(cch)]*/ LPOLESTR psz;
		HRESULT retValue;
	};

	STDMETHOD(GetText)(
		/*[in]*/ const TextSpan* pts,
		/*[in]*/ LONG cch,
		/*[out,size_is(cch)]*/ _Out_cap_(cch) LPOLESTR psz)
	{
		VSL_DEFINE_MOCK_METHOD(GetText)

		VSL_CHECK_VALIDVALUE_POINTER(pts);

		VSL_CHECK_VALIDVALUE(cch);

		VSL_SET_VALIDVALUE_STRINGW(psz, cch);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLineLengthValidValues
	{
		/*[in]*/ LONG iLine;
		/*[out,retval]*/ LONG* piLength;
		HRESULT retValue;
	};

	STDMETHOD(GetLineLength)(
		/*[in]*/ LONG iLine,
		/*[out,retval]*/ LONG* piLength)
	{
		VSL_DEFINE_MOCK_METHOD(GetLineLength)

		VSL_CHECK_VALIDVALUE(iLine);

		VSL_SET_VALIDVALUE(piLength);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLineValidValues
	{
		/*[in]*/ DWORD grfGet;
		/*[in]*/ LONG iLine;
		/*[in]*/ LONG iStartIndex;
		/*[in]*/ LONG iEndIndex;
		/*[out,retval]*/ LINEDATAEX* pLineData;
		HRESULT retValue;
	};

	STDMETHOD(GetLine)(
		/*[in]*/ DWORD grfGet,
		/*[in]*/ LONG iLine,
		/*[in]*/ LONG iStartIndex,
		/*[in]*/ LONG iEndIndex,
		/*[out,retval]*/ LINEDATAEX* pLineData)
	{
		VSL_DEFINE_MOCK_METHOD(GetLine)

		VSL_CHECK_VALIDVALUE(grfGet);

		VSL_CHECK_VALIDVALUE(iLine);

		VSL_CHECK_VALIDVALUE(iStartIndex);

		VSL_CHECK_VALIDVALUE(iEndIndex);

		VSL_SET_VALIDVALUE(pLineData);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReleaseLineValidValues
	{
		/*[in]*/ LINEDATAEX* pLineData;
		HRESULT retValue;
	};

	STDMETHOD(ReleaseLine)(
		/*[in]*/ LINEDATAEX* pLineData)
	{
		VSL_DEFINE_MOCK_METHOD(ReleaseLine)

		VSL_CHECK_VALIDVALUE_POINTER(pLineData);

		VSL_RETURN_VALIDVALUES();
	}
	struct AdviseTextImageEventsValidValues
	{
		/*[in]*/ IVsTextImageEvents* pSink;
		/*[out,retval]*/ DWORD* pCookie;
		HRESULT retValue;
	};

	STDMETHOD(AdviseTextImageEvents)(
		/*[in]*/ IVsTextImageEvents* pSink,
		/*[out,retval]*/ DWORD* pCookie)
	{
		VSL_DEFINE_MOCK_METHOD(AdviseTextImageEvents)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSink);

		VSL_SET_VALIDVALUE(pCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnadviseTextImageEventsValidValues
	{
		/*[in]*/ DWORD Cookie;
		HRESULT retValue;
	};

	STDMETHOD(UnadviseTextImageEvents)(
		/*[in]*/ DWORD Cookie)
	{
		VSL_DEFINE_MOCK_METHOD(UnadviseTextImageEvents)

		VSL_CHECK_VALIDVALUE(Cookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct LockImageValidValues
	{
		/*[in]*/ DWORD grfLock;
		HRESULT retValue;
	};

	STDMETHOD(LockImage)(
		/*[in]*/ DWORD grfLock)
	{
		VSL_DEFINE_MOCK_METHOD(LockImage)

		VSL_CHECK_VALIDVALUE(grfLock);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnlockImageValidValues
	{
		/*[in]*/ DWORD grfLock;
		HRESULT retValue;
	};

	STDMETHOD(UnlockImage)(
		/*[in]*/ DWORD grfLock)
	{
		VSL_DEFINE_MOCK_METHOD(UnlockImage)

		VSL_CHECK_VALIDVALUE(grfLock);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTEXTIMAGE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTextLayer.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTEXTLAYER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTEXTLAYER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTextLayerNotImpl :
	public IVsTextLayer
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextLayerNotImpl)

public:

	typedef IVsTextLayer Interface;

	STDMETHOD(LocalLineIndexToBase)(
		/*[in]*/ long /*iLocalLine*/,
		/*[in]*/ CharIndex /*iLocalIndex*/,
		/*[out]*/ long* /*piBaseLine*/,
		/*[out]*/ CharIndex* /*piBaseIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(BaseLineIndexToLocal)(
		/*[in]*/ long /*iBaseLine*/,
		/*[in]*/ CharIndex /*iBaseIndex*/,
		/*[out]*/ long* /*piLocalLine*/,
		/*[out]*/ CharIndex* /*piLocalIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LocalLineIndexToDeeperLayer)(
		/*[in]*/ IVsTextLayer* /*pTargetLayer*/,
		/*[in]*/ long /*iLocalLine*/,
		/*[in]*/ CharIndex /*iLocalIndex*/,
		/*[out]*/ long* /*piTargetLine*/,
		/*[out]*/ CharIndex* /*piTargetIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DeeperLayerLineIndexToLocal)(
		/*[in]*/ DWORD /*dwFlags*/,
		/*[in]*/ IVsTextLayer* /*pTargetLayer*/,
		/*[in]*/ long /*iLayerLine*/,
		/*[in]*/ CharIndex /*iLayerIndex*/,
		/*[out]*/ long* /*piLocalLine*/,
		/*[out]*/ CharIndex* /*piLocalIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetBaseBuffer)(
		/*[out]*/ IVsTextLines** /*ppiBuf*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LockBufferEx)(
		/*[in]*/ DWORD /*dwFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnlockBufferEx)(
		/*[in]*/ DWORD /*dwFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLengthOfLine)(
		/*[in]*/ long /*iLine*/,
		/*[out]*/ long* /*piLength*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLineCount)(
		/*[out]*/ long* /*piLineCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLastLineIndex)(
		/*[out]*/ long* /*piLine*/,
		/*[out]*/ long* /*piIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMarkerData)(
		/*[in]*/ long /*iTopLine*/,
		/*[in]*/ long /*iBottomLine*/,
		/*[out]*/ MARKERDATA* /*pMarkerData*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReleaseMarkerData)(
		/*[in]*/ MARKERDATA* /*pMarkerData*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLineDataEx)(
		/*[in]*/ DWORD /*dwFlags*/,
		/*[in]*/ long /*iLine*/,
		/*[in]*/ long /*iStartIndex*/,
		/*[in]*/ long /*iEndIndex*/,
		/*[out]*/ LINEDATAEX* /*pLineData*/,
		/*[in]*/ MARKERDATA* /*pMarkerData*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReleaseLineDataEx)(
		/*[in]*/ LINEDATAEX* /*pLineData*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLineText)(
		/*[in]*/ long /*iStartLine*/,
		/*[in]*/ CharIndex /*iStartIndex*/,
		/*[in]*/ long /*iEndLine*/,
		/*[in]*/ CharIndex /*iEndIndex*/,
		/*[out]*/ BSTR* /*pbstrBuf*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CopyLineText)(
		/*[in]*/ long /*iStartLine*/,
		/*[in]*/ CharIndex /*iStartIndex*/,
		/*[in]*/ long /*iEndLine*/,
		/*[in]*/ CharIndex /*iEndIndex*/,
		/*[in]*/ LPWSTR /*pszBuf*/,
		/*[in,out]*/ long* /*pcchBuf*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReplaceLines)(
		/*[in]*/ long /*iStartLine*/,
		/*[in]*/ CharIndex /*iStartIndex*/,
		/*[in]*/ long /*iEndLine*/,
		/*[in]*/ CharIndex /*iEndIndex*/,
		/*[in]*/ LPCWSTR /*pszText*/,
		/*[in]*/ long /*iNewLen*/,
		/*[out]*/ TextSpan* /*pChangedSpan*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanReplaceLines)(
		/*[in]*/ long /*iStartLine*/,
		/*[in]*/ CharIndex /*iStartIndex*/,
		/*[in]*/ long /*iEndLine*/,
		/*[in]*/ CharIndex /*iEndIndex*/,
		/*[in]*/ long /*iNewLen*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateTrackingPoint)(
		/*[in]*/ long /*iLine*/,
		/*[in]*/ CharIndex /*iIndex*/,
		/*[out]*/ IVsTextTrackingPoint** /*ppMarker*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumLayerMarkers)(
		/*[in]*/ long /*iStartLine*/,
		/*[in]*/ CharIndex /*iStartIndex*/,
		/*[in]*/ long /*iEndLine*/,
		/*[in]*/ CharIndex /*iEndIndex*/,
		/*[in]*/ long /*iMarkerType*/,
		/*[in]*/ DWORD /*dwFlags*/,
		/*[out]*/ IVsEnumLayerMarkers** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReplaceLinesEx)(
		/*[in]*/ DWORD /*dwFlags*/,
		/*[in]*/ long /*iStartLine*/,
		/*[in]*/ CharIndex /*iStartIndex*/,
		/*[in]*/ long /*iEndLine*/,
		/*[in]*/ CharIndex /*iEndIndex*/,
		/*[in]*/ LPCWSTR /*pszText*/,
		/*[in]*/ long /*iNewLen*/,
		/*[out]*/ TextSpan* /*pChangedSpan*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(MapLocalSpansToTextOriginatingLayer)(
		/*[in]*/ DWORD /*dwFlags*/,
		/*[in]*/ IVsEnumTextSpans* /*pLocalSpanEnum*/,
		/*[out]*/ IVsTextLayer** /*ppTargetLayer*/,
		/*[out]*/ IVsEnumTextSpans** /*ppTargetSpanEnum*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTextLayerMockImpl :
	public IVsTextLayer,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextLayerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTextLayerMockImpl)

	typedef IVsTextLayer Interface;
	struct LocalLineIndexToBaseValidValues
	{
		/*[in]*/ long iLocalLine;
		/*[in]*/ CharIndex iLocalIndex;
		/*[out]*/ long* piBaseLine;
		/*[out]*/ CharIndex* piBaseIndex;
		HRESULT retValue;
	};

	STDMETHOD(LocalLineIndexToBase)(
		/*[in]*/ long iLocalLine,
		/*[in]*/ CharIndex iLocalIndex,
		/*[out]*/ long* piBaseLine,
		/*[out]*/ CharIndex* piBaseIndex)
	{
		VSL_DEFINE_MOCK_METHOD(LocalLineIndexToBase)

		VSL_CHECK_VALIDVALUE(iLocalLine);

		VSL_CHECK_VALIDVALUE(iLocalIndex);

		VSL_SET_VALIDVALUE(piBaseLine);

		VSL_SET_VALIDVALUE(piBaseIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct BaseLineIndexToLocalValidValues
	{
		/*[in]*/ long iBaseLine;
		/*[in]*/ CharIndex iBaseIndex;
		/*[out]*/ long* piLocalLine;
		/*[out]*/ CharIndex* piLocalIndex;
		HRESULT retValue;
	};

	STDMETHOD(BaseLineIndexToLocal)(
		/*[in]*/ long iBaseLine,
		/*[in]*/ CharIndex iBaseIndex,
		/*[out]*/ long* piLocalLine,
		/*[out]*/ CharIndex* piLocalIndex)
	{
		VSL_DEFINE_MOCK_METHOD(BaseLineIndexToLocal)

		VSL_CHECK_VALIDVALUE(iBaseLine);

		VSL_CHECK_VALIDVALUE(iBaseIndex);

		VSL_SET_VALIDVALUE(piLocalLine);

		VSL_SET_VALIDVALUE(piLocalIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct LocalLineIndexToDeeperLayerValidValues
	{
		/*[in]*/ IVsTextLayer* pTargetLayer;
		/*[in]*/ long iLocalLine;
		/*[in]*/ CharIndex iLocalIndex;
		/*[out]*/ long* piTargetLine;
		/*[out]*/ CharIndex* piTargetIndex;
		HRESULT retValue;
	};

	STDMETHOD(LocalLineIndexToDeeperLayer)(
		/*[in]*/ IVsTextLayer* pTargetLayer,
		/*[in]*/ long iLocalLine,
		/*[in]*/ CharIndex iLocalIndex,
		/*[out]*/ long* piTargetLine,
		/*[out]*/ CharIndex* piTargetIndex)
	{
		VSL_DEFINE_MOCK_METHOD(LocalLineIndexToDeeperLayer)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pTargetLayer);

		VSL_CHECK_VALIDVALUE(iLocalLine);

		VSL_CHECK_VALIDVALUE(iLocalIndex);

		VSL_SET_VALIDVALUE(piTargetLine);

		VSL_SET_VALIDVALUE(piTargetIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct DeeperLayerLineIndexToLocalValidValues
	{
		/*[in]*/ DWORD dwFlags;
		/*[in]*/ IVsTextLayer* pTargetLayer;
		/*[in]*/ long iLayerLine;
		/*[in]*/ CharIndex iLayerIndex;
		/*[out]*/ long* piLocalLine;
		/*[out]*/ CharIndex* piLocalIndex;
		HRESULT retValue;
	};

	STDMETHOD(DeeperLayerLineIndexToLocal)(
		/*[in]*/ DWORD dwFlags,
		/*[in]*/ IVsTextLayer* pTargetLayer,
		/*[in]*/ long iLayerLine,
		/*[in]*/ CharIndex iLayerIndex,
		/*[out]*/ long* piLocalLine,
		/*[out]*/ CharIndex* piLocalIndex)
	{
		VSL_DEFINE_MOCK_METHOD(DeeperLayerLineIndexToLocal)

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pTargetLayer);

		VSL_CHECK_VALIDVALUE(iLayerLine);

		VSL_CHECK_VALIDVALUE(iLayerIndex);

		VSL_SET_VALIDVALUE(piLocalLine);

		VSL_SET_VALIDVALUE(piLocalIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetBaseBufferValidValues
	{
		/*[out]*/ IVsTextLines** ppiBuf;
		HRESULT retValue;
	};

	STDMETHOD(GetBaseBuffer)(
		/*[out]*/ IVsTextLines** ppiBuf)
	{
		VSL_DEFINE_MOCK_METHOD(GetBaseBuffer)

		VSL_SET_VALIDVALUE_INTERFACE(ppiBuf);

		VSL_RETURN_VALIDVALUES();
	}
	struct LockBufferExValidValues
	{
		/*[in]*/ DWORD dwFlags;
		HRESULT retValue;
	};

	STDMETHOD(LockBufferEx)(
		/*[in]*/ DWORD dwFlags)
	{
		VSL_DEFINE_MOCK_METHOD(LockBufferEx)

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnlockBufferExValidValues
	{
		/*[in]*/ DWORD dwFlags;
		HRESULT retValue;
	};

	STDMETHOD(UnlockBufferEx)(
		/*[in]*/ DWORD dwFlags)
	{
		VSL_DEFINE_MOCK_METHOD(UnlockBufferEx)

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLengthOfLineValidValues
	{
		/*[in]*/ long iLine;
		/*[out]*/ long* piLength;
		HRESULT retValue;
	};

	STDMETHOD(GetLengthOfLine)(
		/*[in]*/ long iLine,
		/*[out]*/ long* piLength)
	{
		VSL_DEFINE_MOCK_METHOD(GetLengthOfLine)

		VSL_CHECK_VALIDVALUE(iLine);

		VSL_SET_VALIDVALUE(piLength);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLineCountValidValues
	{
		/*[out]*/ long* piLineCount;
		HRESULT retValue;
	};

	STDMETHOD(GetLineCount)(
		/*[out]*/ long* piLineCount)
	{
		VSL_DEFINE_MOCK_METHOD(GetLineCount)

		VSL_SET_VALIDVALUE(piLineCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLastLineIndexValidValues
	{
		/*[out]*/ long* piLine;
		/*[out]*/ long* piIndex;
		HRESULT retValue;
	};

	STDMETHOD(GetLastLineIndex)(
		/*[out]*/ long* piLine,
		/*[out]*/ long* piIndex)
	{
		VSL_DEFINE_MOCK_METHOD(GetLastLineIndex)

		VSL_SET_VALIDVALUE(piLine);

		VSL_SET_VALIDVALUE(piIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMarkerDataValidValues
	{
		/*[in]*/ long iTopLine;
		/*[in]*/ long iBottomLine;
		/*[out]*/ MARKERDATA* pMarkerData;
		HRESULT retValue;
	};

	STDMETHOD(GetMarkerData)(
		/*[in]*/ long iTopLine,
		/*[in]*/ long iBottomLine,
		/*[out]*/ MARKERDATA* pMarkerData)
	{
		VSL_DEFINE_MOCK_METHOD(GetMarkerData)

		VSL_CHECK_VALIDVALUE(iTopLine);

		VSL_CHECK_VALIDVALUE(iBottomLine);

		VSL_SET_VALIDVALUE(pMarkerData);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReleaseMarkerDataValidValues
	{
		/*[in]*/ MARKERDATA* pMarkerData;
		HRESULT retValue;
	};

	STDMETHOD(ReleaseMarkerData)(
		/*[in]*/ MARKERDATA* pMarkerData)
	{
		VSL_DEFINE_MOCK_METHOD(ReleaseMarkerData)

		VSL_CHECK_VALIDVALUE_POINTER(pMarkerData);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLineDataExValidValues
	{
		/*[in]*/ DWORD dwFlags;
		/*[in]*/ long iLine;
		/*[in]*/ long iStartIndex;
		/*[in]*/ long iEndIndex;
		/*[out]*/ LINEDATAEX* pLineData;
		/*[in]*/ MARKERDATA* pMarkerData;
		HRESULT retValue;
	};

	STDMETHOD(GetLineDataEx)(
		/*[in]*/ DWORD dwFlags,
		/*[in]*/ long iLine,
		/*[in]*/ long iStartIndex,
		/*[in]*/ long iEndIndex,
		/*[out]*/ LINEDATAEX* pLineData,
		/*[in]*/ MARKERDATA* pMarkerData)
	{
		VSL_DEFINE_MOCK_METHOD(GetLineDataEx)

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_CHECK_VALIDVALUE(iLine);

		VSL_CHECK_VALIDVALUE(iStartIndex);

		VSL_CHECK_VALIDVALUE(iEndIndex);

		VSL_SET_VALIDVALUE(pLineData);

		VSL_CHECK_VALIDVALUE_POINTER(pMarkerData);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReleaseLineDataExValidValues
	{
		/*[in]*/ LINEDATAEX* pLineData;
		HRESULT retValue;
	};

	STDMETHOD(ReleaseLineDataEx)(
		/*[in]*/ LINEDATAEX* pLineData)
	{
		VSL_DEFINE_MOCK_METHOD(ReleaseLineDataEx)

		VSL_CHECK_VALIDVALUE_POINTER(pLineData);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLineTextValidValues
	{
		/*[in]*/ long iStartLine;
		/*[in]*/ CharIndex iStartIndex;
		/*[in]*/ long iEndLine;
		/*[in]*/ CharIndex iEndIndex;
		/*[out]*/ BSTR* pbstrBuf;
		HRESULT retValue;
	};

	STDMETHOD(GetLineText)(
		/*[in]*/ long iStartLine,
		/*[in]*/ CharIndex iStartIndex,
		/*[in]*/ long iEndLine,
		/*[in]*/ CharIndex iEndIndex,
		/*[out]*/ BSTR* pbstrBuf)
	{
		VSL_DEFINE_MOCK_METHOD(GetLineText)

		VSL_CHECK_VALIDVALUE(iStartLine);

		VSL_CHECK_VALIDVALUE(iStartIndex);

		VSL_CHECK_VALIDVALUE(iEndLine);

		VSL_CHECK_VALIDVALUE(iEndIndex);

		VSL_SET_VALIDVALUE_BSTR(pbstrBuf);

		VSL_RETURN_VALIDVALUES();
	}
	struct CopyLineTextValidValues
	{
		/*[in]*/ long iStartLine;
		/*[in]*/ CharIndex iStartIndex;
		/*[in]*/ long iEndLine;
		/*[in]*/ CharIndex iEndIndex;
		/*[in]*/ LPWSTR pszBuf;
		/*[in,out]*/ long* pcchBuf;
		HRESULT retValue;
	};

	STDMETHOD(CopyLineText)(
		/*[in]*/ long iStartLine,
		/*[in]*/ CharIndex iStartIndex,
		/*[in]*/ long iEndLine,
		/*[in]*/ CharIndex iEndIndex,
		/*[in]*/ LPWSTR pszBuf,
		/*[in,out]*/ long* pcchBuf)
	{
		VSL_DEFINE_MOCK_METHOD(CopyLineText)

		VSL_CHECK_VALIDVALUE(iStartLine);

		VSL_CHECK_VALIDVALUE(iStartIndex);

		VSL_CHECK_VALIDVALUE(iEndLine);

		VSL_CHECK_VALIDVALUE(iEndIndex);

		VSL_CHECK_VALIDVALUE_STRINGW(pszBuf);

		VSL_SET_VALIDVALUE(pcchBuf);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReplaceLinesValidValues
	{
		/*[in]*/ long iStartLine;
		/*[in]*/ CharIndex iStartIndex;
		/*[in]*/ long iEndLine;
		/*[in]*/ CharIndex iEndIndex;
		/*[in]*/ LPCWSTR pszText;
		/*[in]*/ long iNewLen;
		/*[out]*/ TextSpan* pChangedSpan;
		HRESULT retValue;
	};

	STDMETHOD(ReplaceLines)(
		/*[in]*/ long iStartLine,
		/*[in]*/ CharIndex iStartIndex,
		/*[in]*/ long iEndLine,
		/*[in]*/ CharIndex iEndIndex,
		/*[in]*/ LPCWSTR pszText,
		/*[in]*/ long iNewLen,
		/*[out]*/ TextSpan* pChangedSpan)
	{
		VSL_DEFINE_MOCK_METHOD(ReplaceLines)

		VSL_CHECK_VALIDVALUE(iStartLine);

		VSL_CHECK_VALIDVALUE(iStartIndex);

		VSL_CHECK_VALIDVALUE(iEndLine);

		VSL_CHECK_VALIDVALUE(iEndIndex);

		VSL_CHECK_VALIDVALUE_STRINGW(pszText);

		VSL_CHECK_VALIDVALUE(iNewLen);

		VSL_SET_VALIDVALUE(pChangedSpan);

		VSL_RETURN_VALIDVALUES();
	}
	struct CanReplaceLinesValidValues
	{
		/*[in]*/ long iStartLine;
		/*[in]*/ CharIndex iStartIndex;
		/*[in]*/ long iEndLine;
		/*[in]*/ CharIndex iEndIndex;
		/*[in]*/ long iNewLen;
		HRESULT retValue;
	};

	STDMETHOD(CanReplaceLines)(
		/*[in]*/ long iStartLine,
		/*[in]*/ CharIndex iStartIndex,
		/*[in]*/ long iEndLine,
		/*[in]*/ CharIndex iEndIndex,
		/*[in]*/ long iNewLen)
	{
		VSL_DEFINE_MOCK_METHOD(CanReplaceLines)

		VSL_CHECK_VALIDVALUE(iStartLine);

		VSL_CHECK_VALIDVALUE(iStartIndex);

		VSL_CHECK_VALIDVALUE(iEndLine);

		VSL_CHECK_VALIDVALUE(iEndIndex);

		VSL_CHECK_VALIDVALUE(iNewLen);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateTrackingPointValidValues
	{
		/*[in]*/ long iLine;
		/*[in]*/ CharIndex iIndex;
		/*[out]*/ IVsTextTrackingPoint** ppMarker;
		HRESULT retValue;
	};

	STDMETHOD(CreateTrackingPoint)(
		/*[in]*/ long iLine,
		/*[in]*/ CharIndex iIndex,
		/*[out]*/ IVsTextTrackingPoint** ppMarker)
	{
		VSL_DEFINE_MOCK_METHOD(CreateTrackingPoint)

		VSL_CHECK_VALIDVALUE(iLine);

		VSL_CHECK_VALIDVALUE(iIndex);

		VSL_SET_VALIDVALUE_INTERFACE(ppMarker);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumLayerMarkersValidValues
	{
		/*[in]*/ long iStartLine;
		/*[in]*/ CharIndex iStartIndex;
		/*[in]*/ long iEndLine;
		/*[in]*/ CharIndex iEndIndex;
		/*[in]*/ long iMarkerType;
		/*[in]*/ DWORD dwFlags;
		/*[out]*/ IVsEnumLayerMarkers** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumLayerMarkers)(
		/*[in]*/ long iStartLine,
		/*[in]*/ CharIndex iStartIndex,
		/*[in]*/ long iEndLine,
		/*[in]*/ CharIndex iEndIndex,
		/*[in]*/ long iMarkerType,
		/*[in]*/ DWORD dwFlags,
		/*[out]*/ IVsEnumLayerMarkers** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumLayerMarkers)

		VSL_CHECK_VALIDVALUE(iStartLine);

		VSL_CHECK_VALIDVALUE(iStartIndex);

		VSL_CHECK_VALIDVALUE(iEndLine);

		VSL_CHECK_VALIDVALUE(iEndIndex);

		VSL_CHECK_VALIDVALUE(iMarkerType);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReplaceLinesExValidValues
	{
		/*[in]*/ DWORD dwFlags;
		/*[in]*/ long iStartLine;
		/*[in]*/ CharIndex iStartIndex;
		/*[in]*/ long iEndLine;
		/*[in]*/ CharIndex iEndIndex;
		/*[in]*/ LPCWSTR pszText;
		/*[in]*/ long iNewLen;
		/*[out]*/ TextSpan* pChangedSpan;
		HRESULT retValue;
	};

	STDMETHOD(ReplaceLinesEx)(
		/*[in]*/ DWORD dwFlags,
		/*[in]*/ long iStartLine,
		/*[in]*/ CharIndex iStartIndex,
		/*[in]*/ long iEndLine,
		/*[in]*/ CharIndex iEndIndex,
		/*[in]*/ LPCWSTR pszText,
		/*[in]*/ long iNewLen,
		/*[out]*/ TextSpan* pChangedSpan)
	{
		VSL_DEFINE_MOCK_METHOD(ReplaceLinesEx)

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_CHECK_VALIDVALUE(iStartLine);

		VSL_CHECK_VALIDVALUE(iStartIndex);

		VSL_CHECK_VALIDVALUE(iEndLine);

		VSL_CHECK_VALIDVALUE(iEndIndex);

		VSL_CHECK_VALIDVALUE_STRINGW(pszText);

		VSL_CHECK_VALIDVALUE(iNewLen);

		VSL_SET_VALIDVALUE(pChangedSpan);

		VSL_RETURN_VALIDVALUES();
	}
	struct MapLocalSpansToTextOriginatingLayerValidValues
	{
		/*[in]*/ DWORD dwFlags;
		/*[in]*/ IVsEnumTextSpans* pLocalSpanEnum;
		/*[out]*/ IVsTextLayer** ppTargetLayer;
		/*[out]*/ IVsEnumTextSpans** ppTargetSpanEnum;
		HRESULT retValue;
	};

	STDMETHOD(MapLocalSpansToTextOriginatingLayer)(
		/*[in]*/ DWORD dwFlags,
		/*[in]*/ IVsEnumTextSpans* pLocalSpanEnum,
		/*[out]*/ IVsTextLayer** ppTargetLayer,
		/*[out]*/ IVsEnumTextSpans** ppTargetSpanEnum)
	{
		VSL_DEFINE_MOCK_METHOD(MapLocalSpansToTextOriginatingLayer)

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pLocalSpanEnum);

		VSL_SET_VALIDVALUE_INTERFACE(ppTargetLayer);

		VSL_SET_VALIDVALUE_INTERFACE(ppTargetSpanEnum);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTEXTLAYER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTextImage2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTEXTIMAGE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTEXTIMAGE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTextImage2NotImpl :
	public IVsTextImage2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextImage2NotImpl)

public:

	typedef IVsTextImage2 Interface;

	STDMETHOD(GetEolTypeEx)(
		/*[in]*/ const LINEDATAEX* /*pld*/,
		/*[out]*/ DWORD* /*piEolType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetEolLengthEx)(
		/*[in]*/ const LINEDATAEX* /*pld*/,
		/*[out]*/ unsigned int* /*piEolType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetEolTextEx)(
		/*[in]*/ const LINEDATAEX* /*pld*/,
		/*[out]*/ BSTR* /*pbstrEolText*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTextImage2MockImpl :
	public IVsTextImage2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextImage2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTextImage2MockImpl)

	typedef IVsTextImage2 Interface;
	struct GetEolTypeExValidValues
	{
		/*[in]*/ LINEDATAEX* pld;
		/*[out]*/ DWORD* piEolType;
		HRESULT retValue;
	};

	STDMETHOD(GetEolTypeEx)(
		/*[in]*/ const LINEDATAEX* pld,
		/*[out]*/ DWORD* piEolType)
	{
		VSL_DEFINE_MOCK_METHOD(GetEolTypeEx)

		VSL_CHECK_VALIDVALUE_POINTER(pld);

		VSL_SET_VALIDVALUE(piEolType);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetEolLengthExValidValues
	{
		/*[in]*/ LINEDATAEX* pld;
		/*[out]*/ unsigned int* piEolType;
		HRESULT retValue;
	};

	STDMETHOD(GetEolLengthEx)(
		/*[in]*/ const LINEDATAEX* pld,
		/*[out]*/ unsigned int* piEolType)
	{
		VSL_DEFINE_MOCK_METHOD(GetEolLengthEx)

		VSL_CHECK_VALIDVALUE_POINTER(pld);

		VSL_SET_VALIDVALUE(piEolType);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetEolTextExValidValues
	{
		/*[in]*/ LINEDATAEX* pld;
		/*[out]*/ BSTR* pbstrEolText;
		HRESULT retValue;
	};

	STDMETHOD(GetEolTextEx)(
		/*[in]*/ const LINEDATAEX* pld,
		/*[out]*/ BSTR* pbstrEolText)
	{
		VSL_DEFINE_MOCK_METHOD(GetEolTextEx)

		VSL_CHECK_VALIDVALUE_POINTER(pld);

		VSL_SET_VALIDVALUE_BSTR(pbstrEolText);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTEXTIMAGE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTextImageUtilities.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTEXTIMAGEUTILITIES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTEXTIMAGEUTILITIES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textfind.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTextImageUtilitiesNotImpl :
	public IVsTextImageUtilities
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextImageUtilitiesNotImpl)

public:

	typedef IVsTextImageUtilities Interface;

	STDMETHOD(GetReplaceText)(
		/*[in]*/ VSFINDOPTIONS /*grfOptions*/,
		/*[in]*/ LPCOLESTR /*pszReplace*/,
		/*[in]*/ IVsTextImage* /*pText*/,
		/*[in]*/ const TextSpan* /*pMatch*/,
		/*[in]*/ IVsTextSpanSet* /*pTags*/,
		/*[out,retval]*/ BSTR* /*pbstrComputedText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LoadTextFile)(
		/*[in]*/ LPCOLESTR /*pszFilename*/,
		/*[in]*/ VSTFF /*vstffIn*/,
		/*[out]*/ VSTFF* /*pvstffOut*/,
		/*[out,retval]*/ BSTR* /*pbstr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LoadTextImageFromFile)(
		/*[in]*/ LPCOLESTR /*pszFilename*/,
		/*[in]*/ IVsTextImage* /*pImage*/,
		/*[in]*/ VSTFF /*vstffIn*/,
		/*[out,retval]*/ VSTFF* /*pvstffOut*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SaveTextImageToFile)(
		/*[in]*/ LPCOLESTR /*pszFilename*/,
		/*[in]*/ IVsTextImage* /*pImage*/,
		/*[in]*/ VSTFF /*vstffIn*/,
		/*[out,retval]*/ VSTFF* /*pvstffOut*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTextFormat)(
		/*[in]*/ VSTFF /*vstffIn*/,
		/*[in]*/ DWORD /*cbData*/,
		/*[in,size_is(cbData)]*/ const BYTE* /*pData*/,
		/*[out,retval]*/ VSTFF* /*pvstffOut*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LoadTextImageFromMemory)(
		/*[in]*/ IVsTextImage* /*pImage*/,
		/*[in]*/ VSTFF /*vstffIn*/,
		/*[in]*/ DWORD /*cbData*/,
		/*[in,size_is(cbData)]*/ const BYTE* /*pData*/,
		/*[out,retval]*/ VSTFF* /*pvstffOut*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SaveTextImageToMemory)(
		/*[in]*/ IVsTextImage* /*pImage*/,
		/*[in]*/ VSTFF /*vstffIn*/,
		/*[in]*/ DWORD /*cbData*/,
		/*[out,size_is(cbData),length_is(*pcbWritten)]*/ BYTE* /*pData*/,
		/*[out]*/ DWORD* /*pcbWritten*/,
		/*[out]*/ VSTFF* /*pvstffOut*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTextImageUtilitiesMockImpl :
	public IVsTextImageUtilities,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextImageUtilitiesMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTextImageUtilitiesMockImpl)

	typedef IVsTextImageUtilities Interface;
	struct GetReplaceTextValidValues
	{
		/*[in]*/ VSFINDOPTIONS grfOptions;
		/*[in]*/ LPCOLESTR pszReplace;
		/*[in]*/ IVsTextImage* pText;
		/*[in]*/ TextSpan* pMatch;
		/*[in]*/ IVsTextSpanSet* pTags;
		/*[out,retval]*/ BSTR* pbstrComputedText;
		HRESULT retValue;
	};

	STDMETHOD(GetReplaceText)(
		/*[in]*/ VSFINDOPTIONS grfOptions,
		/*[in]*/ LPCOLESTR pszReplace,
		/*[in]*/ IVsTextImage* pText,
		/*[in]*/ const TextSpan* pMatch,
		/*[in]*/ IVsTextSpanSet* pTags,
		/*[out,retval]*/ BSTR* pbstrComputedText)
	{
		VSL_DEFINE_MOCK_METHOD(GetReplaceText)

		VSL_CHECK_VALIDVALUE(grfOptions);

		VSL_CHECK_VALIDVALUE_STRINGW(pszReplace);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pText);

		VSL_CHECK_VALIDVALUE_POINTER(pMatch);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pTags);

		VSL_SET_VALIDVALUE_BSTR(pbstrComputedText);

		VSL_RETURN_VALIDVALUES();
	}
	struct LoadTextFileValidValues
	{
		/*[in]*/ LPCOLESTR pszFilename;
		/*[in]*/ VSTFF vstffIn;
		/*[out]*/ VSTFF* pvstffOut;
		/*[out,retval]*/ BSTR* pbstr;
		HRESULT retValue;
	};

	STDMETHOD(LoadTextFile)(
		/*[in]*/ LPCOLESTR pszFilename,
		/*[in]*/ VSTFF vstffIn,
		/*[out]*/ VSTFF* pvstffOut,
		/*[out,retval]*/ BSTR* pbstr)
	{
		VSL_DEFINE_MOCK_METHOD(LoadTextFile)

		VSL_CHECK_VALIDVALUE_STRINGW(pszFilename);

		VSL_CHECK_VALIDVALUE(vstffIn);

		VSL_SET_VALIDVALUE(pvstffOut);

		VSL_SET_VALIDVALUE_BSTR(pbstr);

		VSL_RETURN_VALIDVALUES();
	}
	struct LoadTextImageFromFileValidValues
	{
		/*[in]*/ LPCOLESTR pszFilename;
		/*[in]*/ IVsTextImage* pImage;
		/*[in]*/ VSTFF vstffIn;
		/*[out,retval]*/ VSTFF* pvstffOut;
		HRESULT retValue;
	};

	STDMETHOD(LoadTextImageFromFile)(
		/*[in]*/ LPCOLESTR pszFilename,
		/*[in]*/ IVsTextImage* pImage,
		/*[in]*/ VSTFF vstffIn,
		/*[out,retval]*/ VSTFF* pvstffOut)
	{
		VSL_DEFINE_MOCK_METHOD(LoadTextImageFromFile)

		VSL_CHECK_VALIDVALUE_STRINGW(pszFilename);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pImage);

		VSL_CHECK_VALIDVALUE(vstffIn);

		VSL_SET_VALIDVALUE(pvstffOut);

		VSL_RETURN_VALIDVALUES();
	}
	struct SaveTextImageToFileValidValues
	{
		/*[in]*/ LPCOLESTR pszFilename;
		/*[in]*/ IVsTextImage* pImage;
		/*[in]*/ VSTFF vstffIn;
		/*[out,retval]*/ VSTFF* pvstffOut;
		HRESULT retValue;
	};

	STDMETHOD(SaveTextImageToFile)(
		/*[in]*/ LPCOLESTR pszFilename,
		/*[in]*/ IVsTextImage* pImage,
		/*[in]*/ VSTFF vstffIn,
		/*[out,retval]*/ VSTFF* pvstffOut)
	{
		VSL_DEFINE_MOCK_METHOD(SaveTextImageToFile)

		VSL_CHECK_VALIDVALUE_STRINGW(pszFilename);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pImage);

		VSL_CHECK_VALIDVALUE(vstffIn);

		VSL_SET_VALIDVALUE(pvstffOut);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTextFormatValidValues
	{
		/*[in]*/ VSTFF vstffIn;
		/*[in]*/ DWORD cbData;
		/*[in,size_is(cbData)]*/ BYTE* pData;
		/*[out,retval]*/ VSTFF* pvstffOut;
		HRESULT retValue;
	};

	STDMETHOD(GetTextFormat)(
		/*[in]*/ VSTFF vstffIn,
		/*[in]*/ DWORD cbData,
		/*[in,size_is(cbData)]*/ const BYTE* pData,
		/*[out,retval]*/ VSTFF* pvstffOut)
	{
		VSL_DEFINE_MOCK_METHOD(GetTextFormat)

		VSL_CHECK_VALIDVALUE(vstffIn);

		VSL_CHECK_VALIDVALUE(cbData);

		VSL_CHECK_VALIDVALUE_MEMCMP(pData, cbData*sizeof(pData[0]), validValues.cbData*sizeof(validValues.pData[0]));

		VSL_SET_VALIDVALUE(pvstffOut);

		VSL_RETURN_VALIDVALUES();
	}
	struct LoadTextImageFromMemoryValidValues
	{
		/*[in]*/ IVsTextImage* pImage;
		/*[in]*/ VSTFF vstffIn;
		/*[in]*/ DWORD cbData;
		/*[in,size_is(cbData)]*/ BYTE* pData;
		/*[out,retval]*/ VSTFF* pvstffOut;
		HRESULT retValue;
	};

	STDMETHOD(LoadTextImageFromMemory)(
		/*[in]*/ IVsTextImage* pImage,
		/*[in]*/ VSTFF vstffIn,
		/*[in]*/ DWORD cbData,
		/*[in,size_is(cbData)]*/ const BYTE* pData,
		/*[out,retval]*/ VSTFF* pvstffOut)
	{
		VSL_DEFINE_MOCK_METHOD(LoadTextImageFromMemory)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pImage);

		VSL_CHECK_VALIDVALUE(vstffIn);

		VSL_CHECK_VALIDVALUE(cbData);

		VSL_CHECK_VALIDVALUE_MEMCMP(pData, cbData*sizeof(pData[0]), validValues.cbData*sizeof(validValues.pData[0]));

		VSL_SET_VALIDVALUE(pvstffOut);

		VSL_RETURN_VALIDVALUES();
	}
	struct SaveTextImageToMemoryValidValues
	{
		/*[in]*/ IVsTextImage* pImage;
		/*[in]*/ VSTFF vstffIn;
		/*[in]*/ DWORD cbData;
		/*[out,size_is(cbData),length_is(*pcbWritten)]*/ BYTE* pData;
		/*[out]*/ DWORD* pcbWritten;
		/*[out]*/ VSTFF* pvstffOut;
		HRESULT retValue;
	};

	STDMETHOD(SaveTextImageToMemory)(
		/*[in]*/ IVsTextImage* pImage,
		/*[in]*/ VSTFF vstffIn,
		/*[in]*/ DWORD cbData,
		/*[out,size_is(cbData),length_is(*pcbWritten)]*/ BYTE* pData,
		/*[out]*/ DWORD* pcbWritten,
		/*[out]*/ VSTFF* pvstffOut)
	{
		VSL_DEFINE_MOCK_METHOD(SaveTextImageToMemory)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pImage);

		VSL_CHECK_VALIDVALUE(vstffIn);

		VSL_CHECK_VALIDVALUE(cbData);

		VSL_SET_VALIDVALUE_MEMCPY(pData, cbData*sizeof(pData[0]), *(validValues.pcbWritten)*sizeof(validValues.pData[0]));

		VSL_SET_VALIDVALUE(pcbWritten);

		VSL_SET_VALIDVALUE(pvstffOut);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTEXTIMAGEUTILITIES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTextLineMarker.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTEXTLINEMARKER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTEXTLINEMARKER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTextLineMarkerNotImpl :
	public IVsTextLineMarker
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextLineMarkerNotImpl)

public:

	typedef IVsTextLineMarker Interface;

	STDMETHOD(GetLineBuffer)(
		/*[out]*/ IVsTextLines** /*ppBuffer*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ResetSpan)(
		/*[in]*/ long /*iStartLine*/,
		/*[in]*/ CharIndex /*iStartIndex*/,
		/*[in]*/ long /*iEndLine*/,
		/*[in]*/ CharIndex /*iEndIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCurrentSpan)(
		/*[out]*/ TextSpan* /*pSpan*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetType)(
		/*[out]*/ long* /*piMarkerType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetType)(
		/*[in]*/ long /*iMarkerType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetVisualStyle)(
		/*[out]*/ DWORD* /*pdwFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetVisualStyle)(
		/*[in]*/ DWORD /*dwFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invalidate)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DrawGlyph)(
		/*[in]*/ HDC /*hdc*/,
		/*[in]*/ RECT* /*pRect*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTipText)(
		/*[out,optional]*/ BSTR* /*pbstrText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnadviseClient)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMarkerCommandInfo)(
		/*[in]*/ long /*iItem*/,
		/*[out,custom(uuid_IVsTextMarker,"optional")]*/ BSTR* /*pbstrText*/,
		/*[out]*/ DWORD* /*pcmdf*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ExecMarkerCommand)(
		/*[in]*/ long /*iItem*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetBehavior)(
		/*[out]*/ DWORD* /*pdwBehavior*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetBehavior)(
		/*[in]*/ DWORD /*dwBehavior*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPriorityIndex)(
		/*[out]*/ long* /*piPriorityIndex*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTextLineMarkerMockImpl :
	public IVsTextLineMarker,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextLineMarkerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTextLineMarkerMockImpl)

	typedef IVsTextLineMarker Interface;
	struct GetLineBufferValidValues
	{
		/*[out]*/ IVsTextLines** ppBuffer;
		HRESULT retValue;
	};

	STDMETHOD(GetLineBuffer)(
		/*[out]*/ IVsTextLines** ppBuffer)
	{
		VSL_DEFINE_MOCK_METHOD(GetLineBuffer)

		VSL_SET_VALIDVALUE_INTERFACE(ppBuffer);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetSpanValidValues
	{
		/*[in]*/ long iStartLine;
		/*[in]*/ CharIndex iStartIndex;
		/*[in]*/ long iEndLine;
		/*[in]*/ CharIndex iEndIndex;
		HRESULT retValue;
	};

	STDMETHOD(ResetSpan)(
		/*[in]*/ long iStartLine,
		/*[in]*/ CharIndex iStartIndex,
		/*[in]*/ long iEndLine,
		/*[in]*/ CharIndex iEndIndex)
	{
		VSL_DEFINE_MOCK_METHOD(ResetSpan)

		VSL_CHECK_VALIDVALUE(iStartLine);

		VSL_CHECK_VALIDVALUE(iStartIndex);

		VSL_CHECK_VALIDVALUE(iEndLine);

		VSL_CHECK_VALIDVALUE(iEndIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCurrentSpanValidValues
	{
		/*[out]*/ TextSpan* pSpan;
		HRESULT retValue;
	};

	STDMETHOD(GetCurrentSpan)(
		/*[out]*/ TextSpan* pSpan)
	{
		VSL_DEFINE_MOCK_METHOD(GetCurrentSpan)

		VSL_SET_VALIDVALUE(pSpan);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeValidValues
	{
		/*[out]*/ long* piMarkerType;
		HRESULT retValue;
	};

	STDMETHOD(GetType)(
		/*[out]*/ long* piMarkerType)
	{
		VSL_DEFINE_MOCK_METHOD(GetType)

		VSL_SET_VALIDVALUE(piMarkerType);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetTypeValidValues
	{
		/*[in]*/ long iMarkerType;
		HRESULT retValue;
	};

	STDMETHOD(SetType)(
		/*[in]*/ long iMarkerType)
	{
		VSL_DEFINE_MOCK_METHOD(SetType)

		VSL_CHECK_VALIDVALUE(iMarkerType);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetVisualStyleValidValues
	{
		/*[out]*/ DWORD* pdwFlags;
		HRESULT retValue;
	};

	STDMETHOD(GetVisualStyle)(
		/*[out]*/ DWORD* pdwFlags)
	{
		VSL_DEFINE_MOCK_METHOD(GetVisualStyle)

		VSL_SET_VALIDVALUE(pdwFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetVisualStyleValidValues
	{
		/*[in]*/ DWORD dwFlags;
		HRESULT retValue;
	};

	STDMETHOD(SetVisualStyle)(
		/*[in]*/ DWORD dwFlags)
	{
		VSL_DEFINE_MOCK_METHOD(SetVisualStyle)

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct InvalidateValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Invalidate)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Invalidate)

		VSL_RETURN_VALIDVALUES();
	}
	struct DrawGlyphValidValues
	{
		/*[in]*/ HDC hdc;
		/*[in]*/ RECT* pRect;
		HRESULT retValue;
	};

	STDMETHOD(DrawGlyph)(
		/*[in]*/ HDC hdc,
		/*[in]*/ RECT* pRect)
	{
		VSL_DEFINE_MOCK_METHOD(DrawGlyph)

		VSL_CHECK_VALIDVALUE(hdc);

		VSL_CHECK_VALIDVALUE_POINTER(pRect);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTipTextValidValues
	{
		/*[out,optional]*/ BSTR* pbstrText;
		HRESULT retValue;
	};

	STDMETHOD(GetTipText)(
		/*[out,optional]*/ BSTR* pbstrText)
	{
		VSL_DEFINE_MOCK_METHOD(GetTipText)

		VSL_SET_VALIDVALUE_BSTR(pbstrText);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnadviseClientValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(UnadviseClient)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(UnadviseClient)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMarkerCommandInfoValidValues
	{
		/*[in]*/ long iItem;
		/*[out,custom(uuid_IVsTextMarker,"optional")]*/ BSTR* pbstrText;
		/*[out]*/ DWORD* pcmdf;
		HRESULT retValue;
	};

	STDMETHOD(GetMarkerCommandInfo)(
		/*[in]*/ long iItem,
		/*[out,custom(uuid_IVsTextMarker,"optional")]*/ BSTR* pbstrText,
		/*[out]*/ DWORD* pcmdf)
	{
		VSL_DEFINE_MOCK_METHOD(GetMarkerCommandInfo)

		VSL_CHECK_VALIDVALUE(iItem);

		VSL_SET_VALIDVALUE_BSTR(pbstrText);

		VSL_SET_VALIDVALUE(pcmdf);

		VSL_RETURN_VALIDVALUES();
	}
	struct ExecMarkerCommandValidValues
	{
		/*[in]*/ long iItem;
		HRESULT retValue;
	};

	STDMETHOD(ExecMarkerCommand)(
		/*[in]*/ long iItem)
	{
		VSL_DEFINE_MOCK_METHOD(ExecMarkerCommand)

		VSL_CHECK_VALIDVALUE(iItem);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetBehaviorValidValues
	{
		/*[out]*/ DWORD* pdwBehavior;
		HRESULT retValue;
	};

	STDMETHOD(GetBehavior)(
		/*[out]*/ DWORD* pdwBehavior)
	{
		VSL_DEFINE_MOCK_METHOD(GetBehavior)

		VSL_SET_VALIDVALUE(pdwBehavior);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetBehaviorValidValues
	{
		/*[in]*/ DWORD dwBehavior;
		HRESULT retValue;
	};

	STDMETHOD(SetBehavior)(
		/*[in]*/ DWORD dwBehavior)
	{
		VSL_DEFINE_MOCK_METHOD(SetBehavior)

		VSL_CHECK_VALIDVALUE(dwBehavior);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPriorityIndexValidValues
	{
		/*[out]*/ long* piPriorityIndex;
		HRESULT retValue;
	};

	STDMETHOD(GetPriorityIndex)(
		/*[out]*/ long* piPriorityIndex)
	{
		VSL_DEFINE_MOCK_METHOD(GetPriorityIndex)

		VSL_SET_VALIDVALUE(piPriorityIndex);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTEXTLINEMARKER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTextLayer2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTEXTLAYER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTEXTLAYER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTextLayer2NotImpl :
	public IVsTextLayer2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextLayer2NotImpl)

public:

	typedef IVsTextLayer2 Interface;

	STDMETHOD(GetEolTypeEx)(
		/*[in]*/ const LINEDATAEX* /*pld*/,
		/*[out]*/ DWORD* /*piEolType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetEolLengthEx)(
		/*[in]*/ const LINEDATAEX* /*pld*/,
		/*[out]*/ unsigned int* /*piEolType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetEolTextEx)(
		/*[in]*/ const LINEDATAEX* /*pld*/,
		/*[out]*/ BSTR* /*pbstrEolText*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTextLayer2MockImpl :
	public IVsTextLayer2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextLayer2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTextLayer2MockImpl)

	typedef IVsTextLayer2 Interface;
	struct GetEolTypeExValidValues
	{
		/*[in]*/ LINEDATAEX* pld;
		/*[out]*/ DWORD* piEolType;
		HRESULT retValue;
	};

	STDMETHOD(GetEolTypeEx)(
		/*[in]*/ const LINEDATAEX* pld,
		/*[out]*/ DWORD* piEolType)
	{
		VSL_DEFINE_MOCK_METHOD(GetEolTypeEx)

		VSL_CHECK_VALIDVALUE_POINTER(pld);

		VSL_SET_VALIDVALUE(piEolType);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetEolLengthExValidValues
	{
		/*[in]*/ LINEDATAEX* pld;
		/*[out]*/ unsigned int* piEolType;
		HRESULT retValue;
	};

	STDMETHOD(GetEolLengthEx)(
		/*[in]*/ const LINEDATAEX* pld,
		/*[out]*/ unsigned int* piEolType)
	{
		VSL_DEFINE_MOCK_METHOD(GetEolLengthEx)

		VSL_CHECK_VALIDVALUE_POINTER(pld);

		VSL_SET_VALIDVALUE(piEolType);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetEolTextExValidValues
	{
		/*[in]*/ LINEDATAEX* pld;
		/*[out]*/ BSTR* pbstrEolText;
		HRESULT retValue;
	};

	STDMETHOD(GetEolTextEx)(
		/*[in]*/ const LINEDATAEX* pld,
		/*[out]*/ BSTR* pbstrEolText)
	{
		VSL_DEFINE_MOCK_METHOD(GetEolTextEx)

		VSL_CHECK_VALIDVALUE_POINTER(pld);

		VSL_SET_VALIDVALUE_BSTR(pbstrEolText);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTEXTLAYER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTextLineMarkerEx.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTEXTLINEMARKEREX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTEXTLINEMARKEREX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTextLineMarkerExNotImpl :
	public IVsTextLineMarkerEx
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextLineMarkerExNotImpl)

public:

	typedef IVsTextLineMarkerEx Interface;

	STDMETHOD(GetClientData)(
		/*[out]*/ DWORD_PTR* /*pdwData*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetClientData)(
		/*[in]*/ DWORD_PTR /*dwData*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTextLineMarkerExMockImpl :
	public IVsTextLineMarkerEx,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextLineMarkerExMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTextLineMarkerExMockImpl)

	typedef IVsTextLineMarkerEx Interface;
	struct GetClientDataValidValues
	{
		/*[out]*/ DWORD_PTR* pdwData;
		HRESULT retValue;
	};

	STDMETHOD(GetClientData)(
		/*[out]*/ DWORD_PTR* pdwData)
	{
		VSL_DEFINE_MOCK_METHOD(GetClientData)

		VSL_SET_VALIDVALUE(pdwData);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetClientDataValidValues
	{
		/*[in]*/ DWORD_PTR dwData;
		HRESULT retValue;
	};

	STDMETHOD(SetClientData)(
		/*[in]*/ DWORD_PTR dwData)
	{
		VSL_DEFINE_MOCK_METHOD(SetClientData)

		VSL_CHECK_VALIDVALUE(dwData);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTEXTLINEMARKEREX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTextMacroHelper.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTEXTMACROHELPER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTEXTMACROHELPER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTextMacroHelperNotImpl :
	public IVsTextMacroHelper
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextMacroHelperNotImpl)

public:

	typedef IVsTextMacroHelper Interface;

	STDMETHOD(RecordNewLine)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RecordTypeChar)(
		/*[in]*/ OLECHAR /*wchChar*/,
		/*[in]*/ BOOL /*fIsOvertype*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RecordTypeChars)(
		/*[in]*/ LPCOLESTR /*pwszChars*/,
		/*[in]*/ BOOL /*fIsOvertype*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RecordRemovePreviousTyping)(
		/*[in]*/ LPCOLESTR /*pwszPrevChars*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RecordDelete)(
		/*[in]*/ BOOL /*fLeft*/,
		/*[in]*/ UINT /*uiReps*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RecordDeleteSpace)(
		/*[in]*/ BOOL /*fVertical*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RecordMoveSelectionRel)(
		/*[in]*/ MOVESELECTION_REL_TYPE /*mst*/,
		/*[in]*/ BOOL /*fBackwards*/,
		/*[in]*/ BOOL /*fExtend*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RecordMoveSelectionAbs)(
		/*[in]*/ MOVESELECTION_ABS_TYPE /*mst*/,
		/*[in]*/ BOOL /*fExtend*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RecordCollapseSelection)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RecordSelectAll)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RecordSwapAnchor)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RecordEnterBoxMode)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RecordActivateDocument)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RecordGotoLine)(
		/*[in]*/ long /*iLine*/,
		/*[in]*/ BOOL /*fExtend*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RecordCut)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RecordCopy)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RecordPaste)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RecordBookmarkClearAll)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RecordBookmarkSetClear)(
		/*[in]*/ BOOL /*fSet*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RecordBookmarkNextPrev)(
		/*[in]*/ BOOL /*fNext*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RecordChangeCase)(
		/*[in]*/ CASESELECTION_TYPE /*cst*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RecordIndentUnindent)(
		/*[in]*/ BOOL /*fIndent*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RecordFormatSelection)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RecordTabifyUntabify)(
		/*[in]*/ BOOL /*fTabify*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RecordInsertFile)(
		/*[in]*/ LPCOLESTR /*pwszName*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTextMacroHelperMockImpl :
	public IVsTextMacroHelper,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextMacroHelperMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTextMacroHelperMockImpl)

	typedef IVsTextMacroHelper Interface;
	struct RecordNewLineValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(RecordNewLine)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(RecordNewLine)

		VSL_RETURN_VALIDVALUES();
	}
	struct RecordTypeCharValidValues
	{
		/*[in]*/ OLECHAR wchChar;
		/*[in]*/ BOOL fIsOvertype;
		HRESULT retValue;
	};

	STDMETHOD(RecordTypeChar)(
		/*[in]*/ OLECHAR wchChar,
		/*[in]*/ BOOL fIsOvertype)
	{
		VSL_DEFINE_MOCK_METHOD(RecordTypeChar)

		VSL_CHECK_VALIDVALUE(wchChar);

		VSL_CHECK_VALIDVALUE(fIsOvertype);

		VSL_RETURN_VALIDVALUES();
	}
	struct RecordTypeCharsValidValues
	{
		/*[in]*/ LPCOLESTR pwszChars;
		/*[in]*/ BOOL fIsOvertype;
		HRESULT retValue;
	};

	STDMETHOD(RecordTypeChars)(
		/*[in]*/ LPCOLESTR pwszChars,
		/*[in]*/ BOOL fIsOvertype)
	{
		VSL_DEFINE_MOCK_METHOD(RecordTypeChars)

		VSL_CHECK_VALIDVALUE_STRINGW(pwszChars);

		VSL_CHECK_VALIDVALUE(fIsOvertype);

		VSL_RETURN_VALIDVALUES();
	}
	struct RecordRemovePreviousTypingValidValues
	{
		/*[in]*/ LPCOLESTR pwszPrevChars;
		HRESULT retValue;
	};

	STDMETHOD(RecordRemovePreviousTyping)(
		/*[in]*/ LPCOLESTR pwszPrevChars)
	{
		VSL_DEFINE_MOCK_METHOD(RecordRemovePreviousTyping)

		VSL_CHECK_VALIDVALUE_STRINGW(pwszPrevChars);

		VSL_RETURN_VALIDVALUES();
	}
	struct RecordDeleteValidValues
	{
		/*[in]*/ BOOL fLeft;
		/*[in]*/ UINT uiReps;
		HRESULT retValue;
	};

	STDMETHOD(RecordDelete)(
		/*[in]*/ BOOL fLeft,
		/*[in]*/ UINT uiReps)
	{
		VSL_DEFINE_MOCK_METHOD(RecordDelete)

		VSL_CHECK_VALIDVALUE(fLeft);

		VSL_CHECK_VALIDVALUE(uiReps);

		VSL_RETURN_VALIDVALUES();
	}
	struct RecordDeleteSpaceValidValues
	{
		/*[in]*/ BOOL fVertical;
		HRESULT retValue;
	};

	STDMETHOD(RecordDeleteSpace)(
		/*[in]*/ BOOL fVertical)
	{
		VSL_DEFINE_MOCK_METHOD(RecordDeleteSpace)

		VSL_CHECK_VALIDVALUE(fVertical);

		VSL_RETURN_VALIDVALUES();
	}
	struct RecordMoveSelectionRelValidValues
	{
		/*[in]*/ MOVESELECTION_REL_TYPE mst;
		/*[in]*/ BOOL fBackwards;
		/*[in]*/ BOOL fExtend;
		HRESULT retValue;
	};

	STDMETHOD(RecordMoveSelectionRel)(
		/*[in]*/ MOVESELECTION_REL_TYPE mst,
		/*[in]*/ BOOL fBackwards,
		/*[in]*/ BOOL fExtend)
	{
		VSL_DEFINE_MOCK_METHOD(RecordMoveSelectionRel)

		VSL_CHECK_VALIDVALUE(mst);

		VSL_CHECK_VALIDVALUE(fBackwards);

		VSL_CHECK_VALIDVALUE(fExtend);

		VSL_RETURN_VALIDVALUES();
	}
	struct RecordMoveSelectionAbsValidValues
	{
		/*[in]*/ MOVESELECTION_ABS_TYPE mst;
		/*[in]*/ BOOL fExtend;
		HRESULT retValue;
	};

	STDMETHOD(RecordMoveSelectionAbs)(
		/*[in]*/ MOVESELECTION_ABS_TYPE mst,
		/*[in]*/ BOOL fExtend)
	{
		VSL_DEFINE_MOCK_METHOD(RecordMoveSelectionAbs)

		VSL_CHECK_VALIDVALUE(mst);

		VSL_CHECK_VALIDVALUE(fExtend);

		VSL_RETURN_VALIDVALUES();
	}
	struct RecordCollapseSelectionValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(RecordCollapseSelection)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(RecordCollapseSelection)

		VSL_RETURN_VALIDVALUES();
	}
	struct RecordSelectAllValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(RecordSelectAll)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(RecordSelectAll)

		VSL_RETURN_VALIDVALUES();
	}
	struct RecordSwapAnchorValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(RecordSwapAnchor)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(RecordSwapAnchor)

		VSL_RETURN_VALIDVALUES();
	}
	struct RecordEnterBoxModeValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(RecordEnterBoxMode)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(RecordEnterBoxMode)

		VSL_RETURN_VALIDVALUES();
	}
	struct RecordActivateDocumentValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(RecordActivateDocument)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(RecordActivateDocument)

		VSL_RETURN_VALIDVALUES();
	}
	struct RecordGotoLineValidValues
	{
		/*[in]*/ long iLine;
		/*[in]*/ BOOL fExtend;
		HRESULT retValue;
	};

	STDMETHOD(RecordGotoLine)(
		/*[in]*/ long iLine,
		/*[in]*/ BOOL fExtend)
	{
		VSL_DEFINE_MOCK_METHOD(RecordGotoLine)

		VSL_CHECK_VALIDVALUE(iLine);

		VSL_CHECK_VALIDVALUE(fExtend);

		VSL_RETURN_VALIDVALUES();
	}
	struct RecordCutValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(RecordCut)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(RecordCut)

		VSL_RETURN_VALIDVALUES();
	}
	struct RecordCopyValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(RecordCopy)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(RecordCopy)

		VSL_RETURN_VALIDVALUES();
	}
	struct RecordPasteValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(RecordPaste)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(RecordPaste)

		VSL_RETURN_VALIDVALUES();
	}
	struct RecordBookmarkClearAllValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(RecordBookmarkClearAll)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(RecordBookmarkClearAll)

		VSL_RETURN_VALIDVALUES();
	}
	struct RecordBookmarkSetClearValidValues
	{
		/*[in]*/ BOOL fSet;
		HRESULT retValue;
	};

	STDMETHOD(RecordBookmarkSetClear)(
		/*[in]*/ BOOL fSet)
	{
		VSL_DEFINE_MOCK_METHOD(RecordBookmarkSetClear)

		VSL_CHECK_VALIDVALUE(fSet);

		VSL_RETURN_VALIDVALUES();
	}
	struct RecordBookmarkNextPrevValidValues
	{
		/*[in]*/ BOOL fNext;
		HRESULT retValue;
	};

	STDMETHOD(RecordBookmarkNextPrev)(
		/*[in]*/ BOOL fNext)
	{
		VSL_DEFINE_MOCK_METHOD(RecordBookmarkNextPrev)

		VSL_CHECK_VALIDVALUE(fNext);

		VSL_RETURN_VALIDVALUES();
	}
	struct RecordChangeCaseValidValues
	{
		/*[in]*/ CASESELECTION_TYPE cst;
		HRESULT retValue;
	};

	STDMETHOD(RecordChangeCase)(
		/*[in]*/ CASESELECTION_TYPE cst)
	{
		VSL_DEFINE_MOCK_METHOD(RecordChangeCase)

		VSL_CHECK_VALIDVALUE(cst);

		VSL_RETURN_VALIDVALUES();
	}
	struct RecordIndentUnindentValidValues
	{
		/*[in]*/ BOOL fIndent;
		HRESULT retValue;
	};

	STDMETHOD(RecordIndentUnindent)(
		/*[in]*/ BOOL fIndent)
	{
		VSL_DEFINE_MOCK_METHOD(RecordIndentUnindent)

		VSL_CHECK_VALIDVALUE(fIndent);

		VSL_RETURN_VALIDVALUES();
	}
	struct RecordFormatSelectionValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(RecordFormatSelection)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(RecordFormatSelection)

		VSL_RETURN_VALIDVALUES();
	}
	struct RecordTabifyUntabifyValidValues
	{
		/*[in]*/ BOOL fTabify;
		HRESULT retValue;
	};

	STDMETHOD(RecordTabifyUntabify)(
		/*[in]*/ BOOL fTabify)
	{
		VSL_DEFINE_MOCK_METHOD(RecordTabifyUntabify)

		VSL_CHECK_VALIDVALUE(fTabify);

		VSL_RETURN_VALIDVALUES();
	}
	struct RecordInsertFileValidValues
	{
		/*[in]*/ LPCOLESTR pwszName;
		HRESULT retValue;
	};

	STDMETHOD(RecordInsertFile)(
		/*[in]*/ LPCOLESTR pwszName)
	{
		VSL_DEFINE_MOCK_METHOD(RecordInsertFile)

		VSL_CHECK_VALIDVALUE_STRINGW(pwszName);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTEXTMACROHELPER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTextLines.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTEXTLINES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTEXTLINES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTextLinesNotImpl :
	public IVsTextLines
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextLinesNotImpl)

public:

	typedef IVsTextLines Interface;

	STDMETHOD(GetMarkerData)(
		/*[in]*/ long /*iTopLine*/,
		/*[in]*/ long /*iBottomLine*/,
		/*[out]*/ MARKERDATA* /*pMarkerData*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReleaseMarkerData)(
		/*[in]*/ MARKERDATA* /*pMarkerData*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLineData)(
		/*[in]*/ long /*iLine*/,
		/*[out]*/ LINEDATA* /*pLineData*/,
		/*[in]*/ MARKERDATA* /*pMarkerData*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReleaseLineData)(
		/*[in]*/ LINEDATA* /*pLineData*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLineText)(
		/*[in]*/ long /*iStartLine*/,
		/*[in]*/ CharIndex /*iStartIndex*/,
		/*[in]*/ long /*iEndLine*/,
		/*[in]*/ CharIndex /*iEndIndex*/,
		/*[out]*/ BSTR* /*pbstrBuf*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CopyLineText)(
		/*[in]*/ long /*iStartLine*/,
		/*[in]*/ CharIndex /*iStartIndex*/,
		/*[in]*/ long /*iEndLine*/,
		/*[in]*/ CharIndex /*iEndIndex*/,
		/*[in]*/ LPWSTR /*pszBuf*/,
		/*[in,out]*/ long* /*pcchBuf*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReplaceLines)(
		/*[in]*/ long /*iStartLine*/,
		/*[in]*/ CharIndex /*iStartIndex*/,
		/*[in]*/ long /*iEndLine*/,
		/*[in]*/ CharIndex /*iEndIndex*/,
		/*[in]*/ LPCWSTR /*pszText*/,
		/*[in]*/ long /*iNewLen*/,
		/*[out]*/ TextSpan* /*pChangedSpan*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CanReplaceLines)(
		/*[in]*/ long /*iStartLine*/,
		/*[in]*/ CharIndex /*iStartIndex*/,
		/*[in]*/ long /*iEndLine*/,
		/*[in]*/ CharIndex /*iEndIndex*/,
		/*[in]*/ long /*iNewLen*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateLineMarker)(
		/*[in]*/ long /*iMarkerType*/,
		/*[in]*/ long /*iStartLine*/,
		/*[in]*/ CharIndex /*iStartIndex*/,
		/*[in]*/ long /*iEndLine*/,
		/*[in]*/ CharIndex /*iEndIndex*/,
		/*[in]*/ IVsTextMarkerClient* /*pClient*/,
		/*[out]*/ IVsTextLineMarker** /*ppMarker*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumMarkers)(
		/*[in]*/ long /*iStartLine*/,
		/*[in]*/ CharIndex /*iStartIndex*/,
		/*[in]*/ long /*iEndLine*/,
		/*[in]*/ CharIndex /*iEndIndex*/,
		/*[in]*/ long /*iMarkerType*/,
		/*[in]*/ DWORD /*dwFlags*/,
		/*[out]*/ IVsEnumLineMarkers** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FindMarkerByLineIndex)(
		/*[in]*/ long /*iMarkerType*/,
		/*[in]*/ long /*iStartingLine*/,
		/*[in]*/ CharIndex /*iStartingIndex*/,
		/*[in]*/ DWORD /*dwFlags*/,
		/*[out]*/ IVsTextLineMarker** /*ppMarker*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AdviseTextLinesEvents)(
		/*[in]*/ IVsTextLinesEvents* /*pSink*/,
		/*[out]*/ DWORD* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnadviseTextLinesEvents)(
		/*[in]*/ DWORD /*dwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPairExtents)(
		/*[in]*/ const TextSpan* /*pSpanIn*/,
		/*[out]*/ TextSpan* /*pSpanOut*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReloadLines)(
		/*[in]*/ long /*iStartLine*/,
		/*[in]*/ CharIndex /*iStartIndex*/,
		/*[in]*/ long /*iEndLine*/,
		/*[in]*/ CharIndex /*iEndIndex*/,
		/*[in]*/ LPCWSTR /*pszText*/,
		/*[in]*/ long /*iNewLen*/,
		/*[out]*/ TextSpan* /*pChangedSpan*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IVsTextLinesReserved1)(
		/*[in]*/ long /*iLine*/,
		/*[out]*/ LINEDATA* /*pLineData*/,
		/*[in]*/ BOOL /*fAttributes*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLineDataEx)(
		/*[in]*/ DWORD /*dwFlags*/,
		/*[in]*/ long /*iLine*/,
		/*[in]*/ long /*iStartIndex*/,
		/*[in]*/ long /*iEndIndex*/,
		/*[out]*/ LINEDATAEX* /*pLineData*/,
		/*[in]*/ MARKERDATA* /*pMarkerData*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReleaseLineDataEx)(
		/*[in]*/ LINEDATAEX* /*pLineData*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateEditPoint)(
		/*[in]*/ long /*iLine*/,
		/*[in]*/ CharIndex /*iIndex*/,
		/*[out]*/ IDispatch** /*ppEditPoint*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReplaceLinesEx)(
		/*[in]*/ DWORD /*dwFlags*/,
		/*[in]*/ long /*iStartLine*/,
		/*[in]*/ CharIndex /*iStartIndex*/,
		/*[in]*/ long /*iEndLine*/,
		/*[in]*/ CharIndex /*iEndIndex*/,
		/*[in]*/ LPCWSTR /*pszText*/,
		/*[in]*/ long /*iNewLen*/,
		/*[out]*/ TextSpan* /*pChangedSpan*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateTextPoint)(
		/*[in]*/ long /*iLine*/,
		/*[in]*/ CharIndex /*iIndex*/,
		/*[out]*/ IDispatch** /*ppTextPoint*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LockBuffer)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnlockBuffer)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(InitializeContent)(
		/*[in]*/ const WCHAR* /*pszText*/,
		/*[in]*/ long /*iLength*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetStateFlags)(
		/*[out]*/ DWORD* /*pdwReadOnlyFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetStateFlags)(
		/*[in]*/ DWORD /*dwReadOnlyFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPositionOfLine)(
		/*[in]*/ long /*iLine*/,
		/*[out]*/ long* /*piPosition*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPositionOfLineIndex)(
		/*[in]*/ long /*iLine*/,
		/*[in]*/ CharIndex /*iIndex*/,
		/*[out]*/ long* /*piPosition*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLineIndexOfPosition)(
		/*[in]*/ long /*iPosition*/,
		/*[out]*/ long* /*piLine*/,
		/*[out]*/ CharIndex* /*piColumn*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLengthOfLine)(
		/*[in]*/ long /*iLine*/,
		/*[out]*/ long* /*piLength*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLineCount)(
		/*[out]*/ long* /*piLineCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSize)(
		/*[out]*/ long* /*piLength*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLanguageServiceID)(
		/*[out]*/ GUID* /*pguidLangService*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetLanguageServiceID)(
		/*[in]*/ REFGUID /*guidLangService*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetUndoManager)(
		/*[out]*/ IOleUndoManager** /*ppUndoManager*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reserved1)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reserved2)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reserved3)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reserved4)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reload)(
		/*[in]*/ BOOL /*fUndoable*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LockBufferEx)(
		/*[in]*/ DWORD /*dwFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnlockBufferEx)(
		/*[in]*/ DWORD /*dwFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLastLineIndex)(
		/*[out]*/ long* /*piLine*/,
		/*[out]*/ long* /*piIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reserved5)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reserved6)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reserved7)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reserved8)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reserved9)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Reserved10)()VSL_STDMETHOD_NOTIMPL
};

class IVsTextLinesMockImpl :
	public IVsTextLines,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextLinesMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTextLinesMockImpl)

	typedef IVsTextLines Interface;
	struct GetMarkerDataValidValues
	{
		/*[in]*/ long iTopLine;
		/*[in]*/ long iBottomLine;
		/*[out]*/ MARKERDATA* pMarkerData;
		HRESULT retValue;
	};

	STDMETHOD(GetMarkerData)(
		/*[in]*/ long iTopLine,
		/*[in]*/ long iBottomLine,
		/*[out]*/ MARKERDATA* pMarkerData)
	{
		VSL_DEFINE_MOCK_METHOD(GetMarkerData)

		VSL_CHECK_VALIDVALUE(iTopLine);

		VSL_CHECK_VALIDVALUE(iBottomLine);

		VSL_SET_VALIDVALUE(pMarkerData);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReleaseMarkerDataValidValues
	{
		/*[in]*/ MARKERDATA* pMarkerData;
		HRESULT retValue;
	};

	STDMETHOD(ReleaseMarkerData)(
		/*[in]*/ MARKERDATA* pMarkerData)
	{
		VSL_DEFINE_MOCK_METHOD(ReleaseMarkerData)

		VSL_CHECK_VALIDVALUE_POINTER(pMarkerData);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLineDataValidValues
	{
		/*[in]*/ long iLine;
		/*[out]*/ LINEDATA* pLineData;
		/*[in]*/ MARKERDATA* pMarkerData;
		HRESULT retValue;
	};

	STDMETHOD(GetLineData)(
		/*[in]*/ long iLine,
		/*[out]*/ LINEDATA* pLineData,
		/*[in]*/ MARKERDATA* pMarkerData)
	{
		VSL_DEFINE_MOCK_METHOD(GetLineData)

		VSL_CHECK_VALIDVALUE(iLine);

		VSL_SET_VALIDVALUE(pLineData);

		VSL_CHECK_VALIDVALUE_POINTER(pMarkerData);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReleaseLineDataValidValues
	{
		/*[in]*/ LINEDATA* pLineData;
		HRESULT retValue;
	};

	STDMETHOD(ReleaseLineData)(
		/*[in]*/ LINEDATA* pLineData)
	{
		VSL_DEFINE_MOCK_METHOD(ReleaseLineData)

		VSL_CHECK_VALIDVALUE_POINTER(pLineData);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLineTextValidValues
	{
		/*[in]*/ long iStartLine;
		/*[in]*/ CharIndex iStartIndex;
		/*[in]*/ long iEndLine;
		/*[in]*/ CharIndex iEndIndex;
		/*[out]*/ BSTR* pbstrBuf;
		HRESULT retValue;
	};

	STDMETHOD(GetLineText)(
		/*[in]*/ long iStartLine,
		/*[in]*/ CharIndex iStartIndex,
		/*[in]*/ long iEndLine,
		/*[in]*/ CharIndex iEndIndex,
		/*[out]*/ BSTR* pbstrBuf)
	{
		VSL_DEFINE_MOCK_METHOD(GetLineText)

		VSL_CHECK_VALIDVALUE(iStartLine);

		VSL_CHECK_VALIDVALUE(iStartIndex);

		VSL_CHECK_VALIDVALUE(iEndLine);

		VSL_CHECK_VALIDVALUE(iEndIndex);

		VSL_SET_VALIDVALUE_BSTR(pbstrBuf);

		VSL_RETURN_VALIDVALUES();
	}
	struct CopyLineTextValidValues
	{
		/*[in]*/ long iStartLine;
		/*[in]*/ CharIndex iStartIndex;
		/*[in]*/ long iEndLine;
		/*[in]*/ CharIndex iEndIndex;
		/*[in]*/ LPWSTR pszBuf;
		/*[in,out]*/ long* pcchBuf;
		HRESULT retValue;
	};

	STDMETHOD(CopyLineText)(
		/*[in]*/ long iStartLine,
		/*[in]*/ CharIndex iStartIndex,
		/*[in]*/ long iEndLine,
		/*[in]*/ CharIndex iEndIndex,
		/*[in]*/ LPWSTR pszBuf,
		/*[in,out]*/ long* pcchBuf)
	{
		VSL_DEFINE_MOCK_METHOD(CopyLineText)

		VSL_CHECK_VALIDVALUE(iStartLine);

		VSL_CHECK_VALIDVALUE(iStartIndex);

		VSL_CHECK_VALIDVALUE(iEndLine);

		VSL_CHECK_VALIDVALUE(iEndIndex);

		VSL_CHECK_VALIDVALUE_STRINGW(pszBuf);

		VSL_SET_VALIDVALUE(pcchBuf);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReplaceLinesValidValues
	{
		/*[in]*/ long iStartLine;
		/*[in]*/ CharIndex iStartIndex;
		/*[in]*/ long iEndLine;
		/*[in]*/ CharIndex iEndIndex;
		/*[in]*/ LPCWSTR pszText;
		/*[in]*/ long iNewLen;
		/*[out]*/ TextSpan* pChangedSpan;
		HRESULT retValue;
	};

	STDMETHOD(ReplaceLines)(
		/*[in]*/ long iStartLine,
		/*[in]*/ CharIndex iStartIndex,
		/*[in]*/ long iEndLine,
		/*[in]*/ CharIndex iEndIndex,
		/*[in]*/ LPCWSTR pszText,
		/*[in]*/ long iNewLen,
		/*[out]*/ TextSpan* pChangedSpan)
	{
		VSL_DEFINE_MOCK_METHOD(ReplaceLines)

		VSL_CHECK_VALIDVALUE(iStartLine);

		VSL_CHECK_VALIDVALUE(iStartIndex);

		VSL_CHECK_VALIDVALUE(iEndLine);

		VSL_CHECK_VALIDVALUE(iEndIndex);

		VSL_CHECK_VALIDVALUE_STRINGW(pszText);

		VSL_CHECK_VALIDVALUE(iNewLen);

		VSL_SET_VALIDVALUE(pChangedSpan);

		VSL_RETURN_VALIDVALUES();
	}
	struct CanReplaceLinesValidValues
	{
		/*[in]*/ long iStartLine;
		/*[in]*/ CharIndex iStartIndex;
		/*[in]*/ long iEndLine;
		/*[in]*/ CharIndex iEndIndex;
		/*[in]*/ long iNewLen;
		HRESULT retValue;
	};

	STDMETHOD(CanReplaceLines)(
		/*[in]*/ long iStartLine,
		/*[in]*/ CharIndex iStartIndex,
		/*[in]*/ long iEndLine,
		/*[in]*/ CharIndex iEndIndex,
		/*[in]*/ long iNewLen)
	{
		VSL_DEFINE_MOCK_METHOD(CanReplaceLines)

		VSL_CHECK_VALIDVALUE(iStartLine);

		VSL_CHECK_VALIDVALUE(iStartIndex);

		VSL_CHECK_VALIDVALUE(iEndLine);

		VSL_CHECK_VALIDVALUE(iEndIndex);

		VSL_CHECK_VALIDVALUE(iNewLen);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateLineMarkerValidValues
	{
		/*[in]*/ long iMarkerType;
		/*[in]*/ long iStartLine;
		/*[in]*/ CharIndex iStartIndex;
		/*[in]*/ long iEndLine;
		/*[in]*/ CharIndex iEndIndex;
		/*[in]*/ IVsTextMarkerClient* pClient;
		/*[out]*/ IVsTextLineMarker** ppMarker;
		HRESULT retValue;
	};

	STDMETHOD(CreateLineMarker)(
		/*[in]*/ long iMarkerType,
		/*[in]*/ long iStartLine,
		/*[in]*/ CharIndex iStartIndex,
		/*[in]*/ long iEndLine,
		/*[in]*/ CharIndex iEndIndex,
		/*[in]*/ IVsTextMarkerClient* pClient,
		/*[out]*/ IVsTextLineMarker** ppMarker)
	{
		VSL_DEFINE_MOCK_METHOD(CreateLineMarker)

		VSL_CHECK_VALIDVALUE(iMarkerType);

		VSL_CHECK_VALIDVALUE(iStartLine);

		VSL_CHECK_VALIDVALUE(iStartIndex);

		VSL_CHECK_VALIDVALUE(iEndLine);

		VSL_CHECK_VALIDVALUE(iEndIndex);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pClient);

		VSL_SET_VALIDVALUE_INTERFACE(ppMarker);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumMarkersValidValues
	{
		/*[in]*/ long iStartLine;
		/*[in]*/ CharIndex iStartIndex;
		/*[in]*/ long iEndLine;
		/*[in]*/ CharIndex iEndIndex;
		/*[in]*/ long iMarkerType;
		/*[in]*/ DWORD dwFlags;
		/*[out]*/ IVsEnumLineMarkers** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumMarkers)(
		/*[in]*/ long iStartLine,
		/*[in]*/ CharIndex iStartIndex,
		/*[in]*/ long iEndLine,
		/*[in]*/ CharIndex iEndIndex,
		/*[in]*/ long iMarkerType,
		/*[in]*/ DWORD dwFlags,
		/*[out]*/ IVsEnumLineMarkers** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumMarkers)

		VSL_CHECK_VALIDVALUE(iStartLine);

		VSL_CHECK_VALIDVALUE(iStartIndex);

		VSL_CHECK_VALIDVALUE(iEndLine);

		VSL_CHECK_VALIDVALUE(iEndIndex);

		VSL_CHECK_VALIDVALUE(iMarkerType);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct FindMarkerByLineIndexValidValues
	{
		/*[in]*/ long iMarkerType;
		/*[in]*/ long iStartingLine;
		/*[in]*/ CharIndex iStartingIndex;
		/*[in]*/ DWORD dwFlags;
		/*[out]*/ IVsTextLineMarker** ppMarker;
		HRESULT retValue;
	};

	STDMETHOD(FindMarkerByLineIndex)(
		/*[in]*/ long iMarkerType,
		/*[in]*/ long iStartingLine,
		/*[in]*/ CharIndex iStartingIndex,
		/*[in]*/ DWORD dwFlags,
		/*[out]*/ IVsTextLineMarker** ppMarker)
	{
		VSL_DEFINE_MOCK_METHOD(FindMarkerByLineIndex)

		VSL_CHECK_VALIDVALUE(iMarkerType);

		VSL_CHECK_VALIDVALUE(iStartingLine);

		VSL_CHECK_VALIDVALUE(iStartingIndex);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_SET_VALIDVALUE_INTERFACE(ppMarker);

		VSL_RETURN_VALIDVALUES();
	}
	struct AdviseTextLinesEventsValidValues
	{
		/*[in]*/ IVsTextLinesEvents* pSink;
		/*[out]*/ DWORD* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(AdviseTextLinesEvents)(
		/*[in]*/ IVsTextLinesEvents* pSink,
		/*[out]*/ DWORD* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(AdviseTextLinesEvents)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSink);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnadviseTextLinesEventsValidValues
	{
		/*[in]*/ DWORD dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(UnadviseTextLinesEvents)(
		/*[in]*/ DWORD dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(UnadviseTextLinesEvents)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPairExtentsValidValues
	{
		/*[in]*/ TextSpan* pSpanIn;
		/*[out]*/ TextSpan* pSpanOut;
		HRESULT retValue;
	};

	STDMETHOD(GetPairExtents)(
		/*[in]*/ const TextSpan* pSpanIn,
		/*[out]*/ TextSpan* pSpanOut)
	{
		VSL_DEFINE_MOCK_METHOD(GetPairExtents)

		VSL_CHECK_VALIDVALUE_POINTER(pSpanIn);

		VSL_SET_VALIDVALUE(pSpanOut);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReloadLinesValidValues
	{
		/*[in]*/ long iStartLine;
		/*[in]*/ CharIndex iStartIndex;
		/*[in]*/ long iEndLine;
		/*[in]*/ CharIndex iEndIndex;
		/*[in]*/ LPCWSTR pszText;
		/*[in]*/ long iNewLen;
		/*[out]*/ TextSpan* pChangedSpan;
		HRESULT retValue;
	};

	STDMETHOD(ReloadLines)(
		/*[in]*/ long iStartLine,
		/*[in]*/ CharIndex iStartIndex,
		/*[in]*/ long iEndLine,
		/*[in]*/ CharIndex iEndIndex,
		/*[in]*/ LPCWSTR pszText,
		/*[in]*/ long iNewLen,
		/*[out]*/ TextSpan* pChangedSpan)
	{
		VSL_DEFINE_MOCK_METHOD(ReloadLines)

		VSL_CHECK_VALIDVALUE(iStartLine);

		VSL_CHECK_VALIDVALUE(iStartIndex);

		VSL_CHECK_VALIDVALUE(iEndLine);

		VSL_CHECK_VALIDVALUE(iEndIndex);

		VSL_CHECK_VALIDVALUE_STRINGW(pszText);

		VSL_CHECK_VALIDVALUE(iNewLen);

		VSL_SET_VALIDVALUE(pChangedSpan);

		VSL_RETURN_VALIDVALUES();
	}
	struct IVsTextLinesReserved1ValidValues
	{
		/*[in]*/ long iLine;
		/*[out]*/ LINEDATA* pLineData;
		/*[in]*/ BOOL fAttributes;
		HRESULT retValue;
	};

	STDMETHOD(IVsTextLinesReserved1)(
		/*[in]*/ long iLine,
		/*[out]*/ LINEDATA* pLineData,
		/*[in]*/ BOOL fAttributes)
	{
		VSL_DEFINE_MOCK_METHOD(IVsTextLinesReserved1)

		VSL_CHECK_VALIDVALUE(iLine);

		VSL_SET_VALIDVALUE(pLineData);

		VSL_CHECK_VALIDVALUE(fAttributes);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLineDataExValidValues
	{
		/*[in]*/ DWORD dwFlags;
		/*[in]*/ long iLine;
		/*[in]*/ long iStartIndex;
		/*[in]*/ long iEndIndex;
		/*[out]*/ LINEDATAEX* pLineData;
		/*[in]*/ MARKERDATA* pMarkerData;
		HRESULT retValue;
	};

	STDMETHOD(GetLineDataEx)(
		/*[in]*/ DWORD dwFlags,
		/*[in]*/ long iLine,
		/*[in]*/ long iStartIndex,
		/*[in]*/ long iEndIndex,
		/*[out]*/ LINEDATAEX* pLineData,
		/*[in]*/ MARKERDATA* pMarkerData)
	{
		VSL_DEFINE_MOCK_METHOD(GetLineDataEx)

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_CHECK_VALIDVALUE(iLine);

		VSL_CHECK_VALIDVALUE(iStartIndex);

		VSL_CHECK_VALIDVALUE(iEndIndex);

		VSL_SET_VALIDVALUE(pLineData);

		VSL_CHECK_VALIDVALUE_POINTER(pMarkerData);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReleaseLineDataExValidValues
	{
		/*[in]*/ LINEDATAEX* pLineData;
		HRESULT retValue;
	};

	STDMETHOD(ReleaseLineDataEx)(
		/*[in]*/ LINEDATAEX* pLineData)
	{
		VSL_DEFINE_MOCK_METHOD(ReleaseLineDataEx)

		VSL_CHECK_VALIDVALUE_POINTER(pLineData);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateEditPointValidValues
	{
		/*[in]*/ long iLine;
		/*[in]*/ CharIndex iIndex;
		/*[out]*/ IDispatch** ppEditPoint;
		HRESULT retValue;
	};

	STDMETHOD(CreateEditPoint)(
		/*[in]*/ long iLine,
		/*[in]*/ CharIndex iIndex,
		/*[out]*/ IDispatch** ppEditPoint)
	{
		VSL_DEFINE_MOCK_METHOD(CreateEditPoint)

		VSL_CHECK_VALIDVALUE(iLine);

		VSL_CHECK_VALIDVALUE(iIndex);

		VSL_SET_VALIDVALUE_INTERFACE(ppEditPoint);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReplaceLinesExValidValues
	{
		/*[in]*/ DWORD dwFlags;
		/*[in]*/ long iStartLine;
		/*[in]*/ CharIndex iStartIndex;
		/*[in]*/ long iEndLine;
		/*[in]*/ CharIndex iEndIndex;
		/*[in]*/ LPCWSTR pszText;
		/*[in]*/ long iNewLen;
		/*[out]*/ TextSpan* pChangedSpan;
		HRESULT retValue;
	};

	STDMETHOD(ReplaceLinesEx)(
		/*[in]*/ DWORD dwFlags,
		/*[in]*/ long iStartLine,
		/*[in]*/ CharIndex iStartIndex,
		/*[in]*/ long iEndLine,
		/*[in]*/ CharIndex iEndIndex,
		/*[in]*/ LPCWSTR pszText,
		/*[in]*/ long iNewLen,
		/*[out]*/ TextSpan* pChangedSpan)
	{
		VSL_DEFINE_MOCK_METHOD(ReplaceLinesEx)

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_CHECK_VALIDVALUE(iStartLine);

		VSL_CHECK_VALIDVALUE(iStartIndex);

		VSL_CHECK_VALIDVALUE(iEndLine);

		VSL_CHECK_VALIDVALUE(iEndIndex);

		VSL_CHECK_VALIDVALUE_STRINGW(pszText);

		VSL_CHECK_VALIDVALUE(iNewLen);

		VSL_SET_VALIDVALUE(pChangedSpan);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateTextPointValidValues
	{
		/*[in]*/ long iLine;
		/*[in]*/ CharIndex iIndex;
		/*[out]*/ IDispatch** ppTextPoint;
		HRESULT retValue;
	};

	STDMETHOD(CreateTextPoint)(
		/*[in]*/ long iLine,
		/*[in]*/ CharIndex iIndex,
		/*[out]*/ IDispatch** ppTextPoint)
	{
		VSL_DEFINE_MOCK_METHOD(CreateTextPoint)

		VSL_CHECK_VALIDVALUE(iLine);

		VSL_CHECK_VALIDVALUE(iIndex);

		VSL_SET_VALIDVALUE_INTERFACE(ppTextPoint);

		VSL_RETURN_VALIDVALUES();
	}
	struct LockBufferValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(LockBuffer)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(LockBuffer)

		VSL_RETURN_VALIDVALUES();
	}
	struct UnlockBufferValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(UnlockBuffer)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(UnlockBuffer)

		VSL_RETURN_VALIDVALUES();
	}
	struct InitializeContentValidValues
	{
		/*[in]*/ WCHAR* pszText;
		/*[in]*/ long iLength;
		HRESULT retValue;
	};

	STDMETHOD(InitializeContent)(
		/*[in]*/ const WCHAR* pszText,
		/*[in]*/ long iLength)
	{
		VSL_DEFINE_MOCK_METHOD(InitializeContent)

		VSL_CHECK_VALIDVALUE_STRINGW(pszText);

		VSL_CHECK_VALIDVALUE(iLength);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetStateFlagsValidValues
	{
		/*[out]*/ DWORD* pdwReadOnlyFlags;
		HRESULT retValue;
	};

	STDMETHOD(GetStateFlags)(
		/*[out]*/ DWORD* pdwReadOnlyFlags)
	{
		VSL_DEFINE_MOCK_METHOD(GetStateFlags)

		VSL_SET_VALIDVALUE(pdwReadOnlyFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetStateFlagsValidValues
	{
		/*[in]*/ DWORD dwReadOnlyFlags;
		HRESULT retValue;
	};

	STDMETHOD(SetStateFlags)(
		/*[in]*/ DWORD dwReadOnlyFlags)
	{
		VSL_DEFINE_MOCK_METHOD(SetStateFlags)

		VSL_CHECK_VALIDVALUE(dwReadOnlyFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPositionOfLineValidValues
	{
		/*[in]*/ long iLine;
		/*[out]*/ long* piPosition;
		HRESULT retValue;
	};

	STDMETHOD(GetPositionOfLine)(
		/*[in]*/ long iLine,
		/*[out]*/ long* piPosition)
	{
		VSL_DEFINE_MOCK_METHOD(GetPositionOfLine)

		VSL_CHECK_VALIDVALUE(iLine);

		VSL_SET_VALIDVALUE(piPosition);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPositionOfLineIndexValidValues
	{
		/*[in]*/ long iLine;
		/*[in]*/ CharIndex iIndex;
		/*[out]*/ long* piPosition;
		HRESULT retValue;
	};

	STDMETHOD(GetPositionOfLineIndex)(
		/*[in]*/ long iLine,
		/*[in]*/ CharIndex iIndex,
		/*[out]*/ long* piPosition)
	{
		VSL_DEFINE_MOCK_METHOD(GetPositionOfLineIndex)

		VSL_CHECK_VALIDVALUE(iLine);

		VSL_CHECK_VALIDVALUE(iIndex);

		VSL_SET_VALIDVALUE(piPosition);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLineIndexOfPositionValidValues
	{
		/*[in]*/ long iPosition;
		/*[out]*/ long* piLine;
		/*[out]*/ CharIndex* piColumn;
		HRESULT retValue;
	};

	STDMETHOD(GetLineIndexOfPosition)(
		/*[in]*/ long iPosition,
		/*[out]*/ long* piLine,
		/*[out]*/ CharIndex* piColumn)
	{
		VSL_DEFINE_MOCK_METHOD(GetLineIndexOfPosition)

		VSL_CHECK_VALIDVALUE(iPosition);

		VSL_SET_VALIDVALUE(piLine);

		VSL_SET_VALIDVALUE(piColumn);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLengthOfLineValidValues
	{
		/*[in]*/ long iLine;
		/*[out]*/ long* piLength;
		HRESULT retValue;
	};

	STDMETHOD(GetLengthOfLine)(
		/*[in]*/ long iLine,
		/*[out]*/ long* piLength)
	{
		VSL_DEFINE_MOCK_METHOD(GetLengthOfLine)

		VSL_CHECK_VALIDVALUE(iLine);

		VSL_SET_VALIDVALUE(piLength);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLineCountValidValues
	{
		/*[out]*/ long* piLineCount;
		HRESULT retValue;
	};

	STDMETHOD(GetLineCount)(
		/*[out]*/ long* piLineCount)
	{
		VSL_DEFINE_MOCK_METHOD(GetLineCount)

		VSL_SET_VALIDVALUE(piLineCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSizeValidValues
	{
		/*[out]*/ long* piLength;
		HRESULT retValue;
	};

	STDMETHOD(GetSize)(
		/*[out]*/ long* piLength)
	{
		VSL_DEFINE_MOCK_METHOD(GetSize)

		VSL_SET_VALIDVALUE(piLength);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLanguageServiceIDValidValues
	{
		/*[out]*/ GUID* pguidLangService;
		HRESULT retValue;
	};

	STDMETHOD(GetLanguageServiceID)(
		/*[out]*/ GUID* pguidLangService)
	{
		VSL_DEFINE_MOCK_METHOD(GetLanguageServiceID)

		VSL_SET_VALIDVALUE(pguidLangService);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetLanguageServiceIDValidValues
	{
		/*[in]*/ REFGUID guidLangService;
		HRESULT retValue;
	};

	STDMETHOD(SetLanguageServiceID)(
		/*[in]*/ REFGUID guidLangService)
	{
		VSL_DEFINE_MOCK_METHOD(SetLanguageServiceID)

		VSL_CHECK_VALIDVALUE(guidLangService);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetUndoManagerValidValues
	{
		/*[out]*/ IOleUndoManager** ppUndoManager;
		HRESULT retValue;
	};

	STDMETHOD(GetUndoManager)(
		/*[out]*/ IOleUndoManager** ppUndoManager)
	{
		VSL_DEFINE_MOCK_METHOD(GetUndoManager)

		VSL_SET_VALIDVALUE_INTERFACE(ppUndoManager);

		VSL_RETURN_VALIDVALUES();
	}
	struct Reserved1ValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reserved1)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reserved1)

		VSL_RETURN_VALIDVALUES();
	}
	struct Reserved2ValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reserved2)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reserved2)

		VSL_RETURN_VALIDVALUES();
	}
	struct Reserved3ValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reserved3)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reserved3)

		VSL_RETURN_VALIDVALUES();
	}
	struct Reserved4ValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reserved4)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reserved4)

		VSL_RETURN_VALIDVALUES();
	}
	struct ReloadValidValues
	{
		/*[in]*/ BOOL fUndoable;
		HRESULT retValue;
	};

	STDMETHOD(Reload)(
		/*[in]*/ BOOL fUndoable)
	{
		VSL_DEFINE_MOCK_METHOD(Reload)

		VSL_CHECK_VALIDVALUE(fUndoable);

		VSL_RETURN_VALIDVALUES();
	}
	struct LockBufferExValidValues
	{
		/*[in]*/ DWORD dwFlags;
		HRESULT retValue;
	};

	STDMETHOD(LockBufferEx)(
		/*[in]*/ DWORD dwFlags)
	{
		VSL_DEFINE_MOCK_METHOD(LockBufferEx)

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnlockBufferExValidValues
	{
		/*[in]*/ DWORD dwFlags;
		HRESULT retValue;
	};

	STDMETHOD(UnlockBufferEx)(
		/*[in]*/ DWORD dwFlags)
	{
		VSL_DEFINE_MOCK_METHOD(UnlockBufferEx)

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLastLineIndexValidValues
	{
		/*[out]*/ long* piLine;
		/*[out]*/ long* piIndex;
		HRESULT retValue;
	};

	STDMETHOD(GetLastLineIndex)(
		/*[out]*/ long* piLine,
		/*[out]*/ long* piIndex)
	{
		VSL_DEFINE_MOCK_METHOD(GetLastLineIndex)

		VSL_SET_VALIDVALUE(piLine);

		VSL_SET_VALIDVALUE(piIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct Reserved5ValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reserved5)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reserved5)

		VSL_RETURN_VALIDVALUES();
	}
	struct Reserved6ValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reserved6)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reserved6)

		VSL_RETURN_VALIDVALUES();
	}
	struct Reserved7ValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reserved7)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reserved7)

		VSL_RETURN_VALIDVALUES();
	}
	struct Reserved8ValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reserved8)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reserved8)

		VSL_RETURN_VALIDVALUES();
	}
	struct Reserved9ValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reserved9)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reserved9)

		VSL_RETURN_VALIDVALUES();
	}
	struct Reserved10ValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Reserved10)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Reserved10)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTEXTLINES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTextManager.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTEXTMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTEXTMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTextManagerNotImpl :
	public IVsTextManager
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextManagerNotImpl)

public:

	typedef IVsTextManager Interface;

	STDMETHOD(RegisterView)(
		/*[in]*/ IVsTextView* /*pView*/,
		/*[in]*/ IVsTextBuffer* /*pBuffer*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnregisterView)(
		/*[in]*/ IVsTextView* /*pView*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumViews)(
		/*[in]*/ IVsTextBuffer* /*pBuffer*/,
		/*[out]*/ IVsEnumTextViews** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateSelectionAction)(
		/*[in]*/ IVsTextBuffer* /*pBuffer*/,
		/*[out]*/ IVsTextSelectionAction** /*ppAction*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(MapFilenameToLanguageSID)(
		/*[in]*/ const WCHAR* /*pszFileName*/,
		/*[out]*/ GUID* /*pguidLangSID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetRegisteredMarkerTypeID)(
		/*[in]*/ const GUID* /*pguidMarker*/,
		/*[out]*/ long* /*piMarkerTypeID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMarkerTypeInterface)(
		/*[in]*/ long /*iMarkerTypeID*/,
		/*[out]*/ IVsTextMarkerType** /*ppMarkerType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMarkerTypeCount)(
		/*[out]*/ long* /*piMarkerTypeCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetActiveView)(
		/*[in]*/ BOOL /*fMustHaveFocus*/,
		/*[in]*/ IVsTextBuffer* /*pBuffer*/,
		/*[out]*/ IVsTextView** /*ppView*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetUserPreferences)(
		/*[out]*/ VIEWPREFERENCES* /*pViewPrefs*/,
		/*[out]*/ FRAMEPREFERENCES* /*pFramePrefs*/,
		/*[in,out]*/ LANGPREFERENCES* /*pLangPrefs*/,
		/*[in,out]*/ FONTCOLORPREFERENCES* /*pColorPrefs*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetUserPreferences)(
		/*[in]*/ const VIEWPREFERENCES* /*pViewPrefs*/,
		/*[in]*/ const FRAMEPREFERENCES* /*pFramePrefs*/,
		/*[in]*/ const LANGPREFERENCES* /*pLangPrefs*/,
		/*[in]*/ const FONTCOLORPREFERENCES* /*pColorPrefs*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetFileChangeAdvise)(
		/*[in]*/ const WCHAR* /*pszFileName*/,
		/*[in]*/ BOOL /*fStart*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SuspendFileChangeAdvise)(
		/*[in]*/ const WCHAR* /*pszFileName*/,
		/*[in]*/ BOOL /*fSuspend*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(NavigateToPosition)(
		/*[in]*/ IVsTextBuffer* /*pBuffer*/,
		/*[in]*/ REFGUID /*guidDocViewType*/,
		/*[in]*/ long /*iPos*/,
		/*[in]*/ long /*iLen*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(NavigateToLineAndColumn)(
		/*[in]*/ IVsTextBuffer* /*pBuffer*/,
		/*[in]*/ REFGUID /*guidDocViewType*/,
		/*[in]*/ long /*iStartRow*/,
		/*[in]*/ CharIndex /*iStartIndex*/,
		/*[in]*/ long /*iEndRow*/,
		/*[in]*/ CharIndex /*iEndIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetBufferSccStatus)(
		/*[in]*/ IVsUserData* /*pBufData*/,
		/*[out]*/ BOOL* /*pbNonEditable*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RegisterBuffer)(
		/*[in]*/ IVsTextBuffer* /*pBuffer*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnregisterBuffer)(
		/*[in]*/ IVsTextBuffer* /*pBuffer*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumBuffers)(
		/*[out]*/ IVsEnumTextBuffers** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPerLanguagePreferences)(
		/*[out]*/ LANGPREFERENCES* /*pLangPrefs*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetPerLanguagePreferences)(
		/*[in]*/ const LANGPREFERENCES* /*pLangPrefs*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AttemptToCheckOutBufferFromScc)(
		/*[in]*/ IVsUserData* /*pBufData*/,
		/*[out]*/ BOOL* /*pfCheckoutSucceeded*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetShortcutManager)(
		/*[out]*/ IVsShortcutManager** /*ppShortcutMgr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RegisterIndependentView)(
		/*[in]*/ IUnknown* /*pUnk*/,
		/*[in]*/ IVsTextBuffer* /*pBuffer*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnregisterIndependentView)(
		/*[in]*/ IUnknown* /*pUnk*/,
		/*[in]*/ IVsTextBuffer* /*pBuffer*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IgnoreNextFileChange)(
		/*[in]*/ IVsTextBuffer* /*pBuffer*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AdjustFileChangeIgnoreCount)(
		/*[in]*/ IVsTextBuffer* /*pBuffer*/,
		/*[in]*/ BOOL /*fIgnore*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetBufferSccStatus2)(
		/*[in]*/ const WCHAR* /*pszFileName*/,
		/*[out]*/ BOOL* /*pbNonEditable*/,
		/*[out]*/ int* /*piStatusFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AttemptToCheckOutBufferFromScc2)(
		/*[in]*/ const WCHAR* /*pszFileName*/,
		/*[out]*/ BOOL* /*pfCheckoutSucceeded*/,
		/*[out]*/ int* /*piStatusFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumLanguageServices)(
		/*[out]*/ IVsEnumGUID** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumIndependentViews)(
		/*[in]*/ IVsTextBuffer* /*pBuffer*/,
		/*[out]*/ IVsEnumIndependentViews** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTextManagerMockImpl :
	public IVsTextManager,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextManagerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTextManagerMockImpl)

	typedef IVsTextManager Interface;
	struct RegisterViewValidValues
	{
		/*[in]*/ IVsTextView* pView;
		/*[in]*/ IVsTextBuffer* pBuffer;
		HRESULT retValue;
	};

	STDMETHOD(RegisterView)(
		/*[in]*/ IVsTextView* pView,
		/*[in]*/ IVsTextBuffer* pBuffer)
	{
		VSL_DEFINE_MOCK_METHOD(RegisterView)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pView);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnregisterViewValidValues
	{
		/*[in]*/ IVsTextView* pView;
		HRESULT retValue;
	};

	STDMETHOD(UnregisterView)(
		/*[in]*/ IVsTextView* pView)
	{
		VSL_DEFINE_MOCK_METHOD(UnregisterView)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pView);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumViewsValidValues
	{
		/*[in]*/ IVsTextBuffer* pBuffer;
		/*[out]*/ IVsEnumTextViews** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumViews)(
		/*[in]*/ IVsTextBuffer* pBuffer,
		/*[out]*/ IVsEnumTextViews** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumViews)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateSelectionActionValidValues
	{
		/*[in]*/ IVsTextBuffer* pBuffer;
		/*[out]*/ IVsTextSelectionAction** ppAction;
		HRESULT retValue;
	};

	STDMETHOD(CreateSelectionAction)(
		/*[in]*/ IVsTextBuffer* pBuffer,
		/*[out]*/ IVsTextSelectionAction** ppAction)
	{
		VSL_DEFINE_MOCK_METHOD(CreateSelectionAction)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_SET_VALIDVALUE_INTERFACE(ppAction);

		VSL_RETURN_VALIDVALUES();
	}
	struct MapFilenameToLanguageSIDValidValues
	{
		/*[in]*/ WCHAR* pszFileName;
		/*[out]*/ GUID* pguidLangSID;
		HRESULT retValue;
	};

	STDMETHOD(MapFilenameToLanguageSID)(
		/*[in]*/ const WCHAR* pszFileName,
		/*[out]*/ GUID* pguidLangSID)
	{
		VSL_DEFINE_MOCK_METHOD(MapFilenameToLanguageSID)

		VSL_CHECK_VALIDVALUE_STRINGW(pszFileName);

		VSL_SET_VALIDVALUE(pguidLangSID);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetRegisteredMarkerTypeIDValidValues
	{
		/*[in]*/ GUID* pguidMarker;
		/*[out]*/ long* piMarkerTypeID;
		HRESULT retValue;
	};

	STDMETHOD(GetRegisteredMarkerTypeID)(
		/*[in]*/ const GUID* pguidMarker,
		/*[out]*/ long* piMarkerTypeID)
	{
		VSL_DEFINE_MOCK_METHOD(GetRegisteredMarkerTypeID)

		VSL_CHECK_VALIDVALUE_POINTER(pguidMarker);

		VSL_SET_VALIDVALUE(piMarkerTypeID);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMarkerTypeInterfaceValidValues
	{
		/*[in]*/ long iMarkerTypeID;
		/*[out]*/ IVsTextMarkerType** ppMarkerType;
		HRESULT retValue;
	};

	STDMETHOD(GetMarkerTypeInterface)(
		/*[in]*/ long iMarkerTypeID,
		/*[out]*/ IVsTextMarkerType** ppMarkerType)
	{
		VSL_DEFINE_MOCK_METHOD(GetMarkerTypeInterface)

		VSL_CHECK_VALIDVALUE(iMarkerTypeID);

		VSL_SET_VALIDVALUE_INTERFACE(ppMarkerType);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMarkerTypeCountValidValues
	{
		/*[out]*/ long* piMarkerTypeCount;
		HRESULT retValue;
	};

	STDMETHOD(GetMarkerTypeCount)(
		/*[out]*/ long* piMarkerTypeCount)
	{
		VSL_DEFINE_MOCK_METHOD(GetMarkerTypeCount)

		VSL_SET_VALIDVALUE(piMarkerTypeCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetActiveViewValidValues
	{
		/*[in]*/ BOOL fMustHaveFocus;
		/*[in]*/ IVsTextBuffer* pBuffer;
		/*[out]*/ IVsTextView** ppView;
		HRESULT retValue;
	};

	STDMETHOD(GetActiveView)(
		/*[in]*/ BOOL fMustHaveFocus,
		/*[in]*/ IVsTextBuffer* pBuffer,
		/*[out]*/ IVsTextView** ppView)
	{
		VSL_DEFINE_MOCK_METHOD(GetActiveView)

		VSL_CHECK_VALIDVALUE(fMustHaveFocus);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_SET_VALIDVALUE_INTERFACE(ppView);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetUserPreferencesValidValues
	{
		/*[out]*/ VIEWPREFERENCES* pViewPrefs;
		/*[out]*/ FRAMEPREFERENCES* pFramePrefs;
		/*[in,out]*/ LANGPREFERENCES* pLangPrefs;
		/*[in,out]*/ FONTCOLORPREFERENCES* pColorPrefs;
		HRESULT retValue;
	};

	STDMETHOD(GetUserPreferences)(
		/*[out]*/ VIEWPREFERENCES* pViewPrefs,
		/*[out]*/ FRAMEPREFERENCES* pFramePrefs,
		/*[in,out]*/ LANGPREFERENCES* pLangPrefs,
		/*[in,out]*/ FONTCOLORPREFERENCES* pColorPrefs)
	{
		VSL_DEFINE_MOCK_METHOD(GetUserPreferences)

		VSL_SET_VALIDVALUE(pViewPrefs);

		VSL_SET_VALIDVALUE(pFramePrefs);

		VSL_SET_VALIDVALUE(pLangPrefs);

		VSL_SET_VALIDVALUE(pColorPrefs);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetUserPreferencesValidValues
	{
		/*[in]*/ VIEWPREFERENCES* pViewPrefs;
		/*[in]*/ FRAMEPREFERENCES* pFramePrefs;
		/*[in]*/ LANGPREFERENCES* pLangPrefs;
		/*[in]*/ FONTCOLORPREFERENCES* pColorPrefs;
		HRESULT retValue;
	};

	STDMETHOD(SetUserPreferences)(
		/*[in]*/ const VIEWPREFERENCES* pViewPrefs,
		/*[in]*/ const FRAMEPREFERENCES* pFramePrefs,
		/*[in]*/ const LANGPREFERENCES* pLangPrefs,
		/*[in]*/ const FONTCOLORPREFERENCES* pColorPrefs)
	{
		VSL_DEFINE_MOCK_METHOD(SetUserPreferences)

		VSL_CHECK_VALIDVALUE_POINTER(pViewPrefs);

		VSL_CHECK_VALIDVALUE_POINTER(pFramePrefs);

		VSL_CHECK_VALIDVALUE_POINTER(pLangPrefs);

		VSL_CHECK_VALIDVALUE_POINTER(pColorPrefs);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetFileChangeAdviseValidValues
	{
		/*[in]*/ WCHAR* pszFileName;
		/*[in]*/ BOOL fStart;
		HRESULT retValue;
	};

	STDMETHOD(SetFileChangeAdvise)(
		/*[in]*/ const WCHAR* pszFileName,
		/*[in]*/ BOOL fStart)
	{
		VSL_DEFINE_MOCK_METHOD(SetFileChangeAdvise)

		VSL_CHECK_VALIDVALUE_STRINGW(pszFileName);

		VSL_CHECK_VALIDVALUE(fStart);

		VSL_RETURN_VALIDVALUES();
	}
	struct SuspendFileChangeAdviseValidValues
	{
		/*[in]*/ WCHAR* pszFileName;
		/*[in]*/ BOOL fSuspend;
		HRESULT retValue;
	};

	STDMETHOD(SuspendFileChangeAdvise)(
		/*[in]*/ const WCHAR* pszFileName,
		/*[in]*/ BOOL fSuspend)
	{
		VSL_DEFINE_MOCK_METHOD(SuspendFileChangeAdvise)

		VSL_CHECK_VALIDVALUE_STRINGW(pszFileName);

		VSL_CHECK_VALIDVALUE(fSuspend);

		VSL_RETURN_VALIDVALUES();
	}
	struct NavigateToPositionValidValues
	{
		/*[in]*/ IVsTextBuffer* pBuffer;
		/*[in]*/ REFGUID guidDocViewType;
		/*[in]*/ long iPos;
		/*[in]*/ long iLen;
		HRESULT retValue;
	};

	STDMETHOD(NavigateToPosition)(
		/*[in]*/ IVsTextBuffer* pBuffer,
		/*[in]*/ REFGUID guidDocViewType,
		/*[in]*/ long iPos,
		/*[in]*/ long iLen)
	{
		VSL_DEFINE_MOCK_METHOD(NavigateToPosition)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_CHECK_VALIDVALUE(guidDocViewType);

		VSL_CHECK_VALIDVALUE(iPos);

		VSL_CHECK_VALIDVALUE(iLen);

		VSL_RETURN_VALIDVALUES();
	}
	struct NavigateToLineAndColumnValidValues
	{
		/*[in]*/ IVsTextBuffer* pBuffer;
		/*[in]*/ REFGUID guidDocViewType;
		/*[in]*/ long iStartRow;
		/*[in]*/ CharIndex iStartIndex;
		/*[in]*/ long iEndRow;
		/*[in]*/ CharIndex iEndIndex;
		HRESULT retValue;
	};

	STDMETHOD(NavigateToLineAndColumn)(
		/*[in]*/ IVsTextBuffer* pBuffer,
		/*[in]*/ REFGUID guidDocViewType,
		/*[in]*/ long iStartRow,
		/*[in]*/ CharIndex iStartIndex,
		/*[in]*/ long iEndRow,
		/*[in]*/ CharIndex iEndIndex)
	{
		VSL_DEFINE_MOCK_METHOD(NavigateToLineAndColumn)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_CHECK_VALIDVALUE(guidDocViewType);

		VSL_CHECK_VALIDVALUE(iStartRow);

		VSL_CHECK_VALIDVALUE(iStartIndex);

		VSL_CHECK_VALIDVALUE(iEndRow);

		VSL_CHECK_VALIDVALUE(iEndIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetBufferSccStatusValidValues
	{
		/*[in]*/ IVsUserData* pBufData;
		/*[out]*/ BOOL* pbNonEditable;
		HRESULT retValue;
	};

	STDMETHOD(GetBufferSccStatus)(
		/*[in]*/ IVsUserData* pBufData,
		/*[out]*/ BOOL* pbNonEditable)
	{
		VSL_DEFINE_MOCK_METHOD(GetBufferSccStatus)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBufData);

		VSL_SET_VALIDVALUE(pbNonEditable);

		VSL_RETURN_VALIDVALUES();
	}
	struct RegisterBufferValidValues
	{
		/*[in]*/ IVsTextBuffer* pBuffer;
		HRESULT retValue;
	};

	STDMETHOD(RegisterBuffer)(
		/*[in]*/ IVsTextBuffer* pBuffer)
	{
		VSL_DEFINE_MOCK_METHOD(RegisterBuffer)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnregisterBufferValidValues
	{
		/*[in]*/ IVsTextBuffer* pBuffer;
		HRESULT retValue;
	};

	STDMETHOD(UnregisterBuffer)(
		/*[in]*/ IVsTextBuffer* pBuffer)
	{
		VSL_DEFINE_MOCK_METHOD(UnregisterBuffer)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumBuffersValidValues
	{
		/*[out]*/ IVsEnumTextBuffers** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumBuffers)(
		/*[out]*/ IVsEnumTextBuffers** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumBuffers)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPerLanguagePreferencesValidValues
	{
		/*[out]*/ LANGPREFERENCES* pLangPrefs;
		HRESULT retValue;
	};

	STDMETHOD(GetPerLanguagePreferences)(
		/*[out]*/ LANGPREFERENCES* pLangPrefs)
	{
		VSL_DEFINE_MOCK_METHOD(GetPerLanguagePreferences)

		VSL_SET_VALIDVALUE(pLangPrefs);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetPerLanguagePreferencesValidValues
	{
		/*[in]*/ LANGPREFERENCES* pLangPrefs;
		HRESULT retValue;
	};

	STDMETHOD(SetPerLanguagePreferences)(
		/*[in]*/ const LANGPREFERENCES* pLangPrefs)
	{
		VSL_DEFINE_MOCK_METHOD(SetPerLanguagePreferences)

		VSL_CHECK_VALIDVALUE_POINTER(pLangPrefs);

		VSL_RETURN_VALIDVALUES();
	}
	struct AttemptToCheckOutBufferFromSccValidValues
	{
		/*[in]*/ IVsUserData* pBufData;
		/*[out]*/ BOOL* pfCheckoutSucceeded;
		HRESULT retValue;
	};

	STDMETHOD(AttemptToCheckOutBufferFromScc)(
		/*[in]*/ IVsUserData* pBufData,
		/*[out]*/ BOOL* pfCheckoutSucceeded)
	{
		VSL_DEFINE_MOCK_METHOD(AttemptToCheckOutBufferFromScc)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBufData);

		VSL_SET_VALIDVALUE(pfCheckoutSucceeded);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetShortcutManagerValidValues
	{
		/*[out]*/ IVsShortcutManager** ppShortcutMgr;
		HRESULT retValue;
	};

	STDMETHOD(GetShortcutManager)(
		/*[out]*/ IVsShortcutManager** ppShortcutMgr)
	{
		VSL_DEFINE_MOCK_METHOD(GetShortcutManager)

		VSL_SET_VALIDVALUE_INTERFACE(ppShortcutMgr);

		VSL_RETURN_VALIDVALUES();
	}
	struct RegisterIndependentViewValidValues
	{
		/*[in]*/ IUnknown* pUnk;
		/*[in]*/ IVsTextBuffer* pBuffer;
		HRESULT retValue;
	};

	STDMETHOD(RegisterIndependentView)(
		/*[in]*/ IUnknown* pUnk,
		/*[in]*/ IVsTextBuffer* pBuffer)
	{
		VSL_DEFINE_MOCK_METHOD(RegisterIndependentView)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUnk);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnregisterIndependentViewValidValues
	{
		/*[in]*/ IUnknown* pUnk;
		/*[in]*/ IVsTextBuffer* pBuffer;
		HRESULT retValue;
	};

	STDMETHOD(UnregisterIndependentView)(
		/*[in]*/ IUnknown* pUnk,
		/*[in]*/ IVsTextBuffer* pBuffer)
	{
		VSL_DEFINE_MOCK_METHOD(UnregisterIndependentView)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUnk);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_RETURN_VALIDVALUES();
	}
	struct IgnoreNextFileChangeValidValues
	{
		/*[in]*/ IVsTextBuffer* pBuffer;
		HRESULT retValue;
	};

	STDMETHOD(IgnoreNextFileChange)(
		/*[in]*/ IVsTextBuffer* pBuffer)
	{
		VSL_DEFINE_MOCK_METHOD(IgnoreNextFileChange)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_RETURN_VALIDVALUES();
	}
	struct AdjustFileChangeIgnoreCountValidValues
	{
		/*[in]*/ IVsTextBuffer* pBuffer;
		/*[in]*/ BOOL fIgnore;
		HRESULT retValue;
	};

	STDMETHOD(AdjustFileChangeIgnoreCount)(
		/*[in]*/ IVsTextBuffer* pBuffer,
		/*[in]*/ BOOL fIgnore)
	{
		VSL_DEFINE_MOCK_METHOD(AdjustFileChangeIgnoreCount)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_CHECK_VALIDVALUE(fIgnore);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetBufferSccStatus2ValidValues
	{
		/*[in]*/ WCHAR* pszFileName;
		/*[out]*/ BOOL* pbNonEditable;
		/*[out]*/ int* piStatusFlags;
		HRESULT retValue;
	};

	STDMETHOD(GetBufferSccStatus2)(
		/*[in]*/ const WCHAR* pszFileName,
		/*[out]*/ BOOL* pbNonEditable,
		/*[out]*/ int* piStatusFlags)
	{
		VSL_DEFINE_MOCK_METHOD(GetBufferSccStatus2)

		VSL_CHECK_VALIDVALUE_STRINGW(pszFileName);

		VSL_SET_VALIDVALUE(pbNonEditable);

		VSL_SET_VALIDVALUE(piStatusFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct AttemptToCheckOutBufferFromScc2ValidValues
	{
		/*[in]*/ WCHAR* pszFileName;
		/*[out]*/ BOOL* pfCheckoutSucceeded;
		/*[out]*/ int* piStatusFlags;
		HRESULT retValue;
	};

	STDMETHOD(AttemptToCheckOutBufferFromScc2)(
		/*[in]*/ const WCHAR* pszFileName,
		/*[out]*/ BOOL* pfCheckoutSucceeded,
		/*[out]*/ int* piStatusFlags)
	{
		VSL_DEFINE_MOCK_METHOD(AttemptToCheckOutBufferFromScc2)

		VSL_CHECK_VALIDVALUE_STRINGW(pszFileName);

		VSL_SET_VALIDVALUE(pfCheckoutSucceeded);

		VSL_SET_VALIDVALUE(piStatusFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumLanguageServicesValidValues
	{
		/*[out]*/ IVsEnumGUID** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumLanguageServices)(
		/*[out]*/ IVsEnumGUID** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumLanguageServices)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumIndependentViewsValidValues
	{
		/*[in]*/ IVsTextBuffer* pBuffer;
		/*[out]*/ IVsEnumIndependentViews** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumIndependentViews)(
		/*[in]*/ IVsTextBuffer* pBuffer,
		/*[out]*/ IVsEnumIndependentViews** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumIndependentViews)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTEXTMANAGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTextManager2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTEXTMANAGER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTEXTMANAGER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTextManager2NotImpl :
	public IVsTextManager2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextManager2NotImpl)

public:

	typedef IVsTextManager2 Interface;

	STDMETHOD(GetBufferSccStatus3)(
		/*[in]*/ IVsTextBuffer* /*pBuffer*/,
		/*[in,string]*/ LPCOLESTR /*pszFileName*/,
		/*[out]*/ BOOL* /*pbCheckoutSucceeded*/,
		/*[out]*/ int* /*piStatusFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AttemptToCheckOutBufferFromScc3)(
		/*[in]*/ IVsTextBuffer* /*pBuffer*/,
		/*[in,string]*/ LPCOLESTR /*pszFileName*/,
		/*[in]*/ DWORD /*dwQueryEditFlags*/,
		/*[out]*/ BOOL* /*pbCheckoutSucceeded*/,
		/*[out]*/ int* /*piStatusFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetUserPreferences2)(
		/*[out]*/ VIEWPREFERENCES2* /*pViewPrefs*/,
		/*[out]*/ FRAMEPREFERENCES2* /*pFramePrefs*/,
		/*[in,out]*/ LANGPREFERENCES2* /*pLangPrefs*/,
		/*[in,out]*/ FONTCOLORPREFERENCES2* /*pColorPrefs*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetUserPreferences2)(
		/*[in]*/ const VIEWPREFERENCES2* /*pViewPrefs*/,
		/*[in]*/ const FRAMEPREFERENCES2* /*pFramePrefs*/,
		/*[in]*/ const LANGPREFERENCES2* /*pLangPrefs*/,
		/*[in]*/ const FONTCOLORPREFERENCES2* /*pColorPrefs*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ResetColorableItems)(
		/*[in]*/ GUID /*guidLang*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetExpansionManager)(
		/*[out]*/ IVsExpansionManager** /*pExpansionManager*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetActiveView2)(
		/*[in]*/ BOOL /*fMustHaveFocus*/,
		/*[in]*/ IVsTextBuffer* /*pBuffer*/,
		/*[in]*/ VIEWFRAMETYPE /*grfIncludeViewFrameType*/,
		/*[out]*/ IVsTextView** /*ppView*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(NavigateToPosition2)(
		/*[in]*/ IVsTextBuffer* /*pBuffer*/,
		/*[in]*/ REFGUID /*guidDocViewType*/,
		/*[in]*/ long /*iPos*/,
		/*[in]*/ long /*iLen*/,
		/*[in]*/ VIEWFRAMETYPE /*grfIncludeViewFrameType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(NavigateToLineAndColumn2)(
		/*[in]*/ IVsTextBuffer* /*pBuffer*/,
		/*[in]*/ REFGUID /*guidDocViewType*/,
		/*[in]*/ long /*iStartRow*/,
		/*[in]*/ CharIndex /*iStartIndex*/,
		/*[in]*/ long /*iEndRow*/,
		/*[in]*/ CharIndex /*iEndIndex*/,
		/*[in]*/ VIEWFRAMETYPE /*grfIncludeViewFrameType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FireReplaceAllInFilesBegin)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FireReplaceAllInFilesEnd)()VSL_STDMETHOD_NOTIMPL
};

class IVsTextManager2MockImpl :
	public IVsTextManager2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextManager2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTextManager2MockImpl)

	typedef IVsTextManager2 Interface;
	struct GetBufferSccStatus3ValidValues
	{
		/*[in]*/ IVsTextBuffer* pBuffer;
		/*[in,string]*/ LPCOLESTR pszFileName;
		/*[out]*/ BOOL* pbCheckoutSucceeded;
		/*[out]*/ int* piStatusFlags;
		HRESULT retValue;
	};

	STDMETHOD(GetBufferSccStatus3)(
		/*[in]*/ IVsTextBuffer* pBuffer,
		/*[in,string]*/ LPCOLESTR pszFileName,
		/*[out]*/ BOOL* pbCheckoutSucceeded,
		/*[out]*/ int* piStatusFlags)
	{
		VSL_DEFINE_MOCK_METHOD(GetBufferSccStatus3)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_CHECK_VALIDVALUE_STRINGW(pszFileName);

		VSL_SET_VALIDVALUE(pbCheckoutSucceeded);

		VSL_SET_VALIDVALUE(piStatusFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct AttemptToCheckOutBufferFromScc3ValidValues
	{
		/*[in]*/ IVsTextBuffer* pBuffer;
		/*[in,string]*/ LPCOLESTR pszFileName;
		/*[in]*/ DWORD dwQueryEditFlags;
		/*[out]*/ BOOL* pbCheckoutSucceeded;
		/*[out]*/ int* piStatusFlags;
		HRESULT retValue;
	};

	STDMETHOD(AttemptToCheckOutBufferFromScc3)(
		/*[in]*/ IVsTextBuffer* pBuffer,
		/*[in,string]*/ LPCOLESTR pszFileName,
		/*[in]*/ DWORD dwQueryEditFlags,
		/*[out]*/ BOOL* pbCheckoutSucceeded,
		/*[out]*/ int* piStatusFlags)
	{
		VSL_DEFINE_MOCK_METHOD(AttemptToCheckOutBufferFromScc3)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_CHECK_VALIDVALUE_STRINGW(pszFileName);

		VSL_CHECK_VALIDVALUE(dwQueryEditFlags);

		VSL_SET_VALIDVALUE(pbCheckoutSucceeded);

		VSL_SET_VALIDVALUE(piStatusFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetUserPreferences2ValidValues
	{
		/*[out]*/ VIEWPREFERENCES2* pViewPrefs;
		/*[out]*/ FRAMEPREFERENCES2* pFramePrefs;
		/*[in,out]*/ LANGPREFERENCES2* pLangPrefs;
		/*[in,out]*/ FONTCOLORPREFERENCES2* pColorPrefs;
		HRESULT retValue;
	};

	STDMETHOD(GetUserPreferences2)(
		/*[out]*/ VIEWPREFERENCES2* pViewPrefs,
		/*[out]*/ FRAMEPREFERENCES2* pFramePrefs,
		/*[in,out]*/ LANGPREFERENCES2* pLangPrefs,
		/*[in,out]*/ FONTCOLORPREFERENCES2* pColorPrefs)
	{
		VSL_DEFINE_MOCK_METHOD(GetUserPreferences2)

		VSL_SET_VALIDVALUE(pViewPrefs);

		VSL_SET_VALIDVALUE(pFramePrefs);

		VSL_SET_VALIDVALUE(pLangPrefs);

		VSL_SET_VALIDVALUE(pColorPrefs);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetUserPreferences2ValidValues
	{
		/*[in]*/ VIEWPREFERENCES2* pViewPrefs;
		/*[in]*/ FRAMEPREFERENCES2* pFramePrefs;
		/*[in]*/ LANGPREFERENCES2* pLangPrefs;
		/*[in]*/ FONTCOLORPREFERENCES2* pColorPrefs;
		HRESULT retValue;
	};

	STDMETHOD(SetUserPreferences2)(
		/*[in]*/ const VIEWPREFERENCES2* pViewPrefs,
		/*[in]*/ const FRAMEPREFERENCES2* pFramePrefs,
		/*[in]*/ const LANGPREFERENCES2* pLangPrefs,
		/*[in]*/ const FONTCOLORPREFERENCES2* pColorPrefs)
	{
		VSL_DEFINE_MOCK_METHOD(SetUserPreferences2)

		VSL_CHECK_VALIDVALUE_POINTER(pViewPrefs);

		VSL_CHECK_VALIDVALUE_POINTER(pFramePrefs);

		VSL_CHECK_VALIDVALUE_POINTER(pLangPrefs);

		VSL_CHECK_VALIDVALUE_POINTER(pColorPrefs);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetColorableItemsValidValues
	{
		/*[in]*/ GUID guidLang;
		HRESULT retValue;
	};

	STDMETHOD(ResetColorableItems)(
		/*[in]*/ GUID guidLang)
	{
		VSL_DEFINE_MOCK_METHOD(ResetColorableItems)

		VSL_CHECK_VALIDVALUE(guidLang);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetExpansionManagerValidValues
	{
		/*[out]*/ IVsExpansionManager** pExpansionManager;
		HRESULT retValue;
	};

	STDMETHOD(GetExpansionManager)(
		/*[out]*/ IVsExpansionManager** pExpansionManager)
	{
		VSL_DEFINE_MOCK_METHOD(GetExpansionManager)

		VSL_SET_VALIDVALUE_INTERFACE(pExpansionManager);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetActiveView2ValidValues
	{
		/*[in]*/ BOOL fMustHaveFocus;
		/*[in]*/ IVsTextBuffer* pBuffer;
		/*[in]*/ VIEWFRAMETYPE grfIncludeViewFrameType;
		/*[out]*/ IVsTextView** ppView;
		HRESULT retValue;
	};

	STDMETHOD(GetActiveView2)(
		/*[in]*/ BOOL fMustHaveFocus,
		/*[in]*/ IVsTextBuffer* pBuffer,
		/*[in]*/ VIEWFRAMETYPE grfIncludeViewFrameType,
		/*[out]*/ IVsTextView** ppView)
	{
		VSL_DEFINE_MOCK_METHOD(GetActiveView2)

		VSL_CHECK_VALIDVALUE(fMustHaveFocus);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_CHECK_VALIDVALUE(grfIncludeViewFrameType);

		VSL_SET_VALIDVALUE_INTERFACE(ppView);

		VSL_RETURN_VALIDVALUES();
	}
	struct NavigateToPosition2ValidValues
	{
		/*[in]*/ IVsTextBuffer* pBuffer;
		/*[in]*/ REFGUID guidDocViewType;
		/*[in]*/ long iPos;
		/*[in]*/ long iLen;
		/*[in]*/ VIEWFRAMETYPE grfIncludeViewFrameType;
		HRESULT retValue;
	};

	STDMETHOD(NavigateToPosition2)(
		/*[in]*/ IVsTextBuffer* pBuffer,
		/*[in]*/ REFGUID guidDocViewType,
		/*[in]*/ long iPos,
		/*[in]*/ long iLen,
		/*[in]*/ VIEWFRAMETYPE grfIncludeViewFrameType)
	{
		VSL_DEFINE_MOCK_METHOD(NavigateToPosition2)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_CHECK_VALIDVALUE(guidDocViewType);

		VSL_CHECK_VALIDVALUE(iPos);

		VSL_CHECK_VALIDVALUE(iLen);

		VSL_CHECK_VALIDVALUE(grfIncludeViewFrameType);

		VSL_RETURN_VALIDVALUES();
	}
	struct NavigateToLineAndColumn2ValidValues
	{
		/*[in]*/ IVsTextBuffer* pBuffer;
		/*[in]*/ REFGUID guidDocViewType;
		/*[in]*/ long iStartRow;
		/*[in]*/ CharIndex iStartIndex;
		/*[in]*/ long iEndRow;
		/*[in]*/ CharIndex iEndIndex;
		/*[in]*/ VIEWFRAMETYPE grfIncludeViewFrameType;
		HRESULT retValue;
	};

	STDMETHOD(NavigateToLineAndColumn2)(
		/*[in]*/ IVsTextBuffer* pBuffer,
		/*[in]*/ REFGUID guidDocViewType,
		/*[in]*/ long iStartRow,
		/*[in]*/ CharIndex iStartIndex,
		/*[in]*/ long iEndRow,
		/*[in]*/ CharIndex iEndIndex,
		/*[in]*/ VIEWFRAMETYPE grfIncludeViewFrameType)
	{
		VSL_DEFINE_MOCK_METHOD(NavigateToLineAndColumn2)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_CHECK_VALIDVALUE(guidDocViewType);

		VSL_CHECK_VALIDVALUE(iStartRow);

		VSL_CHECK_VALIDVALUE(iStartIndex);

		VSL_CHECK_VALIDVALUE(iEndRow);

		VSL_CHECK_VALIDVALUE(iEndIndex);

		VSL_CHECK_VALIDVALUE(grfIncludeViewFrameType);

		VSL_RETURN_VALIDVALUES();
	}
	struct FireReplaceAllInFilesBeginValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(FireReplaceAllInFilesBegin)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(FireReplaceAllInFilesBegin)

		VSL_RETURN_VALIDVALUES();
	}
	struct FireReplaceAllInFilesEndValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(FireReplaceAllInFilesEnd)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(FireReplaceAllInFilesEnd)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTEXTMANAGER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTextLines2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTEXTLINES2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTEXTLINES2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTextLines2NotImpl :
	public IVsTextLines2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextLines2NotImpl)

public:

	typedef IVsTextLines2 Interface;

	STDMETHOD(GetEolTypeEx)(
		/*[in]*/ const LINEDATAEX* /*pld*/,
		/*[out]*/ DWORD* /*piEolType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetEolLengthEx)(
		/*[in]*/ const LINEDATAEX* /*pld*/,
		/*[out]*/ unsigned int* /*piEolType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetEolTextEx)(
		/*[in]*/ const LINEDATAEX* /*pld*/,
		/*[out]*/ BSTR* /*pbstrEolText*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTextLines2MockImpl :
	public IVsTextLines2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextLines2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTextLines2MockImpl)

	typedef IVsTextLines2 Interface;
	struct GetEolTypeExValidValues
	{
		/*[in]*/ LINEDATAEX* pld;
		/*[out]*/ DWORD* piEolType;
		HRESULT retValue;
	};

	STDMETHOD(GetEolTypeEx)(
		/*[in]*/ const LINEDATAEX* pld,
		/*[out]*/ DWORD* piEolType)
	{
		VSL_DEFINE_MOCK_METHOD(GetEolTypeEx)

		VSL_CHECK_VALIDVALUE_POINTER(pld);

		VSL_SET_VALIDVALUE(piEolType);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetEolLengthExValidValues
	{
		/*[in]*/ LINEDATAEX* pld;
		/*[out]*/ unsigned int* piEolType;
		HRESULT retValue;
	};

	STDMETHOD(GetEolLengthEx)(
		/*[in]*/ const LINEDATAEX* pld,
		/*[out]*/ unsigned int* piEolType)
	{
		VSL_DEFINE_MOCK_METHOD(GetEolLengthEx)

		VSL_CHECK_VALIDVALUE_POINTER(pld);

		VSL_SET_VALIDVALUE(piEolType);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetEolTextExValidValues
	{
		/*[in]*/ LINEDATAEX* pld;
		/*[out]*/ BSTR* pbstrEolText;
		HRESULT retValue;
	};

	STDMETHOD(GetEolTextEx)(
		/*[in]*/ const LINEDATAEX* pld,
		/*[out]*/ BSTR* pbstrEolText)
	{
		VSL_DEFINE_MOCK_METHOD(GetEolTextEx)

		VSL_CHECK_VALIDVALUE_POINTER(pld);

		VSL_SET_VALIDVALUE_BSTR(pbstrEolText);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTEXTLINES2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTextManagerEvents2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTEXTMANAGEREVENTS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTEXTMANAGEREVENTS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTextManagerEvents2NotImpl :
	public IVsTextManagerEvents2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextManagerEvents2NotImpl)

public:

	typedef IVsTextManagerEvents2 Interface;

	STDMETHOD(OnRegisterMarkerType)(
		/*[in]*/ long /*iMarkerType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnRegisterView)(
		/*[in]*/ IVsTextView* /*pView*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnUnregisterView)(
		/*[in]*/ IVsTextView* /*pView*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnUserPreferencesChanged2)(
		/*[in]*/ const VIEWPREFERENCES2* /*pViewPrefs*/,
		/*[in]*/ const FRAMEPREFERENCES2* /*pFramePrefs*/,
		/*[in]*/ const LANGPREFERENCES2* /*pLangPrefs*/,
		/*[in]*/ const FONTCOLORPREFERENCES2* /*pColorPrefs*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnReplaceAllInFilesBegin)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnReplaceAllInFilesEnd)()VSL_STDMETHOD_NOTIMPL
};

class IVsTextManagerEvents2MockImpl :
	public IVsTextManagerEvents2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextManagerEvents2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTextManagerEvents2MockImpl)

	typedef IVsTextManagerEvents2 Interface;
	struct OnRegisterMarkerTypeValidValues
	{
		/*[in]*/ long iMarkerType;
		HRESULT retValue;
	};

	STDMETHOD(OnRegisterMarkerType)(
		/*[in]*/ long iMarkerType)
	{
		VSL_DEFINE_MOCK_METHOD(OnRegisterMarkerType)

		VSL_CHECK_VALIDVALUE(iMarkerType);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnRegisterViewValidValues
	{
		/*[in]*/ IVsTextView* pView;
		HRESULT retValue;
	};

	STDMETHOD(OnRegisterView)(
		/*[in]*/ IVsTextView* pView)
	{
		VSL_DEFINE_MOCK_METHOD(OnRegisterView)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pView);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnUnregisterViewValidValues
	{
		/*[in]*/ IVsTextView* pView;
		HRESULT retValue;
	};

	STDMETHOD(OnUnregisterView)(
		/*[in]*/ IVsTextView* pView)
	{
		VSL_DEFINE_MOCK_METHOD(OnUnregisterView)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pView);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnUserPreferencesChanged2ValidValues
	{
		/*[in]*/ VIEWPREFERENCES2* pViewPrefs;
		/*[in]*/ FRAMEPREFERENCES2* pFramePrefs;
		/*[in]*/ LANGPREFERENCES2* pLangPrefs;
		/*[in]*/ FONTCOLORPREFERENCES2* pColorPrefs;
		HRESULT retValue;
	};

	STDMETHOD(OnUserPreferencesChanged2)(
		/*[in]*/ const VIEWPREFERENCES2* pViewPrefs,
		/*[in]*/ const FRAMEPREFERENCES2* pFramePrefs,
		/*[in]*/ const LANGPREFERENCES2* pLangPrefs,
		/*[in]*/ const FONTCOLORPREFERENCES2* pColorPrefs)
	{
		VSL_DEFINE_MOCK_METHOD(OnUserPreferencesChanged2)

		VSL_CHECK_VALIDVALUE_POINTER(pViewPrefs);

		VSL_CHECK_VALIDVALUE_POINTER(pFramePrefs);

		VSL_CHECK_VALIDVALUE_POINTER(pLangPrefs);

		VSL_CHECK_VALIDVALUE_POINTER(pColorPrefs);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnReplaceAllInFilesBeginValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(OnReplaceAllInFilesBegin)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(OnReplaceAllInFilesBegin)

		VSL_RETURN_VALIDVALUES();
	}
	struct OnReplaceAllInFilesEndValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(OnReplaceAllInFilesEnd)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(OnReplaceAllInFilesEnd)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTEXTMANAGEREVENTS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTextMarker.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTEXTMARKER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTEXTMARKER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTextMarkerNotImpl :
	public IVsTextMarker
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextMarkerNotImpl)

public:

	typedef IVsTextMarker Interface;

	STDMETHOD(GetType)(
		/*[out]*/ long* /*piMarkerType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetType)(
		/*[in]*/ long /*iMarkerType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetVisualStyle)(
		/*[out]*/ DWORD* /*pdwFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetVisualStyle)(
		/*[in]*/ DWORD /*dwFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invalidate)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DrawGlyph)(
		/*[in]*/ HDC /*hdc*/,
		/*[in]*/ RECT* /*pRect*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTipText)(
		/*[out,optional]*/ BSTR* /*pbstrText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnadviseClient)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMarkerCommandInfo)(
		/*[in]*/ long /*iItem*/,
		/*[out,custom(uuid_IVsTextMarker,"optional")]*/ BSTR* /*pbstrText*/,
		/*[out]*/ DWORD* /*pcmdf*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ExecMarkerCommand)(
		/*[in]*/ long /*iItem*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetBehavior)(
		/*[out]*/ DWORD* /*pdwBehavior*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetBehavior)(
		/*[in]*/ DWORD /*dwBehavior*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPriorityIndex)(
		/*[out]*/ long* /*piPriorityIndex*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTextMarkerMockImpl :
	public IVsTextMarker,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextMarkerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTextMarkerMockImpl)

	typedef IVsTextMarker Interface;
	struct GetTypeValidValues
	{
		/*[out]*/ long* piMarkerType;
		HRESULT retValue;
	};

	STDMETHOD(GetType)(
		/*[out]*/ long* piMarkerType)
	{
		VSL_DEFINE_MOCK_METHOD(GetType)

		VSL_SET_VALIDVALUE(piMarkerType);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetTypeValidValues
	{
		/*[in]*/ long iMarkerType;
		HRESULT retValue;
	};

	STDMETHOD(SetType)(
		/*[in]*/ long iMarkerType)
	{
		VSL_DEFINE_MOCK_METHOD(SetType)

		VSL_CHECK_VALIDVALUE(iMarkerType);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetVisualStyleValidValues
	{
		/*[out]*/ DWORD* pdwFlags;
		HRESULT retValue;
	};

	STDMETHOD(GetVisualStyle)(
		/*[out]*/ DWORD* pdwFlags)
	{
		VSL_DEFINE_MOCK_METHOD(GetVisualStyle)

		VSL_SET_VALIDVALUE(pdwFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetVisualStyleValidValues
	{
		/*[in]*/ DWORD dwFlags;
		HRESULT retValue;
	};

	STDMETHOD(SetVisualStyle)(
		/*[in]*/ DWORD dwFlags)
	{
		VSL_DEFINE_MOCK_METHOD(SetVisualStyle)

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct InvalidateValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Invalidate)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Invalidate)

		VSL_RETURN_VALIDVALUES();
	}
	struct DrawGlyphValidValues
	{
		/*[in]*/ HDC hdc;
		/*[in]*/ RECT* pRect;
		HRESULT retValue;
	};

	STDMETHOD(DrawGlyph)(
		/*[in]*/ HDC hdc,
		/*[in]*/ RECT* pRect)
	{
		VSL_DEFINE_MOCK_METHOD(DrawGlyph)

		VSL_CHECK_VALIDVALUE(hdc);

		VSL_CHECK_VALIDVALUE_POINTER(pRect);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTipTextValidValues
	{
		/*[out,optional]*/ BSTR* pbstrText;
		HRESULT retValue;
	};

	STDMETHOD(GetTipText)(
		/*[out,optional]*/ BSTR* pbstrText)
	{
		VSL_DEFINE_MOCK_METHOD(GetTipText)

		VSL_SET_VALIDVALUE_BSTR(pbstrText);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnadviseClientValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(UnadviseClient)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(UnadviseClient)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMarkerCommandInfoValidValues
	{
		/*[in]*/ long iItem;
		/*[out,custom(uuid_IVsTextMarker,"optional")]*/ BSTR* pbstrText;
		/*[out]*/ DWORD* pcmdf;
		HRESULT retValue;
	};

	STDMETHOD(GetMarkerCommandInfo)(
		/*[in]*/ long iItem,
		/*[out,custom(uuid_IVsTextMarker,"optional")]*/ BSTR* pbstrText,
		/*[out]*/ DWORD* pcmdf)
	{
		VSL_DEFINE_MOCK_METHOD(GetMarkerCommandInfo)

		VSL_CHECK_VALIDVALUE(iItem);

		VSL_SET_VALIDVALUE_BSTR(pbstrText);

		VSL_SET_VALIDVALUE(pcmdf);

		VSL_RETURN_VALIDVALUES();
	}
	struct ExecMarkerCommandValidValues
	{
		/*[in]*/ long iItem;
		HRESULT retValue;
	};

	STDMETHOD(ExecMarkerCommand)(
		/*[in]*/ long iItem)
	{
		VSL_DEFINE_MOCK_METHOD(ExecMarkerCommand)

		VSL_CHECK_VALIDVALUE(iItem);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetBehaviorValidValues
	{
		/*[out]*/ DWORD* pdwBehavior;
		HRESULT retValue;
	};

	STDMETHOD(GetBehavior)(
		/*[out]*/ DWORD* pdwBehavior)
	{
		VSL_DEFINE_MOCK_METHOD(GetBehavior)

		VSL_SET_VALIDVALUE(pdwBehavior);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetBehaviorValidValues
	{
		/*[in]*/ DWORD dwBehavior;
		HRESULT retValue;
	};

	STDMETHOD(SetBehavior)(
		/*[in]*/ DWORD dwBehavior)
	{
		VSL_DEFINE_MOCK_METHOD(SetBehavior)

		VSL_CHECK_VALIDVALUE(dwBehavior);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPriorityIndexValidValues
	{
		/*[out]*/ long* piPriorityIndex;
		HRESULT retValue;
	};

	STDMETHOD(GetPriorityIndex)(
		/*[out]*/ long* piPriorityIndex)
	{
		VSL_DEFINE_MOCK_METHOD(GetPriorityIndex)

		VSL_SET_VALIDVALUE(piPriorityIndex);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTEXTMARKER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTextMarkerClientAdvanced.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTEXTMARKERCLIENTADVANCED_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTEXTMARKERCLIENTADVANCED_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTextMarkerClientAdvancedNotImpl :
	public IVsTextMarkerClientAdvanced
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextMarkerClientAdvancedNotImpl)

public:

	typedef IVsTextMarkerClientAdvanced Interface;

	STDMETHOD(OnMarkerTextChanged)(
		/*[in]*/ IVsTextMarker* /*pMarker*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTextMarkerClientAdvancedMockImpl :
	public IVsTextMarkerClientAdvanced,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextMarkerClientAdvancedMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTextMarkerClientAdvancedMockImpl)

	typedef IVsTextMarkerClientAdvanced Interface;
	struct OnMarkerTextChangedValidValues
	{
		/*[in]*/ IVsTextMarker* pMarker;
		HRESULT retValue;
	};

	STDMETHOD(OnMarkerTextChanged)(
		/*[in]*/ IVsTextMarker* pMarker)
	{
		VSL_DEFINE_MOCK_METHOD(OnMarkerTextChanged)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pMarker);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTEXTMARKERCLIENTADVANCED_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTextMarkerColorSet.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTEXTMARKERCOLORSET_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTEXTMARKERCOLORSET_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTextMarkerColorSetNotImpl :
	public IVsTextMarkerColorSet
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextMarkerColorSetNotImpl)

public:

	typedef IVsTextMarkerColorSet Interface;

	STDMETHOD(GetMarkerColors)(
		/*[in]*/ long /*iMarkerType*/,
		/*[out]*/ COLORREF* /*pclrFore*/,
		/*[out]*/ COLORREF* /*pclrBack*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTextMarkerColorSetMockImpl :
	public IVsTextMarkerColorSet,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextMarkerColorSetMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTextMarkerColorSetMockImpl)

	typedef IVsTextMarkerColorSet Interface;
	struct GetMarkerColorsValidValues
	{
		/*[in]*/ long iMarkerType;
		/*[out]*/ COLORREF* pclrFore;
		/*[out]*/ COLORREF* pclrBack;
		HRESULT retValue;
	};

	STDMETHOD(GetMarkerColors)(
		/*[in]*/ long iMarkerType,
		/*[out]*/ COLORREF* pclrFore,
		/*[out]*/ COLORREF* pclrBack)
	{
		VSL_DEFINE_MOCK_METHOD(GetMarkerColors)

		VSL_CHECK_VALIDVALUE(iMarkerType);

		VSL_SET_VALIDVALUE(pclrFore);

		VSL_SET_VALIDVALUE(pclrBack);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTEXTMARKERCOLORSET_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTextMarkerType.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTEXTMARKERTYPE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTEXTMARKERTYPE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTextMarkerTypeNotImpl :
	public IVsTextMarkerType
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextMarkerTypeNotImpl)

public:

	typedef IVsTextMarkerType Interface;

	STDMETHOD(GetVisualStyle)(
		/*[out]*/ DWORD* /*pdwVisualFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDefaultColors)(
		/*[out]*/ COLORINDEX* /*piForeground*/,
		/*[out]*/ COLORINDEX* /*piBackground*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDefaultLineStyle)(
		/*[out]*/ COLORINDEX* /*piLineColor*/,
		/*[out]*/ LINESTYLE* /*piLineIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DrawGlyph)(
		/*[in]*/ HDC /*hdc*/,
		/*[in]*/ RECT* /*pRect*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetBehaviorFlags)(
		/*[out]*/ DWORD* /*pdwFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPriorityIndex)(
		/*[out]*/ long* /*piPriorityIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDisplayName)(
		/*[out]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DrawGlyphEx)(
		/*[in]*/ DWORD /*dwFlags*/,
		/*[in]*/ HDC /*hdc*/,
		/*[in]*/ RECT* /*pRect*/,
		/*[in]*/ long /*iLineHeight*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTextMarkerTypeMockImpl :
	public IVsTextMarkerType,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextMarkerTypeMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTextMarkerTypeMockImpl)

	typedef IVsTextMarkerType Interface;
	struct GetVisualStyleValidValues
	{
		/*[out]*/ DWORD* pdwVisualFlags;
		HRESULT retValue;
	};

	STDMETHOD(GetVisualStyle)(
		/*[out]*/ DWORD* pdwVisualFlags)
	{
		VSL_DEFINE_MOCK_METHOD(GetVisualStyle)

		VSL_SET_VALIDVALUE(pdwVisualFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDefaultColorsValidValues
	{
		/*[out]*/ COLORINDEX* piForeground;
		/*[out]*/ COLORINDEX* piBackground;
		HRESULT retValue;
	};

	STDMETHOD(GetDefaultColors)(
		/*[out]*/ COLORINDEX* piForeground,
		/*[out]*/ COLORINDEX* piBackground)
	{
		VSL_DEFINE_MOCK_METHOD(GetDefaultColors)

		VSL_SET_VALIDVALUE(piForeground);

		VSL_SET_VALIDVALUE(piBackground);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDefaultLineStyleValidValues
	{
		/*[out]*/ COLORINDEX* piLineColor;
		/*[out]*/ LINESTYLE* piLineIndex;
		HRESULT retValue;
	};

	STDMETHOD(GetDefaultLineStyle)(
		/*[out]*/ COLORINDEX* piLineColor,
		/*[out]*/ LINESTYLE* piLineIndex)
	{
		VSL_DEFINE_MOCK_METHOD(GetDefaultLineStyle)

		VSL_SET_VALIDVALUE(piLineColor);

		VSL_SET_VALIDVALUE(piLineIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct DrawGlyphValidValues
	{
		/*[in]*/ HDC hdc;
		/*[in]*/ RECT* pRect;
		HRESULT retValue;
	};

	STDMETHOD(DrawGlyph)(
		/*[in]*/ HDC hdc,
		/*[in]*/ RECT* pRect)
	{
		VSL_DEFINE_MOCK_METHOD(DrawGlyph)

		VSL_CHECK_VALIDVALUE(hdc);

		VSL_CHECK_VALIDVALUE_POINTER(pRect);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetBehaviorFlagsValidValues
	{
		/*[out]*/ DWORD* pdwFlags;
		HRESULT retValue;
	};

	STDMETHOD(GetBehaviorFlags)(
		/*[out]*/ DWORD* pdwFlags)
	{
		VSL_DEFINE_MOCK_METHOD(GetBehaviorFlags)

		VSL_SET_VALIDVALUE(pdwFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPriorityIndexValidValues
	{
		/*[out]*/ long* piPriorityIndex;
		HRESULT retValue;
	};

	STDMETHOD(GetPriorityIndex)(
		/*[out]*/ long* piPriorityIndex)
	{
		VSL_DEFINE_MOCK_METHOD(GetPriorityIndex)

		VSL_SET_VALIDVALUE(piPriorityIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDisplayNameValidValues
	{
		/*[out]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(GetDisplayName)(
		/*[out]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(GetDisplayName)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct DrawGlyphExValidValues
	{
		/*[in]*/ DWORD dwFlags;
		/*[in]*/ HDC hdc;
		/*[in]*/ RECT* pRect;
		/*[in]*/ long iLineHeight;
		HRESULT retValue;
	};

	STDMETHOD(DrawGlyphEx)(
		/*[in]*/ DWORD dwFlags,
		/*[in]*/ HDC hdc,
		/*[in]*/ RECT* pRect,
		/*[in]*/ long iLineHeight)
	{
		VSL_DEFINE_MOCK_METHOD(DrawGlyphEx)

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_CHECK_VALIDVALUE(hdc);

		VSL_CHECK_VALIDVALUE_POINTER(pRect);

		VSL_CHECK_VALIDVALUE(iLineHeight);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTEXTMARKERTYPE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTextMarkerGlyphDropHandler.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTEXTMARKERGLYPHDROPHANDLER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTEXTMARKERGLYPHDROPHANDLER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTextMarkerGlyphDropHandlerNotImpl :
	public IVsTextMarkerGlyphDropHandler
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextMarkerGlyphDropHandlerNotImpl)

public:

	typedef IVsTextMarkerGlyphDropHandler Interface;

	STDMETHOD(DrawCandidateOutlineGlyph)(
		/*[in]*/ DWORD /*dwReserved*/,
		/*[in]*/ HDC /*hdc*/,
		/*[in]*/ RECT* /*pRect*/,
		/*[in]*/ COLORREF /*clrref*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryDropLocation)(
		/*[in]*/ DWORD /*dwReserved*/,
		/*[in]*/ IVsTextView* /*pDestView*/,
		/*[in]*/ IVsTextLines* /*pDestBuffer*/,
		/*[in]*/ long /*iLine*/,
		/*[in]*/ CharIndex /*iIndex*/,
		/*[out]*/ DWORD* /*pdwDropResult*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DropAtLocation)(
		/*[in]*/ DWORD /*dwReserved*/,
		/*[in]*/ IVsTextView* /*pDestView*/,
		/*[in]*/ IVsTextLines* /*pDestBuffer*/,
		/*[in]*/ long /*iLine*/,
		/*[in]*/ CharIndex /*iIndex*/,
		/*[out]*/ DWORD* /*pdwDropResult*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTextMarkerGlyphDropHandlerMockImpl :
	public IVsTextMarkerGlyphDropHandler,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextMarkerGlyphDropHandlerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTextMarkerGlyphDropHandlerMockImpl)

	typedef IVsTextMarkerGlyphDropHandler Interface;
	struct DrawCandidateOutlineGlyphValidValues
	{
		/*[in]*/ DWORD dwReserved;
		/*[in]*/ HDC hdc;
		/*[in]*/ RECT* pRect;
		/*[in]*/ COLORREF clrref;
		HRESULT retValue;
	};

	STDMETHOD(DrawCandidateOutlineGlyph)(
		/*[in]*/ DWORD dwReserved,
		/*[in]*/ HDC hdc,
		/*[in]*/ RECT* pRect,
		/*[in]*/ COLORREF clrref)
	{
		VSL_DEFINE_MOCK_METHOD(DrawCandidateOutlineGlyph)

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_CHECK_VALIDVALUE(hdc);

		VSL_CHECK_VALIDVALUE_POINTER(pRect);

		VSL_CHECK_VALIDVALUE(clrref);

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryDropLocationValidValues
	{
		/*[in]*/ DWORD dwReserved;
		/*[in]*/ IVsTextView* pDestView;
		/*[in]*/ IVsTextLines* pDestBuffer;
		/*[in]*/ long iLine;
		/*[in]*/ CharIndex iIndex;
		/*[out]*/ DWORD* pdwDropResult;
		HRESULT retValue;
	};

	STDMETHOD(QueryDropLocation)(
		/*[in]*/ DWORD dwReserved,
		/*[in]*/ IVsTextView* pDestView,
		/*[in]*/ IVsTextLines* pDestBuffer,
		/*[in]*/ long iLine,
		/*[in]*/ CharIndex iIndex,
		/*[out]*/ DWORD* pdwDropResult)
	{
		VSL_DEFINE_MOCK_METHOD(QueryDropLocation)

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDestView);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDestBuffer);

		VSL_CHECK_VALIDVALUE(iLine);

		VSL_CHECK_VALIDVALUE(iIndex);

		VSL_SET_VALIDVALUE(pdwDropResult);

		VSL_RETURN_VALIDVALUES();
	}
	struct DropAtLocationValidValues
	{
		/*[in]*/ DWORD dwReserved;
		/*[in]*/ IVsTextView* pDestView;
		/*[in]*/ IVsTextLines* pDestBuffer;
		/*[in]*/ long iLine;
		/*[in]*/ CharIndex iIndex;
		/*[out]*/ DWORD* pdwDropResult;
		HRESULT retValue;
	};

	STDMETHOD(DropAtLocation)(
		/*[in]*/ DWORD dwReserved,
		/*[in]*/ IVsTextView* pDestView,
		/*[in]*/ IVsTextLines* pDestBuffer,
		/*[in]*/ long iLine,
		/*[in]*/ CharIndex iIndex,
		/*[out]*/ DWORD* pdwDropResult)
	{
		VSL_DEFINE_MOCK_METHOD(DropAtLocation)

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDestView);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDestBuffer);

		VSL_CHECK_VALIDVALUE(iLine);

		VSL_CHECK_VALIDVALUE(iIndex);

		VSL_SET_VALIDVALUE(pdwDropResult);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTEXTMARKERGLYPHDROPHANDLER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTextMarkerContextProvider.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTEXTMARKERCONTEXTPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTEXTMARKERCONTEXTPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTextMarkerContextProviderNotImpl :
	public IVsTextMarkerContextProvider
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextMarkerContextProviderNotImpl)

public:

	typedef IVsTextMarkerContextProvider Interface;

	STDMETHOD(UpdateContextForMarker)(
		/*[in]*/ DWORD /*dwReserved*/,
		/*[in]*/ IVsUserContext* /*pUC*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveLastContext)(
		/*[in]*/ DWORD /*dwReserved*/,
		/*[in]*/ IVsUserContext* /*pUC*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTextMarkerContextProviderMockImpl :
	public IVsTextMarkerContextProvider,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextMarkerContextProviderMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTextMarkerContextProviderMockImpl)

	typedef IVsTextMarkerContextProvider Interface;
	struct UpdateContextForMarkerValidValues
	{
		/*[in]*/ DWORD dwReserved;
		/*[in]*/ IVsUserContext* pUC;
		HRESULT retValue;
	};

	STDMETHOD(UpdateContextForMarker)(
		/*[in]*/ DWORD dwReserved,
		/*[in]*/ IVsUserContext* pUC)
	{
		VSL_DEFINE_MOCK_METHOD(UpdateContextForMarker)

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUC);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveLastContextValidValues
	{
		/*[in]*/ DWORD dwReserved;
		/*[in]*/ IVsUserContext* pUC;
		HRESULT retValue;
	};

	STDMETHOD(RemoveLastContext)(
		/*[in]*/ DWORD dwReserved,
		/*[in]*/ IVsUserContext* pUC)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveLastContext)

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUC);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTEXTMARKERCONTEXTPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTextMarkerClientEx.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTEXTMARKERCLIENTEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTEXTMARKERCLIENTEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTextMarkerClientExNotImpl :
	public IVsTextMarkerClientEx
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextMarkerClientExNotImpl)

public:

	typedef IVsTextMarkerClientEx Interface;

	STDMETHOD(MarkerInvalidated)(
		/*[in]*/ IVsTextLines* /*pBuffer*/,
		/*[in]*/ IVsTextMarker* /*pMarker*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnHoverOverMarker)(
		/*[in]*/ IVsTextView* /*pView*/,
		/*[in]*/ IVsTextMarker* /*pMarker*/,
		/*[in]*/ BOOL /*fShowUI*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTextMarkerClientExMockImpl :
	public IVsTextMarkerClientEx,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextMarkerClientExMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTextMarkerClientExMockImpl)

	typedef IVsTextMarkerClientEx Interface;
	struct MarkerInvalidatedValidValues
	{
		/*[in]*/ IVsTextLines* pBuffer;
		/*[in]*/ IVsTextMarker* pMarker;
		HRESULT retValue;
	};

	STDMETHOD(MarkerInvalidated)(
		/*[in]*/ IVsTextLines* pBuffer,
		/*[in]*/ IVsTextMarker* pMarker)
	{
		VSL_DEFINE_MOCK_METHOD(MarkerInvalidated)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBuffer);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pMarker);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnHoverOverMarkerValidValues
	{
		/*[in]*/ IVsTextView* pView;
		/*[in]*/ IVsTextMarker* pMarker;
		/*[in]*/ BOOL fShowUI;
		HRESULT retValue;
	};

	STDMETHOD(OnHoverOverMarker)(
		/*[in]*/ IVsTextView* pView,
		/*[in]*/ IVsTextMarker* pMarker,
		/*[in]*/ BOOL fShowUI)
	{
		VSL_DEFINE_MOCK_METHOD(OnHoverOverMarker)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pView);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pMarker);

		VSL_CHECK_VALIDVALUE(fShowUI);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTEXTMARKERCLIENTEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTextMarkerTypeProvider.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTEXTMARKERTYPEPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTEXTMARKERTYPEPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTextMarkerTypeProviderNotImpl :
	public IVsTextMarkerTypeProvider
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextMarkerTypeProviderNotImpl)

public:

	typedef IVsTextMarkerTypeProvider Interface;

	STDMETHOD(GetTextMarkerType)(
		/*[in]*/ GUID* /*pguidMarker*/,
		/*[out]*/ IVsPackageDefinedTextMarkerType** /*ppMarkerType*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTextMarkerTypeProviderMockImpl :
	public IVsTextMarkerTypeProvider,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextMarkerTypeProviderMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTextMarkerTypeProviderMockImpl)

	typedef IVsTextMarkerTypeProvider Interface;
	struct GetTextMarkerTypeValidValues
	{
		/*[in]*/ GUID* pguidMarker;
		/*[out]*/ IVsPackageDefinedTextMarkerType** ppMarkerType;
		HRESULT retValue;
	};

	STDMETHOD(GetTextMarkerType)(
		/*[in]*/ GUID* pguidMarker,
		/*[out]*/ IVsPackageDefinedTextMarkerType** ppMarkerType)
	{
		VSL_DEFINE_MOCK_METHOD(GetTextMarkerType)

		VSL_CHECK_VALIDVALUE_POINTER(pguidMarker);

		VSL_SET_VALIDVALUE_INTERFACE(ppMarkerType);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTEXTMARKERTYPEPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTextOut.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTEXTOUT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTEXTOUT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTextOutNotImpl :
	public IVsTextOut
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextOutNotImpl)

public:

	typedef IVsTextOut Interface;

	STDMETHOD(VsGetTextExtent)(
		/*[in]*/ DWORD_PTR /*hdc*/,
		/*[in]*/ int /*cch*/,
		/*[in,size_is(cch)]*/ LPCOLESTR /*pText*/,
		/*[out,retval]*/ SIZE* /*pSize*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(VsTextOut)(
		/*[in]*/ DWORD_PTR /*hdc*/,
		/*[in]*/ int /*cch*/,
		/*[in,size_is(cch)]*/ LPCOLESTR /*pText*/,
		/*[in]*/ DWORD /*grfETO*/,
		/*[in]*/ int /*x*/,
		/*[in]*/ int /*y*/,
		/*[in]*/ const RECT* /*prc*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTextOutMockImpl :
	public IVsTextOut,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextOutMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTextOutMockImpl)

	typedef IVsTextOut Interface;
	struct VsGetTextExtentValidValues
	{
		/*[in]*/ DWORD_PTR hdc;
		/*[in]*/ int cch;
		/*[in,size_is(cch)]*/ LPCOLESTR pText;
		/*[out,retval]*/ SIZE* pSize;
		HRESULT retValue;
	};

	STDMETHOD(VsGetTextExtent)(
		/*[in]*/ DWORD_PTR hdc,
		/*[in]*/ int cch,
		/*[in,size_is(cch)]*/ LPCOLESTR pText,
		/*[out,retval]*/ SIZE* pSize)
	{
		VSL_DEFINE_MOCK_METHOD(VsGetTextExtent)

		VSL_CHECK_VALIDVALUE(hdc);

		VSL_CHECK_VALIDVALUE(cch);

		VSL_CHECK_VALIDVALUE_STRINGW(pText);

		VSL_SET_VALIDVALUE(pSize);

		VSL_RETURN_VALIDVALUES();
	}
	struct VsTextOutValidValues
	{
		/*[in]*/ DWORD_PTR hdc;
		/*[in]*/ int cch;
		/*[in,size_is(cch)]*/ LPCOLESTR pText;
		/*[in]*/ DWORD grfETO;
		/*[in]*/ int x;
		/*[in]*/ int y;
		/*[in]*/ RECT* prc;
		HRESULT retValue;
	};

	STDMETHOD(VsTextOut)(
		/*[in]*/ DWORD_PTR hdc,
		/*[in]*/ int cch,
		/*[in,size_is(cch)]*/ LPCOLESTR pText,
		/*[in]*/ DWORD grfETO,
		/*[in]*/ int x,
		/*[in]*/ int y,
		/*[in]*/ const RECT* prc)
	{
		VSL_DEFINE_MOCK_METHOD(VsTextOut)

		VSL_CHECK_VALIDVALUE(hdc);

		VSL_CHECK_VALIDVALUE(cch);

		VSL_CHECK_VALIDVALUE_STRINGW(pText);

		VSL_CHECK_VALIDVALUE(grfETO);

		VSL_CHECK_VALIDVALUE(x);

		VSL_CHECK_VALIDVALUE(y);

		VSL_CHECK_VALIDVALUE_POINTER(prc);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTEXTOUT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTextReplaceEvents.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTEXTREPLACEEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTEXTREPLACEEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTextReplaceEventsNotImpl :
	public IVsTextReplaceEvents
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextReplaceEventsNotImpl)

public:

	typedef IVsTextReplaceEvents Interface;

	STDMETHOD(OnReplace)(
		/*[in]*/ const ChangeInput* /*pCI*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTextReplaceEventsMockImpl :
	public IVsTextReplaceEvents,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextReplaceEventsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTextReplaceEventsMockImpl)

	typedef IVsTextReplaceEvents Interface;
	struct OnReplaceValidValues
	{
		/*[in]*/ ChangeInput* pCI;
		HRESULT retValue;
	};

	STDMETHOD(OnReplace)(
		/*[in]*/ const ChangeInput* pCI)
	{
		VSL_DEFINE_MOCK_METHOD(OnReplace)

		VSL_CHECK_VALIDVALUE_POINTER(pCI);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTEXTREPLACEEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTextSelectionAction.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTEXTSELECTIONACTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTEXTSELECTIONACTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTextSelectionActionNotImpl :
	public IVsTextSelectionAction
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextSelectionActionNotImpl)

public:

	typedef IVsTextSelectionAction Interface;

	STDMETHOD(GetOrigin)(
		/*[out]*/ SELECTIONSTATE* /*pSelState*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDestination)(
		/*[out]*/ SELECTIONSTATE* /*pSelState*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetOrigin)(
		/*[in]*/ SELECTIONSTATE* /*pSelState*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetDestination)(
		/*[in]*/ SELECTIONSTATE* /*pSelState*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTextSelectionActionMockImpl :
	public IVsTextSelectionAction,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextSelectionActionMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTextSelectionActionMockImpl)

	typedef IVsTextSelectionAction Interface;
	struct GetOriginValidValues
	{
		/*[out]*/ SELECTIONSTATE* pSelState;
		HRESULT retValue;
	};

	STDMETHOD(GetOrigin)(
		/*[out]*/ SELECTIONSTATE* pSelState)
	{
		VSL_DEFINE_MOCK_METHOD(GetOrigin)

		VSL_SET_VALIDVALUE(pSelState);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDestinationValidValues
	{
		/*[out]*/ SELECTIONSTATE* pSelState;
		HRESULT retValue;
	};

	STDMETHOD(GetDestination)(
		/*[out]*/ SELECTIONSTATE* pSelState)
	{
		VSL_DEFINE_MOCK_METHOD(GetDestination)

		VSL_SET_VALIDVALUE(pSelState);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetOriginValidValues
	{
		/*[in]*/ SELECTIONSTATE* pSelState;
		HRESULT retValue;
	};

	STDMETHOD(SetOrigin)(
		/*[in]*/ SELECTIONSTATE* pSelState)
	{
		VSL_DEFINE_MOCK_METHOD(SetOrigin)

		VSL_CHECK_VALIDVALUE_POINTER(pSelState);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetDestinationValidValues
	{
		/*[in]*/ SELECTIONSTATE* pSelState;
		HRESULT retValue;
	};

	STDMETHOD(SetDestination)(
		/*[in]*/ SELECTIONSTATE* pSelState)
	{
		VSL_DEFINE_MOCK_METHOD(SetDestination)

		VSL_CHECK_VALIDVALUE_POINTER(pSelState);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTEXTSELECTIONACTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTextStorageColorState.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTEXTSTORAGECOLORSTATE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTEXTSTORAGECOLORSTATE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTextStorageColorStateNotImpl :
	public IVsTextStorageColorState
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextStorageColorStateNotImpl)

public:

	typedef IVsTextStorageColorState Interface;

	STDMETHOD(GetColorStateAtStartOfLine)(
		/*[in]*/ long /*iLine*/,
		/*[out]*/ long* /*piState*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTextStorageColorStateMockImpl :
	public IVsTextStorageColorState,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextStorageColorStateMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTextStorageColorStateMockImpl)

	typedef IVsTextStorageColorState Interface;
	struct GetColorStateAtStartOfLineValidValues
	{
		/*[in]*/ long iLine;
		/*[out]*/ long* piState;
		HRESULT retValue;
	};

	STDMETHOD(GetColorStateAtStartOfLine)(
		/*[in]*/ long iLine,
		/*[out]*/ long* piState)
	{
		VSL_DEFINE_MOCK_METHOD(GetColorStateAtStartOfLine)

		VSL_CHECK_VALIDVALUE(iLine);

		VSL_SET_VALIDVALUE(piState);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTEXTSTORAGECOLORSTATE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTextStreamMarker.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTEXTSTREAMMARKER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTEXTSTREAMMARKER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTextStreamMarkerNotImpl :
	public IVsTextStreamMarker
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextStreamMarkerNotImpl)

public:

	typedef IVsTextStreamMarker Interface;

	STDMETHOD(GetStreamBuffer)(
		/*[out]*/ IVsTextStream** /*ppBuffer*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ResetSpan)(
		/*[in]*/ long /*iNewPos*/,
		/*[in]*/ long /*iNewLen*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCurrentSpan)(
		/*[out]*/ long* /*piPos*/,
		/*[out]*/ long* /*piLen*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetType)(
		/*[out]*/ long* /*piMarkerType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetType)(
		/*[in]*/ long /*iMarkerType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetVisualStyle)(
		/*[out]*/ DWORD* /*pdwFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetVisualStyle)(
		/*[in]*/ DWORD /*dwFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invalidate)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DrawGlyph)(
		/*[in]*/ HDC /*hdc*/,
		/*[in]*/ RECT* /*pRect*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTipText)(
		/*[out,optional]*/ BSTR* /*pbstrText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnadviseClient)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMarkerCommandInfo)(
		/*[in]*/ long /*iItem*/,
		/*[out,custom(uuid_IVsTextMarker,"optional")]*/ BSTR* /*pbstrText*/,
		/*[out]*/ DWORD* /*pcmdf*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ExecMarkerCommand)(
		/*[in]*/ long /*iItem*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetBehavior)(
		/*[out]*/ DWORD* /*pdwBehavior*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetBehavior)(
		/*[in]*/ DWORD /*dwBehavior*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPriorityIndex)(
		/*[out]*/ long* /*piPriorityIndex*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTextStreamMarkerMockImpl :
	public IVsTextStreamMarker,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextStreamMarkerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTextStreamMarkerMockImpl)

	typedef IVsTextStreamMarker Interface;
	struct GetStreamBufferValidValues
	{
		/*[out]*/ IVsTextStream** ppBuffer;
		HRESULT retValue;
	};

	STDMETHOD(GetStreamBuffer)(
		/*[out]*/ IVsTextStream** ppBuffer)
	{
		VSL_DEFINE_MOCK_METHOD(GetStreamBuffer)

		VSL_SET_VALIDVALUE_INTERFACE(ppBuffer);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResetSpanValidValues
	{
		/*[in]*/ long iNewPos;
		/*[in]*/ long iNewLen;
		HRESULT retValue;
	};

	STDMETHOD(ResetSpan)(
		/*[in]*/ long iNewPos,
		/*[in]*/ long iNewLen)
	{
		VSL_DEFINE_MOCK_METHOD(ResetSpan)

		VSL_CHECK_VALIDVALUE(iNewPos);

		VSL_CHECK_VALIDVALUE(iNewLen);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCurrentSpanValidValues
	{
		/*[out]*/ long* piPos;
		/*[out]*/ long* piLen;
		HRESULT retValue;
	};

	STDMETHOD(GetCurrentSpan)(
		/*[out]*/ long* piPos,
		/*[out]*/ long* piLen)
	{
		VSL_DEFINE_MOCK_METHOD(GetCurrentSpan)

		VSL_SET_VALIDVALUE(piPos);

		VSL_SET_VALIDVALUE(piLen);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeValidValues
	{
		/*[out]*/ long* piMarkerType;
		HRESULT retValue;
	};

	STDMETHOD(GetType)(
		/*[out]*/ long* piMarkerType)
	{
		VSL_DEFINE_MOCK_METHOD(GetType)

		VSL_SET_VALIDVALUE(piMarkerType);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetTypeValidValues
	{
		/*[in]*/ long iMarkerType;
		HRESULT retValue;
	};

	STDMETHOD(SetType)(
		/*[in]*/ long iMarkerType)
	{
		VSL_DEFINE_MOCK_METHOD(SetType)

		VSL_CHECK_VALIDVALUE(iMarkerType);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetVisualStyleValidValues
	{
		/*[out]*/ DWORD* pdwFlags;
		HRESULT retValue;
	};

	STDMETHOD(GetVisualStyle)(
		/*[out]*/ DWORD* pdwFlags)
	{
		VSL_DEFINE_MOCK_METHOD(GetVisualStyle)

		VSL_SET_VALIDVALUE(pdwFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetVisualStyleValidValues
	{
		/*[in]*/ DWORD dwFlags;
		HRESULT retValue;
	};

	STDMETHOD(SetVisualStyle)(
		/*[in]*/ DWORD dwFlags)
	{
		VSL_DEFINE_MOCK_METHOD(SetVisualStyle)

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct InvalidateValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Invalidate)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Invalidate)

		VSL_RETURN_VALIDVALUES();
	}
	struct DrawGlyphValidValues
	{
		/*[in]*/ HDC hdc;
		/*[in]*/ RECT* pRect;
		HRESULT retValue;
	};

	STDMETHOD(DrawGlyph)(
		/*[in]*/ HDC hdc,
		/*[in]*/ RECT* pRect)
	{
		VSL_DEFINE_MOCK_METHOD(DrawGlyph)

		VSL_CHECK_VALIDVALUE(hdc);

		VSL_CHECK_VALIDVALUE_POINTER(pRect);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTipTextValidValues
	{
		/*[out,optional]*/ BSTR* pbstrText;
		HRESULT retValue;
	};

	STDMETHOD(GetTipText)(
		/*[out,optional]*/ BSTR* pbstrText)
	{
		VSL_DEFINE_MOCK_METHOD(GetTipText)

		VSL_SET_VALIDVALUE_BSTR(pbstrText);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnadviseClientValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(UnadviseClient)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(UnadviseClient)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMarkerCommandInfoValidValues
	{
		/*[in]*/ long iItem;
		/*[out,custom(uuid_IVsTextMarker,"optional")]*/ BSTR* pbstrText;
		/*[out]*/ DWORD* pcmdf;
		HRESULT retValue;
	};

	STDMETHOD(GetMarkerCommandInfo)(
		/*[in]*/ long iItem,
		/*[out,custom(uuid_IVsTextMarker,"optional")]*/ BSTR* pbstrText,
		/*[out]*/ DWORD* pcmdf)
	{
		VSL_DEFINE_MOCK_METHOD(GetMarkerCommandInfo)

		VSL_CHECK_VALIDVALUE(iItem);

		VSL_SET_VALIDVALUE_BSTR(pbstrText);

		VSL_SET_VALIDVALUE(pcmdf);

		VSL_RETURN_VALIDVALUES();
	}
	struct ExecMarkerCommandValidValues
	{
		/*[in]*/ long iItem;
		HRESULT retValue;
	};

	STDMETHOD(ExecMarkerCommand)(
		/*[in]*/ long iItem)
	{
		VSL_DEFINE_MOCK_METHOD(ExecMarkerCommand)

		VSL_CHECK_VALIDVALUE(iItem);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetBehaviorValidValues
	{
		/*[out]*/ DWORD* pdwBehavior;
		HRESULT retValue;
	};

	STDMETHOD(GetBehavior)(
		/*[out]*/ DWORD* pdwBehavior)
	{
		VSL_DEFINE_MOCK_METHOD(GetBehavior)

		VSL_SET_VALIDVALUE(pdwBehavior);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetBehaviorValidValues
	{
		/*[in]*/ DWORD dwBehavior;
		HRESULT retValue;
	};

	STDMETHOD(SetBehavior)(
		/*[in]*/ DWORD dwBehavior)
	{
		VSL_DEFINE_MOCK_METHOD(SetBehavior)

		VSL_CHECK_VALIDVALUE(dwBehavior);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPriorityIndexValidValues
	{
		/*[out]*/ long* piPriorityIndex;
		HRESULT retValue;
	};

	STDMETHOD(GetPriorityIndex)(
		/*[out]*/ long* piPriorityIndex)
	{
		VSL_DEFINE_MOCK_METHOD(GetPriorityIndex)

		VSL_SET_VALIDVALUE(piPriorityIndex);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTEXTSTREAMMARKER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTextStorage2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTEXTSTORAGE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTEXTSTORAGE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTextStorage2NotImpl :
	public IVsTextStorage2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextStorage2NotImpl)

public:

	typedef IVsTextStorage2 Interface;

	STDMETHOD(GetEolTypeEx)(
		/*[in]*/ const LINEDATAEX* /*pld*/,
		/*[out]*/ DWORD* /*piEolType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetEolLengthEx)(
		/*[in]*/ const LINEDATAEX* /*pld*/,
		/*[out]*/ unsigned int* /*piEolType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetEolTextEx)(
		/*[in]*/ const LINEDATAEX* /*pld*/,
		/*[out]*/ BSTR* /*pbstrEolText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetVersionCookie)(
		/*[out]*/ DWORD* /*pdwVersionCookie*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTextStorage2MockImpl :
	public IVsTextStorage2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextStorage2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTextStorage2MockImpl)

	typedef IVsTextStorage2 Interface;
	struct GetEolTypeExValidValues
	{
		/*[in]*/ LINEDATAEX* pld;
		/*[out]*/ DWORD* piEolType;
		HRESULT retValue;
	};

	STDMETHOD(GetEolTypeEx)(
		/*[in]*/ const LINEDATAEX* pld,
		/*[out]*/ DWORD* piEolType)
	{
		VSL_DEFINE_MOCK_METHOD(GetEolTypeEx)

		VSL_CHECK_VALIDVALUE_POINTER(pld);

		VSL_SET_VALIDVALUE(piEolType);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetEolLengthExValidValues
	{
		/*[in]*/ LINEDATAEX* pld;
		/*[out]*/ unsigned int* piEolType;
		HRESULT retValue;
	};

	STDMETHOD(GetEolLengthEx)(
		/*[in]*/ const LINEDATAEX* pld,
		/*[out]*/ unsigned int* piEolType)
	{
		VSL_DEFINE_MOCK_METHOD(GetEolLengthEx)

		VSL_CHECK_VALIDVALUE_POINTER(pld);

		VSL_SET_VALIDVALUE(piEolType);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetEolTextExValidValues
	{
		/*[in]*/ LINEDATAEX* pld;
		/*[out]*/ BSTR* pbstrEolText;
		HRESULT retValue;
	};

	STDMETHOD(GetEolTextEx)(
		/*[in]*/ const LINEDATAEX* pld,
		/*[out]*/ BSTR* pbstrEolText)
	{
		VSL_DEFINE_MOCK_METHOD(GetEolTextEx)

		VSL_CHECK_VALIDVALUE_POINTER(pld);

		VSL_SET_VALIDVALUE_BSTR(pbstrEolText);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetVersionCookieValidValues
	{
		/*[out]*/ DWORD* pdwVersionCookie;
		HRESULT retValue;
	};

	STDMETHOD(GetVersionCookie)(
		/*[out]*/ DWORD* pdwVersionCookie)
	{
		VSL_DEFINE_MOCK_METHOD(GetVersionCookie)

		VSL_SET_VALIDVALUE(pdwVersionCookie);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTEXTSTORAGE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTextSpanSet.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTEXTSPANSET_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTEXTSPANSET_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textfind.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTextSpanSetNotImpl :
	public IVsTextSpanSet
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextSpanSetNotImpl)

public:

	typedef IVsTextSpanSet Interface;

	STDMETHOD(AttachTextImage)(
		/*[in]*/ IUnknown* /*pText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Detach)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SuspendTracking)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ResumeTracking)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Add)(
		/*[in]*/ LONG /*cel*/,
		/*[in,size_is(cel)]*/ const TextSpan* /*pSpan*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCount)(
		/*[out,retval]*/ LONG* /*pcel*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetAt)(
		/*[in]*/ LONG /*iEl*/,
		/*[out,retval]*/ TextSpan* /*pSpan*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveAll)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Sort)(
		/*[in]*/ DWORD /*SortOptions*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddFromEnum)(
		/*[in]*/ IVsEnumTextSpans* /*pEnum*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTextSpanSetMockImpl :
	public IVsTextSpanSet,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextSpanSetMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTextSpanSetMockImpl)

	typedef IVsTextSpanSet Interface;
	struct AttachTextImageValidValues
	{
		/*[in]*/ IUnknown* pText;
		HRESULT retValue;
	};

	STDMETHOD(AttachTextImage)(
		/*[in]*/ IUnknown* pText)
	{
		VSL_DEFINE_MOCK_METHOD(AttachTextImage)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pText);

		VSL_RETURN_VALIDVALUES();
	}
	struct DetachValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Detach)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Detach)

		VSL_RETURN_VALIDVALUES();
	}
	struct SuspendTrackingValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(SuspendTracking)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(SuspendTracking)

		VSL_RETURN_VALIDVALUES();
	}
	struct ResumeTrackingValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(ResumeTracking)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(ResumeTracking)

		VSL_RETURN_VALIDVALUES();
	}
	struct AddValidValues
	{
		/*[in]*/ LONG cel;
		/*[in,size_is(cel)]*/ TextSpan* pSpan;
		HRESULT retValue;
	};

	STDMETHOD(Add)(
		/*[in]*/ LONG cel,
		/*[in,size_is(cel)]*/ const TextSpan* pSpan)
	{
		VSL_DEFINE_MOCK_METHOD(Add)

		VSL_CHECK_VALIDVALUE(cel);

		VSL_CHECK_VALIDVALUE_MEMCMP(pSpan, cel*sizeof(pSpan[0]), validValues.cel*sizeof(validValues.pSpan[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCountValidValues
	{
		/*[out,retval]*/ LONG* pcel;
		HRESULT retValue;
	};

	STDMETHOD(GetCount)(
		/*[out,retval]*/ LONG* pcel)
	{
		VSL_DEFINE_MOCK_METHOD(GetCount)

		VSL_SET_VALIDVALUE(pcel);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetAtValidValues
	{
		/*[in]*/ LONG iEl;
		/*[out,retval]*/ TextSpan* pSpan;
		HRESULT retValue;
	};

	STDMETHOD(GetAt)(
		/*[in]*/ LONG iEl,
		/*[out,retval]*/ TextSpan* pSpan)
	{
		VSL_DEFINE_MOCK_METHOD(GetAt)

		VSL_CHECK_VALIDVALUE(iEl);

		VSL_SET_VALIDVALUE(pSpan);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveAllValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(RemoveAll)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(RemoveAll)

		VSL_RETURN_VALIDVALUES();
	}
	struct SortValidValues
	{
		/*[in]*/ DWORD SortOptions;
		HRESULT retValue;
	};

	STDMETHOD(Sort)(
		/*[in]*/ DWORD SortOptions)
	{
		VSL_DEFINE_MOCK_METHOD(Sort)

		VSL_CHECK_VALIDVALUE(SortOptions);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddFromEnumValidValues
	{
		/*[in]*/ IVsEnumTextSpans* pEnum;
		HRESULT retValue;
	};

	STDMETHOD(AddFromEnum)(
		/*[in]*/ IVsEnumTextSpans* pEnum)
	{
		VSL_DEFINE_MOCK_METHOD(AddFromEnum)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pEnum);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTEXTSPANSET_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTextViewFilter.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTEXTVIEWFILTER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTEXTVIEWFILTER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTextViewFilterNotImpl :
	public IVsTextViewFilter
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextViewFilterNotImpl)

public:

	typedef IVsTextViewFilter Interface;

	STDMETHOD(GetWordExtent)(
		/*[in]*/ long /*iLine*/,
		/*[in]*/ CharIndex /*iIndex*/,
		/*[in]*/ DWORD /*dwFlags*/,
		/*[out]*/ TextSpan* /*pSpan*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDataTipText)(
		/*[in,out]*/ TextSpan* /*pSpan*/,
		/*[out]*/ BSTR* /*pbstrText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPairExtents)(
		/*[in]*/ long /*iLine*/,
		/*[in]*/ CharIndex /*iIndex*/,
		/*[out]*/ TextSpan* /*pSpan*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTextViewFilterMockImpl :
	public IVsTextViewFilter,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextViewFilterMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTextViewFilterMockImpl)

	typedef IVsTextViewFilter Interface;
	struct GetWordExtentValidValues
	{
		/*[in]*/ long iLine;
		/*[in]*/ CharIndex iIndex;
		/*[in]*/ DWORD dwFlags;
		/*[out]*/ TextSpan* pSpan;
		HRESULT retValue;
	};

	STDMETHOD(GetWordExtent)(
		/*[in]*/ long iLine,
		/*[in]*/ CharIndex iIndex,
		/*[in]*/ DWORD dwFlags,
		/*[out]*/ TextSpan* pSpan)
	{
		VSL_DEFINE_MOCK_METHOD(GetWordExtent)

		VSL_CHECK_VALIDVALUE(iLine);

		VSL_CHECK_VALIDVALUE(iIndex);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_SET_VALIDVALUE(pSpan);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDataTipTextValidValues
	{
		/*[in,out]*/ TextSpan* pSpan;
		/*[out]*/ BSTR* pbstrText;
		HRESULT retValue;
	};

	STDMETHOD(GetDataTipText)(
		/*[in,out]*/ TextSpan* pSpan,
		/*[out]*/ BSTR* pbstrText)
	{
		VSL_DEFINE_MOCK_METHOD(GetDataTipText)

		VSL_SET_VALIDVALUE(pSpan);

		VSL_SET_VALIDVALUE_BSTR(pbstrText);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPairExtentsValidValues
	{
		/*[in]*/ long iLine;
		/*[in]*/ CharIndex iIndex;
		/*[out]*/ TextSpan* pSpan;
		HRESULT retValue;
	};

	STDMETHOD(GetPairExtents)(
		/*[in]*/ long iLine,
		/*[in]*/ CharIndex iIndex,
		/*[out]*/ TextSpan* pSpan)
	{
		VSL_DEFINE_MOCK_METHOD(GetPairExtents)

		VSL_CHECK_VALIDVALUE(iLine);

		VSL_CHECK_VALIDVALUE(iIndex);

		VSL_SET_VALIDVALUE(pSpan);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTEXTVIEWFILTER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTextViewIntellisenseHostProvider.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTEXTVIEWINTELLISENSEHOSTPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTEXTVIEWINTELLISENSEHOSTPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "singlefileeditor.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTextViewIntellisenseHostProviderNotImpl :
	public IVsTextViewIntellisenseHostProvider
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextViewIntellisenseHostProviderNotImpl)

public:

	typedef IVsTextViewIntellisenseHostProvider Interface;

	STDMETHOD(CreateIntellisenseHost)(
		/*[in]*/ IVsTextBufferCoordinator* /*pBufferCoordinator*/,
		/*[in]*/ REFIID /*riid*/,
		/*[out,iid_is(riid)]*/ void** /*ppunkHost*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTextViewIntellisenseHostProviderMockImpl :
	public IVsTextViewIntellisenseHostProvider,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextViewIntellisenseHostProviderMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTextViewIntellisenseHostProviderMockImpl)

	typedef IVsTextViewIntellisenseHostProvider Interface;
	struct CreateIntellisenseHostValidValues
	{
		/*[in]*/ IVsTextBufferCoordinator* pBufferCoordinator;
		/*[in]*/ REFIID riid;
		/*[out,iid_is(riid)]*/ void** ppunkHost;
		HRESULT retValue;
	};

	STDMETHOD(CreateIntellisenseHost)(
		/*[in]*/ IVsTextBufferCoordinator* pBufferCoordinator,
		/*[in]*/ REFIID riid,
		/*[out,iid_is(riid)]*/ void** ppunkHost)
	{
		VSL_DEFINE_MOCK_METHOD(CreateIntellisenseHost)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pBufferCoordinator);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_SET_VALIDVALUE(ppunkHost);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTEXTVIEWINTELLISENSEHOSTPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTextViewIntellisenseHost.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTEXTVIEWINTELLISENSEHOST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTEXTVIEWINTELLISENSEHOST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "singlefileeditor.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTextViewIntellisenseHostNotImpl :
	public IVsTextViewIntellisenseHost
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextViewIntellisenseHostNotImpl)

public:

	typedef IVsTextViewIntellisenseHost Interface;

	STDMETHOD(SetSubjectFromPrimaryBuffer)(
		/*[in]*/ TextSpan* /*pSpanInPrimary*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetHostFlags)(
		/*[out,retval]*/ DWORD* /*pdwFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetContextBuffer)(
		/*[out,retval]*/ IVsTextLines** /*ppCtxBuffer*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetContextFocalPoint)(
		/*[out]*/ TextSpan* /*pSpan*/,
		/*[in]*/ long* /*piLen*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetContextCaretPos)(
		/*[in]*/ long /*iLine*/,
		/*[in]*/ long /*iIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetContextCaretPos)(
		/*[out]*/ long* /*piLine*/,
		/*[out]*/ long* /*piIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetContextSelection)(
		/*[in]*/ long /*iStartLine*/,
		/*[in]*/ long /*iStartIndex*/,
		/*[in]*/ long /*iEndLine*/,
		/*[in]*/ long /*iEndIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetContextSelection)(
		/*[out]*/ TextSpan* /*pSelectionSpan*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSubjectText)(
		/*[out,retval]*/ BSTR* /*pbstrSubjectText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetSubjectCaretPos)(
		/*[in]*/ long /*iIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSubjectCaretPos)(
		/*[out]*/ long* /*piIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetSubjectSelection)(
		/*[in]*/ long /*iAnchorIndex*/,
		/*[in]*/ long /*iEndIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSubjectSelection)(
		/*[out]*/ long* /*piAnchorIndex*/,
		/*[out]*/ long* /*piEndIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReplaceSubjectTextSpan)(
		/*[in]*/ long /*iStartIndex*/,
		/*[in]*/ long /*iEndIndex*/,
		/*[in]*/ LPCWSTR /*pszText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UpdateCompletionStatus)(
		/*[in]*/ IVsCompletionSet* /*pCompSet*/,
		/*[in]*/ DWORD /*dwFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UpdateTipWindow)(
		/*[in]*/ IVsTipWindow* /*pTipWindow*/,
		/*[in]*/ DWORD /*dwFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(HighlightMatchingBrace)(
		/*[in]*/ DWORD /*dwFlags*/,
		/*[in]*/ ULONG /*cSpans*/,
		/*[in,size_is(cSpans)]*/ TextSpan* /*rgBaseSpans*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(BeforeCompletorCommit)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AfterCompletorCommit)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetServiceProvider)(
		/*[out]*/ IServiceProvider** /*ppSP*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetHostWindow)(
		/*[out]*/ HWND* /*hwnd*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetContextLocation)(
		/*[in]*/ long /*iPos*/,
		/*[in]*/ long /*iLen*/,
		/*[in]*/ BOOL /*fUseCaretPosition*/,
		/*[out]*/ RECT* /*prc*/,
		/*[out]*/ long* /*piTopX*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UpdateSmartTagWindow)(
		/*[in]*/ IVsSmartTagTipWindow* /*pSmartTagWnd*/,
		/*[in]*/ DWORD /*dwFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSmartTagRect)(
		/*[out]*/ RECT* /*rcSmartTag*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryStatus)(
		/*[in,unique]*/ const GUID* /*pguidCmdGroup*/,
		/*[in]*/ ULONG /*cCmds*/,
		/*[size_is(cCmds),in,out]*/ OLECMD[] /*prgCmds*/,
		/*[in,out,unique]*/ OLECMDTEXT* /*pCmdText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Exec)(
		/*[in,unique]*/ const GUID* /*pguidCmdGroup*/,
		/*[in]*/ DWORD /*nCmdID*/,
		/*[in]*/ DWORD /*nCmdexecopt*/,
		/*[in,unique]*/ VARIANT* /*pvaIn*/,
		/*[in,out,unique]*/ VARIANT* /*pvaOut*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTextViewIntellisenseHostMockImpl :
	public IVsTextViewIntellisenseHost,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextViewIntellisenseHostMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTextViewIntellisenseHostMockImpl)

	typedef IVsTextViewIntellisenseHost Interface;
	struct SetSubjectFromPrimaryBufferValidValues
	{
		/*[in]*/ TextSpan* pSpanInPrimary;
		HRESULT retValue;
	};

	STDMETHOD(SetSubjectFromPrimaryBuffer)(
		/*[in]*/ TextSpan* pSpanInPrimary)
	{
		VSL_DEFINE_MOCK_METHOD(SetSubjectFromPrimaryBuffer)

		VSL_CHECK_VALIDVALUE_POINTER(pSpanInPrimary);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetHostFlagsValidValues
	{
		/*[out,retval]*/ DWORD* pdwFlags;
		HRESULT retValue;
	};

	STDMETHOD(GetHostFlags)(
		/*[out,retval]*/ DWORD* pdwFlags)
	{
		VSL_DEFINE_MOCK_METHOD(GetHostFlags)

		VSL_SET_VALIDVALUE(pdwFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetContextBufferValidValues
	{
		/*[out,retval]*/ IVsTextLines** ppCtxBuffer;
		HRESULT retValue;
	};

	STDMETHOD(GetContextBuffer)(
		/*[out,retval]*/ IVsTextLines** ppCtxBuffer)
	{
		VSL_DEFINE_MOCK_METHOD(GetContextBuffer)

		VSL_SET_VALIDVALUE_INTERFACE(ppCtxBuffer);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetContextFocalPointValidValues
	{
		/*[out]*/ TextSpan* pSpan;
		/*[in]*/ long* piLen;
		HRESULT retValue;
	};

	STDMETHOD(GetContextFocalPoint)(
		/*[out]*/ TextSpan* pSpan,
		/*[in]*/ long* piLen)
	{
		VSL_DEFINE_MOCK_METHOD(GetContextFocalPoint)

		VSL_SET_VALIDVALUE(pSpan);

		VSL_CHECK_VALIDVALUE_POINTER(piLen);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetContextCaretPosValidValues
	{
		/*[in]*/ long iLine;
		/*[in]*/ long iIndex;
		HRESULT retValue;
	};

	STDMETHOD(SetContextCaretPos)(
		/*[in]*/ long iLine,
		/*[in]*/ long iIndex)
	{
		VSL_DEFINE_MOCK_METHOD(SetContextCaretPos)

		VSL_CHECK_VALIDVALUE(iLine);

		VSL_CHECK_VALIDVALUE(iIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetContextCaretPosValidValues
	{
		/*[out]*/ long* piLine;
		/*[out]*/ long* piIndex;
		HRESULT retValue;
	};

	STDMETHOD(GetContextCaretPos)(
		/*[out]*/ long* piLine,
		/*[out]*/ long* piIndex)
	{
		VSL_DEFINE_MOCK_METHOD(GetContextCaretPos)

		VSL_SET_VALIDVALUE(piLine);

		VSL_SET_VALIDVALUE(piIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetContextSelectionValidValues
	{
		/*[in]*/ long iStartLine;
		/*[in]*/ long iStartIndex;
		/*[in]*/ long iEndLine;
		/*[in]*/ long iEndIndex;
		HRESULT retValue;
	};

	STDMETHOD(SetContextSelection)(
		/*[in]*/ long iStartLine,
		/*[in]*/ long iStartIndex,
		/*[in]*/ long iEndLine,
		/*[in]*/ long iEndIndex)
	{
		VSL_DEFINE_MOCK_METHOD(SetContextSelection)

		VSL_CHECK_VALIDVALUE(iStartLine);

		VSL_CHECK_VALIDVALUE(iStartIndex);

		VSL_CHECK_VALIDVALUE(iEndLine);

		VSL_CHECK_VALIDVALUE(iEndIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetContextSelectionValidValues
	{
		/*[out]*/ TextSpan* pSelectionSpan;
		HRESULT retValue;
	};

	STDMETHOD(GetContextSelection)(
		/*[out]*/ TextSpan* pSelectionSpan)
	{
		VSL_DEFINE_MOCK_METHOD(GetContextSelection)

		VSL_SET_VALIDVALUE(pSelectionSpan);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSubjectTextValidValues
	{
		/*[out,retval]*/ BSTR* pbstrSubjectText;
		HRESULT retValue;
	};

	STDMETHOD(GetSubjectText)(
		/*[out,retval]*/ BSTR* pbstrSubjectText)
	{
		VSL_DEFINE_MOCK_METHOD(GetSubjectText)

		VSL_SET_VALIDVALUE_BSTR(pbstrSubjectText);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetSubjectCaretPosValidValues
	{
		/*[in]*/ long iIndex;
		HRESULT retValue;
	};

	STDMETHOD(SetSubjectCaretPos)(
		/*[in]*/ long iIndex)
	{
		VSL_DEFINE_MOCK_METHOD(SetSubjectCaretPos)

		VSL_CHECK_VALIDVALUE(iIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSubjectCaretPosValidValues
	{
		/*[out]*/ long* piIndex;
		HRESULT retValue;
	};

	STDMETHOD(GetSubjectCaretPos)(
		/*[out]*/ long* piIndex)
	{
		VSL_DEFINE_MOCK_METHOD(GetSubjectCaretPos)

		VSL_SET_VALIDVALUE(piIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetSubjectSelectionValidValues
	{
		/*[in]*/ long iAnchorIndex;
		/*[in]*/ long iEndIndex;
		HRESULT retValue;
	};

	STDMETHOD(SetSubjectSelection)(
		/*[in]*/ long iAnchorIndex,
		/*[in]*/ long iEndIndex)
	{
		VSL_DEFINE_MOCK_METHOD(SetSubjectSelection)

		VSL_CHECK_VALIDVALUE(iAnchorIndex);

		VSL_CHECK_VALIDVALUE(iEndIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSubjectSelectionValidValues
	{
		/*[out]*/ long* piAnchorIndex;
		/*[out]*/ long* piEndIndex;
		HRESULT retValue;
	};

	STDMETHOD(GetSubjectSelection)(
		/*[out]*/ long* piAnchorIndex,
		/*[out]*/ long* piEndIndex)
	{
		VSL_DEFINE_MOCK_METHOD(GetSubjectSelection)

		VSL_SET_VALIDVALUE(piAnchorIndex);

		VSL_SET_VALIDVALUE(piEndIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReplaceSubjectTextSpanValidValues
	{
		/*[in]*/ long iStartIndex;
		/*[in]*/ long iEndIndex;
		/*[in]*/ LPCWSTR pszText;
		HRESULT retValue;
	};

	STDMETHOD(ReplaceSubjectTextSpan)(
		/*[in]*/ long iStartIndex,
		/*[in]*/ long iEndIndex,
		/*[in]*/ LPCWSTR pszText)
	{
		VSL_DEFINE_MOCK_METHOD(ReplaceSubjectTextSpan)

		VSL_CHECK_VALIDVALUE(iStartIndex);

		VSL_CHECK_VALIDVALUE(iEndIndex);

		VSL_CHECK_VALIDVALUE_STRINGW(pszText);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateCompletionStatusValidValues
	{
		/*[in]*/ IVsCompletionSet* pCompSet;
		/*[in]*/ DWORD dwFlags;
		HRESULT retValue;
	};

	STDMETHOD(UpdateCompletionStatus)(
		/*[in]*/ IVsCompletionSet* pCompSet,
		/*[in]*/ DWORD dwFlags)
	{
		VSL_DEFINE_MOCK_METHOD(UpdateCompletionStatus)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCompSet);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateTipWindowValidValues
	{
		/*[in]*/ IVsTipWindow* pTipWindow;
		/*[in]*/ DWORD dwFlags;
		HRESULT retValue;
	};

	STDMETHOD(UpdateTipWindow)(
		/*[in]*/ IVsTipWindow* pTipWindow,
		/*[in]*/ DWORD dwFlags)
	{
		VSL_DEFINE_MOCK_METHOD(UpdateTipWindow)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pTipWindow);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct HighlightMatchingBraceValidValues
	{
		/*[in]*/ DWORD dwFlags;
		/*[in]*/ ULONG cSpans;
		/*[in,size_is(cSpans)]*/ TextSpan* rgBaseSpans;
		HRESULT retValue;
	};

	STDMETHOD(HighlightMatchingBrace)(
		/*[in]*/ DWORD dwFlags,
		/*[in]*/ ULONG cSpans,
		/*[in,size_is(cSpans)]*/ TextSpan* rgBaseSpans)
	{
		VSL_DEFINE_MOCK_METHOD(HighlightMatchingBrace)

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_CHECK_VALIDVALUE(cSpans);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgBaseSpans, cSpans*sizeof(rgBaseSpans[0]), validValues.cSpans*sizeof(validValues.rgBaseSpans[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct BeforeCompletorCommitValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(BeforeCompletorCommit)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(BeforeCompletorCommit)

		VSL_RETURN_VALIDVALUES();
	}
	struct AfterCompletorCommitValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(AfterCompletorCommit)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(AfterCompletorCommit)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetServiceProviderValidValues
	{
		/*[out]*/ IServiceProvider** ppSP;
		HRESULT retValue;
	};

	STDMETHOD(GetServiceProvider)(
		/*[out]*/ IServiceProvider** ppSP)
	{
		VSL_DEFINE_MOCK_METHOD(GetServiceProvider)

		VSL_SET_VALIDVALUE_INTERFACE(ppSP);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetHostWindowValidValues
	{
		/*[out]*/ HWND* hwnd;
		HRESULT retValue;
	};

	STDMETHOD(GetHostWindow)(
		/*[out]*/ HWND* hwnd)
	{
		VSL_DEFINE_MOCK_METHOD(GetHostWindow)

		VSL_SET_VALIDVALUE(hwnd);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetContextLocationValidValues
	{
		/*[in]*/ long iPos;
		/*[in]*/ long iLen;
		/*[in]*/ BOOL fUseCaretPosition;
		/*[out]*/ RECT* prc;
		/*[out]*/ long* piTopX;
		HRESULT retValue;
	};

	STDMETHOD(GetContextLocation)(
		/*[in]*/ long iPos,
		/*[in]*/ long iLen,
		/*[in]*/ BOOL fUseCaretPosition,
		/*[out]*/ RECT* prc,
		/*[out]*/ long* piTopX)
	{
		VSL_DEFINE_MOCK_METHOD(GetContextLocation)

		VSL_CHECK_VALIDVALUE(iPos);

		VSL_CHECK_VALIDVALUE(iLen);

		VSL_CHECK_VALIDVALUE(fUseCaretPosition);

		VSL_SET_VALIDVALUE(prc);

		VSL_SET_VALIDVALUE(piTopX);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateSmartTagWindowValidValues
	{
		/*[in]*/ IVsSmartTagTipWindow* pSmartTagWnd;
		/*[in]*/ DWORD dwFlags;
		HRESULT retValue;
	};

	STDMETHOD(UpdateSmartTagWindow)(
		/*[in]*/ IVsSmartTagTipWindow* pSmartTagWnd,
		/*[in]*/ DWORD dwFlags)
	{
		VSL_DEFINE_MOCK_METHOD(UpdateSmartTagWindow)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSmartTagWnd);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSmartTagRectValidValues
	{
		/*[out]*/ RECT* rcSmartTag;
		HRESULT retValue;
	};

	STDMETHOD(GetSmartTagRect)(
		/*[out]*/ RECT* rcSmartTag)
	{
		VSL_DEFINE_MOCK_METHOD(GetSmartTagRect)

		VSL_SET_VALIDVALUE(rcSmartTag);

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryStatusValidValues
	{
		/*[in,unique]*/ GUID* pguidCmdGroup;
		/*[in]*/ ULONG cCmds;
		/*[size_is(cCmds),in,out]*/ OLECMD* prgCmds;
		/*[in,out,unique]*/ OLECMDTEXT* pCmdText;
		HRESULT retValue;
	};

	STDMETHOD(QueryStatus)(
		/*[in,unique]*/ const GUID* pguidCmdGroup,
		/*[in]*/ ULONG cCmds,
		/*[size_is(cCmds),in,out]*/ OLECMD prgCmds[],
		/*[in,out,unique]*/ OLECMDTEXT* pCmdText)
	{
		VSL_DEFINE_MOCK_METHOD(QueryStatus)

		VSL_CHECK_VALIDVALUE_POINTER(pguidCmdGroup);

		VSL_CHECK_VALIDVALUE(cCmds);

		VSL_SET_VALIDVALUE_MEMCPY(prgCmds, cCmds*sizeof(prgCmds[0]), validValues.cCmds*sizeof(validValues.prgCmds[0]));

		VSL_SET_VALIDVALUE(pCmdText);

		VSL_RETURN_VALIDVALUES();
	}
	struct ExecValidValues
	{
		/*[in,unique]*/ GUID* pguidCmdGroup;
		/*[in]*/ DWORD nCmdID;
		/*[in]*/ DWORD nCmdexecopt;
		/*[in,unique]*/ VARIANT* pvaIn;
		/*[in,out,unique]*/ VARIANT* pvaOut;
		HRESULT retValue;
	};

	STDMETHOD(Exec)(
		/*[in,unique]*/ const GUID* pguidCmdGroup,
		/*[in]*/ DWORD nCmdID,
		/*[in]*/ DWORD nCmdexecopt,
		/*[in,unique]*/ VARIANT* pvaIn,
		/*[in,out,unique]*/ VARIANT* pvaOut)
	{
		VSL_DEFINE_MOCK_METHOD(Exec)

		VSL_CHECK_VALIDVALUE_POINTER(pguidCmdGroup);

		VSL_CHECK_VALIDVALUE(nCmdID);

		VSL_CHECK_VALIDVALUE(nCmdexecopt);

		VSL_CHECK_VALIDVALUE_POINTER(pvaIn);

		VSL_SET_VALIDVALUE_VARIANT(pvaOut);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTEXTVIEWINTELLISENSEHOST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTextTipWindow.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTEXTTIPWINDOW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTEXTTIPWINDOW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTextTipWindowNotImpl :
	public IVsTextTipWindow
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextTipWindowNotImpl)

public:

	typedef IVsTextTipWindow Interface;

	STDMETHOD(SetTextTipData)(
		/*[in]*/ IVsTextTipData* /*pMethodData*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetContextStream)(
		/*[out]*/ long* /*piPos*/,
		/*[out]*/ long* /*piLength*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSizePreferences)(
		/*[out]*/ const RECT* /*prcCtxBounds*/,
		/*[out]*/ TIPSIZEDATA* /*pSizeData*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Paint)(
		/*[in]*/ HDC /*hdc*/,
		/*[in]*/ const RECT* /*prc*/)VSL_STDMETHOD_NOTIMPL

	virtual void STDMETHODCALLTYPE Dismiss(){ return ; }

	virtual LRESULT STDMETHODCALLTYPE WndProc(
		/*[in]*/ HWND /*hwnd*/,
		/*[in]*/ UINT /*iMsg*/,
		/*[in]*/ WPARAM /*wParam*/,
		/*[in]*/ LPARAM /*lParam*/){ return LRESULT(); }
};

class IVsTextTipWindowMockImpl :
	public IVsTextTipWindow,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextTipWindowMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTextTipWindowMockImpl)

	typedef IVsTextTipWindow Interface;
	struct SetTextTipDataValidValues
	{
		/*[in]*/ IVsTextTipData* pMethodData;
		HRESULT retValue;
	};

	STDMETHOD(SetTextTipData)(
		/*[in]*/ IVsTextTipData* pMethodData)
	{
		VSL_DEFINE_MOCK_METHOD(SetTextTipData)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pMethodData);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetContextStreamValidValues
	{
		/*[out]*/ long* piPos;
		/*[out]*/ long* piLength;
		HRESULT retValue;
	};

	STDMETHOD(GetContextStream)(
		/*[out]*/ long* piPos,
		/*[out]*/ long* piLength)
	{
		VSL_DEFINE_MOCK_METHOD(GetContextStream)

		VSL_SET_VALIDVALUE(piPos);

		VSL_SET_VALIDVALUE(piLength);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSizePreferencesValidValues
	{
		/*[out]*/ RECT* prcCtxBounds;
		/*[out]*/ TIPSIZEDATA* pSizeData;
		HRESULT retValue;
	};

	STDMETHOD(GetSizePreferences)(
		/*[out]*/ const RECT* prcCtxBounds,
		/*[out]*/ TIPSIZEDATA* pSizeData)
	{
		VSL_DEFINE_MOCK_METHOD(GetSizePreferences)

		VSL_SET_VALIDVALUE_CONST(prcCtxBounds, RECT*);

		VSL_SET_VALIDVALUE(pSizeData);

		VSL_RETURN_VALIDVALUES();
	}
	struct PaintValidValues
	{
		/*[in]*/ HDC hdc;
		/*[in]*/ RECT* prc;
		HRESULT retValue;
	};

	STDMETHOD(Paint)(
		/*[in]*/ HDC hdc,
		/*[in]*/ const RECT* prc)
	{
		VSL_DEFINE_MOCK_METHOD(Paint)

		VSL_CHECK_VALIDVALUE(hdc);

		VSL_CHECK_VALIDVALUE_POINTER(prc);

		VSL_RETURN_VALIDVALUES();
	}

	virtual void _stdcall Dismiss()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS_NORETURN(Dismiss)

	}
	struct WndProcValidValues
	{
		/*[in]*/ HWND hwnd;
		/*[in]*/ UINT iMsg;
		/*[in]*/ WPARAM wParam;
		/*[in]*/ LPARAM lParam;
		LRESULT retValue;
	};

	virtual LRESULT _stdcall WndProc(
		/*[in]*/ HWND hwnd,
		/*[in]*/ UINT iMsg,
		/*[in]*/ WPARAM wParam,
		/*[in]*/ LPARAM lParam)
	{
		VSL_DEFINE_MOCK_METHOD(WndProc)

		VSL_CHECK_VALIDVALUE(hwnd);

		VSL_CHECK_VALIDVALUE(iMsg);

		VSL_CHECK_VALIDVALUE(wParam);

		VSL_CHECK_VALIDVALUE(lParam);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTEXTTIPWINDOW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsThreadedWaitDialog.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTHREADEDWAITDIALOG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTHREADEDWAITDIALOG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsThreadedWaitDialogNotImpl :
	public IVsThreadedWaitDialog
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsThreadedWaitDialogNotImpl)

public:

	typedef IVsThreadedWaitDialog Interface;

	STDMETHOD(StartWaitDialog)(
		/*[in]*/ BSTR /*bstrWaitCaption*/,
		/*[in]*/ BSTR /*bstrWaitMessage*/,
		/*[in]*/ BSTR /*bstrIfTruncateAppend*/,
		/*[in]*/ VSTWDFLAGS /*dwFlags*/,
		/*[in]*/ VARIANT /*varStatusBmpAnim*/,
		/*[in]*/ BSTR /*bstrStatusBarText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EndWaitDialog)(
		/*[in]*/ BOOL* /*pfCancelled*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GiveTimeSlice)(
		/*[in]*/ BSTR /*bstrUpdatedWaitMessage*/,
		/*[in]*/ BSTR /*bstrIfTruncateAppend*/,
		/*[in]*/ BOOL /*fDisableCancel*/,
		/*[out]*/ BOOL* /*pfCancelled*/)VSL_STDMETHOD_NOTIMPL
};

class IVsThreadedWaitDialogMockImpl :
	public IVsThreadedWaitDialog,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsThreadedWaitDialogMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsThreadedWaitDialogMockImpl)

	typedef IVsThreadedWaitDialog Interface;
	struct StartWaitDialogValidValues
	{
		/*[in]*/ BSTR bstrWaitCaption;
		/*[in]*/ BSTR bstrWaitMessage;
		/*[in]*/ BSTR bstrIfTruncateAppend;
		/*[in]*/ VSTWDFLAGS dwFlags;
		/*[in]*/ VARIANT varStatusBmpAnim;
		/*[in]*/ BSTR bstrStatusBarText;
		HRESULT retValue;
	};

	STDMETHOD(StartWaitDialog)(
		/*[in]*/ BSTR bstrWaitCaption,
		/*[in]*/ BSTR bstrWaitMessage,
		/*[in]*/ BSTR bstrIfTruncateAppend,
		/*[in]*/ VSTWDFLAGS dwFlags,
		/*[in]*/ VARIANT varStatusBmpAnim,
		/*[in]*/ BSTR bstrStatusBarText)
	{
		VSL_DEFINE_MOCK_METHOD(StartWaitDialog)

		VSL_CHECK_VALIDVALUE_BSTR(bstrWaitCaption);

		VSL_CHECK_VALIDVALUE_BSTR(bstrWaitMessage);

		VSL_CHECK_VALIDVALUE_BSTR(bstrIfTruncateAppend);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_CHECK_VALIDVALUE(varStatusBmpAnim);

		VSL_CHECK_VALIDVALUE_BSTR(bstrStatusBarText);

		VSL_RETURN_VALIDVALUES();
	}
	struct EndWaitDialogValidValues
	{
		/*[in]*/ BOOL* pfCancelled;
		HRESULT retValue;
	};

	STDMETHOD(EndWaitDialog)(
		/*[in]*/ BOOL* pfCancelled)
	{
		VSL_DEFINE_MOCK_METHOD(EndWaitDialog)

		VSL_CHECK_VALIDVALUE_POINTER(pfCancelled);

		VSL_RETURN_VALIDVALUES();
	}
	struct GiveTimeSliceValidValues
	{
		/*[in]*/ BSTR bstrUpdatedWaitMessage;
		/*[in]*/ BSTR bstrIfTruncateAppend;
		/*[in]*/ BOOL fDisableCancel;
		/*[out]*/ BOOL* pfCancelled;
		HRESULT retValue;
	};

	STDMETHOD(GiveTimeSlice)(
		/*[in]*/ BSTR bstrUpdatedWaitMessage,
		/*[in]*/ BSTR bstrIfTruncateAppend,
		/*[in]*/ BOOL fDisableCancel,
		/*[out]*/ BOOL* pfCancelled)
	{
		VSL_DEFINE_MOCK_METHOD(GiveTimeSlice)

		VSL_CHECK_VALIDVALUE_BSTR(bstrUpdatedWaitMessage);

		VSL_CHECK_VALIDVALUE_BSTR(bstrIfTruncateAppend);

		VSL_CHECK_VALIDVALUE(fDisableCancel);

		VSL_SET_VALIDVALUE(pfCancelled);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTHREADEDWAITDIALOG_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsThreadPool.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTHREADPOOL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTHREADPOOL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsThreadPoolNotImpl :
	public IVsThreadPool
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsThreadPoolNotImpl)

public:

	typedef IVsThreadPool Interface;

	STDMETHOD(ScheduleTask)(
		/*[in]*/ DWORD_PTR /*pTaskProc*/,
		/*[in]*/ DWORD_PTR /*pvParam*/,
		/*[in]*/ VSBACKGROUNDTASKPRIORITY /*priority*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ScheduleWaitableTask)(
		/*[in]*/ DWORD_PTR /*hWait*/,
		/*[in]*/ DWORD_PTR /*pTaskProc*/,
		/*[in]*/ DWORD_PTR /*pvParam*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnscheduleWaitableTask)(
		/*[in]*/ DWORD_PTR /*hWait*/)VSL_STDMETHOD_NOTIMPL
};

class IVsThreadPoolMockImpl :
	public IVsThreadPool,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsThreadPoolMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsThreadPoolMockImpl)

	typedef IVsThreadPool Interface;
	struct ScheduleTaskValidValues
	{
		/*[in]*/ DWORD_PTR pTaskProc;
		/*[in]*/ DWORD_PTR pvParam;
		/*[in]*/ VSBACKGROUNDTASKPRIORITY priority;
		HRESULT retValue;
	};

	STDMETHOD(ScheduleTask)(
		/*[in]*/ DWORD_PTR pTaskProc,
		/*[in]*/ DWORD_PTR pvParam,
		/*[in]*/ VSBACKGROUNDTASKPRIORITY priority)
	{
		VSL_DEFINE_MOCK_METHOD(ScheduleTask)

		VSL_CHECK_VALIDVALUE(pTaskProc);

		VSL_CHECK_VALIDVALUE(pvParam);

		VSL_CHECK_VALIDVALUE(priority);

		VSL_RETURN_VALIDVALUES();
	}
	struct ScheduleWaitableTaskValidValues
	{
		/*[in]*/ DWORD_PTR hWait;
		/*[in]*/ DWORD_PTR pTaskProc;
		/*[in]*/ DWORD_PTR pvParam;
		HRESULT retValue;
	};

	STDMETHOD(ScheduleWaitableTask)(
		/*[in]*/ DWORD_PTR hWait,
		/*[in]*/ DWORD_PTR pTaskProc,
		/*[in]*/ DWORD_PTR pvParam)
	{
		VSL_DEFINE_MOCK_METHOD(ScheduleWaitableTask)

		VSL_CHECK_VALIDVALUE(hWait);

		VSL_CHECK_VALIDVALUE(pTaskProc);

		VSL_CHECK_VALIDVALUE(pvParam);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnscheduleWaitableTaskValidValues
	{
		/*[in]*/ DWORD_PTR hWait;
		HRESULT retValue;
	};

	STDMETHOD(UnscheduleWaitableTask)(
		/*[in]*/ DWORD_PTR hWait)
	{
		VSL_DEFINE_MOCK_METHOD(UnscheduleWaitableTask)

		VSL_CHECK_VALIDVALUE(hWait);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTHREADPOOL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTextViewEx.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTEXTVIEWEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTEXTVIEWEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTextViewExNotImpl :
	public IVsTextViewEx
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextViewExNotImpl)

public:

	typedef IVsTextViewEx Interface;

	STDMETHOD(SetHoverWaitTimer)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(PersistOutliningState)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UpdateSmartTagWindow)(
		/*[in]*/ IVsSmartTagTipWindow* /*pSmartTagWnd*/,
		/*[in]*/ DWORD /*dwFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSmartTagRect)(
		/*[out]*/ RECT* /*rcSmartTag*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(InvokeInsertionUI)(
		/*[in]*/ IVsCompletionSet* /*pCompSet*/,
		/*[in]*/ BSTR /*bstrPrefixText*/,
		/*[in]*/ BSTR /*bstrCompletionChar*/,
		/*[out]*/ IVsInsertionUI** /*pInsertionUI*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetWindowFrame)(
		/*[out]*/ IUnknown** /*ppFrame*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsCompletorWindowActive)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetClusterRange)(
		/*[in]*/ long /*iLine*/,
		/*[in]*/ INT /*iDisplayCol*/,
		/*[out]*/ INT* /*picCharacter*/,
		/*[out]*/ INT* /*piStartCol*/,
		/*[out]*/ INT* /*piEndCol*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetIgnoreMarkerTypes)(
		/*[in]*/ long /*iCountMarkerTypes*/,
		/*[in]*/ DWORD* /*rgIgnoreMarkerTypes*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AppendViewOnlyMarkerTypes)(
		/*[in]*/ unsigned int /*iCountViewMarkerOnly*/,
		/*[in]*/ const DWORD* /*rgViewMarkerOnly*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveViewOnlyMarkerTypes)(
		/*[in]*/ unsigned int /*iCountViewMarkerOnly*/,
		/*[in]*/ const DWORD* /*rgViewMarkerOnly*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetBackgroundColorIndex)(
		/*[in]*/ long /*iBackgroundIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsExpansionUIActive)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsReadOnly)()VSL_STDMETHOD_NOTIMPL
};

class IVsTextViewExMockImpl :
	public IVsTextViewEx,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTextViewExMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTextViewExMockImpl)

	typedef IVsTextViewEx Interface;
	struct SetHoverWaitTimerValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(SetHoverWaitTimer)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(SetHoverWaitTimer)

		VSL_RETURN_VALIDVALUES();
	}
	struct PersistOutliningStateValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(PersistOutliningState)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(PersistOutliningState)

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateSmartTagWindowValidValues
	{
		/*[in]*/ IVsSmartTagTipWindow* pSmartTagWnd;
		/*[in]*/ DWORD dwFlags;
		HRESULT retValue;
	};

	STDMETHOD(UpdateSmartTagWindow)(
		/*[in]*/ IVsSmartTagTipWindow* pSmartTagWnd,
		/*[in]*/ DWORD dwFlags)
	{
		VSL_DEFINE_MOCK_METHOD(UpdateSmartTagWindow)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSmartTagWnd);

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSmartTagRectValidValues
	{
		/*[out]*/ RECT* rcSmartTag;
		HRESULT retValue;
	};

	STDMETHOD(GetSmartTagRect)(
		/*[out]*/ RECT* rcSmartTag)
	{
		VSL_DEFINE_MOCK_METHOD(GetSmartTagRect)

		VSL_SET_VALIDVALUE(rcSmartTag);

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeInsertionUIValidValues
	{
		/*[in]*/ IVsCompletionSet* pCompSet;
		/*[in]*/ BSTR bstrPrefixText;
		/*[in]*/ BSTR bstrCompletionChar;
		/*[out]*/ IVsInsertionUI** pInsertionUI;
		HRESULT retValue;
	};

	STDMETHOD(InvokeInsertionUI)(
		/*[in]*/ IVsCompletionSet* pCompSet,
		/*[in]*/ BSTR bstrPrefixText,
		/*[in]*/ BSTR bstrCompletionChar,
		/*[out]*/ IVsInsertionUI** pInsertionUI)
	{
		VSL_DEFINE_MOCK_METHOD(InvokeInsertionUI)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCompSet);

		VSL_CHECK_VALIDVALUE_BSTR(bstrPrefixText);

		VSL_CHECK_VALIDVALUE_BSTR(bstrCompletionChar);

		VSL_SET_VALIDVALUE_INTERFACE(pInsertionUI);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetWindowFrameValidValues
	{
		/*[out]*/ IUnknown** ppFrame;
		HRESULT retValue;
	};

	STDMETHOD(GetWindowFrame)(
		/*[out]*/ IUnknown** ppFrame)
	{
		VSL_DEFINE_MOCK_METHOD(GetWindowFrame)

		VSL_SET_VALIDVALUE_INTERFACE(ppFrame);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsCompletorWindowActiveValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(IsCompletorWindowActive)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(IsCompletorWindowActive)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetClusterRangeValidValues
	{
		/*[in]*/ long iLine;
		/*[in]*/ INT iDisplayCol;
		/*[out]*/ INT* picCharacter;
		/*[out]*/ INT* piStartCol;
		/*[out]*/ INT* piEndCol;
		HRESULT retValue;
	};

	STDMETHOD(GetClusterRange)(
		/*[in]*/ long iLine,
		/*[in]*/ INT iDisplayCol,
		/*[out]*/ INT* picCharacter,
		/*[out]*/ INT* piStartCol,
		/*[out]*/ INT* piEndCol)
	{
		VSL_DEFINE_MOCK_METHOD(GetClusterRange)

		VSL_CHECK_VALIDVALUE(iLine);

		VSL_CHECK_VALIDVALUE(iDisplayCol);

		VSL_SET_VALIDVALUE(picCharacter);

		VSL_SET_VALIDVALUE(piStartCol);

		VSL_SET_VALIDVALUE(piEndCol);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetIgnoreMarkerTypesValidValues
	{
		/*[in]*/ long iCountMarkerTypes;
		/*[in]*/ DWORD* rgIgnoreMarkerTypes;
		HRESULT retValue;
	};

	STDMETHOD(SetIgnoreMarkerTypes)(
		/*[in]*/ long iCountMarkerTypes,
		/*[in]*/ DWORD* rgIgnoreMarkerTypes)
	{
		VSL_DEFINE_MOCK_METHOD(SetIgnoreMarkerTypes)

		VSL_CHECK_VALIDVALUE(iCountMarkerTypes);

		VSL_CHECK_VALIDVALUE_POINTER(rgIgnoreMarkerTypes);

		VSL_RETURN_VALIDVALUES();
	}
	struct AppendViewOnlyMarkerTypesValidValues
	{
		/*[in]*/ unsigned int iCountViewMarkerOnly;
		/*[in]*/ DWORD* rgViewMarkerOnly;
		HRESULT retValue;
	};

	STDMETHOD(AppendViewOnlyMarkerTypes)(
		/*[in]*/ unsigned int iCountViewMarkerOnly,
		/*[in]*/ const DWORD* rgViewMarkerOnly)
	{
		VSL_DEFINE_MOCK_METHOD(AppendViewOnlyMarkerTypes)

		VSL_CHECK_VALIDVALUE(iCountViewMarkerOnly);

		VSL_CHECK_VALIDVALUE_POINTER(rgViewMarkerOnly);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveViewOnlyMarkerTypesValidValues
	{
		/*[in]*/ unsigned int iCountViewMarkerOnly;
		/*[in]*/ DWORD* rgViewMarkerOnly;
		HRESULT retValue;
	};

	STDMETHOD(RemoveViewOnlyMarkerTypes)(
		/*[in]*/ unsigned int iCountViewMarkerOnly,
		/*[in]*/ const DWORD* rgViewMarkerOnly)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveViewOnlyMarkerTypes)

		VSL_CHECK_VALIDVALUE(iCountViewMarkerOnly);

		VSL_CHECK_VALIDVALUE_POINTER(rgViewMarkerOnly);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetBackgroundColorIndexValidValues
	{
		/*[in]*/ long iBackgroundIndex;
		HRESULT retValue;
	};

	STDMETHOD(SetBackgroundColorIndex)(
		/*[in]*/ long iBackgroundIndex)
	{
		VSL_DEFINE_MOCK_METHOD(SetBackgroundColorIndex)

		VSL_CHECK_VALIDVALUE(iBackgroundIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsExpansionUIActiveValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(IsExpansionUIActive)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(IsExpansionUIActive)

		VSL_RETURN_VALIDVALUES();
	}
	struct IsReadOnlyValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(IsReadOnly)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(IsReadOnly)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTEXTVIEWEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsThreadSafeCommandWindow.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTHREADSAFECOMMANDWINDOW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTHREADSAFECOMMANDWINDOW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsThreadSafeCommandWindowNotImpl :
	public IVsThreadSafeCommandWindow
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsThreadSafeCommandWindowNotImpl)

public:

	typedef IVsThreadSafeCommandWindow Interface;

	STDMETHOD(ThreadSafePrintNoShow)(
		/*[in,ref]*/ LPCOLESTR /*szTextToPrint*/)VSL_STDMETHOD_NOTIMPL
};

class IVsThreadSafeCommandWindowMockImpl :
	public IVsThreadSafeCommandWindow,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsThreadSafeCommandWindowMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsThreadSafeCommandWindowMockImpl)

	typedef IVsThreadSafeCommandWindow Interface;
	struct ThreadSafePrintNoShowValidValues
	{
		/*[in,ref]*/ LPCOLESTR szTextToPrint;
		HRESULT retValue;
	};

	STDMETHOD(ThreadSafePrintNoShow)(
		/*[in,ref]*/ LPCOLESTR szTextToPrint)
	{
		VSL_DEFINE_MOCK_METHOD(ThreadSafePrintNoShow)

		VSL_CHECK_VALIDVALUE_STRINGW(szTextToPrint);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTHREADSAFECOMMANDWINDOW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsThreadSafeTextView.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTHREADSAFETEXTVIEW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTHREADSAFETEXTVIEW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsThreadSafeTextViewNotImpl :
	public IVsThreadSafeTextView
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsThreadSafeTextViewNotImpl)

public:

	typedef IVsThreadSafeTextView Interface;

	STDMETHOD(ThreadSafeSetCaretPos)(
		/*[in]*/ long /*iLine*/,
		/*[in]*/ ViewCol /*iColumn*/)VSL_STDMETHOD_NOTIMPL
};

class IVsThreadSafeTextViewMockImpl :
	public IVsThreadSafeTextView,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsThreadSafeTextViewMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsThreadSafeTextViewMockImpl)

	typedef IVsThreadSafeTextView Interface;
	struct ThreadSafeSetCaretPosValidValues
	{
		/*[in]*/ long iLine;
		/*[in]*/ ViewCol iColumn;
		HRESULT retValue;
	};

	STDMETHOD(ThreadSafeSetCaretPos)(
		/*[in]*/ long iLine,
		/*[in]*/ ViewCol iColumn)
	{
		VSL_DEFINE_MOCK_METHOD(ThreadSafeSetCaretPos)

		VSL_CHECK_VALIDVALUE(iLine);

		VSL_CHECK_VALIDVALUE(iColumn);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTHREADSAFETEXTVIEW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsToolbox.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTOOLBOX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTOOLBOX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsToolboxNotImpl :
	public IVsToolbox
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsToolboxNotImpl)

public:

	typedef IVsToolbox Interface;

	STDMETHOD(SetCursor)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetData)(
		/*[out,retval]*/ IDataObject** /*ppDO*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DataUsed)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetFrame)(
		/*[out,retval]*/ IVsWindowFrame** /*ppWindowFrame*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddItem)(
		/*[in]*/ IDataObject* /*pDO*/,
		/*[in]*/ PTBXITEMINFO /*ptif*/,
		/*[in]*/ LPCOLESTR /*lpszTab*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveItem)(
		/*[in]*/ IDataObject* /*pDO*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RegisterDataProvider)(
		/*[in]*/ IVsToolboxDataProvider* /*pDP*/,
		/*[out,retval]*/ VSCOOKIE* /*pdwProvider*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnregisterDataProvider)(
		/*[in]*/ VSCOOKIE /*dwProvider*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTab)(
		/*[out,retval]*/ BSTR* /*pbstrTab*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddTab)(
		/*[in]*/ LPCOLESTR /*lpszTab*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveTab)(
		/*[in]*/ LPCOLESTR /*lpszTab*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SelectTab)(
		/*[in]*/ LPCOLESTR /*lpszTab*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumTabs)(
		/*[out,retval]*/ IEnumToolboxTabs** /*pEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SelectItem)(
		/*[in]*/ IDataObject* /*pDO*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumItems)(
		/*[in]*/ LPCOLESTR /*lpszTab*/,
		/*[out]*/ IEnumToolboxItems** /*pEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetItemInfo)(
		/*[in]*/ IDataObject* /*pDO*/,
		/*[in]*/ PTBXITEMINFO /*ptif*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddActiveXItem)(
		/*[in]*/ REFCLSID /*clsid*/,
		/*[in]*/ LPCOLESTR /*lpszTab*/,
		/*[in]*/ IVsHierarchy* /*pHierarchy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UpdateToolboxUI)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddItemFromFile)(
		/*[in]*/ LPCOLESTR /*pszFilename*/,
		/*[in]*/ IVsHierarchy* /*pHierSource*/,
		/*[out,retval]*/ BOOL* /*pfItemAdded*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsCurrentUser)(
		/*[in]*/ IVsToolboxUser* /*pUser*/,
		/*[out,retval]*/ BOOL* /*pfCurrent*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddTabEx)(
		/*[in]*/ LPCOLESTR /*lpszTab*/,
		/*[in]*/ VSTBXTABVIEW /*tv*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetTabView)(
		/*[in]*/ LPCOLESTR /*lpszTab*/,
		/*[in]*/ VSTBXTABVIEW /*tv*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTabView)(
		/*[in]*/ LPCOLESTR /*lpszTab*/,
		/*[out,retval]*/ VSTBXTABVIEW* /*ptv*/)VSL_STDMETHOD_NOTIMPL
};

class IVsToolboxMockImpl :
	public IVsToolbox,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsToolboxMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsToolboxMockImpl)

	typedef IVsToolbox Interface;
	struct SetCursorValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(SetCursor)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(SetCursor)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDataValidValues
	{
		/*[out,retval]*/ IDataObject** ppDO;
		HRESULT retValue;
	};

	STDMETHOD(GetData)(
		/*[out,retval]*/ IDataObject** ppDO)
	{
		VSL_DEFINE_MOCK_METHOD(GetData)

		VSL_SET_VALIDVALUE_INTERFACE(ppDO);

		VSL_RETURN_VALIDVALUES();
	}
	struct DataUsedValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(DataUsed)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(DataUsed)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetFrameValidValues
	{
		/*[out,retval]*/ IVsWindowFrame** ppWindowFrame;
		HRESULT retValue;
	};

	STDMETHOD(GetFrame)(
		/*[out,retval]*/ IVsWindowFrame** ppWindowFrame)
	{
		VSL_DEFINE_MOCK_METHOD(GetFrame)

		VSL_SET_VALIDVALUE_INTERFACE(ppWindowFrame);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddItemValidValues
	{
		/*[in]*/ IDataObject* pDO;
		/*[in]*/ PTBXITEMINFO ptif;
		/*[in]*/ LPCOLESTR lpszTab;
		HRESULT retValue;
	};

	STDMETHOD(AddItem)(
		/*[in]*/ IDataObject* pDO,
		/*[in]*/ PTBXITEMINFO ptif,
		/*[in]*/ LPCOLESTR lpszTab)
	{
		VSL_DEFINE_MOCK_METHOD(AddItem)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDO);

		VSL_CHECK_VALIDVALUE(ptif);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszTab);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveItemValidValues
	{
		/*[in]*/ IDataObject* pDO;
		HRESULT retValue;
	};

	STDMETHOD(RemoveItem)(
		/*[in]*/ IDataObject* pDO)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveItem)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDO);

		VSL_RETURN_VALIDVALUES();
	}
	struct RegisterDataProviderValidValues
	{
		/*[in]*/ IVsToolboxDataProvider* pDP;
		/*[out,retval]*/ VSCOOKIE* pdwProvider;
		HRESULT retValue;
	};

	STDMETHOD(RegisterDataProvider)(
		/*[in]*/ IVsToolboxDataProvider* pDP,
		/*[out,retval]*/ VSCOOKIE* pdwProvider)
	{
		VSL_DEFINE_MOCK_METHOD(RegisterDataProvider)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDP);

		VSL_SET_VALIDVALUE(pdwProvider);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnregisterDataProviderValidValues
	{
		/*[in]*/ VSCOOKIE dwProvider;
		HRESULT retValue;
	};

	STDMETHOD(UnregisterDataProvider)(
		/*[in]*/ VSCOOKIE dwProvider)
	{
		VSL_DEFINE_MOCK_METHOD(UnregisterDataProvider)

		VSL_CHECK_VALIDVALUE(dwProvider);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTabValidValues
	{
		/*[out,retval]*/ BSTR* pbstrTab;
		HRESULT retValue;
	};

	STDMETHOD(GetTab)(
		/*[out,retval]*/ BSTR* pbstrTab)
	{
		VSL_DEFINE_MOCK_METHOD(GetTab)

		VSL_SET_VALIDVALUE_BSTR(pbstrTab);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddTabValidValues
	{
		/*[in]*/ LPCOLESTR lpszTab;
		HRESULT retValue;
	};

	STDMETHOD(AddTab)(
		/*[in]*/ LPCOLESTR lpszTab)
	{
		VSL_DEFINE_MOCK_METHOD(AddTab)

		VSL_CHECK_VALIDVALUE_STRINGW(lpszTab);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveTabValidValues
	{
		/*[in]*/ LPCOLESTR lpszTab;
		HRESULT retValue;
	};

	STDMETHOD(RemoveTab)(
		/*[in]*/ LPCOLESTR lpszTab)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveTab)

		VSL_CHECK_VALIDVALUE_STRINGW(lpszTab);

		VSL_RETURN_VALIDVALUES();
	}
	struct SelectTabValidValues
	{
		/*[in]*/ LPCOLESTR lpszTab;
		HRESULT retValue;
	};

	STDMETHOD(SelectTab)(
		/*[in]*/ LPCOLESTR lpszTab)
	{
		VSL_DEFINE_MOCK_METHOD(SelectTab)

		VSL_CHECK_VALIDVALUE_STRINGW(lpszTab);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumTabsValidValues
	{
		/*[out,retval]*/ IEnumToolboxTabs** pEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumTabs)(
		/*[out,retval]*/ IEnumToolboxTabs** pEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumTabs)

		VSL_SET_VALIDVALUE_INTERFACE(pEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct SelectItemValidValues
	{
		/*[in]*/ IDataObject* pDO;
		HRESULT retValue;
	};

	STDMETHOD(SelectItem)(
		/*[in]*/ IDataObject* pDO)
	{
		VSL_DEFINE_MOCK_METHOD(SelectItem)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDO);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumItemsValidValues
	{
		/*[in]*/ LPCOLESTR lpszTab;
		/*[out]*/ IEnumToolboxItems** pEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumItems)(
		/*[in]*/ LPCOLESTR lpszTab,
		/*[out]*/ IEnumToolboxItems** pEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumItems)

		VSL_CHECK_VALIDVALUE_STRINGW(lpszTab);

		VSL_SET_VALIDVALUE_INTERFACE(pEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetItemInfoValidValues
	{
		/*[in]*/ IDataObject* pDO;
		/*[in]*/ PTBXITEMINFO ptif;
		HRESULT retValue;
	};

	STDMETHOD(SetItemInfo)(
		/*[in]*/ IDataObject* pDO,
		/*[in]*/ PTBXITEMINFO ptif)
	{
		VSL_DEFINE_MOCK_METHOD(SetItemInfo)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDO);

		VSL_CHECK_VALIDVALUE(ptif);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddActiveXItemValidValues
	{
		/*[in]*/ REFCLSID clsid;
		/*[in]*/ LPCOLESTR lpszTab;
		/*[in]*/ IVsHierarchy* pHierarchy;
		HRESULT retValue;
	};

	STDMETHOD(AddActiveXItem)(
		/*[in]*/ REFCLSID clsid,
		/*[in]*/ LPCOLESTR lpszTab,
		/*[in]*/ IVsHierarchy* pHierarchy)
	{
		VSL_DEFINE_MOCK_METHOD(AddActiveXItem)

		VSL_CHECK_VALIDVALUE(clsid);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszTab);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateToolboxUIValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(UpdateToolboxUI)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(UpdateToolboxUI)

		VSL_RETURN_VALIDVALUES();
	}
	struct AddItemFromFileValidValues
	{
		/*[in]*/ LPCOLESTR pszFilename;
		/*[in]*/ IVsHierarchy* pHierSource;
		/*[out,retval]*/ BOOL* pfItemAdded;
		HRESULT retValue;
	};

	STDMETHOD(AddItemFromFile)(
		/*[in]*/ LPCOLESTR pszFilename,
		/*[in]*/ IVsHierarchy* pHierSource,
		/*[out,retval]*/ BOOL* pfItemAdded)
	{
		VSL_DEFINE_MOCK_METHOD(AddItemFromFile)

		VSL_CHECK_VALIDVALUE_STRINGW(pszFilename);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierSource);

		VSL_SET_VALIDVALUE(pfItemAdded);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsCurrentUserValidValues
	{
		/*[in]*/ IVsToolboxUser* pUser;
		/*[out,retval]*/ BOOL* pfCurrent;
		HRESULT retValue;
	};

	STDMETHOD(IsCurrentUser)(
		/*[in]*/ IVsToolboxUser* pUser,
		/*[out,retval]*/ BOOL* pfCurrent)
	{
		VSL_DEFINE_MOCK_METHOD(IsCurrentUser)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUser);

		VSL_SET_VALIDVALUE(pfCurrent);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddTabExValidValues
	{
		/*[in]*/ LPCOLESTR lpszTab;
		/*[in]*/ VSTBXTABVIEW tv;
		HRESULT retValue;
	};

	STDMETHOD(AddTabEx)(
		/*[in]*/ LPCOLESTR lpszTab,
		/*[in]*/ VSTBXTABVIEW tv)
	{
		VSL_DEFINE_MOCK_METHOD(AddTabEx)

		VSL_CHECK_VALIDVALUE_STRINGW(lpszTab);

		VSL_CHECK_VALIDVALUE(tv);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetTabViewValidValues
	{
		/*[in]*/ LPCOLESTR lpszTab;
		/*[in]*/ VSTBXTABVIEW tv;
		HRESULT retValue;
	};

	STDMETHOD(SetTabView)(
		/*[in]*/ LPCOLESTR lpszTab,
		/*[in]*/ VSTBXTABVIEW tv)
	{
		VSL_DEFINE_MOCK_METHOD(SetTabView)

		VSL_CHECK_VALIDVALUE_STRINGW(lpszTab);

		VSL_CHECK_VALIDVALUE(tv);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTabViewValidValues
	{
		/*[in]*/ LPCOLESTR lpszTab;
		/*[out,retval]*/ VSTBXTABVIEW* ptv;
		HRESULT retValue;
	};

	STDMETHOD(GetTabView)(
		/*[in]*/ LPCOLESTR lpszTab,
		/*[out,retval]*/ VSTBXTABVIEW* ptv)
	{
		VSL_DEFINE_MOCK_METHOD(GetTabView)

		VSL_CHECK_VALIDVALUE_STRINGW(lpszTab);

		VSL_SET_VALIDVALUE(ptv);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTOOLBOX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsToolboxActiveUserHook.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTOOLBOXACTIVEUSERHOOK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTOOLBOXACTIVEUSERHOOK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsToolboxActiveUserHookNotImpl :
	public IVsToolboxActiveUserHook
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsToolboxActiveUserHookNotImpl)

public:

	typedef IVsToolboxActiveUserHook Interface;

	STDMETHOD(InterceptDataObject)(
		/*[in]*/ IDataObject* /*pIn*/,
		/*[out]*/ IDataObject** /*ppOut*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ToolboxSelectionChanged)(
		/*[in]*/ IDataObject* /*pSelected*/)VSL_STDMETHOD_NOTIMPL
};

class IVsToolboxActiveUserHookMockImpl :
	public IVsToolboxActiveUserHook,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsToolboxActiveUserHookMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsToolboxActiveUserHookMockImpl)

	typedef IVsToolboxActiveUserHook Interface;
	struct InterceptDataObjectValidValues
	{
		/*[in]*/ IDataObject* pIn;
		/*[out]*/ IDataObject** ppOut;
		HRESULT retValue;
	};

	STDMETHOD(InterceptDataObject)(
		/*[in]*/ IDataObject* pIn,
		/*[out]*/ IDataObject** ppOut)
	{
		VSL_DEFINE_MOCK_METHOD(InterceptDataObject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIn);

		VSL_SET_VALIDVALUE_INTERFACE(ppOut);

		VSL_RETURN_VALIDVALUES();
	}
	struct ToolboxSelectionChangedValidValues
	{
		/*[in]*/ IDataObject* pSelected;
		HRESULT retValue;
	};

	STDMETHOD(ToolboxSelectionChanged)(
		/*[in]*/ IDataObject* pSelected)
	{
		VSL_DEFINE_MOCK_METHOD(ToolboxSelectionChanged)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSelected);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTOOLBOXACTIVEUSERHOOK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsToolboxClipboardCycler.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTOOLBOXCLIPBOARDCYCLER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTOOLBOXCLIPBOARDCYCLER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsToolboxClipboardCyclerNotImpl :
	public IVsToolboxClipboardCycler
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsToolboxClipboardCyclerNotImpl)

public:

	typedef IVsToolboxClipboardCycler Interface;

	STDMETHOD(AreDataObjectsAvailable)(
		/*[in]*/ IVsToolboxUser* /*pTarget*/,
		/*[out]*/ BOOL* /*pbItemsAvailable*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetAndSelectNextDataObject)(
		/*[in]*/ IVsToolboxUser* /*pTarget*/,
		/*[out]*/ IDataObject** /*ppDO*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(BeginCycle)()VSL_STDMETHOD_NOTIMPL
};

class IVsToolboxClipboardCyclerMockImpl :
	public IVsToolboxClipboardCycler,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsToolboxClipboardCyclerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsToolboxClipboardCyclerMockImpl)

	typedef IVsToolboxClipboardCycler Interface;
	struct AreDataObjectsAvailableValidValues
	{
		/*[in]*/ IVsToolboxUser* pTarget;
		/*[out]*/ BOOL* pbItemsAvailable;
		HRESULT retValue;
	};

	STDMETHOD(AreDataObjectsAvailable)(
		/*[in]*/ IVsToolboxUser* pTarget,
		/*[out]*/ BOOL* pbItemsAvailable)
	{
		VSL_DEFINE_MOCK_METHOD(AreDataObjectsAvailable)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pTarget);

		VSL_SET_VALIDVALUE(pbItemsAvailable);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetAndSelectNextDataObjectValidValues
	{
		/*[in]*/ IVsToolboxUser* pTarget;
		/*[out]*/ IDataObject** ppDO;
		HRESULT retValue;
	};

	STDMETHOD(GetAndSelectNextDataObject)(
		/*[in]*/ IVsToolboxUser* pTarget,
		/*[out]*/ IDataObject** ppDO)
	{
		VSL_DEFINE_MOCK_METHOD(GetAndSelectNextDataObject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pTarget);

		VSL_SET_VALIDVALUE_INTERFACE(ppDO);

		VSL_RETURN_VALIDVALUES();
	}
	struct BeginCycleValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(BeginCycle)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(BeginCycle)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTOOLBOXCLIPBOARDCYCLER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTipWindow.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTIPWINDOW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTIPWINDOW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTipWindowNotImpl :
	public IVsTipWindow
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTipWindowNotImpl)

public:

	typedef IVsTipWindow Interface;

	STDMETHOD(GetContextStream)(
		/*[out]*/ long* /*piPos*/,
		/*[out]*/ long* /*piLength*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSizePreferences)(
		/*[out]*/ const RECT* /*prcCtxBounds*/,
		/*[out]*/ TIPSIZEDATA* /*pSizeData*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Paint)(
		/*[in]*/ HDC /*hdc*/,
		/*[in]*/ const RECT* /*prc*/)VSL_STDMETHOD_NOTIMPL

	virtual void STDMETHODCALLTYPE Dismiss(){ return ; }

	virtual LRESULT STDMETHODCALLTYPE WndProc(
		/*[in]*/ HWND /*hwnd*/,
		/*[in]*/ UINT /*iMsg*/,
		/*[in]*/ WPARAM /*wParam*/,
		/*[in]*/ LPARAM /*lParam*/){ return LRESULT(); }
};

class IVsTipWindowMockImpl :
	public IVsTipWindow,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTipWindowMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTipWindowMockImpl)

	typedef IVsTipWindow Interface;
	struct GetContextStreamValidValues
	{
		/*[out]*/ long* piPos;
		/*[out]*/ long* piLength;
		HRESULT retValue;
	};

	STDMETHOD(GetContextStream)(
		/*[out]*/ long* piPos,
		/*[out]*/ long* piLength)
	{
		VSL_DEFINE_MOCK_METHOD(GetContextStream)

		VSL_SET_VALIDVALUE(piPos);

		VSL_SET_VALIDVALUE(piLength);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSizePreferencesValidValues
	{
		/*[out]*/ RECT* prcCtxBounds;
		/*[out]*/ TIPSIZEDATA* pSizeData;
		HRESULT retValue;
	};

	STDMETHOD(GetSizePreferences)(
		/*[out]*/ const RECT* prcCtxBounds,
		/*[out]*/ TIPSIZEDATA* pSizeData)
	{
		VSL_DEFINE_MOCK_METHOD(GetSizePreferences)

		VSL_SET_VALIDVALUE_CONST(prcCtxBounds, RECT*);

		VSL_SET_VALIDVALUE(pSizeData);

		VSL_RETURN_VALIDVALUES();
	}
	struct PaintValidValues
	{
		/*[in]*/ HDC hdc;
		/*[in]*/ RECT* prc;
		HRESULT retValue;
	};

	STDMETHOD(Paint)(
		/*[in]*/ HDC hdc,
		/*[in]*/ const RECT* prc)
	{
		VSL_DEFINE_MOCK_METHOD(Paint)

		VSL_CHECK_VALIDVALUE(hdc);

		VSL_CHECK_VALIDVALUE_POINTER(prc);

		VSL_RETURN_VALIDVALUES();
	}

	virtual void _stdcall Dismiss()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS_NORETURN(Dismiss)

	}
	struct WndProcValidValues
	{
		/*[in]*/ HWND hwnd;
		/*[in]*/ UINT iMsg;
		/*[in]*/ WPARAM wParam;
		/*[in]*/ LPARAM lParam;
		LRESULT retValue;
	};

	virtual LRESULT _stdcall WndProc(
		/*[in]*/ HWND hwnd,
		/*[in]*/ UINT iMsg,
		/*[in]*/ WPARAM wParam,
		/*[in]*/ LPARAM lParam)
	{
		VSL_DEFINE_MOCK_METHOD(WndProc)

		VSL_CHECK_VALIDVALUE(hwnd);

		VSL_CHECK_VALIDVALUE(iMsg);

		VSL_CHECK_VALIDVALUE(wParam);

		VSL_CHECK_VALIDVALUE(lParam);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTIPWINDOW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsToolbox2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTOOLBOX2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTOOLBOX2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsToolbox2NotImpl :
	public IVsToolbox2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsToolbox2NotImpl)

public:

	typedef IVsToolbox2 Interface;

	STDMETHOD(AddItem2)(
		/*[in]*/ IDataObject* /*pDO*/,
		/*[in]*/ PTBXITEMINFO /*ptif*/,
		/*[in]*/ LPCOLESTR /*lpszTab*/,
		/*[in]*/ REFGUID /*guidPkg*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddTab2)(
		/*[in]*/ LPCOLESTR /*lpszTab*/,
		/*[in]*/ REFGUID /*guidPkg*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddActiveXItem2)(
		/*[in]*/ REFCLSID /*clsid*/,
		/*[in]*/ LPCOLESTR /*lpszTab*/,
		/*[in]*/ IVsHierarchy* /*pHierarchy*/,
		/*[in]*/ REFGUID /*guidPkg*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddItemFromFile2)(
		/*[in]*/ LPCOLESTR /*pszFilename*/,
		/*[in]*/ IVsHierarchy* /*pHierSource*/,
		/*[in]*/ REFGUID /*guidPkg*/,
		/*[out,retval]*/ BOOL* /*pfItemAdded*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddTabEx2)(
		/*[in]*/ LPCOLESTR /*lpszTab*/,
		/*[in]*/ VSTBXTABVIEW /*tv*/,
		/*[in]*/ REFGUID /*guidPkg*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetCursor)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetData)(
		/*[out,retval]*/ IDataObject** /*ppDO*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DataUsed)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetFrame)(
		/*[out,retval]*/ IVsWindowFrame** /*ppWindowFrame*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddItem)(
		/*[in]*/ IDataObject* /*pDO*/,
		/*[in]*/ PTBXITEMINFO /*ptif*/,
		/*[in]*/ LPCOLESTR /*lpszTab*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveItem)(
		/*[in]*/ IDataObject* /*pDO*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RegisterDataProvider)(
		/*[in]*/ IVsToolboxDataProvider* /*pDP*/,
		/*[out,retval]*/ VSCOOKIE* /*pdwProvider*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnregisterDataProvider)(
		/*[in]*/ VSCOOKIE /*dwProvider*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTab)(
		/*[out,retval]*/ BSTR* /*pbstrTab*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddTab)(
		/*[in]*/ LPCOLESTR /*lpszTab*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveTab)(
		/*[in]*/ LPCOLESTR /*lpszTab*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SelectTab)(
		/*[in]*/ LPCOLESTR /*lpszTab*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumTabs)(
		/*[out,retval]*/ IEnumToolboxTabs** /*pEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SelectItem)(
		/*[in]*/ IDataObject* /*pDO*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnumItems)(
		/*[in]*/ LPCOLESTR /*lpszTab*/,
		/*[out]*/ IEnumToolboxItems** /*pEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetItemInfo)(
		/*[in]*/ IDataObject* /*pDO*/,
		/*[in]*/ PTBXITEMINFO /*ptif*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddActiveXItem)(
		/*[in]*/ REFCLSID /*clsid*/,
		/*[in]*/ LPCOLESTR /*lpszTab*/,
		/*[in]*/ IVsHierarchy* /*pHierarchy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UpdateToolboxUI)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddItemFromFile)(
		/*[in]*/ LPCOLESTR /*pszFilename*/,
		/*[in]*/ IVsHierarchy* /*pHierSource*/,
		/*[out,retval]*/ BOOL* /*pfItemAdded*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsCurrentUser)(
		/*[in]*/ IVsToolboxUser* /*pUser*/,
		/*[out,retval]*/ BOOL* /*pfCurrent*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddTabEx)(
		/*[in]*/ LPCOLESTR /*lpszTab*/,
		/*[in]*/ VSTBXTABVIEW /*tv*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetTabView)(
		/*[in]*/ LPCOLESTR /*lpszTab*/,
		/*[in]*/ VSTBXTABVIEW /*tv*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTabView)(
		/*[in]*/ LPCOLESTR /*lpszTab*/,
		/*[out,retval]*/ VSTBXTABVIEW* /*ptv*/)VSL_STDMETHOD_NOTIMPL
};

class IVsToolbox2MockImpl :
	public IVsToolbox2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsToolbox2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsToolbox2MockImpl)

	typedef IVsToolbox2 Interface;
	struct AddItem2ValidValues
	{
		/*[in]*/ IDataObject* pDO;
		/*[in]*/ PTBXITEMINFO ptif;
		/*[in]*/ LPCOLESTR lpszTab;
		/*[in]*/ REFGUID guidPkg;
		HRESULT retValue;
	};

	STDMETHOD(AddItem2)(
		/*[in]*/ IDataObject* pDO,
		/*[in]*/ PTBXITEMINFO ptif,
		/*[in]*/ LPCOLESTR lpszTab,
		/*[in]*/ REFGUID guidPkg)
	{
		VSL_DEFINE_MOCK_METHOD(AddItem2)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDO);

		VSL_CHECK_VALIDVALUE(ptif);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszTab);

		VSL_CHECK_VALIDVALUE(guidPkg);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddTab2ValidValues
	{
		/*[in]*/ LPCOLESTR lpszTab;
		/*[in]*/ REFGUID guidPkg;
		HRESULT retValue;
	};

	STDMETHOD(AddTab2)(
		/*[in]*/ LPCOLESTR lpszTab,
		/*[in]*/ REFGUID guidPkg)
	{
		VSL_DEFINE_MOCK_METHOD(AddTab2)

		VSL_CHECK_VALIDVALUE_STRINGW(lpszTab);

		VSL_CHECK_VALIDVALUE(guidPkg);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddActiveXItem2ValidValues
	{
		/*[in]*/ REFCLSID clsid;
		/*[in]*/ LPCOLESTR lpszTab;
		/*[in]*/ IVsHierarchy* pHierarchy;
		/*[in]*/ REFGUID guidPkg;
		HRESULT retValue;
	};

	STDMETHOD(AddActiveXItem2)(
		/*[in]*/ REFCLSID clsid,
		/*[in]*/ LPCOLESTR lpszTab,
		/*[in]*/ IVsHierarchy* pHierarchy,
		/*[in]*/ REFGUID guidPkg)
	{
		VSL_DEFINE_MOCK_METHOD(AddActiveXItem2)

		VSL_CHECK_VALIDVALUE(clsid);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszTab);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_CHECK_VALIDVALUE(guidPkg);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddItemFromFile2ValidValues
	{
		/*[in]*/ LPCOLESTR pszFilename;
		/*[in]*/ IVsHierarchy* pHierSource;
		/*[in]*/ REFGUID guidPkg;
		/*[out,retval]*/ BOOL* pfItemAdded;
		HRESULT retValue;
	};

	STDMETHOD(AddItemFromFile2)(
		/*[in]*/ LPCOLESTR pszFilename,
		/*[in]*/ IVsHierarchy* pHierSource,
		/*[in]*/ REFGUID guidPkg,
		/*[out,retval]*/ BOOL* pfItemAdded)
	{
		VSL_DEFINE_MOCK_METHOD(AddItemFromFile2)

		VSL_CHECK_VALIDVALUE_STRINGW(pszFilename);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierSource);

		VSL_CHECK_VALIDVALUE(guidPkg);

		VSL_SET_VALIDVALUE(pfItemAdded);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddTabEx2ValidValues
	{
		/*[in]*/ LPCOLESTR lpszTab;
		/*[in]*/ VSTBXTABVIEW tv;
		/*[in]*/ REFGUID guidPkg;
		HRESULT retValue;
	};

	STDMETHOD(AddTabEx2)(
		/*[in]*/ LPCOLESTR lpszTab,
		/*[in]*/ VSTBXTABVIEW tv,
		/*[in]*/ REFGUID guidPkg)
	{
		VSL_DEFINE_MOCK_METHOD(AddTabEx2)

		VSL_CHECK_VALIDVALUE_STRINGW(lpszTab);

		VSL_CHECK_VALIDVALUE(tv);

		VSL_CHECK_VALIDVALUE(guidPkg);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetCursorValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(SetCursor)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(SetCursor)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDataValidValues
	{
		/*[out,retval]*/ IDataObject** ppDO;
		HRESULT retValue;
	};

	STDMETHOD(GetData)(
		/*[out,retval]*/ IDataObject** ppDO)
	{
		VSL_DEFINE_MOCK_METHOD(GetData)

		VSL_SET_VALIDVALUE_INTERFACE(ppDO);

		VSL_RETURN_VALIDVALUES();
	}
	struct DataUsedValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(DataUsed)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(DataUsed)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetFrameValidValues
	{
		/*[out,retval]*/ IVsWindowFrame** ppWindowFrame;
		HRESULT retValue;
	};

	STDMETHOD(GetFrame)(
		/*[out,retval]*/ IVsWindowFrame** ppWindowFrame)
	{
		VSL_DEFINE_MOCK_METHOD(GetFrame)

		VSL_SET_VALIDVALUE_INTERFACE(ppWindowFrame);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddItemValidValues
	{
		/*[in]*/ IDataObject* pDO;
		/*[in]*/ PTBXITEMINFO ptif;
		/*[in]*/ LPCOLESTR lpszTab;
		HRESULT retValue;
	};

	STDMETHOD(AddItem)(
		/*[in]*/ IDataObject* pDO,
		/*[in]*/ PTBXITEMINFO ptif,
		/*[in]*/ LPCOLESTR lpszTab)
	{
		VSL_DEFINE_MOCK_METHOD(AddItem)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDO);

		VSL_CHECK_VALIDVALUE(ptif);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszTab);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveItemValidValues
	{
		/*[in]*/ IDataObject* pDO;
		HRESULT retValue;
	};

	STDMETHOD(RemoveItem)(
		/*[in]*/ IDataObject* pDO)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveItem)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDO);

		VSL_RETURN_VALIDVALUES();
	}
	struct RegisterDataProviderValidValues
	{
		/*[in]*/ IVsToolboxDataProvider* pDP;
		/*[out,retval]*/ VSCOOKIE* pdwProvider;
		HRESULT retValue;
	};

	STDMETHOD(RegisterDataProvider)(
		/*[in]*/ IVsToolboxDataProvider* pDP,
		/*[out,retval]*/ VSCOOKIE* pdwProvider)
	{
		VSL_DEFINE_MOCK_METHOD(RegisterDataProvider)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDP);

		VSL_SET_VALIDVALUE(pdwProvider);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnregisterDataProviderValidValues
	{
		/*[in]*/ VSCOOKIE dwProvider;
		HRESULT retValue;
	};

	STDMETHOD(UnregisterDataProvider)(
		/*[in]*/ VSCOOKIE dwProvider)
	{
		VSL_DEFINE_MOCK_METHOD(UnregisterDataProvider)

		VSL_CHECK_VALIDVALUE(dwProvider);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTabValidValues
	{
		/*[out,retval]*/ BSTR* pbstrTab;
		HRESULT retValue;
	};

	STDMETHOD(GetTab)(
		/*[out,retval]*/ BSTR* pbstrTab)
	{
		VSL_DEFINE_MOCK_METHOD(GetTab)

		VSL_SET_VALIDVALUE_BSTR(pbstrTab);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddTabValidValues
	{
		/*[in]*/ LPCOLESTR lpszTab;
		HRESULT retValue;
	};

	STDMETHOD(AddTab)(
		/*[in]*/ LPCOLESTR lpszTab)
	{
		VSL_DEFINE_MOCK_METHOD(AddTab)

		VSL_CHECK_VALIDVALUE_STRINGW(lpszTab);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveTabValidValues
	{
		/*[in]*/ LPCOLESTR lpszTab;
		HRESULT retValue;
	};

	STDMETHOD(RemoveTab)(
		/*[in]*/ LPCOLESTR lpszTab)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveTab)

		VSL_CHECK_VALIDVALUE_STRINGW(lpszTab);

		VSL_RETURN_VALIDVALUES();
	}
	struct SelectTabValidValues
	{
		/*[in]*/ LPCOLESTR lpszTab;
		HRESULT retValue;
	};

	STDMETHOD(SelectTab)(
		/*[in]*/ LPCOLESTR lpszTab)
	{
		VSL_DEFINE_MOCK_METHOD(SelectTab)

		VSL_CHECK_VALIDVALUE_STRINGW(lpszTab);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumTabsValidValues
	{
		/*[out,retval]*/ IEnumToolboxTabs** pEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumTabs)(
		/*[out,retval]*/ IEnumToolboxTabs** pEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumTabs)

		VSL_SET_VALIDVALUE_INTERFACE(pEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct SelectItemValidValues
	{
		/*[in]*/ IDataObject* pDO;
		HRESULT retValue;
	};

	STDMETHOD(SelectItem)(
		/*[in]*/ IDataObject* pDO)
	{
		VSL_DEFINE_MOCK_METHOD(SelectItem)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDO);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnumItemsValidValues
	{
		/*[in]*/ LPCOLESTR lpszTab;
		/*[out]*/ IEnumToolboxItems** pEnum;
		HRESULT retValue;
	};

	STDMETHOD(EnumItems)(
		/*[in]*/ LPCOLESTR lpszTab,
		/*[out]*/ IEnumToolboxItems** pEnum)
	{
		VSL_DEFINE_MOCK_METHOD(EnumItems)

		VSL_CHECK_VALIDVALUE_STRINGW(lpszTab);

		VSL_SET_VALIDVALUE_INTERFACE(pEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetItemInfoValidValues
	{
		/*[in]*/ IDataObject* pDO;
		/*[in]*/ PTBXITEMINFO ptif;
		HRESULT retValue;
	};

	STDMETHOD(SetItemInfo)(
		/*[in]*/ IDataObject* pDO,
		/*[in]*/ PTBXITEMINFO ptif)
	{
		VSL_DEFINE_MOCK_METHOD(SetItemInfo)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDO);

		VSL_CHECK_VALIDVALUE(ptif);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddActiveXItemValidValues
	{
		/*[in]*/ REFCLSID clsid;
		/*[in]*/ LPCOLESTR lpszTab;
		/*[in]*/ IVsHierarchy* pHierarchy;
		HRESULT retValue;
	};

	STDMETHOD(AddActiveXItem)(
		/*[in]*/ REFCLSID clsid,
		/*[in]*/ LPCOLESTR lpszTab,
		/*[in]*/ IVsHierarchy* pHierarchy)
	{
		VSL_DEFINE_MOCK_METHOD(AddActiveXItem)

		VSL_CHECK_VALIDVALUE(clsid);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszTab);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierarchy);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateToolboxUIValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(UpdateToolboxUI)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(UpdateToolboxUI)

		VSL_RETURN_VALIDVALUES();
	}
	struct AddItemFromFileValidValues
	{
		/*[in]*/ LPCOLESTR pszFilename;
		/*[in]*/ IVsHierarchy* pHierSource;
		/*[out,retval]*/ BOOL* pfItemAdded;
		HRESULT retValue;
	};

	STDMETHOD(AddItemFromFile)(
		/*[in]*/ LPCOLESTR pszFilename,
		/*[in]*/ IVsHierarchy* pHierSource,
		/*[out,retval]*/ BOOL* pfItemAdded)
	{
		VSL_DEFINE_MOCK_METHOD(AddItemFromFile)

		VSL_CHECK_VALIDVALUE_STRINGW(pszFilename);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierSource);

		VSL_SET_VALIDVALUE(pfItemAdded);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsCurrentUserValidValues
	{
		/*[in]*/ IVsToolboxUser* pUser;
		/*[out,retval]*/ BOOL* pfCurrent;
		HRESULT retValue;
	};

	STDMETHOD(IsCurrentUser)(
		/*[in]*/ IVsToolboxUser* pUser,
		/*[out,retval]*/ BOOL* pfCurrent)
	{
		VSL_DEFINE_MOCK_METHOD(IsCurrentUser)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUser);

		VSL_SET_VALIDVALUE(pfCurrent);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddTabExValidValues
	{
		/*[in]*/ LPCOLESTR lpszTab;
		/*[in]*/ VSTBXTABVIEW tv;
		HRESULT retValue;
	};

	STDMETHOD(AddTabEx)(
		/*[in]*/ LPCOLESTR lpszTab,
		/*[in]*/ VSTBXTABVIEW tv)
	{
		VSL_DEFINE_MOCK_METHOD(AddTabEx)

		VSL_CHECK_VALIDVALUE_STRINGW(lpszTab);

		VSL_CHECK_VALIDVALUE(tv);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetTabViewValidValues
	{
		/*[in]*/ LPCOLESTR lpszTab;
		/*[in]*/ VSTBXTABVIEW tv;
		HRESULT retValue;
	};

	STDMETHOD(SetTabView)(
		/*[in]*/ LPCOLESTR lpszTab,
		/*[in]*/ VSTBXTABVIEW tv)
	{
		VSL_DEFINE_MOCK_METHOD(SetTabView)

		VSL_CHECK_VALIDVALUE_STRINGW(lpszTab);

		VSL_CHECK_VALIDVALUE(tv);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTabViewValidValues
	{
		/*[in]*/ LPCOLESTR lpszTab;
		/*[out,retval]*/ VSTBXTABVIEW* ptv;
		HRESULT retValue;
	};

	STDMETHOD(GetTabView)(
		/*[in]*/ LPCOLESTR lpszTab,
		/*[out,retval]*/ VSTBXTABVIEW* ptv)
	{
		VSL_DEFINE_MOCK_METHOD(GetTabView)

		VSL_CHECK_VALIDVALUE_STRINGW(lpszTab);

		VSL_SET_VALIDVALUE(ptv);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTOOLBOX2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsToolbox3.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTOOLBOX3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTOOLBOX3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsToolbox3NotImpl :
	public IVsToolbox3
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsToolbox3NotImpl)

public:

	typedef IVsToolbox3 Interface;

	STDMETHOD(SetIDOfTab)(
		/*[in]*/ LPCOLESTR /*lpszTabName*/,
		/*[in]*/ LPCOLESTR /*lpszTabID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDOfTab)(
		/*[in]*/ LPCOLESTR /*lpszTabName*/,
		/*[out]*/ BSTR* /*pbstrTabID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTabOfID)(
		/*[in]*/ LPCOLESTR /*lpszTabID*/,
		/*[out]*/ BSTR* /*pbstrTabName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetGeneralTabID)(
		/*[out]*/ BSTR* /*pbstrTabID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetItemID)(
		/*[in]*/ IDataObject* /*pDO*/,
		/*[out]*/ BSTR* /*pbstrID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetItemDisplayName)(
		/*[in]*/ IDataObject* /*pDO*/,
		/*[out]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetLastModifiedTime)(
		/*[out]*/ SYSTEMTIME* /*pst*/)VSL_STDMETHOD_NOTIMPL
};

class IVsToolbox3MockImpl :
	public IVsToolbox3,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsToolbox3MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsToolbox3MockImpl)

	typedef IVsToolbox3 Interface;
	struct SetIDOfTabValidValues
	{
		/*[in]*/ LPCOLESTR lpszTabName;
		/*[in]*/ LPCOLESTR lpszTabID;
		HRESULT retValue;
	};

	STDMETHOD(SetIDOfTab)(
		/*[in]*/ LPCOLESTR lpszTabName,
		/*[in]*/ LPCOLESTR lpszTabID)
	{
		VSL_DEFINE_MOCK_METHOD(SetIDOfTab)

		VSL_CHECK_VALIDVALUE_STRINGW(lpszTabName);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszTabID);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDOfTabValidValues
	{
		/*[in]*/ LPCOLESTR lpszTabName;
		/*[out]*/ BSTR* pbstrTabID;
		HRESULT retValue;
	};

	STDMETHOD(GetIDOfTab)(
		/*[in]*/ LPCOLESTR lpszTabName,
		/*[out]*/ BSTR* pbstrTabID)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDOfTab)

		VSL_CHECK_VALIDVALUE_STRINGW(lpszTabName);

		VSL_SET_VALIDVALUE_BSTR(pbstrTabID);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTabOfIDValidValues
	{
		/*[in]*/ LPCOLESTR lpszTabID;
		/*[out]*/ BSTR* pbstrTabName;
		HRESULT retValue;
	};

	STDMETHOD(GetTabOfID)(
		/*[in]*/ LPCOLESTR lpszTabID,
		/*[out]*/ BSTR* pbstrTabName)
	{
		VSL_DEFINE_MOCK_METHOD(GetTabOfID)

		VSL_CHECK_VALIDVALUE_STRINGW(lpszTabID);

		VSL_SET_VALIDVALUE_BSTR(pbstrTabName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetGeneralTabIDValidValues
	{
		/*[out]*/ BSTR* pbstrTabID;
		HRESULT retValue;
	};

	STDMETHOD(GetGeneralTabID)(
		/*[out]*/ BSTR* pbstrTabID)
	{
		VSL_DEFINE_MOCK_METHOD(GetGeneralTabID)

		VSL_SET_VALIDVALUE_BSTR(pbstrTabID);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetItemIDValidValues
	{
		/*[in]*/ IDataObject* pDO;
		/*[out]*/ BSTR* pbstrID;
		HRESULT retValue;
	};

	STDMETHOD(GetItemID)(
		/*[in]*/ IDataObject* pDO,
		/*[out]*/ BSTR* pbstrID)
	{
		VSL_DEFINE_MOCK_METHOD(GetItemID)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDO);

		VSL_SET_VALIDVALUE_BSTR(pbstrID);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetItemDisplayNameValidValues
	{
		/*[in]*/ IDataObject* pDO;
		/*[out]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(GetItemDisplayName)(
		/*[in]*/ IDataObject* pDO,
		/*[out]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(GetItemDisplayName)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDO);

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetLastModifiedTimeValidValues
	{
		/*[out]*/ SYSTEMTIME* pst;
		HRESULT retValue;
	};

	STDMETHOD(GetLastModifiedTime)(
		/*[out]*/ SYSTEMTIME* pst)
	{
		VSL_DEFINE_MOCK_METHOD(GetLastModifiedTime)

		VSL_SET_VALIDVALUE(pst);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTOOLBOX3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsToolboxDataProvider.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTOOLBOXDATAPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTOOLBOXDATAPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsToolboxDataProviderNotImpl :
	public IVsToolboxDataProvider
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsToolboxDataProviderNotImpl)

public:

	typedef IVsToolboxDataProvider Interface;

	STDMETHOD(FileDropped)(
		/*[in]*/ LPCOLESTR /*pszFileName*/,
		/*[in]*/ IVsHierarchy* /*pHierSource*/,
		/*[out,retval]*/ BOOL* /*pfFileProcessed*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsSupported)(
		/*[in]*/ IDataObject* /*pDO*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsDataSupported)(
		/*[in]*/ FORMATETC* /*pfetc*/,
		/*[in]*/ STGMEDIUM* /*pstm*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetItemInfo)(
		/*[in]*/ IDataObject* /*pDO*/,
		/*[out]*/ PTBXITEMINFO /*ptif*/)VSL_STDMETHOD_NOTIMPL
};

class IVsToolboxDataProviderMockImpl :
	public IVsToolboxDataProvider,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsToolboxDataProviderMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsToolboxDataProviderMockImpl)

	typedef IVsToolboxDataProvider Interface;
	struct FileDroppedValidValues
	{
		/*[in]*/ LPCOLESTR pszFileName;
		/*[in]*/ IVsHierarchy* pHierSource;
		/*[out,retval]*/ BOOL* pfFileProcessed;
		HRESULT retValue;
	};

	STDMETHOD(FileDropped)(
		/*[in]*/ LPCOLESTR pszFileName,
		/*[in]*/ IVsHierarchy* pHierSource,
		/*[out,retval]*/ BOOL* pfFileProcessed)
	{
		VSL_DEFINE_MOCK_METHOD(FileDropped)

		VSL_CHECK_VALIDVALUE_STRINGW(pszFileName);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierSource);

		VSL_SET_VALIDVALUE(pfFileProcessed);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsSupportedValidValues
	{
		/*[in]*/ IDataObject* pDO;
		HRESULT retValue;
	};

	STDMETHOD(IsSupported)(
		/*[in]*/ IDataObject* pDO)
	{
		VSL_DEFINE_MOCK_METHOD(IsSupported)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDO);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsDataSupportedValidValues
	{
		/*[in]*/ FORMATETC* pfetc;
		/*[in]*/ STGMEDIUM* pstm;
		HRESULT retValue;
	};

	STDMETHOD(IsDataSupported)(
		/*[in]*/ FORMATETC* pfetc,
		/*[in]*/ STGMEDIUM* pstm)
	{
		VSL_DEFINE_MOCK_METHOD(IsDataSupported)

		VSL_CHECK_VALIDVALUE_POINTER(pfetc);

		VSL_CHECK_VALIDVALUE_POINTER(pstm);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetItemInfoValidValues
	{
		/*[in]*/ IDataObject* pDO;
		/*[out]*/ PTBXITEMINFO ptif;
		HRESULT retValue;
	};

	STDMETHOD(GetItemInfo)(
		/*[in]*/ IDataObject* pDO,
		/*[out]*/ PTBXITEMINFO ptif)
	{
		VSL_DEFINE_MOCK_METHOD(GetItemInfo)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDO);

		VSL_SET_VALIDVALUE(ptif);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTOOLBOXDATAPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsToolboxUser.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTOOLBOXUSER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTOOLBOXUSER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsToolboxUserNotImpl :
	public IVsToolboxUser
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsToolboxUserNotImpl)

public:

	typedef IVsToolboxUser Interface;

	STDMETHOD(IsSupported)(
		/*[in]*/ IDataObject* /*pDO*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ItemPicked)(
		/*[in]*/ IDataObject* /*pDO*/)VSL_STDMETHOD_NOTIMPL
};

class IVsToolboxUserMockImpl :
	public IVsToolboxUser,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsToolboxUserMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsToolboxUserMockImpl)

	typedef IVsToolboxUser Interface;
	struct IsSupportedValidValues
	{
		/*[in]*/ IDataObject* pDO;
		HRESULT retValue;
	};

	STDMETHOD(IsSupported)(
		/*[in]*/ IDataObject* pDO)
	{
		VSL_DEFINE_MOCK_METHOD(IsSupported)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDO);

		VSL_RETURN_VALIDVALUES();
	}
	struct ItemPickedValidValues
	{
		/*[in]*/ IDataObject* pDO;
		HRESULT retValue;
	};

	STDMETHOD(ItemPicked)(
		/*[in]*/ IDataObject* pDO)
	{
		VSL_DEFINE_MOCK_METHOD(ItemPicked)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDO);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTOOLBOXUSER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsToolboxDataProvider2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTOOLBOXDATAPROVIDER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTOOLBOXDATAPROVIDER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsToolboxDataProvider2NotImpl :
	public IVsToolboxDataProvider2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsToolboxDataProvider2NotImpl)

public:

	typedef IVsToolboxDataProvider2 Interface;

	STDMETHOD(GetPackageGUID)(
		/*[out]*/ GUID* /*pguidPkg*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetUniqueID)(
		/*[out]*/ GUID* /*pguidID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDisplayName)(
		/*[out]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetItemTipInfo)(
		/*[in]*/ IDataObject* /*pDO*/,
		/*[in]*/ LPCOLESTR /*lpszCurrentName*/,
		/*[in]*/ IPropertyBag* /*pStrings*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProfileData)(
		/*[in]*/ IDataObject* /*pDO*/,
		/*[out]*/ BSTR* /*pbstrData*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetItemID)(
		/*[in]*/ IDataObject* /*pDO*/,
		/*[out]*/ BSTR* /*pbstrID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReconstituteItem)(
		/*[in]*/ LPCOLESTR /*lpszCurrentName*/,
		/*[in]*/ LPCOLESTR /*lpszID*/,
		/*[in]*/ LPCOLESTR /*lpszData*/,
		/*[out]*/ IDataObject** /*ppDO*/,
		/*[out]*/ TBXITEMINFO* /*ptif*/)VSL_STDMETHOD_NOTIMPL
};

class IVsToolboxDataProvider2MockImpl :
	public IVsToolboxDataProvider2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsToolboxDataProvider2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsToolboxDataProvider2MockImpl)

	typedef IVsToolboxDataProvider2 Interface;
	struct GetPackageGUIDValidValues
	{
		/*[out]*/ GUID* pguidPkg;
		HRESULT retValue;
	};

	STDMETHOD(GetPackageGUID)(
		/*[out]*/ GUID* pguidPkg)
	{
		VSL_DEFINE_MOCK_METHOD(GetPackageGUID)

		VSL_SET_VALIDVALUE(pguidPkg);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetUniqueIDValidValues
	{
		/*[out]*/ GUID* pguidID;
		HRESULT retValue;
	};

	STDMETHOD(GetUniqueID)(
		/*[out]*/ GUID* pguidID)
	{
		VSL_DEFINE_MOCK_METHOD(GetUniqueID)

		VSL_SET_VALIDVALUE(pguidID);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDisplayNameValidValues
	{
		/*[out]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(GetDisplayName)(
		/*[out]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(GetDisplayName)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetItemTipInfoValidValues
	{
		/*[in]*/ IDataObject* pDO;
		/*[in]*/ LPCOLESTR lpszCurrentName;
		/*[in]*/ IPropertyBag* pStrings;
		HRESULT retValue;
	};

	STDMETHOD(GetItemTipInfo)(
		/*[in]*/ IDataObject* pDO,
		/*[in]*/ LPCOLESTR lpszCurrentName,
		/*[in]*/ IPropertyBag* pStrings)
	{
		VSL_DEFINE_MOCK_METHOD(GetItemTipInfo)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDO);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszCurrentName);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pStrings);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetProfileDataValidValues
	{
		/*[in]*/ IDataObject* pDO;
		/*[out]*/ BSTR* pbstrData;
		HRESULT retValue;
	};

	STDMETHOD(GetProfileData)(
		/*[in]*/ IDataObject* pDO,
		/*[out]*/ BSTR* pbstrData)
	{
		VSL_DEFINE_MOCK_METHOD(GetProfileData)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDO);

		VSL_SET_VALIDVALUE_BSTR(pbstrData);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetItemIDValidValues
	{
		/*[in]*/ IDataObject* pDO;
		/*[out]*/ BSTR* pbstrID;
		HRESULT retValue;
	};

	STDMETHOD(GetItemID)(
		/*[in]*/ IDataObject* pDO,
		/*[out]*/ BSTR* pbstrID)
	{
		VSL_DEFINE_MOCK_METHOD(GetItemID)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDO);

		VSL_SET_VALIDVALUE_BSTR(pbstrID);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReconstituteItemValidValues
	{
		/*[in]*/ LPCOLESTR lpszCurrentName;
		/*[in]*/ LPCOLESTR lpszID;
		/*[in]*/ LPCOLESTR lpszData;
		/*[out]*/ IDataObject** ppDO;
		/*[out]*/ TBXITEMINFO* ptif;
		HRESULT retValue;
	};

	STDMETHOD(ReconstituteItem)(
		/*[in]*/ LPCOLESTR lpszCurrentName,
		/*[in]*/ LPCOLESTR lpszID,
		/*[in]*/ LPCOLESTR lpszData,
		/*[out]*/ IDataObject** ppDO,
		/*[out]*/ TBXITEMINFO* ptif)
	{
		VSL_DEFINE_MOCK_METHOD(ReconstituteItem)

		VSL_CHECK_VALIDVALUE_STRINGW(lpszCurrentName);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszID);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszData);

		VSL_SET_VALIDVALUE_INTERFACE(ppDO);

		VSL_SET_VALIDVALUE(ptif);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTOOLBOXDATAPROVIDER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsToolboxDataProviderRegistry.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTOOLBOXDATAPROVIDERREGISTRY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTOOLBOXDATAPROVIDERREGISTRY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsToolboxDataProviderRegistryNotImpl :
	public IVsToolboxDataProviderRegistry
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsToolboxDataProviderRegistryNotImpl)

public:

	typedef IVsToolboxDataProviderRegistry Interface;

	STDMETHOD(RegisterDataProvider)(
		/*[in]*/ IVsToolboxDataProvider* /*pDP*/,
		/*[out,retval]*/ VSCOOKIE* /*pdwProvider*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnregisterDataProvider)(
		/*[in]*/ VSCOOKIE /*dwProvider*/)VSL_STDMETHOD_NOTIMPL
};

class IVsToolboxDataProviderRegistryMockImpl :
	public IVsToolboxDataProviderRegistry,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsToolboxDataProviderRegistryMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsToolboxDataProviderRegistryMockImpl)

	typedef IVsToolboxDataProviderRegistry Interface;
	struct RegisterDataProviderValidValues
	{
		/*[in]*/ IVsToolboxDataProvider* pDP;
		/*[out,retval]*/ VSCOOKIE* pdwProvider;
		HRESULT retValue;
	};

	STDMETHOD(RegisterDataProvider)(
		/*[in]*/ IVsToolboxDataProvider* pDP,
		/*[out,retval]*/ VSCOOKIE* pdwProvider)
	{
		VSL_DEFINE_MOCK_METHOD(RegisterDataProvider)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDP);

		VSL_SET_VALIDVALUE(pdwProvider);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnregisterDataProviderValidValues
	{
		/*[in]*/ VSCOOKIE dwProvider;
		HRESULT retValue;
	};

	STDMETHOD(UnregisterDataProvider)(
		/*[in]*/ VSCOOKIE dwProvider)
	{
		VSL_DEFINE_MOCK_METHOD(UnregisterDataProvider)

		VSL_CHECK_VALIDVALUE(dwProvider);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTOOLBOXDATAPROVIDERREGISTRY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsToolWindowFactory.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTOOLWINDOWFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTOOLWINDOWFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsToolWindowFactoryNotImpl :
	public IVsToolWindowFactory
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsToolWindowFactoryNotImpl)

public:

	typedef IVsToolWindowFactory Interface;

	STDMETHOD(CreateToolWindow)(
		/*[in]*/ REFGUID /*rguidPersistenceSlot*/,
		/*[in]*/ DWORD /*dwToolWindowId*/)VSL_STDMETHOD_NOTIMPL
};

class IVsToolWindowFactoryMockImpl :
	public IVsToolWindowFactory,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsToolWindowFactoryMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsToolWindowFactoryMockImpl)

	typedef IVsToolWindowFactory Interface;
	struct CreateToolWindowValidValues
	{
		/*[in]*/ REFGUID rguidPersistenceSlot;
		/*[in]*/ DWORD dwToolWindowId;
		HRESULT retValue;
	};

	STDMETHOD(CreateToolWindow)(
		/*[in]*/ REFGUID rguidPersistenceSlot,
		/*[in]*/ DWORD dwToolWindowId)
	{
		VSL_DEFINE_MOCK_METHOD(CreateToolWindow)

		VSL_CHECK_VALIDVALUE(rguidPersistenceSlot);

		VSL_CHECK_VALIDVALUE(dwToolWindowId);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTOOLWINDOWFACTORY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsToolsOptions.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTOOLSOPTIONS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTOOLSOPTIONS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsToolsOptionsNotImpl :
	public IVsToolsOptions
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsToolsOptionsNotImpl)

public:

	typedef IVsToolsOptions Interface;

	STDMETHOD(IsToolsOptionsOpen)(
		/*[out]*/ BOOL* /*pfOpen*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RefreshPageVisibility)()VSL_STDMETHOD_NOTIMPL
};

class IVsToolsOptionsMockImpl :
	public IVsToolsOptions,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsToolsOptionsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsToolsOptionsMockImpl)

	typedef IVsToolsOptions Interface;
	struct IsToolsOptionsOpenValidValues
	{
		/*[out]*/ BOOL* pfOpen;
		HRESULT retValue;
	};

	STDMETHOD(IsToolsOptionsOpen)(
		/*[out]*/ BOOL* pfOpen)
	{
		VSL_DEFINE_MOCK_METHOD(IsToolsOptionsOpen)

		VSL_SET_VALIDVALUE(pfOpen);

		VSL_RETURN_VALIDVALUES();
	}
	struct RefreshPageVisibilityValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(RefreshPageVisibility)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(RefreshPageVisibility)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTOOLSOPTIONS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsToolWindowToolbar.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTOOLWINDOWTOOLBAR_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTOOLWINDOWTOOLBAR_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsToolWindowToolbarNotImpl :
	public IVsToolWindowToolbar
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsToolWindowToolbarNotImpl)

public:

	typedef IVsToolWindowToolbar Interface;

	STDMETHOD(GetBorder)(
		/*[out]*/ RECT* /*prc*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetBorderSpace)(
		/*[in]*/ LPCBORDERWIDTHS /*pbw*/)VSL_STDMETHOD_NOTIMPL
};

class IVsToolWindowToolbarMockImpl :
	public IVsToolWindowToolbar,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsToolWindowToolbarMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsToolWindowToolbarMockImpl)

	typedef IVsToolWindowToolbar Interface;
	struct GetBorderValidValues
	{
		/*[out]*/ RECT* prc;
		HRESULT retValue;
	};

	STDMETHOD(GetBorder)(
		/*[out]*/ RECT* prc)
	{
		VSL_DEFINE_MOCK_METHOD(GetBorder)

		VSL_SET_VALIDVALUE(prc);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetBorderSpaceValidValues
	{
		/*[in]*/ LPCBORDERWIDTHS pbw;
		HRESULT retValue;
	};

	STDMETHOD(SetBorderSpace)(
		/*[in]*/ LPCBORDERWIDTHS pbw)
	{
		VSL_DEFINE_MOCK_METHOD(SetBorderSpace)

		VSL_CHECK_VALIDVALUE(pbw);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTOOLWINDOWTOOLBAR_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsToolWindowToolbarHost.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTOOLWINDOWTOOLBARHOST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTOOLWINDOWTOOLBARHOST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsToolWindowToolbarHostNotImpl :
	public IVsToolWindowToolbarHost
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsToolWindowToolbarHostNotImpl)

public:

	typedef IVsToolWindowToolbarHost Interface;

	STDMETHOD(AddToolbar)(
		/*[in]*/ VSTWT_LOCATION /*dwLoc*/,
		/*[in]*/ const GUID* /*pguid*/,
		/*[in]*/ DWORD /*dwId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(BorderChanged)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ShowHideToolbar)(
		/*[in]*/ const GUID* /*pguid*/,
		/*[in]*/ DWORD /*dwId*/,
		/*[in]*/ BOOL /*fShow*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ProcessMouseActivation)(
		/*[in]*/ HWND /*hwnd*/,
		/*[in]*/ UINT /*msg*/,
		/*[in]*/ WPARAM /*wp*/,
		/*[in]*/ LPARAM /*lp*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ForceUpdateUI)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ProcessMouseActivationModal)(
		/*[in]*/ HWND /*hwnd*/,
		/*[in]*/ UINT /*msg*/,
		/*[in]*/ WPARAM /*wp*/,
		/*[in]*/ LPARAM /*lp*/,
		/*[out]*/ LRESULT* /*plResult*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Close)(
		/*[in]*/ DWORD /*dwReserved*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Show)(
		/*[in]*/ DWORD /*dwReserved*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Hide)(
		/*[in]*/ DWORD /*dwReserved*/)VSL_STDMETHOD_NOTIMPL
};

class IVsToolWindowToolbarHostMockImpl :
	public IVsToolWindowToolbarHost,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsToolWindowToolbarHostMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsToolWindowToolbarHostMockImpl)

	typedef IVsToolWindowToolbarHost Interface;
	struct AddToolbarValidValues
	{
		/*[in]*/ VSTWT_LOCATION dwLoc;
		/*[in]*/ GUID* pguid;
		/*[in]*/ DWORD dwId;
		HRESULT retValue;
	};

	STDMETHOD(AddToolbar)(
		/*[in]*/ VSTWT_LOCATION dwLoc,
		/*[in]*/ const GUID* pguid,
		/*[in]*/ DWORD dwId)
	{
		VSL_DEFINE_MOCK_METHOD(AddToolbar)

		VSL_CHECK_VALIDVALUE(dwLoc);

		VSL_CHECK_VALIDVALUE_POINTER(pguid);

		VSL_CHECK_VALIDVALUE(dwId);

		VSL_RETURN_VALIDVALUES();
	}
	struct BorderChangedValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(BorderChanged)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(BorderChanged)

		VSL_RETURN_VALIDVALUES();
	}
	struct ShowHideToolbarValidValues
	{
		/*[in]*/ GUID* pguid;
		/*[in]*/ DWORD dwId;
		/*[in]*/ BOOL fShow;
		HRESULT retValue;
	};

	STDMETHOD(ShowHideToolbar)(
		/*[in]*/ const GUID* pguid,
		/*[in]*/ DWORD dwId,
		/*[in]*/ BOOL fShow)
	{
		VSL_DEFINE_MOCK_METHOD(ShowHideToolbar)

		VSL_CHECK_VALIDVALUE_POINTER(pguid);

		VSL_CHECK_VALIDVALUE(dwId);

		VSL_CHECK_VALIDVALUE(fShow);

		VSL_RETURN_VALIDVALUES();
	}
	struct ProcessMouseActivationValidValues
	{
		/*[in]*/ HWND hwnd;
		/*[in]*/ UINT msg;
		/*[in]*/ WPARAM wp;
		/*[in]*/ LPARAM lp;
		HRESULT retValue;
	};

	STDMETHOD(ProcessMouseActivation)(
		/*[in]*/ HWND hwnd,
		/*[in]*/ UINT msg,
		/*[in]*/ WPARAM wp,
		/*[in]*/ LPARAM lp)
	{
		VSL_DEFINE_MOCK_METHOD(ProcessMouseActivation)

		VSL_CHECK_VALIDVALUE(hwnd);

		VSL_CHECK_VALIDVALUE(msg);

		VSL_CHECK_VALIDVALUE(wp);

		VSL_CHECK_VALIDVALUE(lp);

		VSL_RETURN_VALIDVALUES();
	}
	struct ForceUpdateUIValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(ForceUpdateUI)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(ForceUpdateUI)

		VSL_RETURN_VALIDVALUES();
	}
	struct ProcessMouseActivationModalValidValues
	{
		/*[in]*/ HWND hwnd;
		/*[in]*/ UINT msg;
		/*[in]*/ WPARAM wp;
		/*[in]*/ LPARAM lp;
		/*[out]*/ LRESULT* plResult;
		HRESULT retValue;
	};

	STDMETHOD(ProcessMouseActivationModal)(
		/*[in]*/ HWND hwnd,
		/*[in]*/ UINT msg,
		/*[in]*/ WPARAM wp,
		/*[in]*/ LPARAM lp,
		/*[out]*/ LRESULT* plResult)
	{
		VSL_DEFINE_MOCK_METHOD(ProcessMouseActivationModal)

		VSL_CHECK_VALIDVALUE(hwnd);

		VSL_CHECK_VALIDVALUE(msg);

		VSL_CHECK_VALIDVALUE(wp);

		VSL_CHECK_VALIDVALUE(lp);

		VSL_SET_VALIDVALUE(plResult);

		VSL_RETURN_VALIDVALUES();
	}
	struct CloseValidValues
	{
		/*[in]*/ DWORD dwReserved;
		HRESULT retValue;
	};

	STDMETHOD(Close)(
		/*[in]*/ DWORD dwReserved)
	{
		VSL_DEFINE_MOCK_METHOD(Close)

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_RETURN_VALIDVALUES();
	}
	struct ShowValidValues
	{
		/*[in]*/ DWORD dwReserved;
		HRESULT retValue;
	};

	STDMETHOD(Show)(
		/*[in]*/ DWORD dwReserved)
	{
		VSL_DEFINE_MOCK_METHOD(Show)

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_RETURN_VALIDVALUES();
	}
	struct HideValidValues
	{
		/*[in]*/ DWORD dwReserved;
		HRESULT retValue;
	};

	STDMETHOD(Hide)(
		/*[in]*/ DWORD dwReserved)
	{
		VSL_DEFINE_MOCK_METHOD(Hide)

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTOOLWINDOWTOOLBARHOST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTrackProjectDocuments3.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTRACKPROJECTDOCUMENTS3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTRACKPROJECTDOCUMENTS3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "IVsTrackProjectDocuments80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTrackProjectDocuments3NotImpl :
	public IVsTrackProjectDocuments3
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTrackProjectDocuments3NotImpl)

public:

	typedef IVsTrackProjectDocuments3 Interface;

	STDMETHOD(BeginQueryBatch)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EndQueryBatch)(
		/*[out,retval]*/ BOOL* /*pfActionOK*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CancelQueryBatch)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnQueryAddFilesEx)(
		/*[in]*/ IVsProject* /*pProject*/,
		/*[in]*/ int /*cFiles*/,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR[] /*rgpszNewMkDocuments*/,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR[] /*rgpszSrcMkDocuments*/,
		/*[in,size_is(cFiles)]*/ const VSQUERYADDFILEFLAGS[] /*rgFlags*/,
		/*[out]*/ VSQUERYADDFILERESULTS* /*pSummaryResult*/,
		/*[out,size_is(cFiles)]*/ VSQUERYADDFILERESULTS[] /*rgResults*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(HandsOffFiles)(
		/*[in]*/ HANDSOFFMODE /*grfRequiredAccess*/,
		/*[in]*/ int /*cFiles*/,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR[] /*rgpszMkDocuments*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(HandsOnFiles)(
		/*[in]*/ int /*cFiles*/,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR[] /*rgpszMkDocuments*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTrackProjectDocuments3MockImpl :
	public IVsTrackProjectDocuments3,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTrackProjectDocuments3MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTrackProjectDocuments3MockImpl)

	typedef IVsTrackProjectDocuments3 Interface;
	struct BeginQueryBatchValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(BeginQueryBatch)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(BeginQueryBatch)

		VSL_RETURN_VALIDVALUES();
	}
	struct EndQueryBatchValidValues
	{
		/*[out,retval]*/ BOOL* pfActionOK;
		HRESULT retValue;
	};

	STDMETHOD(EndQueryBatch)(
		/*[out,retval]*/ BOOL* pfActionOK)
	{
		VSL_DEFINE_MOCK_METHOD(EndQueryBatch)

		VSL_SET_VALIDVALUE(pfActionOK);

		VSL_RETURN_VALIDVALUES();
	}
	struct CancelQueryBatchValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(CancelQueryBatch)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(CancelQueryBatch)

		VSL_RETURN_VALIDVALUES();
	}
	struct OnQueryAddFilesExValidValues
	{
		/*[in]*/ IVsProject* pProject;
		/*[in]*/ int cFiles;
		/*[in,size_is(cFiles)]*/ LPCOLESTR* rgpszNewMkDocuments;
		/*[in,size_is(cFiles)]*/ LPCOLESTR* rgpszSrcMkDocuments;
		/*[in,size_is(cFiles)]*/ VSQUERYADDFILEFLAGS* rgFlags;
		/*[out]*/ VSQUERYADDFILERESULTS* pSummaryResult;
		/*[out,size_is(cFiles)]*/ VSQUERYADDFILERESULTS* rgResults;
		HRESULT retValue;
	};

	STDMETHOD(OnQueryAddFilesEx)(
		/*[in]*/ IVsProject* pProject,
		/*[in]*/ int cFiles,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR rgpszNewMkDocuments[],
		/*[in,size_is(cFiles)]*/ const LPCOLESTR rgpszSrcMkDocuments[],
		/*[in,size_is(cFiles)]*/ const VSQUERYADDFILEFLAGS rgFlags[],
		/*[out]*/ VSQUERYADDFILERESULTS* pSummaryResult,
		/*[out,size_is(cFiles)]*/ VSQUERYADDFILERESULTS rgResults[])
	{
		VSL_DEFINE_MOCK_METHOD(OnQueryAddFilesEx)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProject);

		VSL_CHECK_VALIDVALUE(cFiles);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgpszNewMkDocuments, cFiles*sizeof(rgpszNewMkDocuments[0]), validValues.cFiles*sizeof(validValues.rgpszNewMkDocuments[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgpszSrcMkDocuments, cFiles*sizeof(rgpszSrcMkDocuments[0]), validValues.cFiles*sizeof(validValues.rgpszSrcMkDocuments[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgFlags, cFiles*sizeof(rgFlags[0]), validValues.cFiles*sizeof(validValues.rgFlags[0]));

		VSL_SET_VALIDVALUE(pSummaryResult);

		VSL_SET_VALIDVALUE_MEMCPY(rgResults, cFiles*sizeof(rgResults[0]), validValues.cFiles*sizeof(validValues.rgResults[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct HandsOffFilesValidValues
	{
		/*[in]*/ HANDSOFFMODE grfRequiredAccess;
		/*[in]*/ int cFiles;
		/*[in,size_is(cFiles)]*/ LPCOLESTR* rgpszMkDocuments;
		HRESULT retValue;
	};

	STDMETHOD(HandsOffFiles)(
		/*[in]*/ HANDSOFFMODE grfRequiredAccess,
		/*[in]*/ int cFiles,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR rgpszMkDocuments[])
	{
		VSL_DEFINE_MOCK_METHOD(HandsOffFiles)

		VSL_CHECK_VALIDVALUE(grfRequiredAccess);

		VSL_CHECK_VALIDVALUE(cFiles);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgpszMkDocuments, cFiles*sizeof(rgpszMkDocuments[0]), validValues.cFiles*sizeof(validValues.rgpszMkDocuments[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct HandsOnFilesValidValues
	{
		/*[in]*/ int cFiles;
		/*[in,size_is(cFiles)]*/ LPCOLESTR* rgpszMkDocuments;
		HRESULT retValue;
	};

	STDMETHOD(HandsOnFiles)(
		/*[in]*/ int cFiles,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR rgpszMkDocuments[])
	{
		VSL_DEFINE_MOCK_METHOD(HandsOnFiles)

		VSL_CHECK_VALIDVALUE(cFiles);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgpszMkDocuments, cFiles*sizeof(rgpszMkDocuments[0]), validValues.cFiles*sizeof(validValues.rgpszMkDocuments[0]));

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTRACKPROJECTDOCUMENTS3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTrackProjectDocumentsEvents3.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTRACKPROJECTDOCUMENTSEVENTS3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTRACKPROJECTDOCUMENTSEVENTS3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "IVsTrackProjectDocumentsEvents80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTrackProjectDocumentsEvents3NotImpl :
	public IVsTrackProjectDocumentsEvents3
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTrackProjectDocumentsEvents3NotImpl)

public:

	typedef IVsTrackProjectDocumentsEvents3 Interface;

	STDMETHOD(OnBeginQueryBatch)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnEndQueryBatch)(
		/*[out,retval]*/ BOOL* /*pfActionOK*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnCancelQueryBatch)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnQueryAddFilesEx)(
		/*[in]*/ IVsProject* /*pProject*/,
		/*[in]*/ int /*cFiles*/,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR[] /*rgpszNewMkDocuments*/,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR[] /*rgpszSrcMkDocuments*/,
		/*[in,size_is(cFiles)]*/ const VSQUERYADDFILEFLAGS[] /*rgFlags*/,
		/*[out]*/ VSQUERYADDFILERESULTS* /*pSummaryResult*/,
		/*[out,size_is(cFiles)]*/ VSQUERYADDFILERESULTS[] /*rgResults*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(HandsOffFiles)(
		/*[in]*/ HANDSOFFMODE /*grfRequiredAccess*/,
		/*[in]*/ int /*cFiles*/,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR[] /*rgpszMkDocuments*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(HandsOnFiles)(
		/*[in]*/ int /*cFiles*/,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR[] /*rgpszMkDocuments*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTrackProjectDocumentsEvents3MockImpl :
	public IVsTrackProjectDocumentsEvents3,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTrackProjectDocumentsEvents3MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTrackProjectDocumentsEvents3MockImpl)

	typedef IVsTrackProjectDocumentsEvents3 Interface;
	struct OnBeginQueryBatchValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(OnBeginQueryBatch)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(OnBeginQueryBatch)

		VSL_RETURN_VALIDVALUES();
	}
	struct OnEndQueryBatchValidValues
	{
		/*[out,retval]*/ BOOL* pfActionOK;
		HRESULT retValue;
	};

	STDMETHOD(OnEndQueryBatch)(
		/*[out,retval]*/ BOOL* pfActionOK)
	{
		VSL_DEFINE_MOCK_METHOD(OnEndQueryBatch)

		VSL_SET_VALIDVALUE(pfActionOK);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnCancelQueryBatchValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(OnCancelQueryBatch)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(OnCancelQueryBatch)

		VSL_RETURN_VALIDVALUES();
	}
	struct OnQueryAddFilesExValidValues
	{
		/*[in]*/ IVsProject* pProject;
		/*[in]*/ int cFiles;
		/*[in,size_is(cFiles)]*/ LPCOLESTR* rgpszNewMkDocuments;
		/*[in,size_is(cFiles)]*/ LPCOLESTR* rgpszSrcMkDocuments;
		/*[in,size_is(cFiles)]*/ VSQUERYADDFILEFLAGS* rgFlags;
		/*[out]*/ VSQUERYADDFILERESULTS* pSummaryResult;
		/*[out,size_is(cFiles)]*/ VSQUERYADDFILERESULTS* rgResults;
		HRESULT retValue;
	};

	STDMETHOD(OnQueryAddFilesEx)(
		/*[in]*/ IVsProject* pProject,
		/*[in]*/ int cFiles,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR rgpszNewMkDocuments[],
		/*[in,size_is(cFiles)]*/ const LPCOLESTR rgpszSrcMkDocuments[],
		/*[in,size_is(cFiles)]*/ const VSQUERYADDFILEFLAGS rgFlags[],
		/*[out]*/ VSQUERYADDFILERESULTS* pSummaryResult,
		/*[out,size_is(cFiles)]*/ VSQUERYADDFILERESULTS rgResults[])
	{
		VSL_DEFINE_MOCK_METHOD(OnQueryAddFilesEx)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProject);

		VSL_CHECK_VALIDVALUE(cFiles);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgpszNewMkDocuments, cFiles*sizeof(rgpszNewMkDocuments[0]), validValues.cFiles*sizeof(validValues.rgpszNewMkDocuments[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgpszSrcMkDocuments, cFiles*sizeof(rgpszSrcMkDocuments[0]), validValues.cFiles*sizeof(validValues.rgpszSrcMkDocuments[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgFlags, cFiles*sizeof(rgFlags[0]), validValues.cFiles*sizeof(validValues.rgFlags[0]));

		VSL_SET_VALIDVALUE(pSummaryResult);

		VSL_SET_VALIDVALUE_MEMCPY(rgResults, cFiles*sizeof(rgResults[0]), validValues.cFiles*sizeof(validValues.rgResults[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct HandsOffFilesValidValues
	{
		/*[in]*/ HANDSOFFMODE grfRequiredAccess;
		/*[in]*/ int cFiles;
		/*[in,size_is(cFiles)]*/ LPCOLESTR* rgpszMkDocuments;
		HRESULT retValue;
	};

	STDMETHOD(HandsOffFiles)(
		/*[in]*/ HANDSOFFMODE grfRequiredAccess,
		/*[in]*/ int cFiles,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR rgpszMkDocuments[])
	{
		VSL_DEFINE_MOCK_METHOD(HandsOffFiles)

		VSL_CHECK_VALIDVALUE(grfRequiredAccess);

		VSL_CHECK_VALIDVALUE(cFiles);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgpszMkDocuments, cFiles*sizeof(rgpszMkDocuments[0]), validValues.cFiles*sizeof(validValues.rgpszMkDocuments[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct HandsOnFilesValidValues
	{
		/*[in]*/ int cFiles;
		/*[in,size_is(cFiles)]*/ LPCOLESTR* rgpszMkDocuments;
		HRESULT retValue;
	};

	STDMETHOD(HandsOnFiles)(
		/*[in]*/ int cFiles,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR rgpszMkDocuments[])
	{
		VSL_DEFINE_MOCK_METHOD(HandsOnFiles)

		VSL_CHECK_VALIDVALUE(cFiles);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgpszMkDocuments, cFiles*sizeof(rgpszMkDocuments[0]), validValues.cFiles*sizeof(validValues.rgpszMkDocuments[0]));

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTRACKPROJECTDOCUMENTSEVENTS3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTrackSelectionEx.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTRACKSELECTIONEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTRACKSELECTIONEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTrackSelectionExNotImpl :
	public IVsTrackSelectionEx
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTrackSelectionExNotImpl)

public:

	typedef IVsTrackSelectionEx Interface;

	STDMETHOD(OnSelectChangeEx)(
		/*[in]*/ IVsHierarchy* /*pHier*/,
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ IVsMultiItemSelect* /*pMIS*/,
		/*[in]*/ ISelectionContainer* /*pSC*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsMyHierarchyCurrent)(
		/*[out]*/ BOOL* /*pfCurrent*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnElementValueChange)(
		/*[in]*/ VSSELELEMID /*elementid*/,
		/*[in]*/ BOOL /*fDontPropagate*/,
		/*[in]*/ VARIANT /*varValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCurrentSelection)(
		/*[out]*/ IVsHierarchy** /*ppHier*/,
		/*[out]*/ VSITEMID* /*pitemid*/,
		/*[out]*/ IVsMultiItemSelect** /*ppMIS*/,
		/*[out]*/ ISelectionContainer** /*ppSC*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnSelectChange)(
		/*[in]*/ ISelectionContainer* /*pSC*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTrackSelectionExMockImpl :
	public IVsTrackSelectionEx,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTrackSelectionExMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTrackSelectionExMockImpl)

	typedef IVsTrackSelectionEx Interface;
	struct OnSelectChangeExValidValues
	{
		/*[in]*/ IVsHierarchy* pHier;
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ IVsMultiItemSelect* pMIS;
		/*[in]*/ ISelectionContainer* pSC;
		HRESULT retValue;
	};

	STDMETHOD(OnSelectChangeEx)(
		/*[in]*/ IVsHierarchy* pHier,
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ IVsMultiItemSelect* pMIS,
		/*[in]*/ ISelectionContainer* pSC)
	{
		VSL_DEFINE_MOCK_METHOD(OnSelectChangeEx)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHier);

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pMIS);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSC);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsMyHierarchyCurrentValidValues
	{
		/*[out]*/ BOOL* pfCurrent;
		HRESULT retValue;
	};

	STDMETHOD(IsMyHierarchyCurrent)(
		/*[out]*/ BOOL* pfCurrent)
	{
		VSL_DEFINE_MOCK_METHOD(IsMyHierarchyCurrent)

		VSL_SET_VALIDVALUE(pfCurrent);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnElementValueChangeValidValues
	{
		/*[in]*/ VSSELELEMID elementid;
		/*[in]*/ BOOL fDontPropagate;
		/*[in]*/ VARIANT varValue;
		HRESULT retValue;
	};

	STDMETHOD(OnElementValueChange)(
		/*[in]*/ VSSELELEMID elementid,
		/*[in]*/ BOOL fDontPropagate,
		/*[in]*/ VARIANT varValue)
	{
		VSL_DEFINE_MOCK_METHOD(OnElementValueChange)

		VSL_CHECK_VALIDVALUE(elementid);

		VSL_CHECK_VALIDVALUE(fDontPropagate);

		VSL_CHECK_VALIDVALUE(varValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCurrentSelectionValidValues
	{
		/*[out]*/ IVsHierarchy** ppHier;
		/*[out]*/ VSITEMID* pitemid;
		/*[out]*/ IVsMultiItemSelect** ppMIS;
		/*[out]*/ ISelectionContainer** ppSC;
		HRESULT retValue;
	};

	STDMETHOD(GetCurrentSelection)(
		/*[out]*/ IVsHierarchy** ppHier,
		/*[out]*/ VSITEMID* pitemid,
		/*[out]*/ IVsMultiItemSelect** ppMIS,
		/*[out]*/ ISelectionContainer** ppSC)
	{
		VSL_DEFINE_MOCK_METHOD(GetCurrentSelection)

		VSL_SET_VALIDVALUE_INTERFACE(ppHier);

		VSL_SET_VALIDVALUE(pitemid);

		VSL_SET_VALIDVALUE_INTERFACE(ppMIS);

		VSL_SET_VALIDVALUE_INTERFACE(ppSC);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnSelectChangeValidValues
	{
		/*[in]*/ ISelectionContainer* pSC;
		HRESULT retValue;
	};

	STDMETHOD(OnSelectChange)(
		/*[in]*/ ISelectionContainer* pSC)
	{
		VSL_DEFINE_MOCK_METHOD(OnSelectChange)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSC);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTRACKSELECTIONEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTrackProjectDocuments2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTRACKPROJECTDOCUMENTS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTRACKPROJECTDOCUMENTS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "IVsTrackProjectDocuments2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTrackProjectDocuments2NotImpl :
	public IVsTrackProjectDocuments2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTrackProjectDocuments2NotImpl)

public:

	typedef IVsTrackProjectDocuments2 Interface;

	STDMETHOD(BeginBatch)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EndBatch)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Flush)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnQueryAddFiles)(
		/*[in]*/ IVsProject* /*pProject*/,
		/*[in]*/ int /*cFiles*/,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR[] /*rgpszMkDocuments*/,
		/*[in,size_is(cFiles)]*/ const VSQUERYADDFILEFLAGS[] /*rgFlags*/,
		/*[out]*/ VSQUERYADDFILERESULTS* /*pSummaryResult*/,
		/*[out,size_is(cFiles)]*/ VSQUERYADDFILERESULTS[] /*rgResults*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterAddFilesEx)(
		/*[in]*/ IVsProject* /*pProject*/,
		/*[in]*/ int /*cFiles*/,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR[] /*rgpszMkDocuments*/,
		/*[in,size_is(cFiles)]*/ const VSADDFILEFLAGS[] /*rgFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterAddFiles)(
		/*[in]*/ IVsProject* /*pProject*/,
		/*[in]*/ int /*cFiles*/,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR[] /*rgpszMkDocuments*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterAddDirectoriesEx)(
		/*[in]*/ IVsProject* /*pProject*/,
		/*[in]*/ int /*cDirectories*/,
		/*[in,size_is(cDirectories)]*/ const LPCOLESTR[] /*rgpszMkDocuments*/,
		/*[in,size_is(cDirectories)]*/ const VSADDDIRECTORYFLAGS[] /*rgFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterAddDirectories)(
		/*[in]*/ IVsProject* /*pProject*/,
		/*[in]*/ int /*cDirectories*/,
		/*[in,size_is(cDirectories)]*/ const LPCOLESTR[] /*rgpszMkDocuments*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterRemoveFiles)(
		/*[in]*/ IVsProject* /*pProject*/,
		/*[in]*/ int /*cFiles*/,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR[] /*rgpszMkDocuments*/,
		/*[in,size_is(cFiles)]*/ const VSREMOVEFILEFLAGS[] /*rgFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterRemoveDirectories)(
		/*[in]*/ IVsProject* /*pProject*/,
		/*[in]*/ int /*cDirectories*/,
		/*[in,size_is(cDirectories)]*/ const LPCOLESTR[] /*rgpszMkDocuments*/,
		/*[in,size_is(cDirectories)]*/ const VSREMOVEDIRECTORYFLAGS[] /*rgFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnQueryRenameFiles)(
		/*[in]*/ IVsProject* /*pProject*/,
		/*[in]*/ int /*cFiles*/,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR[] /*rgszMkOldNames*/,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR[] /*rgszMkNewNames*/,
		/*[in,size_is(cFiles)]*/ const VSQUERYRENAMEFILEFLAGS[] /*rgflags*/,
		/*[out]*/ VSQUERYRENAMEFILERESULTS* /*pSummaryResult*/,
		/*[out,size_is(cFiles)]*/ VSQUERYRENAMEFILERESULTS[] /*rgResults*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnQueryRenameFile)(
		/*[in]*/ IVsProject* /*pProject*/,
		/*[in]*/ LPCOLESTR /*pszMkOldName*/,
		/*[in]*/ LPCOLESTR /*pszMkNewName*/,
		/*[in]*/ VSRENAMEFILEFLAGS /*flags*/,
		/*[out]*/ BOOL* /*pfRenameCanContinue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterRenameFiles)(
		/*[in]*/ IVsProject* /*pProject*/,
		/*[in]*/ int /*cFiles*/,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR[] /*rgszMkOldNames*/,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR[] /*rgszMkNewNames*/,
		/*[in,size_is(cFiles)]*/ const VSRENAMEFILEFLAGS[] /*rgflags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterRenameFile)(
		/*[in]*/ IVsProject* /*pProject*/,
		/*[in]*/ LPCOLESTR /*pszMkOldName*/,
		/*[in]*/ LPCOLESTR /*pszMkNewName*/,
		/*[in]*/ VSRENAMEFILEFLAGS /*flags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnQueryRenameDirectories)(
		/*[in]*/ IVsProject* /*pProject*/,
		/*[in]*/ int /*cDirs*/,
		/*[in,size_is(cDirs)]*/ const LPCOLESTR[] /*rgszMkOldNames*/,
		/*[in,size_is(cDirs)]*/ const LPCOLESTR[] /*rgszMkNewNames*/,
		/*[in,size_is(cDirs)]*/ const VSQUERYRENAMEDIRECTORYFLAGS[] /*rgflags*/,
		/*[out]*/ VSQUERYRENAMEDIRECTORYRESULTS* /*pSummaryResult*/,
		/*[out,size_is(cDirs)]*/ VSQUERYRENAMEDIRECTORYRESULTS[] /*rgResults*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterRenameDirectories)(
		/*[in]*/ IVsProject* /*pProject*/,
		/*[in]*/ int /*cDirs*/,
		/*[in,size_is(cDirs)]*/ const LPCOLESTR[] /*rgszMkOldNames*/,
		/*[in,size_is(cDirs)]*/ const LPCOLESTR[] /*rgszMkNewNames*/,
		/*[in,size_is(cDirs)]*/ const VSRENAMEDIRECTORYFLAGS[] /*rgflags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AdviseTrackProjectDocumentsEvents)(
		/*[in]*/ IVsTrackProjectDocumentsEvents2* /*pEventSink*/,
		/*[out]*/ VSCOOKIE* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnadviseTrackProjectDocumentsEvents)(
		/*[in]*/ VSCOOKIE /*dwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnQueryAddDirectories)(
		/*[in]*/ IVsProject* /*pProject*/,
		/*[in]*/ int /*cDirectories*/,
		/*[in,size_is(cDirectories)]*/ const LPCOLESTR[] /*rgpszMkDocuments*/,
		/*[in,size_is(cDirectories)]*/ const VSQUERYADDDIRECTORYFLAGS[] /*rgFlags*/,
		/*[out]*/ VSQUERYADDDIRECTORYRESULTS* /*pSummaryResult*/,
		/*[out,size_is(cDirectories)]*/ VSQUERYADDDIRECTORYRESULTS[] /*rgResults*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnQueryRemoveFiles)(
		/*[in]*/ IVsProject* /*pProject*/,
		/*[in]*/ int /*cFiles*/,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR[] /*rgpszMkDocuments*/,
		/*[in,size_is(cFiles)]*/ const VSQUERYREMOVEFILEFLAGS[] /*rgFlags*/,
		/*[out]*/ VSQUERYREMOVEFILERESULTS* /*pSummaryResult*/,
		/*[out,size_is(cFiles)]*/ VSQUERYREMOVEFILERESULTS[] /*rgResults*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnQueryRemoveDirectories)(
		/*[in]*/ IVsProject* /*pProject*/,
		/*[in]*/ int /*cDirectories*/,
		/*[in,size_is(cDirectories)]*/ const LPCOLESTR[] /*rgpszMkDocuments*/,
		/*[in,size_is(cDirectories)]*/ const VSQUERYREMOVEDIRECTORYFLAGS[] /*rgFlags*/,
		/*[out]*/ VSQUERYREMOVEDIRECTORYRESULTS* /*pSummaryResult*/,
		/*[out,size_is(cDirectories)]*/ VSQUERYREMOVEDIRECTORYRESULTS[] /*rgResults*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterSccStatusChanged)(
		/*[in]*/ IVsProject* /*pProject*/,
		/*[in]*/ int /*cFiles*/,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR[] /*rgpszMkDocuments*/,
		/*[in,size_is(cFiles)]*/ const DWORD[] /*rgdwSccStatus*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTrackProjectDocuments2MockImpl :
	public IVsTrackProjectDocuments2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTrackProjectDocuments2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTrackProjectDocuments2MockImpl)

	typedef IVsTrackProjectDocuments2 Interface;
	struct BeginBatchValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(BeginBatch)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(BeginBatch)

		VSL_RETURN_VALIDVALUES();
	}
	struct EndBatchValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(EndBatch)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(EndBatch)

		VSL_RETURN_VALIDVALUES();
	}
	struct FlushValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Flush)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Flush)

		VSL_RETURN_VALIDVALUES();
	}
	struct OnQueryAddFilesValidValues
	{
		/*[in]*/ IVsProject* pProject;
		/*[in]*/ int cFiles;
		/*[in,size_is(cFiles)]*/ LPCOLESTR* rgpszMkDocuments;
		/*[in,size_is(cFiles)]*/ VSQUERYADDFILEFLAGS* rgFlags;
		/*[out]*/ VSQUERYADDFILERESULTS* pSummaryResult;
		/*[out,size_is(cFiles)]*/ VSQUERYADDFILERESULTS* rgResults;
		HRESULT retValue;
	};

	STDMETHOD(OnQueryAddFiles)(
		/*[in]*/ IVsProject* pProject,
		/*[in]*/ int cFiles,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR rgpszMkDocuments[],
		/*[in,size_is(cFiles)]*/ const VSQUERYADDFILEFLAGS rgFlags[],
		/*[out]*/ VSQUERYADDFILERESULTS* pSummaryResult,
		/*[out,size_is(cFiles)]*/ VSQUERYADDFILERESULTS rgResults[])
	{
		VSL_DEFINE_MOCK_METHOD(OnQueryAddFiles)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProject);

		VSL_CHECK_VALIDVALUE(cFiles);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgpszMkDocuments, cFiles*sizeof(rgpszMkDocuments[0]), validValues.cFiles*sizeof(validValues.rgpszMkDocuments[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgFlags, cFiles*sizeof(rgFlags[0]), validValues.cFiles*sizeof(validValues.rgFlags[0]));

		VSL_SET_VALIDVALUE(pSummaryResult);

		VSL_SET_VALIDVALUE_MEMCPY(rgResults, cFiles*sizeof(rgResults[0]), validValues.cFiles*sizeof(validValues.rgResults[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterAddFilesExValidValues
	{
		/*[in]*/ IVsProject* pProject;
		/*[in]*/ int cFiles;
		/*[in,size_is(cFiles)]*/ LPCOLESTR* rgpszMkDocuments;
		/*[in,size_is(cFiles)]*/ VSADDFILEFLAGS* rgFlags;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterAddFilesEx)(
		/*[in]*/ IVsProject* pProject,
		/*[in]*/ int cFiles,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR rgpszMkDocuments[],
		/*[in,size_is(cFiles)]*/ const VSADDFILEFLAGS rgFlags[])
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterAddFilesEx)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProject);

		VSL_CHECK_VALIDVALUE(cFiles);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgpszMkDocuments, cFiles*sizeof(rgpszMkDocuments[0]), validValues.cFiles*sizeof(validValues.rgpszMkDocuments[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgFlags, cFiles*sizeof(rgFlags[0]), validValues.cFiles*sizeof(validValues.rgFlags[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterAddFilesValidValues
	{
		/*[in]*/ IVsProject* pProject;
		/*[in]*/ int cFiles;
		/*[in,size_is(cFiles)]*/ LPCOLESTR* rgpszMkDocuments;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterAddFiles)(
		/*[in]*/ IVsProject* pProject,
		/*[in]*/ int cFiles,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR rgpszMkDocuments[])
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterAddFiles)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProject);

		VSL_CHECK_VALIDVALUE(cFiles);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgpszMkDocuments, cFiles*sizeof(rgpszMkDocuments[0]), validValues.cFiles*sizeof(validValues.rgpszMkDocuments[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterAddDirectoriesExValidValues
	{
		/*[in]*/ IVsProject* pProject;
		/*[in]*/ int cDirectories;
		/*[in,size_is(cDirectories)]*/ LPCOLESTR* rgpszMkDocuments;
		/*[in,size_is(cDirectories)]*/ VSADDDIRECTORYFLAGS* rgFlags;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterAddDirectoriesEx)(
		/*[in]*/ IVsProject* pProject,
		/*[in]*/ int cDirectories,
		/*[in,size_is(cDirectories)]*/ const LPCOLESTR rgpszMkDocuments[],
		/*[in,size_is(cDirectories)]*/ const VSADDDIRECTORYFLAGS rgFlags[])
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterAddDirectoriesEx)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProject);

		VSL_CHECK_VALIDVALUE(cDirectories);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgpszMkDocuments, cDirectories*sizeof(rgpszMkDocuments[0]), validValues.cDirectories*sizeof(validValues.rgpszMkDocuments[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgFlags, cDirectories*sizeof(rgFlags[0]), validValues.cDirectories*sizeof(validValues.rgFlags[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterAddDirectoriesValidValues
	{
		/*[in]*/ IVsProject* pProject;
		/*[in]*/ int cDirectories;
		/*[in,size_is(cDirectories)]*/ LPCOLESTR* rgpszMkDocuments;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterAddDirectories)(
		/*[in]*/ IVsProject* pProject,
		/*[in]*/ int cDirectories,
		/*[in,size_is(cDirectories)]*/ const LPCOLESTR rgpszMkDocuments[])
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterAddDirectories)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProject);

		VSL_CHECK_VALIDVALUE(cDirectories);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgpszMkDocuments, cDirectories*sizeof(rgpszMkDocuments[0]), validValues.cDirectories*sizeof(validValues.rgpszMkDocuments[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterRemoveFilesValidValues
	{
		/*[in]*/ IVsProject* pProject;
		/*[in]*/ int cFiles;
		/*[in,size_is(cFiles)]*/ LPCOLESTR* rgpszMkDocuments;
		/*[in,size_is(cFiles)]*/ VSREMOVEFILEFLAGS* rgFlags;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterRemoveFiles)(
		/*[in]*/ IVsProject* pProject,
		/*[in]*/ int cFiles,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR rgpszMkDocuments[],
		/*[in,size_is(cFiles)]*/ const VSREMOVEFILEFLAGS rgFlags[])
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterRemoveFiles)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProject);

		VSL_CHECK_VALIDVALUE(cFiles);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgpszMkDocuments, cFiles*sizeof(rgpszMkDocuments[0]), validValues.cFiles*sizeof(validValues.rgpszMkDocuments[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgFlags, cFiles*sizeof(rgFlags[0]), validValues.cFiles*sizeof(validValues.rgFlags[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterRemoveDirectoriesValidValues
	{
		/*[in]*/ IVsProject* pProject;
		/*[in]*/ int cDirectories;
		/*[in,size_is(cDirectories)]*/ LPCOLESTR* rgpszMkDocuments;
		/*[in,size_is(cDirectories)]*/ VSREMOVEDIRECTORYFLAGS* rgFlags;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterRemoveDirectories)(
		/*[in]*/ IVsProject* pProject,
		/*[in]*/ int cDirectories,
		/*[in,size_is(cDirectories)]*/ const LPCOLESTR rgpszMkDocuments[],
		/*[in,size_is(cDirectories)]*/ const VSREMOVEDIRECTORYFLAGS rgFlags[])
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterRemoveDirectories)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProject);

		VSL_CHECK_VALIDVALUE(cDirectories);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgpszMkDocuments, cDirectories*sizeof(rgpszMkDocuments[0]), validValues.cDirectories*sizeof(validValues.rgpszMkDocuments[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgFlags, cDirectories*sizeof(rgFlags[0]), validValues.cDirectories*sizeof(validValues.rgFlags[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct OnQueryRenameFilesValidValues
	{
		/*[in]*/ IVsProject* pProject;
		/*[in]*/ int cFiles;
		/*[in,size_is(cFiles)]*/ LPCOLESTR* rgszMkOldNames;
		/*[in,size_is(cFiles)]*/ LPCOLESTR* rgszMkNewNames;
		/*[in,size_is(cFiles)]*/ VSQUERYRENAMEFILEFLAGS* rgflags;
		/*[out]*/ VSQUERYRENAMEFILERESULTS* pSummaryResult;
		/*[out,size_is(cFiles)]*/ VSQUERYRENAMEFILERESULTS* rgResults;
		HRESULT retValue;
	};

	STDMETHOD(OnQueryRenameFiles)(
		/*[in]*/ IVsProject* pProject,
		/*[in]*/ int cFiles,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR rgszMkOldNames[],
		/*[in,size_is(cFiles)]*/ const LPCOLESTR rgszMkNewNames[],
		/*[in,size_is(cFiles)]*/ const VSQUERYRENAMEFILEFLAGS rgflags[],
		/*[out]*/ VSQUERYRENAMEFILERESULTS* pSummaryResult,
		/*[out,size_is(cFiles)]*/ VSQUERYRENAMEFILERESULTS rgResults[])
	{
		VSL_DEFINE_MOCK_METHOD(OnQueryRenameFiles)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProject);

		VSL_CHECK_VALIDVALUE(cFiles);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszMkOldNames, cFiles*sizeof(rgszMkOldNames[0]), validValues.cFiles*sizeof(validValues.rgszMkOldNames[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszMkNewNames, cFiles*sizeof(rgszMkNewNames[0]), validValues.cFiles*sizeof(validValues.rgszMkNewNames[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgflags, cFiles*sizeof(rgflags[0]), validValues.cFiles*sizeof(validValues.rgflags[0]));

		VSL_SET_VALIDVALUE(pSummaryResult);

		VSL_SET_VALIDVALUE_MEMCPY(rgResults, cFiles*sizeof(rgResults[0]), validValues.cFiles*sizeof(validValues.rgResults[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct OnQueryRenameFileValidValues
	{
		/*[in]*/ IVsProject* pProject;
		/*[in]*/ LPCOLESTR pszMkOldName;
		/*[in]*/ LPCOLESTR pszMkNewName;
		/*[in]*/ VSRENAMEFILEFLAGS flags;
		/*[out]*/ BOOL* pfRenameCanContinue;
		HRESULT retValue;
	};

	STDMETHOD(OnQueryRenameFile)(
		/*[in]*/ IVsProject* pProject,
		/*[in]*/ LPCOLESTR pszMkOldName,
		/*[in]*/ LPCOLESTR pszMkNewName,
		/*[in]*/ VSRENAMEFILEFLAGS flags,
		/*[out]*/ BOOL* pfRenameCanContinue)
	{
		VSL_DEFINE_MOCK_METHOD(OnQueryRenameFile)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProject);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkOldName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkNewName);

		VSL_CHECK_VALIDVALUE(flags);

		VSL_SET_VALIDVALUE(pfRenameCanContinue);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterRenameFilesValidValues
	{
		/*[in]*/ IVsProject* pProject;
		/*[in]*/ int cFiles;
		/*[in,size_is(cFiles)]*/ LPCOLESTR* rgszMkOldNames;
		/*[in,size_is(cFiles)]*/ LPCOLESTR* rgszMkNewNames;
		/*[in,size_is(cFiles)]*/ VSRENAMEFILEFLAGS* rgflags;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterRenameFiles)(
		/*[in]*/ IVsProject* pProject,
		/*[in]*/ int cFiles,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR rgszMkOldNames[],
		/*[in,size_is(cFiles)]*/ const LPCOLESTR rgszMkNewNames[],
		/*[in,size_is(cFiles)]*/ const VSRENAMEFILEFLAGS rgflags[])
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterRenameFiles)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProject);

		VSL_CHECK_VALIDVALUE(cFiles);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszMkOldNames, cFiles*sizeof(rgszMkOldNames[0]), validValues.cFiles*sizeof(validValues.rgszMkOldNames[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszMkNewNames, cFiles*sizeof(rgszMkNewNames[0]), validValues.cFiles*sizeof(validValues.rgszMkNewNames[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgflags, cFiles*sizeof(rgflags[0]), validValues.cFiles*sizeof(validValues.rgflags[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterRenameFileValidValues
	{
		/*[in]*/ IVsProject* pProject;
		/*[in]*/ LPCOLESTR pszMkOldName;
		/*[in]*/ LPCOLESTR pszMkNewName;
		/*[in]*/ VSRENAMEFILEFLAGS flags;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterRenameFile)(
		/*[in]*/ IVsProject* pProject,
		/*[in]*/ LPCOLESTR pszMkOldName,
		/*[in]*/ LPCOLESTR pszMkNewName,
		/*[in]*/ VSRENAMEFILEFLAGS flags)
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterRenameFile)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProject);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkOldName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkNewName);

		VSL_CHECK_VALIDVALUE(flags);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnQueryRenameDirectoriesValidValues
	{
		/*[in]*/ IVsProject* pProject;
		/*[in]*/ int cDirs;
		/*[in,size_is(cDirs)]*/ LPCOLESTR* rgszMkOldNames;
		/*[in,size_is(cDirs)]*/ LPCOLESTR* rgszMkNewNames;
		/*[in,size_is(cDirs)]*/ VSQUERYRENAMEDIRECTORYFLAGS* rgflags;
		/*[out]*/ VSQUERYRENAMEDIRECTORYRESULTS* pSummaryResult;
		/*[out,size_is(cDirs)]*/ VSQUERYRENAMEDIRECTORYRESULTS* rgResults;
		HRESULT retValue;
	};

	STDMETHOD(OnQueryRenameDirectories)(
		/*[in]*/ IVsProject* pProject,
		/*[in]*/ int cDirs,
		/*[in,size_is(cDirs)]*/ const LPCOLESTR rgszMkOldNames[],
		/*[in,size_is(cDirs)]*/ const LPCOLESTR rgszMkNewNames[],
		/*[in,size_is(cDirs)]*/ const VSQUERYRENAMEDIRECTORYFLAGS rgflags[],
		/*[out]*/ VSQUERYRENAMEDIRECTORYRESULTS* pSummaryResult,
		/*[out,size_is(cDirs)]*/ VSQUERYRENAMEDIRECTORYRESULTS rgResults[])
	{
		VSL_DEFINE_MOCK_METHOD(OnQueryRenameDirectories)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProject);

		VSL_CHECK_VALIDVALUE(cDirs);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszMkOldNames, cDirs*sizeof(rgszMkOldNames[0]), validValues.cDirs*sizeof(validValues.rgszMkOldNames[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszMkNewNames, cDirs*sizeof(rgszMkNewNames[0]), validValues.cDirs*sizeof(validValues.rgszMkNewNames[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgflags, cDirs*sizeof(rgflags[0]), validValues.cDirs*sizeof(validValues.rgflags[0]));

		VSL_SET_VALIDVALUE(pSummaryResult);

		VSL_SET_VALIDVALUE_MEMCPY(rgResults, cDirs*sizeof(rgResults[0]), validValues.cDirs*sizeof(validValues.rgResults[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterRenameDirectoriesValidValues
	{
		/*[in]*/ IVsProject* pProject;
		/*[in]*/ int cDirs;
		/*[in,size_is(cDirs)]*/ LPCOLESTR* rgszMkOldNames;
		/*[in,size_is(cDirs)]*/ LPCOLESTR* rgszMkNewNames;
		/*[in,size_is(cDirs)]*/ VSRENAMEDIRECTORYFLAGS* rgflags;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterRenameDirectories)(
		/*[in]*/ IVsProject* pProject,
		/*[in]*/ int cDirs,
		/*[in,size_is(cDirs)]*/ const LPCOLESTR rgszMkOldNames[],
		/*[in,size_is(cDirs)]*/ const LPCOLESTR rgszMkNewNames[],
		/*[in,size_is(cDirs)]*/ const VSRENAMEDIRECTORYFLAGS rgflags[])
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterRenameDirectories)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProject);

		VSL_CHECK_VALIDVALUE(cDirs);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszMkOldNames, cDirs*sizeof(rgszMkOldNames[0]), validValues.cDirs*sizeof(validValues.rgszMkOldNames[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszMkNewNames, cDirs*sizeof(rgszMkNewNames[0]), validValues.cDirs*sizeof(validValues.rgszMkNewNames[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgflags, cDirs*sizeof(rgflags[0]), validValues.cDirs*sizeof(validValues.rgflags[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct AdviseTrackProjectDocumentsEventsValidValues
	{
		/*[in]*/ IVsTrackProjectDocumentsEvents2* pEventSink;
		/*[out]*/ VSCOOKIE* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(AdviseTrackProjectDocumentsEvents)(
		/*[in]*/ IVsTrackProjectDocumentsEvents2* pEventSink,
		/*[out]*/ VSCOOKIE* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(AdviseTrackProjectDocumentsEvents)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pEventSink);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnadviseTrackProjectDocumentsEventsValidValues
	{
		/*[in]*/ VSCOOKIE dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(UnadviseTrackProjectDocumentsEvents)(
		/*[in]*/ VSCOOKIE dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(UnadviseTrackProjectDocumentsEvents)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnQueryAddDirectoriesValidValues
	{
		/*[in]*/ IVsProject* pProject;
		/*[in]*/ int cDirectories;
		/*[in,size_is(cDirectories)]*/ LPCOLESTR* rgpszMkDocuments;
		/*[in,size_is(cDirectories)]*/ VSQUERYADDDIRECTORYFLAGS* rgFlags;
		/*[out]*/ VSQUERYADDDIRECTORYRESULTS* pSummaryResult;
		/*[out,size_is(cDirectories)]*/ VSQUERYADDDIRECTORYRESULTS* rgResults;
		HRESULT retValue;
	};

	STDMETHOD(OnQueryAddDirectories)(
		/*[in]*/ IVsProject* pProject,
		/*[in]*/ int cDirectories,
		/*[in,size_is(cDirectories)]*/ const LPCOLESTR rgpszMkDocuments[],
		/*[in,size_is(cDirectories)]*/ const VSQUERYADDDIRECTORYFLAGS rgFlags[],
		/*[out]*/ VSQUERYADDDIRECTORYRESULTS* pSummaryResult,
		/*[out,size_is(cDirectories)]*/ VSQUERYADDDIRECTORYRESULTS rgResults[])
	{
		VSL_DEFINE_MOCK_METHOD(OnQueryAddDirectories)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProject);

		VSL_CHECK_VALIDVALUE(cDirectories);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgpszMkDocuments, cDirectories*sizeof(rgpszMkDocuments[0]), validValues.cDirectories*sizeof(validValues.rgpszMkDocuments[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgFlags, cDirectories*sizeof(rgFlags[0]), validValues.cDirectories*sizeof(validValues.rgFlags[0]));

		VSL_SET_VALIDVALUE(pSummaryResult);

		VSL_SET_VALIDVALUE_MEMCPY(rgResults, cDirectories*sizeof(rgResults[0]), validValues.cDirectories*sizeof(validValues.rgResults[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct OnQueryRemoveFilesValidValues
	{
		/*[in]*/ IVsProject* pProject;
		/*[in]*/ int cFiles;
		/*[in,size_is(cFiles)]*/ LPCOLESTR* rgpszMkDocuments;
		/*[in,size_is(cFiles)]*/ VSQUERYREMOVEFILEFLAGS* rgFlags;
		/*[out]*/ VSQUERYREMOVEFILERESULTS* pSummaryResult;
		/*[out,size_is(cFiles)]*/ VSQUERYREMOVEFILERESULTS* rgResults;
		HRESULT retValue;
	};

	STDMETHOD(OnQueryRemoveFiles)(
		/*[in]*/ IVsProject* pProject,
		/*[in]*/ int cFiles,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR rgpszMkDocuments[],
		/*[in,size_is(cFiles)]*/ const VSQUERYREMOVEFILEFLAGS rgFlags[],
		/*[out]*/ VSQUERYREMOVEFILERESULTS* pSummaryResult,
		/*[out,size_is(cFiles)]*/ VSQUERYREMOVEFILERESULTS rgResults[])
	{
		VSL_DEFINE_MOCK_METHOD(OnQueryRemoveFiles)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProject);

		VSL_CHECK_VALIDVALUE(cFiles);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgpszMkDocuments, cFiles*sizeof(rgpszMkDocuments[0]), validValues.cFiles*sizeof(validValues.rgpszMkDocuments[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgFlags, cFiles*sizeof(rgFlags[0]), validValues.cFiles*sizeof(validValues.rgFlags[0]));

		VSL_SET_VALIDVALUE(pSummaryResult);

		VSL_SET_VALIDVALUE_MEMCPY(rgResults, cFiles*sizeof(rgResults[0]), validValues.cFiles*sizeof(validValues.rgResults[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct OnQueryRemoveDirectoriesValidValues
	{
		/*[in]*/ IVsProject* pProject;
		/*[in]*/ int cDirectories;
		/*[in,size_is(cDirectories)]*/ LPCOLESTR* rgpszMkDocuments;
		/*[in,size_is(cDirectories)]*/ VSQUERYREMOVEDIRECTORYFLAGS* rgFlags;
		/*[out]*/ VSQUERYREMOVEDIRECTORYRESULTS* pSummaryResult;
		/*[out,size_is(cDirectories)]*/ VSQUERYREMOVEDIRECTORYRESULTS* rgResults;
		HRESULT retValue;
	};

	STDMETHOD(OnQueryRemoveDirectories)(
		/*[in]*/ IVsProject* pProject,
		/*[in]*/ int cDirectories,
		/*[in,size_is(cDirectories)]*/ const LPCOLESTR rgpszMkDocuments[],
		/*[in,size_is(cDirectories)]*/ const VSQUERYREMOVEDIRECTORYFLAGS rgFlags[],
		/*[out]*/ VSQUERYREMOVEDIRECTORYRESULTS* pSummaryResult,
		/*[out,size_is(cDirectories)]*/ VSQUERYREMOVEDIRECTORYRESULTS rgResults[])
	{
		VSL_DEFINE_MOCK_METHOD(OnQueryRemoveDirectories)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProject);

		VSL_CHECK_VALIDVALUE(cDirectories);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgpszMkDocuments, cDirectories*sizeof(rgpszMkDocuments[0]), validValues.cDirectories*sizeof(validValues.rgpszMkDocuments[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgFlags, cDirectories*sizeof(rgFlags[0]), validValues.cDirectories*sizeof(validValues.rgFlags[0]));

		VSL_SET_VALIDVALUE(pSummaryResult);

		VSL_SET_VALIDVALUE_MEMCPY(rgResults, cDirectories*sizeof(rgResults[0]), validValues.cDirectories*sizeof(validValues.rgResults[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterSccStatusChangedValidValues
	{
		/*[in]*/ IVsProject* pProject;
		/*[in]*/ int cFiles;
		/*[in,size_is(cFiles)]*/ LPCOLESTR* rgpszMkDocuments;
		/*[in,size_is(cFiles)]*/ DWORD* rgdwSccStatus;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterSccStatusChanged)(
		/*[in]*/ IVsProject* pProject,
		/*[in]*/ int cFiles,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR rgpszMkDocuments[],
		/*[in,size_is(cFiles)]*/ const DWORD rgdwSccStatus[])
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterSccStatusChanged)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProject);

		VSL_CHECK_VALIDVALUE(cFiles);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgpszMkDocuments, cFiles*sizeof(rgpszMkDocuments[0]), validValues.cFiles*sizeof(validValues.rgpszMkDocuments[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgdwSccStatus, cFiles*sizeof(rgdwSccStatus[0]), validValues.cFiles*sizeof(validValues.rgdwSccStatus[0]));

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTRACKPROJECTDOCUMENTS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTypeLibraryWrapper.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTYPELIBRARYWRAPPER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTYPELIBRARYWRAPPER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "compsvcspkg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTypeLibraryWrapperNotImpl :
	public IVsTypeLibraryWrapper
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTypeLibraryWrapperNotImpl)

public:

	typedef IVsTypeLibraryWrapper Interface;

	STDMETHOD(WrapTypeLibrary)(
		/*[in]*/ TLIBATTR* /*pTypeLibToWrap*/,
		/*[in]*/ LPCOLESTR /*wszDestinationDirectory*/,
		/*[in]*/ LPCOLESTR /*wszKeyFile*/,
		/*[in]*/ LPCOLESTR /*wszKeyContainer*/,
		/*[in]*/ BOOL /*bDelaySign*/,
		/*[in]*/ IVsTypeLibraryWrapperCallback* /*pCallback*/,
		/*[out]*/ BSTR** /*rgbstrWrapperPaths*/,
		/*[out]*/ TLIBATTR** /*rgWrappedTypeLibs*/,
		/*[out]*/ BOOL** /*rgbGenerated*/,
		/*[out]*/ BSTR** /*rgbstrWrapperTools*/,
		/*[out]*/ ULONG* /*pcWrappedTypeLibs*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMainWrapperFilename)(
		/*[in]*/ TLIBATTR* /*pTypeLibToWrap*/,
		/*[out,retval]*/ BSTR* /*pbstrFileName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(NeedsRegeneration)(
		/*[in]*/ TLIBATTR* /*pTypeLibToWrap*/,
		/*[in]*/ LPCOLESTR /*wszKeyFile*/,
		/*[in]*/ LPCOLESTR /*wszKeyContainerName*/,
		/*[in]*/ BOOL /*bDelaySign*/,
		/*[in]*/ BOOL /*bCurrentlyDelaySigned*/,
		/*[in]*/ LPCOLESTR /*wszExistingWrapperFilename*/,
		/*[out,retval]*/ BOOL* /*pbNeedsRegeneration*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMainWrapperFriendlyName)(
		/*[in]*/ TLIBATTR* /*pTypeLibToWrap*/,
		/*[out,retval]*/ BSTR* /*pbstrFileName*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTypeLibraryWrapperMockImpl :
	public IVsTypeLibraryWrapper,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTypeLibraryWrapperMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTypeLibraryWrapperMockImpl)

	typedef IVsTypeLibraryWrapper Interface;
	struct WrapTypeLibraryValidValues
	{
		/*[in]*/ TLIBATTR* pTypeLibToWrap;
		/*[in]*/ LPCOLESTR wszDestinationDirectory;
		/*[in]*/ LPCOLESTR wszKeyFile;
		/*[in]*/ LPCOLESTR wszKeyContainer;
		/*[in]*/ BOOL bDelaySign;
		/*[in]*/ IVsTypeLibraryWrapperCallback* pCallback;
		/*[out]*/ BSTR** rgbstrWrapperPaths;
		/*[out]*/ TLIBATTR** rgWrappedTypeLibs;
		/*[out]*/ BOOL** rgbGenerated;
		/*[out]*/ BSTR** rgbstrWrapperTools;
		/*[out]*/ ULONG* pcWrappedTypeLibs;
		HRESULT retValue;
	};

	STDMETHOD(WrapTypeLibrary)(
		/*[in]*/ TLIBATTR* pTypeLibToWrap,
		/*[in]*/ LPCOLESTR wszDestinationDirectory,
		/*[in]*/ LPCOLESTR wszKeyFile,
		/*[in]*/ LPCOLESTR wszKeyContainer,
		/*[in]*/ BOOL bDelaySign,
		/*[in]*/ IVsTypeLibraryWrapperCallback* pCallback,
		/*[out]*/ BSTR** rgbstrWrapperPaths,
		/*[out]*/ TLIBATTR** rgWrappedTypeLibs,
		/*[out]*/ BOOL** rgbGenerated,
		/*[out]*/ BSTR** rgbstrWrapperTools,
		/*[out]*/ ULONG* pcWrappedTypeLibs)
	{
		VSL_DEFINE_MOCK_METHOD(WrapTypeLibrary)

		VSL_CHECK_VALIDVALUE_POINTER(pTypeLibToWrap);

		VSL_CHECK_VALIDVALUE_STRINGW(wszDestinationDirectory);

		VSL_CHECK_VALIDVALUE_STRINGW(wszKeyFile);

		VSL_CHECK_VALIDVALUE_STRINGW(wszKeyContainer);

		VSL_CHECK_VALIDVALUE(bDelaySign);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCallback);

		VSL_SET_VALIDVALUE(rgbstrWrapperPaths);

		VSL_SET_VALIDVALUE(rgWrappedTypeLibs);

		VSL_SET_VALIDVALUE(rgbGenerated);

		VSL_SET_VALIDVALUE(rgbstrWrapperTools);

		VSL_SET_VALIDVALUE(pcWrappedTypeLibs);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMainWrapperFilenameValidValues
	{
		/*[in]*/ TLIBATTR* pTypeLibToWrap;
		/*[out,retval]*/ BSTR* pbstrFileName;
		HRESULT retValue;
	};

	STDMETHOD(GetMainWrapperFilename)(
		/*[in]*/ TLIBATTR* pTypeLibToWrap,
		/*[out,retval]*/ BSTR* pbstrFileName)
	{
		VSL_DEFINE_MOCK_METHOD(GetMainWrapperFilename)

		VSL_CHECK_VALIDVALUE_POINTER(pTypeLibToWrap);

		VSL_SET_VALIDVALUE_BSTR(pbstrFileName);

		VSL_RETURN_VALIDVALUES();
	}
	struct NeedsRegenerationValidValues
	{
		/*[in]*/ TLIBATTR* pTypeLibToWrap;
		/*[in]*/ LPCOLESTR wszKeyFile;
		/*[in]*/ LPCOLESTR wszKeyContainerName;
		/*[in]*/ BOOL bDelaySign;
		/*[in]*/ BOOL bCurrentlyDelaySigned;
		/*[in]*/ LPCOLESTR wszExistingWrapperFilename;
		/*[out,retval]*/ BOOL* pbNeedsRegeneration;
		HRESULT retValue;
	};

	STDMETHOD(NeedsRegeneration)(
		/*[in]*/ TLIBATTR* pTypeLibToWrap,
		/*[in]*/ LPCOLESTR wszKeyFile,
		/*[in]*/ LPCOLESTR wszKeyContainerName,
		/*[in]*/ BOOL bDelaySign,
		/*[in]*/ BOOL bCurrentlyDelaySigned,
		/*[in]*/ LPCOLESTR wszExistingWrapperFilename,
		/*[out,retval]*/ BOOL* pbNeedsRegeneration)
	{
		VSL_DEFINE_MOCK_METHOD(NeedsRegeneration)

		VSL_CHECK_VALIDVALUE_POINTER(pTypeLibToWrap);

		VSL_CHECK_VALIDVALUE_STRINGW(wszKeyFile);

		VSL_CHECK_VALIDVALUE_STRINGW(wszKeyContainerName);

		VSL_CHECK_VALIDVALUE(bDelaySign);

		VSL_CHECK_VALIDVALUE(bCurrentlyDelaySigned);

		VSL_CHECK_VALIDVALUE_STRINGW(wszExistingWrapperFilename);

		VSL_SET_VALIDVALUE(pbNeedsRegeneration);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMainWrapperFriendlyNameValidValues
	{
		/*[in]*/ TLIBATTR* pTypeLibToWrap;
		/*[out,retval]*/ BSTR* pbstrFileName;
		HRESULT retValue;
	};

	STDMETHOD(GetMainWrapperFriendlyName)(
		/*[in]*/ TLIBATTR* pTypeLibToWrap,
		/*[out,retval]*/ BSTR* pbstrFileName)
	{
		VSL_DEFINE_MOCK_METHOD(GetMainWrapperFriendlyName)

		VSL_CHECK_VALIDVALUE_POINTER(pTypeLibToWrap);

		VSL_SET_VALIDVALUE_BSTR(pbstrFileName);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTYPELIBRARYWRAPPER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTshell.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTSHELL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTSHELL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTshellNotImpl :
	public IVsTshell
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTshellNotImpl)

public:

	typedef IVsTshell Interface;

	STDMETHOD(DebOutputStringW)(
		/*[in]*/ LPCOLESTR /*pwsz*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DebOutputStringA)(
		/*[in]*/ LPSTR /*psz*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddCmdTable)(
		/*[in]*/ UINT /*cCmd*/,
		/*[in,size_is(cCmd)]*/ const TSHELL_CMD[] /*rgpCmd*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetValue)(
		/*[in]*/ LPSTR /*pszKey*/,
		/*[out]*/ UINT* /*piVal*/,
		/*[out]*/ LPSTR* /*ppszVal*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetValue)(
		/*[in]*/ LPSTR /*pszKey*/,
		/*[in]*/ UINT /*iVal*/,
		/*[in]*/ LPSTR /*pszVal*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(DeleteValue)(
		/*[in]*/ LPSTR /*pszKey*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsExecutingScript)(
		/*[out]*/ BOOL* /*pfRunScript*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ExecuteTestCommand)(
		/*[in]*/ LPSTR /*szCommandLine*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetVSLoggingInterface)(
		/*[in]*/ IVsTestLog* /*pVsTestLog*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTestData)(
		/*[in]*/ VSTDTYPE /*dwType*/,
		/*[in,out]*/ GUID* /*pguidData*/,
		/*[in,out]*/ DWORD* /*pdwData*/,
		/*[in,out]*/ void** /*ppvData*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetBreakTransitionComplete)(
		/*[in]*/ BOOL /*bTransitionComplete*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTshellMockImpl :
	public IVsTshell,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTshellMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTshellMockImpl)

	typedef IVsTshell Interface;
	struct DebOutputStringWValidValues
	{
		/*[in]*/ LPCOLESTR pwsz;
		HRESULT retValue;
	};

	STDMETHOD(DebOutputStringW)(
		/*[in]*/ LPCOLESTR pwsz)
	{
		VSL_DEFINE_MOCK_METHOD(DebOutputStringW)

		VSL_CHECK_VALIDVALUE_STRINGW(pwsz);

		VSL_RETURN_VALIDVALUES();
	}
	struct DebOutputStringAValidValues
	{
		/*[in]*/ LPSTR psz;
		HRESULT retValue;
	};

	STDMETHOD(DebOutputStringA)(
		/*[in]*/ LPSTR psz)
	{
		VSL_DEFINE_MOCK_METHOD(DebOutputStringA)

		VSL_CHECK_VALIDVALUE_STRINGA(psz);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddCmdTableValidValues
	{
		/*[in]*/ UINT cCmd;
		/*[in,size_is(cCmd)]*/ TSHELL_CMD* rgpCmd;
		HRESULT retValue;
	};

	STDMETHOD(AddCmdTable)(
		/*[in]*/ UINT cCmd,
		/*[in,size_is(cCmd)]*/ const TSHELL_CMD rgpCmd[])
	{
		VSL_DEFINE_MOCK_METHOD(AddCmdTable)

		VSL_CHECK_VALIDVALUE(cCmd);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgpCmd, cCmd*sizeof(rgpCmd[0]), validValues.cCmd*sizeof(validValues.rgpCmd[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct GetValueValidValues
	{
		/*[in]*/ LPSTR pszKey;
		/*[out]*/ UINT* piVal;
		/*[out]*/ LPSTR* ppszVal;
		HRESULT retValue;
	};

	STDMETHOD(GetValue)(
		/*[in]*/ LPSTR pszKey,
		/*[out]*/ UINT* piVal,
		/*[out]*/ LPSTR* ppszVal)
	{
		VSL_DEFINE_MOCK_METHOD(GetValue)

		VSL_CHECK_VALIDVALUE_STRINGA(pszKey);

		VSL_SET_VALIDVALUE(piVal);

		VSL_SET_VALIDVALUE(ppszVal);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetValueValidValues
	{
		/*[in]*/ LPSTR pszKey;
		/*[in]*/ UINT iVal;
		/*[in]*/ LPSTR pszVal;
		HRESULT retValue;
	};

	STDMETHOD(SetValue)(
		/*[in]*/ LPSTR pszKey,
		/*[in]*/ UINT iVal,
		/*[in]*/ LPSTR pszVal)
	{
		VSL_DEFINE_MOCK_METHOD(SetValue)

		VSL_CHECK_VALIDVALUE_STRINGA(pszKey);

		VSL_CHECK_VALIDVALUE(iVal);

		VSL_CHECK_VALIDVALUE_STRINGA(pszVal);

		VSL_RETURN_VALIDVALUES();
	}
	struct DeleteValueValidValues
	{
		/*[in]*/ LPSTR pszKey;
		HRESULT retValue;
	};

	STDMETHOD(DeleteValue)(
		/*[in]*/ LPSTR pszKey)
	{
		VSL_DEFINE_MOCK_METHOD(DeleteValue)

		VSL_CHECK_VALIDVALUE_STRINGA(pszKey);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsExecutingScriptValidValues
	{
		/*[out]*/ BOOL* pfRunScript;
		HRESULT retValue;
	};

	STDMETHOD(IsExecutingScript)(
		/*[out]*/ BOOL* pfRunScript)
	{
		VSL_DEFINE_MOCK_METHOD(IsExecutingScript)

		VSL_SET_VALIDVALUE(pfRunScript);

		VSL_RETURN_VALIDVALUES();
	}
	struct ExecuteTestCommandValidValues
	{
		/*[in]*/ LPSTR szCommandLine;
		HRESULT retValue;
	};

	STDMETHOD(ExecuteTestCommand)(
		/*[in]*/ LPSTR szCommandLine)
	{
		VSL_DEFINE_MOCK_METHOD(ExecuteTestCommand)

		VSL_CHECK_VALIDVALUE_STRINGA(szCommandLine);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetVSLoggingInterfaceValidValues
	{
		/*[in]*/ IVsTestLog* pVsTestLog;
		HRESULT retValue;
	};

	STDMETHOD(SetVSLoggingInterface)(
		/*[in]*/ IVsTestLog* pVsTestLog)
	{
		VSL_DEFINE_MOCK_METHOD(SetVSLoggingInterface)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pVsTestLog);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTestDataValidValues
	{
		/*[in]*/ VSTDTYPE dwType;
		/*[in,out]*/ GUID* pguidData;
		/*[in,out]*/ DWORD* pdwData;
		/*[in,out]*/ void** ppvData;
		HRESULT retValue;
	};

	STDMETHOD(GetTestData)(
		/*[in]*/ VSTDTYPE dwType,
		/*[in,out]*/ GUID* pguidData,
		/*[in,out]*/ DWORD* pdwData,
		/*[in,out]*/ void** ppvData)
	{
		VSL_DEFINE_MOCK_METHOD(GetTestData)

		VSL_CHECK_VALIDVALUE(dwType);

		VSL_SET_VALIDVALUE(pguidData);

		VSL_SET_VALIDVALUE(pdwData);

		VSL_SET_VALIDVALUE(ppvData);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetBreakTransitionCompleteValidValues
	{
		/*[in]*/ BOOL bTransitionComplete;
		HRESULT retValue;
	};

	STDMETHOD(SetBreakTransitionComplete)(
		/*[in]*/ BOOL bTransitionComplete)
	{
		VSL_DEFINE_MOCK_METHOD(SetBreakTransitionComplete)

		VSL_CHECK_VALIDVALUE(bTransitionComplete);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTSHELL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTrackProjectDocumentsEvents2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTRACKPROJECTDOCUMENTSEVENTS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTRACKPROJECTDOCUMENTSEVENTS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "IVsTrackProjectDocumentsEvents2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTrackProjectDocumentsEvents2NotImpl :
	public IVsTrackProjectDocumentsEvents2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTrackProjectDocumentsEvents2NotImpl)

public:

	typedef IVsTrackProjectDocumentsEvents2 Interface;

	STDMETHOD(OnQueryAddFiles)(
		/*[in]*/ IVsProject* /*pProject*/,
		/*[in]*/ int /*cFiles*/,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR[] /*rgpszMkDocuments*/,
		/*[in,size_is(cFiles)]*/ const VSQUERYADDFILEFLAGS[] /*rgFlags*/,
		/*[out]*/ VSQUERYADDFILERESULTS* /*pSummaryResult*/,
		/*[out,size_is(cFiles)]*/ VSQUERYADDFILERESULTS[] /*rgResults*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterAddFilesEx)(
		/*[in]*/ int /*cProjects*/,
		/*[in]*/ int /*cFiles*/,
		/*[in,size_is(cProjects)]*/ IVsProject*[] /*rgpProjects*/,
		/*[in,size_is(cProjects)]*/ const int[] /*rgFirstIndices*/,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR[] /*rgpszMkDocuments*/,
		/*[in,size_is(cFiles)]*/ const VSADDFILEFLAGS[] /*rgFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterAddDirectoriesEx)(
		/*[in]*/ int /*cProjects*/,
		/*[in]*/ int /*cDirectories*/,
		/*[in,size_is(cProjects)]*/ IVsProject*[] /*rgpProjects*/,
		/*[in,size_is(cProjects)]*/ const int[] /*rgFirstIndices*/,
		/*[in,size_is(cDirectories)]*/ const LPCOLESTR[] /*rgpszMkDocuments*/,
		/*[in,size_is(cDirectories)]*/ const VSADDDIRECTORYFLAGS[] /*rgFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterRemoveFiles)(
		/*[in]*/ int /*cProjects*/,
		/*[in]*/ int /*cFiles*/,
		/*[in,size_is(cProjects)]*/ IVsProject*[] /*rgpProjects*/,
		/*[in,size_is(cProjects)]*/ const int[] /*rgFirstIndices*/,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR[] /*rgpszMkDocuments*/,
		/*[in,size_is(cFiles)]*/ const VSREMOVEFILEFLAGS[] /*rgFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterRemoveDirectories)(
		/*[in]*/ int /*cProjects*/,
		/*[in]*/ int /*cDirectories*/,
		/*[in,size_is(cProjects)]*/ IVsProject*[] /*rgpProjects*/,
		/*[in,size_is(cProjects)]*/ const int[] /*rgFirstIndices*/,
		/*[in,size_is(cDirectories)]*/ const LPCOLESTR[] /*rgpszMkDocuments*/,
		/*[in,size_is(cDirectories)]*/ const VSREMOVEDIRECTORYFLAGS[] /*rgFlags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnQueryRenameFiles)(
		/*[in]*/ IVsProject* /*pProject*/,
		/*[in]*/ int /*cFiles*/,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR[] /*rgszMkOldNames*/,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR[] /*rgszMkNewNames*/,
		/*[in,size_is(cFiles)]*/ const VSQUERYRENAMEFILEFLAGS[] /*rgflags*/,
		/*[out]*/ VSQUERYRENAMEFILERESULTS* /*pSummaryResult*/,
		/*[out,size_is(cFiles)]*/ VSQUERYRENAMEFILERESULTS[] /*rgResults*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterRenameFiles)(
		/*[in]*/ int /*cProjects*/,
		/*[in]*/ int /*cFiles*/,
		/*[in,size_is(cProjects)]*/ IVsProject*[] /*rgpProjects*/,
		/*[in,size_is(cProjects)]*/ const int[] /*rgFirstIndices*/,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR[] /*rgszMkOldNames*/,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR[] /*rgszMkNewNames*/,
		/*[in,size_is(cFiles)]*/ const VSRENAMEFILEFLAGS[] /*rgflags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnQueryRenameDirectories)(
		/*[in]*/ IVsProject* /*pProject*/,
		/*[in]*/ int /*cDirs*/,
		/*[in,size_is(cDirs)]*/ const LPCOLESTR[] /*rgszMkOldNames*/,
		/*[in,size_is(cDirs)]*/ const LPCOLESTR[] /*rgszMkNewNames*/,
		/*[in,size_is(cDirs)]*/ const VSQUERYRENAMEDIRECTORYFLAGS[] /*rgflags*/,
		/*[out]*/ VSQUERYRENAMEDIRECTORYRESULTS* /*pSummaryResult*/,
		/*[out,size_is(cDirs)]*/ VSQUERYRENAMEDIRECTORYRESULTS[] /*rgResults*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterRenameDirectories)(
		/*[in]*/ int /*cProjects*/,
		/*[in]*/ int /*cDirs*/,
		/*[in,size_is(cProjects)]*/ IVsProject*[] /*rgpProjects*/,
		/*[in,size_is(cProjects)]*/ const int[] /*rgFirstIndices*/,
		/*[in,size_is(cDirs)]*/ const LPCOLESTR[] /*rgszMkOldNames*/,
		/*[in,size_is(cDirs)]*/ const LPCOLESTR[] /*rgszMkNewNames*/,
		/*[in,size_is(cDirs)]*/ const VSRENAMEDIRECTORYFLAGS[] /*rgflags*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnQueryAddDirectories)(
		/*[in]*/ IVsProject* /*pProject*/,
		/*[in]*/ int /*cDirectories*/,
		/*[in,size_is(cDirectories)]*/ const LPCOLESTR[] /*rgpszMkDocuments*/,
		/*[in,size_is(cDirectories)]*/ const VSQUERYADDDIRECTORYFLAGS[] /*rgFlags*/,
		/*[out]*/ VSQUERYADDDIRECTORYRESULTS* /*pSummaryResult*/,
		/*[out,size_is(cDirectories)]*/ VSQUERYADDDIRECTORYRESULTS[] /*rgResults*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnQueryRemoveFiles)(
		/*[in]*/ IVsProject* /*pProject*/,
		/*[in]*/ int /*cFiles*/,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR[] /*rgpszMkDocuments*/,
		/*[in,size_is(cFiles)]*/ const VSQUERYREMOVEFILEFLAGS[] /*rgFlags*/,
		/*[out]*/ VSQUERYREMOVEFILERESULTS* /*pSummaryResult*/,
		/*[out,size_is(cFiles)]*/ VSQUERYREMOVEFILERESULTS[] /*rgResults*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnQueryRemoveDirectories)(
		/*[in]*/ IVsProject* /*pProject*/,
		/*[in]*/ int /*cDirectories*/,
		/*[in,size_is(cDirectories)]*/ const LPCOLESTR[] /*rgpszMkDocuments*/,
		/*[in,size_is(cDirectories)]*/ const VSQUERYREMOVEDIRECTORYFLAGS[] /*rgFlags*/,
		/*[out]*/ VSQUERYREMOVEDIRECTORYRESULTS* /*pSummaryResult*/,
		/*[out,size_is(cDirectories)]*/ VSQUERYREMOVEDIRECTORYRESULTS[] /*rgResults*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterSccStatusChanged)(
		/*[in]*/ int /*cProjects*/,
		/*[in]*/ int /*cFiles*/,
		/*[in,size_is(cProjects)]*/ IVsProject*[] /*rgpProjects*/,
		/*[in,size_is(cProjects)]*/ const int[] /*rgFirstIndices*/,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR[] /*rgpszMkDocuments*/,
		/*[in,size_is(cFiles)]*/ const DWORD[] /*rgdwSccStatus*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTrackProjectDocumentsEvents2MockImpl :
	public IVsTrackProjectDocumentsEvents2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTrackProjectDocumentsEvents2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTrackProjectDocumentsEvents2MockImpl)

	typedef IVsTrackProjectDocumentsEvents2 Interface;
	struct OnQueryAddFilesValidValues
	{
		/*[in]*/ IVsProject* pProject;
		/*[in]*/ int cFiles;
		/*[in,size_is(cFiles)]*/ LPCOLESTR* rgpszMkDocuments;
		/*[in,size_is(cFiles)]*/ VSQUERYADDFILEFLAGS* rgFlags;
		/*[out]*/ VSQUERYADDFILERESULTS* pSummaryResult;
		/*[out,size_is(cFiles)]*/ VSQUERYADDFILERESULTS* rgResults;
		HRESULT retValue;
	};

	STDMETHOD(OnQueryAddFiles)(
		/*[in]*/ IVsProject* pProject,
		/*[in]*/ int cFiles,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR rgpszMkDocuments[],
		/*[in,size_is(cFiles)]*/ const VSQUERYADDFILEFLAGS rgFlags[],
		/*[out]*/ VSQUERYADDFILERESULTS* pSummaryResult,
		/*[out,size_is(cFiles)]*/ VSQUERYADDFILERESULTS rgResults[])
	{
		VSL_DEFINE_MOCK_METHOD(OnQueryAddFiles)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProject);

		VSL_CHECK_VALIDVALUE(cFiles);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgpszMkDocuments, cFiles*sizeof(rgpszMkDocuments[0]), validValues.cFiles*sizeof(validValues.rgpszMkDocuments[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgFlags, cFiles*sizeof(rgFlags[0]), validValues.cFiles*sizeof(validValues.rgFlags[0]));

		VSL_SET_VALIDVALUE(pSummaryResult);

		VSL_SET_VALIDVALUE_MEMCPY(rgResults, cFiles*sizeof(rgResults[0]), validValues.cFiles*sizeof(validValues.rgResults[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterAddFilesExValidValues
	{
		/*[in]*/ int cProjects;
		/*[in]*/ int cFiles;
		/*[in,size_is(cProjects)]*/ IVsProject** rgpProjects;
		/*[in,size_is(cProjects)]*/ int* rgFirstIndices;
		/*[in,size_is(cFiles)]*/ LPCOLESTR* rgpszMkDocuments;
		/*[in,size_is(cFiles)]*/ VSADDFILEFLAGS* rgFlags;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterAddFilesEx)(
		/*[in]*/ int cProjects,
		/*[in]*/ int cFiles,
		/*[in,size_is(cProjects)]*/ IVsProject* rgpProjects[],
		/*[in,size_is(cProjects)]*/ const int rgFirstIndices[],
		/*[in,size_is(cFiles)]*/ const LPCOLESTR rgpszMkDocuments[],
		/*[in,size_is(cFiles)]*/ const VSADDFILEFLAGS rgFlags[])
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterAddFilesEx)

		VSL_CHECK_VALIDVALUE(cProjects);

		VSL_CHECK_VALIDVALUE(cFiles);

		VSL_CHECK_VALIDVALUE_ARRAY(rgpProjects, cProjects, validValues.cProjects);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgFirstIndices, cProjects*sizeof(rgFirstIndices[0]), validValues.cProjects*sizeof(validValues.rgFirstIndices[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgpszMkDocuments, cFiles*sizeof(rgpszMkDocuments[0]), validValues.cFiles*sizeof(validValues.rgpszMkDocuments[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgFlags, cFiles*sizeof(rgFlags[0]), validValues.cFiles*sizeof(validValues.rgFlags[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterAddDirectoriesExValidValues
	{
		/*[in]*/ int cProjects;
		/*[in]*/ int cDirectories;
		/*[in,size_is(cProjects)]*/ IVsProject** rgpProjects;
		/*[in,size_is(cProjects)]*/ int* rgFirstIndices;
		/*[in,size_is(cDirectories)]*/ LPCOLESTR* rgpszMkDocuments;
		/*[in,size_is(cDirectories)]*/ VSADDDIRECTORYFLAGS* rgFlags;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterAddDirectoriesEx)(
		/*[in]*/ int cProjects,
		/*[in]*/ int cDirectories,
		/*[in,size_is(cProjects)]*/ IVsProject* rgpProjects[],
		/*[in,size_is(cProjects)]*/ const int rgFirstIndices[],
		/*[in,size_is(cDirectories)]*/ const LPCOLESTR rgpszMkDocuments[],
		/*[in,size_is(cDirectories)]*/ const VSADDDIRECTORYFLAGS rgFlags[])
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterAddDirectoriesEx)

		VSL_CHECK_VALIDVALUE(cProjects);

		VSL_CHECK_VALIDVALUE(cDirectories);

		VSL_CHECK_VALIDVALUE_ARRAY(rgpProjects, cProjects, validValues.cProjects);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgFirstIndices, cProjects*sizeof(rgFirstIndices[0]), validValues.cProjects*sizeof(validValues.rgFirstIndices[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgpszMkDocuments, cDirectories*sizeof(rgpszMkDocuments[0]), validValues.cDirectories*sizeof(validValues.rgpszMkDocuments[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgFlags, cDirectories*sizeof(rgFlags[0]), validValues.cDirectories*sizeof(validValues.rgFlags[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterRemoveFilesValidValues
	{
		/*[in]*/ int cProjects;
		/*[in]*/ int cFiles;
		/*[in,size_is(cProjects)]*/ IVsProject** rgpProjects;
		/*[in,size_is(cProjects)]*/ int* rgFirstIndices;
		/*[in,size_is(cFiles)]*/ LPCOLESTR* rgpszMkDocuments;
		/*[in,size_is(cFiles)]*/ VSREMOVEFILEFLAGS* rgFlags;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterRemoveFiles)(
		/*[in]*/ int cProjects,
		/*[in]*/ int cFiles,
		/*[in,size_is(cProjects)]*/ IVsProject* rgpProjects[],
		/*[in,size_is(cProjects)]*/ const int rgFirstIndices[],
		/*[in,size_is(cFiles)]*/ const LPCOLESTR rgpszMkDocuments[],
		/*[in,size_is(cFiles)]*/ const VSREMOVEFILEFLAGS rgFlags[])
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterRemoveFiles)

		VSL_CHECK_VALIDVALUE(cProjects);

		VSL_CHECK_VALIDVALUE(cFiles);

		VSL_CHECK_VALIDVALUE_ARRAY(rgpProjects, cProjects, validValues.cProjects);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgFirstIndices, cProjects*sizeof(rgFirstIndices[0]), validValues.cProjects*sizeof(validValues.rgFirstIndices[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgpszMkDocuments, cFiles*sizeof(rgpszMkDocuments[0]), validValues.cFiles*sizeof(validValues.rgpszMkDocuments[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgFlags, cFiles*sizeof(rgFlags[0]), validValues.cFiles*sizeof(validValues.rgFlags[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterRemoveDirectoriesValidValues
	{
		/*[in]*/ int cProjects;
		/*[in]*/ int cDirectories;
		/*[in,size_is(cProjects)]*/ IVsProject** rgpProjects;
		/*[in,size_is(cProjects)]*/ int* rgFirstIndices;
		/*[in,size_is(cDirectories)]*/ LPCOLESTR* rgpszMkDocuments;
		/*[in,size_is(cDirectories)]*/ VSREMOVEDIRECTORYFLAGS* rgFlags;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterRemoveDirectories)(
		/*[in]*/ int cProjects,
		/*[in]*/ int cDirectories,
		/*[in,size_is(cProjects)]*/ IVsProject* rgpProjects[],
		/*[in,size_is(cProjects)]*/ const int rgFirstIndices[],
		/*[in,size_is(cDirectories)]*/ const LPCOLESTR rgpszMkDocuments[],
		/*[in,size_is(cDirectories)]*/ const VSREMOVEDIRECTORYFLAGS rgFlags[])
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterRemoveDirectories)

		VSL_CHECK_VALIDVALUE(cProjects);

		VSL_CHECK_VALIDVALUE(cDirectories);

		VSL_CHECK_VALIDVALUE_ARRAY(rgpProjects, cProjects, validValues.cProjects);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgFirstIndices, cProjects*sizeof(rgFirstIndices[0]), validValues.cProjects*sizeof(validValues.rgFirstIndices[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgpszMkDocuments, cDirectories*sizeof(rgpszMkDocuments[0]), validValues.cDirectories*sizeof(validValues.rgpszMkDocuments[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgFlags, cDirectories*sizeof(rgFlags[0]), validValues.cDirectories*sizeof(validValues.rgFlags[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct OnQueryRenameFilesValidValues
	{
		/*[in]*/ IVsProject* pProject;
		/*[in]*/ int cFiles;
		/*[in,size_is(cFiles)]*/ LPCOLESTR* rgszMkOldNames;
		/*[in,size_is(cFiles)]*/ LPCOLESTR* rgszMkNewNames;
		/*[in,size_is(cFiles)]*/ VSQUERYRENAMEFILEFLAGS* rgflags;
		/*[out]*/ VSQUERYRENAMEFILERESULTS* pSummaryResult;
		/*[out,size_is(cFiles)]*/ VSQUERYRENAMEFILERESULTS* rgResults;
		HRESULT retValue;
	};

	STDMETHOD(OnQueryRenameFiles)(
		/*[in]*/ IVsProject* pProject,
		/*[in]*/ int cFiles,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR rgszMkOldNames[],
		/*[in,size_is(cFiles)]*/ const LPCOLESTR rgszMkNewNames[],
		/*[in,size_is(cFiles)]*/ const VSQUERYRENAMEFILEFLAGS rgflags[],
		/*[out]*/ VSQUERYRENAMEFILERESULTS* pSummaryResult,
		/*[out,size_is(cFiles)]*/ VSQUERYRENAMEFILERESULTS rgResults[])
	{
		VSL_DEFINE_MOCK_METHOD(OnQueryRenameFiles)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProject);

		VSL_CHECK_VALIDVALUE(cFiles);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszMkOldNames, cFiles*sizeof(rgszMkOldNames[0]), validValues.cFiles*sizeof(validValues.rgszMkOldNames[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszMkNewNames, cFiles*sizeof(rgszMkNewNames[0]), validValues.cFiles*sizeof(validValues.rgszMkNewNames[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgflags, cFiles*sizeof(rgflags[0]), validValues.cFiles*sizeof(validValues.rgflags[0]));

		VSL_SET_VALIDVALUE(pSummaryResult);

		VSL_SET_VALIDVALUE_MEMCPY(rgResults, cFiles*sizeof(rgResults[0]), validValues.cFiles*sizeof(validValues.rgResults[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterRenameFilesValidValues
	{
		/*[in]*/ int cProjects;
		/*[in]*/ int cFiles;
		/*[in,size_is(cProjects)]*/ IVsProject** rgpProjects;
		/*[in,size_is(cProjects)]*/ int* rgFirstIndices;
		/*[in,size_is(cFiles)]*/ LPCOLESTR* rgszMkOldNames;
		/*[in,size_is(cFiles)]*/ LPCOLESTR* rgszMkNewNames;
		/*[in,size_is(cFiles)]*/ VSRENAMEFILEFLAGS* rgflags;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterRenameFiles)(
		/*[in]*/ int cProjects,
		/*[in]*/ int cFiles,
		/*[in,size_is(cProjects)]*/ IVsProject* rgpProjects[],
		/*[in,size_is(cProjects)]*/ const int rgFirstIndices[],
		/*[in,size_is(cFiles)]*/ const LPCOLESTR rgszMkOldNames[],
		/*[in,size_is(cFiles)]*/ const LPCOLESTR rgszMkNewNames[],
		/*[in,size_is(cFiles)]*/ const VSRENAMEFILEFLAGS rgflags[])
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterRenameFiles)

		VSL_CHECK_VALIDVALUE(cProjects);

		VSL_CHECK_VALIDVALUE(cFiles);

		VSL_CHECK_VALIDVALUE_ARRAY(rgpProjects, cProjects, validValues.cProjects);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgFirstIndices, cProjects*sizeof(rgFirstIndices[0]), validValues.cProjects*sizeof(validValues.rgFirstIndices[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszMkOldNames, cFiles*sizeof(rgszMkOldNames[0]), validValues.cFiles*sizeof(validValues.rgszMkOldNames[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszMkNewNames, cFiles*sizeof(rgszMkNewNames[0]), validValues.cFiles*sizeof(validValues.rgszMkNewNames[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgflags, cFiles*sizeof(rgflags[0]), validValues.cFiles*sizeof(validValues.rgflags[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct OnQueryRenameDirectoriesValidValues
	{
		/*[in]*/ IVsProject* pProject;
		/*[in]*/ int cDirs;
		/*[in,size_is(cDirs)]*/ LPCOLESTR* rgszMkOldNames;
		/*[in,size_is(cDirs)]*/ LPCOLESTR* rgszMkNewNames;
		/*[in,size_is(cDirs)]*/ VSQUERYRENAMEDIRECTORYFLAGS* rgflags;
		/*[out]*/ VSQUERYRENAMEDIRECTORYRESULTS* pSummaryResult;
		/*[out,size_is(cDirs)]*/ VSQUERYRENAMEDIRECTORYRESULTS* rgResults;
		HRESULT retValue;
	};

	STDMETHOD(OnQueryRenameDirectories)(
		/*[in]*/ IVsProject* pProject,
		/*[in]*/ int cDirs,
		/*[in,size_is(cDirs)]*/ const LPCOLESTR rgszMkOldNames[],
		/*[in,size_is(cDirs)]*/ const LPCOLESTR rgszMkNewNames[],
		/*[in,size_is(cDirs)]*/ const VSQUERYRENAMEDIRECTORYFLAGS rgflags[],
		/*[out]*/ VSQUERYRENAMEDIRECTORYRESULTS* pSummaryResult,
		/*[out,size_is(cDirs)]*/ VSQUERYRENAMEDIRECTORYRESULTS rgResults[])
	{
		VSL_DEFINE_MOCK_METHOD(OnQueryRenameDirectories)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProject);

		VSL_CHECK_VALIDVALUE(cDirs);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszMkOldNames, cDirs*sizeof(rgszMkOldNames[0]), validValues.cDirs*sizeof(validValues.rgszMkOldNames[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszMkNewNames, cDirs*sizeof(rgszMkNewNames[0]), validValues.cDirs*sizeof(validValues.rgszMkNewNames[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgflags, cDirs*sizeof(rgflags[0]), validValues.cDirs*sizeof(validValues.rgflags[0]));

		VSL_SET_VALIDVALUE(pSummaryResult);

		VSL_SET_VALIDVALUE_MEMCPY(rgResults, cDirs*sizeof(rgResults[0]), validValues.cDirs*sizeof(validValues.rgResults[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterRenameDirectoriesValidValues
	{
		/*[in]*/ int cProjects;
		/*[in]*/ int cDirs;
		/*[in,size_is(cProjects)]*/ IVsProject** rgpProjects;
		/*[in,size_is(cProjects)]*/ int* rgFirstIndices;
		/*[in,size_is(cDirs)]*/ LPCOLESTR* rgszMkOldNames;
		/*[in,size_is(cDirs)]*/ LPCOLESTR* rgszMkNewNames;
		/*[in,size_is(cDirs)]*/ VSRENAMEDIRECTORYFLAGS* rgflags;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterRenameDirectories)(
		/*[in]*/ int cProjects,
		/*[in]*/ int cDirs,
		/*[in,size_is(cProjects)]*/ IVsProject* rgpProjects[],
		/*[in,size_is(cProjects)]*/ const int rgFirstIndices[],
		/*[in,size_is(cDirs)]*/ const LPCOLESTR rgszMkOldNames[],
		/*[in,size_is(cDirs)]*/ const LPCOLESTR rgszMkNewNames[],
		/*[in,size_is(cDirs)]*/ const VSRENAMEDIRECTORYFLAGS rgflags[])
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterRenameDirectories)

		VSL_CHECK_VALIDVALUE(cProjects);

		VSL_CHECK_VALIDVALUE(cDirs);

		VSL_CHECK_VALIDVALUE_ARRAY(rgpProjects, cProjects, validValues.cProjects);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgFirstIndices, cProjects*sizeof(rgFirstIndices[0]), validValues.cProjects*sizeof(validValues.rgFirstIndices[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszMkOldNames, cDirs*sizeof(rgszMkOldNames[0]), validValues.cDirs*sizeof(validValues.rgszMkOldNames[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszMkNewNames, cDirs*sizeof(rgszMkNewNames[0]), validValues.cDirs*sizeof(validValues.rgszMkNewNames[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgflags, cDirs*sizeof(rgflags[0]), validValues.cDirs*sizeof(validValues.rgflags[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct OnQueryAddDirectoriesValidValues
	{
		/*[in]*/ IVsProject* pProject;
		/*[in]*/ int cDirectories;
		/*[in,size_is(cDirectories)]*/ LPCOLESTR* rgpszMkDocuments;
		/*[in,size_is(cDirectories)]*/ VSQUERYADDDIRECTORYFLAGS* rgFlags;
		/*[out]*/ VSQUERYADDDIRECTORYRESULTS* pSummaryResult;
		/*[out,size_is(cDirectories)]*/ VSQUERYADDDIRECTORYRESULTS* rgResults;
		HRESULT retValue;
	};

	STDMETHOD(OnQueryAddDirectories)(
		/*[in]*/ IVsProject* pProject,
		/*[in]*/ int cDirectories,
		/*[in,size_is(cDirectories)]*/ const LPCOLESTR rgpszMkDocuments[],
		/*[in,size_is(cDirectories)]*/ const VSQUERYADDDIRECTORYFLAGS rgFlags[],
		/*[out]*/ VSQUERYADDDIRECTORYRESULTS* pSummaryResult,
		/*[out,size_is(cDirectories)]*/ VSQUERYADDDIRECTORYRESULTS rgResults[])
	{
		VSL_DEFINE_MOCK_METHOD(OnQueryAddDirectories)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProject);

		VSL_CHECK_VALIDVALUE(cDirectories);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgpszMkDocuments, cDirectories*sizeof(rgpszMkDocuments[0]), validValues.cDirectories*sizeof(validValues.rgpszMkDocuments[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgFlags, cDirectories*sizeof(rgFlags[0]), validValues.cDirectories*sizeof(validValues.rgFlags[0]));

		VSL_SET_VALIDVALUE(pSummaryResult);

		VSL_SET_VALIDVALUE_MEMCPY(rgResults, cDirectories*sizeof(rgResults[0]), validValues.cDirectories*sizeof(validValues.rgResults[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct OnQueryRemoveFilesValidValues
	{
		/*[in]*/ IVsProject* pProject;
		/*[in]*/ int cFiles;
		/*[in,size_is(cFiles)]*/ LPCOLESTR* rgpszMkDocuments;
		/*[in,size_is(cFiles)]*/ VSQUERYREMOVEFILEFLAGS* rgFlags;
		/*[out]*/ VSQUERYREMOVEFILERESULTS* pSummaryResult;
		/*[out,size_is(cFiles)]*/ VSQUERYREMOVEFILERESULTS* rgResults;
		HRESULT retValue;
	};

	STDMETHOD(OnQueryRemoveFiles)(
		/*[in]*/ IVsProject* pProject,
		/*[in]*/ int cFiles,
		/*[in,size_is(cFiles)]*/ const LPCOLESTR rgpszMkDocuments[],
		/*[in,size_is(cFiles)]*/ const VSQUERYREMOVEFILEFLAGS rgFlags[],
		/*[out]*/ VSQUERYREMOVEFILERESULTS* pSummaryResult,
		/*[out,size_is(cFiles)]*/ VSQUERYREMOVEFILERESULTS rgResults[])
	{
		VSL_DEFINE_MOCK_METHOD(OnQueryRemoveFiles)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProject);

		VSL_CHECK_VALIDVALUE(cFiles);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgpszMkDocuments, cFiles*sizeof(rgpszMkDocuments[0]), validValues.cFiles*sizeof(validValues.rgpszMkDocuments[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgFlags, cFiles*sizeof(rgFlags[0]), validValues.cFiles*sizeof(validValues.rgFlags[0]));

		VSL_SET_VALIDVALUE(pSummaryResult);

		VSL_SET_VALIDVALUE_MEMCPY(rgResults, cFiles*sizeof(rgResults[0]), validValues.cFiles*sizeof(validValues.rgResults[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct OnQueryRemoveDirectoriesValidValues
	{
		/*[in]*/ IVsProject* pProject;
		/*[in]*/ int cDirectories;
		/*[in,size_is(cDirectories)]*/ LPCOLESTR* rgpszMkDocuments;
		/*[in,size_is(cDirectories)]*/ VSQUERYREMOVEDIRECTORYFLAGS* rgFlags;
		/*[out]*/ VSQUERYREMOVEDIRECTORYRESULTS* pSummaryResult;
		/*[out,size_is(cDirectories)]*/ VSQUERYREMOVEDIRECTORYRESULTS* rgResults;
		HRESULT retValue;
	};

	STDMETHOD(OnQueryRemoveDirectories)(
		/*[in]*/ IVsProject* pProject,
		/*[in]*/ int cDirectories,
		/*[in,size_is(cDirectories)]*/ const LPCOLESTR rgpszMkDocuments[],
		/*[in,size_is(cDirectories)]*/ const VSQUERYREMOVEDIRECTORYFLAGS rgFlags[],
		/*[out]*/ VSQUERYREMOVEDIRECTORYRESULTS* pSummaryResult,
		/*[out,size_is(cDirectories)]*/ VSQUERYREMOVEDIRECTORYRESULTS rgResults[])
	{
		VSL_DEFINE_MOCK_METHOD(OnQueryRemoveDirectories)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pProject);

		VSL_CHECK_VALIDVALUE(cDirectories);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgpszMkDocuments, cDirectories*sizeof(rgpszMkDocuments[0]), validValues.cDirectories*sizeof(validValues.rgpszMkDocuments[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgFlags, cDirectories*sizeof(rgFlags[0]), validValues.cDirectories*sizeof(validValues.rgFlags[0]));

		VSL_SET_VALIDVALUE(pSummaryResult);

		VSL_SET_VALIDVALUE_MEMCPY(rgResults, cDirectories*sizeof(rgResults[0]), validValues.cDirectories*sizeof(validValues.rgResults[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterSccStatusChangedValidValues
	{
		/*[in]*/ int cProjects;
		/*[in]*/ int cFiles;
		/*[in,size_is(cProjects)]*/ IVsProject** rgpProjects;
		/*[in,size_is(cProjects)]*/ int* rgFirstIndices;
		/*[in,size_is(cFiles)]*/ LPCOLESTR* rgpszMkDocuments;
		/*[in,size_is(cFiles)]*/ DWORD* rgdwSccStatus;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterSccStatusChanged)(
		/*[in]*/ int cProjects,
		/*[in]*/ int cFiles,
		/*[in,size_is(cProjects)]*/ IVsProject* rgpProjects[],
		/*[in,size_is(cProjects)]*/ const int rgFirstIndices[],
		/*[in,size_is(cFiles)]*/ const LPCOLESTR rgpszMkDocuments[],
		/*[in,size_is(cFiles)]*/ const DWORD rgdwSccStatus[])
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterSccStatusChanged)

		VSL_CHECK_VALIDVALUE(cProjects);

		VSL_CHECK_VALIDVALUE(cFiles);

		VSL_CHECK_VALIDVALUE_ARRAY(rgpProjects, cProjects, validValues.cProjects);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgFirstIndices, cProjects*sizeof(rgFirstIndices[0]), validValues.cProjects*sizeof(validValues.rgFirstIndices[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgpszMkDocuments, cFiles*sizeof(rgpszMkDocuments[0]), validValues.cFiles*sizeof(validValues.rgpszMkDocuments[0]));

		VSL_CHECK_VALIDVALUE_MEMCMP(rgdwSccStatus, cFiles*sizeof(rgdwSccStatus[0]), validValues.cFiles*sizeof(validValues.rgdwSccStatus[0]));

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTRACKPROJECTDOCUMENTSEVENTS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsUIHierarchyWindow.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSUIHIERARCHYWINDOW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSUIHIERARCHYWINDOW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsUIHierarchyWindowNotImpl :
	public IVsUIHierarchyWindow
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUIHierarchyWindowNotImpl)

public:

	typedef IVsUIHierarchyWindow Interface;

	STDMETHOD(Init)(
		/*[in]*/ IVsUIHierarchy* /*pUIH*/,
		/*[in]*/ UIHWINFLAGS /*grfUIHWF*/,
		/*[out]*/ IUnknown** /*ppunkOut*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ExpandItem)(
		/*[in]*/ IVsUIHierarchy* /*pUIH*/,
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ EXPANDFLAGS /*expf*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddUIHierarchy)(
		/*[in]*/ IVsUIHierarchy* /*pUIH*/,
		/*[in]*/ VSADDHIEROPTIONS /*grfAddOptions*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveUIHierarchy)(
		/*[in]*/ IVsUIHierarchy* /*pUIH*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetWindowHelpTopic)(
		/*[in]*/ LPCOLESTR /*lpszHelpFile*/,
		/*[in]*/ DWORD /*dwContext*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetItemState)(
		/*[in]*/ IVsUIHierarchy* /*pHier*/,
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ VSHIERARCHYITEMSTATE /*dwStateMask*/,
		/*[out,retval]*/ VSHIERARCHYITEMSTATE* /*pdwState*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FindCommonSelectedHierarchy)(
		/*[in]*/ VSCOMHIEROPTIONS /*grfOpt*/,
		/*[out,retval]*/ IVsUIHierarchy** /*lppCommonUIH*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetCursor)(
		/*[in]*/ HCURSOR /*hNewCursor*/,
		/*[out,retval]*/ HCURSOR* /*phOldCursor*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCurrentSelection)(
		/*[out]*/ IVsHierarchy** /*ppHier*/,
		/*[out]*/ VSITEMID* /*pitemid*/,
		/*[out]*/ IVsMultiItemSelect** /*ppMIS*/)VSL_STDMETHOD_NOTIMPL
};

class IVsUIHierarchyWindowMockImpl :
	public IVsUIHierarchyWindow,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUIHierarchyWindowMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsUIHierarchyWindowMockImpl)

	typedef IVsUIHierarchyWindow Interface;
	struct InitValidValues
	{
		/*[in]*/ IVsUIHierarchy* pUIH;
		/*[in]*/ UIHWINFLAGS grfUIHWF;
		/*[out]*/ IUnknown** ppunkOut;
		HRESULT retValue;
	};

	STDMETHOD(Init)(
		/*[in]*/ IVsUIHierarchy* pUIH,
		/*[in]*/ UIHWINFLAGS grfUIHWF,
		/*[out]*/ IUnknown** ppunkOut)
	{
		VSL_DEFINE_MOCK_METHOD(Init)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUIH);

		VSL_CHECK_VALIDVALUE(grfUIHWF);

		VSL_SET_VALIDVALUE_INTERFACE(ppunkOut);

		VSL_RETURN_VALIDVALUES();
	}
	struct ExpandItemValidValues
	{
		/*[in]*/ IVsUIHierarchy* pUIH;
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ EXPANDFLAGS expf;
		HRESULT retValue;
	};

	STDMETHOD(ExpandItem)(
		/*[in]*/ IVsUIHierarchy* pUIH,
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ EXPANDFLAGS expf)
	{
		VSL_DEFINE_MOCK_METHOD(ExpandItem)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUIH);

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE(expf);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddUIHierarchyValidValues
	{
		/*[in]*/ IVsUIHierarchy* pUIH;
		/*[in]*/ VSADDHIEROPTIONS grfAddOptions;
		HRESULT retValue;
	};

	STDMETHOD(AddUIHierarchy)(
		/*[in]*/ IVsUIHierarchy* pUIH,
		/*[in]*/ VSADDHIEROPTIONS grfAddOptions)
	{
		VSL_DEFINE_MOCK_METHOD(AddUIHierarchy)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUIH);

		VSL_CHECK_VALIDVALUE(grfAddOptions);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveUIHierarchyValidValues
	{
		/*[in]*/ IVsUIHierarchy* pUIH;
		HRESULT retValue;
	};

	STDMETHOD(RemoveUIHierarchy)(
		/*[in]*/ IVsUIHierarchy* pUIH)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveUIHierarchy)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUIH);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetWindowHelpTopicValidValues
	{
		/*[in]*/ LPCOLESTR lpszHelpFile;
		/*[in]*/ DWORD dwContext;
		HRESULT retValue;
	};

	STDMETHOD(SetWindowHelpTopic)(
		/*[in]*/ LPCOLESTR lpszHelpFile,
		/*[in]*/ DWORD dwContext)
	{
		VSL_DEFINE_MOCK_METHOD(SetWindowHelpTopic)

		VSL_CHECK_VALIDVALUE_STRINGW(lpszHelpFile);

		VSL_CHECK_VALIDVALUE(dwContext);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetItemStateValidValues
	{
		/*[in]*/ IVsUIHierarchy* pHier;
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ VSHIERARCHYITEMSTATE dwStateMask;
		/*[out,retval]*/ VSHIERARCHYITEMSTATE* pdwState;
		HRESULT retValue;
	};

	STDMETHOD(GetItemState)(
		/*[in]*/ IVsUIHierarchy* pHier,
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ VSHIERARCHYITEMSTATE dwStateMask,
		/*[out,retval]*/ VSHIERARCHYITEMSTATE* pdwState)
	{
		VSL_DEFINE_MOCK_METHOD(GetItemState)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHier);

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE(dwStateMask);

		VSL_SET_VALIDVALUE(pdwState);

		VSL_RETURN_VALIDVALUES();
	}
	struct FindCommonSelectedHierarchyValidValues
	{
		/*[in]*/ VSCOMHIEROPTIONS grfOpt;
		/*[out,retval]*/ IVsUIHierarchy** lppCommonUIH;
		HRESULT retValue;
	};

	STDMETHOD(FindCommonSelectedHierarchy)(
		/*[in]*/ VSCOMHIEROPTIONS grfOpt,
		/*[out,retval]*/ IVsUIHierarchy** lppCommonUIH)
	{
		VSL_DEFINE_MOCK_METHOD(FindCommonSelectedHierarchy)

		VSL_CHECK_VALIDVALUE(grfOpt);

		VSL_SET_VALIDVALUE_INTERFACE(lppCommonUIH);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetCursorValidValues
	{
		/*[in]*/ HCURSOR hNewCursor;
		/*[out,retval]*/ HCURSOR* phOldCursor;
		HRESULT retValue;
	};

	STDMETHOD(SetCursor)(
		/*[in]*/ HCURSOR hNewCursor,
		/*[out,retval]*/ HCURSOR* phOldCursor)
	{
		VSL_DEFINE_MOCK_METHOD(SetCursor)

		VSL_CHECK_VALIDVALUE(hNewCursor);

		VSL_SET_VALIDVALUE(phOldCursor);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCurrentSelectionValidValues
	{
		/*[out]*/ IVsHierarchy** ppHier;
		/*[out]*/ VSITEMID* pitemid;
		/*[out]*/ IVsMultiItemSelect** ppMIS;
		HRESULT retValue;
	};

	STDMETHOD(GetCurrentSelection)(
		/*[out]*/ IVsHierarchy** ppHier,
		/*[out]*/ VSITEMID* pitemid,
		/*[out]*/ IVsMultiItemSelect** ppMIS)
	{
		VSL_DEFINE_MOCK_METHOD(GetCurrentSelection)

		VSL_SET_VALIDVALUE_INTERFACE(ppHier);

		VSL_SET_VALIDVALUE(pitemid);

		VSL_SET_VALIDVALUE_INTERFACE(ppMIS);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSUIHIERARCHYWINDOW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsUIHierWinClipboardHelperEvents.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSUIHIERWINCLIPBOARDHELPEREVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSUIHIERWINCLIPBOARDHELPEREVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsUIHierWinClipboardHelperEventsNotImpl :
	public IVsUIHierWinClipboardHelperEvents
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUIHierWinClipboardHelperEventsNotImpl)

public:

	typedef IVsUIHierWinClipboardHelperEvents Interface;

	STDMETHOD(OnPaste)(
		/*[in]*/ BOOL /*fDataWasCut*/,
		/*[in]*/ DWORD /*dwEffects*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnClear)(
		/*[in]*/ BOOL /*fDataWasCut*/)VSL_STDMETHOD_NOTIMPL
};

class IVsUIHierWinClipboardHelperEventsMockImpl :
	public IVsUIHierWinClipboardHelperEvents,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUIHierWinClipboardHelperEventsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsUIHierWinClipboardHelperEventsMockImpl)

	typedef IVsUIHierWinClipboardHelperEvents Interface;
	struct OnPasteValidValues
	{
		/*[in]*/ BOOL fDataWasCut;
		/*[in]*/ DWORD dwEffects;
		HRESULT retValue;
	};

	STDMETHOD(OnPaste)(
		/*[in]*/ BOOL fDataWasCut,
		/*[in]*/ DWORD dwEffects)
	{
		VSL_DEFINE_MOCK_METHOD(OnPaste)

		VSL_CHECK_VALIDVALUE(fDataWasCut);

		VSL_CHECK_VALIDVALUE(dwEffects);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnClearValidValues
	{
		/*[in]*/ BOOL fDataWasCut;
		HRESULT retValue;
	};

	STDMETHOD(OnClear)(
		/*[in]*/ BOOL fDataWasCut)
	{
		VSL_DEFINE_MOCK_METHOD(OnClear)

		VSL_CHECK_VALIDVALUE(fDataWasCut);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSUIHIERWINCLIPBOARDHELPEREVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsUIHierarchy.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSUIHIERARCHY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSUIHIERARCHY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsUIHierarchyNotImpl :
	public IVsUIHierarchy
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUIHierarchyNotImpl)

public:

	typedef IVsUIHierarchy Interface;

	STDMETHOD(QueryStatusCommand)(
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in,unique]*/ const GUID* /*pguidCmdGroup*/,
		/*[in]*/ ULONG /*cCmds*/,
		/*[in,out,size_is(cCmds)]*/ OLECMD[] /*prgCmds*/,
		/*[in,out,unique]*/ OLECMDTEXT* /*pCmdText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ExecCommand)(
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in,unique]*/ const GUID* /*pguidCmdGroup*/,
		/*[in]*/ DWORD /*nCmdID*/,
		/*[in]*/ DWORD /*nCmdexecopt*/,
		/*[in,unique]*/ VARIANT* /*pvaIn*/,
		/*[in,out,unique]*/ VARIANT* /*pvaOut*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetSite)(
		/*[in]*/ IServiceProvider* /*pSP*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSite)(
		/*[out]*/ IServiceProvider** /*ppSP*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryClose)(
		/*[out]*/ BOOL* /*pfCanClose*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Close)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetGuidProperty)(
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ VSHPROPID /*propid*/,
		/*[out]*/ GUID* /*pguid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetGuidProperty)(
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ VSHPROPID /*propid*/,
		/*[in]*/ REFGUID /*rguid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProperty)(
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ VSHPROPID /*propid*/,
		/*[out]*/ VARIANT* /*pvar*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetProperty)(
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ VSHPROPID /*propid*/,
		/*[in]*/ VARIANT /*var*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetNestedHierarchy)(
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ REFIID /*iidHierarchyNested*/,
		/*[out,iid_is(iidHierarchyNested)]*/ void** /*ppHierarchyNested*/,
		/*[out]*/ VSITEMID* /*pitemidNested*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCanonicalName)(
		/*[in]*/ VSITEMID /*itemid*/,
		/*[out]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ParseCanonicalName)(
		/*[in]*/ LPCOLESTR /*pszName*/,
		/*[out]*/ VSITEMID* /*pitemid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Unused0)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AdviseHierarchyEvents)(
		/*[in]*/ IVsHierarchyEvents* /*pEventSink*/,
		/*[out]*/ VSCOOKIE* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnadviseHierarchyEvents)(
		/*[in]*/ VSCOOKIE /*dwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Unused1)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Unused2)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Unused3)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Unused4)()VSL_STDMETHOD_NOTIMPL
};

class IVsUIHierarchyMockImpl :
	public IVsUIHierarchy,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUIHierarchyMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsUIHierarchyMockImpl)

	typedef IVsUIHierarchy Interface;
	struct QueryStatusCommandValidValues
	{
		/*[in]*/ VSITEMID itemid;
		/*[in,unique]*/ GUID* pguidCmdGroup;
		/*[in]*/ ULONG cCmds;
		/*[in,out,size_is(cCmds)]*/ OLECMD* prgCmds;
		/*[in,out,unique]*/ OLECMDTEXT* pCmdText;
		HRESULT retValue;
	};

	STDMETHOD(QueryStatusCommand)(
		/*[in]*/ VSITEMID itemid,
		/*[in,unique]*/ const GUID* pguidCmdGroup,
		/*[in]*/ ULONG cCmds,
		/*[in,out,size_is(cCmds)]*/ OLECMD prgCmds[],
		/*[in,out,unique]*/ OLECMDTEXT* pCmdText)
	{
		VSL_DEFINE_MOCK_METHOD(QueryStatusCommand)

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE_POINTER(pguidCmdGroup);

		VSL_CHECK_VALIDVALUE(cCmds);

		VSL_SET_VALIDVALUE_MEMCPY(prgCmds, cCmds*sizeof(prgCmds[0]), validValues.cCmds*sizeof(validValues.prgCmds[0]));

		VSL_SET_VALIDVALUE(pCmdText);

		VSL_RETURN_VALIDVALUES();
	}
	struct ExecCommandValidValues
	{
		/*[in]*/ VSITEMID itemid;
		/*[in,unique]*/ GUID* pguidCmdGroup;
		/*[in]*/ DWORD nCmdID;
		/*[in]*/ DWORD nCmdexecopt;
		/*[in,unique]*/ VARIANT* pvaIn;
		/*[in,out,unique]*/ VARIANT* pvaOut;
		HRESULT retValue;
	};

	STDMETHOD(ExecCommand)(
		/*[in]*/ VSITEMID itemid,
		/*[in,unique]*/ const GUID* pguidCmdGroup,
		/*[in]*/ DWORD nCmdID,
		/*[in]*/ DWORD nCmdexecopt,
		/*[in,unique]*/ VARIANT* pvaIn,
		/*[in,out,unique]*/ VARIANT* pvaOut)
	{
		VSL_DEFINE_MOCK_METHOD(ExecCommand)

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE_POINTER(pguidCmdGroup);

		VSL_CHECK_VALIDVALUE(nCmdID);

		VSL_CHECK_VALIDVALUE(nCmdexecopt);

		VSL_CHECK_VALIDVALUE_POINTER(pvaIn);

		VSL_SET_VALIDVALUE_VARIANT(pvaOut);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetSiteValidValues
	{
		/*[in]*/ IServiceProvider* pSP;
		HRESULT retValue;
	};

	STDMETHOD(SetSite)(
		/*[in]*/ IServiceProvider* pSP)
	{
		VSL_DEFINE_MOCK_METHOD(SetSite)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSP);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSiteValidValues
	{
		/*[out]*/ IServiceProvider** ppSP;
		HRESULT retValue;
	};

	STDMETHOD(GetSite)(
		/*[out]*/ IServiceProvider** ppSP)
	{
		VSL_DEFINE_MOCK_METHOD(GetSite)

		VSL_SET_VALIDVALUE_INTERFACE(ppSP);

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryCloseValidValues
	{
		/*[out]*/ BOOL* pfCanClose;
		HRESULT retValue;
	};

	STDMETHOD(QueryClose)(
		/*[out]*/ BOOL* pfCanClose)
	{
		VSL_DEFINE_MOCK_METHOD(QueryClose)

		VSL_SET_VALIDVALUE(pfCanClose);

		VSL_RETURN_VALIDVALUES();
	}
	struct CloseValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Close)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Close)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetGuidPropertyValidValues
	{
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ VSHPROPID propid;
		/*[out]*/ GUID* pguid;
		HRESULT retValue;
	};

	STDMETHOD(GetGuidProperty)(
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ VSHPROPID propid,
		/*[out]*/ GUID* pguid)
	{
		VSL_DEFINE_MOCK_METHOD(GetGuidProperty)

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE(propid);

		VSL_SET_VALIDVALUE(pguid);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetGuidPropertyValidValues
	{
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ VSHPROPID propid;
		/*[in]*/ REFGUID rguid;
		HRESULT retValue;
	};

	STDMETHOD(SetGuidProperty)(
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ VSHPROPID propid,
		/*[in]*/ REFGUID rguid)
	{
		VSL_DEFINE_MOCK_METHOD(SetGuidProperty)

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE(propid);

		VSL_CHECK_VALIDVALUE(rguid);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPropertyValidValues
	{
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ VSHPROPID propid;
		/*[out]*/ VARIANT* pvar;
		HRESULT retValue;
	};

	STDMETHOD(GetProperty)(
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ VSHPROPID propid,
		/*[out]*/ VARIANT* pvar)
	{
		VSL_DEFINE_MOCK_METHOD(GetProperty)

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE(propid);

		VSL_SET_VALIDVALUE_VARIANT(pvar);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetPropertyValidValues
	{
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ VSHPROPID propid;
		/*[in]*/ VARIANT var;
		HRESULT retValue;
	};

	STDMETHOD(SetProperty)(
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ VSHPROPID propid,
		/*[in]*/ VARIANT var)
	{
		VSL_DEFINE_MOCK_METHOD(SetProperty)

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE(propid);

		VSL_CHECK_VALIDVALUE(var);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetNestedHierarchyValidValues
	{
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ REFIID iidHierarchyNested;
		/*[out,iid_is(iidHierarchyNested)]*/ void** ppHierarchyNested;
		/*[out]*/ VSITEMID* pitemidNested;
		HRESULT retValue;
	};

	STDMETHOD(GetNestedHierarchy)(
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ REFIID iidHierarchyNested,
		/*[out,iid_is(iidHierarchyNested)]*/ void** ppHierarchyNested,
		/*[out]*/ VSITEMID* pitemidNested)
	{
		VSL_DEFINE_MOCK_METHOD(GetNestedHierarchy)

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE(iidHierarchyNested);

		VSL_SET_VALIDVALUE(ppHierarchyNested);

		VSL_SET_VALIDVALUE(pitemidNested);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCanonicalNameValidValues
	{
		/*[in]*/ VSITEMID itemid;
		/*[out]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(GetCanonicalName)(
		/*[in]*/ VSITEMID itemid,
		/*[out]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(GetCanonicalName)

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct ParseCanonicalNameValidValues
	{
		/*[in]*/ LPCOLESTR pszName;
		/*[out]*/ VSITEMID* pitemid;
		HRESULT retValue;
	};

	STDMETHOD(ParseCanonicalName)(
		/*[in]*/ LPCOLESTR pszName,
		/*[out]*/ VSITEMID* pitemid)
	{
		VSL_DEFINE_MOCK_METHOD(ParseCanonicalName)

		VSL_CHECK_VALIDVALUE_STRINGW(pszName);

		VSL_SET_VALIDVALUE(pitemid);

		VSL_RETURN_VALIDVALUES();
	}
	struct Unused0ValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Unused0)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Unused0)

		VSL_RETURN_VALIDVALUES();
	}
	struct AdviseHierarchyEventsValidValues
	{
		/*[in]*/ IVsHierarchyEvents* pEventSink;
		/*[out]*/ VSCOOKIE* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(AdviseHierarchyEvents)(
		/*[in]*/ IVsHierarchyEvents* pEventSink,
		/*[out]*/ VSCOOKIE* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(AdviseHierarchyEvents)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pEventSink);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnadviseHierarchyEventsValidValues
	{
		/*[in]*/ VSCOOKIE dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(UnadviseHierarchyEvents)(
		/*[in]*/ VSCOOKIE dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(UnadviseHierarchyEvents)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct Unused1ValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Unused1)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Unused1)

		VSL_RETURN_VALIDVALUES();
	}
	struct Unused2ValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Unused2)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Unused2)

		VSL_RETURN_VALIDVALUES();
	}
	struct Unused3ValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Unused3)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Unused3)

		VSL_RETURN_VALIDVALUES();
	}
	struct Unused4ValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Unused4)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Unused4)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSUIHIERARCHY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsUIHierarchyWindow2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSUIHIERARCHYWINDOW2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSUIHIERARCHYWINDOW2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsUIHierarchyWindow2NotImpl :
	public IVsUIHierarchyWindow2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUIHierarchyWindow2NotImpl)

public:

	typedef IVsUIHierarchyWindow2 Interface;

	STDMETHOD(SetItemAttribute)(
		/*[in]*/ IVsUIHierarchy* /*pUIH*/,
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ VSHIERITEMATTRIBUTE /*attribute*/,
		/*[in]*/ VARIANT /*value*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Init)(
		/*[in]*/ IVsUIHierarchy* /*pUIH*/,
		/*[in]*/ UIHWINFLAGS /*grfUIHWF*/,
		/*[out]*/ IUnknown** /*ppunkOut*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ExpandItem)(
		/*[in]*/ IVsUIHierarchy* /*pUIH*/,
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ EXPANDFLAGS /*expf*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddUIHierarchy)(
		/*[in]*/ IVsUIHierarchy* /*pUIH*/,
		/*[in]*/ VSADDHIEROPTIONS /*grfAddOptions*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveUIHierarchy)(
		/*[in]*/ IVsUIHierarchy* /*pUIH*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetWindowHelpTopic)(
		/*[in]*/ LPCOLESTR /*lpszHelpFile*/,
		/*[in]*/ DWORD /*dwContext*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetItemState)(
		/*[in]*/ IVsUIHierarchy* /*pHier*/,
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ VSHIERARCHYITEMSTATE /*dwStateMask*/,
		/*[out,retval]*/ VSHIERARCHYITEMSTATE* /*pdwState*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FindCommonSelectedHierarchy)(
		/*[in]*/ VSCOMHIEROPTIONS /*grfOpt*/,
		/*[out,retval]*/ IVsUIHierarchy** /*lppCommonUIH*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetCursor)(
		/*[in]*/ HCURSOR /*hNewCursor*/,
		/*[out,retval]*/ HCURSOR* /*phOldCursor*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCurrentSelection)(
		/*[out]*/ IVsHierarchy** /*ppHier*/,
		/*[out]*/ VSITEMID* /*pitemid*/,
		/*[out]*/ IVsMultiItemSelect** /*ppMIS*/)VSL_STDMETHOD_NOTIMPL
};

class IVsUIHierarchyWindow2MockImpl :
	public IVsUIHierarchyWindow2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUIHierarchyWindow2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsUIHierarchyWindow2MockImpl)

	typedef IVsUIHierarchyWindow2 Interface;
	struct SetItemAttributeValidValues
	{
		/*[in]*/ IVsUIHierarchy* pUIH;
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ VSHIERITEMATTRIBUTE attribute;
		/*[in]*/ VARIANT value;
		HRESULT retValue;
	};

	STDMETHOD(SetItemAttribute)(
		/*[in]*/ IVsUIHierarchy* pUIH,
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ VSHIERITEMATTRIBUTE attribute,
		/*[in]*/ VARIANT value)
	{
		VSL_DEFINE_MOCK_METHOD(SetItemAttribute)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUIH);

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE(attribute);

		VSL_CHECK_VALIDVALUE(value);

		VSL_RETURN_VALIDVALUES();
	}
	struct InitValidValues
	{
		/*[in]*/ IVsUIHierarchy* pUIH;
		/*[in]*/ UIHWINFLAGS grfUIHWF;
		/*[out]*/ IUnknown** ppunkOut;
		HRESULT retValue;
	};

	STDMETHOD(Init)(
		/*[in]*/ IVsUIHierarchy* pUIH,
		/*[in]*/ UIHWINFLAGS grfUIHWF,
		/*[out]*/ IUnknown** ppunkOut)
	{
		VSL_DEFINE_MOCK_METHOD(Init)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUIH);

		VSL_CHECK_VALIDVALUE(grfUIHWF);

		VSL_SET_VALIDVALUE_INTERFACE(ppunkOut);

		VSL_RETURN_VALIDVALUES();
	}
	struct ExpandItemValidValues
	{
		/*[in]*/ IVsUIHierarchy* pUIH;
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ EXPANDFLAGS expf;
		HRESULT retValue;
	};

	STDMETHOD(ExpandItem)(
		/*[in]*/ IVsUIHierarchy* pUIH,
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ EXPANDFLAGS expf)
	{
		VSL_DEFINE_MOCK_METHOD(ExpandItem)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUIH);

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE(expf);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddUIHierarchyValidValues
	{
		/*[in]*/ IVsUIHierarchy* pUIH;
		/*[in]*/ VSADDHIEROPTIONS grfAddOptions;
		HRESULT retValue;
	};

	STDMETHOD(AddUIHierarchy)(
		/*[in]*/ IVsUIHierarchy* pUIH,
		/*[in]*/ VSADDHIEROPTIONS grfAddOptions)
	{
		VSL_DEFINE_MOCK_METHOD(AddUIHierarchy)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUIH);

		VSL_CHECK_VALIDVALUE(grfAddOptions);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveUIHierarchyValidValues
	{
		/*[in]*/ IVsUIHierarchy* pUIH;
		HRESULT retValue;
	};

	STDMETHOD(RemoveUIHierarchy)(
		/*[in]*/ IVsUIHierarchy* pUIH)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveUIHierarchy)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUIH);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetWindowHelpTopicValidValues
	{
		/*[in]*/ LPCOLESTR lpszHelpFile;
		/*[in]*/ DWORD dwContext;
		HRESULT retValue;
	};

	STDMETHOD(SetWindowHelpTopic)(
		/*[in]*/ LPCOLESTR lpszHelpFile,
		/*[in]*/ DWORD dwContext)
	{
		VSL_DEFINE_MOCK_METHOD(SetWindowHelpTopic)

		VSL_CHECK_VALIDVALUE_STRINGW(lpszHelpFile);

		VSL_CHECK_VALIDVALUE(dwContext);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetItemStateValidValues
	{
		/*[in]*/ IVsUIHierarchy* pHier;
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ VSHIERARCHYITEMSTATE dwStateMask;
		/*[out,retval]*/ VSHIERARCHYITEMSTATE* pdwState;
		HRESULT retValue;
	};

	STDMETHOD(GetItemState)(
		/*[in]*/ IVsUIHierarchy* pHier,
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ VSHIERARCHYITEMSTATE dwStateMask,
		/*[out,retval]*/ VSHIERARCHYITEMSTATE* pdwState)
	{
		VSL_DEFINE_MOCK_METHOD(GetItemState)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHier);

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE(dwStateMask);

		VSL_SET_VALIDVALUE(pdwState);

		VSL_RETURN_VALIDVALUES();
	}
	struct FindCommonSelectedHierarchyValidValues
	{
		/*[in]*/ VSCOMHIEROPTIONS grfOpt;
		/*[out,retval]*/ IVsUIHierarchy** lppCommonUIH;
		HRESULT retValue;
	};

	STDMETHOD(FindCommonSelectedHierarchy)(
		/*[in]*/ VSCOMHIEROPTIONS grfOpt,
		/*[out,retval]*/ IVsUIHierarchy** lppCommonUIH)
	{
		VSL_DEFINE_MOCK_METHOD(FindCommonSelectedHierarchy)

		VSL_CHECK_VALIDVALUE(grfOpt);

		VSL_SET_VALIDVALUE_INTERFACE(lppCommonUIH);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetCursorValidValues
	{
		/*[in]*/ HCURSOR hNewCursor;
		/*[out,retval]*/ HCURSOR* phOldCursor;
		HRESULT retValue;
	};

	STDMETHOD(SetCursor)(
		/*[in]*/ HCURSOR hNewCursor,
		/*[out,retval]*/ HCURSOR* phOldCursor)
	{
		VSL_DEFINE_MOCK_METHOD(SetCursor)

		VSL_CHECK_VALIDVALUE(hNewCursor);

		VSL_SET_VALIDVALUE(phOldCursor);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCurrentSelectionValidValues
	{
		/*[out]*/ IVsHierarchy** ppHier;
		/*[out]*/ VSITEMID* pitemid;
		/*[out]*/ IVsMultiItemSelect** ppMIS;
		HRESULT retValue;
	};

	STDMETHOD(GetCurrentSelection)(
		/*[out]*/ IVsHierarchy** ppHier,
		/*[out]*/ VSITEMID* pitemid,
		/*[out]*/ IVsMultiItemSelect** ppMIS)
	{
		VSL_DEFINE_MOCK_METHOD(GetCurrentSelection)

		VSL_SET_VALIDVALUE_INTERFACE(ppHier);

		VSL_SET_VALIDVALUE(pitemid);

		VSL_SET_VALIDVALUE_INTERFACE(ppMIS);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSUIHIERARCHYWINDOW2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsUIHierWinClipboardHelper.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSUIHIERWINCLIPBOARDHELPER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSUIHIERWINCLIPBOARDHELPER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsUIHierWinClipboardHelperNotImpl :
	public IVsUIHierWinClipboardHelper
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUIHierWinClipboardHelperNotImpl)

public:

	typedef IVsUIHierWinClipboardHelper Interface;

	STDMETHOD(Cut)(
		/*[in]*/ IDataObject* /*pDataObject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Copy)(
		/*[in]*/ IDataObject* /*pDataObject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Paste)(
		/*[in]*/ IDataObject* /*pDataObject*/,
		/*[in]*/ DWORD /*dwEffects*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AdviseClipboardHelperEvents)(
		/*[in]*/ IVsUIHierWinClipboardHelperEvents* /*pSink*/,
		/*[out]*/ VSCOOKIE* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnadviseClipboardHelperEvents)(
		/*[in]*/ VSCOOKIE /*dwCookie*/)VSL_STDMETHOD_NOTIMPL
};

class IVsUIHierWinClipboardHelperMockImpl :
	public IVsUIHierWinClipboardHelper,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUIHierWinClipboardHelperMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsUIHierWinClipboardHelperMockImpl)

	typedef IVsUIHierWinClipboardHelper Interface;
	struct CutValidValues
	{
		/*[in]*/ IDataObject* pDataObject;
		HRESULT retValue;
	};

	STDMETHOD(Cut)(
		/*[in]*/ IDataObject* pDataObject)
	{
		VSL_DEFINE_MOCK_METHOD(Cut)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDataObject);

		VSL_RETURN_VALIDVALUES();
	}
	struct CopyValidValues
	{
		/*[in]*/ IDataObject* pDataObject;
		HRESULT retValue;
	};

	STDMETHOD(Copy)(
		/*[in]*/ IDataObject* pDataObject)
	{
		VSL_DEFINE_MOCK_METHOD(Copy)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDataObject);

		VSL_RETURN_VALIDVALUES();
	}
	struct PasteValidValues
	{
		/*[in]*/ IDataObject* pDataObject;
		/*[in]*/ DWORD dwEffects;
		HRESULT retValue;
	};

	STDMETHOD(Paste)(
		/*[in]*/ IDataObject* pDataObject,
		/*[in]*/ DWORD dwEffects)
	{
		VSL_DEFINE_MOCK_METHOD(Paste)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDataObject);

		VSL_CHECK_VALIDVALUE(dwEffects);

		VSL_RETURN_VALIDVALUES();
	}
	struct AdviseClipboardHelperEventsValidValues
	{
		/*[in]*/ IVsUIHierWinClipboardHelperEvents* pSink;
		/*[out]*/ VSCOOKIE* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(AdviseClipboardHelperEvents)(
		/*[in]*/ IVsUIHierWinClipboardHelperEvents* pSink,
		/*[out]*/ VSCOOKIE* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(AdviseClipboardHelperEvents)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSink);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnadviseClipboardHelperEventsValidValues
	{
		/*[in]*/ VSCOOKIE dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(UnadviseClipboardHelperEvents)(
		/*[in]*/ VSCOOKIE dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(UnadviseClipboardHelperEvents)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSUIHIERWINCLIPBOARDHELPER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsTypeLibraryWrapperCallback.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSTYPELIBRARYWRAPPERCALLBACK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSTYPELIBRARYWRAPPERCALLBACK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "compsvcspkg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsTypeLibraryWrapperCallbackNotImpl :
	public IVsTypeLibraryWrapperCallback
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTypeLibraryWrapperCallbackNotImpl)

public:

	typedef IVsTypeLibraryWrapperCallback Interface;

	STDMETHOD(GetAssembly)(
		/*[in]*/ LPCOLESTR /*wszFusionName*/,
		/*[out,retval]*/ BSTR* /*pbstrPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetComClassic)(
		/*[in]*/ TLIBATTR* /*pTypeLibAttr*/,
		/*[in]*/ LPCOLESTR /*wszWrapperTool*/,
		/*[out]*/ BOOL* /*pDelaySigned*/,
		/*[out]*/ BSTR* /*pbstrWrapperTool*/,
		/*[out,retval]*/ BSTR* /*pbstrPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetComClassicByTypeLibName)(
		/*[in]*/ LPCOLESTR /*wszTypeLibName*/,
		/*[out]*/ TLIBATTR* /*pTypeLibAttr*/,
		/*[out]*/ BOOL* /*pDelaySigned*/,
		/*[out]*/ BSTR* /*pbstrWrapperTool*/,
		/*[out,retval]*/ BSTR* /*pbstrPath*/)VSL_STDMETHOD_NOTIMPL
};

class IVsTypeLibraryWrapperCallbackMockImpl :
	public IVsTypeLibraryWrapperCallback,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsTypeLibraryWrapperCallbackMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsTypeLibraryWrapperCallbackMockImpl)

	typedef IVsTypeLibraryWrapperCallback Interface;
	struct GetAssemblyValidValues
	{
		/*[in]*/ LPCOLESTR wszFusionName;
		/*[out,retval]*/ BSTR* pbstrPath;
		HRESULT retValue;
	};

	STDMETHOD(GetAssembly)(
		/*[in]*/ LPCOLESTR wszFusionName,
		/*[out,retval]*/ BSTR* pbstrPath)
	{
		VSL_DEFINE_MOCK_METHOD(GetAssembly)

		VSL_CHECK_VALIDVALUE_STRINGW(wszFusionName);

		VSL_SET_VALIDVALUE_BSTR(pbstrPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetComClassicValidValues
	{
		/*[in]*/ TLIBATTR* pTypeLibAttr;
		/*[in]*/ LPCOLESTR wszWrapperTool;
		/*[out]*/ BOOL* pDelaySigned;
		/*[out]*/ BSTR* pbstrWrapperTool;
		/*[out,retval]*/ BSTR* pbstrPath;
		HRESULT retValue;
	};

	STDMETHOD(GetComClassic)(
		/*[in]*/ TLIBATTR* pTypeLibAttr,
		/*[in]*/ LPCOLESTR wszWrapperTool,
		/*[out]*/ BOOL* pDelaySigned,
		/*[out]*/ BSTR* pbstrWrapperTool,
		/*[out,retval]*/ BSTR* pbstrPath)
	{
		VSL_DEFINE_MOCK_METHOD(GetComClassic)

		VSL_CHECK_VALIDVALUE_POINTER(pTypeLibAttr);

		VSL_CHECK_VALIDVALUE_STRINGW(wszWrapperTool);

		VSL_SET_VALIDVALUE(pDelaySigned);

		VSL_SET_VALIDVALUE_BSTR(pbstrWrapperTool);

		VSL_SET_VALIDVALUE_BSTR(pbstrPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetComClassicByTypeLibNameValidValues
	{
		/*[in]*/ LPCOLESTR wszTypeLibName;
		/*[out]*/ TLIBATTR* pTypeLibAttr;
		/*[out]*/ BOOL* pDelaySigned;
		/*[out]*/ BSTR* pbstrWrapperTool;
		/*[out,retval]*/ BSTR* pbstrPath;
		HRESULT retValue;
	};

	STDMETHOD(GetComClassicByTypeLibName)(
		/*[in]*/ LPCOLESTR wszTypeLibName,
		/*[out]*/ TLIBATTR* pTypeLibAttr,
		/*[out]*/ BOOL* pDelaySigned,
		/*[out]*/ BSTR* pbstrWrapperTool,
		/*[out,retval]*/ BSTR* pbstrPath)
	{
		VSL_DEFINE_MOCK_METHOD(GetComClassicByTypeLibName)

		VSL_CHECK_VALIDVALUE_STRINGW(wszTypeLibName);

		VSL_SET_VALIDVALUE(pTypeLibAttr);

		VSL_SET_VALIDVALUE(pDelaySigned);

		VSL_SET_VALIDVALUE_BSTR(pbstrWrapperTool);

		VSL_SET_VALIDVALUE_BSTR(pbstrPath);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSTYPELIBRARYWRAPPERCALLBACK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsUIShell.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSUISHELL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSUISHELL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsUIShellNotImpl :
	public IVsUIShell
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUIShellNotImpl)

public:

	typedef IVsUIShell Interface;

	STDMETHOD(GetToolWindowEnum)(
		/*[out]*/ IEnumWindowFrames** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDocumentWindowEnum)(
		/*[out]*/ IEnumWindowFrames** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FindToolWindow)(
		/*[in]*/ VSFINDTOOLWIN /*grfFTW*/,
		/*[in]*/ REFGUID /*rguidPersistenceSlot*/,
		/*[out]*/ IVsWindowFrame** /*ppWindowFrame*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateToolWindow)(
		/*[in]*/ VSCREATETOOLWIN /*grfCTW*/,
		/*[in]*/ DWORD /*dwToolWindowId*/,
		/*[in]*/ IUnknown* /*punkTool*/,
		/*[in]*/ REFCLSID /*rclsidTool*/,
		/*[in]*/ REFGUID /*rguidPersistenceSlot*/,
		/*[in]*/ REFGUID /*rguidAutoActivate*/,
		/*[in]*/ IServiceProvider* /*pSP*/,
		/*[in]*/ LPCOLESTR /*pszCaption*/,
		/*[out]*/ BOOL* /*pfDefaultPosition*/,
		/*[out]*/ IVsWindowFrame** /*ppWindowFrame*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateDocumentWindow)(
		/*[in]*/ VSCREATEDOCWIN /*grfCDW*/,
		/*[in]*/ LPCOLESTR /*pszMkDocument*/,
		/*[in]*/ IVsUIHierarchy* /*pUIH*/,
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ IUnknown* /*punkDocView*/,
		/*[in]*/ IUnknown* /*punkDocData*/,
		/*[in]*/ REFGUID /*rguidEditorType*/,
		/*[in]*/ LPCOLESTR /*pszPhysicalView*/,
		/*[in]*/ REFGUID /*rguidCmdUI*/,
		/*[in]*/ IServiceProvider* /*pSP*/,
		/*[in]*/ LPCOLESTR /*pszOwnerCaption*/,
		/*[in]*/ LPCOLESTR /*pszEditorCaption*/,
		/*[out]*/ BOOL* /*pfDefaultPosition*/,
		/*[out]*/ IVsWindowFrame** /*ppWindowFrame*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetErrorInfo)(
		/*[in]*/ HRESULT /*hr*/,
		/*[in]*/ LPCOLESTR /*pszDescription*/,
		/*[in]*/ DWORD /*dwReserved*/,
		/*[in]*/ LPCOLESTR /*pszHelpKeyword*/,
		/*[in]*/ LPCOLESTR /*pszSource*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReportErrorInfo)(
		/*[in]*/ HRESULT /*hr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDialogOwnerHwnd)(
		/*[out]*/ HWND* /*phwnd*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnableModeless)(
		/*[in]*/ BOOL /*fEnable*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SaveDocDataToFile)(
		/*[in]*/ VSSAVEFLAGS /*grfSave*/,
		/*[in]*/ IUnknown* /*pPersistFile*/,
		/*[in]*/ LPCOLESTR /*pszUntitledPath*/,
		/*[out]*/ BSTR* /*pbstrDocumentNew*/,
		/*[out]*/ BOOL* /*pfCanceled*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetupToolbar)(
		/*[in]*/ HWND /*hwnd*/,
		/*[in]*/ IVsToolWindowToolbar* /*ptwt*/,
		/*[out]*/ IVsToolWindowToolbarHost** /*pptwth*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetForegroundWindow)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(TranslateAcceleratorAsACmd)(
		/*[in]*/ LPMSG /*pMsg*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UpdateCommandUI)(
		/*[in]*/ BOOL /*fImmediateUpdate*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UpdateDocDataIsDirtyFeedback)(
		/*[in]*/ VSCOOKIE /*docCookie*/,
		/*[in]*/ BOOL /*fDirty*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RefreshPropertyBrowser)(
		/*[in]*/ DISPID /*dispid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetWaitCursor)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(PostExecCommand)(
		/*[in,unique]*/ const GUID* /*pguidCmdGroup*/,
		/*[in]*/ DWORD /*nCmdID*/,
		/*[in]*/ DWORD /*nCmdexecopt*/,
		/*[in,unique]*/ VARIANT* /*pvaIn*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ShowContextMenu)(
		/*[in]*/ DWORD /*dwCompRole*/,
		/*[in]*/ REFCLSID /*rclsidActive*/,
		/*[in]*/ LONG /*nMenuId*/,
		/*[in]*/ REFPOINTS /*pos*/,
		/*[in]*/ IOleCommandTarget* /*pCmdTrgtActive*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ShowMessageBox)(
		/*[in]*/ DWORD /*dwCompRole*/,
		/*[in]*/ REFCLSID /*rclsidComp*/,
		/*[in]*/ _In_z_ LPOLESTR /*pszTitle*/,
		/*[in]*/ _In_z_ LPOLESTR /*pszText*/,
		/*[in]*/ _In_z_ LPOLESTR /*pszHelpFile*/,
		/*[in]*/ DWORD /*dwHelpContextID*/,
		/*[in]*/ OLEMSGBUTTON /*msgbtn*/,
		/*[in]*/ OLEMSGDEFBUTTON /*msgdefbtn*/,
		/*[in]*/ OLEMSGICON /*msgicon*/,
		/*[in]*/ BOOL /*fSysAlert*/,
		/*[out,retval]*/ LONG* /*pnResult*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetMRUComboText)(
		/*[in]*/ const GUID* /*pguidCmdGroup*/,
		/*[in]*/ DWORD /*dwCmdId*/,
		/*[in]*/ _In_ LPSTR /*lpszText*/,
		/*[in]*/ BOOL /*fAddToList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetToolbarVisibleInFullScreen)(
		/*[in]*/ const GUID* /*pguidCmdGroup*/,
		/*[in]*/ DWORD /*dwToolbarId*/,
		/*[in]*/ BOOL /*fVisibleInFullScreen*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FindToolWindowEx)(
		/*[in]*/ VSFINDTOOLWIN /*grfFTW*/,
		/*[in]*/ REFGUID /*rguidPersistenceSlot*/,
		/*[in]*/ DWORD /*dwToolWinId*/,
		/*[out]*/ IVsWindowFrame** /*ppWindowFrame*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetAppName)(
		/*[out]*/ BSTR* /*pbstrAppName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetVSSysColor)(
		/*[in]*/ VSSYSCOLOR /*dwSysColIndex*/,
		/*[out]*/ DWORD* /*pdwRGBval*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetMRUComboTextW)(
		/*[in]*/ const GUID* /*pguidCmdGroup*/,
		/*[in]*/ DWORD /*dwCmdId*/,
		/*[in]*/ _In_ LPWSTR /*pwszText*/,
		/*[in]*/ BOOL /*fAddToList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(PostSetFocusMenuCommand)(
		/*[in,unique]*/ const GUID* /*pguidCmdGroup*/,
		/*[in]*/ DWORD /*nCmdId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCurrentBFNavigationItem)(
		/*[out]*/ IVsWindowFrame** /*ppWindowFrame*/,
		/*[out]*/ BSTR* /*pbstrData*/,
		/*[out]*/ IUnknown** /*ppunk*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddNewBFNavigationItem)(
		/*[in]*/ IVsWindowFrame* /*pWindowFrame*/,
		/*[in]*/ BSTR /*bstrData*/,
		/*[in]*/ IUnknown* /*punk*/,
		/*[in]*/ BOOL /*fReplaceCurrent*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnModeChange)(
		/*[in]*/ DBGMODE /*dbgmodeNew*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetErrorInfo)(
		/*[out]*/ BSTR* /*pbstrErrText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetOpenFileNameViaDlg)(
		/*[in,out]*/ VSOPENFILENAMEW* /*pOpenFileName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSaveFileNameViaDlg)(
		/*[in,out]*/ VSSAVEFILENAMEW* /*pSaveFileName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDirectoryViaBrowseDlg)(
		/*[in,out]*/ VSBROWSEINFOW* /*pBrowse*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CenterDialogOnWindow)(
		/*[in]*/ HWND /*hwndDialog*/,
		/*[in]*/ HWND /*hwndParent*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPreviousBFNavigationItem)(
		/*[out]*/ IVsWindowFrame** /*ppWindowFrame*/,
		/*[out]*/ BSTR* /*pbstrData*/,
		/*[out]*/ IUnknown** /*ppunk*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetNextBFNavigationItem)(
		/*[out]*/ IVsWindowFrame** /*ppWindowFrame*/,
		/*[out]*/ BSTR* /*pbstrData*/,
		/*[out]*/ IUnknown** /*ppunk*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetURLViaDlg)(
		/*[in]*/ LPCOLESTR /*pszDlgTitle*/,
		/*[in]*/ LPCOLESTR /*pszStaticLabel*/,
		/*[in]*/ LPCOLESTR /*pszHelpTopic*/,
		/*[out]*/ BSTR* /*pbstrURL*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveAdjacentBFNavigationItem)(
		/*[in]*/ RemoveBFDirection /*rdDir*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveCurrentNavigationDupes)(
		/*[in]*/ RemoveBFDirection /*rdDir*/)VSL_STDMETHOD_NOTIMPL
};

class IVsUIShellMockImpl :
	public IVsUIShell,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUIShellMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsUIShellMockImpl)

	typedef IVsUIShell Interface;
	struct GetToolWindowEnumValidValues
	{
		/*[out]*/ IEnumWindowFrames** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(GetToolWindowEnum)(
		/*[out]*/ IEnumWindowFrames** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(GetToolWindowEnum)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDocumentWindowEnumValidValues
	{
		/*[out]*/ IEnumWindowFrames** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(GetDocumentWindowEnum)(
		/*[out]*/ IEnumWindowFrames** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(GetDocumentWindowEnum)

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct FindToolWindowValidValues
	{
		/*[in]*/ VSFINDTOOLWIN grfFTW;
		/*[in]*/ REFGUID rguidPersistenceSlot;
		/*[out]*/ IVsWindowFrame** ppWindowFrame;
		HRESULT retValue;
	};

	STDMETHOD(FindToolWindow)(
		/*[in]*/ VSFINDTOOLWIN grfFTW,
		/*[in]*/ REFGUID rguidPersistenceSlot,
		/*[out]*/ IVsWindowFrame** ppWindowFrame)
	{
		VSL_DEFINE_MOCK_METHOD(FindToolWindow)

		VSL_CHECK_VALIDVALUE(grfFTW);

		VSL_CHECK_VALIDVALUE(rguidPersistenceSlot);

		VSL_SET_VALIDVALUE_INTERFACE(ppWindowFrame);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateToolWindowValidValues
	{
		/*[in]*/ VSCREATETOOLWIN grfCTW;
		/*[in]*/ DWORD dwToolWindowId;
		/*[in]*/ IUnknown* punkTool;
		/*[in]*/ REFCLSID rclsidTool;
		/*[in]*/ REFGUID rguidPersistenceSlot;
		/*[in]*/ REFGUID rguidAutoActivate;
		/*[in]*/ IServiceProvider* pSP;
		/*[in]*/ LPCOLESTR pszCaption;
		/*[out]*/ BOOL* pfDefaultPosition;
		/*[out]*/ IVsWindowFrame** ppWindowFrame;
		HRESULT retValue;
	};

	STDMETHOD(CreateToolWindow)(
		/*[in]*/ VSCREATETOOLWIN grfCTW,
		/*[in]*/ DWORD dwToolWindowId,
		/*[in]*/ IUnknown* punkTool,
		/*[in]*/ REFCLSID rclsidTool,
		/*[in]*/ REFGUID rguidPersistenceSlot,
		/*[in]*/ REFGUID rguidAutoActivate,
		/*[in]*/ IServiceProvider* pSP,
		/*[in]*/ LPCOLESTR pszCaption,
		/*[out]*/ BOOL* pfDefaultPosition,
		/*[out]*/ IVsWindowFrame** ppWindowFrame)
	{
		VSL_DEFINE_MOCK_METHOD(CreateToolWindow)

		VSL_CHECK_VALIDVALUE(grfCTW);

		VSL_CHECK_VALIDVALUE(dwToolWindowId);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkTool);

		VSL_CHECK_VALIDVALUE(rclsidTool);

		VSL_CHECK_VALIDVALUE(rguidPersistenceSlot);

		VSL_CHECK_VALIDVALUE(rguidAutoActivate);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSP);

		VSL_CHECK_VALIDVALUE_STRINGW(pszCaption);

		VSL_SET_VALIDVALUE(pfDefaultPosition);

		VSL_SET_VALIDVALUE_INTERFACE(ppWindowFrame);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateDocumentWindowValidValues
	{
		/*[in]*/ VSCREATEDOCWIN grfCDW;
		/*[in]*/ LPCOLESTR pszMkDocument;
		/*[in]*/ IVsUIHierarchy* pUIH;
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ IUnknown* punkDocView;
		/*[in]*/ IUnknown* punkDocData;
		/*[in]*/ REFGUID rguidEditorType;
		/*[in]*/ LPCOLESTR pszPhysicalView;
		/*[in]*/ REFGUID rguidCmdUI;
		/*[in]*/ IServiceProvider* pSP;
		/*[in]*/ LPCOLESTR pszOwnerCaption;
		/*[in]*/ LPCOLESTR pszEditorCaption;
		/*[out]*/ BOOL* pfDefaultPosition;
		/*[out]*/ IVsWindowFrame** ppWindowFrame;
		HRESULT retValue;
	};

	STDMETHOD(CreateDocumentWindow)(
		/*[in]*/ VSCREATEDOCWIN grfCDW,
		/*[in]*/ LPCOLESTR pszMkDocument,
		/*[in]*/ IVsUIHierarchy* pUIH,
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ IUnknown* punkDocView,
		/*[in]*/ IUnknown* punkDocData,
		/*[in]*/ REFGUID rguidEditorType,
		/*[in]*/ LPCOLESTR pszPhysicalView,
		/*[in]*/ REFGUID rguidCmdUI,
		/*[in]*/ IServiceProvider* pSP,
		/*[in]*/ LPCOLESTR pszOwnerCaption,
		/*[in]*/ LPCOLESTR pszEditorCaption,
		/*[out]*/ BOOL* pfDefaultPosition,
		/*[out]*/ IVsWindowFrame** ppWindowFrame)
	{
		VSL_DEFINE_MOCK_METHOD(CreateDocumentWindow)

		VSL_CHECK_VALIDVALUE(grfCDW);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUIH);

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkDocView);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkDocData);

		VSL_CHECK_VALIDVALUE(rguidEditorType);

		VSL_CHECK_VALIDVALUE_STRINGW(pszPhysicalView);

		VSL_CHECK_VALIDVALUE(rguidCmdUI);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSP);

		VSL_CHECK_VALIDVALUE_STRINGW(pszOwnerCaption);

		VSL_CHECK_VALIDVALUE_STRINGW(pszEditorCaption);

		VSL_SET_VALIDVALUE(pfDefaultPosition);

		VSL_SET_VALIDVALUE_INTERFACE(ppWindowFrame);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetErrorInfoValidValues
	{
		/*[in]*/ HRESULT hr;
		/*[in]*/ LPCOLESTR pszDescription;
		/*[in]*/ DWORD dwReserved;
		/*[in]*/ LPCOLESTR pszHelpKeyword;
		/*[in]*/ LPCOLESTR pszSource;
		HRESULT retValue;
	};

	STDMETHOD(SetErrorInfo)(
		/*[in]*/ HRESULT hr,
		/*[in]*/ LPCOLESTR pszDescription,
		/*[in]*/ DWORD dwReserved,
		/*[in]*/ LPCOLESTR pszHelpKeyword,
		/*[in]*/ LPCOLESTR pszSource)
	{
		VSL_DEFINE_MOCK_METHOD(SetErrorInfo)

		VSL_CHECK_VALIDVALUE(hr);

		VSL_CHECK_VALIDVALUE_STRINGW(pszDescription);

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_CHECK_VALIDVALUE_STRINGW(pszHelpKeyword);

		VSL_CHECK_VALIDVALUE_STRINGW(pszSource);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReportErrorInfoValidValues
	{
		/*[in]*/ HRESULT hr;
		HRESULT retValue;
	};

	STDMETHOD(ReportErrorInfo)(
		/*[in]*/ HRESULT hr)
	{
		VSL_DEFINE_MOCK_METHOD(ReportErrorInfo)

		VSL_CHECK_VALIDVALUE(hr);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDialogOwnerHwndValidValues
	{
		/*[out]*/ HWND* phwnd;
		HRESULT retValue;
	};

	STDMETHOD(GetDialogOwnerHwnd)(
		/*[out]*/ HWND* phwnd)
	{
		VSL_DEFINE_MOCK_METHOD(GetDialogOwnerHwnd)

		VSL_SET_VALIDVALUE(phwnd);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnableModelessValidValues
	{
		/*[in]*/ BOOL fEnable;
		HRESULT retValue;
	};

	STDMETHOD(EnableModeless)(
		/*[in]*/ BOOL fEnable)
	{
		VSL_DEFINE_MOCK_METHOD(EnableModeless)

		VSL_CHECK_VALIDVALUE(fEnable);

		VSL_RETURN_VALIDVALUES();
	}
	struct SaveDocDataToFileValidValues
	{
		/*[in]*/ VSSAVEFLAGS grfSave;
		/*[in]*/ IUnknown* pPersistFile;
		/*[in]*/ LPCOLESTR pszUntitledPath;
		/*[out]*/ BSTR* pbstrDocumentNew;
		/*[out]*/ BOOL* pfCanceled;
		HRESULT retValue;
	};

	STDMETHOD(SaveDocDataToFile)(
		/*[in]*/ VSSAVEFLAGS grfSave,
		/*[in]*/ IUnknown* pPersistFile,
		/*[in]*/ LPCOLESTR pszUntitledPath,
		/*[out]*/ BSTR* pbstrDocumentNew,
		/*[out]*/ BOOL* pfCanceled)
	{
		VSL_DEFINE_MOCK_METHOD(SaveDocDataToFile)

		VSL_CHECK_VALIDVALUE(grfSave);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pPersistFile);

		VSL_CHECK_VALIDVALUE_STRINGW(pszUntitledPath);

		VSL_SET_VALIDVALUE_BSTR(pbstrDocumentNew);

		VSL_SET_VALIDVALUE(pfCanceled);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetupToolbarValidValues
	{
		/*[in]*/ HWND hwnd;
		/*[in]*/ IVsToolWindowToolbar* ptwt;
		/*[out]*/ IVsToolWindowToolbarHost** pptwth;
		HRESULT retValue;
	};

	STDMETHOD(SetupToolbar)(
		/*[in]*/ HWND hwnd,
		/*[in]*/ IVsToolWindowToolbar* ptwt,
		/*[out]*/ IVsToolWindowToolbarHost** pptwth)
	{
		VSL_DEFINE_MOCK_METHOD(SetupToolbar)

		VSL_CHECK_VALIDVALUE(hwnd);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(ptwt);

		VSL_SET_VALIDVALUE_INTERFACE(pptwth);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetForegroundWindowValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(SetForegroundWindow)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(SetForegroundWindow)

		VSL_RETURN_VALIDVALUES();
	}
	struct TranslateAcceleratorAsACmdValidValues
	{
		/*[in]*/ LPMSG pMsg;
		HRESULT retValue;
	};

	STDMETHOD(TranslateAcceleratorAsACmd)(
		/*[in]*/ LPMSG pMsg)
	{
		VSL_DEFINE_MOCK_METHOD(TranslateAcceleratorAsACmd)

		VSL_CHECK_VALIDVALUE(pMsg);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateCommandUIValidValues
	{
		/*[in]*/ BOOL fImmediateUpdate;
		HRESULT retValue;
	};

	STDMETHOD(UpdateCommandUI)(
		/*[in]*/ BOOL fImmediateUpdate)
	{
		VSL_DEFINE_MOCK_METHOD(UpdateCommandUI)

		VSL_CHECK_VALIDVALUE(fImmediateUpdate);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateDocDataIsDirtyFeedbackValidValues
	{
		/*[in]*/ VSCOOKIE docCookie;
		/*[in]*/ BOOL fDirty;
		HRESULT retValue;
	};

	STDMETHOD(UpdateDocDataIsDirtyFeedback)(
		/*[in]*/ VSCOOKIE docCookie,
		/*[in]*/ BOOL fDirty)
	{
		VSL_DEFINE_MOCK_METHOD(UpdateDocDataIsDirtyFeedback)

		VSL_CHECK_VALIDVALUE(docCookie);

		VSL_CHECK_VALIDVALUE(fDirty);

		VSL_RETURN_VALIDVALUES();
	}
	struct RefreshPropertyBrowserValidValues
	{
		/*[in]*/ DISPID dispid;
		HRESULT retValue;
	};

	STDMETHOD(RefreshPropertyBrowser)(
		/*[in]*/ DISPID dispid)
	{
		VSL_DEFINE_MOCK_METHOD(RefreshPropertyBrowser)

		VSL_CHECK_VALIDVALUE(dispid);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetWaitCursorValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(SetWaitCursor)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(SetWaitCursor)

		VSL_RETURN_VALIDVALUES();
	}
	struct PostExecCommandValidValues
	{
		/*[in,unique]*/ GUID* pguidCmdGroup;
		/*[in]*/ DWORD nCmdID;
		/*[in]*/ DWORD nCmdexecopt;
		/*[in,unique]*/ VARIANT* pvaIn;
		HRESULT retValue;
	};

	STDMETHOD(PostExecCommand)(
		/*[in,unique]*/ const GUID* pguidCmdGroup,
		/*[in]*/ DWORD nCmdID,
		/*[in]*/ DWORD nCmdexecopt,
		/*[in,unique]*/ VARIANT* pvaIn)
	{
		VSL_DEFINE_MOCK_METHOD(PostExecCommand)

		VSL_CHECK_VALIDVALUE_POINTER(pguidCmdGroup);

		VSL_CHECK_VALIDVALUE(nCmdID);

		VSL_CHECK_VALIDVALUE(nCmdexecopt);

		VSL_CHECK_VALIDVALUE_POINTER(pvaIn);

		VSL_RETURN_VALIDVALUES();
	}
	struct ShowContextMenuValidValues
	{
		/*[in]*/ DWORD dwCompRole;
		/*[in]*/ REFCLSID rclsidActive;
		/*[in]*/ LONG nMenuId;
		/*[in]*/ REFPOINTS pos;
		/*[in]*/ IOleCommandTarget* pCmdTrgtActive;
		HRESULT retValue;
	};

	STDMETHOD(ShowContextMenu)(
		/*[in]*/ DWORD dwCompRole,
		/*[in]*/ REFCLSID rclsidActive,
		/*[in]*/ LONG nMenuId,
		/*[in]*/ REFPOINTS pos,
		/*[in]*/ IOleCommandTarget* pCmdTrgtActive)
	{
		VSL_DEFINE_MOCK_METHOD(ShowContextMenu)

		VSL_CHECK_VALIDVALUE(dwCompRole);

		VSL_CHECK_VALIDVALUE(rclsidActive);

		VSL_CHECK_VALIDVALUE(nMenuId);

		VSL_CHECK_VALIDVALUE(pos);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCmdTrgtActive);

		VSL_RETURN_VALIDVALUES();
	}
	struct ShowMessageBoxValidValues
	{
		/*[in]*/ DWORD dwCompRole;
		/*[in]*/ REFCLSID rclsidComp;
		/*[in]*/ LPOLESTR pszTitle;
		/*[in]*/ LPOLESTR pszText;
		/*[in]*/ LPOLESTR pszHelpFile;
		/*[in]*/ DWORD dwHelpContextID;
		/*[in]*/ OLEMSGBUTTON msgbtn;
		/*[in]*/ OLEMSGDEFBUTTON msgdefbtn;
		/*[in]*/ OLEMSGICON msgicon;
		/*[in]*/ BOOL fSysAlert;
		/*[out,retval]*/ LONG* pnResult;
		HRESULT retValue;
	};

	STDMETHOD(ShowMessageBox)(
		/*[in]*/ DWORD dwCompRole,
		/*[in]*/ REFCLSID rclsidComp,
		/*[in]*/ _In_z_ LPOLESTR pszTitle,
		/*[in]*/ _In_z_ LPOLESTR pszText,
		/*[in]*/ _In_z_ LPOLESTR pszHelpFile,
		/*[in]*/ DWORD dwHelpContextID,
		/*[in]*/ OLEMSGBUTTON msgbtn,
		/*[in]*/ OLEMSGDEFBUTTON msgdefbtn,
		/*[in]*/ OLEMSGICON msgicon,
		/*[in]*/ BOOL fSysAlert,
		/*[out,retval]*/ LONG* pnResult)
	{
		VSL_DEFINE_MOCK_METHOD(ShowMessageBox)

		VSL_CHECK_VALIDVALUE(dwCompRole);

		VSL_CHECK_VALIDVALUE(rclsidComp);

		VSL_CHECK_VALIDVALUE_STRINGW(pszTitle);

		VSL_CHECK_VALIDVALUE_STRINGW(pszText);

		VSL_CHECK_VALIDVALUE_STRINGW(pszHelpFile);

		VSL_CHECK_VALIDVALUE(dwHelpContextID);

		VSL_CHECK_VALIDVALUE(msgbtn);

		VSL_CHECK_VALIDVALUE(msgdefbtn);

		VSL_CHECK_VALIDVALUE(msgicon);

		VSL_CHECK_VALIDVALUE(fSysAlert);

		VSL_SET_VALIDVALUE(pnResult);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetMRUComboTextValidValues
	{
		/*[in]*/ GUID* pguidCmdGroup;
		/*[in]*/ DWORD dwCmdId;
		/*[in]*/ LPSTR lpszText;
		/*[in]*/ BOOL fAddToList;
		HRESULT retValue;
	};

	STDMETHOD(SetMRUComboText)(
		/*[in]*/ const GUID* pguidCmdGroup,
		/*[in]*/ DWORD dwCmdId,
		/*[in]*/ _In_opt_ LPSTR lpszText,
		/*[in]*/ BOOL fAddToList)
	{
		VSL_DEFINE_MOCK_METHOD(SetMRUComboText)

		VSL_CHECK_VALIDVALUE_POINTER(pguidCmdGroup);

		VSL_CHECK_VALIDVALUE(dwCmdId);

		VSL_CHECK_VALIDVALUE_STRINGA(lpszText);

		VSL_CHECK_VALIDVALUE(fAddToList);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetToolbarVisibleInFullScreenValidValues
	{
		/*[in]*/ GUID* pguidCmdGroup;
		/*[in]*/ DWORD dwToolbarId;
		/*[in]*/ BOOL fVisibleInFullScreen;
		HRESULT retValue;
	};

	STDMETHOD(SetToolbarVisibleInFullScreen)(
		/*[in]*/ const GUID* pguidCmdGroup,
		/*[in]*/ DWORD dwToolbarId,
		/*[in]*/ BOOL fVisibleInFullScreen)
	{
		VSL_DEFINE_MOCK_METHOD(SetToolbarVisibleInFullScreen)

		VSL_CHECK_VALIDVALUE_POINTER(pguidCmdGroup);

		VSL_CHECK_VALIDVALUE(dwToolbarId);

		VSL_CHECK_VALIDVALUE(fVisibleInFullScreen);

		VSL_RETURN_VALIDVALUES();
	}
	struct FindToolWindowExValidValues
	{
		/*[in]*/ VSFINDTOOLWIN grfFTW;
		/*[in]*/ REFGUID rguidPersistenceSlot;
		/*[in]*/ DWORD dwToolWinId;
		/*[out]*/ IVsWindowFrame** ppWindowFrame;
		HRESULT retValue;
	};

	STDMETHOD(FindToolWindowEx)(
		/*[in]*/ VSFINDTOOLWIN grfFTW,
		/*[in]*/ REFGUID rguidPersistenceSlot,
		/*[in]*/ DWORD dwToolWinId,
		/*[out]*/ IVsWindowFrame** ppWindowFrame)
	{
		VSL_DEFINE_MOCK_METHOD(FindToolWindowEx)

		VSL_CHECK_VALIDVALUE(grfFTW);

		VSL_CHECK_VALIDVALUE(rguidPersistenceSlot);

		VSL_CHECK_VALIDVALUE(dwToolWinId);

		VSL_SET_VALIDVALUE_INTERFACE(ppWindowFrame);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetAppNameValidValues
	{
		/*[out]*/ BSTR* pbstrAppName;
		HRESULT retValue;
	};

	STDMETHOD(GetAppName)(
		/*[out]*/ BSTR* pbstrAppName)
	{
		VSL_DEFINE_MOCK_METHOD(GetAppName)

		VSL_SET_VALIDVALUE_BSTR(pbstrAppName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetVSSysColorValidValues
	{
		/*[in]*/ VSSYSCOLOR dwSysColIndex;
		/*[out]*/ DWORD* pdwRGBval;
		HRESULT retValue;
	};

	STDMETHOD(GetVSSysColor)(
		/*[in]*/ VSSYSCOLOR dwSysColIndex,
		/*[out]*/ DWORD* pdwRGBval)
	{
		VSL_DEFINE_MOCK_METHOD(GetVSSysColor)

		VSL_CHECK_VALIDVALUE(dwSysColIndex);

		VSL_SET_VALIDVALUE(pdwRGBval);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetMRUComboTextWValidValues
	{
		/*[in]*/ GUID* pguidCmdGroup;
		/*[in]*/ DWORD dwCmdId;
		/*[in]*/ LPWSTR pwszText;
		/*[in]*/ BOOL fAddToList;
		HRESULT retValue;
	};

	STDMETHOD(SetMRUComboTextW)(
		/*[in]*/ const GUID* pguidCmdGroup,
		/*[in]*/ DWORD dwCmdId,
		/*[in]*/ _In_opt_ LPWSTR pwszText,
		/*[in]*/ BOOL fAddToList)
	{
		VSL_DEFINE_MOCK_METHOD(SetMRUComboTextW)

		VSL_CHECK_VALIDVALUE_POINTER(pguidCmdGroup);

		VSL_CHECK_VALIDVALUE(dwCmdId);

		VSL_CHECK_VALIDVALUE_STRINGW(pwszText);

		VSL_CHECK_VALIDVALUE(fAddToList);

		VSL_RETURN_VALIDVALUES();
	}
	struct PostSetFocusMenuCommandValidValues
	{
		/*[in,unique]*/ GUID* pguidCmdGroup;
		/*[in]*/ DWORD nCmdId;
		HRESULT retValue;
	};

	STDMETHOD(PostSetFocusMenuCommand)(
		/*[in,unique]*/ const GUID* pguidCmdGroup,
		/*[in]*/ DWORD nCmdId)
	{
		VSL_DEFINE_MOCK_METHOD(PostSetFocusMenuCommand)

		VSL_CHECK_VALIDVALUE_POINTER(pguidCmdGroup);

		VSL_CHECK_VALIDVALUE(nCmdId);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCurrentBFNavigationItemValidValues
	{
		/*[out]*/ IVsWindowFrame** ppWindowFrame;
		/*[out]*/ BSTR* pbstrData;
		/*[out]*/ IUnknown** ppunk;
		HRESULT retValue;
	};

	STDMETHOD(GetCurrentBFNavigationItem)(
		/*[out]*/ IVsWindowFrame** ppWindowFrame,
		/*[out]*/ BSTR* pbstrData,
		/*[out]*/ IUnknown** ppunk)
	{
		VSL_DEFINE_MOCK_METHOD(GetCurrentBFNavigationItem)

		VSL_SET_VALIDVALUE_INTERFACE(ppWindowFrame);

		VSL_SET_VALIDVALUE_BSTR(pbstrData);

		VSL_SET_VALIDVALUE_INTERFACE(ppunk);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddNewBFNavigationItemValidValues
	{
		/*[in]*/ IVsWindowFrame* pWindowFrame;
		/*[in]*/ BSTR bstrData;
		/*[in]*/ IUnknown* punk;
		/*[in]*/ BOOL fReplaceCurrent;
		HRESULT retValue;
	};

	STDMETHOD(AddNewBFNavigationItem)(
		/*[in]*/ IVsWindowFrame* pWindowFrame,
		/*[in]*/ BSTR bstrData,
		/*[in]*/ IUnknown* punk,
		/*[in]*/ BOOL fReplaceCurrent)
	{
		VSL_DEFINE_MOCK_METHOD(AddNewBFNavigationItem)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pWindowFrame);

		VSL_CHECK_VALIDVALUE_BSTR(bstrData);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punk);

		VSL_CHECK_VALIDVALUE(fReplaceCurrent);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnModeChangeValidValues
	{
		/*[in]*/ DBGMODE dbgmodeNew;
		HRESULT retValue;
	};

	STDMETHOD(OnModeChange)(
		/*[in]*/ DBGMODE dbgmodeNew)
	{
		VSL_DEFINE_MOCK_METHOD(OnModeChange)

		VSL_CHECK_VALIDVALUE(dbgmodeNew);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetErrorInfoValidValues
	{
		/*[out]*/ BSTR* pbstrErrText;
		HRESULT retValue;
	};

	STDMETHOD(GetErrorInfo)(
		/*[out]*/ BSTR* pbstrErrText)
	{
		VSL_DEFINE_MOCK_METHOD(GetErrorInfo)

		VSL_SET_VALIDVALUE_BSTR(pbstrErrText);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetOpenFileNameViaDlgValidValues
	{
		/*[in,out]*/ VSOPENFILENAMEW* pOpenFileName;
		HRESULT retValue;
	};

	STDMETHOD(GetOpenFileNameViaDlg)(
		/*[in,out]*/ VSOPENFILENAMEW* pOpenFileName)
	{
		VSL_DEFINE_MOCK_METHOD(GetOpenFileNameViaDlg)

		VSL_SET_VALIDVALUE(pOpenFileName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSaveFileNameViaDlgValidValues
	{
		/*[in,out]*/ VSSAVEFILENAMEW* pSaveFileName;
		HRESULT retValue;
	};

	STDMETHOD(GetSaveFileNameViaDlg)(
		/*[in,out]*/ VSSAVEFILENAMEW* pSaveFileName)
	{
		VSL_DEFINE_MOCK_METHOD(GetSaveFileNameViaDlg)

		VSL_SET_VALIDVALUE(pSaveFileName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDirectoryViaBrowseDlgValidValues
	{
		/*[in,out]*/ VSBROWSEINFOW* pBrowse;
		HRESULT retValue;
	};

	STDMETHOD(GetDirectoryViaBrowseDlg)(
		/*[in,out]*/ VSBROWSEINFOW* pBrowse)
	{
		VSL_DEFINE_MOCK_METHOD(GetDirectoryViaBrowseDlg)

		VSL_SET_VALIDVALUE(pBrowse);

		VSL_RETURN_VALIDVALUES();
	}
	struct CenterDialogOnWindowValidValues
	{
		/*[in]*/ HWND hwndDialog;
		/*[in]*/ HWND hwndParent;
		HRESULT retValue;
	};

	STDMETHOD(CenterDialogOnWindow)(
		/*[in]*/ HWND hwndDialog,
		/*[in]*/ HWND hwndParent)
	{
		VSL_DEFINE_MOCK_METHOD(CenterDialogOnWindow)

		VSL_CHECK_VALIDVALUE(hwndDialog);

		VSL_CHECK_VALIDVALUE(hwndParent);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPreviousBFNavigationItemValidValues
	{
		/*[out]*/ IVsWindowFrame** ppWindowFrame;
		/*[out]*/ BSTR* pbstrData;
		/*[out]*/ IUnknown** ppunk;
		HRESULT retValue;
	};

	STDMETHOD(GetPreviousBFNavigationItem)(
		/*[out]*/ IVsWindowFrame** ppWindowFrame,
		/*[out]*/ BSTR* pbstrData,
		/*[out]*/ IUnknown** ppunk)
	{
		VSL_DEFINE_MOCK_METHOD(GetPreviousBFNavigationItem)

		VSL_SET_VALIDVALUE_INTERFACE(ppWindowFrame);

		VSL_SET_VALIDVALUE_BSTR(pbstrData);

		VSL_SET_VALIDVALUE_INTERFACE(ppunk);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetNextBFNavigationItemValidValues
	{
		/*[out]*/ IVsWindowFrame** ppWindowFrame;
		/*[out]*/ BSTR* pbstrData;
		/*[out]*/ IUnknown** ppunk;
		HRESULT retValue;
	};

	STDMETHOD(GetNextBFNavigationItem)(
		/*[out]*/ IVsWindowFrame** ppWindowFrame,
		/*[out]*/ BSTR* pbstrData,
		/*[out]*/ IUnknown** ppunk)
	{
		VSL_DEFINE_MOCK_METHOD(GetNextBFNavigationItem)

		VSL_SET_VALIDVALUE_INTERFACE(ppWindowFrame);

		VSL_SET_VALIDVALUE_BSTR(pbstrData);

		VSL_SET_VALIDVALUE_INTERFACE(ppunk);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetURLViaDlgValidValues
	{
		/*[in]*/ LPCOLESTR pszDlgTitle;
		/*[in]*/ LPCOLESTR pszStaticLabel;
		/*[in]*/ LPCOLESTR pszHelpTopic;
		/*[out]*/ BSTR* pbstrURL;
		HRESULT retValue;
	};

	STDMETHOD(GetURLViaDlg)(
		/*[in]*/ LPCOLESTR pszDlgTitle,
		/*[in]*/ LPCOLESTR pszStaticLabel,
		/*[in]*/ LPCOLESTR pszHelpTopic,
		/*[out]*/ BSTR* pbstrURL)
	{
		VSL_DEFINE_MOCK_METHOD(GetURLViaDlg)

		VSL_CHECK_VALIDVALUE_STRINGW(pszDlgTitle);

		VSL_CHECK_VALIDVALUE_STRINGW(pszStaticLabel);

		VSL_CHECK_VALIDVALUE_STRINGW(pszHelpTopic);

		VSL_SET_VALIDVALUE_BSTR(pbstrURL);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveAdjacentBFNavigationItemValidValues
	{
		/*[in]*/ RemoveBFDirection rdDir;
		HRESULT retValue;
	};

	STDMETHOD(RemoveAdjacentBFNavigationItem)(
		/*[in]*/ RemoveBFDirection rdDir)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveAdjacentBFNavigationItem)

		VSL_CHECK_VALIDVALUE(rdDir);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveCurrentNavigationDupesValidValues
	{
		/*[in]*/ RemoveBFDirection rdDir;
		HRESULT retValue;
	};

	STDMETHOD(RemoveCurrentNavigationDupes)(
		/*[in]*/ RemoveBFDirection rdDir)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveCurrentNavigationDupes)

		VSL_CHECK_VALIDVALUE(rdDir);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSUISHELL_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsUIShell2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSUISHELL2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSUISHELL2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsUIShell2NotImpl :
	public IVsUIShell2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUIShell2NotImpl)

public:

	typedef IVsUIShell2 Interface;

	STDMETHOD(GetOpenFileNameViaDlgEx)(
		/*[in,out]*/ VSOPENFILENAMEW* /*pOpenFileName*/,
		/*[in]*/ LPCOLESTR /*pszHelpTopic*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSaveFileNameViaDlgEx)(
		/*[in,out]*/ VSSAVEFILENAMEW* /*pSaveFileName*/,
		/*[in]*/ LPCOLESTR /*pszHelpTopic*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDirectoryViaBrowseDlgEx)(
		/*[in,out]*/ VSBROWSEINFOW* /*pBrowse*/,
		/*[in]*/ LPCOLESTR /*pszHelpTopic*/,
		/*[in]*/ LPCOLESTR /*pszOpenButtonLabel*/,
		/*[in]*/ LPCOLESTR /*pszCeilingDir*/,
		/*[in]*/ VSNSEBROWSEINFOW* /*pNSEBrowseInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SaveItemsViaDlg)(
		/*[in]*/ UINT /*cItems*/,
		/*[in,size_is(cItems)]*/ VSSAVETREEITEM[] /*rgSaveItems*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetVSSysColorEx)(
		/*[in]*/ VSSYSCOLOREX /*dwSysColIndex*/,
		/*[out]*/ DWORD* /*pdwRGBval*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateGradient)(
		/*[in]*/ GRADIENTTYPE /*gradientType*/,
		/*[out]*/ IVsGradient** /*pGradient*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetVSCursor)(
		/*[in]*/ VSCURSORTYPE /*cursor*/,
		/*[out]*/ HCURSOR* /*phIcon*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsAutoRecoverSavingCheckpoints)(
		/*[out]*/ BOOL* /*pfARSaving*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(VsDialogBoxParam)(
		/*[in]*/ HINSTANCE /*hinst*/,
		/*[in]*/ DWORD /*dwId*/,
		/*[in]*/ DLGPROC /*lpDialogFunc*/,
		/*[in]*/ LPARAM /*lp*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateIconImageButton)(
		/*[in]*/ HWND /*hwnd*/,
		/*[in]*/ HICON /*hicon*/,
		/*[in]*/ BWI_IMAGE_POS /*bwiPos*/,
		/*[out]*/ IVsImageButton** /*ppImageButton*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateGlyphImageButton)(
		/*[in]*/ HWND /*hwnd*/,
		/*[in]*/ WCHAR /*chGlyph*/,
		/*[in]*/ int /*xShift*/,
		/*[in]*/ int /*yShift*/,
		/*[in]*/ BWI_IMAGE_POS /*bwiPos*/,
		/*[out]*/ IVsImageButton** /*ppImageButton*/)VSL_STDMETHOD_NOTIMPL
};

class IVsUIShell2MockImpl :
	public IVsUIShell2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUIShell2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsUIShell2MockImpl)

	typedef IVsUIShell2 Interface;
	struct GetOpenFileNameViaDlgExValidValues
	{
		/*[in,out]*/ VSOPENFILENAMEW* pOpenFileName;
		/*[in]*/ LPCOLESTR pszHelpTopic;
		HRESULT retValue;
	};

	STDMETHOD(GetOpenFileNameViaDlgEx)(
		/*[in,out]*/ VSOPENFILENAMEW* pOpenFileName,
		/*[in]*/ LPCOLESTR pszHelpTopic)
	{
		VSL_DEFINE_MOCK_METHOD(GetOpenFileNameViaDlgEx)

		VSL_SET_VALIDVALUE(pOpenFileName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszHelpTopic);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSaveFileNameViaDlgExValidValues
	{
		/*[in,out]*/ VSSAVEFILENAMEW* pSaveFileName;
		/*[in]*/ LPCOLESTR pszHelpTopic;
		HRESULT retValue;
	};

	STDMETHOD(GetSaveFileNameViaDlgEx)(
		/*[in,out]*/ VSSAVEFILENAMEW* pSaveFileName,
		/*[in]*/ LPCOLESTR pszHelpTopic)
	{
		VSL_DEFINE_MOCK_METHOD(GetSaveFileNameViaDlgEx)

		VSL_SET_VALIDVALUE(pSaveFileName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszHelpTopic);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDirectoryViaBrowseDlgExValidValues
	{
		/*[in,out]*/ VSBROWSEINFOW* pBrowse;
		/*[in]*/ LPCOLESTR pszHelpTopic;
		/*[in]*/ LPCOLESTR pszOpenButtonLabel;
		/*[in]*/ LPCOLESTR pszCeilingDir;
		/*[in]*/ VSNSEBROWSEINFOW* pNSEBrowseInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetDirectoryViaBrowseDlgEx)(
		/*[in,out]*/ VSBROWSEINFOW* pBrowse,
		/*[in]*/ LPCOLESTR pszHelpTopic,
		/*[in]*/ LPCOLESTR pszOpenButtonLabel,
		/*[in]*/ LPCOLESTR pszCeilingDir,
		/*[in]*/ VSNSEBROWSEINFOW* pNSEBrowseInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetDirectoryViaBrowseDlgEx)

		VSL_SET_VALIDVALUE(pBrowse);

		VSL_CHECK_VALIDVALUE_STRINGW(pszHelpTopic);

		VSL_CHECK_VALIDVALUE_STRINGW(pszOpenButtonLabel);

		VSL_CHECK_VALIDVALUE_STRINGW(pszCeilingDir);

		VSL_CHECK_VALIDVALUE_POINTER(pNSEBrowseInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct SaveItemsViaDlgValidValues
	{
		/*[in]*/ UINT cItems;
		/*[in,size_is(cItems)]*/ VSSAVETREEITEM* rgSaveItems;
		HRESULT retValue;
	};

	STDMETHOD(SaveItemsViaDlg)(
		/*[in]*/ UINT cItems,
		/*[in,size_is(cItems)]*/ VSSAVETREEITEM rgSaveItems[])
	{
		VSL_DEFINE_MOCK_METHOD(SaveItemsViaDlg)

		VSL_CHECK_VALIDVALUE(cItems);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgSaveItems, cItems*sizeof(rgSaveItems[0]), validValues.cItems*sizeof(validValues.rgSaveItems[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct GetVSSysColorExValidValues
	{
		/*[in]*/ VSSYSCOLOREX dwSysColIndex;
		/*[out]*/ DWORD* pdwRGBval;
		HRESULT retValue;
	};

	STDMETHOD(GetVSSysColorEx)(
		/*[in]*/ VSSYSCOLOREX dwSysColIndex,
		/*[out]*/ DWORD* pdwRGBval)
	{
		VSL_DEFINE_MOCK_METHOD(GetVSSysColorEx)

		VSL_CHECK_VALIDVALUE(dwSysColIndex);

		VSL_SET_VALIDVALUE(pdwRGBval);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateGradientValidValues
	{
		/*[in]*/ GRADIENTTYPE gradientType;
		/*[out]*/ IVsGradient** pGradient;
		HRESULT retValue;
	};

	STDMETHOD(CreateGradient)(
		/*[in]*/ GRADIENTTYPE gradientType,
		/*[out]*/ IVsGradient** pGradient)
	{
		VSL_DEFINE_MOCK_METHOD(CreateGradient)

		VSL_CHECK_VALIDVALUE(gradientType);

		VSL_SET_VALIDVALUE_INTERFACE(pGradient);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetVSCursorValidValues
	{
		/*[in]*/ VSCURSORTYPE cursor;
		/*[out]*/ HCURSOR* phIcon;
		HRESULT retValue;
	};

	STDMETHOD(GetVSCursor)(
		/*[in]*/ VSCURSORTYPE cursor,
		/*[out]*/ HCURSOR* phIcon)
	{
		VSL_DEFINE_MOCK_METHOD(GetVSCursor)

		VSL_CHECK_VALIDVALUE(cursor);

		VSL_SET_VALIDVALUE(phIcon);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsAutoRecoverSavingCheckpointsValidValues
	{
		/*[out]*/ BOOL* pfARSaving;
		HRESULT retValue;
	};

	STDMETHOD(IsAutoRecoverSavingCheckpoints)(
		/*[out]*/ BOOL* pfARSaving)
	{
		VSL_DEFINE_MOCK_METHOD(IsAutoRecoverSavingCheckpoints)

		VSL_SET_VALIDVALUE(pfARSaving);

		VSL_RETURN_VALIDVALUES();
	}
	struct VsDialogBoxParamValidValues
	{
		/*[in]*/ HINSTANCE hinst;
		/*[in]*/ DWORD dwId;
		/*[in]*/ DLGPROC lpDialogFunc;
		/*[in]*/ LPARAM lp;
		HRESULT retValue;
	};

	STDMETHOD(VsDialogBoxParam)(
		/*[in]*/ HINSTANCE hinst,
		/*[in]*/ DWORD dwId,
		/*[in]*/ DLGPROC lpDialogFunc,
		/*[in]*/ LPARAM lp)
	{
		VSL_DEFINE_MOCK_METHOD(VsDialogBoxParam)

		VSL_CHECK_VALIDVALUE(hinst);

		VSL_CHECK_VALIDVALUE(dwId);

		VSL_CHECK_VALIDVALUE(lpDialogFunc);

		VSL_CHECK_VALIDVALUE(lp);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateIconImageButtonValidValues
	{
		/*[in]*/ HWND hwnd;
		/*[in]*/ HICON hicon;
		/*[in]*/ BWI_IMAGE_POS bwiPos;
		/*[out]*/ IVsImageButton** ppImageButton;
		HRESULT retValue;
	};

	STDMETHOD(CreateIconImageButton)(
		/*[in]*/ HWND hwnd,
		/*[in]*/ HICON hicon,
		/*[in]*/ BWI_IMAGE_POS bwiPos,
		/*[out]*/ IVsImageButton** ppImageButton)
	{
		VSL_DEFINE_MOCK_METHOD(CreateIconImageButton)

		VSL_CHECK_VALIDVALUE(hwnd);

		VSL_CHECK_VALIDVALUE(hicon);

		VSL_CHECK_VALIDVALUE(bwiPos);

		VSL_SET_VALIDVALUE_INTERFACE(ppImageButton);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateGlyphImageButtonValidValues
	{
		/*[in]*/ HWND hwnd;
		/*[in]*/ WCHAR chGlyph;
		/*[in]*/ int xShift;
		/*[in]*/ int yShift;
		/*[in]*/ BWI_IMAGE_POS bwiPos;
		/*[out]*/ IVsImageButton** ppImageButton;
		HRESULT retValue;
	};

	STDMETHOD(CreateGlyphImageButton)(
		/*[in]*/ HWND hwnd,
		/*[in]*/ WCHAR chGlyph,
		/*[in]*/ int xShift,
		/*[in]*/ int yShift,
		/*[in]*/ BWI_IMAGE_POS bwiPos,
		/*[out]*/ IVsImageButton** ppImageButton)
	{
		VSL_DEFINE_MOCK_METHOD(CreateGlyphImageButton)

		VSL_CHECK_VALIDVALUE(hwnd);

		VSL_CHECK_VALIDVALUE(chGlyph);

		VSL_CHECK_VALIDVALUE(xShift);

		VSL_CHECK_VALIDVALUE(yShift);

		VSL_CHECK_VALIDVALUE(bwiPos);

		VSL_SET_VALIDVALUE_INTERFACE(ppImageButton);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSUISHELL2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsUIShellOpenDocument.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSUISHELLOPENDOCUMENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSUISHELLOPENDOCUMENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsUIShellOpenDocumentNotImpl :
	public IVsUIShellOpenDocument
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUIShellOpenDocumentNotImpl)

public:

	typedef IVsUIShellOpenDocument Interface;

	STDMETHOD(IsDocumentOpen)(
		/*[in]*/ IVsUIHierarchy* /*pHierCaller*/,
		/*[in]*/ VSITEMID /*itemidCaller*/,
		/*[in]*/ LPCOLESTR /*pszMkDocument*/,
		/*[in]*/ REFGUID /*rguidLogicalView*/,
		/*[in]*/ VSIDOFLAGS /*grfIDO*/,
		/*[out]*/ IVsUIHierarchy** /*ppHierOpen*/,
		/*[out]*/ VSITEMID* /*pitemidOpen*/,
		/*[out]*/ IVsWindowFrame** /*ppWindowFrame*/,
		/*[out,retval]*/ BOOL* /*pfOpen*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsDocumentInAProject)(
		/*[in]*/ LPCOLESTR /*pszMkDocument*/,
		/*[out]*/ IVsUIHierarchy** /*ppUIH*/,
		/*[out]*/ VSITEMID* /*pitemid*/,
		/*[out]*/ IServiceProvider** /*ppSP*/,
		/*[out,retval]*/ VSDOCINPROJECT* /*pDocInProj*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OpenDocumentViaProject)(
		/*[in]*/ LPCOLESTR /*pszMkDocument*/,
		/*[in]*/ REFGUID /*rguidLogicalView*/,
		/*[out]*/ IServiceProvider** /*ppSP*/,
		/*[out]*/ IVsUIHierarchy** /*ppHier*/,
		/*[out]*/ VSITEMID* /*pitemid*/,
		/*[out,retval]*/ IVsWindowFrame** /*ppWindowFrame*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OpenStandardEditor)(
		/*[in]*/ VSOSEFLAGS /*grfOpenStandard*/,
		/*[in]*/ LPCOLESTR /*pszMkDocument*/,
		/*[in]*/ REFGUID /*rguidLogicalView*/,
		/*[in]*/ LPCOLESTR /*pszOwnerCaption*/,
		/*[in]*/ IVsUIHierarchy* /*pHier*/,
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ IUnknown* /*punkDocDataExisting*/,
		/*[in]*/ IServiceProvider* /*pSP*/,
		/*[out,retval]*/ IVsWindowFrame** /*ppWindowFrame*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OpenStandardPreviewer)(
		/*[in]*/ VSOSPFLAGS /*ospOpenDocPreviewer*/,
		/*[in]*/ LPCOLESTR /*pszURL*/,
		/*[in]*/ VSPREVIEWRESOLUTION /*resolution*/,
		/*[in]*/ DWORD /*dwReserved*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetStandardEditorFactory)(
		/*[in]*/ DWORD /*dwReserved*/,
		/*[in,out]*/ GUID* /*pguidEditorType*/,
		/*[in]*/ LPCOLESTR /*pszMkDocument*/,
		/*[in]*/ REFGUID /*rguidLogicalView*/,
		/*[out]*/ BSTR* /*pbstrPhysicalView*/,
		/*[out,retval]*/ IVsEditorFactory** /*ppEF*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(MapLogicalView)(
		/*[in]*/ REFGUID /*rguidEditorType*/,
		/*[in]*/ REFGUID /*rguidLogicalView*/,
		/*[out,retval]*/ BSTR* /*pbstrPhysicalView*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OpenSpecificEditor)(
		/*[in]*/ VSOSPEFLAGS /*grfOpenSpecific*/,
		/*[in]*/ LPCOLESTR /*pszMkDocument*/,
		/*[in]*/ REFGUID /*rguidEditorType*/,
		/*[in]*/ LPCOLESTR /*pszPhysicalView*/,
		/*[in]*/ REFGUID /*rguidLogicalView*/,
		/*[in]*/ LPCOLESTR /*pszOwnerCaption*/,
		/*[in]*/ IVsUIHierarchy* /*pHier*/,
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ IUnknown* /*punkDocDataExisting*/,
		/*[in]*/ IServiceProvider* /*pSPHierContext*/,
		/*[out,retval]*/ IVsWindowFrame** /*ppWindowFrame*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(InitializeEditorInstance)(
		/*[in]*/ VSIEIFLAGS /*grfIEI*/,
		/*[in]*/ IUnknown* /*punkDocView*/,
		/*[in]*/ IUnknown* /*punkDocData*/,
		/*[in]*/ LPCOLESTR /*pszMkDocument*/,
		/*[in]*/ REFGUID /*rguidEditorType*/,
		/*[in]*/ LPCOLESTR /*pszPhysicalView*/,
		/*[in]*/ REFGUID /*rguidLogicalView*/,
		/*[in]*/ LPCOLESTR /*pszOwnerCaption*/,
		/*[in]*/ LPCOLESTR /*pszEditorCaption*/,
		/*[in]*/ IVsUIHierarchy* /*pHier*/,
		/*[in]*/ VSITEMID /*itemid*/,
		/*[in]*/ IUnknown* /*punkDocDataExisting*/,
		/*[in]*/ IServiceProvider* /*pSPHierContext*/,
		/*[in]*/ REFGUID /*rguidCmdUI*/,
		/*[out,retval]*/ IVsWindowFrame** /*ppWindowFrame*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsSpecificDocumentViewOpen)(
		/*[in]*/ IVsUIHierarchy* /*pHierCaller*/,
		/*[in]*/ VSITEMID /*itemidCaller*/,
		/*[in]*/ LPCOLESTR /*pszMkDocument*/,
		/*[in]*/ REFGUID /*rguidEditorType*/,
		/*[in]*/ LPCOLESTR /*pszPhysicalView*/,
		/*[in]*/ VSIDOFLAGS /*grfIDO*/,
		/*[out]*/ IVsUIHierarchy** /*ppHierOpen*/,
		/*[out]*/ VSITEMID* /*pitemidOpen*/,
		/*[out]*/ IVsWindowFrame** /*ppWindowFrame*/,
		/*[out,retval]*/ BOOL* /*pfOpen*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OpenDocumentViaProjectWithSpecific)(
		/*[in]*/ LPCOLESTR /*pszMkDocument*/,
		/*[in]*/ VSSPECIFICEDITORFLAGS /*grfEditorFlags*/,
		/*[in]*/ REFGUID /*rguidEditorType*/,
		/*[in]*/ LPCOLESTR /*pszPhysicalView*/,
		/*[in]*/ REFGUID /*rguidLogicalView*/,
		/*[out]*/ IServiceProvider** /*ppSP*/,
		/*[out]*/ IVsUIHierarchy** /*ppHier*/,
		/*[out]*/ VSITEMID* /*pitemid*/,
		/*[out,retval]*/ IVsWindowFrame** /*ppWindowFrame*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OpenCopyOfStandardEditor)(
		/*[in]*/ IVsWindowFrame* /*pWindowFrame*/,
		/*[in]*/ REFGUID /*rguidLogicalView*/,
		/*[out,retval]*/ IVsWindowFrame** /*ppNewWindowFrame*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetFirstDefaultPreviewer)(
		/*[out]*/ BSTR* /*pbstrDefBrowserPath*/,
		/*[out]*/ BOOL* /*pfIsInternalBrowser*/,
		/*[out]*/ BOOL* /*pfIsSystemBrowser*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SearchProjectsForRelativePath)(
		/*[in]*/ VSRELPATHSEARCHFLAGS /*grfRPS*/,
		/*[in]*/ LPCOLESTR /*pszRelPath*/,
		/*[out,retval]*/ BSTR* /*pbstrAbsPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddStandardPreviewer)(
		/*[in]*/ LPCOLESTR /*pszExePath*/,
		/*[in]*/ LPCOLESTR /*pszDisplayName*/,
		/*[in]*/ BOOL /*fUseDDE*/,
		/*[in]*/ LPCOLESTR /*pszDDEService*/,
		/*[in]*/ LPCOLESTR /*pszDDETopicOpenURL*/,
		/*[in]*/ LPCOLESTR /*pszDDEItemOpenURL*/,
		/*[in]*/ LPCOLESTR /*pszDDETopicActivate*/,
		/*[in]*/ LPCOLESTR /*pszDDEItemActivate*/,
		/*[in]*/ VSASPFLAGS /*aspAddPreviewerFlags*/)VSL_STDMETHOD_NOTIMPL
};

class IVsUIShellOpenDocumentMockImpl :
	public IVsUIShellOpenDocument,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUIShellOpenDocumentMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsUIShellOpenDocumentMockImpl)

	typedef IVsUIShellOpenDocument Interface;
	struct IsDocumentOpenValidValues
	{
		/*[in]*/ IVsUIHierarchy* pHierCaller;
		/*[in]*/ VSITEMID itemidCaller;
		/*[in]*/ LPCOLESTR pszMkDocument;
		/*[in]*/ REFGUID rguidLogicalView;
		/*[in]*/ VSIDOFLAGS grfIDO;
		/*[out]*/ IVsUIHierarchy** ppHierOpen;
		/*[out]*/ VSITEMID* pitemidOpen;
		/*[out]*/ IVsWindowFrame** ppWindowFrame;
		/*[out,retval]*/ BOOL* pfOpen;
		HRESULT retValue;
	};

	STDMETHOD(IsDocumentOpen)(
		/*[in]*/ IVsUIHierarchy* pHierCaller,
		/*[in]*/ VSITEMID itemidCaller,
		/*[in]*/ LPCOLESTR pszMkDocument,
		/*[in]*/ REFGUID rguidLogicalView,
		/*[in]*/ VSIDOFLAGS grfIDO,
		/*[out]*/ IVsUIHierarchy** ppHierOpen,
		/*[out]*/ VSITEMID* pitemidOpen,
		/*[out]*/ IVsWindowFrame** ppWindowFrame,
		/*[out,retval]*/ BOOL* pfOpen)
	{
		VSL_DEFINE_MOCK_METHOD(IsDocumentOpen)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierCaller);

		VSL_CHECK_VALIDVALUE(itemidCaller);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_CHECK_VALIDVALUE(rguidLogicalView);

		VSL_CHECK_VALIDVALUE(grfIDO);

		VSL_SET_VALIDVALUE_INTERFACE(ppHierOpen);

		VSL_SET_VALIDVALUE(pitemidOpen);

		VSL_SET_VALIDVALUE_INTERFACE(ppWindowFrame);

		VSL_SET_VALIDVALUE(pfOpen);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsDocumentInAProjectValidValues
	{
		/*[in]*/ LPCOLESTR pszMkDocument;
		/*[out]*/ IVsUIHierarchy** ppUIH;
		/*[out]*/ VSITEMID* pitemid;
		/*[out]*/ IServiceProvider** ppSP;
		/*[out,retval]*/ VSDOCINPROJECT* pDocInProj;
		HRESULT retValue;
	};

	STDMETHOD(IsDocumentInAProject)(
		/*[in]*/ LPCOLESTR pszMkDocument,
		/*[out]*/ IVsUIHierarchy** ppUIH,
		/*[out]*/ VSITEMID* pitemid,
		/*[out]*/ IServiceProvider** ppSP,
		/*[out,retval]*/ VSDOCINPROJECT* pDocInProj)
	{
		VSL_DEFINE_MOCK_METHOD(IsDocumentInAProject)

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_SET_VALIDVALUE_INTERFACE(ppUIH);

		VSL_SET_VALIDVALUE(pitemid);

		VSL_SET_VALIDVALUE_INTERFACE(ppSP);

		VSL_SET_VALIDVALUE(pDocInProj);

		VSL_RETURN_VALIDVALUES();
	}
	struct OpenDocumentViaProjectValidValues
	{
		/*[in]*/ LPCOLESTR pszMkDocument;
		/*[in]*/ REFGUID rguidLogicalView;
		/*[out]*/ IServiceProvider** ppSP;
		/*[out]*/ IVsUIHierarchy** ppHier;
		/*[out]*/ VSITEMID* pitemid;
		/*[out,retval]*/ IVsWindowFrame** ppWindowFrame;
		HRESULT retValue;
	};

	STDMETHOD(OpenDocumentViaProject)(
		/*[in]*/ LPCOLESTR pszMkDocument,
		/*[in]*/ REFGUID rguidLogicalView,
		/*[out]*/ IServiceProvider** ppSP,
		/*[out]*/ IVsUIHierarchy** ppHier,
		/*[out]*/ VSITEMID* pitemid,
		/*[out,retval]*/ IVsWindowFrame** ppWindowFrame)
	{
		VSL_DEFINE_MOCK_METHOD(OpenDocumentViaProject)

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_CHECK_VALIDVALUE(rguidLogicalView);

		VSL_SET_VALIDVALUE_INTERFACE(ppSP);

		VSL_SET_VALIDVALUE_INTERFACE(ppHier);

		VSL_SET_VALIDVALUE(pitemid);

		VSL_SET_VALIDVALUE_INTERFACE(ppWindowFrame);

		VSL_RETURN_VALIDVALUES();
	}
	struct OpenStandardEditorValidValues
	{
		/*[in]*/ VSOSEFLAGS grfOpenStandard;
		/*[in]*/ LPCOLESTR pszMkDocument;
		/*[in]*/ REFGUID rguidLogicalView;
		/*[in]*/ LPCOLESTR pszOwnerCaption;
		/*[in]*/ IVsUIHierarchy* pHier;
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ IUnknown* punkDocDataExisting;
		/*[in]*/ IServiceProvider* pSP;
		/*[out,retval]*/ IVsWindowFrame** ppWindowFrame;
		HRESULT retValue;
	};

	STDMETHOD(OpenStandardEditor)(
		/*[in]*/ VSOSEFLAGS grfOpenStandard,
		/*[in]*/ LPCOLESTR pszMkDocument,
		/*[in]*/ REFGUID rguidLogicalView,
		/*[in]*/ LPCOLESTR pszOwnerCaption,
		/*[in]*/ IVsUIHierarchy* pHier,
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ IUnknown* punkDocDataExisting,
		/*[in]*/ IServiceProvider* pSP,
		/*[out,retval]*/ IVsWindowFrame** ppWindowFrame)
	{
		VSL_DEFINE_MOCK_METHOD(OpenStandardEditor)

		VSL_CHECK_VALIDVALUE(grfOpenStandard);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_CHECK_VALIDVALUE(rguidLogicalView);

		VSL_CHECK_VALIDVALUE_STRINGW(pszOwnerCaption);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHier);

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkDocDataExisting);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSP);

		VSL_SET_VALIDVALUE_INTERFACE(ppWindowFrame);

		VSL_RETURN_VALIDVALUES();
	}
	struct OpenStandardPreviewerValidValues
	{
		/*[in]*/ VSOSPFLAGS ospOpenDocPreviewer;
		/*[in]*/ LPCOLESTR pszURL;
		/*[in]*/ VSPREVIEWRESOLUTION resolution;
		/*[in]*/ DWORD dwReserved;
		HRESULT retValue;
	};

	STDMETHOD(OpenStandardPreviewer)(
		/*[in]*/ VSOSPFLAGS ospOpenDocPreviewer,
		/*[in]*/ LPCOLESTR pszURL,
		/*[in]*/ VSPREVIEWRESOLUTION resolution,
		/*[in]*/ DWORD dwReserved)
	{
		VSL_DEFINE_MOCK_METHOD(OpenStandardPreviewer)

		VSL_CHECK_VALIDVALUE(ospOpenDocPreviewer);

		VSL_CHECK_VALIDVALUE_STRINGW(pszURL);

		VSL_CHECK_VALIDVALUE(resolution);

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetStandardEditorFactoryValidValues
	{
		/*[in]*/ DWORD dwReserved;
		/*[in,out]*/ GUID* pguidEditorType;
		/*[in]*/ LPCOLESTR pszMkDocument;
		/*[in]*/ REFGUID rguidLogicalView;
		/*[out]*/ BSTR* pbstrPhysicalView;
		/*[out,retval]*/ IVsEditorFactory** ppEF;
		HRESULT retValue;
	};

	STDMETHOD(GetStandardEditorFactory)(
		/*[in]*/ DWORD dwReserved,
		/*[in,out]*/ GUID* pguidEditorType,
		/*[in]*/ LPCOLESTR pszMkDocument,
		/*[in]*/ REFGUID rguidLogicalView,
		/*[out]*/ BSTR* pbstrPhysicalView,
		/*[out,retval]*/ IVsEditorFactory** ppEF)
	{
		VSL_DEFINE_MOCK_METHOD(GetStandardEditorFactory)

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_SET_VALIDVALUE(pguidEditorType);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_CHECK_VALIDVALUE(rguidLogicalView);

		VSL_SET_VALIDVALUE_BSTR(pbstrPhysicalView);

		VSL_SET_VALIDVALUE_INTERFACE(ppEF);

		VSL_RETURN_VALIDVALUES();
	}
	struct MapLogicalViewValidValues
	{
		/*[in]*/ REFGUID rguidEditorType;
		/*[in]*/ REFGUID rguidLogicalView;
		/*[out,retval]*/ BSTR* pbstrPhysicalView;
		HRESULT retValue;
	};

	STDMETHOD(MapLogicalView)(
		/*[in]*/ REFGUID rguidEditorType,
		/*[in]*/ REFGUID rguidLogicalView,
		/*[out,retval]*/ BSTR* pbstrPhysicalView)
	{
		VSL_DEFINE_MOCK_METHOD(MapLogicalView)

		VSL_CHECK_VALIDVALUE(rguidEditorType);

		VSL_CHECK_VALIDVALUE(rguidLogicalView);

		VSL_SET_VALIDVALUE_BSTR(pbstrPhysicalView);

		VSL_RETURN_VALIDVALUES();
	}
	struct OpenSpecificEditorValidValues
	{
		/*[in]*/ VSOSPEFLAGS grfOpenSpecific;
		/*[in]*/ LPCOLESTR pszMkDocument;
		/*[in]*/ REFGUID rguidEditorType;
		/*[in]*/ LPCOLESTR pszPhysicalView;
		/*[in]*/ REFGUID rguidLogicalView;
		/*[in]*/ LPCOLESTR pszOwnerCaption;
		/*[in]*/ IVsUIHierarchy* pHier;
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ IUnknown* punkDocDataExisting;
		/*[in]*/ IServiceProvider* pSPHierContext;
		/*[out,retval]*/ IVsWindowFrame** ppWindowFrame;
		HRESULT retValue;
	};

	STDMETHOD(OpenSpecificEditor)(
		/*[in]*/ VSOSPEFLAGS grfOpenSpecific,
		/*[in]*/ LPCOLESTR pszMkDocument,
		/*[in]*/ REFGUID rguidEditorType,
		/*[in]*/ LPCOLESTR pszPhysicalView,
		/*[in]*/ REFGUID rguidLogicalView,
		/*[in]*/ LPCOLESTR pszOwnerCaption,
		/*[in]*/ IVsUIHierarchy* pHier,
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ IUnknown* punkDocDataExisting,
		/*[in]*/ IServiceProvider* pSPHierContext,
		/*[out,retval]*/ IVsWindowFrame** ppWindowFrame)
	{
		VSL_DEFINE_MOCK_METHOD(OpenSpecificEditor)

		VSL_CHECK_VALIDVALUE(grfOpenSpecific);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_CHECK_VALIDVALUE(rguidEditorType);

		VSL_CHECK_VALIDVALUE_STRINGW(pszPhysicalView);

		VSL_CHECK_VALIDVALUE(rguidLogicalView);

		VSL_CHECK_VALIDVALUE_STRINGW(pszOwnerCaption);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHier);

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkDocDataExisting);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSPHierContext);

		VSL_SET_VALIDVALUE_INTERFACE(ppWindowFrame);

		VSL_RETURN_VALIDVALUES();
	}
	struct InitializeEditorInstanceValidValues
	{
		/*[in]*/ VSIEIFLAGS grfIEI;
		/*[in]*/ IUnknown* punkDocView;
		/*[in]*/ IUnknown* punkDocData;
		/*[in]*/ LPCOLESTR pszMkDocument;
		/*[in]*/ REFGUID rguidEditorType;
		/*[in]*/ LPCOLESTR pszPhysicalView;
		/*[in]*/ REFGUID rguidLogicalView;
		/*[in]*/ LPCOLESTR pszOwnerCaption;
		/*[in]*/ LPCOLESTR pszEditorCaption;
		/*[in]*/ IVsUIHierarchy* pHier;
		/*[in]*/ VSITEMID itemid;
		/*[in]*/ IUnknown* punkDocDataExisting;
		/*[in]*/ IServiceProvider* pSPHierContext;
		/*[in]*/ REFGUID rguidCmdUI;
		/*[out,retval]*/ IVsWindowFrame** ppWindowFrame;
		HRESULT retValue;
	};

	STDMETHOD(InitializeEditorInstance)(
		/*[in]*/ VSIEIFLAGS grfIEI,
		/*[in]*/ IUnknown* punkDocView,
		/*[in]*/ IUnknown* punkDocData,
		/*[in]*/ LPCOLESTR pszMkDocument,
		/*[in]*/ REFGUID rguidEditorType,
		/*[in]*/ LPCOLESTR pszPhysicalView,
		/*[in]*/ REFGUID rguidLogicalView,
		/*[in]*/ LPCOLESTR pszOwnerCaption,
		/*[in]*/ LPCOLESTR pszEditorCaption,
		/*[in]*/ IVsUIHierarchy* pHier,
		/*[in]*/ VSITEMID itemid,
		/*[in]*/ IUnknown* punkDocDataExisting,
		/*[in]*/ IServiceProvider* pSPHierContext,
		/*[in]*/ REFGUID rguidCmdUI,
		/*[out,retval]*/ IVsWindowFrame** ppWindowFrame)
	{
		VSL_DEFINE_MOCK_METHOD(InitializeEditorInstance)

		VSL_CHECK_VALIDVALUE(grfIEI);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkDocView);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkDocData);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_CHECK_VALIDVALUE(rguidEditorType);

		VSL_CHECK_VALIDVALUE_STRINGW(pszPhysicalView);

		VSL_CHECK_VALIDVALUE(rguidLogicalView);

		VSL_CHECK_VALIDVALUE_STRINGW(pszOwnerCaption);

		VSL_CHECK_VALIDVALUE_STRINGW(pszEditorCaption);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHier);

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(punkDocDataExisting);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSPHierContext);

		VSL_CHECK_VALIDVALUE(rguidCmdUI);

		VSL_SET_VALIDVALUE_INTERFACE(ppWindowFrame);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsSpecificDocumentViewOpenValidValues
	{
		/*[in]*/ IVsUIHierarchy* pHierCaller;
		/*[in]*/ VSITEMID itemidCaller;
		/*[in]*/ LPCOLESTR pszMkDocument;
		/*[in]*/ REFGUID rguidEditorType;
		/*[in]*/ LPCOLESTR pszPhysicalView;
		/*[in]*/ VSIDOFLAGS grfIDO;
		/*[out]*/ IVsUIHierarchy** ppHierOpen;
		/*[out]*/ VSITEMID* pitemidOpen;
		/*[out]*/ IVsWindowFrame** ppWindowFrame;
		/*[out,retval]*/ BOOL* pfOpen;
		HRESULT retValue;
	};

	STDMETHOD(IsSpecificDocumentViewOpen)(
		/*[in]*/ IVsUIHierarchy* pHierCaller,
		/*[in]*/ VSITEMID itemidCaller,
		/*[in]*/ LPCOLESTR pszMkDocument,
		/*[in]*/ REFGUID rguidEditorType,
		/*[in]*/ LPCOLESTR pszPhysicalView,
		/*[in]*/ VSIDOFLAGS grfIDO,
		/*[out]*/ IVsUIHierarchy** ppHierOpen,
		/*[out]*/ VSITEMID* pitemidOpen,
		/*[out]*/ IVsWindowFrame** ppWindowFrame,
		/*[out,retval]*/ BOOL* pfOpen)
	{
		VSL_DEFINE_MOCK_METHOD(IsSpecificDocumentViewOpen)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierCaller);

		VSL_CHECK_VALIDVALUE(itemidCaller);

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_CHECK_VALIDVALUE(rguidEditorType);

		VSL_CHECK_VALIDVALUE_STRINGW(pszPhysicalView);

		VSL_CHECK_VALIDVALUE(grfIDO);

		VSL_SET_VALIDVALUE_INTERFACE(ppHierOpen);

		VSL_SET_VALIDVALUE(pitemidOpen);

		VSL_SET_VALIDVALUE_INTERFACE(ppWindowFrame);

		VSL_SET_VALIDVALUE(pfOpen);

		VSL_RETURN_VALIDVALUES();
	}
	struct OpenDocumentViaProjectWithSpecificValidValues
	{
		/*[in]*/ LPCOLESTR pszMkDocument;
		/*[in]*/ VSSPECIFICEDITORFLAGS grfEditorFlags;
		/*[in]*/ REFGUID rguidEditorType;
		/*[in]*/ LPCOLESTR pszPhysicalView;
		/*[in]*/ REFGUID rguidLogicalView;
		/*[out]*/ IServiceProvider** ppSP;
		/*[out]*/ IVsUIHierarchy** ppHier;
		/*[out]*/ VSITEMID* pitemid;
		/*[out,retval]*/ IVsWindowFrame** ppWindowFrame;
		HRESULT retValue;
	};

	STDMETHOD(OpenDocumentViaProjectWithSpecific)(
		/*[in]*/ LPCOLESTR pszMkDocument,
		/*[in]*/ VSSPECIFICEDITORFLAGS grfEditorFlags,
		/*[in]*/ REFGUID rguidEditorType,
		/*[in]*/ LPCOLESTR pszPhysicalView,
		/*[in]*/ REFGUID rguidLogicalView,
		/*[out]*/ IServiceProvider** ppSP,
		/*[out]*/ IVsUIHierarchy** ppHier,
		/*[out]*/ VSITEMID* pitemid,
		/*[out,retval]*/ IVsWindowFrame** ppWindowFrame)
	{
		VSL_DEFINE_MOCK_METHOD(OpenDocumentViaProjectWithSpecific)

		VSL_CHECK_VALIDVALUE_STRINGW(pszMkDocument);

		VSL_CHECK_VALIDVALUE(grfEditorFlags);

		VSL_CHECK_VALIDVALUE(rguidEditorType);

		VSL_CHECK_VALIDVALUE_STRINGW(pszPhysicalView);

		VSL_CHECK_VALIDVALUE(rguidLogicalView);

		VSL_SET_VALIDVALUE_INTERFACE(ppSP);

		VSL_SET_VALIDVALUE_INTERFACE(ppHier);

		VSL_SET_VALIDVALUE(pitemid);

		VSL_SET_VALIDVALUE_INTERFACE(ppWindowFrame);

		VSL_RETURN_VALIDVALUES();
	}
	struct OpenCopyOfStandardEditorValidValues
	{
		/*[in]*/ IVsWindowFrame* pWindowFrame;
		/*[in]*/ REFGUID rguidLogicalView;
		/*[out,retval]*/ IVsWindowFrame** ppNewWindowFrame;
		HRESULT retValue;
	};

	STDMETHOD(OpenCopyOfStandardEditor)(
		/*[in]*/ IVsWindowFrame* pWindowFrame,
		/*[in]*/ REFGUID rguidLogicalView,
		/*[out,retval]*/ IVsWindowFrame** ppNewWindowFrame)
	{
		VSL_DEFINE_MOCK_METHOD(OpenCopyOfStandardEditor)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pWindowFrame);

		VSL_CHECK_VALIDVALUE(rguidLogicalView);

		VSL_SET_VALIDVALUE_INTERFACE(ppNewWindowFrame);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetFirstDefaultPreviewerValidValues
	{
		/*[out]*/ BSTR* pbstrDefBrowserPath;
		/*[out]*/ BOOL* pfIsInternalBrowser;
		/*[out]*/ BOOL* pfIsSystemBrowser;
		HRESULT retValue;
	};

	STDMETHOD(GetFirstDefaultPreviewer)(
		/*[out]*/ BSTR* pbstrDefBrowserPath,
		/*[out]*/ BOOL* pfIsInternalBrowser,
		/*[out]*/ BOOL* pfIsSystemBrowser)
	{
		VSL_DEFINE_MOCK_METHOD(GetFirstDefaultPreviewer)

		VSL_SET_VALIDVALUE_BSTR(pbstrDefBrowserPath);

		VSL_SET_VALIDVALUE(pfIsInternalBrowser);

		VSL_SET_VALIDVALUE(pfIsSystemBrowser);

		VSL_RETURN_VALIDVALUES();
	}
	struct SearchProjectsForRelativePathValidValues
	{
		/*[in]*/ VSRELPATHSEARCHFLAGS grfRPS;
		/*[in]*/ LPCOLESTR pszRelPath;
		/*[out,retval]*/ BSTR* pbstrAbsPath;
		HRESULT retValue;
	};

	STDMETHOD(SearchProjectsForRelativePath)(
		/*[in]*/ VSRELPATHSEARCHFLAGS grfRPS,
		/*[in]*/ LPCOLESTR pszRelPath,
		/*[out,retval]*/ BSTR* pbstrAbsPath)
	{
		VSL_DEFINE_MOCK_METHOD(SearchProjectsForRelativePath)

		VSL_CHECK_VALIDVALUE(grfRPS);

		VSL_CHECK_VALIDVALUE_STRINGW(pszRelPath);

		VSL_SET_VALIDVALUE_BSTR(pbstrAbsPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddStandardPreviewerValidValues
	{
		/*[in]*/ LPCOLESTR pszExePath;
		/*[in]*/ LPCOLESTR pszDisplayName;
		/*[in]*/ BOOL fUseDDE;
		/*[in]*/ LPCOLESTR pszDDEService;
		/*[in]*/ LPCOLESTR pszDDETopicOpenURL;
		/*[in]*/ LPCOLESTR pszDDEItemOpenURL;
		/*[in]*/ LPCOLESTR pszDDETopicActivate;
		/*[in]*/ LPCOLESTR pszDDEItemActivate;
		/*[in]*/ VSASPFLAGS aspAddPreviewerFlags;
		HRESULT retValue;
	};

	STDMETHOD(AddStandardPreviewer)(
		/*[in]*/ LPCOLESTR pszExePath,
		/*[in]*/ LPCOLESTR pszDisplayName,
		/*[in]*/ BOOL fUseDDE,
		/*[in]*/ LPCOLESTR pszDDEService,
		/*[in]*/ LPCOLESTR pszDDETopicOpenURL,
		/*[in]*/ LPCOLESTR pszDDEItemOpenURL,
		/*[in]*/ LPCOLESTR pszDDETopicActivate,
		/*[in]*/ LPCOLESTR pszDDEItemActivate,
		/*[in]*/ VSASPFLAGS aspAddPreviewerFlags)
	{
		VSL_DEFINE_MOCK_METHOD(AddStandardPreviewer)

		VSL_CHECK_VALIDVALUE_STRINGW(pszExePath);

		VSL_CHECK_VALIDVALUE_STRINGW(pszDisplayName);

		VSL_CHECK_VALIDVALUE(fUseDDE);

		VSL_CHECK_VALIDVALUE_STRINGW(pszDDEService);

		VSL_CHECK_VALIDVALUE_STRINGW(pszDDETopicOpenURL);

		VSL_CHECK_VALIDVALUE_STRINGW(pszDDEItemOpenURL);

		VSL_CHECK_VALIDVALUE_STRINGW(pszDDETopicActivate);

		VSL_CHECK_VALIDVALUE_STRINGW(pszDDEItemActivate);

		VSL_CHECK_VALIDVALUE(aspAddPreviewerFlags);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSUISHELLOPENDOCUMENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsUpdateSolutionEvents2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSUPDATESOLUTIONEVENTS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSUPDATESOLUTIONEVENTS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsUpdateSolutionEvents2NotImpl :
	public IVsUpdateSolutionEvents2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUpdateSolutionEvents2NotImpl)

public:

	typedef IVsUpdateSolutionEvents2 Interface;

	STDMETHOD(UpdateProjectCfg_Begin)(
		/*[in]*/ IVsHierarchy* /*pHierProj*/,
		/*[in]*/ IVsCfg* /*pCfgProj*/,
		/*[in]*/ IVsCfg* /*pCfgSln*/,
		/*[in]*/ DWORD /*dwAction*/,
		/*[in,out]*/ BOOL* /*pfCancel*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UpdateProjectCfg_Done)(
		/*[in]*/ IVsHierarchy* /*pHierProj*/,
		/*[in]*/ IVsCfg* /*pCfgProj*/,
		/*[in]*/ IVsCfg* /*pCfgSln*/,
		/*[in]*/ DWORD /*dwAction*/,
		/*[in]*/ BOOL /*fSuccess*/,
		/*[in]*/ BOOL /*fCancel*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UpdateSolution_Begin)(
		/*[in,out]*/ BOOL* /*pfCancelUpdate*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UpdateSolution_Done)(
		/*[in]*/ BOOL /*fSucceeded*/,
		/*[in]*/ BOOL /*fModified*/,
		/*[in]*/ BOOL /*fCancelCommand*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UpdateSolution_StartUpdate)(
		/*[in,out]*/ BOOL* /*pfCancelUpdate*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UpdateSolution_Cancel)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnActiveProjectCfgChange)(
		/*[in]*/ IVsHierarchy* /*pIVsHierarchy*/)VSL_STDMETHOD_NOTIMPL
};

class IVsUpdateSolutionEvents2MockImpl :
	public IVsUpdateSolutionEvents2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUpdateSolutionEvents2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsUpdateSolutionEvents2MockImpl)

	typedef IVsUpdateSolutionEvents2 Interface;
	struct UpdateProjectCfg_BeginValidValues
	{
		/*[in]*/ IVsHierarchy* pHierProj;
		/*[in]*/ IVsCfg* pCfgProj;
		/*[in]*/ IVsCfg* pCfgSln;
		/*[in]*/ DWORD dwAction;
		/*[in,out]*/ BOOL* pfCancel;
		HRESULT retValue;
	};

	STDMETHOD(UpdateProjectCfg_Begin)(
		/*[in]*/ IVsHierarchy* pHierProj,
		/*[in]*/ IVsCfg* pCfgProj,
		/*[in]*/ IVsCfg* pCfgSln,
		/*[in]*/ DWORD dwAction,
		/*[in,out]*/ BOOL* pfCancel)
	{
		VSL_DEFINE_MOCK_METHOD(UpdateProjectCfg_Begin)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierProj);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCfgProj);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCfgSln);

		VSL_CHECK_VALIDVALUE(dwAction);

		VSL_SET_VALIDVALUE(pfCancel);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateProjectCfg_DoneValidValues
	{
		/*[in]*/ IVsHierarchy* pHierProj;
		/*[in]*/ IVsCfg* pCfgProj;
		/*[in]*/ IVsCfg* pCfgSln;
		/*[in]*/ DWORD dwAction;
		/*[in]*/ BOOL fSuccess;
		/*[in]*/ BOOL fCancel;
		HRESULT retValue;
	};

	STDMETHOD(UpdateProjectCfg_Done)(
		/*[in]*/ IVsHierarchy* pHierProj,
		/*[in]*/ IVsCfg* pCfgProj,
		/*[in]*/ IVsCfg* pCfgSln,
		/*[in]*/ DWORD dwAction,
		/*[in]*/ BOOL fSuccess,
		/*[in]*/ BOOL fCancel)
	{
		VSL_DEFINE_MOCK_METHOD(UpdateProjectCfg_Done)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHierProj);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCfgProj);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCfgSln);

		VSL_CHECK_VALIDVALUE(dwAction);

		VSL_CHECK_VALIDVALUE(fSuccess);

		VSL_CHECK_VALIDVALUE(fCancel);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateSolution_BeginValidValues
	{
		/*[in,out]*/ BOOL* pfCancelUpdate;
		HRESULT retValue;
	};

	STDMETHOD(UpdateSolution_Begin)(
		/*[in,out]*/ BOOL* pfCancelUpdate)
	{
		VSL_DEFINE_MOCK_METHOD(UpdateSolution_Begin)

		VSL_SET_VALIDVALUE(pfCancelUpdate);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateSolution_DoneValidValues
	{
		/*[in]*/ BOOL fSucceeded;
		/*[in]*/ BOOL fModified;
		/*[in]*/ BOOL fCancelCommand;
		HRESULT retValue;
	};

	STDMETHOD(UpdateSolution_Done)(
		/*[in]*/ BOOL fSucceeded,
		/*[in]*/ BOOL fModified,
		/*[in]*/ BOOL fCancelCommand)
	{
		VSL_DEFINE_MOCK_METHOD(UpdateSolution_Done)

		VSL_CHECK_VALIDVALUE(fSucceeded);

		VSL_CHECK_VALIDVALUE(fModified);

		VSL_CHECK_VALIDVALUE(fCancelCommand);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateSolution_StartUpdateValidValues
	{
		/*[in,out]*/ BOOL* pfCancelUpdate;
		HRESULT retValue;
	};

	STDMETHOD(UpdateSolution_StartUpdate)(
		/*[in,out]*/ BOOL* pfCancelUpdate)
	{
		VSL_DEFINE_MOCK_METHOD(UpdateSolution_StartUpdate)

		VSL_SET_VALIDVALUE(pfCancelUpdate);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateSolution_CancelValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(UpdateSolution_Cancel)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(UpdateSolution_Cancel)

		VSL_RETURN_VALIDVALUES();
	}
	struct OnActiveProjectCfgChangeValidValues
	{
		/*[in]*/ IVsHierarchy* pIVsHierarchy;
		HRESULT retValue;
	};

	STDMETHOD(OnActiveProjectCfgChange)(
		/*[in]*/ IVsHierarchy* pIVsHierarchy)
	{
		VSL_DEFINE_MOCK_METHOD(OnActiveProjectCfgChange)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIVsHierarchy);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSUPDATESOLUTIONEVENTS2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsUpdateSolutionEvents3.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSUPDATESOLUTIONEVENTS3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSUPDATESOLUTIONEVENTS3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsUpdateSolutionEvents3NotImpl :
	public IVsUpdateSolutionEvents3
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUpdateSolutionEvents3NotImpl)

public:

	typedef IVsUpdateSolutionEvents3 Interface;

	STDMETHOD(OnBeforeActiveSolutionCfgChange)(
		/*[in]*/ IVsCfg* /*pOldActiveSlnCfg*/,
		/*[in]*/ IVsCfg* /*pNewActiveSlnCfg*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnAfterActiveSolutionCfgChange)(
		/*[in]*/ IVsCfg* /*pOldActiveSlnCfg*/,
		/*[in]*/ IVsCfg* /*pNewActiveSlnCfg*/)VSL_STDMETHOD_NOTIMPL
};

class IVsUpdateSolutionEvents3MockImpl :
	public IVsUpdateSolutionEvents3,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUpdateSolutionEvents3MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsUpdateSolutionEvents3MockImpl)

	typedef IVsUpdateSolutionEvents3 Interface;
	struct OnBeforeActiveSolutionCfgChangeValidValues
	{
		/*[in]*/ IVsCfg* pOldActiveSlnCfg;
		/*[in]*/ IVsCfg* pNewActiveSlnCfg;
		HRESULT retValue;
	};

	STDMETHOD(OnBeforeActiveSolutionCfgChange)(
		/*[in]*/ IVsCfg* pOldActiveSlnCfg,
		/*[in]*/ IVsCfg* pNewActiveSlnCfg)
	{
		VSL_DEFINE_MOCK_METHOD(OnBeforeActiveSolutionCfgChange)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pOldActiveSlnCfg);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pNewActiveSlnCfg);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnAfterActiveSolutionCfgChangeValidValues
	{
		/*[in]*/ IVsCfg* pOldActiveSlnCfg;
		/*[in]*/ IVsCfg* pNewActiveSlnCfg;
		HRESULT retValue;
	};

	STDMETHOD(OnAfterActiveSolutionCfgChange)(
		/*[in]*/ IVsCfg* pOldActiveSlnCfg,
		/*[in]*/ IVsCfg* pNewActiveSlnCfg)
	{
		VSL_DEFINE_MOCK_METHOD(OnAfterActiveSolutionCfgChange)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pOldActiveSlnCfg);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pNewActiveSlnCfg);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSUPDATESOLUTIONEVENTS3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsUIShellDocumentWindowMgr.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSUISHELLDOCUMENTWINDOWMGR_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSUISHELLDOCUMENTWINDOWMGR_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsUIShellDocumentWindowMgrNotImpl :
	public IVsUIShellDocumentWindowMgr
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUIShellDocumentWindowMgrNotImpl)

public:

	typedef IVsUIShellDocumentWindowMgr Interface;

	STDMETHOD(SaveDocumentWindowPositions)(
		/*[in]*/ DWORD /*dwReserved*/,
		/*[in]*/ IStream* /*pStream*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ReopenDocumentWindows)(
		/*[in]*/ IStream* /*pStream*/)VSL_STDMETHOD_NOTIMPL
};

class IVsUIShellDocumentWindowMgrMockImpl :
	public IVsUIShellDocumentWindowMgr,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUIShellDocumentWindowMgrMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsUIShellDocumentWindowMgrMockImpl)

	typedef IVsUIShellDocumentWindowMgr Interface;
	struct SaveDocumentWindowPositionsValidValues
	{
		/*[in]*/ DWORD dwReserved;
		/*[in]*/ IStream* pStream;
		HRESULT retValue;
	};

	STDMETHOD(SaveDocumentWindowPositions)(
		/*[in]*/ DWORD dwReserved,
		/*[in]*/ IStream* pStream)
	{
		VSL_DEFINE_MOCK_METHOD(SaveDocumentWindowPositions)

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pStream);

		VSL_RETURN_VALIDVALUES();
	}
	struct ReopenDocumentWindowsValidValues
	{
		/*[in]*/ IStream* pStream;
		HRESULT retValue;
	};

	STDMETHOD(ReopenDocumentWindows)(
		/*[in]*/ IStream* pStream)
	{
		VSL_DEFINE_MOCK_METHOD(ReopenDocumentWindows)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pStream);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSUISHELLDOCUMENTWINDOWMGR_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsUpdateSolutionEvents.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSUPDATESOLUTIONEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSUPDATESOLUTIONEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsUpdateSolutionEventsNotImpl :
	public IVsUpdateSolutionEvents
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUpdateSolutionEventsNotImpl)

public:

	typedef IVsUpdateSolutionEvents Interface;

	STDMETHOD(UpdateSolution_Begin)(
		/*[in,out]*/ BOOL* /*pfCancelUpdate*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UpdateSolution_Done)(
		/*[in]*/ BOOL /*fSucceeded*/,
		/*[in]*/ BOOL /*fModified*/,
		/*[in]*/ BOOL /*fCancelCommand*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UpdateSolution_StartUpdate)(
		/*[in,out]*/ BOOL* /*pfCancelUpdate*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UpdateSolution_Cancel)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnActiveProjectCfgChange)(
		/*[in]*/ IVsHierarchy* /*pIVsHierarchy*/)VSL_STDMETHOD_NOTIMPL
};

class IVsUpdateSolutionEventsMockImpl :
	public IVsUpdateSolutionEvents,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUpdateSolutionEventsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsUpdateSolutionEventsMockImpl)

	typedef IVsUpdateSolutionEvents Interface;
	struct UpdateSolution_BeginValidValues
	{
		/*[in,out]*/ BOOL* pfCancelUpdate;
		HRESULT retValue;
	};

	STDMETHOD(UpdateSolution_Begin)(
		/*[in,out]*/ BOOL* pfCancelUpdate)
	{
		VSL_DEFINE_MOCK_METHOD(UpdateSolution_Begin)

		VSL_SET_VALIDVALUE(pfCancelUpdate);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateSolution_DoneValidValues
	{
		/*[in]*/ BOOL fSucceeded;
		/*[in]*/ BOOL fModified;
		/*[in]*/ BOOL fCancelCommand;
		HRESULT retValue;
	};

	STDMETHOD(UpdateSolution_Done)(
		/*[in]*/ BOOL fSucceeded,
		/*[in]*/ BOOL fModified,
		/*[in]*/ BOOL fCancelCommand)
	{
		VSL_DEFINE_MOCK_METHOD(UpdateSolution_Done)

		VSL_CHECK_VALIDVALUE(fSucceeded);

		VSL_CHECK_VALIDVALUE(fModified);

		VSL_CHECK_VALIDVALUE(fCancelCommand);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateSolution_StartUpdateValidValues
	{
		/*[in,out]*/ BOOL* pfCancelUpdate;
		HRESULT retValue;
	};

	STDMETHOD(UpdateSolution_StartUpdate)(
		/*[in,out]*/ BOOL* pfCancelUpdate)
	{
		VSL_DEFINE_MOCK_METHOD(UpdateSolution_StartUpdate)

		VSL_SET_VALIDVALUE(pfCancelUpdate);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateSolution_CancelValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(UpdateSolution_Cancel)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(UpdateSolution_Cancel)

		VSL_RETURN_VALIDVALUES();
	}
	struct OnActiveProjectCfgChangeValidValues
	{
		/*[in]*/ IVsHierarchy* pIVsHierarchy;
		HRESULT retValue;
	};

	STDMETHOD(OnActiveProjectCfgChange)(
		/*[in]*/ IVsHierarchy* pIVsHierarchy)
	{
		VSL_DEFINE_MOCK_METHOD(OnActiveProjectCfgChange)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIVsHierarchy);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSUPDATESOLUTIONEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsUIShellOpenDocument2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSUISHELLOPENDOCUMENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSUISHELLOPENDOCUMENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsUIShellOpenDocument2NotImpl :
	public IVsUIShellOpenDocument2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUIShellOpenDocument2NotImpl)

public:

	typedef IVsUIShellOpenDocument2 Interface;

	STDMETHOD(GetDefaultPreviewers)(
		/*[in]*/ ULONG /*celt*/,
		/*[in,out,size_is(celt)]*/ VSDEFAULTPREVIEWER[] /*rgDefaultPreviewers*/,
		/*[out]*/ ULONG* /*pcActual*/)VSL_STDMETHOD_NOTIMPL
};

class IVsUIShellOpenDocument2MockImpl :
	public IVsUIShellOpenDocument2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUIShellOpenDocument2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsUIShellOpenDocument2MockImpl)

	typedef IVsUIShellOpenDocument2 Interface;
	struct GetDefaultPreviewersValidValues
	{
		/*[in]*/ ULONG celt;
		/*[in,out,size_is(celt)]*/ VSDEFAULTPREVIEWER* rgDefaultPreviewers;
		/*[out]*/ ULONG* pcActual;
		HRESULT retValue;
	};

	STDMETHOD(GetDefaultPreviewers)(
		/*[in]*/ ULONG celt,
		/*[in,out,size_is(celt)]*/ VSDEFAULTPREVIEWER rgDefaultPreviewers[],
		/*[out]*/ ULONG* pcActual)
	{
		VSL_DEFINE_MOCK_METHOD(GetDefaultPreviewers)

		VSL_CHECK_VALIDVALUE(celt);

		VSL_SET_VALIDVALUE_MEMCPY(rgDefaultPreviewers, celt*sizeof(rgDefaultPreviewers[0]), validValues.celt*sizeof(validValues.rgDefaultPreviewers[0]));

		VSL_SET_VALIDVALUE(pcActual);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSUISHELLOPENDOCUMENT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsUserContextCustomize.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSUSERCONTEXTCUSTOMIZE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSUSERCONTEXTCUSTOMIZE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "context.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsUserContextCustomizeNotImpl :
	public IVsUserContextCustomize
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUserContextCustomizeNotImpl)

public:

	typedef IVsUserContextCustomize Interface;

	STDMETHOD(GetLimitKeywordSource)(
		/*[out,retval]*/ LONG* /*pLimKwdSrc*/)VSL_STDMETHOD_NOTIMPL
};

class IVsUserContextCustomizeMockImpl :
	public IVsUserContextCustomize,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUserContextCustomizeMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsUserContextCustomizeMockImpl)

	typedef IVsUserContextCustomize Interface;
	struct GetLimitKeywordSourceValidValues
	{
		/*[out,retval]*/ LONG* pLimKwdSrc;
		HRESULT retValue;
	};

	STDMETHOD(GetLimitKeywordSource)(
		/*[out,retval]*/ LONG* pLimKwdSrc)
	{
		VSL_DEFINE_MOCK_METHOD(GetLimitKeywordSource)

		VSL_SET_VALIDVALUE(pLimKwdSrc);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSUSERCONTEXTCUSTOMIZE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsUserContextExport.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSUSERCONTEXTEXPORT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSUSERCONTEXTEXPORT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "context2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsUserContextExportNotImpl :
	public IVsUserContextExport
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUserContextExportNotImpl)

public:

	typedef IVsUserContextExport Interface;

	STDMETHOD(GetUserContextAsText)(
		/*[in]*/ VSUSERCONTEXTEXPORTTEXTFLAGS /*dwFlags*/,
		/*[in]*/ BSTR /*bstrOptions*/,
		/*[in]*/ BSTR* /*pbstrKeywords*/,
		/*[in]*/ BSTR* /*pbstrAttributes*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetUserContextAsSafeArray)(
		/*[in]*/ VSUSERCONTEXTEXPORTTEXTFLAGS /*dwFlags*/,
		/*[in]*/ BSTR /*bstrF1Keyword*/,
		/*[in]*/ SAFEARRAY** /*ppKeywords*/,
		/*[in]*/ SAFEARRAY** /*ppAttributes*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateSubcontextsFromSafeArrays)(
		/*[in]*/ IVsMonitorUserContext* /*pMUC*/,
		/*[in]*/ SAFEARRAY* /*pKeywords*/,
		/*[in]*/ SAFEARRAY* /*pAttributes*/)VSL_STDMETHOD_NOTIMPL
};

class IVsUserContextExportMockImpl :
	public IVsUserContextExport,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUserContextExportMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsUserContextExportMockImpl)

	typedef IVsUserContextExport Interface;
	struct GetUserContextAsTextValidValues
	{
		/*[in]*/ VSUSERCONTEXTEXPORTTEXTFLAGS dwFlags;
		/*[in]*/ BSTR bstrOptions;
		/*[in]*/ BSTR* pbstrKeywords;
		/*[in]*/ BSTR* pbstrAttributes;
		HRESULT retValue;
	};

	STDMETHOD(GetUserContextAsText)(
		/*[in]*/ VSUSERCONTEXTEXPORTTEXTFLAGS dwFlags,
		/*[in]*/ BSTR bstrOptions,
		/*[in]*/ BSTR* pbstrKeywords,
		/*[in]*/ BSTR* pbstrAttributes)
	{
		VSL_DEFINE_MOCK_METHOD(GetUserContextAsText)

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_CHECK_VALIDVALUE_BSTR(bstrOptions);

		VSL_CHECK_VALIDVALUE_POINTER(pbstrKeywords);

		VSL_CHECK_VALIDVALUE_POINTER(pbstrAttributes);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetUserContextAsSafeArrayValidValues
	{
		/*[in]*/ VSUSERCONTEXTEXPORTTEXTFLAGS dwFlags;
		/*[in]*/ BSTR bstrF1Keyword;
		/*[in]*/ SAFEARRAY** ppKeywords;
		/*[in]*/ SAFEARRAY** ppAttributes;
		HRESULT retValue;
	};

	STDMETHOD(GetUserContextAsSafeArray)(
		/*[in]*/ VSUSERCONTEXTEXPORTTEXTFLAGS dwFlags,
		/*[in]*/ BSTR bstrF1Keyword,
		/*[in]*/ SAFEARRAY** ppKeywords,
		/*[in]*/ SAFEARRAY** ppAttributes)
	{
		VSL_DEFINE_MOCK_METHOD(GetUserContextAsSafeArray)

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_CHECK_VALIDVALUE_BSTR(bstrF1Keyword);

		VSL_CHECK_VALIDVALUE_SAFEARRAY(ppKeywords);

		VSL_CHECK_VALIDVALUE_SAFEARRAY(ppAttributes);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateSubcontextsFromSafeArraysValidValues
	{
		/*[in]*/ IVsMonitorUserContext* pMUC;
		/*[in]*/ SAFEARRAY* pKeywords;
		/*[in]*/ SAFEARRAY* pAttributes;
		HRESULT retValue;
	};

	STDMETHOD(CreateSubcontextsFromSafeArrays)(
		/*[in]*/ IVsMonitorUserContext* pMUC,
		/*[in]*/ SAFEARRAY* pKeywords,
		/*[in]*/ SAFEARRAY* pAttributes)
	{
		VSL_DEFINE_MOCK_METHOD(CreateSubcontextsFromSafeArrays)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pMUC);

		VSL_CHECK_VALIDVALUE(pKeywords);

		VSL_CHECK_VALIDVALUE(pAttributes);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSUSERCONTEXTEXPORT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsUserContextItemCollection.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSUSERCONTEXTITEMCOLLECTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSUSERCONTEXTITEMCOLLECTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "context.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsUserContextItemCollectionNotImpl :
	public IVsUserContextItemCollection
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUserContextItemCollectionNotImpl)

public:

	typedef IVsUserContextItemCollection Interface;

	STDMETHOD(get_Item)(
		/*[in]*/ VARIANT /*index*/,
		/*[out,retval]*/ IVsUserContextItem** /*ppItem*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get__NewEnum)(
		/*[out,retval]*/ IUnknown** /*pEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Count)(
		/*[out,retval]*/ long* /*pCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ItemAt)(
		/*[in]*/ long /*index*/,
		/*[out,retval]*/ IVsUserContextItem** /*ppItem*/)VSL_STDMETHOD_NOTIMPL
};

class IVsUserContextItemCollectionMockImpl :
	public IVsUserContextItemCollection,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUserContextItemCollectionMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsUserContextItemCollectionMockImpl)

	typedef IVsUserContextItemCollection Interface;
	struct get_ItemValidValues
	{
		/*[in]*/ VARIANT index;
		/*[out,retval]*/ IVsUserContextItem** ppItem;
		HRESULT retValue;
	};

	STDMETHOD(get_Item)(
		/*[in]*/ VARIANT index,
		/*[out,retval]*/ IVsUserContextItem** ppItem)
	{
		VSL_DEFINE_MOCK_METHOD(get_Item)

		VSL_CHECK_VALIDVALUE(index);

		VSL_SET_VALIDVALUE_INTERFACE(ppItem);

		VSL_RETURN_VALIDVALUES();
	}
	struct get__NewEnumValidValues
	{
		/*[out,retval]*/ IUnknown** pEnum;
		HRESULT retValue;
	};

	STDMETHOD(get__NewEnum)(
		/*[out,retval]*/ IUnknown** pEnum)
	{
		VSL_DEFINE_MOCK_METHOD(get__NewEnum)

		VSL_SET_VALIDVALUE_INTERFACE(pEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CountValidValues
	{
		/*[out,retval]*/ long* pCount;
		HRESULT retValue;
	};

	STDMETHOD(get_Count)(
		/*[out,retval]*/ long* pCount)
	{
		VSL_DEFINE_MOCK_METHOD(get_Count)

		VSL_SET_VALIDVALUE(pCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ItemAtValidValues
	{
		/*[in]*/ long index;
		/*[out,retval]*/ IVsUserContextItem** ppItem;
		HRESULT retValue;
	};

	STDMETHOD(get_ItemAt)(
		/*[in]*/ long index,
		/*[out,retval]*/ IVsUserContextItem** ppItem)
	{
		VSL_DEFINE_MOCK_METHOD(get_ItemAt)

		VSL_CHECK_VALIDVALUE(index);

		VSL_SET_VALIDVALUE_INTERFACE(ppItem);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSUSERCONTEXTITEMCOLLECTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsUpgradeLogger.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSUPGRADELOGGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSUPGRADELOGGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsUpgradeLoggerNotImpl :
	public IVsUpgradeLogger
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUpgradeLoggerNotImpl)

public:

	typedef IVsUpgradeLogger Interface;

	STDMETHOD(LogMessage)(
		/*[in]*/ VSUL_ERRORLEVEL /*ErrorLevel*/,
		/*[in]*/ BSTR /*bstrProject*/,
		/*[in]*/ BSTR /*bstrSource*/,
		/*[in]*/ BSTR /*bstrDescription*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Flush)()VSL_STDMETHOD_NOTIMPL
};

class IVsUpgradeLoggerMockImpl :
	public IVsUpgradeLogger,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUpgradeLoggerMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsUpgradeLoggerMockImpl)

	typedef IVsUpgradeLogger Interface;
	struct LogMessageValidValues
	{
		/*[in]*/ VSUL_ERRORLEVEL ErrorLevel;
		/*[in]*/ BSTR bstrProject;
		/*[in]*/ BSTR bstrSource;
		/*[in]*/ BSTR bstrDescription;
		HRESULT retValue;
	};

	STDMETHOD(LogMessage)(
		/*[in]*/ VSUL_ERRORLEVEL ErrorLevel,
		/*[in]*/ BSTR bstrProject,
		/*[in]*/ BSTR bstrSource,
		/*[in]*/ BSTR bstrDescription)
	{
		VSL_DEFINE_MOCK_METHOD(LogMessage)

		VSL_CHECK_VALIDVALUE(ErrorLevel);

		VSL_CHECK_VALIDVALUE_BSTR(bstrProject);

		VSL_CHECK_VALIDVALUE_BSTR(bstrSource);

		VSL_CHECK_VALIDVALUE_BSTR(bstrDescription);

		VSL_RETURN_VALIDVALUES();
	}
	struct FlushValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Flush)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Flush)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSUPGRADELOGGER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsUserContext.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSUSERCONTEXT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSUSERCONTEXT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "context.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsUserContextNotImpl :
	public IVsUserContext
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUserContextNotImpl)

public:

	typedef IVsUserContext Interface;

	STDMETHOD(AddAttribute)(
		/*[in]*/ VSUSERCONTEXTATTRIBUTEUSAGE /*usage*/,
		/*[in]*/ LPCOLESTR /*szName*/,
		/*[in]*/ LPCOLESTR /*szValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveAttribute)(
		/*[in]*/ LPCOLESTR /*szName*/,
		/*[in]*/ LPCOLESTR /*szValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddSubcontext)(
		/*[in]*/ IVsUserContext* /*pSubCtx*/,
		/*[in]*/ int /*lPriority*/,
		/*[out,retval]*/ VSCOOKIE* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveSubcontext)(
		/*[in]*/ VSCOOKIE /*dwcookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CountAttributes)(
		/*[in]*/ LPCOLESTR /*pszName*/,
		/*[in]*/ BOOL /*fIncludeChildren*/,
		/*[out,retval]*/ int* /*pc*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetAttribute)(
		/*[in]*/ int /*iAttribute*/,
		/*[in]*/ LPCOLESTR /*pszName*/,
		/*[in]*/ BOOL /*fIncludeChildren*/,
		/*[out]*/ BSTR* /*pbstrName*/,
		/*[out,retval]*/ BSTR* /*pbstrValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CountSubcontexts)(
		/*[out,retval]*/ int* /*pc*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSubcontext)(
		/*[in]*/ int /*i*/,
		/*[out,retval]*/ IVsUserContext** /*ppSubCtx*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsDirty)(
		/*[out,retval]*/ BOOL* /*pfDirty*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetDirty)(
		/*[in]*/ BOOL /*fDirty*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Update)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AdviseUpdate)(
		/*[in]*/ IVsUserContextUpdate* /*pUpdate*/,
		/*[out,retval]*/ VSCOOKIE* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnadviseUpdate)(
		/*[in]*/ VSCOOKIE /*dwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetAttrUsage)(
		/*[in]*/ int /*index*/,
		/*[in]*/ BOOL /*fIncludeChildren*/,
		/*[out,retval]*/ VSUSERCONTEXTATTRIBUTEUSAGE* /*pUsage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveAllSubcontext)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPriority)(
		/*[out,retval]*/ int* /*lPriority*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveAttributeIncludeChildren)(
		/*[in]*/ LPCOLESTR /*szName*/,
		/*[in]*/ LPCOLESTR /*szValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetAttributePri)(
		/*[in]*/ int /*iAttribute*/,
		/*[in]*/ LPCOLESTR /*pszName*/,
		/*[in]*/ BOOL /*fIncludeChildren*/,
		/*[out]*/ int* /*piPriority*/,
		/*[out]*/ BSTR* /*pbstrName*/,
		/*[out,retval]*/ BSTR* /*pbstrValue*/)VSL_STDMETHOD_NOTIMPL
};

class IVsUserContextMockImpl :
	public IVsUserContext,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUserContextMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsUserContextMockImpl)

	typedef IVsUserContext Interface;
	struct AddAttributeValidValues
	{
		/*[in]*/ VSUSERCONTEXTATTRIBUTEUSAGE usage;
		/*[in]*/ LPCOLESTR szName;
		/*[in]*/ LPCOLESTR szValue;
		HRESULT retValue;
	};

	STDMETHOD(AddAttribute)(
		/*[in]*/ VSUSERCONTEXTATTRIBUTEUSAGE usage,
		/*[in]*/ LPCOLESTR szName,
		/*[in]*/ LPCOLESTR szValue)
	{
		VSL_DEFINE_MOCK_METHOD(AddAttribute)

		VSL_CHECK_VALIDVALUE(usage);

		VSL_CHECK_VALIDVALUE_STRINGW(szName);

		VSL_CHECK_VALIDVALUE_STRINGW(szValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveAttributeValidValues
	{
		/*[in]*/ LPCOLESTR szName;
		/*[in]*/ LPCOLESTR szValue;
		HRESULT retValue;
	};

	STDMETHOD(RemoveAttribute)(
		/*[in]*/ LPCOLESTR szName,
		/*[in]*/ LPCOLESTR szValue)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveAttribute)

		VSL_CHECK_VALIDVALUE_STRINGW(szName);

		VSL_CHECK_VALIDVALUE_STRINGW(szValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddSubcontextValidValues
	{
		/*[in]*/ IVsUserContext* pSubCtx;
		/*[in]*/ int lPriority;
		/*[out,retval]*/ VSCOOKIE* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(AddSubcontext)(
		/*[in]*/ IVsUserContext* pSubCtx,
		/*[in]*/ int lPriority,
		/*[out,retval]*/ VSCOOKIE* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(AddSubcontext)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSubCtx);

		VSL_CHECK_VALIDVALUE(lPriority);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveSubcontextValidValues
	{
		/*[in]*/ VSCOOKIE dwcookie;
		HRESULT retValue;
	};

	STDMETHOD(RemoveSubcontext)(
		/*[in]*/ VSCOOKIE dwcookie)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveSubcontext)

		VSL_CHECK_VALIDVALUE(dwcookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct CountAttributesValidValues
	{
		/*[in]*/ LPCOLESTR pszName;
		/*[in]*/ BOOL fIncludeChildren;
		/*[out,retval]*/ int* pc;
		HRESULT retValue;
	};

	STDMETHOD(CountAttributes)(
		/*[in]*/ LPCOLESTR pszName,
		/*[in]*/ BOOL fIncludeChildren,
		/*[out,retval]*/ int* pc)
	{
		VSL_DEFINE_MOCK_METHOD(CountAttributes)

		VSL_CHECK_VALIDVALUE_STRINGW(pszName);

		VSL_CHECK_VALIDVALUE(fIncludeChildren);

		VSL_SET_VALIDVALUE(pc);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetAttributeValidValues
	{
		/*[in]*/ int iAttribute;
		/*[in]*/ LPCOLESTR pszName;
		/*[in]*/ BOOL fIncludeChildren;
		/*[out]*/ BSTR* pbstrName;
		/*[out,retval]*/ BSTR* pbstrValue;
		HRESULT retValue;
	};

	STDMETHOD(GetAttribute)(
		/*[in]*/ int iAttribute,
		/*[in]*/ LPCOLESTR pszName,
		/*[in]*/ BOOL fIncludeChildren,
		/*[out]*/ BSTR* pbstrName,
		/*[out,retval]*/ BSTR* pbstrValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetAttribute)

		VSL_CHECK_VALIDVALUE(iAttribute);

		VSL_CHECK_VALIDVALUE_STRINGW(pszName);

		VSL_CHECK_VALIDVALUE(fIncludeChildren);

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_SET_VALIDVALUE_BSTR(pbstrValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct CountSubcontextsValidValues
	{
		/*[out,retval]*/ int* pc;
		HRESULT retValue;
	};

	STDMETHOD(CountSubcontexts)(
		/*[out,retval]*/ int* pc)
	{
		VSL_DEFINE_MOCK_METHOD(CountSubcontexts)

		VSL_SET_VALIDVALUE(pc);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSubcontextValidValues
	{
		/*[in]*/ int i;
		/*[out,retval]*/ IVsUserContext** ppSubCtx;
		HRESULT retValue;
	};

	STDMETHOD(GetSubcontext)(
		/*[in]*/ int i,
		/*[out,retval]*/ IVsUserContext** ppSubCtx)
	{
		VSL_DEFINE_MOCK_METHOD(GetSubcontext)

		VSL_CHECK_VALIDVALUE(i);

		VSL_SET_VALIDVALUE_INTERFACE(ppSubCtx);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsDirtyValidValues
	{
		/*[out,retval]*/ BOOL* pfDirty;
		HRESULT retValue;
	};

	STDMETHOD(IsDirty)(
		/*[out,retval]*/ BOOL* pfDirty)
	{
		VSL_DEFINE_MOCK_METHOD(IsDirty)

		VSL_SET_VALIDVALUE(pfDirty);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetDirtyValidValues
	{
		/*[in]*/ BOOL fDirty;
		HRESULT retValue;
	};

	STDMETHOD(SetDirty)(
		/*[in]*/ BOOL fDirty)
	{
		VSL_DEFINE_MOCK_METHOD(SetDirty)

		VSL_CHECK_VALIDVALUE(fDirty);

		VSL_RETURN_VALIDVALUES();
	}
	struct UpdateValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Update)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Update)

		VSL_RETURN_VALIDVALUES();
	}
	struct AdviseUpdateValidValues
	{
		/*[in]*/ IVsUserContextUpdate* pUpdate;
		/*[out,retval]*/ VSCOOKIE* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(AdviseUpdate)(
		/*[in]*/ IVsUserContextUpdate* pUpdate,
		/*[out,retval]*/ VSCOOKIE* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(AdviseUpdate)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUpdate);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnadviseUpdateValidValues
	{
		/*[in]*/ VSCOOKIE dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(UnadviseUpdate)(
		/*[in]*/ VSCOOKIE dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(UnadviseUpdate)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetAttrUsageValidValues
	{
		/*[in]*/ int index;
		/*[in]*/ BOOL fIncludeChildren;
		/*[out,retval]*/ VSUSERCONTEXTATTRIBUTEUSAGE* pUsage;
		HRESULT retValue;
	};

	STDMETHOD(GetAttrUsage)(
		/*[in]*/ int index,
		/*[in]*/ BOOL fIncludeChildren,
		/*[out,retval]*/ VSUSERCONTEXTATTRIBUTEUSAGE* pUsage)
	{
		VSL_DEFINE_MOCK_METHOD(GetAttrUsage)

		VSL_CHECK_VALIDVALUE(index);

		VSL_CHECK_VALIDVALUE(fIncludeChildren);

		VSL_SET_VALIDVALUE(pUsage);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveAllSubcontextValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(RemoveAllSubcontext)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(RemoveAllSubcontext)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPriorityValidValues
	{
		/*[out,retval]*/ int* lPriority;
		HRESULT retValue;
	};

	STDMETHOD(GetPriority)(
		/*[out,retval]*/ int* lPriority)
	{
		VSL_DEFINE_MOCK_METHOD(GetPriority)

		VSL_SET_VALIDVALUE(lPriority);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveAttributeIncludeChildrenValidValues
	{
		/*[in]*/ LPCOLESTR szName;
		/*[in]*/ LPCOLESTR szValue;
		HRESULT retValue;
	};

	STDMETHOD(RemoveAttributeIncludeChildren)(
		/*[in]*/ LPCOLESTR szName,
		/*[in]*/ LPCOLESTR szValue)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveAttributeIncludeChildren)

		VSL_CHECK_VALIDVALUE_STRINGW(szName);

		VSL_CHECK_VALIDVALUE_STRINGW(szValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetAttributePriValidValues
	{
		/*[in]*/ int iAttribute;
		/*[in]*/ LPCOLESTR pszName;
		/*[in]*/ BOOL fIncludeChildren;
		/*[out]*/ int* piPriority;
		/*[out]*/ BSTR* pbstrName;
		/*[out,retval]*/ BSTR* pbstrValue;
		HRESULT retValue;
	};

	STDMETHOD(GetAttributePri)(
		/*[in]*/ int iAttribute,
		/*[in]*/ LPCOLESTR pszName,
		/*[in]*/ BOOL fIncludeChildren,
		/*[out]*/ int* piPriority,
		/*[out]*/ BSTR* pbstrName,
		/*[out,retval]*/ BSTR* pbstrValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetAttributePri)

		VSL_CHECK_VALIDVALUE(iAttribute);

		VSL_CHECK_VALIDVALUE_STRINGW(pszName);

		VSL_CHECK_VALIDVALUE(fIncludeChildren);

		VSL_SET_VALIDVALUE(piPriority);

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_SET_VALIDVALUE_BSTR(pbstrValue);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSUSERCONTEXT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsUserContextItemEvents.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSUSERCONTEXTITEMEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSUSERCONTEXTITEMEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "context.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsUserContextItemEventsNotImpl :
	public IVsUserContextItemEvents
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUserContextItemEventsNotImpl)

public:

	typedef IVsUserContextItemEvents Interface;

	STDMETHOD(OnUserContextItemsAvailable)(
		/*[in]*/ IVsUserContextItemCollection* /*pList*/)VSL_STDMETHOD_NOTIMPL
};

class IVsUserContextItemEventsMockImpl :
	public IVsUserContextItemEvents,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUserContextItemEventsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsUserContextItemEventsMockImpl)

	typedef IVsUserContextItemEvents Interface;
	struct OnUserContextItemsAvailableValidValues
	{
		/*[in]*/ IVsUserContextItemCollection* pList;
		HRESULT retValue;
	};

	STDMETHOD(OnUserContextItemsAvailable)(
		/*[in]*/ IVsUserContextItemCollection* pList)
	{
		VSL_DEFINE_MOCK_METHOD(OnUserContextItemsAvailable)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pList);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSUSERCONTEXTITEMEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsUserContextItemProvider.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSUSERCONTEXTITEMPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSUSERCONTEXTITEMPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "context.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsUserContextItemProviderNotImpl :
	public IVsUserContextItemProvider
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUserContextItemProviderNotImpl)

public:

	typedef IVsUserContextItemProvider Interface;

	STDMETHOD(GetProperty)(
		/*[in]*/ VSCIPPROPID /*property*/,
		/*[out,retval]*/ VARIANT* /*pvar*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetProperty)(
		/*[in]*/ VSCIPPROPID /*property*/,
		/*[in]*/ VARIANT /*var*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(KeywordLookup)(
		/*[in]*/ LPCOLESTR /*pwzTargetAttr*/,
		/*[in]*/ LPCOLESTR /*pwzTargetAttrValue*/,
		/*[out]*/ IVsUserContextItemCollection** /*ppList*/,
		/*[in]*/ IVsMonitorUserContext* /*pCMUC*/,
		/*[in]*/ BOOL /*fCheckIdle*/,
		/*[in]*/ BOOL /*fContinueInterrupt*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(PackedAttributeLookup)(
		/*[in]*/ LPCOLESTR /*pwzRequired*/,
		/*[in]*/ LPCOLESTR /*pwzScope*/,
		/*[out]*/ IVsUserContextItemCollection** /*ppList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LookupEnabled)(
		/*[out]*/ BOOL* /*pfLookupEnabled*/)VSL_STDMETHOD_NOTIMPL
};

class IVsUserContextItemProviderMockImpl :
	public IVsUserContextItemProvider,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUserContextItemProviderMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsUserContextItemProviderMockImpl)

	typedef IVsUserContextItemProvider Interface;
	struct GetPropertyValidValues
	{
		/*[in]*/ VSCIPPROPID property;
		/*[out,retval]*/ VARIANT* pvar;
		HRESULT retValue;
	};

	STDMETHOD(GetProperty)(
		/*[in]*/ VSCIPPROPID property,
		/*[out,retval]*/ VARIANT* pvar)
	{
		VSL_DEFINE_MOCK_METHOD(GetProperty)

		VSL_CHECK_VALIDVALUE(property);

		VSL_SET_VALIDVALUE_VARIANT(pvar);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetPropertyValidValues
	{
		/*[in]*/ VSCIPPROPID property;
		/*[in]*/ VARIANT var;
		HRESULT retValue;
	};

	STDMETHOD(SetProperty)(
		/*[in]*/ VSCIPPROPID property,
		/*[in]*/ VARIANT var)
	{
		VSL_DEFINE_MOCK_METHOD(SetProperty)

		VSL_CHECK_VALIDVALUE(property);

		VSL_CHECK_VALIDVALUE(var);

		VSL_RETURN_VALIDVALUES();
	}
	struct KeywordLookupValidValues
	{
		/*[in]*/ LPCOLESTR pwzTargetAttr;
		/*[in]*/ LPCOLESTR pwzTargetAttrValue;
		/*[out]*/ IVsUserContextItemCollection** ppList;
		/*[in]*/ IVsMonitorUserContext* pCMUC;
		/*[in]*/ BOOL fCheckIdle;
		/*[in]*/ BOOL fContinueInterrupt;
		HRESULT retValue;
	};

	STDMETHOD(KeywordLookup)(
		/*[in]*/ LPCOLESTR pwzTargetAttr,
		/*[in]*/ LPCOLESTR pwzTargetAttrValue,
		/*[out]*/ IVsUserContextItemCollection** ppList,
		/*[in]*/ IVsMonitorUserContext* pCMUC,
		/*[in]*/ BOOL fCheckIdle,
		/*[in]*/ BOOL fContinueInterrupt)
	{
		VSL_DEFINE_MOCK_METHOD(KeywordLookup)

		VSL_CHECK_VALIDVALUE_STRINGW(pwzTargetAttr);

		VSL_CHECK_VALIDVALUE_STRINGW(pwzTargetAttrValue);

		VSL_SET_VALIDVALUE_INTERFACE(ppList);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCMUC);

		VSL_CHECK_VALIDVALUE(fCheckIdle);

		VSL_CHECK_VALIDVALUE(fContinueInterrupt);

		VSL_RETURN_VALIDVALUES();
	}
	struct PackedAttributeLookupValidValues
	{
		/*[in]*/ LPCOLESTR pwzRequired;
		/*[in]*/ LPCOLESTR pwzScope;
		/*[out]*/ IVsUserContextItemCollection** ppList;
		HRESULT retValue;
	};

	STDMETHOD(PackedAttributeLookup)(
		/*[in]*/ LPCOLESTR pwzRequired,
		/*[in]*/ LPCOLESTR pwzScope,
		/*[out]*/ IVsUserContextItemCollection** ppList)
	{
		VSL_DEFINE_MOCK_METHOD(PackedAttributeLookup)

		VSL_CHECK_VALIDVALUE_STRINGW(pwzRequired);

		VSL_CHECK_VALIDVALUE_STRINGW(pwzScope);

		VSL_SET_VALIDVALUE_INTERFACE(ppList);

		VSL_RETURN_VALIDVALUES();
	}
	struct LookupEnabledValidValues
	{
		/*[out]*/ BOOL* pfLookupEnabled;
		HRESULT retValue;
	};

	STDMETHOD(LookupEnabled)(
		/*[out]*/ BOOL* pfLookupEnabled)
	{
		VSL_DEFINE_MOCK_METHOD(LookupEnabled)

		VSL_SET_VALIDVALUE(pfLookupEnabled);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSUSERCONTEXTITEMPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsUserContextItem.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSUSERCONTEXTITEM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSUSERCONTEXTITEM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "context.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsUserContextItemNotImpl :
	public IVsUserContextItem
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUserContextItemNotImpl)

public:

	typedef IVsUserContextItem Interface;

	STDMETHOD(get_Name)(
		/*[out,retval]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Command)(
		/*[out,retval]*/ BSTR* /*pbstrCommand*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CountAttributes)(
		/*[in]*/ LPCOLESTR /*pszAttrName*/,
		/*[out,retval]*/ int* /*pc*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetAttribute)(
		/*[in]*/ LPCOLESTR /*pszAttrName*/,
		/*[in]*/ int /*index*/,
		/*[out,optional]*/ BSTR* /*pbstrName*/,
		/*[out,optional,retval]*/ BSTR* /*pbstrValue*/)VSL_STDMETHOD_NOTIMPL
};

class IVsUserContextItemMockImpl :
	public IVsUserContextItem,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUserContextItemMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsUserContextItemMockImpl)

	typedef IVsUserContextItem Interface;
	struct get_NameValidValues
	{
		/*[out,retval]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(get_Name)(
		/*[out,retval]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(get_Name)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CommandValidValues
	{
		/*[out,retval]*/ BSTR* pbstrCommand;
		HRESULT retValue;
	};

	STDMETHOD(get_Command)(
		/*[out,retval]*/ BSTR* pbstrCommand)
	{
		VSL_DEFINE_MOCK_METHOD(get_Command)

		VSL_SET_VALIDVALUE_BSTR(pbstrCommand);

		VSL_RETURN_VALIDVALUES();
	}
	struct CountAttributesValidValues
	{
		/*[in]*/ LPCOLESTR pszAttrName;
		/*[out,retval]*/ int* pc;
		HRESULT retValue;
	};

	STDMETHOD(CountAttributes)(
		/*[in]*/ LPCOLESTR pszAttrName,
		/*[out,retval]*/ int* pc)
	{
		VSL_DEFINE_MOCK_METHOD(CountAttributes)

		VSL_CHECK_VALIDVALUE_STRINGW(pszAttrName);

		VSL_SET_VALIDVALUE(pc);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetAttributeValidValues
	{
		/*[in]*/ LPCOLESTR pszAttrName;
		/*[in]*/ int index;
		/*[out,optional]*/ BSTR* pbstrName;
		/*[out,optional,retval]*/ BSTR* pbstrValue;
		HRESULT retValue;
	};

	STDMETHOD(GetAttribute)(
		/*[in]*/ LPCOLESTR pszAttrName,
		/*[in]*/ int index,
		/*[out,optional]*/ BSTR* pbstrName,
		/*[out,optional,retval]*/ BSTR* pbstrValue)
	{
		VSL_DEFINE_MOCK_METHOD(GetAttribute)

		VSL_CHECK_VALIDVALUE_STRINGW(pszAttrName);

		VSL_CHECK_VALIDVALUE(index);

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_SET_VALIDVALUE_BSTR(pbstrValue);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSUSERCONTEXTITEM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsUserSettingsQuery.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSUSERSETTINGSQUERY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSUSERSETTINGSQUERY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsUserSettingsQueryNotImpl :
	public IVsUserSettingsQuery
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUserSettingsQueryNotImpl)

public:

	typedef IVsUserSettingsQuery Interface;

	STDMETHOD(NeedExport)(
		/*[in]*/ LPCOLESTR /*szCategoryGUID*/,
		/*[out]*/ BOOL* /*pfNeedExport*/)VSL_STDMETHOD_NOTIMPL
};

class IVsUserSettingsQueryMockImpl :
	public IVsUserSettingsQuery,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUserSettingsQueryMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsUserSettingsQueryMockImpl)

	typedef IVsUserSettingsQuery Interface;
	struct NeedExportValidValues
	{
		/*[in]*/ LPCOLESTR szCategoryGUID;
		/*[out]*/ BOOL* pfNeedExport;
		HRESULT retValue;
	};

	STDMETHOD(NeedExport)(
		/*[in]*/ LPCOLESTR szCategoryGUID,
		/*[out]*/ BOOL* pfNeedExport)
	{
		VSL_DEFINE_MOCK_METHOD(NeedExport)

		VSL_CHECK_VALIDVALUE_STRINGW(szCategoryGUID);

		VSL_SET_VALIDVALUE(pfNeedExport);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSUSERSETTINGSQUERY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsUserData.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSUSERDATA_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSUSERDATA_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsUserDataNotImpl :
	public IVsUserData
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUserDataNotImpl)

public:

	typedef IVsUserData Interface;

	STDMETHOD(GetData)(
		/*[in]*/ REFGUID /*riidKey*/,
		/*[out]*/ VARIANT* /*pvtData*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetData)(
		/*[in]*/ REFGUID /*riidKey*/,
		/*[in]*/ VARIANT /*vtData*/)VSL_STDMETHOD_NOTIMPL
};

class IVsUserDataMockImpl :
	public IVsUserData,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUserDataMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsUserDataMockImpl)

	typedef IVsUserData Interface;
	struct GetDataValidValues
	{
		/*[in]*/ REFGUID riidKey;
		/*[out]*/ VARIANT* pvtData;
		HRESULT retValue;
	};

	STDMETHOD(GetData)(
		/*[in]*/ REFGUID riidKey,
		/*[out]*/ VARIANT* pvtData)
	{
		VSL_DEFINE_MOCK_METHOD(GetData)

		VSL_CHECK_VALIDVALUE(riidKey);

		VSL_SET_VALIDVALUE_VARIANT(pvtData);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetDataValidValues
	{
		/*[in]*/ REFGUID riidKey;
		/*[in]*/ VARIANT vtData;
		HRESULT retValue;
	};

	STDMETHOD(SetData)(
		/*[in]*/ REFGUID riidKey,
		/*[in]*/ VARIANT vtData)
	{
		VSL_DEFINE_MOCK_METHOD(SetData)

		VSL_CHECK_VALIDVALUE(riidKey);

		VSL_CHECK_VALIDVALUE(vtData);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSUSERDATA_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsWebBrowser.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSWEBBROWSER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSWEBBROWSER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsbrowse.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsWebBrowserNotImpl :
	public IVsWebBrowser
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWebBrowserNotImpl)

public:

	typedef IVsWebBrowser Interface;

	STDMETHOD(Navigate)(
		/*[in]*/ DWORD /*dwFlags*/,
		/*[in]*/ LPCOLESTR /*lpszURL*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(NavigateEx)(
		/*[in]*/ DWORD /*dwFlags*/,
		/*[in]*/ LPCOLESTR /*lpszURL*/,
		/*[in]*/ VARIANT* /*pvarTargetFrame*/,
		/*[in]*/ VARIANT* /*pvarPostData*/,
		/*[in]*/ VARIANT* /*pvarHeaders*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Stop)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Refresh)(
		/*[in]*/ VSWBREFRESHTYPE /*dwRefreshType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDocumentInfo)(
		/*[in]*/ VSWBDOCINFOINDEX /*dwInfoIndex*/,
		/*[out]*/ VARIANT* /*pvarInfo*/)VSL_STDMETHOD_NOTIMPL
};

class IVsWebBrowserMockImpl :
	public IVsWebBrowser,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWebBrowserMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsWebBrowserMockImpl)

	typedef IVsWebBrowser Interface;
	struct NavigateValidValues
	{
		/*[in]*/ DWORD dwFlags;
		/*[in]*/ LPCOLESTR lpszURL;
		HRESULT retValue;
	};

	STDMETHOD(Navigate)(
		/*[in]*/ DWORD dwFlags,
		/*[in]*/ LPCOLESTR lpszURL)
	{
		VSL_DEFINE_MOCK_METHOD(Navigate)

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszURL);

		VSL_RETURN_VALIDVALUES();
	}
	struct NavigateExValidValues
	{
		/*[in]*/ DWORD dwFlags;
		/*[in]*/ LPCOLESTR lpszURL;
		/*[in]*/ VARIANT* pvarTargetFrame;
		/*[in]*/ VARIANT* pvarPostData;
		/*[in]*/ VARIANT* pvarHeaders;
		HRESULT retValue;
	};

	STDMETHOD(NavigateEx)(
		/*[in]*/ DWORD dwFlags,
		/*[in]*/ LPCOLESTR lpszURL,
		/*[in]*/ VARIANT* pvarTargetFrame,
		/*[in]*/ VARIANT* pvarPostData,
		/*[in]*/ VARIANT* pvarHeaders)
	{
		VSL_DEFINE_MOCK_METHOD(NavigateEx)

		VSL_CHECK_VALIDVALUE(dwFlags);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszURL);

		VSL_CHECK_VALIDVALUE_POINTER(pvarTargetFrame);

		VSL_CHECK_VALIDVALUE_POINTER(pvarPostData);

		VSL_CHECK_VALIDVALUE_POINTER(pvarHeaders);

		VSL_RETURN_VALIDVALUES();
	}
	struct StopValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Stop)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Stop)

		VSL_RETURN_VALIDVALUES();
	}
	struct RefreshValidValues
	{
		/*[in]*/ VSWBREFRESHTYPE dwRefreshType;
		HRESULT retValue;
	};

	STDMETHOD(Refresh)(
		/*[in]*/ VSWBREFRESHTYPE dwRefreshType)
	{
		VSL_DEFINE_MOCK_METHOD(Refresh)

		VSL_CHECK_VALIDVALUE(dwRefreshType);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDocumentInfoValidValues
	{
		/*[in]*/ VSWBDOCINFOINDEX dwInfoIndex;
		/*[out]*/ VARIANT* pvarInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetDocumentInfo)(
		/*[in]*/ VSWBDOCINFOINDEX dwInfoIndex,
		/*[out]*/ VARIANT* pvarInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetDocumentInfo)

		VSL_CHECK_VALIDVALUE(dwInfoIndex);

		VSL_SET_VALIDVALUE_VARIANT(pvarInfo);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSWEBBROWSER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsUserContextUpdate.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSUSERCONTEXTUPDATE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSUSERCONTEXTUPDATE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "context.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsUserContextUpdateNotImpl :
	public IVsUserContextUpdate
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUserContextUpdateNotImpl)

public:

	typedef IVsUserContextUpdate Interface;

	STDMETHOD(UpdateUserContext)(
		/*[in]*/ IVsUserContext* /*pCtx*/,
		/*[in]*/ VSCOOKIE /*dwCookie*/)VSL_STDMETHOD_NOTIMPL
};

class IVsUserContextUpdateMockImpl :
	public IVsUserContextUpdate,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUserContextUpdateMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsUserContextUpdateMockImpl)

	typedef IVsUserContextUpdate Interface;
	struct UpdateUserContextValidValues
	{
		/*[in]*/ IVsUserContext* pCtx;
		/*[in]*/ VSCOOKIE dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(UpdateUserContext)(
		/*[in]*/ IVsUserContext* pCtx,
		/*[in]*/ VSCOOKIE dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(UpdateUserContext)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pCtx);

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSUSERCONTEXTUPDATE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsUserSettings.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSUSERSETTINGS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSUSERSETTINGS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsUserSettingsNotImpl :
	public IVsUserSettings
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUserSettingsNotImpl)

public:

	typedef IVsUserSettings Interface;

	STDMETHOD(ExportSettings)(
		/*[in]*/ LPCOLESTR /*pszCategoryGUID*/,
		/*[in]*/ IVsSettingsWriter* /*pSettings*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ImportSettings)(
		/*[in]*/ LPCOLESTR /*pszCategoryGUID*/,
		/*[in]*/ IVsSettingsReader* /*pSettings*/,
		/*[in]*/ UserSettingsFlags /*flags*/,
		/*[in,out]*/ BOOL* /*pfRestartRequired*/)VSL_STDMETHOD_NOTIMPL
};

class IVsUserSettingsMockImpl :
	public IVsUserSettings,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsUserSettingsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsUserSettingsMockImpl)

	typedef IVsUserSettings Interface;
	struct ExportSettingsValidValues
	{
		/*[in]*/ LPCOLESTR pszCategoryGUID;
		/*[in]*/ IVsSettingsWriter* pSettings;
		HRESULT retValue;
	};

	STDMETHOD(ExportSettings)(
		/*[in]*/ LPCOLESTR pszCategoryGUID,
		/*[in]*/ IVsSettingsWriter* pSettings)
	{
		VSL_DEFINE_MOCK_METHOD(ExportSettings)

		VSL_CHECK_VALIDVALUE_STRINGW(pszCategoryGUID);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSettings);

		VSL_RETURN_VALIDVALUES();
	}
	struct ImportSettingsValidValues
	{
		/*[in]*/ LPCOLESTR pszCategoryGUID;
		/*[in]*/ IVsSettingsReader* pSettings;
		/*[in]*/ UserSettingsFlags flags;
		/*[in,out]*/ BOOL* pfRestartRequired;
		HRESULT retValue;
	};

	STDMETHOD(ImportSettings)(
		/*[in]*/ LPCOLESTR pszCategoryGUID,
		/*[in]*/ IVsSettingsReader* pSettings,
		/*[in]*/ UserSettingsFlags flags,
		/*[in,out]*/ BOOL* pfRestartRequired)
	{
		VSL_DEFINE_MOCK_METHOD(ImportSettings)

		VSL_CHECK_VALIDVALUE_STRINGW(pszCategoryGUID);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSettings);

		VSL_CHECK_VALIDVALUE(flags);

		VSL_SET_VALIDVALUE(pfRestartRequired);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSUSERSETTINGS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsVba.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSVBA_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSVBA_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vbapkg.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsVbaNotImpl :
	public IVsVba
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsVbaNotImpl)

public:

	typedef IVsVba Interface;

	STDMETHOD(ShowVBA)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetVbaUnk)(
		/*[in]*/ IUnknown** /*pUnknown*/)VSL_STDMETHOD_NOTIMPL
};

class IVsVbaMockImpl :
	public IVsVba,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsVbaMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsVbaMockImpl)

	typedef IVsVba Interface;
	struct ShowVBAValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(ShowVBA)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(ShowVBA)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetVbaUnkValidValues
	{
		/*[in]*/ IUnknown** pUnknown;
		HRESULT retValue;
	};

	STDMETHOD(GetVbaUnk)(
		/*[in]*/ IUnknown** pUnknown)
	{
		VSL_DEFINE_MOCK_METHOD(GetVbaUnk)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUnknown);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSVBA_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsViewRangeClient.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSVIEWRANGECLIENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSVIEWRANGECLIENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "textmgr.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsViewRangeClientNotImpl :
	public IVsViewRangeClient
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsViewRangeClientNotImpl)

public:

	typedef IVsViewRangeClient Interface;

	STDMETHOD(AdjustViewRange)(
		/*[in]*/ IVsTextView* /*pView*/,
		/*[in]*/ TextViewAction /*action*/,
		/*[in]*/ long /*iLine*/,
		/*[in]*/ long /*iCount*/)VSL_STDMETHOD_NOTIMPL
};

class IVsViewRangeClientMockImpl :
	public IVsViewRangeClient,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsViewRangeClientMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsViewRangeClientMockImpl)

	typedef IVsViewRangeClient Interface;
	struct AdjustViewRangeValidValues
	{
		/*[in]*/ IVsTextView* pView;
		/*[in]*/ TextViewAction action;
		/*[in]*/ long iLine;
		/*[in]*/ long iCount;
		HRESULT retValue;
	};

	STDMETHOD(AdjustViewRange)(
		/*[in]*/ IVsTextView* pView,
		/*[in]*/ TextViewAction action,
		/*[in]*/ long iLine,
		/*[in]*/ long iCount)
	{
		VSL_DEFINE_MOCK_METHOD(AdjustViewRange)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pView);

		VSL_CHECK_VALIDVALUE(action);

		VSL_CHECK_VALIDVALUE(iLine);

		VSL_CHECK_VALIDVALUE(iCount);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSVIEWRANGECLIENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsWebBrowserUser.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSWEBBROWSERUSER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSWEBBROWSERUSER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsbrowse.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsWebBrowserUserNotImpl :
	public IVsWebBrowserUser
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWebBrowserUserNotImpl)

public:

	typedef IVsWebBrowserUser Interface;

	STDMETHOD(Disconnect)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCustomMenuInfo)(
		/*[in]*/ IUnknown* /*pUnkCmdReserved*/,
		/*[in]*/ IDispatch* /*pDispReserved*/,
		/*[in]*/ DWORD /*dwType*/,
		/*[in]*/ DWORD /*dwPosition*/,
		/*[out]*/ GUID* /*pguidCmdGroup*/,
		/*[out]*/ long* /*pdwMenuID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCmdUIGuid)(
		/*[out]*/ GUID* /*pguidCmdUI*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetExternalObject)(
		/*[out]*/ IDispatch** /*ppDispObject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(TranslateUrl)(
		/*[in]*/ DWORD /*dwReserved*/,
		/*[in]*/ LPCOLESTR /*lpszURLIn*/,
		/*[out]*/ LPOLESTR* /*lppszURLOut*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(FilterDataObject)(
		/*[in]*/ IDataObject* /*pDataObjIn*/,
		/*[out]*/ IDataObject** /*ppDataObjOut*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDropTarget)(
		/*[in]*/ IDropTarget* /*pDropTgtIn*/,
		/*[out]*/ IDropTarget** /*ppDropTgtOut*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(TranslateAccelarator)(
		/*[in]*/ LPMSG /*lpMsg*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCustomURL)(
		/*[in]*/ VSWBCUSTOMURL /*nPage*/,
		/*[out]*/ BSTR* /*pbstrURL*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetOptionKeyPath)(
		/*[in]*/ DWORD /*dwReserved*/,
		/*[out]*/ BSTR* /*pbstrKey*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Resize)(
		/*[in]*/ int /*cx*/,
		/*[in]*/ int /*cy*/)VSL_STDMETHOD_NOTIMPL
};

class IVsWebBrowserUserMockImpl :
	public IVsWebBrowserUser,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWebBrowserUserMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsWebBrowserUserMockImpl)

	typedef IVsWebBrowserUser Interface;
	struct DisconnectValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Disconnect)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Disconnect)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCustomMenuInfoValidValues
	{
		/*[in]*/ IUnknown* pUnkCmdReserved;
		/*[in]*/ IDispatch* pDispReserved;
		/*[in]*/ DWORD dwType;
		/*[in]*/ DWORD dwPosition;
		/*[out]*/ GUID* pguidCmdGroup;
		/*[out]*/ long* pdwMenuID;
		HRESULT retValue;
	};

	STDMETHOD(GetCustomMenuInfo)(
		/*[in]*/ IUnknown* pUnkCmdReserved,
		/*[in]*/ IDispatch* pDispReserved,
		/*[in]*/ DWORD dwType,
		/*[in]*/ DWORD dwPosition,
		/*[out]*/ GUID* pguidCmdGroup,
		/*[out]*/ long* pdwMenuID)
	{
		VSL_DEFINE_MOCK_METHOD(GetCustomMenuInfo)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUnkCmdReserved);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDispReserved);

		VSL_CHECK_VALIDVALUE(dwType);

		VSL_CHECK_VALIDVALUE(dwPosition);

		VSL_SET_VALIDVALUE(pguidCmdGroup);

		VSL_SET_VALIDVALUE(pdwMenuID);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCmdUIGuidValidValues
	{
		/*[out]*/ GUID* pguidCmdUI;
		HRESULT retValue;
	};

	STDMETHOD(GetCmdUIGuid)(
		/*[out]*/ GUID* pguidCmdUI)
	{
		VSL_DEFINE_MOCK_METHOD(GetCmdUIGuid)

		VSL_SET_VALIDVALUE(pguidCmdUI);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetExternalObjectValidValues
	{
		/*[out]*/ IDispatch** ppDispObject;
		HRESULT retValue;
	};

	STDMETHOD(GetExternalObject)(
		/*[out]*/ IDispatch** ppDispObject)
	{
		VSL_DEFINE_MOCK_METHOD(GetExternalObject)

		VSL_SET_VALIDVALUE_INTERFACE(ppDispObject);

		VSL_RETURN_VALIDVALUES();
	}
	struct TranslateUrlValidValues
	{
		/*[in]*/ DWORD dwReserved;
		/*[in]*/ LPCOLESTR lpszURLIn;
		/*[out]*/ LPOLESTR* lppszURLOut;
		HRESULT retValue;
	};

	STDMETHOD(TranslateUrl)(
		/*[in]*/ DWORD dwReserved,
		/*[in]*/ LPCOLESTR lpszURLIn,
		/*[out]*/ LPOLESTR* lppszURLOut)
	{
		VSL_DEFINE_MOCK_METHOD(TranslateUrl)

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszURLIn);

		VSL_SET_VALIDVALUE(lppszURLOut);

		VSL_RETURN_VALIDVALUES();
	}
	struct FilterDataObjectValidValues
	{
		/*[in]*/ IDataObject* pDataObjIn;
		/*[out]*/ IDataObject** ppDataObjOut;
		HRESULT retValue;
	};

	STDMETHOD(FilterDataObject)(
		/*[in]*/ IDataObject* pDataObjIn,
		/*[out]*/ IDataObject** ppDataObjOut)
	{
		VSL_DEFINE_MOCK_METHOD(FilterDataObject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDataObjIn);

		VSL_SET_VALIDVALUE_INTERFACE(ppDataObjOut);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDropTargetValidValues
	{
		/*[in]*/ IDropTarget* pDropTgtIn;
		/*[out]*/ IDropTarget** ppDropTgtOut;
		HRESULT retValue;
	};

	STDMETHOD(GetDropTarget)(
		/*[in]*/ IDropTarget* pDropTgtIn,
		/*[out]*/ IDropTarget** ppDropTgtOut)
	{
		VSL_DEFINE_MOCK_METHOD(GetDropTarget)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDropTgtIn);

		VSL_SET_VALIDVALUE_INTERFACE(ppDropTgtOut);

		VSL_RETURN_VALIDVALUES();
	}
	struct TranslateAccelaratorValidValues
	{
		/*[in]*/ LPMSG lpMsg;
		HRESULT retValue;
	};

	STDMETHOD(TranslateAccelarator)(
		/*[in]*/ LPMSG lpMsg)
	{
		VSL_DEFINE_MOCK_METHOD(TranslateAccelarator)

		VSL_CHECK_VALIDVALUE(lpMsg);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCustomURLValidValues
	{
		/*[in]*/ VSWBCUSTOMURL nPage;
		/*[out]*/ BSTR* pbstrURL;
		HRESULT retValue;
	};

	STDMETHOD(GetCustomURL)(
		/*[in]*/ VSWBCUSTOMURL nPage,
		/*[out]*/ BSTR* pbstrURL)
	{
		VSL_DEFINE_MOCK_METHOD(GetCustomURL)

		VSL_CHECK_VALIDVALUE(nPage);

		VSL_SET_VALIDVALUE_BSTR(pbstrURL);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetOptionKeyPathValidValues
	{
		/*[in]*/ DWORD dwReserved;
		/*[out]*/ BSTR* pbstrKey;
		HRESULT retValue;
	};

	STDMETHOD(GetOptionKeyPath)(
		/*[in]*/ DWORD dwReserved,
		/*[out]*/ BSTR* pbstrKey)
	{
		VSL_DEFINE_MOCK_METHOD(GetOptionKeyPath)

		VSL_CHECK_VALIDVALUE(dwReserved);

		VSL_SET_VALIDVALUE_BSTR(pbstrKey);

		VSL_RETURN_VALIDVALUES();
	}
	struct ResizeValidValues
	{
		/*[in]*/ int cx;
		/*[in]*/ int cy;
		HRESULT retValue;
	};

	STDMETHOD(Resize)(
		/*[in]*/ int cx,
		/*[in]*/ int cy)
	{
		VSL_DEFINE_MOCK_METHOD(Resize)

		VSL_CHECK_VALIDVALUE(cx);

		VSL_CHECK_VALIDVALUE(cy);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSWEBBROWSERUSER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsWebBrowsingService.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSWEBBROWSINGSERVICE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSWEBBROWSINGSERVICE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsbrowse.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsWebBrowsingServiceNotImpl :
	public IVsWebBrowsingService
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWebBrowsingServiceNotImpl)

public:

	typedef IVsWebBrowsingService Interface;

	STDMETHOD(CreateWebBrowser)(
		/*[in]*/ VSCREATEWEBBROWSER /*dwCreateFlags*/,
		/*[in]*/ REFGUID /*rguidOwner*/,
		/*[in]*/ LPCOLESTR /*lpszBaseCaption*/,
		/*[in]*/ LPCOLESTR /*lpszStartURL*/,
		/*[in]*/ IVsWebBrowserUser* /*pUser*/,
		/*[out]*/ IVsWebBrowser** /*ppBrowser*/,
		/*[out]*/ IVsWindowFrame** /*ppFrame*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetFirstWebBrowser)(
		/*[in]*/ REFGUID /*rguidPersistenceSlot*/,
		/*[out]*/ IVsWindowFrame** /*ppFrame*/,
		/*[out]*/ IVsWebBrowser** /*ppBrowser*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetWebBrowserEnum)(
		/*[in]*/ REFGUID /*rguidPersistenceSlot*/,
		/*[out]*/ IEnumWindowFrames** /*ppEnum*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateExternalWebBrowser)(
		/*[in]*/ VSCREATEWEBBROWSER /*dwCreateFlags*/,
		/*[in]*/ VSPREVIEWRESOLUTION /*dwResolution*/,
		/*[in]*/ LPCOLESTR /*lpszURL*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateWebBrowserEx)(
		/*[in]*/ VSCREATEWEBBROWSER /*dwCreateFlags*/,
		/*[in]*/ REFGUID /*rguidPersistenceSlot*/,
		/*[in]*/ DWORD /*dwId*/,
		/*[in]*/ LPCOLESTR /*lpszBaseCaption*/,
		/*[in]*/ LPCOLESTR /*lpszStartURL*/,
		/*[in]*/ IVsWebBrowserUser* /*pUser*/,
		/*[out]*/ IVsWebBrowser** /*ppBrowser*/,
		/*[out]*/ IVsWindowFrame** /*ppFrame*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Navigate)(
		/*[in]*/ LPCOLESTR /*lpszURL*/,
		/*[in]*/ VSWBNAVIGATEFLAGS /*dwNaviageFlags*/,
		/*[out]*/ IVsWindowFrame** /*ppFrame*/)VSL_STDMETHOD_NOTIMPL
};

class IVsWebBrowsingServiceMockImpl :
	public IVsWebBrowsingService,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWebBrowsingServiceMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsWebBrowsingServiceMockImpl)

	typedef IVsWebBrowsingService Interface;
	struct CreateWebBrowserValidValues
	{
		/*[in]*/ VSCREATEWEBBROWSER dwCreateFlags;
		/*[in]*/ REFGUID rguidOwner;
		/*[in]*/ LPCOLESTR lpszBaseCaption;
		/*[in]*/ LPCOLESTR lpszStartURL;
		/*[in]*/ IVsWebBrowserUser* pUser;
		/*[out]*/ IVsWebBrowser** ppBrowser;
		/*[out]*/ IVsWindowFrame** ppFrame;
		HRESULT retValue;
	};

	STDMETHOD(CreateWebBrowser)(
		/*[in]*/ VSCREATEWEBBROWSER dwCreateFlags,
		/*[in]*/ REFGUID rguidOwner,
		/*[in]*/ LPCOLESTR lpszBaseCaption,
		/*[in]*/ LPCOLESTR lpszStartURL,
		/*[in]*/ IVsWebBrowserUser* pUser,
		/*[out]*/ IVsWebBrowser** ppBrowser,
		/*[out]*/ IVsWindowFrame** ppFrame)
	{
		VSL_DEFINE_MOCK_METHOD(CreateWebBrowser)

		VSL_CHECK_VALIDVALUE(dwCreateFlags);

		VSL_CHECK_VALIDVALUE(rguidOwner);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszBaseCaption);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszStartURL);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUser);

		VSL_SET_VALIDVALUE_INTERFACE(ppBrowser);

		VSL_SET_VALIDVALUE_INTERFACE(ppFrame);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetFirstWebBrowserValidValues
	{
		/*[in]*/ REFGUID rguidPersistenceSlot;
		/*[out]*/ IVsWindowFrame** ppFrame;
		/*[out]*/ IVsWebBrowser** ppBrowser;
		HRESULT retValue;
	};

	STDMETHOD(GetFirstWebBrowser)(
		/*[in]*/ REFGUID rguidPersistenceSlot,
		/*[out]*/ IVsWindowFrame** ppFrame,
		/*[out]*/ IVsWebBrowser** ppBrowser)
	{
		VSL_DEFINE_MOCK_METHOD(GetFirstWebBrowser)

		VSL_CHECK_VALIDVALUE(rguidPersistenceSlot);

		VSL_SET_VALIDVALUE_INTERFACE(ppFrame);

		VSL_SET_VALIDVALUE_INTERFACE(ppBrowser);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetWebBrowserEnumValidValues
	{
		/*[in]*/ REFGUID rguidPersistenceSlot;
		/*[out]*/ IEnumWindowFrames** ppEnum;
		HRESULT retValue;
	};

	STDMETHOD(GetWebBrowserEnum)(
		/*[in]*/ REFGUID rguidPersistenceSlot,
		/*[out]*/ IEnumWindowFrames** ppEnum)
	{
		VSL_DEFINE_MOCK_METHOD(GetWebBrowserEnum)

		VSL_CHECK_VALIDVALUE(rguidPersistenceSlot);

		VSL_SET_VALIDVALUE_INTERFACE(ppEnum);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateExternalWebBrowserValidValues
	{
		/*[in]*/ VSCREATEWEBBROWSER dwCreateFlags;
		/*[in]*/ VSPREVIEWRESOLUTION dwResolution;
		/*[in]*/ LPCOLESTR lpszURL;
		HRESULT retValue;
	};

	STDMETHOD(CreateExternalWebBrowser)(
		/*[in]*/ VSCREATEWEBBROWSER dwCreateFlags,
		/*[in]*/ VSPREVIEWRESOLUTION dwResolution,
		/*[in]*/ LPCOLESTR lpszURL)
	{
		VSL_DEFINE_MOCK_METHOD(CreateExternalWebBrowser)

		VSL_CHECK_VALIDVALUE(dwCreateFlags);

		VSL_CHECK_VALIDVALUE(dwResolution);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszURL);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateWebBrowserExValidValues
	{
		/*[in]*/ VSCREATEWEBBROWSER dwCreateFlags;
		/*[in]*/ REFGUID rguidPersistenceSlot;
		/*[in]*/ DWORD dwId;
		/*[in]*/ LPCOLESTR lpszBaseCaption;
		/*[in]*/ LPCOLESTR lpszStartURL;
		/*[in]*/ IVsWebBrowserUser* pUser;
		/*[out]*/ IVsWebBrowser** ppBrowser;
		/*[out]*/ IVsWindowFrame** ppFrame;
		HRESULT retValue;
	};

	STDMETHOD(CreateWebBrowserEx)(
		/*[in]*/ VSCREATEWEBBROWSER dwCreateFlags,
		/*[in]*/ REFGUID rguidPersistenceSlot,
		/*[in]*/ DWORD dwId,
		/*[in]*/ LPCOLESTR lpszBaseCaption,
		/*[in]*/ LPCOLESTR lpszStartURL,
		/*[in]*/ IVsWebBrowserUser* pUser,
		/*[out]*/ IVsWebBrowser** ppBrowser,
		/*[out]*/ IVsWindowFrame** ppFrame)
	{
		VSL_DEFINE_MOCK_METHOD(CreateWebBrowserEx)

		VSL_CHECK_VALIDVALUE(dwCreateFlags);

		VSL_CHECK_VALIDVALUE(rguidPersistenceSlot);

		VSL_CHECK_VALIDVALUE(dwId);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszBaseCaption);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszStartURL);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pUser);

		VSL_SET_VALIDVALUE_INTERFACE(ppBrowser);

		VSL_SET_VALIDVALUE_INTERFACE(ppFrame);

		VSL_RETURN_VALIDVALUES();
	}
	struct NavigateValidValues
	{
		/*[in]*/ LPCOLESTR lpszURL;
		/*[in]*/ VSWBNAVIGATEFLAGS dwNaviageFlags;
		/*[out]*/ IVsWindowFrame** ppFrame;
		HRESULT retValue;
	};

	STDMETHOD(Navigate)(
		/*[in]*/ LPCOLESTR lpszURL,
		/*[in]*/ VSWBNAVIGATEFLAGS dwNaviageFlags,
		/*[out]*/ IVsWindowFrame** ppFrame)
	{
		VSL_DEFINE_MOCK_METHOD(Navigate)

		VSL_CHECK_VALIDVALUE_STRINGW(lpszURL);

		VSL_CHECK_VALIDVALUE(dwNaviageFlags);

		VSL_SET_VALIDVALUE_INTERFACE(ppFrame);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSWEBBROWSINGSERVICE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsWebFavorites.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSWEBFAVORITES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSWEBFAVORITES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsbrowse.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsWebFavoritesNotImpl :
	public IVsWebFavorites
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWebFavoritesNotImpl)

public:

	typedef IVsWebFavorites Interface;

	STDMETHOD(AddFavorite)(
		/*[in]*/ LPCOLESTR /*lpszURL*/,
		/*[in]*/ LPCOLESTR /*lpszName*/,
		/*[in]*/ LPCOLESTR /*pszIconFileName*/,
		/*[in]*/ int /*iIconIndex*/,
		/*[out]*/ BSTR* /*pbstrFileName*/)VSL_STDMETHOD_NOTIMPL
};

class IVsWebFavoritesMockImpl :
	public IVsWebFavorites,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWebFavoritesMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsWebFavoritesMockImpl)

	typedef IVsWebFavorites Interface;
	struct AddFavoriteValidValues
	{
		/*[in]*/ LPCOLESTR lpszURL;
		/*[in]*/ LPCOLESTR lpszName;
		/*[in]*/ LPCOLESTR pszIconFileName;
		/*[in]*/ int iIconIndex;
		/*[out]*/ BSTR* pbstrFileName;
		HRESULT retValue;
	};

	STDMETHOD(AddFavorite)(
		/*[in]*/ LPCOLESTR lpszURL,
		/*[in]*/ LPCOLESTR lpszName,
		/*[in]*/ LPCOLESTR pszIconFileName,
		/*[in]*/ int iIconIndex,
		/*[out]*/ BSTR* pbstrFileName)
	{
		VSL_DEFINE_MOCK_METHOD(AddFavorite)

		VSL_CHECK_VALIDVALUE_STRINGW(lpszURL);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszIconFileName);

		VSL_CHECK_VALIDVALUE(iIconIndex);

		VSL_SET_VALIDVALUE_BSTR(pbstrFileName);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSWEBFAVORITES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsWebFormDesignerSupport.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSWEBFORMDESIGNERSUPPORT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSWEBFORMDESIGNERSUPPORT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "singlefileeditor.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsWebFormDesignerSupportNotImpl :
	public IVsWebFormDesignerSupport
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWebFormDesignerSupportNotImpl)

public:

	typedef IVsWebFormDesignerSupport Interface;

	STDMETHOD(GetCodeDomProvider)(
		/*[out]*/ IUnknown** /*ppProvider*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddReference)(
		/*[in]*/ LPCWSTR /*pszReference*/)VSL_STDMETHOD_NOTIMPL
};

class IVsWebFormDesignerSupportMockImpl :
	public IVsWebFormDesignerSupport,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWebFormDesignerSupportMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsWebFormDesignerSupportMockImpl)

	typedef IVsWebFormDesignerSupport Interface;
	struct GetCodeDomProviderValidValues
	{
		/*[out]*/ IUnknown** ppProvider;
		HRESULT retValue;
	};

	STDMETHOD(GetCodeDomProvider)(
		/*[out]*/ IUnknown** ppProvider)
	{
		VSL_DEFINE_MOCK_METHOD(GetCodeDomProvider)

		VSL_SET_VALIDVALUE_INTERFACE(ppProvider);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddReferenceValidValues
	{
		/*[in]*/ LPCWSTR pszReference;
		HRESULT retValue;
	};

	STDMETHOD(AddReference)(
		/*[in]*/ LPCWSTR pszReference)
	{
		VSL_DEFINE_MOCK_METHOD(AddReference)

		VSL_CHECK_VALIDVALUE_STRINGW(pszReference);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSWEBFORMDESIGNERSUPPORT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsWebMigrationService.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSWEBMIGRATIONSERVICE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSWEBMIGRATIONSERVICE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "webmigration.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsWebMigrationServiceNotImpl :
	public IVsWebMigrationService
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWebMigrationServiceNotImpl)

public:

	typedef IVsWebMigrationService Interface;

	STDMETHOD(MigrateWeb)(
		/*[in]*/ IVsProject* /*pIVsProj*/,
		/*[in]*/ LPCOLESTR /*pszLocation*/,
		/*[in]*/ LPCOLESTR /*pszProjFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsWebProject)(
		/*[in]*/ LPCOLESTR /*pszProjFile*/,
		/*[out]*/ BOOL* /*pIsWeb*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProjectSCCInfo)(
		/*[in]*/ BSTR /*bstrProjectFIle*/,
		/*[out]*/ BSTR* /*pbstrSccProjectName*/,
		/*[out]*/ BSTR* /*pbstrSccAuxPath*/,
		/*[out]*/ BSTR* /*pbstrSccLocalPath*/,
		/*[out]*/ BSTR* /*pbstrProvider*/)VSL_STDMETHOD_NOTIMPL
};

class IVsWebMigrationServiceMockImpl :
	public IVsWebMigrationService,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWebMigrationServiceMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsWebMigrationServiceMockImpl)

	typedef IVsWebMigrationService Interface;
	struct MigrateWebValidValues
	{
		/*[in]*/ IVsProject* pIVsProj;
		/*[in]*/ LPCOLESTR pszLocation;
		/*[in]*/ LPCOLESTR pszProjFile;
		HRESULT retValue;
	};

	STDMETHOD(MigrateWeb)(
		/*[in]*/ IVsProject* pIVsProj,
		/*[in]*/ LPCOLESTR pszLocation,
		/*[in]*/ LPCOLESTR pszProjFile)
	{
		VSL_DEFINE_MOCK_METHOD(MigrateWeb)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIVsProj);

		VSL_CHECK_VALIDVALUE_STRINGW(pszLocation);

		VSL_CHECK_VALIDVALUE_STRINGW(pszProjFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsWebProjectValidValues
	{
		/*[in]*/ LPCOLESTR pszProjFile;
		/*[out]*/ BOOL* pIsWeb;
		HRESULT retValue;
	};

	STDMETHOD(IsWebProject)(
		/*[in]*/ LPCOLESTR pszProjFile,
		/*[out]*/ BOOL* pIsWeb)
	{
		VSL_DEFINE_MOCK_METHOD(IsWebProject)

		VSL_CHECK_VALIDVALUE_STRINGW(pszProjFile);

		VSL_SET_VALIDVALUE(pIsWeb);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetProjectSCCInfoValidValues
	{
		/*[in]*/ BSTR bstrProjectFIle;
		/*[out]*/ BSTR* pbstrSccProjectName;
		/*[out]*/ BSTR* pbstrSccAuxPath;
		/*[out]*/ BSTR* pbstrSccLocalPath;
		/*[out]*/ BSTR* pbstrProvider;
		HRESULT retValue;
	};

	STDMETHOD(GetProjectSCCInfo)(
		/*[in]*/ BSTR bstrProjectFIle,
		/*[out]*/ BSTR* pbstrSccProjectName,
		/*[out]*/ BSTR* pbstrSccAuxPath,
		/*[out]*/ BSTR* pbstrSccLocalPath,
		/*[out]*/ BSTR* pbstrProvider)
	{
		VSL_DEFINE_MOCK_METHOD(GetProjectSCCInfo)

		VSL_CHECK_VALIDVALUE_BSTR(bstrProjectFIle);

		VSL_SET_VALIDVALUE_BSTR(pbstrSccProjectName);

		VSL_SET_VALIDVALUE_BSTR(pbstrSccAuxPath);

		VSL_SET_VALIDVALUE_BSTR(pbstrSccLocalPath);

		VSL_SET_VALIDVALUE_BSTR(pbstrProvider);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSWEBMIGRATIONSERVICE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsWebBrowserUser2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSWEBBROWSERUSER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSWEBBROWSERUSER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsWebBrowserUser2NotImpl :
	public IVsWebBrowserUser2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWebBrowserUser2NotImpl)

public:

	typedef IVsWebBrowserUser2 Interface;

	STDMETHOD(GetWebBrowserContext)(
		/*[out]*/ IServiceProvider** /*ppServiceProvider*/)VSL_STDMETHOD_NOTIMPL
};

class IVsWebBrowserUser2MockImpl :
	public IVsWebBrowserUser2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWebBrowserUser2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsWebBrowserUser2MockImpl)

	typedef IVsWebBrowserUser2 Interface;
	struct GetWebBrowserContextValidValues
	{
		/*[out]*/ IServiceProvider** ppServiceProvider;
		HRESULT retValue;
	};

	STDMETHOD(GetWebBrowserContext)(
		/*[out]*/ IServiceProvider** ppServiceProvider)
	{
		VSL_DEFINE_MOCK_METHOD(GetWebBrowserContext)

		VSL_SET_VALIDVALUE_INTERFACE(ppServiceProvider);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSWEBBROWSERUSER2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsWebMigration.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSWEBMIGRATION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSWEBMIGRATION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "webmigration.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsWebMigrationNotImpl :
	public IVsWebMigration
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWebMigrationNotImpl)

public:

	typedef IVsWebMigration Interface;

	STDMETHOD(LoadAssembly)(
		/*[in]*/ BSTR /*bstrFilePath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetBaseType)(
		/*[in]*/ BSTR /*bstrClassName*/,
		/*[out]*/ BSTR* /*pbstrBaseClass*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Unload)()VSL_STDMETHOD_NOTIMPL
};

class IVsWebMigrationMockImpl :
	public IVsWebMigration,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWebMigrationMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsWebMigrationMockImpl)

	typedef IVsWebMigration Interface;
	struct LoadAssemblyValidValues
	{
		/*[in]*/ BSTR bstrFilePath;
		HRESULT retValue;
	};

	STDMETHOD(LoadAssembly)(
		/*[in]*/ BSTR bstrFilePath)
	{
		VSL_DEFINE_MOCK_METHOD(LoadAssembly)

		VSL_CHECK_VALIDVALUE_BSTR(bstrFilePath);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetBaseTypeValidValues
	{
		/*[in]*/ BSTR bstrClassName;
		/*[out]*/ BSTR* pbstrBaseClass;
		HRESULT retValue;
	};

	STDMETHOD(GetBaseType)(
		/*[in]*/ BSTR bstrClassName,
		/*[out]*/ BSTR* pbstrBaseClass)
	{
		VSL_DEFINE_MOCK_METHOD(GetBaseType)

		VSL_CHECK_VALIDVALUE_BSTR(bstrClassName);

		VSL_SET_VALIDVALUE_BSTR(pbstrBaseClass);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnloadValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Unload)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Unload)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSWEBMIGRATION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsWebPreview.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSWEBPREVIEW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSWEBPREVIEW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsbrowse.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsWebPreviewNotImpl :
	public IVsWebPreview
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWebPreviewNotImpl)

public:

	typedef IVsWebPreview Interface;

	STDMETHOD(PreviewURL)(
		/*[in]*/ IVsWebPreviewAction* /*pAction*/,
		/*[in]*/ LPCOLESTR /*lpszURL*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(PreviewURLEx)(
		/*[in]*/ IVsWebPreviewAction* /*pAction*/,
		/*[in]*/ LPCOLESTR /*lpszURL*/,
		/*[in]*/ VSWBPREVIEWOPTIONS /*opt*/,
		/*[in]*/ int /*cx*/,
		/*[in]*/ int /*cy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ActivatePreview)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Resize)(
		/*[in]*/ int /*cx*/,
		/*[in]*/ int /*cy*/)VSL_STDMETHOD_NOTIMPL
};

class IVsWebPreviewMockImpl :
	public IVsWebPreview,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWebPreviewMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsWebPreviewMockImpl)

	typedef IVsWebPreview Interface;
	struct PreviewURLValidValues
	{
		/*[in]*/ IVsWebPreviewAction* pAction;
		/*[in]*/ LPCOLESTR lpszURL;
		HRESULT retValue;
	};

	STDMETHOD(PreviewURL)(
		/*[in]*/ IVsWebPreviewAction* pAction,
		/*[in]*/ LPCOLESTR lpszURL)
	{
		VSL_DEFINE_MOCK_METHOD(PreviewURL)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pAction);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszURL);

		VSL_RETURN_VALIDVALUES();
	}
	struct PreviewURLExValidValues
	{
		/*[in]*/ IVsWebPreviewAction* pAction;
		/*[in]*/ LPCOLESTR lpszURL;
		/*[in]*/ VSWBPREVIEWOPTIONS opt;
		/*[in]*/ int cx;
		/*[in]*/ int cy;
		HRESULT retValue;
	};

	STDMETHOD(PreviewURLEx)(
		/*[in]*/ IVsWebPreviewAction* pAction,
		/*[in]*/ LPCOLESTR lpszURL,
		/*[in]*/ VSWBPREVIEWOPTIONS opt,
		/*[in]*/ int cx,
		/*[in]*/ int cy)
	{
		VSL_DEFINE_MOCK_METHOD(PreviewURLEx)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pAction);

		VSL_CHECK_VALIDVALUE_STRINGW(lpszURL);

		VSL_CHECK_VALIDVALUE(opt);

		VSL_CHECK_VALIDVALUE(cx);

		VSL_CHECK_VALIDVALUE(cy);

		VSL_RETURN_VALIDVALUES();
	}
	struct ActivatePreviewValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(ActivatePreview)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(ActivatePreview)

		VSL_RETURN_VALIDVALUES();
	}
	struct ResizeValidValues
	{
		/*[in]*/ int cx;
		/*[in]*/ int cy;
		HRESULT retValue;
	};

	STDMETHOD(Resize)(
		/*[in]*/ int cx,
		/*[in]*/ int cy)
	{
		VSL_DEFINE_MOCK_METHOD(Resize)

		VSL_CHECK_VALIDVALUE(cx);

		VSL_CHECK_VALIDVALUE(cy);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSWEBPREVIEW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsWebPreviewAction.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSWEBPREVIEWACTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSWEBPREVIEWACTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsbrowse.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsWebPreviewActionNotImpl :
	public IVsWebPreviewAction
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWebPreviewActionNotImpl)

public:

	typedef IVsWebPreviewAction Interface;

	STDMETHOD(OnPreviewLoadStart)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnPreviewClose)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnPreviewLoaded)(
		/*[in]*/ IDispatch* /*pDispDocument*/)VSL_STDMETHOD_NOTIMPL
};

class IVsWebPreviewActionMockImpl :
	public IVsWebPreviewAction,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWebPreviewActionMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsWebPreviewActionMockImpl)

	typedef IVsWebPreviewAction Interface;
	struct OnPreviewLoadStartValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(OnPreviewLoadStart)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(OnPreviewLoadStart)

		VSL_RETURN_VALIDVALUES();
	}
	struct OnPreviewCloseValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(OnPreviewClose)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(OnPreviewClose)

		VSL_RETURN_VALIDVALUES();
	}
	struct OnPreviewLoadedValidValues
	{
		/*[in]*/ IDispatch* pDispDocument;
		HRESULT retValue;
	};

	STDMETHOD(OnPreviewLoaded)(
		/*[in]*/ IDispatch* pDispDocument)
	{
		VSL_DEFINE_MOCK_METHOD(OnPreviewLoaded)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDispDocument);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSWEBPREVIEWACTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVSWebReferenceDynamicProperties2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSWEBREFERENCEDYNAMICPROPERTIES2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSWEBREFERENCEDYNAMICPROPERTIES2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vslangproj80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVSWebReferenceDynamicProperties2NotImpl :
	public IVSWebReferenceDynamicProperties2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVSWebReferenceDynamicProperties2NotImpl)

public:

	typedef IVSWebReferenceDynamicProperties2 Interface;

	STDMETHOD(GetDynamicPropertyName)(
		/*[in]*/ LPCWSTR /*pszWebServiceName*/,
		/*[out,retval]*/ BSTR* /*pbstrPropertyName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetDynamicProperty)(
		/*[in]*/ LPCWSTR /*pszUrl*/,
		/*[in]*/ LPCWSTR /*pszPropertyName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SupportsDynamicProperties)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbSupportsDynamicProperties*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class IVSWebReferenceDynamicProperties2MockImpl :
	public IVSWebReferenceDynamicProperties2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVSWebReferenceDynamicProperties2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVSWebReferenceDynamicProperties2MockImpl)

	typedef IVSWebReferenceDynamicProperties2 Interface;
	struct GetDynamicPropertyNameValidValues
	{
		/*[in]*/ LPCWSTR pszWebServiceName;
		/*[out,retval]*/ BSTR* pbstrPropertyName;
		HRESULT retValue;
	};

	STDMETHOD(GetDynamicPropertyName)(
		/*[in]*/ LPCWSTR pszWebServiceName,
		/*[out,retval]*/ BSTR* pbstrPropertyName)
	{
		VSL_DEFINE_MOCK_METHOD(GetDynamicPropertyName)

		VSL_CHECK_VALIDVALUE_STRINGW(pszWebServiceName);

		VSL_SET_VALIDVALUE_BSTR(pbstrPropertyName);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetDynamicPropertyValidValues
	{
		/*[in]*/ LPCWSTR pszUrl;
		/*[in]*/ LPCWSTR pszPropertyName;
		HRESULT retValue;
	};

	STDMETHOD(SetDynamicProperty)(
		/*[in]*/ LPCWSTR pszUrl,
		/*[in]*/ LPCWSTR pszPropertyName)
	{
		VSL_DEFINE_MOCK_METHOD(SetDynamicProperty)

		VSL_CHECK_VALIDVALUE_STRINGW(pszUrl);

		VSL_CHECK_VALIDVALUE_STRINGW(pszPropertyName);

		VSL_RETURN_VALIDVALUES();
	}
	struct SupportsDynamicPropertiesValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbSupportsDynamicProperties;
		HRESULT retValue;
	};

	STDMETHOD(SupportsDynamicProperties)(
		/*[out,retval]*/ VARIANT_BOOL* pbSupportsDynamicProperties)
	{
		VSL_DEFINE_MOCK_METHOD(SupportsDynamicProperties)

		VSL_SET_VALIDVALUE(pbSupportsDynamicProperties);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSWEBREFERENCEDYNAMICPROPERTIES2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsWebService.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSWEBSERVICE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSWEBSERVICE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "IVsWebServices.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsWebServiceNotImpl :
	public IVsWebService
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWebServiceNotImpl)

public:

	typedef IVsWebService Interface;

	STDMETHOD(Url)(
		/*[out,retval]*/ BSTR* /*bstrUrl*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AppRelativeUrl)(
		/*[out,retval]*/ BSTR* /*bstrAppUrl*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProvider)(
		/*[out,retval]*/ IVsWebServiceProvider** /*ppIVsWebServiceProvider*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AdviseWebServiceEvents)(
		/*[in]*/ IVsWebServiceEvents* /*pEvents*/,
		/*[out,retval]*/ VSCOOKIE* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnadviseWebServiceEvents)(
		/*[in]*/ VSCOOKIE /*dwCookie*/)VSL_STDMETHOD_NOTIMPL
};

class IVsWebServiceMockImpl :
	public IVsWebService,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWebServiceMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsWebServiceMockImpl)

	typedef IVsWebService Interface;
	struct UrlValidValues
	{
		/*[out,retval]*/ BSTR* bstrUrl;
		HRESULT retValue;
	};

	STDMETHOD(Url)(
		/*[out,retval]*/ BSTR* bstrUrl)
	{
		VSL_DEFINE_MOCK_METHOD(Url)

		VSL_SET_VALIDVALUE_BSTR(bstrUrl);

		VSL_RETURN_VALIDVALUES();
	}
	struct AppRelativeUrlValidValues
	{
		/*[out,retval]*/ BSTR* bstrAppUrl;
		HRESULT retValue;
	};

	STDMETHOD(AppRelativeUrl)(
		/*[out,retval]*/ BSTR* bstrAppUrl)
	{
		VSL_DEFINE_MOCK_METHOD(AppRelativeUrl)

		VSL_SET_VALIDVALUE_BSTR(bstrAppUrl);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetProviderValidValues
	{
		/*[out,retval]*/ IVsWebServiceProvider** ppIVsWebServiceProvider;
		HRESULT retValue;
	};

	STDMETHOD(GetProvider)(
		/*[out,retval]*/ IVsWebServiceProvider** ppIVsWebServiceProvider)
	{
		VSL_DEFINE_MOCK_METHOD(GetProvider)

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsWebServiceProvider);

		VSL_RETURN_VALIDVALUES();
	}
	struct AdviseWebServiceEventsValidValues
	{
		/*[in]*/ IVsWebServiceEvents* pEvents;
		/*[out,retval]*/ VSCOOKIE* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(AdviseWebServiceEvents)(
		/*[in]*/ IVsWebServiceEvents* pEvents,
		/*[out,retval]*/ VSCOOKIE* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(AdviseWebServiceEvents)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pEvents);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnadviseWebServiceEventsValidValues
	{
		/*[in]*/ VSCOOKIE dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(UnadviseWebServiceEvents)(
		/*[in]*/ VSCOOKIE dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(UnadviseWebServiceEvents)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSWEBSERVICE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVSWebReferenceDynamicProperties.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSWEBREFERENCEDYNAMICPROPERTIES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSWEBREFERENCEDYNAMICPROPERTIES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vslangproj.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVSWebReferenceDynamicPropertiesNotImpl :
	public IVSWebReferenceDynamicProperties
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVSWebReferenceDynamicPropertiesNotImpl)

public:

	typedef IVSWebReferenceDynamicProperties Interface;

	STDMETHOD(GetDynamicPropertyName)(
		/*[in]*/ LPCWSTR /*pszWebServiceName*/,
		/*[out,retval]*/ BSTR* /*pbstrPropertyName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetDynamicProperty)(
		/*[in]*/ LPCWSTR /*pszUrl*/,
		/*[in]*/ LPCWSTR /*pszPropertyName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SupportsDynamicProperties)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbSupportsDynamicProperties*/)VSL_STDMETHOD_NOTIMPL
};

class IVSWebReferenceDynamicPropertiesMockImpl :
	public IVSWebReferenceDynamicProperties,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVSWebReferenceDynamicPropertiesMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVSWebReferenceDynamicPropertiesMockImpl)

	typedef IVSWebReferenceDynamicProperties Interface;
	struct GetDynamicPropertyNameValidValues
	{
		/*[in]*/ LPCWSTR pszWebServiceName;
		/*[out,retval]*/ BSTR* pbstrPropertyName;
		HRESULT retValue;
	};

	STDMETHOD(GetDynamicPropertyName)(
		/*[in]*/ LPCWSTR pszWebServiceName,
		/*[out,retval]*/ BSTR* pbstrPropertyName)
	{
		VSL_DEFINE_MOCK_METHOD(GetDynamicPropertyName)

		VSL_CHECK_VALIDVALUE_STRINGW(pszWebServiceName);

		VSL_SET_VALIDVALUE_BSTR(pbstrPropertyName);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetDynamicPropertyValidValues
	{
		/*[in]*/ LPCWSTR pszUrl;
		/*[in]*/ LPCWSTR pszPropertyName;
		HRESULT retValue;
	};

	STDMETHOD(SetDynamicProperty)(
		/*[in]*/ LPCWSTR pszUrl,
		/*[in]*/ LPCWSTR pszPropertyName)
	{
		VSL_DEFINE_MOCK_METHOD(SetDynamicProperty)

		VSL_CHECK_VALIDVALUE_STRINGW(pszUrl);

		VSL_CHECK_VALIDVALUE_STRINGW(pszPropertyName);

		VSL_RETURN_VALIDVALUES();
	}
	struct SupportsDynamicPropertiesValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbSupportsDynamicProperties;
		HRESULT retValue;
	};

	STDMETHOD(SupportsDynamicProperties)(
		/*[out,retval]*/ VARIANT_BOOL* pbSupportsDynamicProperties)
	{
		VSL_DEFINE_MOCK_METHOD(SupportsDynamicProperties)

		VSL_SET_VALIDVALUE(pbSupportsDynamicProperties);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSWEBREFERENCEDYNAMICPROPERTIES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsWebServiceEvents.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSWEBSERVICEEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSWEBSERVICEEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "IVsWebServices.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsWebServiceEventsNotImpl :
	public IVsWebServiceEvents
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWebServiceEventsNotImpl)

public:

	typedef IVsWebServiceEvents Interface;

	STDMETHOD(OnRemoved)(
		/*[in]*/ LPCOLESTR /*pszOldURL*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnRenamed)(
		/*[in]*/ LPCOLESTR /*pszOldURL*/,
		/*[in]*/ LPCOLESTR /*pszNewURL*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnChanged)(
		/*[in]*/ IVsWebService* /*pIVsWebReference*/)VSL_STDMETHOD_NOTIMPL
};

class IVsWebServiceEventsMockImpl :
	public IVsWebServiceEvents,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWebServiceEventsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsWebServiceEventsMockImpl)

	typedef IVsWebServiceEvents Interface;
	struct OnRemovedValidValues
	{
		/*[in]*/ LPCOLESTR pszOldURL;
		HRESULT retValue;
	};

	STDMETHOD(OnRemoved)(
		/*[in]*/ LPCOLESTR pszOldURL)
	{
		VSL_DEFINE_MOCK_METHOD(OnRemoved)

		VSL_CHECK_VALIDVALUE_STRINGW(pszOldURL);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnRenamedValidValues
	{
		/*[in]*/ LPCOLESTR pszOldURL;
		/*[in]*/ LPCOLESTR pszNewURL;
		HRESULT retValue;
	};

	STDMETHOD(OnRenamed)(
		/*[in]*/ LPCOLESTR pszOldURL,
		/*[in]*/ LPCOLESTR pszNewURL)
	{
		VSL_DEFINE_MOCK_METHOD(OnRenamed)

		VSL_CHECK_VALIDVALUE_STRINGW(pszOldURL);

		VSL_CHECK_VALIDVALUE_STRINGW(pszNewURL);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnChangedValidValues
	{
		/*[in]*/ IVsWebService* pIVsWebReference;
		HRESULT retValue;
	};

	STDMETHOD(OnChanged)(
		/*[in]*/ IVsWebService* pIVsWebReference)
	{
		VSL_DEFINE_MOCK_METHOD(OnChanged)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIVsWebReference);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSWEBSERVICEEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsWebProject.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSWEBPROJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSWEBPROJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsWebProjectNotImpl :
	public IVsWebProject
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWebProjectNotImpl)

public:

	typedef IVsWebProject Interface;

	STDMETHOD(AddNewWebItem)(
		/*[in]*/ VSITEMID /*itemidLoc*/,
		/*[in]*/ VSADDITEMOPERATION /*dwAddItemOperation*/,
		/*[in]*/ LPCOLESTR /*pszItemName*/,
		/*[in]*/ LPCOLESTR /*pszFileTemplate*/,
		/*[in]*/ VSADDNEWWEBITEMOPTIONS /*options*/,
		/*[in]*/ LPCOLESTR /*pszSelectedLanguage*/,
		/*[in]*/ HWND /*hwndDlgOwner*/,
		/*[out,retval]*/ VSADDRESULT* /*pResult*/)VSL_STDMETHOD_NOTIMPL
};

class IVsWebProjectMockImpl :
	public IVsWebProject,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWebProjectMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsWebProjectMockImpl)

	typedef IVsWebProject Interface;
	struct AddNewWebItemValidValues
	{
		/*[in]*/ VSITEMID itemidLoc;
		/*[in]*/ VSADDITEMOPERATION dwAddItemOperation;
		/*[in]*/ LPCOLESTR pszItemName;
		/*[in]*/ LPCOLESTR pszFileTemplate;
		/*[in]*/ VSADDNEWWEBITEMOPTIONS options;
		/*[in]*/ LPCOLESTR pszSelectedLanguage;
		/*[in]*/ HWND hwndDlgOwner;
		/*[out,retval]*/ VSADDRESULT* pResult;
		HRESULT retValue;
	};

	STDMETHOD(AddNewWebItem)(
		/*[in]*/ VSITEMID itemidLoc,
		/*[in]*/ VSADDITEMOPERATION dwAddItemOperation,
		/*[in]*/ LPCOLESTR pszItemName,
		/*[in]*/ LPCOLESTR pszFileTemplate,
		/*[in]*/ VSADDNEWWEBITEMOPTIONS options,
		/*[in]*/ LPCOLESTR pszSelectedLanguage,
		/*[in]*/ HWND hwndDlgOwner,
		/*[out,retval]*/ VSADDRESULT* pResult)
	{
		VSL_DEFINE_MOCK_METHOD(AddNewWebItem)

		VSL_CHECK_VALIDVALUE(itemidLoc);

		VSL_CHECK_VALIDVALUE(dwAddItemOperation);

		VSL_CHECK_VALIDVALUE_STRINGW(pszItemName);

		VSL_CHECK_VALIDVALUE_STRINGW(pszFileTemplate);

		VSL_CHECK_VALIDVALUE(options);

		VSL_CHECK_VALIDVALUE_STRINGW(pszSelectedLanguage);

		VSL_CHECK_VALIDVALUE(hwndDlgOwner);

		VSL_SET_VALIDVALUE(pResult);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSWEBPROJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsWebServiceProvider.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSWEBSERVICEPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSWEBSERVICEPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "IVsWebServices.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsWebServiceProviderNotImpl :
	public IVsWebServiceProvider
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWebServiceProviderNotImpl)

public:

	typedef IVsWebServiceProvider Interface;

	STDMETHOD(WebServices)(
		/*[out,retval]*/ IEnumWebServices** /*ppIEnumWebServices*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetWebService)(
		/*[in]*/ LPCOLESTR /*pszUrl*/,
		/*[out,retval]*/ IVsWebService** /*ppIVsWebService*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(StartServer)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AdviseWebServiceProviderEvents)(
		/*[in]*/ IVsWebServiceProviderEvents* /*pEvents*/,
		/*[out,retval]*/ VSCOOKIE* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnadviseWebServiceProviderEvents)(
		/*[in]*/ VSCOOKIE /*dwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnsureServerRunning)(
		/*[out,retval]*/ BSTR* /*pbstrUrl*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ApplicationUrl)(
		/*[out,retval]*/ BSTR* /*pbstrUrl*/)VSL_STDMETHOD_NOTIMPL
};

class IVsWebServiceProviderMockImpl :
	public IVsWebServiceProvider,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWebServiceProviderMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsWebServiceProviderMockImpl)

	typedef IVsWebServiceProvider Interface;
	struct WebServicesValidValues
	{
		/*[out,retval]*/ IEnumWebServices** ppIEnumWebServices;
		HRESULT retValue;
	};

	STDMETHOD(WebServices)(
		/*[out,retval]*/ IEnumWebServices** ppIEnumWebServices)
	{
		VSL_DEFINE_MOCK_METHOD(WebServices)

		VSL_SET_VALIDVALUE_INTERFACE(ppIEnumWebServices);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetWebServiceValidValues
	{
		/*[in]*/ LPCOLESTR pszUrl;
		/*[out,retval]*/ IVsWebService** ppIVsWebService;
		HRESULT retValue;
	};

	STDMETHOD(GetWebService)(
		/*[in]*/ LPCOLESTR pszUrl,
		/*[out,retval]*/ IVsWebService** ppIVsWebService)
	{
		VSL_DEFINE_MOCK_METHOD(GetWebService)

		VSL_CHECK_VALIDVALUE_STRINGW(pszUrl);

		VSL_SET_VALIDVALUE_INTERFACE(ppIVsWebService);

		VSL_RETURN_VALIDVALUES();
	}
	struct StartServerValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(StartServer)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(StartServer)

		VSL_RETURN_VALIDVALUES();
	}
	struct AdviseWebServiceProviderEventsValidValues
	{
		/*[in]*/ IVsWebServiceProviderEvents* pEvents;
		/*[out,retval]*/ VSCOOKIE* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(AdviseWebServiceProviderEvents)(
		/*[in]*/ IVsWebServiceProviderEvents* pEvents,
		/*[out,retval]*/ VSCOOKIE* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(AdviseWebServiceProviderEvents)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pEvents);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnadviseWebServiceProviderEventsValidValues
	{
		/*[in]*/ VSCOOKIE dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(UnadviseWebServiceProviderEvents)(
		/*[in]*/ VSCOOKIE dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(UnadviseWebServiceProviderEvents)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnsureServerRunningValidValues
	{
		/*[out,retval]*/ BSTR* pbstrUrl;
		HRESULT retValue;
	};

	STDMETHOD(EnsureServerRunning)(
		/*[out,retval]*/ BSTR* pbstrUrl)
	{
		VSL_DEFINE_MOCK_METHOD(EnsureServerRunning)

		VSL_SET_VALIDVALUE_BSTR(pbstrUrl);

		VSL_RETURN_VALIDVALUES();
	}
	struct ApplicationUrlValidValues
	{
		/*[out,retval]*/ BSTR* pbstrUrl;
		HRESULT retValue;
	};

	STDMETHOD(ApplicationUrl)(
		/*[out,retval]*/ BSTR* pbstrUrl)
	{
		VSL_DEFINE_MOCK_METHOD(ApplicationUrl)

		VSL_SET_VALIDVALUE_BSTR(pbstrUrl);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSWEBSERVICEPROVIDER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsWebURLMRU.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSWEBURLMRU_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSWEBURLMRU_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsbrowse.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsWebURLMRUNotImpl :
	public IVsWebURLMRU
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWebURLMRUNotImpl)

public:

	typedef IVsWebURLMRU Interface;

	STDMETHOD(AddURL)(
		/*[in]*/ BSTR /*bstrURL*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetURLArray)(
		/*[out,retval]*/ VARIANT* /*pvarURLs*/)VSL_STDMETHOD_NOTIMPL
};

class IVsWebURLMRUMockImpl :
	public IVsWebURLMRU,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWebURLMRUMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsWebURLMRUMockImpl)

	typedef IVsWebURLMRU Interface;
	struct AddURLValidValues
	{
		/*[in]*/ BSTR bstrURL;
		HRESULT retValue;
	};

	STDMETHOD(AddURL)(
		/*[in]*/ BSTR bstrURL)
	{
		VSL_DEFINE_MOCK_METHOD(AddURL)

		VSL_CHECK_VALIDVALUE_BSTR(bstrURL);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetURLArrayValidValues
	{
		/*[out,retval]*/ VARIANT* pvarURLs;
		HRESULT retValue;
	};

	STDMETHOD(GetURLArray)(
		/*[out,retval]*/ VARIANT* pvarURLs)
	{
		VSL_DEFINE_MOCK_METHOD(GetURLArray)

		VSL_SET_VALIDVALUE_VARIANT(pvarURLs);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSWEBURLMRU_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsWindowFrameNotify.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSWINDOWFRAMENOTIFY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSWINDOWFRAMENOTIFY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsWindowFrameNotifyNotImpl :
	public IVsWindowFrameNotify
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWindowFrameNotifyNotImpl)

public:

	typedef IVsWindowFrameNotify Interface;

	STDMETHOD(OnShow)(
		/*[in]*/ FRAMESHOW /*fShow*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnMove)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnSize)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnDockableChange)(
		/*[in]*/ BOOL /*fDockable*/)VSL_STDMETHOD_NOTIMPL
};

class IVsWindowFrameNotifyMockImpl :
	public IVsWindowFrameNotify,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWindowFrameNotifyMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsWindowFrameNotifyMockImpl)

	typedef IVsWindowFrameNotify Interface;
	struct OnShowValidValues
	{
		/*[in]*/ FRAMESHOW fShow;
		HRESULT retValue;
	};

	STDMETHOD(OnShow)(
		/*[in]*/ FRAMESHOW fShow)
	{
		VSL_DEFINE_MOCK_METHOD(OnShow)

		VSL_CHECK_VALIDVALUE(fShow);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnMoveValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(OnMove)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(OnMove)

		VSL_RETURN_VALIDVALUES();
	}
	struct OnSizeValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(OnSize)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(OnSize)

		VSL_RETURN_VALIDVALUES();
	}
	struct OnDockableChangeValidValues
	{
		/*[in]*/ BOOL fDockable;
		HRESULT retValue;
	};

	STDMETHOD(OnDockableChange)(
		/*[in]*/ BOOL fDockable)
	{
		VSL_DEFINE_MOCK_METHOD(OnDockableChange)

		VSL_CHECK_VALIDVALUE(fDockable);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSWINDOWFRAMENOTIFY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsWindowFrame2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSWINDOWFRAME2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSWINDOWFRAME2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsWindowFrame2NotImpl :
	public IVsWindowFrame2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWindowFrame2NotImpl)

public:

	typedef IVsWindowFrame2 Interface;

	STDMETHOD(Advise)(
		/*[in]*/ IVsWindowFrameNotify* /*pNotify*/,
		/*[out]*/ VSCOOKIE* /*pdwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Unadvise)(
		/*[in]*/ VSCOOKIE /*dwCookie*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ActivateOwnerDockedWindow)()VSL_STDMETHOD_NOTIMPL
};

class IVsWindowFrame2MockImpl :
	public IVsWindowFrame2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWindowFrame2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsWindowFrame2MockImpl)

	typedef IVsWindowFrame2 Interface;
	struct AdviseValidValues
	{
		/*[in]*/ IVsWindowFrameNotify* pNotify;
		/*[out]*/ VSCOOKIE* pdwCookie;
		HRESULT retValue;
	};

	STDMETHOD(Advise)(
		/*[in]*/ IVsWindowFrameNotify* pNotify,
		/*[out]*/ VSCOOKIE* pdwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(Advise)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pNotify);

		VSL_SET_VALIDVALUE(pdwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnadviseValidValues
	{
		/*[in]*/ VSCOOKIE dwCookie;
		HRESULT retValue;
	};

	STDMETHOD(Unadvise)(
		/*[in]*/ VSCOOKIE dwCookie)
	{
		VSL_DEFINE_MOCK_METHOD(Unadvise)

		VSL_CHECK_VALIDVALUE(dwCookie);

		VSL_RETURN_VALIDVALUES();
	}
	struct ActivateOwnerDockedWindowValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(ActivateOwnerDockedWindow)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(ActivateOwnerDockedWindow)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSWINDOWFRAME2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsWindowFrameNotify2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSWINDOWFRAMENOTIFY2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSWINDOWFRAMENOTIFY2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsWindowFrameNotify2NotImpl :
	public IVsWindowFrameNotify2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWindowFrameNotify2NotImpl)

public:

	typedef IVsWindowFrameNotify2 Interface;

	STDMETHOD(OnClose)(
		/*[in,out]*/ FRAMECLOSE* /*pgrfSaveOptions*/)VSL_STDMETHOD_NOTIMPL
};

class IVsWindowFrameNotify2MockImpl :
	public IVsWindowFrameNotify2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWindowFrameNotify2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsWindowFrameNotify2MockImpl)

	typedef IVsWindowFrameNotify2 Interface;
	struct OnCloseValidValues
	{
		/*[in,out]*/ FRAMECLOSE* pgrfSaveOptions;
		HRESULT retValue;
	};

	STDMETHOD(OnClose)(
		/*[in,out]*/ FRAMECLOSE* pgrfSaveOptions)
	{
		VSL_DEFINE_MOCK_METHOD(OnClose)

		VSL_SET_VALIDVALUE(pgrfSaveOptions);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSWINDOWFRAMENOTIFY2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsWebServiceProviderEvents.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSWEBSERVICEPROVIDEREVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSWEBSERVICEPROVIDEREVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "IVsWebServices.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsWebServiceProviderEventsNotImpl :
	public IVsWebServiceProviderEvents
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWebServiceProviderEventsNotImpl)

public:

	typedef IVsWebServiceProviderEvents Interface;

	STDMETHOD(OnAdded)(
		/*[in]*/ IVsWebService* /*pIVsWebReference*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnRemoved)(
		/*[in]*/ LPCOLESTR /*pszURL*/)VSL_STDMETHOD_NOTIMPL
};

class IVsWebServiceProviderEventsMockImpl :
	public IVsWebServiceProviderEvents,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWebServiceProviderEventsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsWebServiceProviderEventsMockImpl)

	typedef IVsWebServiceProviderEvents Interface;
	struct OnAddedValidValues
	{
		/*[in]*/ IVsWebService* pIVsWebReference;
		HRESULT retValue;
	};

	STDMETHOD(OnAdded)(
		/*[in]*/ IVsWebService* pIVsWebReference)
	{
		VSL_DEFINE_MOCK_METHOD(OnAdded)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIVsWebReference);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnRemovedValidValues
	{
		/*[in]*/ LPCOLESTR pszURL;
		HRESULT retValue;
	};

	STDMETHOD(OnRemoved)(
		/*[in]*/ LPCOLESTR pszURL)
	{
		VSL_DEFINE_MOCK_METHOD(OnRemoved)

		VSL_CHECK_VALIDVALUE_STRINGW(pszURL);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSWEBSERVICEPROVIDEREVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsWindowFrame.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSWINDOWFRAME_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSWINDOWFRAME_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsWindowFrameNotImpl :
	public IVsWindowFrame
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWindowFrameNotImpl)

public:

	typedef IVsWindowFrame Interface;

	STDMETHOD(Show)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Hide)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsVisible)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ShowNoActivate)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CloseFrame)(
		/*[in]*/ FRAMECLOSE /*grfSaveOptions*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetFramePos)(
		/*[in]*/ VSSETFRAMEPOS /*dwSFP*/,
		/*[in]*/ REFGUID /*rguidRelativeTo*/,
		/*[in]*/ int /*x*/,
		/*[in]*/ int /*y*/,
		/*[in]*/ int /*cx*/,
		/*[in]*/ int /*cy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetFramePos)(
		/*[out]*/ VSSETFRAMEPOS* /*pdwSFP*/,
		/*[out]*/ GUID* /*pguidRelativeTo*/,
		/*[out]*/ int* /*px*/,
		/*[out]*/ int* /*py*/,
		/*[out]*/ int* /*pcx*/,
		/*[out]*/ int* /*pcy*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetProperty)(
		/*[in]*/ VSFPROPID /*propid*/,
		/*[out]*/ VARIANT* /*pvar*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetProperty)(
		/*[in]*/ VSFPROPID /*propid*/,
		/*[in]*/ VARIANT /*var*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetGuidProperty)(
		/*[in]*/ VSFPROPID /*propid*/,
		/*[out]*/ GUID* /*pguid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetGuidProperty)(
		/*[in]*/ VSFPROPID /*propid*/,
		/*[in]*/ REFGUID /*rguid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(QueryViewInterface)(
		/*[in]*/ REFIID /*riid*/,
		/*[out,iid_is(riid)]*/ void** /*ppv*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsOnScreen)(
		/*[out,retval]*/ BOOL* /*pfOnScreen*/)VSL_STDMETHOD_NOTIMPL
};

class IVsWindowFrameMockImpl :
	public IVsWindowFrame,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWindowFrameMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsWindowFrameMockImpl)

	typedef IVsWindowFrame Interface;
	struct ShowValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Show)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Show)

		VSL_RETURN_VALIDVALUES();
	}
	struct HideValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Hide)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Hide)

		VSL_RETURN_VALIDVALUES();
	}
	struct IsVisibleValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(IsVisible)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(IsVisible)

		VSL_RETURN_VALIDVALUES();
	}
	struct ShowNoActivateValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(ShowNoActivate)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(ShowNoActivate)

		VSL_RETURN_VALIDVALUES();
	}
	struct CloseFrameValidValues
	{
		/*[in]*/ FRAMECLOSE grfSaveOptions;
		HRESULT retValue;
	};

	STDMETHOD(CloseFrame)(
		/*[in]*/ FRAMECLOSE grfSaveOptions)
	{
		VSL_DEFINE_MOCK_METHOD(CloseFrame)

		VSL_CHECK_VALIDVALUE(grfSaveOptions);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetFramePosValidValues
	{
		/*[in]*/ VSSETFRAMEPOS dwSFP;
		/*[in]*/ REFGUID rguidRelativeTo;
		/*[in]*/ int x;
		/*[in]*/ int y;
		/*[in]*/ int cx;
		/*[in]*/ int cy;
		HRESULT retValue;
	};

	STDMETHOD(SetFramePos)(
		/*[in]*/ VSSETFRAMEPOS dwSFP,
		/*[in]*/ REFGUID rguidRelativeTo,
		/*[in]*/ int x,
		/*[in]*/ int y,
		/*[in]*/ int cx,
		/*[in]*/ int cy)
	{
		VSL_DEFINE_MOCK_METHOD(SetFramePos)

		VSL_CHECK_VALIDVALUE(dwSFP);

		VSL_CHECK_VALIDVALUE(rguidRelativeTo);

		VSL_CHECK_VALIDVALUE(x);

		VSL_CHECK_VALIDVALUE(y);

		VSL_CHECK_VALIDVALUE(cx);

		VSL_CHECK_VALIDVALUE(cy);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetFramePosValidValues
	{
		/*[out]*/ VSSETFRAMEPOS* pdwSFP;
		/*[out]*/ GUID* pguidRelativeTo;
		/*[out]*/ int* px;
		/*[out]*/ int* py;
		/*[out]*/ int* pcx;
		/*[out]*/ int* pcy;
		HRESULT retValue;
	};

	STDMETHOD(GetFramePos)(
		/*[out]*/ VSSETFRAMEPOS* pdwSFP,
		/*[out]*/ GUID* pguidRelativeTo,
		/*[out]*/ int* px,
		/*[out]*/ int* py,
		/*[out]*/ int* pcx,
		/*[out]*/ int* pcy)
	{
		VSL_DEFINE_MOCK_METHOD(GetFramePos)

		VSL_SET_VALIDVALUE(pdwSFP);

		VSL_SET_VALIDVALUE(pguidRelativeTo);

		VSL_SET_VALIDVALUE(px);

		VSL_SET_VALIDVALUE(py);

		VSL_SET_VALIDVALUE(pcx);

		VSL_SET_VALIDVALUE(pcy);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPropertyValidValues
	{
		/*[in]*/ VSFPROPID propid;
		/*[out]*/ VARIANT* pvar;
		HRESULT retValue;
	};

	STDMETHOD(GetProperty)(
		/*[in]*/ VSFPROPID propid,
		/*[out]*/ VARIANT* pvar)
	{
		VSL_DEFINE_MOCK_METHOD(GetProperty)

		VSL_CHECK_VALIDVALUE(propid);

		VSL_SET_VALIDVALUE_VARIANT(pvar);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetPropertyValidValues
	{
		/*[in]*/ VSFPROPID propid;
		/*[in]*/ VARIANT var;
		HRESULT retValue;
	};

	STDMETHOD(SetProperty)(
		/*[in]*/ VSFPROPID propid,
		/*[in]*/ VARIANT var)
	{
		VSL_DEFINE_MOCK_METHOD(SetProperty)

		VSL_CHECK_VALIDVALUE(propid);

		VSL_CHECK_VALIDVALUE(var);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetGuidPropertyValidValues
	{
		/*[in]*/ VSFPROPID propid;
		/*[out]*/ GUID* pguid;
		HRESULT retValue;
	};

	STDMETHOD(GetGuidProperty)(
		/*[in]*/ VSFPROPID propid,
		/*[out]*/ GUID* pguid)
	{
		VSL_DEFINE_MOCK_METHOD(GetGuidProperty)

		VSL_CHECK_VALIDVALUE(propid);

		VSL_SET_VALIDVALUE(pguid);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetGuidPropertyValidValues
	{
		/*[in]*/ VSFPROPID propid;
		/*[in]*/ REFGUID rguid;
		HRESULT retValue;
	};

	STDMETHOD(SetGuidProperty)(
		/*[in]*/ VSFPROPID propid,
		/*[in]*/ REFGUID rguid)
	{
		VSL_DEFINE_MOCK_METHOD(SetGuidProperty)

		VSL_CHECK_VALIDVALUE(propid);

		VSL_CHECK_VALIDVALUE(rguid);

		VSL_RETURN_VALIDVALUES();
	}
	struct QueryViewInterfaceValidValues
	{
		/*[in]*/ REFIID riid;
		/*[out,iid_is(riid)]*/ void** ppv;
		HRESULT retValue;
	};

	STDMETHOD(QueryViewInterface)(
		/*[in]*/ REFIID riid,
		/*[out,iid_is(riid)]*/ void** ppv)
	{
		VSL_DEFINE_MOCK_METHOD(QueryViewInterface)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_SET_VALIDVALUE(ppv);

		VSL_RETURN_VALIDVALUES();
	}
	struct IsOnScreenValidValues
	{
		/*[out,retval]*/ BOOL* pfOnScreen;
		HRESULT retValue;
	};

	STDMETHOD(IsOnScreen)(
		/*[out,retval]*/ BOOL* pfOnScreen)
	{
		VSL_DEFINE_MOCK_METHOD(IsOnScreen)

		VSL_SET_VALIDVALUE(pfOnScreen);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSWINDOWFRAME_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsWindowPane.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSWINDOWPANE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSWINDOWPANE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsWindowPaneNotImpl :
	public IVsWindowPane
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWindowPaneNotImpl)

public:

	typedef IVsWindowPane Interface;

	STDMETHOD(SetSite)(
		/*[in]*/ IServiceProvider* /*pSP*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreatePaneWindow)(
		/*[in]*/ HWND /*hwndParent*/,
		/*[in]*/ int /*x*/,
		/*[in]*/ int /*y*/,
		/*[in]*/ int /*cx*/,
		/*[in]*/ int /*cy*/,
		/*[out]*/ HWND* /*hwnd*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetDefaultSize)(
		/*[out]*/ SIZE* /*psize*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ClosePane)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(LoadViewState)(
		/*[in]*/ IStream* /*pstream*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SaveViewState)(
		/*[in]*/ IStream* /*pstream*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(TranslateAccelerator)(
		/*[in]*/ LPMSG /*lpmsg*/)VSL_STDMETHOD_NOTIMPL
};

class IVsWindowPaneMockImpl :
	public IVsWindowPane,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWindowPaneMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsWindowPaneMockImpl)

	typedef IVsWindowPane Interface;
	struct SetSiteValidValues
	{
		/*[in]*/ IServiceProvider* pSP;
		HRESULT retValue;
	};

	STDMETHOD(SetSite)(
		/*[in]*/ IServiceProvider* pSP)
	{
		VSL_DEFINE_MOCK_METHOD(SetSite)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSP);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreatePaneWindowValidValues
	{
		/*[in]*/ HWND hwndParent;
		/*[in]*/ int x;
		/*[in]*/ int y;
		/*[in]*/ int cx;
		/*[in]*/ int cy;
		/*[out]*/ HWND* hwnd;
		HRESULT retValue;
	};

	STDMETHOD(CreatePaneWindow)(
		/*[in]*/ HWND hwndParent,
		/*[in]*/ int x,
		/*[in]*/ int y,
		/*[in]*/ int cx,
		/*[in]*/ int cy,
		/*[out]*/ HWND* hwnd)
	{
		VSL_DEFINE_MOCK_METHOD(CreatePaneWindow)

		VSL_CHECK_VALIDVALUE(hwndParent);

		VSL_CHECK_VALIDVALUE(x);

		VSL_CHECK_VALIDVALUE(y);

		VSL_CHECK_VALIDVALUE(cx);

		VSL_CHECK_VALIDVALUE(cy);

		VSL_SET_VALIDVALUE(hwnd);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetDefaultSizeValidValues
	{
		/*[out]*/ SIZE* psize;
		HRESULT retValue;
	};

	STDMETHOD(GetDefaultSize)(
		/*[out]*/ SIZE* psize)
	{
		VSL_DEFINE_MOCK_METHOD(GetDefaultSize)

		VSL_SET_VALIDVALUE(psize);

		VSL_RETURN_VALIDVALUES();
	}
	struct ClosePaneValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(ClosePane)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(ClosePane)

		VSL_RETURN_VALIDVALUES();
	}
	struct LoadViewStateValidValues
	{
		/*[in]*/ IStream* pstream;
		HRESULT retValue;
	};

	STDMETHOD(LoadViewState)(
		/*[in]*/ IStream* pstream)
	{
		VSL_DEFINE_MOCK_METHOD(LoadViewState)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pstream);

		VSL_RETURN_VALIDVALUES();
	}
	struct SaveViewStateValidValues
	{
		/*[in]*/ IStream* pstream;
		HRESULT retValue;
	};

	STDMETHOD(SaveViewState)(
		/*[in]*/ IStream* pstream)
	{
		VSL_DEFINE_MOCK_METHOD(SaveViewState)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pstream);

		VSL_RETURN_VALIDVALUES();
	}
	struct TranslateAcceleratorValidValues
	{
		/*[in]*/ LPMSG lpmsg;
		HRESULT retValue;
	};

	STDMETHOD(TranslateAccelerator)(
		/*[in]*/ LPMSG lpmsg)
	{
		VSL_DEFINE_MOCK_METHOD(TranslateAccelerator)

		VSL_CHECK_VALIDVALUE(lpmsg);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSWINDOWPANE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsWindowFrameNotify3.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSWINDOWFRAMENOTIFY3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSWINDOWFRAMENOTIFY3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsWindowFrameNotify3NotImpl :
	public IVsWindowFrameNotify3
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWindowFrameNotify3NotImpl)

public:

	typedef IVsWindowFrameNotify3 Interface;

	STDMETHOD(OnShow)(
		/*[in]*/ FRAMESHOW2 /*fShow*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnMove)(
		/*[in]*/ int /*x*/,
		/*[in]*/ int /*y*/,
		/*[in]*/ int /*w*/,
		/*[in]*/ int /*h*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnSize)(
		/*[in]*/ int /*x*/,
		/*[in]*/ int /*y*/,
		/*[in]*/ int /*w*/,
		/*[in]*/ int /*h*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnDockableChange)(
		/*[in]*/ BOOL /*fDockable*/,
		/*[in]*/ int /*x*/,
		/*[in]*/ int /*y*/,
		/*[in]*/ int /*w*/,
		/*[in]*/ int /*h*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(OnClose)(
		/*[in,out]*/ FRAMECLOSE* /*pgrfSaveOptions*/)VSL_STDMETHOD_NOTIMPL
};

class IVsWindowFrameNotify3MockImpl :
	public IVsWindowFrameNotify3,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWindowFrameNotify3MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsWindowFrameNotify3MockImpl)

	typedef IVsWindowFrameNotify3 Interface;
	struct OnShowValidValues
	{
		/*[in]*/ FRAMESHOW2 fShow;
		HRESULT retValue;
	};

	STDMETHOD(OnShow)(
		/*[in]*/ FRAMESHOW2 fShow)
	{
		VSL_DEFINE_MOCK_METHOD(OnShow)

		VSL_CHECK_VALIDVALUE(fShow);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnMoveValidValues
	{
		/*[in]*/ int x;
		/*[in]*/ int y;
		/*[in]*/ int w;
		/*[in]*/ int h;
		HRESULT retValue;
	};

	STDMETHOD(OnMove)(
		/*[in]*/ int x,
		/*[in]*/ int y,
		/*[in]*/ int w,
		/*[in]*/ int h)
	{
		VSL_DEFINE_MOCK_METHOD(OnMove)

		VSL_CHECK_VALIDVALUE(x);

		VSL_CHECK_VALIDVALUE(y);

		VSL_CHECK_VALIDVALUE(w);

		VSL_CHECK_VALIDVALUE(h);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnSizeValidValues
	{
		/*[in]*/ int x;
		/*[in]*/ int y;
		/*[in]*/ int w;
		/*[in]*/ int h;
		HRESULT retValue;
	};

	STDMETHOD(OnSize)(
		/*[in]*/ int x,
		/*[in]*/ int y,
		/*[in]*/ int w,
		/*[in]*/ int h)
	{
		VSL_DEFINE_MOCK_METHOD(OnSize)

		VSL_CHECK_VALIDVALUE(x);

		VSL_CHECK_VALIDVALUE(y);

		VSL_CHECK_VALIDVALUE(w);

		VSL_CHECK_VALIDVALUE(h);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnDockableChangeValidValues
	{
		/*[in]*/ BOOL fDockable;
		/*[in]*/ int x;
		/*[in]*/ int y;
		/*[in]*/ int w;
		/*[in]*/ int h;
		HRESULT retValue;
	};

	STDMETHOD(OnDockableChange)(
		/*[in]*/ BOOL fDockable,
		/*[in]*/ int x,
		/*[in]*/ int y,
		/*[in]*/ int w,
		/*[in]*/ int h)
	{
		VSL_DEFINE_MOCK_METHOD(OnDockableChange)

		VSL_CHECK_VALIDVALUE(fDockable);

		VSL_CHECK_VALIDVALUE(x);

		VSL_CHECK_VALIDVALUE(y);

		VSL_CHECK_VALIDVALUE(w);

		VSL_CHECK_VALIDVALUE(h);

		VSL_RETURN_VALIDVALUES();
	}
	struct OnCloseValidValues
	{
		/*[in,out]*/ FRAMECLOSE* pgrfSaveOptions;
		HRESULT retValue;
	};

	STDMETHOD(OnClose)(
		/*[in,out]*/ FRAMECLOSE* pgrfSaveOptions)
	{
		VSL_DEFINE_MOCK_METHOD(OnClose)

		VSL_SET_VALIDVALUE(pgrfSaveOptions);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSWINDOWFRAMENOTIFY3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsWindowPaneCommitFilter.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSWINDOWPANECOMMITFILTER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSWINDOWPANECOMMITFILTER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsWindowPaneCommitFilterNotImpl :
	public IVsWindowPaneCommitFilter
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWindowPaneCommitFilterNotImpl)

public:

	typedef IVsWindowPaneCommitFilter Interface;

	STDMETHOD(IsCommitCommand)(
		/*[in]*/ REFGUID /*pguidCmdGroup*/,
		/*[in]*/ DWORD /*dwCmdID*/,
		/*[out]*/ BOOL* /*pfCommitCommand*/)VSL_STDMETHOD_NOTIMPL
};

class IVsWindowPaneCommitFilterMockImpl :
	public IVsWindowPaneCommitFilter,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWindowPaneCommitFilterMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsWindowPaneCommitFilterMockImpl)

	typedef IVsWindowPaneCommitFilter Interface;
	struct IsCommitCommandValidValues
	{
		/*[in]*/ REFGUID pguidCmdGroup;
		/*[in]*/ DWORD dwCmdID;
		/*[out]*/ BOOL* pfCommitCommand;
		HRESULT retValue;
	};

	STDMETHOD(IsCommitCommand)(
		/*[in]*/ REFGUID pguidCmdGroup,
		/*[in]*/ DWORD dwCmdID,
		/*[out]*/ BOOL* pfCommitCommand)
	{
		VSL_DEFINE_MOCK_METHOD(IsCommitCommand)

		VSL_CHECK_VALIDVALUE(pguidCmdGroup);

		VSL_CHECK_VALIDVALUE(dwCmdID);

		VSL_SET_VALIDVALUE(pfCommitCommand);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSWINDOWPANECOMMITFILTER_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsXMLMemberData.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSXMLMEMBERDATA_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSXMLMEMBERDATA_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsXMLMemberDataNotImpl :
	public IVsXMLMemberData
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsXMLMemberDataNotImpl)

public:

	typedef IVsXMLMemberData Interface;

	STDMETHOD(GetSummaryText)(
		/*[out]*/ BSTR* /*pbstrSummary*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetParamCount)(
		/*[out]*/ long* /*piParams*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetParamTextAt)(
		/*[in]*/ long /*iParam*/,
		/*[out]*/ BSTR* /*pbstrName*/,
		/*[out]*/ BSTR* /*pbstrText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetReturnsText)(
		/*[out]*/ BSTR* /*pbstrReturns*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetRemarksText)(
		/*[out]*/ BSTR* /*pbstrRemarks*/)VSL_STDMETHOD_NOTIMPL
};

class IVsXMLMemberDataMockImpl :
	public IVsXMLMemberData,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsXMLMemberDataMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsXMLMemberDataMockImpl)

	typedef IVsXMLMemberData Interface;
	struct GetSummaryTextValidValues
	{
		/*[out]*/ BSTR* pbstrSummary;
		HRESULT retValue;
	};

	STDMETHOD(GetSummaryText)(
		/*[out]*/ BSTR* pbstrSummary)
	{
		VSL_DEFINE_MOCK_METHOD(GetSummaryText)

		VSL_SET_VALIDVALUE_BSTR(pbstrSummary);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetParamCountValidValues
	{
		/*[out]*/ long* piParams;
		HRESULT retValue;
	};

	STDMETHOD(GetParamCount)(
		/*[out]*/ long* piParams)
	{
		VSL_DEFINE_MOCK_METHOD(GetParamCount)

		VSL_SET_VALIDVALUE(piParams);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetParamTextAtValidValues
	{
		/*[in]*/ long iParam;
		/*[out]*/ BSTR* pbstrName;
		/*[out]*/ BSTR* pbstrText;
		HRESULT retValue;
	};

	STDMETHOD(GetParamTextAt)(
		/*[in]*/ long iParam,
		/*[out]*/ BSTR* pbstrName,
		/*[out]*/ BSTR* pbstrText)
	{
		VSL_DEFINE_MOCK_METHOD(GetParamTextAt)

		VSL_CHECK_VALIDVALUE(iParam);

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_SET_VALIDVALUE_BSTR(pbstrText);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetReturnsTextValidValues
	{
		/*[out]*/ BSTR* pbstrReturns;
		HRESULT retValue;
	};

	STDMETHOD(GetReturnsText)(
		/*[out]*/ BSTR* pbstrReturns)
	{
		VSL_DEFINE_MOCK_METHOD(GetReturnsText)

		VSL_SET_VALIDVALUE_BSTR(pbstrReturns);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetRemarksTextValidValues
	{
		/*[out]*/ BSTR* pbstrRemarks;
		HRESULT retValue;
	};

	STDMETHOD(GetRemarksText)(
		/*[out]*/ BSTR* pbstrRemarks)
	{
		VSL_DEFINE_MOCK_METHOD(GetRemarksText)

		VSL_SET_VALIDVALUE_BSTR(pbstrRemarks);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSXMLMEMBERDATA_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsWindowView.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSWINDOWVIEW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSWINDOWVIEW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsWindowViewNotImpl :
	public IVsWindowView
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWindowViewNotImpl)

public:

	typedef IVsWindowView Interface;

	STDMETHOD(GetProperty)(
		/*[in]*/ VSVPROPID /*propid*/,
		/*[out]*/ VARIANT* /*pvar*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetProperty)(
		/*[in]*/ VSVPROPID /*propid*/,
		/*[in]*/ VARIANT /*var*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetGuidProperty)(
		/*[in]*/ VSVPROPID /*propid*/,
		/*[out]*/ GUID* /*pguid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetGuidProperty)(
		/*[in]*/ VSVPROPID /*propid*/,
		/*[in]*/ REFGUID /*rguid*/)VSL_STDMETHOD_NOTIMPL
};

class IVsWindowViewMockImpl :
	public IVsWindowView,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWindowViewMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsWindowViewMockImpl)

	typedef IVsWindowView Interface;
	struct GetPropertyValidValues
	{
		/*[in]*/ VSVPROPID propid;
		/*[out]*/ VARIANT* pvar;
		HRESULT retValue;
	};

	STDMETHOD(GetProperty)(
		/*[in]*/ VSVPROPID propid,
		/*[out]*/ VARIANT* pvar)
	{
		VSL_DEFINE_MOCK_METHOD(GetProperty)

		VSL_CHECK_VALIDVALUE(propid);

		VSL_SET_VALIDVALUE_VARIANT(pvar);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetPropertyValidValues
	{
		/*[in]*/ VSVPROPID propid;
		/*[in]*/ VARIANT var;
		HRESULT retValue;
	};

	STDMETHOD(SetProperty)(
		/*[in]*/ VSVPROPID propid,
		/*[in]*/ VARIANT var)
	{
		VSL_DEFINE_MOCK_METHOD(SetProperty)

		VSL_CHECK_VALIDVALUE(propid);

		VSL_CHECK_VALIDVALUE(var);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetGuidPropertyValidValues
	{
		/*[in]*/ VSVPROPID propid;
		/*[out]*/ GUID* pguid;
		HRESULT retValue;
	};

	STDMETHOD(GetGuidProperty)(
		/*[in]*/ VSVPROPID propid,
		/*[out]*/ GUID* pguid)
	{
		VSL_DEFINE_MOCK_METHOD(GetGuidProperty)

		VSL_CHECK_VALIDVALUE(propid);

		VSL_SET_VALIDVALUE(pguid);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetGuidPropertyValidValues
	{
		/*[in]*/ VSVPROPID propid;
		/*[in]*/ REFGUID rguid;
		HRESULT retValue;
	};

	STDMETHOD(SetGuidProperty)(
		/*[in]*/ VSVPROPID propid,
		/*[in]*/ REFGUID rguid)
	{
		VSL_DEFINE_MOCK_METHOD(SetGuidProperty)

		VSL_CHECK_VALIDVALUE(propid);

		VSL_CHECK_VALIDVALUE(rguid);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSWINDOWVIEW_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsXMLMemberData3.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSXMLMEMBERDATA3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSXMLMEMBERDATA3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsXMLMemberData3NotImpl :
	public IVsXMLMemberData3
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsXMLMemberData3NotImpl)

public:

	typedef IVsXMLMemberData3 Interface;

	STDMETHOD(SetOptions)(
		/*[in]*/ XMLMEMBERDATA_OPTIONS /*options*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetSummaryText)(
		/*[out]*/ BSTR* /*pbstrSummary*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetParamCount)(
		/*[out]*/ long* /*piParams*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetParamTextAt)(
		/*[in]*/ long /*iParam*/,
		/*[out]*/ BSTR* /*pbstrName*/,
		/*[out]*/ BSTR* /*pbstrText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetReturnsText)(
		/*[out]*/ BSTR* /*pbstrReturns*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetRemarksText)(
		/*[out]*/ BSTR* /*pbstrRemarks*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetExceptionCount)(
		/*[out]*/ long* /*piExceptions*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetExceptionTextAt)(
		/*[in]*/ long /*iException*/,
		/*[out]*/ BSTR* /*pbstrType*/,
		/*[out]*/ BSTR* /*pbstrText*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetFilterPriority)(
		/*[out]*/ long* /*piFilterPriority*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCompletionListText)(
		/*[out]*/ BSTR* /*pbstrCompletionList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetCompletionListTextAt)(
		/*[in]*/ long /*iParam*/,
		/*[out]*/ BSTR* /*pbstrCompletionList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetPermissionSet)(
		/*[out]*/ BSTR* /*pbstrPermissionSetXML*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeParamCount)(
		/*[out]*/ long* /*piTypeParams*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeParamTextAt)(
		/*[in]*/ long /*iTypeParam*/,
		/*[out]*/ BSTR* /*pbstrName*/,
		/*[out]*/ BSTR* /*pbstrText*/)VSL_STDMETHOD_NOTIMPL
};

class IVsXMLMemberData3MockImpl :
	public IVsXMLMemberData3,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsXMLMemberData3MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsXMLMemberData3MockImpl)

	typedef IVsXMLMemberData3 Interface;
	struct SetOptionsValidValues
	{
		/*[in]*/ XMLMEMBERDATA_OPTIONS options;
		HRESULT retValue;
	};

	STDMETHOD(SetOptions)(
		/*[in]*/ XMLMEMBERDATA_OPTIONS options)
	{
		VSL_DEFINE_MOCK_METHOD(SetOptions)

		VSL_CHECK_VALIDVALUE(options);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetSummaryTextValidValues
	{
		/*[out]*/ BSTR* pbstrSummary;
		HRESULT retValue;
	};

	STDMETHOD(GetSummaryText)(
		/*[out]*/ BSTR* pbstrSummary)
	{
		VSL_DEFINE_MOCK_METHOD(GetSummaryText)

		VSL_SET_VALIDVALUE_BSTR(pbstrSummary);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetParamCountValidValues
	{
		/*[out]*/ long* piParams;
		HRESULT retValue;
	};

	STDMETHOD(GetParamCount)(
		/*[out]*/ long* piParams)
	{
		VSL_DEFINE_MOCK_METHOD(GetParamCount)

		VSL_SET_VALIDVALUE(piParams);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetParamTextAtValidValues
	{
		/*[in]*/ long iParam;
		/*[out]*/ BSTR* pbstrName;
		/*[out]*/ BSTR* pbstrText;
		HRESULT retValue;
	};

	STDMETHOD(GetParamTextAt)(
		/*[in]*/ long iParam,
		/*[out]*/ BSTR* pbstrName,
		/*[out]*/ BSTR* pbstrText)
	{
		VSL_DEFINE_MOCK_METHOD(GetParamTextAt)

		VSL_CHECK_VALIDVALUE(iParam);

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_SET_VALIDVALUE_BSTR(pbstrText);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetReturnsTextValidValues
	{
		/*[out]*/ BSTR* pbstrReturns;
		HRESULT retValue;
	};

	STDMETHOD(GetReturnsText)(
		/*[out]*/ BSTR* pbstrReturns)
	{
		VSL_DEFINE_MOCK_METHOD(GetReturnsText)

		VSL_SET_VALIDVALUE_BSTR(pbstrReturns);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetRemarksTextValidValues
	{
		/*[out]*/ BSTR* pbstrRemarks;
		HRESULT retValue;
	};

	STDMETHOD(GetRemarksText)(
		/*[out]*/ BSTR* pbstrRemarks)
	{
		VSL_DEFINE_MOCK_METHOD(GetRemarksText)

		VSL_SET_VALIDVALUE_BSTR(pbstrRemarks);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetExceptionCountValidValues
	{
		/*[out]*/ long* piExceptions;
		HRESULT retValue;
	};

	STDMETHOD(GetExceptionCount)(
		/*[out]*/ long* piExceptions)
	{
		VSL_DEFINE_MOCK_METHOD(GetExceptionCount)

		VSL_SET_VALIDVALUE(piExceptions);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetExceptionTextAtValidValues
	{
		/*[in]*/ long iException;
		/*[out]*/ BSTR* pbstrType;
		/*[out]*/ BSTR* pbstrText;
		HRESULT retValue;
	};

	STDMETHOD(GetExceptionTextAt)(
		/*[in]*/ long iException,
		/*[out]*/ BSTR* pbstrType,
		/*[out]*/ BSTR* pbstrText)
	{
		VSL_DEFINE_MOCK_METHOD(GetExceptionTextAt)

		VSL_CHECK_VALIDVALUE(iException);

		VSL_SET_VALIDVALUE_BSTR(pbstrType);

		VSL_SET_VALIDVALUE_BSTR(pbstrText);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetFilterPriorityValidValues
	{
		/*[out]*/ long* piFilterPriority;
		HRESULT retValue;
	};

	STDMETHOD(GetFilterPriority)(
		/*[out]*/ long* piFilterPriority)
	{
		VSL_DEFINE_MOCK_METHOD(GetFilterPriority)

		VSL_SET_VALIDVALUE(piFilterPriority);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCompletionListTextValidValues
	{
		/*[out]*/ BSTR* pbstrCompletionList;
		HRESULT retValue;
	};

	STDMETHOD(GetCompletionListText)(
		/*[out]*/ BSTR* pbstrCompletionList)
	{
		VSL_DEFINE_MOCK_METHOD(GetCompletionListText)

		VSL_SET_VALIDVALUE_BSTR(pbstrCompletionList);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetCompletionListTextAtValidValues
	{
		/*[in]*/ long iParam;
		/*[out]*/ BSTR* pbstrCompletionList;
		HRESULT retValue;
	};

	STDMETHOD(GetCompletionListTextAt)(
		/*[in]*/ long iParam,
		/*[out]*/ BSTR* pbstrCompletionList)
	{
		VSL_DEFINE_MOCK_METHOD(GetCompletionListTextAt)

		VSL_CHECK_VALIDVALUE(iParam);

		VSL_SET_VALIDVALUE_BSTR(pbstrCompletionList);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetPermissionSetValidValues
	{
		/*[out]*/ BSTR* pbstrPermissionSetXML;
		HRESULT retValue;
	};

	STDMETHOD(GetPermissionSet)(
		/*[out]*/ BSTR* pbstrPermissionSetXML)
	{
		VSL_DEFINE_MOCK_METHOD(GetPermissionSet)

		VSL_SET_VALIDVALUE_BSTR(pbstrPermissionSetXML);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeParamCountValidValues
	{
		/*[out]*/ long* piTypeParams;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeParamCount)(
		/*[out]*/ long* piTypeParams)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeParamCount)

		VSL_SET_VALIDVALUE(piTypeParams);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeParamTextAtValidValues
	{
		/*[in]*/ long iTypeParam;
		/*[out]*/ BSTR* pbstrName;
		/*[out]*/ BSTR* pbstrText;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeParamTextAt)(
		/*[in]*/ long iTypeParam,
		/*[out]*/ BSTR* pbstrName,
		/*[out]*/ BSTR* pbstrText)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeParamTextAt)

		VSL_CHECK_VALIDVALUE(iTypeParam);

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_SET_VALIDVALUE_BSTR(pbstrText);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSXMLMEMBERDATA3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsWindowPaneCommit.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSWINDOWPANECOMMIT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSWINDOWPANECOMMIT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsWindowPaneCommitNotImpl :
	public IVsWindowPaneCommit
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWindowPaneCommitNotImpl)

public:

	typedef IVsWindowPaneCommit Interface;

	STDMETHOD(CommitPendingEdit)(
		/*[out]*/ BOOL* /*pfCommitFailed*/)VSL_STDMETHOD_NOTIMPL
};

class IVsWindowPaneCommitMockImpl :
	public IVsWindowPaneCommit,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsWindowPaneCommitMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsWindowPaneCommitMockImpl)

	typedef IVsWindowPaneCommit Interface;
	struct CommitPendingEditValidValues
	{
		/*[out]*/ BOOL* pfCommitFailed;
		HRESULT retValue;
	};

	STDMETHOD(CommitPendingEdit)(
		/*[out]*/ BOOL* pfCommitFailed)
	{
		VSL_DEFINE_MOCK_METHOD(CommitPendingEdit)

		VSL_SET_VALIDVALUE(pfCommitFailed);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSWINDOWPANECOMMIT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsXMLMemberDataRegisterCallBack.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSXMLMEMBERDATAREGISTERCALLBACK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSXMLMEMBERDATAREGISTERCALLBACK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsXMLMemberDataRegisterCallBackNotImpl :
	public IVsXMLMemberDataRegisterCallBack
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsXMLMemberDataRegisterCallBackNotImpl)

public:

	typedef IVsXMLMemberDataRegisterCallBack Interface;

	STDMETHOD(RegisterCallBack)(
		/*[in]*/ IVsXMLMemberDataCallBack* /*pIVsXMLMemberDataCallBack*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(UnregisterCallBack)()VSL_STDMETHOD_NOTIMPL
};

class IVsXMLMemberDataRegisterCallBackMockImpl :
	public IVsXMLMemberDataRegisterCallBack,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsXMLMemberDataRegisterCallBackMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsXMLMemberDataRegisterCallBackMockImpl)

	typedef IVsXMLMemberDataRegisterCallBack Interface;
	struct RegisterCallBackValidValues
	{
		/*[in]*/ IVsXMLMemberDataCallBack* pIVsXMLMemberDataCallBack;
		HRESULT retValue;
	};

	STDMETHOD(RegisterCallBack)(
		/*[in]*/ IVsXMLMemberDataCallBack* pIVsXMLMemberDataCallBack)
	{
		VSL_DEFINE_MOCK_METHOD(RegisterCallBack)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pIVsXMLMemberDataCallBack);

		VSL_RETURN_VALIDVALUES();
	}
	struct UnregisterCallBackValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(UnregisterCallBack)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(UnregisterCallBack)

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSXMLMEMBERDATAREGISTERCALLBACK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsXMLMemberDataCallBack.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSXMLMEMBERDATACALLBACK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSXMLMEMBERDATACALLBACK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsXMLMemberDataCallBackNotImpl :
	public IVsXMLMemberDataCallBack
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsXMLMemberDataCallBackNotImpl)

public:

	typedef IVsXMLMemberDataCallBack Interface;

	STDMETHOD(GetDisplayNameForTag)(
		/*[in]*/ XMLMEMBERDATA_TAGTYPE /*nTagType*/,
		/*[in]*/ LPCOLESTR /*wszBufferIn*/,
		/*[out]*/ BSTR* /*pbstrBufferOut*/)VSL_STDMETHOD_NOTIMPL
};

class IVsXMLMemberDataCallBackMockImpl :
	public IVsXMLMemberDataCallBack,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsXMLMemberDataCallBackMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsXMLMemberDataCallBackMockImpl)

	typedef IVsXMLMemberDataCallBack Interface;
	struct GetDisplayNameForTagValidValues
	{
		/*[in]*/ XMLMEMBERDATA_TAGTYPE nTagType;
		/*[in]*/ LPCOLESTR wszBufferIn;
		/*[out]*/ BSTR* pbstrBufferOut;
		HRESULT retValue;
	};

	STDMETHOD(GetDisplayNameForTag)(
		/*[in]*/ XMLMEMBERDATA_TAGTYPE nTagType,
		/*[in]*/ LPCOLESTR wszBufferIn,
		/*[out]*/ BSTR* pbstrBufferOut)
	{
		VSL_DEFINE_MOCK_METHOD(GetDisplayNameForTag)

		VSL_CHECK_VALIDVALUE(nTagType);

		VSL_CHECK_VALIDVALUE_STRINGW(wszBufferIn);

		VSL_SET_VALIDVALUE_BSTR(pbstrBufferOut);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSXMLMEMBERDATACALLBACK_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIWaitMultiple.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IWAITMULTIPLE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IWAITMULTIPLE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "ObjIdl.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IWaitMultipleNotImpl :
	public IWaitMultiple
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IWaitMultipleNotImpl)

public:

	typedef IWaitMultiple Interface;

	STDMETHOD(WaitMultiple)(
		/*[in]*/ DWORD /*timeout*/,
		/*[out]*/ ISynchronize** /*pSync*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddSynchronize)(
		/*[in]*/ ISynchronize* /*pSync*/)VSL_STDMETHOD_NOTIMPL
};

class IWaitMultipleMockImpl :
	public IWaitMultiple,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IWaitMultipleMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IWaitMultipleMockImpl)

	typedef IWaitMultiple Interface;
	struct WaitMultipleValidValues
	{
		/*[in]*/ DWORD timeout;
		/*[out]*/ ISynchronize** pSync;
		HRESULT retValue;
	};

	STDMETHOD(WaitMultiple)(
		/*[in]*/ DWORD timeout,
		/*[out]*/ ISynchronize** pSync)
	{
		VSL_DEFINE_MOCK_METHOD(WaitMultiple)

		VSL_CHECK_VALIDVALUE(timeout);

		VSL_SET_VALIDVALUE_INTERFACE(pSync);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddSynchronizeValidValues
	{
		/*[in]*/ ISynchronize* pSync;
		HRESULT retValue;
	};

	STDMETHOD(AddSynchronize)(
		/*[in]*/ ISynchronize* pSync)
	{
		VSL_DEFINE_MOCK_METHOD(AddSynchronize)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pSync);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IWAITMULTIPLE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsXMLMemberIndex.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSXMLMEMBERINDEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSXMLMEMBERINDEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsXMLMemberIndexNotImpl :
	public IVsXMLMemberIndex
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsXMLMemberIndexNotImpl)

public:

	typedef IVsXMLMemberIndex Interface;

	STDMETHOD(BuildMemberIndex)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ParseMemberSignature)(
		/*[in]*/ LPCOLESTR /*pszSignature*/,
		/*[out]*/ DWORD_PTR* /*pdwID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMemberXML)(
		/*[in]*/ DWORD_PTR /*dwID*/,
		/*[out]*/ BSTR* /*pbstrXML*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMemberDataFromXML)(
		/*[in]*/ LPCOLESTR /*pszXML*/,
		/*[out]*/ IVsXMLMemberData** /*ppObj*/)VSL_STDMETHOD_NOTIMPL
};

class IVsXMLMemberIndexMockImpl :
	public IVsXMLMemberIndex,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsXMLMemberIndexMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsXMLMemberIndexMockImpl)

	typedef IVsXMLMemberIndex Interface;
	struct BuildMemberIndexValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(BuildMemberIndex)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(BuildMemberIndex)

		VSL_RETURN_VALIDVALUES();
	}
	struct ParseMemberSignatureValidValues
	{
		/*[in]*/ LPCOLESTR pszSignature;
		/*[out]*/ DWORD_PTR* pdwID;
		HRESULT retValue;
	};

	STDMETHOD(ParseMemberSignature)(
		/*[in]*/ LPCOLESTR pszSignature,
		/*[out]*/ DWORD_PTR* pdwID)
	{
		VSL_DEFINE_MOCK_METHOD(ParseMemberSignature)

		VSL_CHECK_VALIDVALUE_STRINGW(pszSignature);

		VSL_SET_VALIDVALUE(pdwID);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMemberXMLValidValues
	{
		/*[in]*/ DWORD_PTR dwID;
		/*[out]*/ BSTR* pbstrXML;
		HRESULT retValue;
	};

	STDMETHOD(GetMemberXML)(
		/*[in]*/ DWORD_PTR dwID,
		/*[out]*/ BSTR* pbstrXML)
	{
		VSL_DEFINE_MOCK_METHOD(GetMemberXML)

		VSL_CHECK_VALIDVALUE(dwID);

		VSL_SET_VALIDVALUE_BSTR(pbstrXML);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMemberDataFromXMLValidValues
	{
		/*[in]*/ LPCOLESTR pszXML;
		/*[out]*/ IVsXMLMemberData** ppObj;
		HRESULT retValue;
	};

	STDMETHOD(GetMemberDataFromXML)(
		/*[in]*/ LPCOLESTR pszXML,
		/*[out]*/ IVsXMLMemberData** ppObj)
	{
		VSL_DEFINE_MOCK_METHOD(GetMemberDataFromXML)

		VSL_CHECK_VALIDVALUE_STRINGW(pszXML);

		VSL_SET_VALIDVALUE_INTERFACE(ppObj);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSXMLMEMBERINDEX_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIWebApplicationCtxSvc.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IWEBAPPLICATIONCTXSVC_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IWEBAPPLICATIONCTXSVC_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "Webapplicationctx.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IWebApplicationCtxSvcNotImpl :
	public IWebApplicationCtxSvc
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IWebApplicationCtxSvcNotImpl)

public:

	typedef IWebApplicationCtxSvc Interface;

	STDMETHOD(GetItemContext)(
		/*[in]*/ IVsHierarchy* /*pHier*/,
		/*[in]*/ VSITEMID /*itemid*/,
		/*[out]*/ IServiceProvider** /*ppServiceProvider*/)VSL_STDMETHOD_NOTIMPL
};

class IWebApplicationCtxSvcMockImpl :
	public IWebApplicationCtxSvc,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IWebApplicationCtxSvcMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IWebApplicationCtxSvcMockImpl)

	typedef IWebApplicationCtxSvc Interface;
	struct GetItemContextValidValues
	{
		/*[in]*/ IVsHierarchy* pHier;
		/*[in]*/ VSITEMID itemid;
		/*[out]*/ IServiceProvider** ppServiceProvider;
		HRESULT retValue;
	};

	STDMETHOD(GetItemContext)(
		/*[in]*/ IVsHierarchy* pHier,
		/*[in]*/ VSITEMID itemid,
		/*[out]*/ IServiceProvider** ppServiceProvider)
	{
		VSL_DEFINE_MOCK_METHOD(GetItemContext)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pHier);

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_SET_VALIDVALUE_INTERFACE(ppServiceProvider);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IWEBAPPLICATIONCTXSVC_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIVsXMLMemberIndexService.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IVSXMLMEMBERINDEXSERVICE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IVSXMLMEMBERINDEXSERVICE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vsshell.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IVsXMLMemberIndexServiceNotImpl :
	public IVsXMLMemberIndexService
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsXMLMemberIndexServiceNotImpl)

public:

	typedef IVsXMLMemberIndexService Interface;

	STDMETHOD(CreateXMLMemberIndex)(
		/*[in]*/ LPCOLESTR /*pszBinaryName*/,
		/*[out]*/ IVsXMLMemberIndex** /*ppIndex*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetMemberDataFromXML)(
		/*[in]*/ LPCOLESTR /*pszXML*/,
		/*[out]*/ IVsXMLMemberData** /*ppObj*/)VSL_STDMETHOD_NOTIMPL
};

class IVsXMLMemberIndexServiceMockImpl :
	public IVsXMLMemberIndexService,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IVsXMLMemberIndexServiceMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IVsXMLMemberIndexServiceMockImpl)

	typedef IVsXMLMemberIndexService Interface;
	struct CreateXMLMemberIndexValidValues
	{
		/*[in]*/ LPCOLESTR pszBinaryName;
		/*[out]*/ IVsXMLMemberIndex** ppIndex;
		HRESULT retValue;
	};

	STDMETHOD(CreateXMLMemberIndex)(
		/*[in]*/ LPCOLESTR pszBinaryName,
		/*[out]*/ IVsXMLMemberIndex** ppIndex)
	{
		VSL_DEFINE_MOCK_METHOD(CreateXMLMemberIndex)

		VSL_CHECK_VALIDVALUE_STRINGW(pszBinaryName);

		VSL_SET_VALIDVALUE_INTERFACE(ppIndex);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetMemberDataFromXMLValidValues
	{
		/*[in]*/ LPCOLESTR pszXML;
		/*[out]*/ IVsXMLMemberData** ppObj;
		HRESULT retValue;
	};

	STDMETHOD(GetMemberDataFromXML)(
		/*[in]*/ LPCOLESTR pszXML,
		/*[out]*/ IVsXMLMemberData** ppObj)
	{
		VSL_DEFINE_MOCK_METHOD(GetMemberDataFromXML)

		VSL_CHECK_VALIDVALUE_STRINGW(pszXML);

		VSL_SET_VALIDVALUE_INTERFACE(ppObj);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IVSXMLMEMBERINDEXSERVICE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIWebFileCtxService.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IWEBFILECTXSERVICE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IWEBFILECTXSERVICE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "Webapplicationctx.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IWebFileCtxServiceNotImpl :
	public IWebFileCtxService
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IWebFileCtxServiceNotImpl)

public:

	typedef IWebFileCtxService Interface;

	STDMETHOD(AddFileToIntellisense)(
		/*[in]*/ LPCWSTR /*pszFilePath*/,
		/*[out]*/ VSITEMID* /*pItemID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(EnsureFileOpened)(
		/*[in]*/ VSITEMID /*itemid*/,
		/*[out]*/ IVsWindowFrame** /*ppFrame*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveFileFromIntellisense)(
		/*[in]*/ LPCWSTR /*pszFilePath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetWebRootPath)(
		/*[out]*/ BSTR* /*pbstrWebRootPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIntellisenseProjectName)(
		/*[out]*/ BSTR* /*pbstrProjectName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddDependentAssemblyFile)(
		/*[in]*/ LPCWSTR /*pszFilePath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RemoveDependentAssemblyFile)(
		/*[in]*/ LPCWSTR /*pszFilePath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ConvertToAppRelPath)(
		/*[in]*/ LPCWSTR /*pszFilePath*/,
		/*[out]*/ BSTR* /*pbstrAppRelPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CBMCallbackActive)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(WaitForIntellisenseReady)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(IsDocumentInProject)(
		/*[in]*/ LPCWSTR /*pszFilePath*/,
		/*[out]*/ VSITEMID* /*pItemID*/)VSL_STDMETHOD_NOTIMPL
};

class IWebFileCtxServiceMockImpl :
	public IWebFileCtxService,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IWebFileCtxServiceMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IWebFileCtxServiceMockImpl)

	typedef IWebFileCtxService Interface;
	struct AddFileToIntellisenseValidValues
	{
		/*[in]*/ LPCWSTR pszFilePath;
		/*[out]*/ VSITEMID* pItemID;
		HRESULT retValue;
	};

	STDMETHOD(AddFileToIntellisense)(
		/*[in]*/ LPCWSTR pszFilePath,
		/*[out]*/ VSITEMID* pItemID)
	{
		VSL_DEFINE_MOCK_METHOD(AddFileToIntellisense)

		VSL_CHECK_VALIDVALUE_STRINGW(pszFilePath);

		VSL_SET_VALIDVALUE(pItemID);

		VSL_RETURN_VALIDVALUES();
	}
	struct EnsureFileOpenedValidValues
	{
		/*[in]*/ VSITEMID itemid;
		/*[out]*/ IVsWindowFrame** ppFrame;
		HRESULT retValue;
	};

	STDMETHOD(EnsureFileOpened)(
		/*[in]*/ VSITEMID itemid,
		/*[out]*/ IVsWindowFrame** ppFrame)
	{
		VSL_DEFINE_MOCK_METHOD(EnsureFileOpened)

		VSL_CHECK_VALIDVALUE(itemid);

		VSL_SET_VALIDVALUE_INTERFACE(ppFrame);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveFileFromIntellisenseValidValues
	{
		/*[in]*/ LPCWSTR pszFilePath;
		HRESULT retValue;
	};

	STDMETHOD(RemoveFileFromIntellisense)(
		/*[in]*/ LPCWSTR pszFilePath)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveFileFromIntellisense)

		VSL_CHECK_VALIDVALUE_STRINGW(pszFilePath);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetWebRootPathValidValues
	{
		/*[out]*/ BSTR* pbstrWebRootPath;
		HRESULT retValue;
	};

	STDMETHOD(GetWebRootPath)(
		/*[out]*/ BSTR* pbstrWebRootPath)
	{
		VSL_DEFINE_MOCK_METHOD(GetWebRootPath)

		VSL_SET_VALIDVALUE_BSTR(pbstrWebRootPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIntellisenseProjectNameValidValues
	{
		/*[out]*/ BSTR* pbstrProjectName;
		HRESULT retValue;
	};

	STDMETHOD(GetIntellisenseProjectName)(
		/*[out]*/ BSTR* pbstrProjectName)
	{
		VSL_DEFINE_MOCK_METHOD(GetIntellisenseProjectName)

		VSL_SET_VALIDVALUE_BSTR(pbstrProjectName);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddDependentAssemblyFileValidValues
	{
		/*[in]*/ LPCWSTR pszFilePath;
		HRESULT retValue;
	};

	STDMETHOD(AddDependentAssemblyFile)(
		/*[in]*/ LPCWSTR pszFilePath)
	{
		VSL_DEFINE_MOCK_METHOD(AddDependentAssemblyFile)

		VSL_CHECK_VALIDVALUE_STRINGW(pszFilePath);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveDependentAssemblyFileValidValues
	{
		/*[in]*/ LPCWSTR pszFilePath;
		HRESULT retValue;
	};

	STDMETHOD(RemoveDependentAssemblyFile)(
		/*[in]*/ LPCWSTR pszFilePath)
	{
		VSL_DEFINE_MOCK_METHOD(RemoveDependentAssemblyFile)

		VSL_CHECK_VALIDVALUE_STRINGW(pszFilePath);

		VSL_RETURN_VALIDVALUES();
	}
	struct ConvertToAppRelPathValidValues
	{
		/*[in]*/ LPCWSTR pszFilePath;
		/*[out]*/ BSTR* pbstrAppRelPath;
		HRESULT retValue;
	};

	STDMETHOD(ConvertToAppRelPath)(
		/*[in]*/ LPCWSTR pszFilePath,
		/*[out]*/ BSTR* pbstrAppRelPath)
	{
		VSL_DEFINE_MOCK_METHOD(ConvertToAppRelPath)

		VSL_CHECK_VALIDVALUE_STRINGW(pszFilePath);

		VSL_SET_VALIDVALUE_BSTR(pbstrAppRelPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct CBMCallbackActiveValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(CBMCallbackActive)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(CBMCallbackActive)

		VSL_RETURN_VALIDVALUES();
	}
	struct WaitForIntellisenseReadyValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(WaitForIntellisenseReady)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(WaitForIntellisenseReady)

		VSL_RETURN_VALIDVALUES();
	}
	struct IsDocumentInProjectValidValues
	{
		/*[in]*/ LPCWSTR pszFilePath;
		/*[out]*/ VSITEMID* pItemID;
		HRESULT retValue;
	};

	STDMETHOD(IsDocumentInProject)(
		/*[in]*/ LPCWSTR pszFilePath,
		/*[out]*/ VSITEMID* pItemID)
	{
		VSL_DEFINE_MOCK_METHOD(IsDocumentInProject)

		VSL_CHECK_VALIDVALUE_STRINGW(pszFilePath);

		VSL_SET_VALIDVALUE(pItemID);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IWEBFILECTXSERVICE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIXMLDOMAttribute.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IXMLDOMATTRIBUTE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IXMLDOMATTRIBUTE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "XmlDom.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IXMLDOMAttributeNotImpl :
	public IXMLDOMAttribute
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IXMLDOMAttributeNotImpl)

public:

	typedef IXMLDOMAttribute Interface;

	STDMETHOD(get_name)(
		/*[out,retval]*/ BSTR* /*attributeName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_value)(
		/*[out,retval]*/ VARIANT* /*attributeValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_value)(
		/*[in]*/ VARIANT /*attributeValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeName)(
		/*[out,retval]*/ BSTR* /*name*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeValue)(
		/*[out,retval]*/ VARIANT* /*value*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_nodeValue)(
		/*[in]*/ VARIANT /*value*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeType)(
		/*[out,retval]*/ DOMNodeType* /*type*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_parentNode)(
		/*[out,retval]*/ IXMLDOMNode** /*parent*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_childNodes)(
		/*[out,retval]*/ IXMLDOMNodeList** /*childList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_firstChild)(
		/*[out,retval]*/ IXMLDOMNode** /*firstChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_lastChild)(
		/*[out,retval]*/ IXMLDOMNode** /*lastChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_previousSibling)(
		/*[out,retval]*/ IXMLDOMNode** /*previousSibling*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nextSibling)(
		/*[out,retval]*/ IXMLDOMNode** /*nextSibling*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_attributes)(
		/*[out,retval]*/ IXMLDOMNamedNodeMap** /*attributeMap*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(insertBefore)(
		/*[in]*/ IXMLDOMNode* /*newChild*/,
		/*[in]*/ VARIANT /*refChild*/,
		/*[out,retval]*/ IXMLDOMNode** /*outNewChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(replaceChild)(
		/*[in]*/ IXMLDOMNode* /*newChild*/,
		/*[in]*/ IXMLDOMNode* /*oldChild*/,
		/*[out,retval]*/ IXMLDOMNode** /*outOldChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(removeChild)(
		/*[in]*/ IXMLDOMNode* /*childNode*/,
		/*[out,retval]*/ IXMLDOMNode** /*oldChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(appendChild)(
		/*[in]*/ IXMLDOMNode* /*newChild*/,
		/*[out,retval]*/ IXMLDOMNode** /*outNewChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(hasChildNodes)(
		/*[out,retval]*/ VARIANT_BOOL* /*hasChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ownerDocument)(
		/*[out,retval]*/ IXMLDOMDocument** /*DOMDocument*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(cloneNode)(
		/*[in]*/ VARIANT_BOOL /*deep*/,
		/*[out,retval]*/ IXMLDOMNode** /*cloneRoot*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeTypeString)(
		/*[retval,out]*/ BSTR* /*nodeType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_text)(
		/*[retval,out]*/ BSTR* /*text*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_text)(
		/*[in]*/ BSTR /*text*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_specified)(
		/*[out,retval]*/ VARIANT_BOOL* /*isSpecified*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_definition)(
		/*[retval,out]*/ IXMLDOMNode** /*definitionNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeTypedValue)(
		/*[retval,out]*/ VARIANT* /*typedValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_nodeTypedValue)(
		/*[in]*/ VARIANT /*typedValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_dataType)(
		/*[retval,out]*/ VARIANT* /*dataTypeName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_dataType)(
		/*[in]*/ BSTR /*dataTypeName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_xml)(
		/*[retval,out]*/ BSTR* /*xmlString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(transformNode)(
		/*[in]*/ IXMLDOMNode* /*stylesheet*/,
		/*[retval,out]*/ BSTR* /*xmlString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(selectNodes)(
		/*[in]*/ BSTR /*queryString*/,
		/*[retval,out]*/ IXMLDOMNodeList** /*resultList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(selectSingleNode)(
		/*[in]*/ BSTR /*queryString*/,
		/*[retval,out]*/ IXMLDOMNode** /*resultNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_parsed)(
		/*[retval,out]*/ VARIANT_BOOL* /*isParsed*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_namespaceURI)(
		/*[retval,out]*/ BSTR* /*namespaceURI*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_prefix)(
		/*[retval,out]*/ BSTR* /*prefixString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_baseName)(
		/*[retval,out]*/ BSTR* /*nameString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(transformNodeToObject)(
		/*[in]*/ IXMLDOMNode* /*stylesheet*/,
		/*[in]*/ VARIANT /*outputObject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class IXMLDOMAttributeMockImpl :
	public IXMLDOMAttribute,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IXMLDOMAttributeMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IXMLDOMAttributeMockImpl)

	typedef IXMLDOMAttribute Interface;
	struct get_nameValidValues
	{
		/*[out,retval]*/ BSTR* attributeName;
		HRESULT retValue;
	};

	STDMETHOD(get_name)(
		/*[out,retval]*/ BSTR* attributeName)
	{
		VSL_DEFINE_MOCK_METHOD(get_name)

		VSL_SET_VALIDVALUE_BSTR(attributeName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_valueValidValues
	{
		/*[out,retval]*/ VARIANT* attributeValue;
		HRESULT retValue;
	};

	STDMETHOD(get_value)(
		/*[out,retval]*/ VARIANT* attributeValue)
	{
		VSL_DEFINE_MOCK_METHOD(get_value)

		VSL_SET_VALIDVALUE_VARIANT(attributeValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_valueValidValues
	{
		/*[in]*/ VARIANT attributeValue;
		HRESULT retValue;
	};

	STDMETHOD(put_value)(
		/*[in]*/ VARIANT attributeValue)
	{
		VSL_DEFINE_MOCK_METHOD(put_value)

		VSL_CHECK_VALIDVALUE(attributeValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeNameValidValues
	{
		/*[out,retval]*/ BSTR* name;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeName)(
		/*[out,retval]*/ BSTR* name)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeName)

		VSL_SET_VALIDVALUE_BSTR(name);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeValueValidValues
	{
		/*[out,retval]*/ VARIANT* value;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeValue)(
		/*[out,retval]*/ VARIANT* value)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeValue)

		VSL_SET_VALIDVALUE_VARIANT(value);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_nodeValueValidValues
	{
		/*[in]*/ VARIANT value;
		HRESULT retValue;
	};

	STDMETHOD(put_nodeValue)(
		/*[in]*/ VARIANT value)
	{
		VSL_DEFINE_MOCK_METHOD(put_nodeValue)

		VSL_CHECK_VALIDVALUE(value);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeTypeValidValues
	{
		/*[out,retval]*/ DOMNodeType* type;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeType)(
		/*[out,retval]*/ DOMNodeType* type)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeType)

		VSL_SET_VALIDVALUE(type);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_parentNodeValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** parent;
		HRESULT retValue;
	};

	STDMETHOD(get_parentNode)(
		/*[out,retval]*/ IXMLDOMNode** parent)
	{
		VSL_DEFINE_MOCK_METHOD(get_parentNode)

		VSL_SET_VALIDVALUE_INTERFACE(parent);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_childNodesValidValues
	{
		/*[out,retval]*/ IXMLDOMNodeList** childList;
		HRESULT retValue;
	};

	STDMETHOD(get_childNodes)(
		/*[out,retval]*/ IXMLDOMNodeList** childList)
	{
		VSL_DEFINE_MOCK_METHOD(get_childNodes)

		VSL_SET_VALIDVALUE_INTERFACE(childList);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_firstChildValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** firstChild;
		HRESULT retValue;
	};

	STDMETHOD(get_firstChild)(
		/*[out,retval]*/ IXMLDOMNode** firstChild)
	{
		VSL_DEFINE_MOCK_METHOD(get_firstChild)

		VSL_SET_VALIDVALUE_INTERFACE(firstChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_lastChildValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** lastChild;
		HRESULT retValue;
	};

	STDMETHOD(get_lastChild)(
		/*[out,retval]*/ IXMLDOMNode** lastChild)
	{
		VSL_DEFINE_MOCK_METHOD(get_lastChild)

		VSL_SET_VALIDVALUE_INTERFACE(lastChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_previousSiblingValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** previousSibling;
		HRESULT retValue;
	};

	STDMETHOD(get_previousSibling)(
		/*[out,retval]*/ IXMLDOMNode** previousSibling)
	{
		VSL_DEFINE_MOCK_METHOD(get_previousSibling)

		VSL_SET_VALIDVALUE_INTERFACE(previousSibling);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nextSiblingValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** nextSibling;
		HRESULT retValue;
	};

	STDMETHOD(get_nextSibling)(
		/*[out,retval]*/ IXMLDOMNode** nextSibling)
	{
		VSL_DEFINE_MOCK_METHOD(get_nextSibling)

		VSL_SET_VALIDVALUE_INTERFACE(nextSibling);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_attributesValidValues
	{
		/*[out,retval]*/ IXMLDOMNamedNodeMap** attributeMap;
		HRESULT retValue;
	};

	STDMETHOD(get_attributes)(
		/*[out,retval]*/ IXMLDOMNamedNodeMap** attributeMap)
	{
		VSL_DEFINE_MOCK_METHOD(get_attributes)

		VSL_SET_VALIDVALUE_INTERFACE(attributeMap);

		VSL_RETURN_VALIDVALUES();
	}
	struct insertBeforeValidValues
	{
		/*[in]*/ IXMLDOMNode* newChild;
		/*[in]*/ VARIANT refChild;
		/*[out,retval]*/ IXMLDOMNode** outNewChild;
		HRESULT retValue;
	};

	STDMETHOD(insertBefore)(
		/*[in]*/ IXMLDOMNode* newChild,
		/*[in]*/ VARIANT refChild,
		/*[out,retval]*/ IXMLDOMNode** outNewChild)
	{
		VSL_DEFINE_MOCK_METHOD(insertBefore)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(newChild);

		VSL_CHECK_VALIDVALUE(refChild);

		VSL_SET_VALIDVALUE_INTERFACE(outNewChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct replaceChildValidValues
	{
		/*[in]*/ IXMLDOMNode* newChild;
		/*[in]*/ IXMLDOMNode* oldChild;
		/*[out,retval]*/ IXMLDOMNode** outOldChild;
		HRESULT retValue;
	};

	STDMETHOD(replaceChild)(
		/*[in]*/ IXMLDOMNode* newChild,
		/*[in]*/ IXMLDOMNode* oldChild,
		/*[out,retval]*/ IXMLDOMNode** outOldChild)
	{
		VSL_DEFINE_MOCK_METHOD(replaceChild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(newChild);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(oldChild);

		VSL_SET_VALIDVALUE_INTERFACE(outOldChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct removeChildValidValues
	{
		/*[in]*/ IXMLDOMNode* childNode;
		/*[out,retval]*/ IXMLDOMNode** oldChild;
		HRESULT retValue;
	};

	STDMETHOD(removeChild)(
		/*[in]*/ IXMLDOMNode* childNode,
		/*[out,retval]*/ IXMLDOMNode** oldChild)
	{
		VSL_DEFINE_MOCK_METHOD(removeChild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(childNode);

		VSL_SET_VALIDVALUE_INTERFACE(oldChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct appendChildValidValues
	{
		/*[in]*/ IXMLDOMNode* newChild;
		/*[out,retval]*/ IXMLDOMNode** outNewChild;
		HRESULT retValue;
	};

	STDMETHOD(appendChild)(
		/*[in]*/ IXMLDOMNode* newChild,
		/*[out,retval]*/ IXMLDOMNode** outNewChild)
	{
		VSL_DEFINE_MOCK_METHOD(appendChild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(newChild);

		VSL_SET_VALIDVALUE_INTERFACE(outNewChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct hasChildNodesValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* hasChild;
		HRESULT retValue;
	};

	STDMETHOD(hasChildNodes)(
		/*[out,retval]*/ VARIANT_BOOL* hasChild)
	{
		VSL_DEFINE_MOCK_METHOD(hasChildNodes)

		VSL_SET_VALIDVALUE(hasChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ownerDocumentValidValues
	{
		/*[out,retval]*/ IXMLDOMDocument** DOMDocument;
		HRESULT retValue;
	};

	STDMETHOD(get_ownerDocument)(
		/*[out,retval]*/ IXMLDOMDocument** DOMDocument)
	{
		VSL_DEFINE_MOCK_METHOD(get_ownerDocument)

		VSL_SET_VALIDVALUE_INTERFACE(DOMDocument);

		VSL_RETURN_VALIDVALUES();
	}
	struct cloneNodeValidValues
	{
		/*[in]*/ VARIANT_BOOL deep;
		/*[out,retval]*/ IXMLDOMNode** cloneRoot;
		HRESULT retValue;
	};

	STDMETHOD(cloneNode)(
		/*[in]*/ VARIANT_BOOL deep,
		/*[out,retval]*/ IXMLDOMNode** cloneRoot)
	{
		VSL_DEFINE_MOCK_METHOD(cloneNode)

		VSL_CHECK_VALIDVALUE(deep);

		VSL_SET_VALIDVALUE_INTERFACE(cloneRoot);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeTypeStringValidValues
	{
		/*[retval,out]*/ BSTR* nodeType;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeTypeString)(
		/*[retval,out]*/ BSTR* nodeType)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeTypeString)

		VSL_SET_VALIDVALUE_BSTR(nodeType);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_textValidValues
	{
		/*[retval,out]*/ BSTR* text;
		HRESULT retValue;
	};

	STDMETHOD(get_text)(
		/*[retval,out]*/ BSTR* text)
	{
		VSL_DEFINE_MOCK_METHOD(get_text)

		VSL_SET_VALIDVALUE_BSTR(text);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_textValidValues
	{
		/*[in]*/ BSTR text;
		HRESULT retValue;
	};

	STDMETHOD(put_text)(
		/*[in]*/ BSTR text)
	{
		VSL_DEFINE_MOCK_METHOD(put_text)

		VSL_CHECK_VALIDVALUE_BSTR(text);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_specifiedValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* isSpecified;
		HRESULT retValue;
	};

	STDMETHOD(get_specified)(
		/*[out,retval]*/ VARIANT_BOOL* isSpecified)
	{
		VSL_DEFINE_MOCK_METHOD(get_specified)

		VSL_SET_VALIDVALUE(isSpecified);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_definitionValidValues
	{
		/*[retval,out]*/ IXMLDOMNode** definitionNode;
		HRESULT retValue;
	};

	STDMETHOD(get_definition)(
		/*[retval,out]*/ IXMLDOMNode** definitionNode)
	{
		VSL_DEFINE_MOCK_METHOD(get_definition)

		VSL_SET_VALIDVALUE_INTERFACE(definitionNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeTypedValueValidValues
	{
		/*[retval,out]*/ VARIANT* typedValue;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeTypedValue)(
		/*[retval,out]*/ VARIANT* typedValue)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeTypedValue)

		VSL_SET_VALIDVALUE_VARIANT(typedValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_nodeTypedValueValidValues
	{
		/*[in]*/ VARIANT typedValue;
		HRESULT retValue;
	};

	STDMETHOD(put_nodeTypedValue)(
		/*[in]*/ VARIANT typedValue)
	{
		VSL_DEFINE_MOCK_METHOD(put_nodeTypedValue)

		VSL_CHECK_VALIDVALUE(typedValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_dataTypeValidValues
	{
		/*[retval,out]*/ VARIANT* dataTypeName;
		HRESULT retValue;
	};

	STDMETHOD(get_dataType)(
		/*[retval,out]*/ VARIANT* dataTypeName)
	{
		VSL_DEFINE_MOCK_METHOD(get_dataType)

		VSL_SET_VALIDVALUE_VARIANT(dataTypeName);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_dataTypeValidValues
	{
		/*[in]*/ BSTR dataTypeName;
		HRESULT retValue;
	};

	STDMETHOD(put_dataType)(
		/*[in]*/ BSTR dataTypeName)
	{
		VSL_DEFINE_MOCK_METHOD(put_dataType)

		VSL_CHECK_VALIDVALUE_BSTR(dataTypeName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_xmlValidValues
	{
		/*[retval,out]*/ BSTR* xmlString;
		HRESULT retValue;
	};

	STDMETHOD(get_xml)(
		/*[retval,out]*/ BSTR* xmlString)
	{
		VSL_DEFINE_MOCK_METHOD(get_xml)

		VSL_SET_VALIDVALUE_BSTR(xmlString);

		VSL_RETURN_VALIDVALUES();
	}
	struct transformNodeValidValues
	{
		/*[in]*/ IXMLDOMNode* stylesheet;
		/*[retval,out]*/ BSTR* xmlString;
		HRESULT retValue;
	};

	STDMETHOD(transformNode)(
		/*[in]*/ IXMLDOMNode* stylesheet,
		/*[retval,out]*/ BSTR* xmlString)
	{
		VSL_DEFINE_MOCK_METHOD(transformNode)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(stylesheet);

		VSL_SET_VALIDVALUE_BSTR(xmlString);

		VSL_RETURN_VALIDVALUES();
	}
	struct selectNodesValidValues
	{
		/*[in]*/ BSTR queryString;
		/*[retval,out]*/ IXMLDOMNodeList** resultList;
		HRESULT retValue;
	};

	STDMETHOD(selectNodes)(
		/*[in]*/ BSTR queryString,
		/*[retval,out]*/ IXMLDOMNodeList** resultList)
	{
		VSL_DEFINE_MOCK_METHOD(selectNodes)

		VSL_CHECK_VALIDVALUE_BSTR(queryString);

		VSL_SET_VALIDVALUE_INTERFACE(resultList);

		VSL_RETURN_VALIDVALUES();
	}
	struct selectSingleNodeValidValues
	{
		/*[in]*/ BSTR queryString;
		/*[retval,out]*/ IXMLDOMNode** resultNode;
		HRESULT retValue;
	};

	STDMETHOD(selectSingleNode)(
		/*[in]*/ BSTR queryString,
		/*[retval,out]*/ IXMLDOMNode** resultNode)
	{
		VSL_DEFINE_MOCK_METHOD(selectSingleNode)

		VSL_CHECK_VALIDVALUE_BSTR(queryString);

		VSL_SET_VALIDVALUE_INTERFACE(resultNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_parsedValidValues
	{
		/*[retval,out]*/ VARIANT_BOOL* isParsed;
		HRESULT retValue;
	};

	STDMETHOD(get_parsed)(
		/*[retval,out]*/ VARIANT_BOOL* isParsed)
	{
		VSL_DEFINE_MOCK_METHOD(get_parsed)

		VSL_SET_VALIDVALUE(isParsed);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_namespaceURIValidValues
	{
		/*[retval,out]*/ BSTR* namespaceURI;
		HRESULT retValue;
	};

	STDMETHOD(get_namespaceURI)(
		/*[retval,out]*/ BSTR* namespaceURI)
	{
		VSL_DEFINE_MOCK_METHOD(get_namespaceURI)

		VSL_SET_VALIDVALUE_BSTR(namespaceURI);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_prefixValidValues
	{
		/*[retval,out]*/ BSTR* prefixString;
		HRESULT retValue;
	};

	STDMETHOD(get_prefix)(
		/*[retval,out]*/ BSTR* prefixString)
	{
		VSL_DEFINE_MOCK_METHOD(get_prefix)

		VSL_SET_VALIDVALUE_BSTR(prefixString);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_baseNameValidValues
	{
		/*[retval,out]*/ BSTR* nameString;
		HRESULT retValue;
	};

	STDMETHOD(get_baseName)(
		/*[retval,out]*/ BSTR* nameString)
	{
		VSL_DEFINE_MOCK_METHOD(get_baseName)

		VSL_SET_VALIDVALUE_BSTR(nameString);

		VSL_RETURN_VALIDVALUES();
	}
	struct transformNodeToObjectValidValues
	{
		/*[in]*/ IXMLDOMNode* stylesheet;
		/*[in]*/ VARIANT outputObject;
		HRESULT retValue;
	};

	STDMETHOD(transformNodeToObject)(
		/*[in]*/ IXMLDOMNode* stylesheet,
		/*[in]*/ VARIANT outputObject)
	{
		VSL_DEFINE_MOCK_METHOD(transformNodeToObject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(stylesheet);

		VSL_CHECK_VALIDVALUE(outputObject);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IXMLDOMATTRIBUTE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIXMLDOMCDATASection.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IXMLDOMCDATASECTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IXMLDOMCDATASECTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "XmlDom.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IXMLDOMCDATASectionNotImpl :
	public IXMLDOMCDATASection
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IXMLDOMCDATASectionNotImpl)

public:

	typedef IXMLDOMCDATASection Interface;

	STDMETHOD(splitText)(
		/*[in]*/ long /*offset*/,
		/*[out,retval]*/ IXMLDOMText** /*rightHandTextNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_data)(
		/*[out,retval]*/ BSTR* /*data*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_data)(
		/*[in]*/ BSTR /*data*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_length)(
		/*[out,retval]*/ long* /*dataLength*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(substringData)(
		/*[in]*/ long /*offset*/,
		/*[in]*/ long /*count*/,
		/*[out,retval]*/ BSTR* /*data*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(appendData)(
		/*[in]*/ BSTR /*data*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(insertData)(
		/*[in]*/ long /*offset*/,
		/*[in]*/ BSTR /*data*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(deleteData)(
		/*[in]*/ long /*offset*/,
		/*[in]*/ long /*count*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(replaceData)(
		/*[in]*/ long /*offset*/,
		/*[in]*/ long /*count*/,
		/*[in]*/ BSTR /*data*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeName)(
		/*[out,retval]*/ BSTR* /*name*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeValue)(
		/*[out,retval]*/ VARIANT* /*value*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_nodeValue)(
		/*[in]*/ VARIANT /*value*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeType)(
		/*[out,retval]*/ DOMNodeType* /*type*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_parentNode)(
		/*[out,retval]*/ IXMLDOMNode** /*parent*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_childNodes)(
		/*[out,retval]*/ IXMLDOMNodeList** /*childList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_firstChild)(
		/*[out,retval]*/ IXMLDOMNode** /*firstChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_lastChild)(
		/*[out,retval]*/ IXMLDOMNode** /*lastChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_previousSibling)(
		/*[out,retval]*/ IXMLDOMNode** /*previousSibling*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nextSibling)(
		/*[out,retval]*/ IXMLDOMNode** /*nextSibling*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_attributes)(
		/*[out,retval]*/ IXMLDOMNamedNodeMap** /*attributeMap*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(insertBefore)(
		/*[in]*/ IXMLDOMNode* /*newChild*/,
		/*[in]*/ VARIANT /*refChild*/,
		/*[out,retval]*/ IXMLDOMNode** /*outNewChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(replaceChild)(
		/*[in]*/ IXMLDOMNode* /*newChild*/,
		/*[in]*/ IXMLDOMNode* /*oldChild*/,
		/*[out,retval]*/ IXMLDOMNode** /*outOldChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(removeChild)(
		/*[in]*/ IXMLDOMNode* /*childNode*/,
		/*[out,retval]*/ IXMLDOMNode** /*oldChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(appendChild)(
		/*[in]*/ IXMLDOMNode* /*newChild*/,
		/*[out,retval]*/ IXMLDOMNode** /*outNewChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(hasChildNodes)(
		/*[out,retval]*/ VARIANT_BOOL* /*hasChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ownerDocument)(
		/*[out,retval]*/ IXMLDOMDocument** /*DOMDocument*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(cloneNode)(
		/*[in]*/ VARIANT_BOOL /*deep*/,
		/*[out,retval]*/ IXMLDOMNode** /*cloneRoot*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeTypeString)(
		/*[retval,out]*/ BSTR* /*nodeType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_text)(
		/*[retval,out]*/ BSTR* /*text*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_text)(
		/*[in]*/ BSTR /*text*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_specified)(
		/*[out,retval]*/ VARIANT_BOOL* /*isSpecified*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_definition)(
		/*[retval,out]*/ IXMLDOMNode** /*definitionNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeTypedValue)(
		/*[retval,out]*/ VARIANT* /*typedValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_nodeTypedValue)(
		/*[in]*/ VARIANT /*typedValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_dataType)(
		/*[retval,out]*/ VARIANT* /*dataTypeName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_dataType)(
		/*[in]*/ BSTR /*dataTypeName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_xml)(
		/*[retval,out]*/ BSTR* /*xmlString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(transformNode)(
		/*[in]*/ IXMLDOMNode* /*stylesheet*/,
		/*[retval,out]*/ BSTR* /*xmlString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(selectNodes)(
		/*[in]*/ BSTR /*queryString*/,
		/*[retval,out]*/ IXMLDOMNodeList** /*resultList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(selectSingleNode)(
		/*[in]*/ BSTR /*queryString*/,
		/*[retval,out]*/ IXMLDOMNode** /*resultNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_parsed)(
		/*[retval,out]*/ VARIANT_BOOL* /*isParsed*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_namespaceURI)(
		/*[retval,out]*/ BSTR* /*namespaceURI*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_prefix)(
		/*[retval,out]*/ BSTR* /*prefixString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_baseName)(
		/*[retval,out]*/ BSTR* /*nameString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(transformNodeToObject)(
		/*[in]*/ IXMLDOMNode* /*stylesheet*/,
		/*[in]*/ VARIANT /*outputObject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class IXMLDOMCDATASectionMockImpl :
	public IXMLDOMCDATASection,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IXMLDOMCDATASectionMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IXMLDOMCDATASectionMockImpl)

	typedef IXMLDOMCDATASection Interface;
	struct splitTextValidValues
	{
		/*[in]*/ long offset;
		/*[out,retval]*/ IXMLDOMText** rightHandTextNode;
		HRESULT retValue;
	};

	STDMETHOD(splitText)(
		/*[in]*/ long offset,
		/*[out,retval]*/ IXMLDOMText** rightHandTextNode)
	{
		VSL_DEFINE_MOCK_METHOD(splitText)

		VSL_CHECK_VALIDVALUE(offset);

		VSL_SET_VALIDVALUE_INTERFACE(rightHandTextNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_dataValidValues
	{
		/*[out,retval]*/ BSTR* data;
		HRESULT retValue;
	};

	STDMETHOD(get_data)(
		/*[out,retval]*/ BSTR* data)
	{
		VSL_DEFINE_MOCK_METHOD(get_data)

		VSL_SET_VALIDVALUE_BSTR(data);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_dataValidValues
	{
		/*[in]*/ BSTR data;
		HRESULT retValue;
	};

	STDMETHOD(put_data)(
		/*[in]*/ BSTR data)
	{
		VSL_DEFINE_MOCK_METHOD(put_data)

		VSL_CHECK_VALIDVALUE_BSTR(data);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_lengthValidValues
	{
		/*[out,retval]*/ long* dataLength;
		HRESULT retValue;
	};

	STDMETHOD(get_length)(
		/*[out,retval]*/ long* dataLength)
	{
		VSL_DEFINE_MOCK_METHOD(get_length)

		VSL_SET_VALIDVALUE(dataLength);

		VSL_RETURN_VALIDVALUES();
	}
	struct substringDataValidValues
	{
		/*[in]*/ long offset;
		/*[in]*/ long count;
		/*[out,retval]*/ BSTR* data;
		HRESULT retValue;
	};

	STDMETHOD(substringData)(
		/*[in]*/ long offset,
		/*[in]*/ long count,
		/*[out,retval]*/ BSTR* data)
	{
		VSL_DEFINE_MOCK_METHOD(substringData)

		VSL_CHECK_VALIDVALUE(offset);

		VSL_CHECK_VALIDVALUE(count);

		VSL_SET_VALIDVALUE_BSTR(data);

		VSL_RETURN_VALIDVALUES();
	}
	struct appendDataValidValues
	{
		/*[in]*/ BSTR data;
		HRESULT retValue;
	};

	STDMETHOD(appendData)(
		/*[in]*/ BSTR data)
	{
		VSL_DEFINE_MOCK_METHOD(appendData)

		VSL_CHECK_VALIDVALUE_BSTR(data);

		VSL_RETURN_VALIDVALUES();
	}
	struct insertDataValidValues
	{
		/*[in]*/ long offset;
		/*[in]*/ BSTR data;
		HRESULT retValue;
	};

	STDMETHOD(insertData)(
		/*[in]*/ long offset,
		/*[in]*/ BSTR data)
	{
		VSL_DEFINE_MOCK_METHOD(insertData)

		VSL_CHECK_VALIDVALUE(offset);

		VSL_CHECK_VALIDVALUE_BSTR(data);

		VSL_RETURN_VALIDVALUES();
	}
	struct deleteDataValidValues
	{
		/*[in]*/ long offset;
		/*[in]*/ long count;
		HRESULT retValue;
	};

	STDMETHOD(deleteData)(
		/*[in]*/ long offset,
		/*[in]*/ long count)
	{
		VSL_DEFINE_MOCK_METHOD(deleteData)

		VSL_CHECK_VALIDVALUE(offset);

		VSL_CHECK_VALIDVALUE(count);

		VSL_RETURN_VALIDVALUES();
	}
	struct replaceDataValidValues
	{
		/*[in]*/ long offset;
		/*[in]*/ long count;
		/*[in]*/ BSTR data;
		HRESULT retValue;
	};

	STDMETHOD(replaceData)(
		/*[in]*/ long offset,
		/*[in]*/ long count,
		/*[in]*/ BSTR data)
	{
		VSL_DEFINE_MOCK_METHOD(replaceData)

		VSL_CHECK_VALIDVALUE(offset);

		VSL_CHECK_VALIDVALUE(count);

		VSL_CHECK_VALIDVALUE_BSTR(data);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeNameValidValues
	{
		/*[out,retval]*/ BSTR* name;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeName)(
		/*[out,retval]*/ BSTR* name)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeName)

		VSL_SET_VALIDVALUE_BSTR(name);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeValueValidValues
	{
		/*[out,retval]*/ VARIANT* value;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeValue)(
		/*[out,retval]*/ VARIANT* value)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeValue)

		VSL_SET_VALIDVALUE_VARIANT(value);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_nodeValueValidValues
	{
		/*[in]*/ VARIANT value;
		HRESULT retValue;
	};

	STDMETHOD(put_nodeValue)(
		/*[in]*/ VARIANT value)
	{
		VSL_DEFINE_MOCK_METHOD(put_nodeValue)

		VSL_CHECK_VALIDVALUE(value);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeTypeValidValues
	{
		/*[out,retval]*/ DOMNodeType* type;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeType)(
		/*[out,retval]*/ DOMNodeType* type)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeType)

		VSL_SET_VALIDVALUE(type);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_parentNodeValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** parent;
		HRESULT retValue;
	};

	STDMETHOD(get_parentNode)(
		/*[out,retval]*/ IXMLDOMNode** parent)
	{
		VSL_DEFINE_MOCK_METHOD(get_parentNode)

		VSL_SET_VALIDVALUE_INTERFACE(parent);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_childNodesValidValues
	{
		/*[out,retval]*/ IXMLDOMNodeList** childList;
		HRESULT retValue;
	};

	STDMETHOD(get_childNodes)(
		/*[out,retval]*/ IXMLDOMNodeList** childList)
	{
		VSL_DEFINE_MOCK_METHOD(get_childNodes)

		VSL_SET_VALIDVALUE_INTERFACE(childList);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_firstChildValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** firstChild;
		HRESULT retValue;
	};

	STDMETHOD(get_firstChild)(
		/*[out,retval]*/ IXMLDOMNode** firstChild)
	{
		VSL_DEFINE_MOCK_METHOD(get_firstChild)

		VSL_SET_VALIDVALUE_INTERFACE(firstChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_lastChildValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** lastChild;
		HRESULT retValue;
	};

	STDMETHOD(get_lastChild)(
		/*[out,retval]*/ IXMLDOMNode** lastChild)
	{
		VSL_DEFINE_MOCK_METHOD(get_lastChild)

		VSL_SET_VALIDVALUE_INTERFACE(lastChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_previousSiblingValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** previousSibling;
		HRESULT retValue;
	};

	STDMETHOD(get_previousSibling)(
		/*[out,retval]*/ IXMLDOMNode** previousSibling)
	{
		VSL_DEFINE_MOCK_METHOD(get_previousSibling)

		VSL_SET_VALIDVALUE_INTERFACE(previousSibling);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nextSiblingValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** nextSibling;
		HRESULT retValue;
	};

	STDMETHOD(get_nextSibling)(
		/*[out,retval]*/ IXMLDOMNode** nextSibling)
	{
		VSL_DEFINE_MOCK_METHOD(get_nextSibling)

		VSL_SET_VALIDVALUE_INTERFACE(nextSibling);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_attributesValidValues
	{
		/*[out,retval]*/ IXMLDOMNamedNodeMap** attributeMap;
		HRESULT retValue;
	};

	STDMETHOD(get_attributes)(
		/*[out,retval]*/ IXMLDOMNamedNodeMap** attributeMap)
	{
		VSL_DEFINE_MOCK_METHOD(get_attributes)

		VSL_SET_VALIDVALUE_INTERFACE(attributeMap);

		VSL_RETURN_VALIDVALUES();
	}
	struct insertBeforeValidValues
	{
		/*[in]*/ IXMLDOMNode* newChild;
		/*[in]*/ VARIANT refChild;
		/*[out,retval]*/ IXMLDOMNode** outNewChild;
		HRESULT retValue;
	};

	STDMETHOD(insertBefore)(
		/*[in]*/ IXMLDOMNode* newChild,
		/*[in]*/ VARIANT refChild,
		/*[out,retval]*/ IXMLDOMNode** outNewChild)
	{
		VSL_DEFINE_MOCK_METHOD(insertBefore)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(newChild);

		VSL_CHECK_VALIDVALUE(refChild);

		VSL_SET_VALIDVALUE_INTERFACE(outNewChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct replaceChildValidValues
	{
		/*[in]*/ IXMLDOMNode* newChild;
		/*[in]*/ IXMLDOMNode* oldChild;
		/*[out,retval]*/ IXMLDOMNode** outOldChild;
		HRESULT retValue;
	};

	STDMETHOD(replaceChild)(
		/*[in]*/ IXMLDOMNode* newChild,
		/*[in]*/ IXMLDOMNode* oldChild,
		/*[out,retval]*/ IXMLDOMNode** outOldChild)
	{
		VSL_DEFINE_MOCK_METHOD(replaceChild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(newChild);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(oldChild);

		VSL_SET_VALIDVALUE_INTERFACE(outOldChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct removeChildValidValues
	{
		/*[in]*/ IXMLDOMNode* childNode;
		/*[out,retval]*/ IXMLDOMNode** oldChild;
		HRESULT retValue;
	};

	STDMETHOD(removeChild)(
		/*[in]*/ IXMLDOMNode* childNode,
		/*[out,retval]*/ IXMLDOMNode** oldChild)
	{
		VSL_DEFINE_MOCK_METHOD(removeChild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(childNode);

		VSL_SET_VALIDVALUE_INTERFACE(oldChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct appendChildValidValues
	{
		/*[in]*/ IXMLDOMNode* newChild;
		/*[out,retval]*/ IXMLDOMNode** outNewChild;
		HRESULT retValue;
	};

	STDMETHOD(appendChild)(
		/*[in]*/ IXMLDOMNode* newChild,
		/*[out,retval]*/ IXMLDOMNode** outNewChild)
	{
		VSL_DEFINE_MOCK_METHOD(appendChild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(newChild);

		VSL_SET_VALIDVALUE_INTERFACE(outNewChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct hasChildNodesValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* hasChild;
		HRESULT retValue;
	};

	STDMETHOD(hasChildNodes)(
		/*[out,retval]*/ VARIANT_BOOL* hasChild)
	{
		VSL_DEFINE_MOCK_METHOD(hasChildNodes)

		VSL_SET_VALIDVALUE(hasChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ownerDocumentValidValues
	{
		/*[out,retval]*/ IXMLDOMDocument** DOMDocument;
		HRESULT retValue;
	};

	STDMETHOD(get_ownerDocument)(
		/*[out,retval]*/ IXMLDOMDocument** DOMDocument)
	{
		VSL_DEFINE_MOCK_METHOD(get_ownerDocument)

		VSL_SET_VALIDVALUE_INTERFACE(DOMDocument);

		VSL_RETURN_VALIDVALUES();
	}
	struct cloneNodeValidValues
	{
		/*[in]*/ VARIANT_BOOL deep;
		/*[out,retval]*/ IXMLDOMNode** cloneRoot;
		HRESULT retValue;
	};

	STDMETHOD(cloneNode)(
		/*[in]*/ VARIANT_BOOL deep,
		/*[out,retval]*/ IXMLDOMNode** cloneRoot)
	{
		VSL_DEFINE_MOCK_METHOD(cloneNode)

		VSL_CHECK_VALIDVALUE(deep);

		VSL_SET_VALIDVALUE_INTERFACE(cloneRoot);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeTypeStringValidValues
	{
		/*[retval,out]*/ BSTR* nodeType;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeTypeString)(
		/*[retval,out]*/ BSTR* nodeType)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeTypeString)

		VSL_SET_VALIDVALUE_BSTR(nodeType);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_textValidValues
	{
		/*[retval,out]*/ BSTR* text;
		HRESULT retValue;
	};

	STDMETHOD(get_text)(
		/*[retval,out]*/ BSTR* text)
	{
		VSL_DEFINE_MOCK_METHOD(get_text)

		VSL_SET_VALIDVALUE_BSTR(text);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_textValidValues
	{
		/*[in]*/ BSTR text;
		HRESULT retValue;
	};

	STDMETHOD(put_text)(
		/*[in]*/ BSTR text)
	{
		VSL_DEFINE_MOCK_METHOD(put_text)

		VSL_CHECK_VALIDVALUE_BSTR(text);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_specifiedValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* isSpecified;
		HRESULT retValue;
	};

	STDMETHOD(get_specified)(
		/*[out,retval]*/ VARIANT_BOOL* isSpecified)
	{
		VSL_DEFINE_MOCK_METHOD(get_specified)

		VSL_SET_VALIDVALUE(isSpecified);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_definitionValidValues
	{
		/*[retval,out]*/ IXMLDOMNode** definitionNode;
		HRESULT retValue;
	};

	STDMETHOD(get_definition)(
		/*[retval,out]*/ IXMLDOMNode** definitionNode)
	{
		VSL_DEFINE_MOCK_METHOD(get_definition)

		VSL_SET_VALIDVALUE_INTERFACE(definitionNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeTypedValueValidValues
	{
		/*[retval,out]*/ VARIANT* typedValue;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeTypedValue)(
		/*[retval,out]*/ VARIANT* typedValue)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeTypedValue)

		VSL_SET_VALIDVALUE_VARIANT(typedValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_nodeTypedValueValidValues
	{
		/*[in]*/ VARIANT typedValue;
		HRESULT retValue;
	};

	STDMETHOD(put_nodeTypedValue)(
		/*[in]*/ VARIANT typedValue)
	{
		VSL_DEFINE_MOCK_METHOD(put_nodeTypedValue)

		VSL_CHECK_VALIDVALUE(typedValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_dataTypeValidValues
	{
		/*[retval,out]*/ VARIANT* dataTypeName;
		HRESULT retValue;
	};

	STDMETHOD(get_dataType)(
		/*[retval,out]*/ VARIANT* dataTypeName)
	{
		VSL_DEFINE_MOCK_METHOD(get_dataType)

		VSL_SET_VALIDVALUE_VARIANT(dataTypeName);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_dataTypeValidValues
	{
		/*[in]*/ BSTR dataTypeName;
		HRESULT retValue;
	};

	STDMETHOD(put_dataType)(
		/*[in]*/ BSTR dataTypeName)
	{
		VSL_DEFINE_MOCK_METHOD(put_dataType)

		VSL_CHECK_VALIDVALUE_BSTR(dataTypeName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_xmlValidValues
	{
		/*[retval,out]*/ BSTR* xmlString;
		HRESULT retValue;
	};

	STDMETHOD(get_xml)(
		/*[retval,out]*/ BSTR* xmlString)
	{
		VSL_DEFINE_MOCK_METHOD(get_xml)

		VSL_SET_VALIDVALUE_BSTR(xmlString);

		VSL_RETURN_VALIDVALUES();
	}
	struct transformNodeValidValues
	{
		/*[in]*/ IXMLDOMNode* stylesheet;
		/*[retval,out]*/ BSTR* xmlString;
		HRESULT retValue;
	};

	STDMETHOD(transformNode)(
		/*[in]*/ IXMLDOMNode* stylesheet,
		/*[retval,out]*/ BSTR* xmlString)
	{
		VSL_DEFINE_MOCK_METHOD(transformNode)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(stylesheet);

		VSL_SET_VALIDVALUE_BSTR(xmlString);

		VSL_RETURN_VALIDVALUES();
	}
	struct selectNodesValidValues
	{
		/*[in]*/ BSTR queryString;
		/*[retval,out]*/ IXMLDOMNodeList** resultList;
		HRESULT retValue;
	};

	STDMETHOD(selectNodes)(
		/*[in]*/ BSTR queryString,
		/*[retval,out]*/ IXMLDOMNodeList** resultList)
	{
		VSL_DEFINE_MOCK_METHOD(selectNodes)

		VSL_CHECK_VALIDVALUE_BSTR(queryString);

		VSL_SET_VALIDVALUE_INTERFACE(resultList);

		VSL_RETURN_VALIDVALUES();
	}
	struct selectSingleNodeValidValues
	{
		/*[in]*/ BSTR queryString;
		/*[retval,out]*/ IXMLDOMNode** resultNode;
		HRESULT retValue;
	};

	STDMETHOD(selectSingleNode)(
		/*[in]*/ BSTR queryString,
		/*[retval,out]*/ IXMLDOMNode** resultNode)
	{
		VSL_DEFINE_MOCK_METHOD(selectSingleNode)

		VSL_CHECK_VALIDVALUE_BSTR(queryString);

		VSL_SET_VALIDVALUE_INTERFACE(resultNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_parsedValidValues
	{
		/*[retval,out]*/ VARIANT_BOOL* isParsed;
		HRESULT retValue;
	};

	STDMETHOD(get_parsed)(
		/*[retval,out]*/ VARIANT_BOOL* isParsed)
	{
		VSL_DEFINE_MOCK_METHOD(get_parsed)

		VSL_SET_VALIDVALUE(isParsed);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_namespaceURIValidValues
	{
		/*[retval,out]*/ BSTR* namespaceURI;
		HRESULT retValue;
	};

	STDMETHOD(get_namespaceURI)(
		/*[retval,out]*/ BSTR* namespaceURI)
	{
		VSL_DEFINE_MOCK_METHOD(get_namespaceURI)

		VSL_SET_VALIDVALUE_BSTR(namespaceURI);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_prefixValidValues
	{
		/*[retval,out]*/ BSTR* prefixString;
		HRESULT retValue;
	};

	STDMETHOD(get_prefix)(
		/*[retval,out]*/ BSTR* prefixString)
	{
		VSL_DEFINE_MOCK_METHOD(get_prefix)

		VSL_SET_VALIDVALUE_BSTR(prefixString);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_baseNameValidValues
	{
		/*[retval,out]*/ BSTR* nameString;
		HRESULT retValue;
	};

	STDMETHOD(get_baseName)(
		/*[retval,out]*/ BSTR* nameString)
	{
		VSL_DEFINE_MOCK_METHOD(get_baseName)

		VSL_SET_VALIDVALUE_BSTR(nameString);

		VSL_RETURN_VALIDVALUES();
	}
	struct transformNodeToObjectValidValues
	{
		/*[in]*/ IXMLDOMNode* stylesheet;
		/*[in]*/ VARIANT outputObject;
		HRESULT retValue;
	};

	STDMETHOD(transformNodeToObject)(
		/*[in]*/ IXMLDOMNode* stylesheet,
		/*[in]*/ VARIANT outputObject)
	{
		VSL_DEFINE_MOCK_METHOD(transformNodeToObject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(stylesheet);

		VSL_CHECK_VALIDVALUE(outputObject);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IXMLDOMCDATASECTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIXMLDOMDocument.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IXMLDOMDOCUMENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IXMLDOMDOCUMENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "XmlDom.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IXMLDOMDocumentNotImpl :
	public IXMLDOMDocument
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IXMLDOMDocumentNotImpl)

public:

	typedef IXMLDOMDocument Interface;

	STDMETHOD(get_doctype)(
		/*[out,retval]*/ IXMLDOMDocumentType** /*documentType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_implementation)(
		/*[out,retval]*/ IXMLDOMImplementation** /*impl*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_documentElement)(
		/*[out,retval]*/ IXMLDOMElement** /*DOMElement*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(putref_documentElement)(
		/*[in]*/ IXMLDOMElement* /*DOMElement*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(createElement)(
		/*[in]*/ BSTR /*tagName*/,
		/*[out,retval]*/ IXMLDOMElement** /*element*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(createDocumentFragment)(
		/*[out,retval]*/ IXMLDOMDocumentFragment** /*docFrag*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(createTextNode)(
		/*[in]*/ BSTR /*data*/,
		/*[out,retval]*/ IXMLDOMText** /*text*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(createComment)(
		/*[in]*/ BSTR /*data*/,
		/*[out,retval]*/ IXMLDOMComment** /*comment*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(createCDATASection)(
		/*[in]*/ BSTR /*data*/,
		/*[out,retval]*/ IXMLDOMCDATASection** /*cdata*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(createProcessingInstruction)(
		/*[in]*/ BSTR /*target*/,
		/*[in]*/ BSTR /*data*/,
		/*[out,retval]*/ IXMLDOMProcessingInstruction** /*pi*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(createAttribute)(
		/*[in]*/ BSTR /*name*/,
		/*[out,retval]*/ IXMLDOMAttribute** /*attribute*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(createEntityReference)(
		/*[in]*/ BSTR /*name*/,
		/*[out,retval]*/ IXMLDOMEntityReference** /*entityRef*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(getElementsByTagName)(
		/*[in]*/ BSTR /*tagName*/,
		/*[out,retval]*/ IXMLDOMNodeList** /*resultList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(createNode)(
		/*[in]*/ VARIANT /*Type*/,
		/*[in]*/ BSTR /*name*/,
		/*[in]*/ BSTR /*namespaceURI*/,
		/*[retval,out]*/ IXMLDOMNode** /*node*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(nodeFromID)(
		/*[in]*/ BSTR /*idString*/,
		/*[retval,out]*/ IXMLDOMNode** /*node*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(load)(
		/*[in]*/ VARIANT /*xmlSource*/,
		/*[out,retval]*/ VARIANT_BOOL* /*isSuccessful*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_readyState)(
		/*[retval,out]*/ long* /*value*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_parseError)(
		/*[retval,out]*/ IXMLDOMParseError** /*errorObj*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_url)(
		/*[retval,out]*/ BSTR* /*urlString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_async)(
		/*[retval,out]*/ VARIANT_BOOL* /*isAsync*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_async)(
		/*[in]*/ VARIANT_BOOL /*isAsync*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(abort)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(loadXML)(
		/*[in]*/ BSTR /*bstrXML*/,
		/*[out,retval]*/ VARIANT_BOOL* /*isSuccessful*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(save)(
		/*[in]*/ VARIANT /*desination*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_validateOnParse)(
		/*[retval,out]*/ VARIANT_BOOL* /*isValidating*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_validateOnParse)(
		/*[in]*/ VARIANT_BOOL /*isValidating*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_resolveExternals)(
		/*[retval,out]*/ VARIANT_BOOL* /*isResolving*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_resolveExternals)(
		/*[in]*/ VARIANT_BOOL /*isResolving*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_preserveWhiteSpace)(
		/*[retval,out]*/ VARIANT_BOOL* /*isPreserving*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_preserveWhiteSpace)(
		/*[in]*/ VARIANT_BOOL /*isPreserving*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_onreadystatechange)(
		/*[in]*/ VARIANT /*readystatechangeSink*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_ondataavailable)(
		/*[in]*/ VARIANT /*ondataavailableSink*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_ontransformnode)(
		/*[in]*/ VARIANT /*ontransformnodeSink*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeName)(
		/*[out,retval]*/ BSTR* /*name*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeValue)(
		/*[out,retval]*/ VARIANT* /*value*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_nodeValue)(
		/*[in]*/ VARIANT /*value*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeType)(
		/*[out,retval]*/ DOMNodeType* /*type*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_parentNode)(
		/*[out,retval]*/ IXMLDOMNode** /*parent*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_childNodes)(
		/*[out,retval]*/ IXMLDOMNodeList** /*childList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_firstChild)(
		/*[out,retval]*/ IXMLDOMNode** /*firstChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_lastChild)(
		/*[out,retval]*/ IXMLDOMNode** /*lastChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_previousSibling)(
		/*[out,retval]*/ IXMLDOMNode** /*previousSibling*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nextSibling)(
		/*[out,retval]*/ IXMLDOMNode** /*nextSibling*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_attributes)(
		/*[out,retval]*/ IXMLDOMNamedNodeMap** /*attributeMap*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(insertBefore)(
		/*[in]*/ IXMLDOMNode* /*newChild*/,
		/*[in]*/ VARIANT /*refChild*/,
		/*[out,retval]*/ IXMLDOMNode** /*outNewChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(replaceChild)(
		/*[in]*/ IXMLDOMNode* /*newChild*/,
		/*[in]*/ IXMLDOMNode* /*oldChild*/,
		/*[out,retval]*/ IXMLDOMNode** /*outOldChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(removeChild)(
		/*[in]*/ IXMLDOMNode* /*childNode*/,
		/*[out,retval]*/ IXMLDOMNode** /*oldChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(appendChild)(
		/*[in]*/ IXMLDOMNode* /*newChild*/,
		/*[out,retval]*/ IXMLDOMNode** /*outNewChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(hasChildNodes)(
		/*[out,retval]*/ VARIANT_BOOL* /*hasChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ownerDocument)(
		/*[out,retval]*/ IXMLDOMDocument** /*DOMDocument*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(cloneNode)(
		/*[in]*/ VARIANT_BOOL /*deep*/,
		/*[out,retval]*/ IXMLDOMNode** /*cloneRoot*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeTypeString)(
		/*[retval,out]*/ BSTR* /*nodeType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_text)(
		/*[retval,out]*/ BSTR* /*text*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_text)(
		/*[in]*/ BSTR /*text*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_specified)(
		/*[out,retval]*/ VARIANT_BOOL* /*isSpecified*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_definition)(
		/*[retval,out]*/ IXMLDOMNode** /*definitionNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeTypedValue)(
		/*[retval,out]*/ VARIANT* /*typedValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_nodeTypedValue)(
		/*[in]*/ VARIANT /*typedValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_dataType)(
		/*[retval,out]*/ VARIANT* /*dataTypeName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_dataType)(
		/*[in]*/ BSTR /*dataTypeName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_xml)(
		/*[retval,out]*/ BSTR* /*xmlString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(transformNode)(
		/*[in]*/ IXMLDOMNode* /*stylesheet*/,
		/*[retval,out]*/ BSTR* /*xmlString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(selectNodes)(
		/*[in]*/ BSTR /*queryString*/,
		/*[retval,out]*/ IXMLDOMNodeList** /*resultList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(selectSingleNode)(
		/*[in]*/ BSTR /*queryString*/,
		/*[retval,out]*/ IXMLDOMNode** /*resultNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_parsed)(
		/*[retval,out]*/ VARIANT_BOOL* /*isParsed*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_namespaceURI)(
		/*[retval,out]*/ BSTR* /*namespaceURI*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_prefix)(
		/*[retval,out]*/ BSTR* /*prefixString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_baseName)(
		/*[retval,out]*/ BSTR* /*nameString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(transformNodeToObject)(
		/*[in]*/ IXMLDOMNode* /*stylesheet*/,
		/*[in]*/ VARIANT /*outputObject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class IXMLDOMDocumentMockImpl :
	public IXMLDOMDocument,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IXMLDOMDocumentMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IXMLDOMDocumentMockImpl)

	typedef IXMLDOMDocument Interface;
	struct get_doctypeValidValues
	{
		/*[out,retval]*/ IXMLDOMDocumentType** documentType;
		HRESULT retValue;
	};

	STDMETHOD(get_doctype)(
		/*[out,retval]*/ IXMLDOMDocumentType** documentType)
	{
		VSL_DEFINE_MOCK_METHOD(get_doctype)

		VSL_SET_VALIDVALUE_INTERFACE(documentType);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_implementationValidValues
	{
		/*[out,retval]*/ IXMLDOMImplementation** impl;
		HRESULT retValue;
	};

	STDMETHOD(get_implementation)(
		/*[out,retval]*/ IXMLDOMImplementation** impl)
	{
		VSL_DEFINE_MOCK_METHOD(get_implementation)

		VSL_SET_VALIDVALUE_INTERFACE(impl);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_documentElementValidValues
	{
		/*[out,retval]*/ IXMLDOMElement** DOMElement;
		HRESULT retValue;
	};

	STDMETHOD(get_documentElement)(
		/*[out,retval]*/ IXMLDOMElement** DOMElement)
	{
		VSL_DEFINE_MOCK_METHOD(get_documentElement)

		VSL_SET_VALIDVALUE_INTERFACE(DOMElement);

		VSL_RETURN_VALIDVALUES();
	}
	struct putref_documentElementValidValues
	{
		/*[in]*/ IXMLDOMElement* DOMElement;
		HRESULT retValue;
	};

	STDMETHOD(putref_documentElement)(
		/*[in]*/ IXMLDOMElement* DOMElement)
	{
		VSL_DEFINE_MOCK_METHOD(putref_documentElement)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(DOMElement);

		VSL_RETURN_VALIDVALUES();
	}
	struct createElementValidValues
	{
		/*[in]*/ BSTR tagName;
		/*[out,retval]*/ IXMLDOMElement** element;
		HRESULT retValue;
	};

	STDMETHOD(createElement)(
		/*[in]*/ BSTR tagName,
		/*[out,retval]*/ IXMLDOMElement** element)
	{
		VSL_DEFINE_MOCK_METHOD(createElement)

		VSL_CHECK_VALIDVALUE_BSTR(tagName);

		VSL_SET_VALIDVALUE_INTERFACE(element);

		VSL_RETURN_VALIDVALUES();
	}
	struct createDocumentFragmentValidValues
	{
		/*[out,retval]*/ IXMLDOMDocumentFragment** docFrag;
		HRESULT retValue;
	};

	STDMETHOD(createDocumentFragment)(
		/*[out,retval]*/ IXMLDOMDocumentFragment** docFrag)
	{
		VSL_DEFINE_MOCK_METHOD(createDocumentFragment)

		VSL_SET_VALIDVALUE_INTERFACE(docFrag);

		VSL_RETURN_VALIDVALUES();
	}
	struct createTextNodeValidValues
	{
		/*[in]*/ BSTR data;
		/*[out,retval]*/ IXMLDOMText** text;
		HRESULT retValue;
	};

	STDMETHOD(createTextNode)(
		/*[in]*/ BSTR data,
		/*[out,retval]*/ IXMLDOMText** text)
	{
		VSL_DEFINE_MOCK_METHOD(createTextNode)

		VSL_CHECK_VALIDVALUE_BSTR(data);

		VSL_SET_VALIDVALUE_INTERFACE(text);

		VSL_RETURN_VALIDVALUES();
	}
	struct createCommentValidValues
	{
		/*[in]*/ BSTR data;
		/*[out,retval]*/ IXMLDOMComment** comment;
		HRESULT retValue;
	};

	STDMETHOD(createComment)(
		/*[in]*/ BSTR data,
		/*[out,retval]*/ IXMLDOMComment** comment)
	{
		VSL_DEFINE_MOCK_METHOD(createComment)

		VSL_CHECK_VALIDVALUE_BSTR(data);

		VSL_SET_VALIDVALUE_INTERFACE(comment);

		VSL_RETURN_VALIDVALUES();
	}
	struct createCDATASectionValidValues
	{
		/*[in]*/ BSTR data;
		/*[out,retval]*/ IXMLDOMCDATASection** cdata;
		HRESULT retValue;
	};

	STDMETHOD(createCDATASection)(
		/*[in]*/ BSTR data,
		/*[out,retval]*/ IXMLDOMCDATASection** cdata)
	{
		VSL_DEFINE_MOCK_METHOD(createCDATASection)

		VSL_CHECK_VALIDVALUE_BSTR(data);

		VSL_SET_VALIDVALUE_INTERFACE(cdata);

		VSL_RETURN_VALIDVALUES();
	}
	struct createProcessingInstructionValidValues
	{
		/*[in]*/ BSTR target;
		/*[in]*/ BSTR data;
		/*[out,retval]*/ IXMLDOMProcessingInstruction** pi;
		HRESULT retValue;
	};

	STDMETHOD(createProcessingInstruction)(
		/*[in]*/ BSTR target,
		/*[in]*/ BSTR data,
		/*[out,retval]*/ IXMLDOMProcessingInstruction** pi)
	{
		VSL_DEFINE_MOCK_METHOD(createProcessingInstruction)

		VSL_CHECK_VALIDVALUE_BSTR(target);

		VSL_CHECK_VALIDVALUE_BSTR(data);

		VSL_SET_VALIDVALUE_INTERFACE(pi);

		VSL_RETURN_VALIDVALUES();
	}
	struct createAttributeValidValues
	{
		/*[in]*/ BSTR name;
		/*[out,retval]*/ IXMLDOMAttribute** attribute;
		HRESULT retValue;
	};

	STDMETHOD(createAttribute)(
		/*[in]*/ BSTR name,
		/*[out,retval]*/ IXMLDOMAttribute** attribute)
	{
		VSL_DEFINE_MOCK_METHOD(createAttribute)

		VSL_CHECK_VALIDVALUE_BSTR(name);

		VSL_SET_VALIDVALUE_INTERFACE(attribute);

		VSL_RETURN_VALIDVALUES();
	}
	struct createEntityReferenceValidValues
	{
		/*[in]*/ BSTR name;
		/*[out,retval]*/ IXMLDOMEntityReference** entityRef;
		HRESULT retValue;
	};

	STDMETHOD(createEntityReference)(
		/*[in]*/ BSTR name,
		/*[out,retval]*/ IXMLDOMEntityReference** entityRef)
	{
		VSL_DEFINE_MOCK_METHOD(createEntityReference)

		VSL_CHECK_VALIDVALUE_BSTR(name);

		VSL_SET_VALIDVALUE_INTERFACE(entityRef);

		VSL_RETURN_VALIDVALUES();
	}
	struct getElementsByTagNameValidValues
	{
		/*[in]*/ BSTR tagName;
		/*[out,retval]*/ IXMLDOMNodeList** resultList;
		HRESULT retValue;
	};

	STDMETHOD(getElementsByTagName)(
		/*[in]*/ BSTR tagName,
		/*[out,retval]*/ IXMLDOMNodeList** resultList)
	{
		VSL_DEFINE_MOCK_METHOD(getElementsByTagName)

		VSL_CHECK_VALIDVALUE_BSTR(tagName);

		VSL_SET_VALIDVALUE_INTERFACE(resultList);

		VSL_RETURN_VALIDVALUES();
	}
	struct createNodeValidValues
	{
		/*[in]*/ VARIANT Type;
		/*[in]*/ BSTR name;
		/*[in]*/ BSTR namespaceURI;
		/*[retval,out]*/ IXMLDOMNode** node;
		HRESULT retValue;
	};

	STDMETHOD(createNode)(
		/*[in]*/ VARIANT Type,
		/*[in]*/ BSTR name,
		/*[in]*/ BSTR namespaceURI,
		/*[retval,out]*/ IXMLDOMNode** node)
	{
		VSL_DEFINE_MOCK_METHOD(createNode)

		VSL_CHECK_VALIDVALUE(Type);

		VSL_CHECK_VALIDVALUE_BSTR(name);

		VSL_CHECK_VALIDVALUE_BSTR(namespaceURI);

		VSL_SET_VALIDVALUE_INTERFACE(node);

		VSL_RETURN_VALIDVALUES();
	}
	struct nodeFromIDValidValues
	{
		/*[in]*/ BSTR idString;
		/*[retval,out]*/ IXMLDOMNode** node;
		HRESULT retValue;
	};

	STDMETHOD(nodeFromID)(
		/*[in]*/ BSTR idString,
		/*[retval,out]*/ IXMLDOMNode** node)
	{
		VSL_DEFINE_MOCK_METHOD(nodeFromID)

		VSL_CHECK_VALIDVALUE_BSTR(idString);

		VSL_SET_VALIDVALUE_INTERFACE(node);

		VSL_RETURN_VALIDVALUES();
	}
	struct loadValidValues
	{
		/*[in]*/ VARIANT xmlSource;
		/*[out,retval]*/ VARIANT_BOOL* isSuccessful;
		HRESULT retValue;
	};

	STDMETHOD(load)(
		/*[in]*/ VARIANT xmlSource,
		/*[out,retval]*/ VARIANT_BOOL* isSuccessful)
	{
		VSL_DEFINE_MOCK_METHOD(load)

		VSL_CHECK_VALIDVALUE(xmlSource);

		VSL_SET_VALIDVALUE(isSuccessful);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_readyStateValidValues
	{
		/*[retval,out]*/ long* value;
		HRESULT retValue;
	};

	STDMETHOD(get_readyState)(
		/*[retval,out]*/ long* value)
	{
		VSL_DEFINE_MOCK_METHOD(get_readyState)

		VSL_SET_VALIDVALUE(value);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_parseErrorValidValues
	{
		/*[retval,out]*/ IXMLDOMParseError** errorObj;
		HRESULT retValue;
	};

	STDMETHOD(get_parseError)(
		/*[retval,out]*/ IXMLDOMParseError** errorObj)
	{
		VSL_DEFINE_MOCK_METHOD(get_parseError)

		VSL_SET_VALIDVALUE_INTERFACE(errorObj);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_urlValidValues
	{
		/*[retval,out]*/ BSTR* urlString;
		HRESULT retValue;
	};

	STDMETHOD(get_url)(
		/*[retval,out]*/ BSTR* urlString)
	{
		VSL_DEFINE_MOCK_METHOD(get_url)

		VSL_SET_VALIDVALUE_BSTR(urlString);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_asyncValidValues
	{
		/*[retval,out]*/ VARIANT_BOOL* isAsync;
		HRESULT retValue;
	};

	STDMETHOD(get_async)(
		/*[retval,out]*/ VARIANT_BOOL* isAsync)
	{
		VSL_DEFINE_MOCK_METHOD(get_async)

		VSL_SET_VALIDVALUE(isAsync);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_asyncValidValues
	{
		/*[in]*/ VARIANT_BOOL isAsync;
		HRESULT retValue;
	};

	STDMETHOD(put_async)(
		/*[in]*/ VARIANT_BOOL isAsync)
	{
		VSL_DEFINE_MOCK_METHOD(put_async)

		VSL_CHECK_VALIDVALUE(isAsync);

		VSL_RETURN_VALIDVALUES();
	}
	struct abortValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(abort)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(abort)

		VSL_RETURN_VALIDVALUES();
	}
	struct loadXMLValidValues
	{
		/*[in]*/ BSTR bstrXML;
		/*[out,retval]*/ VARIANT_BOOL* isSuccessful;
		HRESULT retValue;
	};

	STDMETHOD(loadXML)(
		/*[in]*/ BSTR bstrXML,
		/*[out,retval]*/ VARIANT_BOOL* isSuccessful)
	{
		VSL_DEFINE_MOCK_METHOD(loadXML)

		VSL_CHECK_VALIDVALUE_BSTR(bstrXML);

		VSL_SET_VALIDVALUE(isSuccessful);

		VSL_RETURN_VALIDVALUES();
	}
	struct saveValidValues
	{
		/*[in]*/ VARIANT desination;
		HRESULT retValue;
	};

	STDMETHOD(save)(
		/*[in]*/ VARIANT desination)
	{
		VSL_DEFINE_MOCK_METHOD(save)

		VSL_CHECK_VALIDVALUE(desination);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_validateOnParseValidValues
	{
		/*[retval,out]*/ VARIANT_BOOL* isValidating;
		HRESULT retValue;
	};

	STDMETHOD(get_validateOnParse)(
		/*[retval,out]*/ VARIANT_BOOL* isValidating)
	{
		VSL_DEFINE_MOCK_METHOD(get_validateOnParse)

		VSL_SET_VALIDVALUE(isValidating);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_validateOnParseValidValues
	{
		/*[in]*/ VARIANT_BOOL isValidating;
		HRESULT retValue;
	};

	STDMETHOD(put_validateOnParse)(
		/*[in]*/ VARIANT_BOOL isValidating)
	{
		VSL_DEFINE_MOCK_METHOD(put_validateOnParse)

		VSL_CHECK_VALIDVALUE(isValidating);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_resolveExternalsValidValues
	{
		/*[retval,out]*/ VARIANT_BOOL* isResolving;
		HRESULT retValue;
	};

	STDMETHOD(get_resolveExternals)(
		/*[retval,out]*/ VARIANT_BOOL* isResolving)
	{
		VSL_DEFINE_MOCK_METHOD(get_resolveExternals)

		VSL_SET_VALIDVALUE(isResolving);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_resolveExternalsValidValues
	{
		/*[in]*/ VARIANT_BOOL isResolving;
		HRESULT retValue;
	};

	STDMETHOD(put_resolveExternals)(
		/*[in]*/ VARIANT_BOOL isResolving)
	{
		VSL_DEFINE_MOCK_METHOD(put_resolveExternals)

		VSL_CHECK_VALIDVALUE(isResolving);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_preserveWhiteSpaceValidValues
	{
		/*[retval,out]*/ VARIANT_BOOL* isPreserving;
		HRESULT retValue;
	};

	STDMETHOD(get_preserveWhiteSpace)(
		/*[retval,out]*/ VARIANT_BOOL* isPreserving)
	{
		VSL_DEFINE_MOCK_METHOD(get_preserveWhiteSpace)

		VSL_SET_VALIDVALUE(isPreserving);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_preserveWhiteSpaceValidValues
	{
		/*[in]*/ VARIANT_BOOL isPreserving;
		HRESULT retValue;
	};

	STDMETHOD(put_preserveWhiteSpace)(
		/*[in]*/ VARIANT_BOOL isPreserving)
	{
		VSL_DEFINE_MOCK_METHOD(put_preserveWhiteSpace)

		VSL_CHECK_VALIDVALUE(isPreserving);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_onreadystatechangeValidValues
	{
		/*[in]*/ VARIANT readystatechangeSink;
		HRESULT retValue;
	};

	STDMETHOD(put_onreadystatechange)(
		/*[in]*/ VARIANT readystatechangeSink)
	{
		VSL_DEFINE_MOCK_METHOD(put_onreadystatechange)

		VSL_CHECK_VALIDVALUE(readystatechangeSink);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_ondataavailableValidValues
	{
		/*[in]*/ VARIANT ondataavailableSink;
		HRESULT retValue;
	};

	STDMETHOD(put_ondataavailable)(
		/*[in]*/ VARIANT ondataavailableSink)
	{
		VSL_DEFINE_MOCK_METHOD(put_ondataavailable)

		VSL_CHECK_VALIDVALUE(ondataavailableSink);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_ontransformnodeValidValues
	{
		/*[in]*/ VARIANT ontransformnodeSink;
		HRESULT retValue;
	};

	STDMETHOD(put_ontransformnode)(
		/*[in]*/ VARIANT ontransformnodeSink)
	{
		VSL_DEFINE_MOCK_METHOD(put_ontransformnode)

		VSL_CHECK_VALIDVALUE(ontransformnodeSink);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeNameValidValues
	{
		/*[out,retval]*/ BSTR* name;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeName)(
		/*[out,retval]*/ BSTR* name)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeName)

		VSL_SET_VALIDVALUE_BSTR(name);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeValueValidValues
	{
		/*[out,retval]*/ VARIANT* value;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeValue)(
		/*[out,retval]*/ VARIANT* value)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeValue)

		VSL_SET_VALIDVALUE_VARIANT(value);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_nodeValueValidValues
	{
		/*[in]*/ VARIANT value;
		HRESULT retValue;
	};

	STDMETHOD(put_nodeValue)(
		/*[in]*/ VARIANT value)
	{
		VSL_DEFINE_MOCK_METHOD(put_nodeValue)

		VSL_CHECK_VALIDVALUE(value);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeTypeValidValues
	{
		/*[out,retval]*/ DOMNodeType* type;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeType)(
		/*[out,retval]*/ DOMNodeType* type)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeType)

		VSL_SET_VALIDVALUE(type);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_parentNodeValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** parent;
		HRESULT retValue;
	};

	STDMETHOD(get_parentNode)(
		/*[out,retval]*/ IXMLDOMNode** parent)
	{
		VSL_DEFINE_MOCK_METHOD(get_parentNode)

		VSL_SET_VALIDVALUE_INTERFACE(parent);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_childNodesValidValues
	{
		/*[out,retval]*/ IXMLDOMNodeList** childList;
		HRESULT retValue;
	};

	STDMETHOD(get_childNodes)(
		/*[out,retval]*/ IXMLDOMNodeList** childList)
	{
		VSL_DEFINE_MOCK_METHOD(get_childNodes)

		VSL_SET_VALIDVALUE_INTERFACE(childList);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_firstChildValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** firstChild;
		HRESULT retValue;
	};

	STDMETHOD(get_firstChild)(
		/*[out,retval]*/ IXMLDOMNode** firstChild)
	{
		VSL_DEFINE_MOCK_METHOD(get_firstChild)

		VSL_SET_VALIDVALUE_INTERFACE(firstChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_lastChildValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** lastChild;
		HRESULT retValue;
	};

	STDMETHOD(get_lastChild)(
		/*[out,retval]*/ IXMLDOMNode** lastChild)
	{
		VSL_DEFINE_MOCK_METHOD(get_lastChild)

		VSL_SET_VALIDVALUE_INTERFACE(lastChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_previousSiblingValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** previousSibling;
		HRESULT retValue;
	};

	STDMETHOD(get_previousSibling)(
		/*[out,retval]*/ IXMLDOMNode** previousSibling)
	{
		VSL_DEFINE_MOCK_METHOD(get_previousSibling)

		VSL_SET_VALIDVALUE_INTERFACE(previousSibling);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nextSiblingValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** nextSibling;
		HRESULT retValue;
	};

	STDMETHOD(get_nextSibling)(
		/*[out,retval]*/ IXMLDOMNode** nextSibling)
	{
		VSL_DEFINE_MOCK_METHOD(get_nextSibling)

		VSL_SET_VALIDVALUE_INTERFACE(nextSibling);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_attributesValidValues
	{
		/*[out,retval]*/ IXMLDOMNamedNodeMap** attributeMap;
		HRESULT retValue;
	};

	STDMETHOD(get_attributes)(
		/*[out,retval]*/ IXMLDOMNamedNodeMap** attributeMap)
	{
		VSL_DEFINE_MOCK_METHOD(get_attributes)

		VSL_SET_VALIDVALUE_INTERFACE(attributeMap);

		VSL_RETURN_VALIDVALUES();
	}
	struct insertBeforeValidValues
	{
		/*[in]*/ IXMLDOMNode* newChild;
		/*[in]*/ VARIANT refChild;
		/*[out,retval]*/ IXMLDOMNode** outNewChild;
		HRESULT retValue;
	};

	STDMETHOD(insertBefore)(
		/*[in]*/ IXMLDOMNode* newChild,
		/*[in]*/ VARIANT refChild,
		/*[out,retval]*/ IXMLDOMNode** outNewChild)
	{
		VSL_DEFINE_MOCK_METHOD(insertBefore)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(newChild);

		VSL_CHECK_VALIDVALUE(refChild);

		VSL_SET_VALIDVALUE_INTERFACE(outNewChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct replaceChildValidValues
	{
		/*[in]*/ IXMLDOMNode* newChild;
		/*[in]*/ IXMLDOMNode* oldChild;
		/*[out,retval]*/ IXMLDOMNode** outOldChild;
		HRESULT retValue;
	};

	STDMETHOD(replaceChild)(
		/*[in]*/ IXMLDOMNode* newChild,
		/*[in]*/ IXMLDOMNode* oldChild,
		/*[out,retval]*/ IXMLDOMNode** outOldChild)
	{
		VSL_DEFINE_MOCK_METHOD(replaceChild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(newChild);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(oldChild);

		VSL_SET_VALIDVALUE_INTERFACE(outOldChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct removeChildValidValues
	{
		/*[in]*/ IXMLDOMNode* childNode;
		/*[out,retval]*/ IXMLDOMNode** oldChild;
		HRESULT retValue;
	};

	STDMETHOD(removeChild)(
		/*[in]*/ IXMLDOMNode* childNode,
		/*[out,retval]*/ IXMLDOMNode** oldChild)
	{
		VSL_DEFINE_MOCK_METHOD(removeChild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(childNode);

		VSL_SET_VALIDVALUE_INTERFACE(oldChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct appendChildValidValues
	{
		/*[in]*/ IXMLDOMNode* newChild;
		/*[out,retval]*/ IXMLDOMNode** outNewChild;
		HRESULT retValue;
	};

	STDMETHOD(appendChild)(
		/*[in]*/ IXMLDOMNode* newChild,
		/*[out,retval]*/ IXMLDOMNode** outNewChild)
	{
		VSL_DEFINE_MOCK_METHOD(appendChild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(newChild);

		VSL_SET_VALIDVALUE_INTERFACE(outNewChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct hasChildNodesValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* hasChild;
		HRESULT retValue;
	};

	STDMETHOD(hasChildNodes)(
		/*[out,retval]*/ VARIANT_BOOL* hasChild)
	{
		VSL_DEFINE_MOCK_METHOD(hasChildNodes)

		VSL_SET_VALIDVALUE(hasChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ownerDocumentValidValues
	{
		/*[out,retval]*/ IXMLDOMDocument** DOMDocument;
		HRESULT retValue;
	};

	STDMETHOD(get_ownerDocument)(
		/*[out,retval]*/ IXMLDOMDocument** DOMDocument)
	{
		VSL_DEFINE_MOCK_METHOD(get_ownerDocument)

		VSL_SET_VALIDVALUE_INTERFACE(DOMDocument);

		VSL_RETURN_VALIDVALUES();
	}
	struct cloneNodeValidValues
	{
		/*[in]*/ VARIANT_BOOL deep;
		/*[out,retval]*/ IXMLDOMNode** cloneRoot;
		HRESULT retValue;
	};

	STDMETHOD(cloneNode)(
		/*[in]*/ VARIANT_BOOL deep,
		/*[out,retval]*/ IXMLDOMNode** cloneRoot)
	{
		VSL_DEFINE_MOCK_METHOD(cloneNode)

		VSL_CHECK_VALIDVALUE(deep);

		VSL_SET_VALIDVALUE_INTERFACE(cloneRoot);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeTypeStringValidValues
	{
		/*[retval,out]*/ BSTR* nodeType;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeTypeString)(
		/*[retval,out]*/ BSTR* nodeType)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeTypeString)

		VSL_SET_VALIDVALUE_BSTR(nodeType);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_textValidValues
	{
		/*[retval,out]*/ BSTR* text;
		HRESULT retValue;
	};

	STDMETHOD(get_text)(
		/*[retval,out]*/ BSTR* text)
	{
		VSL_DEFINE_MOCK_METHOD(get_text)

		VSL_SET_VALIDVALUE_BSTR(text);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_textValidValues
	{
		/*[in]*/ BSTR text;
		HRESULT retValue;
	};

	STDMETHOD(put_text)(
		/*[in]*/ BSTR text)
	{
		VSL_DEFINE_MOCK_METHOD(put_text)

		VSL_CHECK_VALIDVALUE_BSTR(text);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_specifiedValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* isSpecified;
		HRESULT retValue;
	};

	STDMETHOD(get_specified)(
		/*[out,retval]*/ VARIANT_BOOL* isSpecified)
	{
		VSL_DEFINE_MOCK_METHOD(get_specified)

		VSL_SET_VALIDVALUE(isSpecified);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_definitionValidValues
	{
		/*[retval,out]*/ IXMLDOMNode** definitionNode;
		HRESULT retValue;
	};

	STDMETHOD(get_definition)(
		/*[retval,out]*/ IXMLDOMNode** definitionNode)
	{
		VSL_DEFINE_MOCK_METHOD(get_definition)

		VSL_SET_VALIDVALUE_INTERFACE(definitionNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeTypedValueValidValues
	{
		/*[retval,out]*/ VARIANT* typedValue;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeTypedValue)(
		/*[retval,out]*/ VARIANT* typedValue)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeTypedValue)

		VSL_SET_VALIDVALUE_VARIANT(typedValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_nodeTypedValueValidValues
	{
		/*[in]*/ VARIANT typedValue;
		HRESULT retValue;
	};

	STDMETHOD(put_nodeTypedValue)(
		/*[in]*/ VARIANT typedValue)
	{
		VSL_DEFINE_MOCK_METHOD(put_nodeTypedValue)

		VSL_CHECK_VALIDVALUE(typedValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_dataTypeValidValues
	{
		/*[retval,out]*/ VARIANT* dataTypeName;
		HRESULT retValue;
	};

	STDMETHOD(get_dataType)(
		/*[retval,out]*/ VARIANT* dataTypeName)
	{
		VSL_DEFINE_MOCK_METHOD(get_dataType)

		VSL_SET_VALIDVALUE_VARIANT(dataTypeName);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_dataTypeValidValues
	{
		/*[in]*/ BSTR dataTypeName;
		HRESULT retValue;
	};

	STDMETHOD(put_dataType)(
		/*[in]*/ BSTR dataTypeName)
	{
		VSL_DEFINE_MOCK_METHOD(put_dataType)

		VSL_CHECK_VALIDVALUE_BSTR(dataTypeName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_xmlValidValues
	{
		/*[retval,out]*/ BSTR* xmlString;
		HRESULT retValue;
	};

	STDMETHOD(get_xml)(
		/*[retval,out]*/ BSTR* xmlString)
	{
		VSL_DEFINE_MOCK_METHOD(get_xml)

		VSL_SET_VALIDVALUE_BSTR(xmlString);

		VSL_RETURN_VALIDVALUES();
	}
	struct transformNodeValidValues
	{
		/*[in]*/ IXMLDOMNode* stylesheet;
		/*[retval,out]*/ BSTR* xmlString;
		HRESULT retValue;
	};

	STDMETHOD(transformNode)(
		/*[in]*/ IXMLDOMNode* stylesheet,
		/*[retval,out]*/ BSTR* xmlString)
	{
		VSL_DEFINE_MOCK_METHOD(transformNode)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(stylesheet);

		VSL_SET_VALIDVALUE_BSTR(xmlString);

		VSL_RETURN_VALIDVALUES();
	}
	struct selectNodesValidValues
	{
		/*[in]*/ BSTR queryString;
		/*[retval,out]*/ IXMLDOMNodeList** resultList;
		HRESULT retValue;
	};

	STDMETHOD(selectNodes)(
		/*[in]*/ BSTR queryString,
		/*[retval,out]*/ IXMLDOMNodeList** resultList)
	{
		VSL_DEFINE_MOCK_METHOD(selectNodes)

		VSL_CHECK_VALIDVALUE_BSTR(queryString);

		VSL_SET_VALIDVALUE_INTERFACE(resultList);

		VSL_RETURN_VALIDVALUES();
	}
	struct selectSingleNodeValidValues
	{
		/*[in]*/ BSTR queryString;
		/*[retval,out]*/ IXMLDOMNode** resultNode;
		HRESULT retValue;
	};

	STDMETHOD(selectSingleNode)(
		/*[in]*/ BSTR queryString,
		/*[retval,out]*/ IXMLDOMNode** resultNode)
	{
		VSL_DEFINE_MOCK_METHOD(selectSingleNode)

		VSL_CHECK_VALIDVALUE_BSTR(queryString);

		VSL_SET_VALIDVALUE_INTERFACE(resultNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_parsedValidValues
	{
		/*[retval,out]*/ VARIANT_BOOL* isParsed;
		HRESULT retValue;
	};

	STDMETHOD(get_parsed)(
		/*[retval,out]*/ VARIANT_BOOL* isParsed)
	{
		VSL_DEFINE_MOCK_METHOD(get_parsed)

		VSL_SET_VALIDVALUE(isParsed);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_namespaceURIValidValues
	{
		/*[retval,out]*/ BSTR* namespaceURI;
		HRESULT retValue;
	};

	STDMETHOD(get_namespaceURI)(
		/*[retval,out]*/ BSTR* namespaceURI)
	{
		VSL_DEFINE_MOCK_METHOD(get_namespaceURI)

		VSL_SET_VALIDVALUE_BSTR(namespaceURI);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_prefixValidValues
	{
		/*[retval,out]*/ BSTR* prefixString;
		HRESULT retValue;
	};

	STDMETHOD(get_prefix)(
		/*[retval,out]*/ BSTR* prefixString)
	{
		VSL_DEFINE_MOCK_METHOD(get_prefix)

		VSL_SET_VALIDVALUE_BSTR(prefixString);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_baseNameValidValues
	{
		/*[retval,out]*/ BSTR* nameString;
		HRESULT retValue;
	};

	STDMETHOD(get_baseName)(
		/*[retval,out]*/ BSTR* nameString)
	{
		VSL_DEFINE_MOCK_METHOD(get_baseName)

		VSL_SET_VALIDVALUE_BSTR(nameString);

		VSL_RETURN_VALIDVALUES();
	}
	struct transformNodeToObjectValidValues
	{
		/*[in]*/ IXMLDOMNode* stylesheet;
		/*[in]*/ VARIANT outputObject;
		HRESULT retValue;
	};

	STDMETHOD(transformNodeToObject)(
		/*[in]*/ IXMLDOMNode* stylesheet,
		/*[in]*/ VARIANT outputObject)
	{
		VSL_DEFINE_MOCK_METHOD(transformNodeToObject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(stylesheet);

		VSL_CHECK_VALIDVALUE(outputObject);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IXMLDOMDOCUMENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIXMLDOMDocumentType.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IXMLDOMDOCUMENTTYPE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IXMLDOMDOCUMENTTYPE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "XmlDom.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IXMLDOMDocumentTypeNotImpl :
	public IXMLDOMDocumentType
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IXMLDOMDocumentTypeNotImpl)

public:

	typedef IXMLDOMDocumentType Interface;

	STDMETHOD(get_name)(
		/*[out,retval]*/ BSTR* /*rootName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_entities)(
		/*[out,retval]*/ IXMLDOMNamedNodeMap** /*entityMap*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_notations)(
		/*[out,retval]*/ IXMLDOMNamedNodeMap** /*notationMap*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeName)(
		/*[out,retval]*/ BSTR* /*name*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeValue)(
		/*[out,retval]*/ VARIANT* /*value*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_nodeValue)(
		/*[in]*/ VARIANT /*value*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeType)(
		/*[out,retval]*/ DOMNodeType* /*type*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_parentNode)(
		/*[out,retval]*/ IXMLDOMNode** /*parent*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_childNodes)(
		/*[out,retval]*/ IXMLDOMNodeList** /*childList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_firstChild)(
		/*[out,retval]*/ IXMLDOMNode** /*firstChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_lastChild)(
		/*[out,retval]*/ IXMLDOMNode** /*lastChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_previousSibling)(
		/*[out,retval]*/ IXMLDOMNode** /*previousSibling*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nextSibling)(
		/*[out,retval]*/ IXMLDOMNode** /*nextSibling*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_attributes)(
		/*[out,retval]*/ IXMLDOMNamedNodeMap** /*attributeMap*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(insertBefore)(
		/*[in]*/ IXMLDOMNode* /*newChild*/,
		/*[in]*/ VARIANT /*refChild*/,
		/*[out,retval]*/ IXMLDOMNode** /*outNewChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(replaceChild)(
		/*[in]*/ IXMLDOMNode* /*newChild*/,
		/*[in]*/ IXMLDOMNode* /*oldChild*/,
		/*[out,retval]*/ IXMLDOMNode** /*outOldChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(removeChild)(
		/*[in]*/ IXMLDOMNode* /*childNode*/,
		/*[out,retval]*/ IXMLDOMNode** /*oldChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(appendChild)(
		/*[in]*/ IXMLDOMNode* /*newChild*/,
		/*[out,retval]*/ IXMLDOMNode** /*outNewChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(hasChildNodes)(
		/*[out,retval]*/ VARIANT_BOOL* /*hasChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ownerDocument)(
		/*[out,retval]*/ IXMLDOMDocument** /*DOMDocument*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(cloneNode)(
		/*[in]*/ VARIANT_BOOL /*deep*/,
		/*[out,retval]*/ IXMLDOMNode** /*cloneRoot*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeTypeString)(
		/*[retval,out]*/ BSTR* /*nodeType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_text)(
		/*[retval,out]*/ BSTR* /*text*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_text)(
		/*[in]*/ BSTR /*text*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_specified)(
		/*[out,retval]*/ VARIANT_BOOL* /*isSpecified*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_definition)(
		/*[retval,out]*/ IXMLDOMNode** /*definitionNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeTypedValue)(
		/*[retval,out]*/ VARIANT* /*typedValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_nodeTypedValue)(
		/*[in]*/ VARIANT /*typedValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_dataType)(
		/*[retval,out]*/ VARIANT* /*dataTypeName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_dataType)(
		/*[in]*/ BSTR /*dataTypeName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_xml)(
		/*[retval,out]*/ BSTR* /*xmlString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(transformNode)(
		/*[in]*/ IXMLDOMNode* /*stylesheet*/,
		/*[retval,out]*/ BSTR* /*xmlString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(selectNodes)(
		/*[in]*/ BSTR /*queryString*/,
		/*[retval,out]*/ IXMLDOMNodeList** /*resultList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(selectSingleNode)(
		/*[in]*/ BSTR /*queryString*/,
		/*[retval,out]*/ IXMLDOMNode** /*resultNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_parsed)(
		/*[retval,out]*/ VARIANT_BOOL* /*isParsed*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_namespaceURI)(
		/*[retval,out]*/ BSTR* /*namespaceURI*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_prefix)(
		/*[retval,out]*/ BSTR* /*prefixString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_baseName)(
		/*[retval,out]*/ BSTR* /*nameString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(transformNodeToObject)(
		/*[in]*/ IXMLDOMNode* /*stylesheet*/,
		/*[in]*/ VARIANT /*outputObject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class IXMLDOMDocumentTypeMockImpl :
	public IXMLDOMDocumentType,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IXMLDOMDocumentTypeMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IXMLDOMDocumentTypeMockImpl)

	typedef IXMLDOMDocumentType Interface;
	struct get_nameValidValues
	{
		/*[out,retval]*/ BSTR* rootName;
		HRESULT retValue;
	};

	STDMETHOD(get_name)(
		/*[out,retval]*/ BSTR* rootName)
	{
		VSL_DEFINE_MOCK_METHOD(get_name)

		VSL_SET_VALIDVALUE_BSTR(rootName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_entitiesValidValues
	{
		/*[out,retval]*/ IXMLDOMNamedNodeMap** entityMap;
		HRESULT retValue;
	};

	STDMETHOD(get_entities)(
		/*[out,retval]*/ IXMLDOMNamedNodeMap** entityMap)
	{
		VSL_DEFINE_MOCK_METHOD(get_entities)

		VSL_SET_VALIDVALUE_INTERFACE(entityMap);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_notationsValidValues
	{
		/*[out,retval]*/ IXMLDOMNamedNodeMap** notationMap;
		HRESULT retValue;
	};

	STDMETHOD(get_notations)(
		/*[out,retval]*/ IXMLDOMNamedNodeMap** notationMap)
	{
		VSL_DEFINE_MOCK_METHOD(get_notations)

		VSL_SET_VALIDVALUE_INTERFACE(notationMap);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeNameValidValues
	{
		/*[out,retval]*/ BSTR* name;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeName)(
		/*[out,retval]*/ BSTR* name)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeName)

		VSL_SET_VALIDVALUE_BSTR(name);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeValueValidValues
	{
		/*[out,retval]*/ VARIANT* value;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeValue)(
		/*[out,retval]*/ VARIANT* value)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeValue)

		VSL_SET_VALIDVALUE_VARIANT(value);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_nodeValueValidValues
	{
		/*[in]*/ VARIANT value;
		HRESULT retValue;
	};

	STDMETHOD(put_nodeValue)(
		/*[in]*/ VARIANT value)
	{
		VSL_DEFINE_MOCK_METHOD(put_nodeValue)

		VSL_CHECK_VALIDVALUE(value);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeTypeValidValues
	{
		/*[out,retval]*/ DOMNodeType* type;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeType)(
		/*[out,retval]*/ DOMNodeType* type)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeType)

		VSL_SET_VALIDVALUE(type);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_parentNodeValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** parent;
		HRESULT retValue;
	};

	STDMETHOD(get_parentNode)(
		/*[out,retval]*/ IXMLDOMNode** parent)
	{
		VSL_DEFINE_MOCK_METHOD(get_parentNode)

		VSL_SET_VALIDVALUE_INTERFACE(parent);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_childNodesValidValues
	{
		/*[out,retval]*/ IXMLDOMNodeList** childList;
		HRESULT retValue;
	};

	STDMETHOD(get_childNodes)(
		/*[out,retval]*/ IXMLDOMNodeList** childList)
	{
		VSL_DEFINE_MOCK_METHOD(get_childNodes)

		VSL_SET_VALIDVALUE_INTERFACE(childList);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_firstChildValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** firstChild;
		HRESULT retValue;
	};

	STDMETHOD(get_firstChild)(
		/*[out,retval]*/ IXMLDOMNode** firstChild)
	{
		VSL_DEFINE_MOCK_METHOD(get_firstChild)

		VSL_SET_VALIDVALUE_INTERFACE(firstChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_lastChildValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** lastChild;
		HRESULT retValue;
	};

	STDMETHOD(get_lastChild)(
		/*[out,retval]*/ IXMLDOMNode** lastChild)
	{
		VSL_DEFINE_MOCK_METHOD(get_lastChild)

		VSL_SET_VALIDVALUE_INTERFACE(lastChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_previousSiblingValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** previousSibling;
		HRESULT retValue;
	};

	STDMETHOD(get_previousSibling)(
		/*[out,retval]*/ IXMLDOMNode** previousSibling)
	{
		VSL_DEFINE_MOCK_METHOD(get_previousSibling)

		VSL_SET_VALIDVALUE_INTERFACE(previousSibling);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nextSiblingValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** nextSibling;
		HRESULT retValue;
	};

	STDMETHOD(get_nextSibling)(
		/*[out,retval]*/ IXMLDOMNode** nextSibling)
	{
		VSL_DEFINE_MOCK_METHOD(get_nextSibling)

		VSL_SET_VALIDVALUE_INTERFACE(nextSibling);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_attributesValidValues
	{
		/*[out,retval]*/ IXMLDOMNamedNodeMap** attributeMap;
		HRESULT retValue;
	};

	STDMETHOD(get_attributes)(
		/*[out,retval]*/ IXMLDOMNamedNodeMap** attributeMap)
	{
		VSL_DEFINE_MOCK_METHOD(get_attributes)

		VSL_SET_VALIDVALUE_INTERFACE(attributeMap);

		VSL_RETURN_VALIDVALUES();
	}
	struct insertBeforeValidValues
	{
		/*[in]*/ IXMLDOMNode* newChild;
		/*[in]*/ VARIANT refChild;
		/*[out,retval]*/ IXMLDOMNode** outNewChild;
		HRESULT retValue;
	};

	STDMETHOD(insertBefore)(
		/*[in]*/ IXMLDOMNode* newChild,
		/*[in]*/ VARIANT refChild,
		/*[out,retval]*/ IXMLDOMNode** outNewChild)
	{
		VSL_DEFINE_MOCK_METHOD(insertBefore)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(newChild);

		VSL_CHECK_VALIDVALUE(refChild);

		VSL_SET_VALIDVALUE_INTERFACE(outNewChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct replaceChildValidValues
	{
		/*[in]*/ IXMLDOMNode* newChild;
		/*[in]*/ IXMLDOMNode* oldChild;
		/*[out,retval]*/ IXMLDOMNode** outOldChild;
		HRESULT retValue;
	};

	STDMETHOD(replaceChild)(
		/*[in]*/ IXMLDOMNode* newChild,
		/*[in]*/ IXMLDOMNode* oldChild,
		/*[out,retval]*/ IXMLDOMNode** outOldChild)
	{
		VSL_DEFINE_MOCK_METHOD(replaceChild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(newChild);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(oldChild);

		VSL_SET_VALIDVALUE_INTERFACE(outOldChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct removeChildValidValues
	{
		/*[in]*/ IXMLDOMNode* childNode;
		/*[out,retval]*/ IXMLDOMNode** oldChild;
		HRESULT retValue;
	};

	STDMETHOD(removeChild)(
		/*[in]*/ IXMLDOMNode* childNode,
		/*[out,retval]*/ IXMLDOMNode** oldChild)
	{
		VSL_DEFINE_MOCK_METHOD(removeChild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(childNode);

		VSL_SET_VALIDVALUE_INTERFACE(oldChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct appendChildValidValues
	{
		/*[in]*/ IXMLDOMNode* newChild;
		/*[out,retval]*/ IXMLDOMNode** outNewChild;
		HRESULT retValue;
	};

	STDMETHOD(appendChild)(
		/*[in]*/ IXMLDOMNode* newChild,
		/*[out,retval]*/ IXMLDOMNode** outNewChild)
	{
		VSL_DEFINE_MOCK_METHOD(appendChild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(newChild);

		VSL_SET_VALIDVALUE_INTERFACE(outNewChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct hasChildNodesValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* hasChild;
		HRESULT retValue;
	};

	STDMETHOD(hasChildNodes)(
		/*[out,retval]*/ VARIANT_BOOL* hasChild)
	{
		VSL_DEFINE_MOCK_METHOD(hasChildNodes)

		VSL_SET_VALIDVALUE(hasChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ownerDocumentValidValues
	{
		/*[out,retval]*/ IXMLDOMDocument** DOMDocument;
		HRESULT retValue;
	};

	STDMETHOD(get_ownerDocument)(
		/*[out,retval]*/ IXMLDOMDocument** DOMDocument)
	{
		VSL_DEFINE_MOCK_METHOD(get_ownerDocument)

		VSL_SET_VALIDVALUE_INTERFACE(DOMDocument);

		VSL_RETURN_VALIDVALUES();
	}
	struct cloneNodeValidValues
	{
		/*[in]*/ VARIANT_BOOL deep;
		/*[out,retval]*/ IXMLDOMNode** cloneRoot;
		HRESULT retValue;
	};

	STDMETHOD(cloneNode)(
		/*[in]*/ VARIANT_BOOL deep,
		/*[out,retval]*/ IXMLDOMNode** cloneRoot)
	{
		VSL_DEFINE_MOCK_METHOD(cloneNode)

		VSL_CHECK_VALIDVALUE(deep);

		VSL_SET_VALIDVALUE_INTERFACE(cloneRoot);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeTypeStringValidValues
	{
		/*[retval,out]*/ BSTR* nodeType;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeTypeString)(
		/*[retval,out]*/ BSTR* nodeType)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeTypeString)

		VSL_SET_VALIDVALUE_BSTR(nodeType);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_textValidValues
	{
		/*[retval,out]*/ BSTR* text;
		HRESULT retValue;
	};

	STDMETHOD(get_text)(
		/*[retval,out]*/ BSTR* text)
	{
		VSL_DEFINE_MOCK_METHOD(get_text)

		VSL_SET_VALIDVALUE_BSTR(text);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_textValidValues
	{
		/*[in]*/ BSTR text;
		HRESULT retValue;
	};

	STDMETHOD(put_text)(
		/*[in]*/ BSTR text)
	{
		VSL_DEFINE_MOCK_METHOD(put_text)

		VSL_CHECK_VALIDVALUE_BSTR(text);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_specifiedValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* isSpecified;
		HRESULT retValue;
	};

	STDMETHOD(get_specified)(
		/*[out,retval]*/ VARIANT_BOOL* isSpecified)
	{
		VSL_DEFINE_MOCK_METHOD(get_specified)

		VSL_SET_VALIDVALUE(isSpecified);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_definitionValidValues
	{
		/*[retval,out]*/ IXMLDOMNode** definitionNode;
		HRESULT retValue;
	};

	STDMETHOD(get_definition)(
		/*[retval,out]*/ IXMLDOMNode** definitionNode)
	{
		VSL_DEFINE_MOCK_METHOD(get_definition)

		VSL_SET_VALIDVALUE_INTERFACE(definitionNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeTypedValueValidValues
	{
		/*[retval,out]*/ VARIANT* typedValue;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeTypedValue)(
		/*[retval,out]*/ VARIANT* typedValue)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeTypedValue)

		VSL_SET_VALIDVALUE_VARIANT(typedValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_nodeTypedValueValidValues
	{
		/*[in]*/ VARIANT typedValue;
		HRESULT retValue;
	};

	STDMETHOD(put_nodeTypedValue)(
		/*[in]*/ VARIANT typedValue)
	{
		VSL_DEFINE_MOCK_METHOD(put_nodeTypedValue)

		VSL_CHECK_VALIDVALUE(typedValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_dataTypeValidValues
	{
		/*[retval,out]*/ VARIANT* dataTypeName;
		HRESULT retValue;
	};

	STDMETHOD(get_dataType)(
		/*[retval,out]*/ VARIANT* dataTypeName)
	{
		VSL_DEFINE_MOCK_METHOD(get_dataType)

		VSL_SET_VALIDVALUE_VARIANT(dataTypeName);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_dataTypeValidValues
	{
		/*[in]*/ BSTR dataTypeName;
		HRESULT retValue;
	};

	STDMETHOD(put_dataType)(
		/*[in]*/ BSTR dataTypeName)
	{
		VSL_DEFINE_MOCK_METHOD(put_dataType)

		VSL_CHECK_VALIDVALUE_BSTR(dataTypeName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_xmlValidValues
	{
		/*[retval,out]*/ BSTR* xmlString;
		HRESULT retValue;
	};

	STDMETHOD(get_xml)(
		/*[retval,out]*/ BSTR* xmlString)
	{
		VSL_DEFINE_MOCK_METHOD(get_xml)

		VSL_SET_VALIDVALUE_BSTR(xmlString);

		VSL_RETURN_VALIDVALUES();
	}
	struct transformNodeValidValues
	{
		/*[in]*/ IXMLDOMNode* stylesheet;
		/*[retval,out]*/ BSTR* xmlString;
		HRESULT retValue;
	};

	STDMETHOD(transformNode)(
		/*[in]*/ IXMLDOMNode* stylesheet,
		/*[retval,out]*/ BSTR* xmlString)
	{
		VSL_DEFINE_MOCK_METHOD(transformNode)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(stylesheet);

		VSL_SET_VALIDVALUE_BSTR(xmlString);

		VSL_RETURN_VALIDVALUES();
	}
	struct selectNodesValidValues
	{
		/*[in]*/ BSTR queryString;
		/*[retval,out]*/ IXMLDOMNodeList** resultList;
		HRESULT retValue;
	};

	STDMETHOD(selectNodes)(
		/*[in]*/ BSTR queryString,
		/*[retval,out]*/ IXMLDOMNodeList** resultList)
	{
		VSL_DEFINE_MOCK_METHOD(selectNodes)

		VSL_CHECK_VALIDVALUE_BSTR(queryString);

		VSL_SET_VALIDVALUE_INTERFACE(resultList);

		VSL_RETURN_VALIDVALUES();
	}
	struct selectSingleNodeValidValues
	{
		/*[in]*/ BSTR queryString;
		/*[retval,out]*/ IXMLDOMNode** resultNode;
		HRESULT retValue;
	};

	STDMETHOD(selectSingleNode)(
		/*[in]*/ BSTR queryString,
		/*[retval,out]*/ IXMLDOMNode** resultNode)
	{
		VSL_DEFINE_MOCK_METHOD(selectSingleNode)

		VSL_CHECK_VALIDVALUE_BSTR(queryString);

		VSL_SET_VALIDVALUE_INTERFACE(resultNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_parsedValidValues
	{
		/*[retval,out]*/ VARIANT_BOOL* isParsed;
		HRESULT retValue;
	};

	STDMETHOD(get_parsed)(
		/*[retval,out]*/ VARIANT_BOOL* isParsed)
	{
		VSL_DEFINE_MOCK_METHOD(get_parsed)

		VSL_SET_VALIDVALUE(isParsed);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_namespaceURIValidValues
	{
		/*[retval,out]*/ BSTR* namespaceURI;
		HRESULT retValue;
	};

	STDMETHOD(get_namespaceURI)(
		/*[retval,out]*/ BSTR* namespaceURI)
	{
		VSL_DEFINE_MOCK_METHOD(get_namespaceURI)

		VSL_SET_VALIDVALUE_BSTR(namespaceURI);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_prefixValidValues
	{
		/*[retval,out]*/ BSTR* prefixString;
		HRESULT retValue;
	};

	STDMETHOD(get_prefix)(
		/*[retval,out]*/ BSTR* prefixString)
	{
		VSL_DEFINE_MOCK_METHOD(get_prefix)

		VSL_SET_VALIDVALUE_BSTR(prefixString);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_baseNameValidValues
	{
		/*[retval,out]*/ BSTR* nameString;
		HRESULT retValue;
	};

	STDMETHOD(get_baseName)(
		/*[retval,out]*/ BSTR* nameString)
	{
		VSL_DEFINE_MOCK_METHOD(get_baseName)

		VSL_SET_VALIDVALUE_BSTR(nameString);

		VSL_RETURN_VALIDVALUES();
	}
	struct transformNodeToObjectValidValues
	{
		/*[in]*/ IXMLDOMNode* stylesheet;
		/*[in]*/ VARIANT outputObject;
		HRESULT retValue;
	};

	STDMETHOD(transformNodeToObject)(
		/*[in]*/ IXMLDOMNode* stylesheet,
		/*[in]*/ VARIANT outputObject)
	{
		VSL_DEFINE_MOCK_METHOD(transformNodeToObject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(stylesheet);

		VSL_CHECK_VALIDVALUE(outputObject);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IXMLDOMDOCUMENTTYPE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIXMLDOMCharacterData.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IXMLDOMCHARACTERDATA_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IXMLDOMCHARACTERDATA_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "XmlDom.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IXMLDOMCharacterDataNotImpl :
	public IXMLDOMCharacterData
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IXMLDOMCharacterDataNotImpl)

public:

	typedef IXMLDOMCharacterData Interface;

	STDMETHOD(get_data)(
		/*[out,retval]*/ BSTR* /*data*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_data)(
		/*[in]*/ BSTR /*data*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_length)(
		/*[out,retval]*/ long* /*dataLength*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(substringData)(
		/*[in]*/ long /*offset*/,
		/*[in]*/ long /*count*/,
		/*[out,retval]*/ BSTR* /*data*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(appendData)(
		/*[in]*/ BSTR /*data*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(insertData)(
		/*[in]*/ long /*offset*/,
		/*[in]*/ BSTR /*data*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(deleteData)(
		/*[in]*/ long /*offset*/,
		/*[in]*/ long /*count*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(replaceData)(
		/*[in]*/ long /*offset*/,
		/*[in]*/ long /*count*/,
		/*[in]*/ BSTR /*data*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeName)(
		/*[out,retval]*/ BSTR* /*name*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeValue)(
		/*[out,retval]*/ VARIANT* /*value*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_nodeValue)(
		/*[in]*/ VARIANT /*value*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeType)(
		/*[out,retval]*/ DOMNodeType* /*type*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_parentNode)(
		/*[out,retval]*/ IXMLDOMNode** /*parent*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_childNodes)(
		/*[out,retval]*/ IXMLDOMNodeList** /*childList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_firstChild)(
		/*[out,retval]*/ IXMLDOMNode** /*firstChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_lastChild)(
		/*[out,retval]*/ IXMLDOMNode** /*lastChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_previousSibling)(
		/*[out,retval]*/ IXMLDOMNode** /*previousSibling*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nextSibling)(
		/*[out,retval]*/ IXMLDOMNode** /*nextSibling*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_attributes)(
		/*[out,retval]*/ IXMLDOMNamedNodeMap** /*attributeMap*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(insertBefore)(
		/*[in]*/ IXMLDOMNode* /*newChild*/,
		/*[in]*/ VARIANT /*refChild*/,
		/*[out,retval]*/ IXMLDOMNode** /*outNewChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(replaceChild)(
		/*[in]*/ IXMLDOMNode* /*newChild*/,
		/*[in]*/ IXMLDOMNode* /*oldChild*/,
		/*[out,retval]*/ IXMLDOMNode** /*outOldChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(removeChild)(
		/*[in]*/ IXMLDOMNode* /*childNode*/,
		/*[out,retval]*/ IXMLDOMNode** /*oldChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(appendChild)(
		/*[in]*/ IXMLDOMNode* /*newChild*/,
		/*[out,retval]*/ IXMLDOMNode** /*outNewChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(hasChildNodes)(
		/*[out,retval]*/ VARIANT_BOOL* /*hasChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ownerDocument)(
		/*[out,retval]*/ IXMLDOMDocument** /*DOMDocument*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(cloneNode)(
		/*[in]*/ VARIANT_BOOL /*deep*/,
		/*[out,retval]*/ IXMLDOMNode** /*cloneRoot*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeTypeString)(
		/*[retval,out]*/ BSTR* /*nodeType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_text)(
		/*[retval,out]*/ BSTR* /*text*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_text)(
		/*[in]*/ BSTR /*text*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_specified)(
		/*[out,retval]*/ VARIANT_BOOL* /*isSpecified*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_definition)(
		/*[retval,out]*/ IXMLDOMNode** /*definitionNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeTypedValue)(
		/*[retval,out]*/ VARIANT* /*typedValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_nodeTypedValue)(
		/*[in]*/ VARIANT /*typedValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_dataType)(
		/*[retval,out]*/ VARIANT* /*dataTypeName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_dataType)(
		/*[in]*/ BSTR /*dataTypeName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_xml)(
		/*[retval,out]*/ BSTR* /*xmlString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(transformNode)(
		/*[in]*/ IXMLDOMNode* /*stylesheet*/,
		/*[retval,out]*/ BSTR* /*xmlString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(selectNodes)(
		/*[in]*/ BSTR /*queryString*/,
		/*[retval,out]*/ IXMLDOMNodeList** /*resultList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(selectSingleNode)(
		/*[in]*/ BSTR /*queryString*/,
		/*[retval,out]*/ IXMLDOMNode** /*resultNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_parsed)(
		/*[retval,out]*/ VARIANT_BOOL* /*isParsed*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_namespaceURI)(
		/*[retval,out]*/ BSTR* /*namespaceURI*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_prefix)(
		/*[retval,out]*/ BSTR* /*prefixString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_baseName)(
		/*[retval,out]*/ BSTR* /*nameString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(transformNodeToObject)(
		/*[in]*/ IXMLDOMNode* /*stylesheet*/,
		/*[in]*/ VARIANT /*outputObject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class IXMLDOMCharacterDataMockImpl :
	public IXMLDOMCharacterData,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IXMLDOMCharacterDataMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IXMLDOMCharacterDataMockImpl)

	typedef IXMLDOMCharacterData Interface;
	struct get_dataValidValues
	{
		/*[out,retval]*/ BSTR* data;
		HRESULT retValue;
	};

	STDMETHOD(get_data)(
		/*[out,retval]*/ BSTR* data)
	{
		VSL_DEFINE_MOCK_METHOD(get_data)

		VSL_SET_VALIDVALUE_BSTR(data);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_dataValidValues
	{
		/*[in]*/ BSTR data;
		HRESULT retValue;
	};

	STDMETHOD(put_data)(
		/*[in]*/ BSTR data)
	{
		VSL_DEFINE_MOCK_METHOD(put_data)

		VSL_CHECK_VALIDVALUE_BSTR(data);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_lengthValidValues
	{
		/*[out,retval]*/ long* dataLength;
		HRESULT retValue;
	};

	STDMETHOD(get_length)(
		/*[out,retval]*/ long* dataLength)
	{
		VSL_DEFINE_MOCK_METHOD(get_length)

		VSL_SET_VALIDVALUE(dataLength);

		VSL_RETURN_VALIDVALUES();
	}
	struct substringDataValidValues
	{
		/*[in]*/ long offset;
		/*[in]*/ long count;
		/*[out,retval]*/ BSTR* data;
		HRESULT retValue;
	};

	STDMETHOD(substringData)(
		/*[in]*/ long offset,
		/*[in]*/ long count,
		/*[out,retval]*/ BSTR* data)
	{
		VSL_DEFINE_MOCK_METHOD(substringData)

		VSL_CHECK_VALIDVALUE(offset);

		VSL_CHECK_VALIDVALUE(count);

		VSL_SET_VALIDVALUE_BSTR(data);

		VSL_RETURN_VALIDVALUES();
	}
	struct appendDataValidValues
	{
		/*[in]*/ BSTR data;
		HRESULT retValue;
	};

	STDMETHOD(appendData)(
		/*[in]*/ BSTR data)
	{
		VSL_DEFINE_MOCK_METHOD(appendData)

		VSL_CHECK_VALIDVALUE_BSTR(data);

		VSL_RETURN_VALIDVALUES();
	}
	struct insertDataValidValues
	{
		/*[in]*/ long offset;
		/*[in]*/ BSTR data;
		HRESULT retValue;
	};

	STDMETHOD(insertData)(
		/*[in]*/ long offset,
		/*[in]*/ BSTR data)
	{
		VSL_DEFINE_MOCK_METHOD(insertData)

		VSL_CHECK_VALIDVALUE(offset);

		VSL_CHECK_VALIDVALUE_BSTR(data);

		VSL_RETURN_VALIDVALUES();
	}
	struct deleteDataValidValues
	{
		/*[in]*/ long offset;
		/*[in]*/ long count;
		HRESULT retValue;
	};

	STDMETHOD(deleteData)(
		/*[in]*/ long offset,
		/*[in]*/ long count)
	{
		VSL_DEFINE_MOCK_METHOD(deleteData)

		VSL_CHECK_VALIDVALUE(offset);

		VSL_CHECK_VALIDVALUE(count);

		VSL_RETURN_VALIDVALUES();
	}
	struct replaceDataValidValues
	{
		/*[in]*/ long offset;
		/*[in]*/ long count;
		/*[in]*/ BSTR data;
		HRESULT retValue;
	};

	STDMETHOD(replaceData)(
		/*[in]*/ long offset,
		/*[in]*/ long count,
		/*[in]*/ BSTR data)
	{
		VSL_DEFINE_MOCK_METHOD(replaceData)

		VSL_CHECK_VALIDVALUE(offset);

		VSL_CHECK_VALIDVALUE(count);

		VSL_CHECK_VALIDVALUE_BSTR(data);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeNameValidValues
	{
		/*[out,retval]*/ BSTR* name;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeName)(
		/*[out,retval]*/ BSTR* name)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeName)

		VSL_SET_VALIDVALUE_BSTR(name);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeValueValidValues
	{
		/*[out,retval]*/ VARIANT* value;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeValue)(
		/*[out,retval]*/ VARIANT* value)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeValue)

		VSL_SET_VALIDVALUE_VARIANT(value);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_nodeValueValidValues
	{
		/*[in]*/ VARIANT value;
		HRESULT retValue;
	};

	STDMETHOD(put_nodeValue)(
		/*[in]*/ VARIANT value)
	{
		VSL_DEFINE_MOCK_METHOD(put_nodeValue)

		VSL_CHECK_VALIDVALUE(value);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeTypeValidValues
	{
		/*[out,retval]*/ DOMNodeType* type;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeType)(
		/*[out,retval]*/ DOMNodeType* type)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeType)

		VSL_SET_VALIDVALUE(type);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_parentNodeValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** parent;
		HRESULT retValue;
	};

	STDMETHOD(get_parentNode)(
		/*[out,retval]*/ IXMLDOMNode** parent)
	{
		VSL_DEFINE_MOCK_METHOD(get_parentNode)

		VSL_SET_VALIDVALUE_INTERFACE(parent);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_childNodesValidValues
	{
		/*[out,retval]*/ IXMLDOMNodeList** childList;
		HRESULT retValue;
	};

	STDMETHOD(get_childNodes)(
		/*[out,retval]*/ IXMLDOMNodeList** childList)
	{
		VSL_DEFINE_MOCK_METHOD(get_childNodes)

		VSL_SET_VALIDVALUE_INTERFACE(childList);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_firstChildValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** firstChild;
		HRESULT retValue;
	};

	STDMETHOD(get_firstChild)(
		/*[out,retval]*/ IXMLDOMNode** firstChild)
	{
		VSL_DEFINE_MOCK_METHOD(get_firstChild)

		VSL_SET_VALIDVALUE_INTERFACE(firstChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_lastChildValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** lastChild;
		HRESULT retValue;
	};

	STDMETHOD(get_lastChild)(
		/*[out,retval]*/ IXMLDOMNode** lastChild)
	{
		VSL_DEFINE_MOCK_METHOD(get_lastChild)

		VSL_SET_VALIDVALUE_INTERFACE(lastChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_previousSiblingValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** previousSibling;
		HRESULT retValue;
	};

	STDMETHOD(get_previousSibling)(
		/*[out,retval]*/ IXMLDOMNode** previousSibling)
	{
		VSL_DEFINE_MOCK_METHOD(get_previousSibling)

		VSL_SET_VALIDVALUE_INTERFACE(previousSibling);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nextSiblingValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** nextSibling;
		HRESULT retValue;
	};

	STDMETHOD(get_nextSibling)(
		/*[out,retval]*/ IXMLDOMNode** nextSibling)
	{
		VSL_DEFINE_MOCK_METHOD(get_nextSibling)

		VSL_SET_VALIDVALUE_INTERFACE(nextSibling);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_attributesValidValues
	{
		/*[out,retval]*/ IXMLDOMNamedNodeMap** attributeMap;
		HRESULT retValue;
	};

	STDMETHOD(get_attributes)(
		/*[out,retval]*/ IXMLDOMNamedNodeMap** attributeMap)
	{
		VSL_DEFINE_MOCK_METHOD(get_attributes)

		VSL_SET_VALIDVALUE_INTERFACE(attributeMap);

		VSL_RETURN_VALIDVALUES();
	}
	struct insertBeforeValidValues
	{
		/*[in]*/ IXMLDOMNode* newChild;
		/*[in]*/ VARIANT refChild;
		/*[out,retval]*/ IXMLDOMNode** outNewChild;
		HRESULT retValue;
	};

	STDMETHOD(insertBefore)(
		/*[in]*/ IXMLDOMNode* newChild,
		/*[in]*/ VARIANT refChild,
		/*[out,retval]*/ IXMLDOMNode** outNewChild)
	{
		VSL_DEFINE_MOCK_METHOD(insertBefore)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(newChild);

		VSL_CHECK_VALIDVALUE(refChild);

		VSL_SET_VALIDVALUE_INTERFACE(outNewChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct replaceChildValidValues
	{
		/*[in]*/ IXMLDOMNode* newChild;
		/*[in]*/ IXMLDOMNode* oldChild;
		/*[out,retval]*/ IXMLDOMNode** outOldChild;
		HRESULT retValue;
	};

	STDMETHOD(replaceChild)(
		/*[in]*/ IXMLDOMNode* newChild,
		/*[in]*/ IXMLDOMNode* oldChild,
		/*[out,retval]*/ IXMLDOMNode** outOldChild)
	{
		VSL_DEFINE_MOCK_METHOD(replaceChild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(newChild);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(oldChild);

		VSL_SET_VALIDVALUE_INTERFACE(outOldChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct removeChildValidValues
	{
		/*[in]*/ IXMLDOMNode* childNode;
		/*[out,retval]*/ IXMLDOMNode** oldChild;
		HRESULT retValue;
	};

	STDMETHOD(removeChild)(
		/*[in]*/ IXMLDOMNode* childNode,
		/*[out,retval]*/ IXMLDOMNode** oldChild)
	{
		VSL_DEFINE_MOCK_METHOD(removeChild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(childNode);

		VSL_SET_VALIDVALUE_INTERFACE(oldChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct appendChildValidValues
	{
		/*[in]*/ IXMLDOMNode* newChild;
		/*[out,retval]*/ IXMLDOMNode** outNewChild;
		HRESULT retValue;
	};

	STDMETHOD(appendChild)(
		/*[in]*/ IXMLDOMNode* newChild,
		/*[out,retval]*/ IXMLDOMNode** outNewChild)
	{
		VSL_DEFINE_MOCK_METHOD(appendChild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(newChild);

		VSL_SET_VALIDVALUE_INTERFACE(outNewChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct hasChildNodesValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* hasChild;
		HRESULT retValue;
	};

	STDMETHOD(hasChildNodes)(
		/*[out,retval]*/ VARIANT_BOOL* hasChild)
	{
		VSL_DEFINE_MOCK_METHOD(hasChildNodes)

		VSL_SET_VALIDVALUE(hasChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ownerDocumentValidValues
	{
		/*[out,retval]*/ IXMLDOMDocument** DOMDocument;
		HRESULT retValue;
	};

	STDMETHOD(get_ownerDocument)(
		/*[out,retval]*/ IXMLDOMDocument** DOMDocument)
	{
		VSL_DEFINE_MOCK_METHOD(get_ownerDocument)

		VSL_SET_VALIDVALUE_INTERFACE(DOMDocument);

		VSL_RETURN_VALIDVALUES();
	}
	struct cloneNodeValidValues
	{
		/*[in]*/ VARIANT_BOOL deep;
		/*[out,retval]*/ IXMLDOMNode** cloneRoot;
		HRESULT retValue;
	};

	STDMETHOD(cloneNode)(
		/*[in]*/ VARIANT_BOOL deep,
		/*[out,retval]*/ IXMLDOMNode** cloneRoot)
	{
		VSL_DEFINE_MOCK_METHOD(cloneNode)

		VSL_CHECK_VALIDVALUE(deep);

		VSL_SET_VALIDVALUE_INTERFACE(cloneRoot);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeTypeStringValidValues
	{
		/*[retval,out]*/ BSTR* nodeType;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeTypeString)(
		/*[retval,out]*/ BSTR* nodeType)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeTypeString)

		VSL_SET_VALIDVALUE_BSTR(nodeType);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_textValidValues
	{
		/*[retval,out]*/ BSTR* text;
		HRESULT retValue;
	};

	STDMETHOD(get_text)(
		/*[retval,out]*/ BSTR* text)
	{
		VSL_DEFINE_MOCK_METHOD(get_text)

		VSL_SET_VALIDVALUE_BSTR(text);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_textValidValues
	{
		/*[in]*/ BSTR text;
		HRESULT retValue;
	};

	STDMETHOD(put_text)(
		/*[in]*/ BSTR text)
	{
		VSL_DEFINE_MOCK_METHOD(put_text)

		VSL_CHECK_VALIDVALUE_BSTR(text);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_specifiedValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* isSpecified;
		HRESULT retValue;
	};

	STDMETHOD(get_specified)(
		/*[out,retval]*/ VARIANT_BOOL* isSpecified)
	{
		VSL_DEFINE_MOCK_METHOD(get_specified)

		VSL_SET_VALIDVALUE(isSpecified);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_definitionValidValues
	{
		/*[retval,out]*/ IXMLDOMNode** definitionNode;
		HRESULT retValue;
	};

	STDMETHOD(get_definition)(
		/*[retval,out]*/ IXMLDOMNode** definitionNode)
	{
		VSL_DEFINE_MOCK_METHOD(get_definition)

		VSL_SET_VALIDVALUE_INTERFACE(definitionNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeTypedValueValidValues
	{
		/*[retval,out]*/ VARIANT* typedValue;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeTypedValue)(
		/*[retval,out]*/ VARIANT* typedValue)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeTypedValue)

		VSL_SET_VALIDVALUE_VARIANT(typedValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_nodeTypedValueValidValues
	{
		/*[in]*/ VARIANT typedValue;
		HRESULT retValue;
	};

	STDMETHOD(put_nodeTypedValue)(
		/*[in]*/ VARIANT typedValue)
	{
		VSL_DEFINE_MOCK_METHOD(put_nodeTypedValue)

		VSL_CHECK_VALIDVALUE(typedValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_dataTypeValidValues
	{
		/*[retval,out]*/ VARIANT* dataTypeName;
		HRESULT retValue;
	};

	STDMETHOD(get_dataType)(
		/*[retval,out]*/ VARIANT* dataTypeName)
	{
		VSL_DEFINE_MOCK_METHOD(get_dataType)

		VSL_SET_VALIDVALUE_VARIANT(dataTypeName);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_dataTypeValidValues
	{
		/*[in]*/ BSTR dataTypeName;
		HRESULT retValue;
	};

	STDMETHOD(put_dataType)(
		/*[in]*/ BSTR dataTypeName)
	{
		VSL_DEFINE_MOCK_METHOD(put_dataType)

		VSL_CHECK_VALIDVALUE_BSTR(dataTypeName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_xmlValidValues
	{
		/*[retval,out]*/ BSTR* xmlString;
		HRESULT retValue;
	};

	STDMETHOD(get_xml)(
		/*[retval,out]*/ BSTR* xmlString)
	{
		VSL_DEFINE_MOCK_METHOD(get_xml)

		VSL_SET_VALIDVALUE_BSTR(xmlString);

		VSL_RETURN_VALIDVALUES();
	}
	struct transformNodeValidValues
	{
		/*[in]*/ IXMLDOMNode* stylesheet;
		/*[retval,out]*/ BSTR* xmlString;
		HRESULT retValue;
	};

	STDMETHOD(transformNode)(
		/*[in]*/ IXMLDOMNode* stylesheet,
		/*[retval,out]*/ BSTR* xmlString)
	{
		VSL_DEFINE_MOCK_METHOD(transformNode)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(stylesheet);

		VSL_SET_VALIDVALUE_BSTR(xmlString);

		VSL_RETURN_VALIDVALUES();
	}
	struct selectNodesValidValues
	{
		/*[in]*/ BSTR queryString;
		/*[retval,out]*/ IXMLDOMNodeList** resultList;
		HRESULT retValue;
	};

	STDMETHOD(selectNodes)(
		/*[in]*/ BSTR queryString,
		/*[retval,out]*/ IXMLDOMNodeList** resultList)
	{
		VSL_DEFINE_MOCK_METHOD(selectNodes)

		VSL_CHECK_VALIDVALUE_BSTR(queryString);

		VSL_SET_VALIDVALUE_INTERFACE(resultList);

		VSL_RETURN_VALIDVALUES();
	}
	struct selectSingleNodeValidValues
	{
		/*[in]*/ BSTR queryString;
		/*[retval,out]*/ IXMLDOMNode** resultNode;
		HRESULT retValue;
	};

	STDMETHOD(selectSingleNode)(
		/*[in]*/ BSTR queryString,
		/*[retval,out]*/ IXMLDOMNode** resultNode)
	{
		VSL_DEFINE_MOCK_METHOD(selectSingleNode)

		VSL_CHECK_VALIDVALUE_BSTR(queryString);

		VSL_SET_VALIDVALUE_INTERFACE(resultNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_parsedValidValues
	{
		/*[retval,out]*/ VARIANT_BOOL* isParsed;
		HRESULT retValue;
	};

	STDMETHOD(get_parsed)(
		/*[retval,out]*/ VARIANT_BOOL* isParsed)
	{
		VSL_DEFINE_MOCK_METHOD(get_parsed)

		VSL_SET_VALIDVALUE(isParsed);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_namespaceURIValidValues
	{
		/*[retval,out]*/ BSTR* namespaceURI;
		HRESULT retValue;
	};

	STDMETHOD(get_namespaceURI)(
		/*[retval,out]*/ BSTR* namespaceURI)
	{
		VSL_DEFINE_MOCK_METHOD(get_namespaceURI)

		VSL_SET_VALIDVALUE_BSTR(namespaceURI);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_prefixValidValues
	{
		/*[retval,out]*/ BSTR* prefixString;
		HRESULT retValue;
	};

	STDMETHOD(get_prefix)(
		/*[retval,out]*/ BSTR* prefixString)
	{
		VSL_DEFINE_MOCK_METHOD(get_prefix)

		VSL_SET_VALIDVALUE_BSTR(prefixString);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_baseNameValidValues
	{
		/*[retval,out]*/ BSTR* nameString;
		HRESULT retValue;
	};

	STDMETHOD(get_baseName)(
		/*[retval,out]*/ BSTR* nameString)
	{
		VSL_DEFINE_MOCK_METHOD(get_baseName)

		VSL_SET_VALIDVALUE_BSTR(nameString);

		VSL_RETURN_VALIDVALUES();
	}
	struct transformNodeToObjectValidValues
	{
		/*[in]*/ IXMLDOMNode* stylesheet;
		/*[in]*/ VARIANT outputObject;
		HRESULT retValue;
	};

	STDMETHOD(transformNodeToObject)(
		/*[in]*/ IXMLDOMNode* stylesheet,
		/*[in]*/ VARIANT outputObject)
	{
		VSL_DEFINE_MOCK_METHOD(transformNodeToObject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(stylesheet);

		VSL_CHECK_VALIDVALUE(outputObject);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IXMLDOMCHARACTERDATA_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIXMLDOMComment.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IXMLDOMCOMMENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IXMLDOMCOMMENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "XmlDom.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IXMLDOMCommentNotImpl :
	public IXMLDOMComment
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IXMLDOMCommentNotImpl)

public:

	typedef IXMLDOMComment Interface;

	STDMETHOD(get_data)(
		/*[out,retval]*/ BSTR* /*data*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_data)(
		/*[in]*/ BSTR /*data*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_length)(
		/*[out,retval]*/ long* /*dataLength*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(substringData)(
		/*[in]*/ long /*offset*/,
		/*[in]*/ long /*count*/,
		/*[out,retval]*/ BSTR* /*data*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(appendData)(
		/*[in]*/ BSTR /*data*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(insertData)(
		/*[in]*/ long /*offset*/,
		/*[in]*/ BSTR /*data*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(deleteData)(
		/*[in]*/ long /*offset*/,
		/*[in]*/ long /*count*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(replaceData)(
		/*[in]*/ long /*offset*/,
		/*[in]*/ long /*count*/,
		/*[in]*/ BSTR /*data*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeName)(
		/*[out,retval]*/ BSTR* /*name*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeValue)(
		/*[out,retval]*/ VARIANT* /*value*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_nodeValue)(
		/*[in]*/ VARIANT /*value*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeType)(
		/*[out,retval]*/ DOMNodeType* /*type*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_parentNode)(
		/*[out,retval]*/ IXMLDOMNode** /*parent*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_childNodes)(
		/*[out,retval]*/ IXMLDOMNodeList** /*childList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_firstChild)(
		/*[out,retval]*/ IXMLDOMNode** /*firstChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_lastChild)(
		/*[out,retval]*/ IXMLDOMNode** /*lastChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_previousSibling)(
		/*[out,retval]*/ IXMLDOMNode** /*previousSibling*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nextSibling)(
		/*[out,retval]*/ IXMLDOMNode** /*nextSibling*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_attributes)(
		/*[out,retval]*/ IXMLDOMNamedNodeMap** /*attributeMap*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(insertBefore)(
		/*[in]*/ IXMLDOMNode* /*newChild*/,
		/*[in]*/ VARIANT /*refChild*/,
		/*[out,retval]*/ IXMLDOMNode** /*outNewChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(replaceChild)(
		/*[in]*/ IXMLDOMNode* /*newChild*/,
		/*[in]*/ IXMLDOMNode* /*oldChild*/,
		/*[out,retval]*/ IXMLDOMNode** /*outOldChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(removeChild)(
		/*[in]*/ IXMLDOMNode* /*childNode*/,
		/*[out,retval]*/ IXMLDOMNode** /*oldChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(appendChild)(
		/*[in]*/ IXMLDOMNode* /*newChild*/,
		/*[out,retval]*/ IXMLDOMNode** /*outNewChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(hasChildNodes)(
		/*[out,retval]*/ VARIANT_BOOL* /*hasChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ownerDocument)(
		/*[out,retval]*/ IXMLDOMDocument** /*DOMDocument*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(cloneNode)(
		/*[in]*/ VARIANT_BOOL /*deep*/,
		/*[out,retval]*/ IXMLDOMNode** /*cloneRoot*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeTypeString)(
		/*[retval,out]*/ BSTR* /*nodeType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_text)(
		/*[retval,out]*/ BSTR* /*text*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_text)(
		/*[in]*/ BSTR /*text*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_specified)(
		/*[out,retval]*/ VARIANT_BOOL* /*isSpecified*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_definition)(
		/*[retval,out]*/ IXMLDOMNode** /*definitionNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeTypedValue)(
		/*[retval,out]*/ VARIANT* /*typedValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_nodeTypedValue)(
		/*[in]*/ VARIANT /*typedValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_dataType)(
		/*[retval,out]*/ VARIANT* /*dataTypeName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_dataType)(
		/*[in]*/ BSTR /*dataTypeName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_xml)(
		/*[retval,out]*/ BSTR* /*xmlString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(transformNode)(
		/*[in]*/ IXMLDOMNode* /*stylesheet*/,
		/*[retval,out]*/ BSTR* /*xmlString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(selectNodes)(
		/*[in]*/ BSTR /*queryString*/,
		/*[retval,out]*/ IXMLDOMNodeList** /*resultList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(selectSingleNode)(
		/*[in]*/ BSTR /*queryString*/,
		/*[retval,out]*/ IXMLDOMNode** /*resultNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_parsed)(
		/*[retval,out]*/ VARIANT_BOOL* /*isParsed*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_namespaceURI)(
		/*[retval,out]*/ BSTR* /*namespaceURI*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_prefix)(
		/*[retval,out]*/ BSTR* /*prefixString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_baseName)(
		/*[retval,out]*/ BSTR* /*nameString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(transformNodeToObject)(
		/*[in]*/ IXMLDOMNode* /*stylesheet*/,
		/*[in]*/ VARIANT /*outputObject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class IXMLDOMCommentMockImpl :
	public IXMLDOMComment,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IXMLDOMCommentMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IXMLDOMCommentMockImpl)

	typedef IXMLDOMComment Interface;
	struct get_dataValidValues
	{
		/*[out,retval]*/ BSTR* data;
		HRESULT retValue;
	};

	STDMETHOD(get_data)(
		/*[out,retval]*/ BSTR* data)
	{
		VSL_DEFINE_MOCK_METHOD(get_data)

		VSL_SET_VALIDVALUE_BSTR(data);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_dataValidValues
	{
		/*[in]*/ BSTR data;
		HRESULT retValue;
	};

	STDMETHOD(put_data)(
		/*[in]*/ BSTR data)
	{
		VSL_DEFINE_MOCK_METHOD(put_data)

		VSL_CHECK_VALIDVALUE_BSTR(data);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_lengthValidValues
	{
		/*[out,retval]*/ long* dataLength;
		HRESULT retValue;
	};

	STDMETHOD(get_length)(
		/*[out,retval]*/ long* dataLength)
	{
		VSL_DEFINE_MOCK_METHOD(get_length)

		VSL_SET_VALIDVALUE(dataLength);

		VSL_RETURN_VALIDVALUES();
	}
	struct substringDataValidValues
	{
		/*[in]*/ long offset;
		/*[in]*/ long count;
		/*[out,retval]*/ BSTR* data;
		HRESULT retValue;
	};

	STDMETHOD(substringData)(
		/*[in]*/ long offset,
		/*[in]*/ long count,
		/*[out,retval]*/ BSTR* data)
	{
		VSL_DEFINE_MOCK_METHOD(substringData)

		VSL_CHECK_VALIDVALUE(offset);

		VSL_CHECK_VALIDVALUE(count);

		VSL_SET_VALIDVALUE_BSTR(data);

		VSL_RETURN_VALIDVALUES();
	}
	struct appendDataValidValues
	{
		/*[in]*/ BSTR data;
		HRESULT retValue;
	};

	STDMETHOD(appendData)(
		/*[in]*/ BSTR data)
	{
		VSL_DEFINE_MOCK_METHOD(appendData)

		VSL_CHECK_VALIDVALUE_BSTR(data);

		VSL_RETURN_VALIDVALUES();
	}
	struct insertDataValidValues
	{
		/*[in]*/ long offset;
		/*[in]*/ BSTR data;
		HRESULT retValue;
	};

	STDMETHOD(insertData)(
		/*[in]*/ long offset,
		/*[in]*/ BSTR data)
	{
		VSL_DEFINE_MOCK_METHOD(insertData)

		VSL_CHECK_VALIDVALUE(offset);

		VSL_CHECK_VALIDVALUE_BSTR(data);

		VSL_RETURN_VALIDVALUES();
	}
	struct deleteDataValidValues
	{
		/*[in]*/ long offset;
		/*[in]*/ long count;
		HRESULT retValue;
	};

	STDMETHOD(deleteData)(
		/*[in]*/ long offset,
		/*[in]*/ long count)
	{
		VSL_DEFINE_MOCK_METHOD(deleteData)

		VSL_CHECK_VALIDVALUE(offset);

		VSL_CHECK_VALIDVALUE(count);

		VSL_RETURN_VALIDVALUES();
	}
	struct replaceDataValidValues
	{
		/*[in]*/ long offset;
		/*[in]*/ long count;
		/*[in]*/ BSTR data;
		HRESULT retValue;
	};

	STDMETHOD(replaceData)(
		/*[in]*/ long offset,
		/*[in]*/ long count,
		/*[in]*/ BSTR data)
	{
		VSL_DEFINE_MOCK_METHOD(replaceData)

		VSL_CHECK_VALIDVALUE(offset);

		VSL_CHECK_VALIDVALUE(count);

		VSL_CHECK_VALIDVALUE_BSTR(data);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeNameValidValues
	{
		/*[out,retval]*/ BSTR* name;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeName)(
		/*[out,retval]*/ BSTR* name)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeName)

		VSL_SET_VALIDVALUE_BSTR(name);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeValueValidValues
	{
		/*[out,retval]*/ VARIANT* value;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeValue)(
		/*[out,retval]*/ VARIANT* value)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeValue)

		VSL_SET_VALIDVALUE_VARIANT(value);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_nodeValueValidValues
	{
		/*[in]*/ VARIANT value;
		HRESULT retValue;
	};

	STDMETHOD(put_nodeValue)(
		/*[in]*/ VARIANT value)
	{
		VSL_DEFINE_MOCK_METHOD(put_nodeValue)

		VSL_CHECK_VALIDVALUE(value);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeTypeValidValues
	{
		/*[out,retval]*/ DOMNodeType* type;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeType)(
		/*[out,retval]*/ DOMNodeType* type)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeType)

		VSL_SET_VALIDVALUE(type);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_parentNodeValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** parent;
		HRESULT retValue;
	};

	STDMETHOD(get_parentNode)(
		/*[out,retval]*/ IXMLDOMNode** parent)
	{
		VSL_DEFINE_MOCK_METHOD(get_parentNode)

		VSL_SET_VALIDVALUE_INTERFACE(parent);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_childNodesValidValues
	{
		/*[out,retval]*/ IXMLDOMNodeList** childList;
		HRESULT retValue;
	};

	STDMETHOD(get_childNodes)(
		/*[out,retval]*/ IXMLDOMNodeList** childList)
	{
		VSL_DEFINE_MOCK_METHOD(get_childNodes)

		VSL_SET_VALIDVALUE_INTERFACE(childList);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_firstChildValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** firstChild;
		HRESULT retValue;
	};

	STDMETHOD(get_firstChild)(
		/*[out,retval]*/ IXMLDOMNode** firstChild)
	{
		VSL_DEFINE_MOCK_METHOD(get_firstChild)

		VSL_SET_VALIDVALUE_INTERFACE(firstChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_lastChildValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** lastChild;
		HRESULT retValue;
	};

	STDMETHOD(get_lastChild)(
		/*[out,retval]*/ IXMLDOMNode** lastChild)
	{
		VSL_DEFINE_MOCK_METHOD(get_lastChild)

		VSL_SET_VALIDVALUE_INTERFACE(lastChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_previousSiblingValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** previousSibling;
		HRESULT retValue;
	};

	STDMETHOD(get_previousSibling)(
		/*[out,retval]*/ IXMLDOMNode** previousSibling)
	{
		VSL_DEFINE_MOCK_METHOD(get_previousSibling)

		VSL_SET_VALIDVALUE_INTERFACE(previousSibling);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nextSiblingValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** nextSibling;
		HRESULT retValue;
	};

	STDMETHOD(get_nextSibling)(
		/*[out,retval]*/ IXMLDOMNode** nextSibling)
	{
		VSL_DEFINE_MOCK_METHOD(get_nextSibling)

		VSL_SET_VALIDVALUE_INTERFACE(nextSibling);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_attributesValidValues
	{
		/*[out,retval]*/ IXMLDOMNamedNodeMap** attributeMap;
		HRESULT retValue;
	};

	STDMETHOD(get_attributes)(
		/*[out,retval]*/ IXMLDOMNamedNodeMap** attributeMap)
	{
		VSL_DEFINE_MOCK_METHOD(get_attributes)

		VSL_SET_VALIDVALUE_INTERFACE(attributeMap);

		VSL_RETURN_VALIDVALUES();
	}
	struct insertBeforeValidValues
	{
		/*[in]*/ IXMLDOMNode* newChild;
		/*[in]*/ VARIANT refChild;
		/*[out,retval]*/ IXMLDOMNode** outNewChild;
		HRESULT retValue;
	};

	STDMETHOD(insertBefore)(
		/*[in]*/ IXMLDOMNode* newChild,
		/*[in]*/ VARIANT refChild,
		/*[out,retval]*/ IXMLDOMNode** outNewChild)
	{
		VSL_DEFINE_MOCK_METHOD(insertBefore)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(newChild);

		VSL_CHECK_VALIDVALUE(refChild);

		VSL_SET_VALIDVALUE_INTERFACE(outNewChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct replaceChildValidValues
	{
		/*[in]*/ IXMLDOMNode* newChild;
		/*[in]*/ IXMLDOMNode* oldChild;
		/*[out,retval]*/ IXMLDOMNode** outOldChild;
		HRESULT retValue;
	};

	STDMETHOD(replaceChild)(
		/*[in]*/ IXMLDOMNode* newChild,
		/*[in]*/ IXMLDOMNode* oldChild,
		/*[out,retval]*/ IXMLDOMNode** outOldChild)
	{
		VSL_DEFINE_MOCK_METHOD(replaceChild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(newChild);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(oldChild);

		VSL_SET_VALIDVALUE_INTERFACE(outOldChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct removeChildValidValues
	{
		/*[in]*/ IXMLDOMNode* childNode;
		/*[out,retval]*/ IXMLDOMNode** oldChild;
		HRESULT retValue;
	};

	STDMETHOD(removeChild)(
		/*[in]*/ IXMLDOMNode* childNode,
		/*[out,retval]*/ IXMLDOMNode** oldChild)
	{
		VSL_DEFINE_MOCK_METHOD(removeChild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(childNode);

		VSL_SET_VALIDVALUE_INTERFACE(oldChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct appendChildValidValues
	{
		/*[in]*/ IXMLDOMNode* newChild;
		/*[out,retval]*/ IXMLDOMNode** outNewChild;
		HRESULT retValue;
	};

	STDMETHOD(appendChild)(
		/*[in]*/ IXMLDOMNode* newChild,
		/*[out,retval]*/ IXMLDOMNode** outNewChild)
	{
		VSL_DEFINE_MOCK_METHOD(appendChild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(newChild);

		VSL_SET_VALIDVALUE_INTERFACE(outNewChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct hasChildNodesValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* hasChild;
		HRESULT retValue;
	};

	STDMETHOD(hasChildNodes)(
		/*[out,retval]*/ VARIANT_BOOL* hasChild)
	{
		VSL_DEFINE_MOCK_METHOD(hasChildNodes)

		VSL_SET_VALIDVALUE(hasChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ownerDocumentValidValues
	{
		/*[out,retval]*/ IXMLDOMDocument** DOMDocument;
		HRESULT retValue;
	};

	STDMETHOD(get_ownerDocument)(
		/*[out,retval]*/ IXMLDOMDocument** DOMDocument)
	{
		VSL_DEFINE_MOCK_METHOD(get_ownerDocument)

		VSL_SET_VALIDVALUE_INTERFACE(DOMDocument);

		VSL_RETURN_VALIDVALUES();
	}
	struct cloneNodeValidValues
	{
		/*[in]*/ VARIANT_BOOL deep;
		/*[out,retval]*/ IXMLDOMNode** cloneRoot;
		HRESULT retValue;
	};

	STDMETHOD(cloneNode)(
		/*[in]*/ VARIANT_BOOL deep,
		/*[out,retval]*/ IXMLDOMNode** cloneRoot)
	{
		VSL_DEFINE_MOCK_METHOD(cloneNode)

		VSL_CHECK_VALIDVALUE(deep);

		VSL_SET_VALIDVALUE_INTERFACE(cloneRoot);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeTypeStringValidValues
	{
		/*[retval,out]*/ BSTR* nodeType;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeTypeString)(
		/*[retval,out]*/ BSTR* nodeType)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeTypeString)

		VSL_SET_VALIDVALUE_BSTR(nodeType);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_textValidValues
	{
		/*[retval,out]*/ BSTR* text;
		HRESULT retValue;
	};

	STDMETHOD(get_text)(
		/*[retval,out]*/ BSTR* text)
	{
		VSL_DEFINE_MOCK_METHOD(get_text)

		VSL_SET_VALIDVALUE_BSTR(text);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_textValidValues
	{
		/*[in]*/ BSTR text;
		HRESULT retValue;
	};

	STDMETHOD(put_text)(
		/*[in]*/ BSTR text)
	{
		VSL_DEFINE_MOCK_METHOD(put_text)

		VSL_CHECK_VALIDVALUE_BSTR(text);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_specifiedValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* isSpecified;
		HRESULT retValue;
	};

	STDMETHOD(get_specified)(
		/*[out,retval]*/ VARIANT_BOOL* isSpecified)
	{
		VSL_DEFINE_MOCK_METHOD(get_specified)

		VSL_SET_VALIDVALUE(isSpecified);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_definitionValidValues
	{
		/*[retval,out]*/ IXMLDOMNode** definitionNode;
		HRESULT retValue;
	};

	STDMETHOD(get_definition)(
		/*[retval,out]*/ IXMLDOMNode** definitionNode)
	{
		VSL_DEFINE_MOCK_METHOD(get_definition)

		VSL_SET_VALIDVALUE_INTERFACE(definitionNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeTypedValueValidValues
	{
		/*[retval,out]*/ VARIANT* typedValue;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeTypedValue)(
		/*[retval,out]*/ VARIANT* typedValue)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeTypedValue)

		VSL_SET_VALIDVALUE_VARIANT(typedValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_nodeTypedValueValidValues
	{
		/*[in]*/ VARIANT typedValue;
		HRESULT retValue;
	};

	STDMETHOD(put_nodeTypedValue)(
		/*[in]*/ VARIANT typedValue)
	{
		VSL_DEFINE_MOCK_METHOD(put_nodeTypedValue)

		VSL_CHECK_VALIDVALUE(typedValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_dataTypeValidValues
	{
		/*[retval,out]*/ VARIANT* dataTypeName;
		HRESULT retValue;
	};

	STDMETHOD(get_dataType)(
		/*[retval,out]*/ VARIANT* dataTypeName)
	{
		VSL_DEFINE_MOCK_METHOD(get_dataType)

		VSL_SET_VALIDVALUE_VARIANT(dataTypeName);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_dataTypeValidValues
	{
		/*[in]*/ BSTR dataTypeName;
		HRESULT retValue;
	};

	STDMETHOD(put_dataType)(
		/*[in]*/ BSTR dataTypeName)
	{
		VSL_DEFINE_MOCK_METHOD(put_dataType)

		VSL_CHECK_VALIDVALUE_BSTR(dataTypeName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_xmlValidValues
	{
		/*[retval,out]*/ BSTR* xmlString;
		HRESULT retValue;
	};

	STDMETHOD(get_xml)(
		/*[retval,out]*/ BSTR* xmlString)
	{
		VSL_DEFINE_MOCK_METHOD(get_xml)

		VSL_SET_VALIDVALUE_BSTR(xmlString);

		VSL_RETURN_VALIDVALUES();
	}
	struct transformNodeValidValues
	{
		/*[in]*/ IXMLDOMNode* stylesheet;
		/*[retval,out]*/ BSTR* xmlString;
		HRESULT retValue;
	};

	STDMETHOD(transformNode)(
		/*[in]*/ IXMLDOMNode* stylesheet,
		/*[retval,out]*/ BSTR* xmlString)
	{
		VSL_DEFINE_MOCK_METHOD(transformNode)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(stylesheet);

		VSL_SET_VALIDVALUE_BSTR(xmlString);

		VSL_RETURN_VALIDVALUES();
	}
	struct selectNodesValidValues
	{
		/*[in]*/ BSTR queryString;
		/*[retval,out]*/ IXMLDOMNodeList** resultList;
		HRESULT retValue;
	};

	STDMETHOD(selectNodes)(
		/*[in]*/ BSTR queryString,
		/*[retval,out]*/ IXMLDOMNodeList** resultList)
	{
		VSL_DEFINE_MOCK_METHOD(selectNodes)

		VSL_CHECK_VALIDVALUE_BSTR(queryString);

		VSL_SET_VALIDVALUE_INTERFACE(resultList);

		VSL_RETURN_VALIDVALUES();
	}
	struct selectSingleNodeValidValues
	{
		/*[in]*/ BSTR queryString;
		/*[retval,out]*/ IXMLDOMNode** resultNode;
		HRESULT retValue;
	};

	STDMETHOD(selectSingleNode)(
		/*[in]*/ BSTR queryString,
		/*[retval,out]*/ IXMLDOMNode** resultNode)
	{
		VSL_DEFINE_MOCK_METHOD(selectSingleNode)

		VSL_CHECK_VALIDVALUE_BSTR(queryString);

		VSL_SET_VALIDVALUE_INTERFACE(resultNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_parsedValidValues
	{
		/*[retval,out]*/ VARIANT_BOOL* isParsed;
		HRESULT retValue;
	};

	STDMETHOD(get_parsed)(
		/*[retval,out]*/ VARIANT_BOOL* isParsed)
	{
		VSL_DEFINE_MOCK_METHOD(get_parsed)

		VSL_SET_VALIDVALUE(isParsed);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_namespaceURIValidValues
	{
		/*[retval,out]*/ BSTR* namespaceURI;
		HRESULT retValue;
	};

	STDMETHOD(get_namespaceURI)(
		/*[retval,out]*/ BSTR* namespaceURI)
	{
		VSL_DEFINE_MOCK_METHOD(get_namespaceURI)

		VSL_SET_VALIDVALUE_BSTR(namespaceURI);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_prefixValidValues
	{
		/*[retval,out]*/ BSTR* prefixString;
		HRESULT retValue;
	};

	STDMETHOD(get_prefix)(
		/*[retval,out]*/ BSTR* prefixString)
	{
		VSL_DEFINE_MOCK_METHOD(get_prefix)

		VSL_SET_VALIDVALUE_BSTR(prefixString);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_baseNameValidValues
	{
		/*[retval,out]*/ BSTR* nameString;
		HRESULT retValue;
	};

	STDMETHOD(get_baseName)(
		/*[retval,out]*/ BSTR* nameString)
	{
		VSL_DEFINE_MOCK_METHOD(get_baseName)

		VSL_SET_VALIDVALUE_BSTR(nameString);

		VSL_RETURN_VALIDVALUES();
	}
	struct transformNodeToObjectValidValues
	{
		/*[in]*/ IXMLDOMNode* stylesheet;
		/*[in]*/ VARIANT outputObject;
		HRESULT retValue;
	};

	STDMETHOD(transformNodeToObject)(
		/*[in]*/ IXMLDOMNode* stylesheet,
		/*[in]*/ VARIANT outputObject)
	{
		VSL_DEFINE_MOCK_METHOD(transformNodeToObject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(stylesheet);

		VSL_CHECK_VALIDVALUE(outputObject);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IXMLDOMCOMMENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIXMLDOMDocumentFragment.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IXMLDOMDOCUMENTFRAGMENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IXMLDOMDOCUMENTFRAGMENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "XmlDom.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IXMLDOMDocumentFragmentNotImpl :
	public IXMLDOMDocumentFragment
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IXMLDOMDocumentFragmentNotImpl)

public:

	typedef IXMLDOMDocumentFragment Interface;

	STDMETHOD(get_nodeName)(
		/*[out,retval]*/ BSTR* /*name*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeValue)(
		/*[out,retval]*/ VARIANT* /*value*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_nodeValue)(
		/*[in]*/ VARIANT /*value*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeType)(
		/*[out,retval]*/ DOMNodeType* /*type*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_parentNode)(
		/*[out,retval]*/ IXMLDOMNode** /*parent*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_childNodes)(
		/*[out,retval]*/ IXMLDOMNodeList** /*childList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_firstChild)(
		/*[out,retval]*/ IXMLDOMNode** /*firstChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_lastChild)(
		/*[out,retval]*/ IXMLDOMNode** /*lastChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_previousSibling)(
		/*[out,retval]*/ IXMLDOMNode** /*previousSibling*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nextSibling)(
		/*[out,retval]*/ IXMLDOMNode** /*nextSibling*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_attributes)(
		/*[out,retval]*/ IXMLDOMNamedNodeMap** /*attributeMap*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(insertBefore)(
		/*[in]*/ IXMLDOMNode* /*newChild*/,
		/*[in]*/ VARIANT /*refChild*/,
		/*[out,retval]*/ IXMLDOMNode** /*outNewChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(replaceChild)(
		/*[in]*/ IXMLDOMNode* /*newChild*/,
		/*[in]*/ IXMLDOMNode* /*oldChild*/,
		/*[out,retval]*/ IXMLDOMNode** /*outOldChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(removeChild)(
		/*[in]*/ IXMLDOMNode* /*childNode*/,
		/*[out,retval]*/ IXMLDOMNode** /*oldChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(appendChild)(
		/*[in]*/ IXMLDOMNode* /*newChild*/,
		/*[out,retval]*/ IXMLDOMNode** /*outNewChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(hasChildNodes)(
		/*[out,retval]*/ VARIANT_BOOL* /*hasChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ownerDocument)(
		/*[out,retval]*/ IXMLDOMDocument** /*DOMDocument*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(cloneNode)(
		/*[in]*/ VARIANT_BOOL /*deep*/,
		/*[out,retval]*/ IXMLDOMNode** /*cloneRoot*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeTypeString)(
		/*[retval,out]*/ BSTR* /*nodeType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_text)(
		/*[retval,out]*/ BSTR* /*text*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_text)(
		/*[in]*/ BSTR /*text*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_specified)(
		/*[out,retval]*/ VARIANT_BOOL* /*isSpecified*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_definition)(
		/*[retval,out]*/ IXMLDOMNode** /*definitionNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeTypedValue)(
		/*[retval,out]*/ VARIANT* /*typedValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_nodeTypedValue)(
		/*[in]*/ VARIANT /*typedValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_dataType)(
		/*[retval,out]*/ VARIANT* /*dataTypeName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_dataType)(
		/*[in]*/ BSTR /*dataTypeName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_xml)(
		/*[retval,out]*/ BSTR* /*xmlString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(transformNode)(
		/*[in]*/ IXMLDOMNode* /*stylesheet*/,
		/*[retval,out]*/ BSTR* /*xmlString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(selectNodes)(
		/*[in]*/ BSTR /*queryString*/,
		/*[retval,out]*/ IXMLDOMNodeList** /*resultList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(selectSingleNode)(
		/*[in]*/ BSTR /*queryString*/,
		/*[retval,out]*/ IXMLDOMNode** /*resultNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_parsed)(
		/*[retval,out]*/ VARIANT_BOOL* /*isParsed*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_namespaceURI)(
		/*[retval,out]*/ BSTR* /*namespaceURI*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_prefix)(
		/*[retval,out]*/ BSTR* /*prefixString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_baseName)(
		/*[retval,out]*/ BSTR* /*nameString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(transformNodeToObject)(
		/*[in]*/ IXMLDOMNode* /*stylesheet*/,
		/*[in]*/ VARIANT /*outputObject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class IXMLDOMDocumentFragmentMockImpl :
	public IXMLDOMDocumentFragment,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IXMLDOMDocumentFragmentMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IXMLDOMDocumentFragmentMockImpl)

	typedef IXMLDOMDocumentFragment Interface;
	struct get_nodeNameValidValues
	{
		/*[out,retval]*/ BSTR* name;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeName)(
		/*[out,retval]*/ BSTR* name)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeName)

		VSL_SET_VALIDVALUE_BSTR(name);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeValueValidValues
	{
		/*[out,retval]*/ VARIANT* value;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeValue)(
		/*[out,retval]*/ VARIANT* value)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeValue)

		VSL_SET_VALIDVALUE_VARIANT(value);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_nodeValueValidValues
	{
		/*[in]*/ VARIANT value;
		HRESULT retValue;
	};

	STDMETHOD(put_nodeValue)(
		/*[in]*/ VARIANT value)
	{
		VSL_DEFINE_MOCK_METHOD(put_nodeValue)

		VSL_CHECK_VALIDVALUE(value);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeTypeValidValues
	{
		/*[out,retval]*/ DOMNodeType* type;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeType)(
		/*[out,retval]*/ DOMNodeType* type)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeType)

		VSL_SET_VALIDVALUE(type);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_parentNodeValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** parent;
		HRESULT retValue;
	};

	STDMETHOD(get_parentNode)(
		/*[out,retval]*/ IXMLDOMNode** parent)
	{
		VSL_DEFINE_MOCK_METHOD(get_parentNode)

		VSL_SET_VALIDVALUE_INTERFACE(parent);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_childNodesValidValues
	{
		/*[out,retval]*/ IXMLDOMNodeList** childList;
		HRESULT retValue;
	};

	STDMETHOD(get_childNodes)(
		/*[out,retval]*/ IXMLDOMNodeList** childList)
	{
		VSL_DEFINE_MOCK_METHOD(get_childNodes)

		VSL_SET_VALIDVALUE_INTERFACE(childList);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_firstChildValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** firstChild;
		HRESULT retValue;
	};

	STDMETHOD(get_firstChild)(
		/*[out,retval]*/ IXMLDOMNode** firstChild)
	{
		VSL_DEFINE_MOCK_METHOD(get_firstChild)

		VSL_SET_VALIDVALUE_INTERFACE(firstChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_lastChildValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** lastChild;
		HRESULT retValue;
	};

	STDMETHOD(get_lastChild)(
		/*[out,retval]*/ IXMLDOMNode** lastChild)
	{
		VSL_DEFINE_MOCK_METHOD(get_lastChild)

		VSL_SET_VALIDVALUE_INTERFACE(lastChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_previousSiblingValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** previousSibling;
		HRESULT retValue;
	};

	STDMETHOD(get_previousSibling)(
		/*[out,retval]*/ IXMLDOMNode** previousSibling)
	{
		VSL_DEFINE_MOCK_METHOD(get_previousSibling)

		VSL_SET_VALIDVALUE_INTERFACE(previousSibling);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nextSiblingValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** nextSibling;
		HRESULT retValue;
	};

	STDMETHOD(get_nextSibling)(
		/*[out,retval]*/ IXMLDOMNode** nextSibling)
	{
		VSL_DEFINE_MOCK_METHOD(get_nextSibling)

		VSL_SET_VALIDVALUE_INTERFACE(nextSibling);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_attributesValidValues
	{
		/*[out,retval]*/ IXMLDOMNamedNodeMap** attributeMap;
		HRESULT retValue;
	};

	STDMETHOD(get_attributes)(
		/*[out,retval]*/ IXMLDOMNamedNodeMap** attributeMap)
	{
		VSL_DEFINE_MOCK_METHOD(get_attributes)

		VSL_SET_VALIDVALUE_INTERFACE(attributeMap);

		VSL_RETURN_VALIDVALUES();
	}
	struct insertBeforeValidValues
	{
		/*[in]*/ IXMLDOMNode* newChild;
		/*[in]*/ VARIANT refChild;
		/*[out,retval]*/ IXMLDOMNode** outNewChild;
		HRESULT retValue;
	};

	STDMETHOD(insertBefore)(
		/*[in]*/ IXMLDOMNode* newChild,
		/*[in]*/ VARIANT refChild,
		/*[out,retval]*/ IXMLDOMNode** outNewChild)
	{
		VSL_DEFINE_MOCK_METHOD(insertBefore)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(newChild);

		VSL_CHECK_VALIDVALUE(refChild);

		VSL_SET_VALIDVALUE_INTERFACE(outNewChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct replaceChildValidValues
	{
		/*[in]*/ IXMLDOMNode* newChild;
		/*[in]*/ IXMLDOMNode* oldChild;
		/*[out,retval]*/ IXMLDOMNode** outOldChild;
		HRESULT retValue;
	};

	STDMETHOD(replaceChild)(
		/*[in]*/ IXMLDOMNode* newChild,
		/*[in]*/ IXMLDOMNode* oldChild,
		/*[out,retval]*/ IXMLDOMNode** outOldChild)
	{
		VSL_DEFINE_MOCK_METHOD(replaceChild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(newChild);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(oldChild);

		VSL_SET_VALIDVALUE_INTERFACE(outOldChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct removeChildValidValues
	{
		/*[in]*/ IXMLDOMNode* childNode;
		/*[out,retval]*/ IXMLDOMNode** oldChild;
		HRESULT retValue;
	};

	STDMETHOD(removeChild)(
		/*[in]*/ IXMLDOMNode* childNode,
		/*[out,retval]*/ IXMLDOMNode** oldChild)
	{
		VSL_DEFINE_MOCK_METHOD(removeChild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(childNode);

		VSL_SET_VALIDVALUE_INTERFACE(oldChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct appendChildValidValues
	{
		/*[in]*/ IXMLDOMNode* newChild;
		/*[out,retval]*/ IXMLDOMNode** outNewChild;
		HRESULT retValue;
	};

	STDMETHOD(appendChild)(
		/*[in]*/ IXMLDOMNode* newChild,
		/*[out,retval]*/ IXMLDOMNode** outNewChild)
	{
		VSL_DEFINE_MOCK_METHOD(appendChild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(newChild);

		VSL_SET_VALIDVALUE_INTERFACE(outNewChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct hasChildNodesValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* hasChild;
		HRESULT retValue;
	};

	STDMETHOD(hasChildNodes)(
		/*[out,retval]*/ VARIANT_BOOL* hasChild)
	{
		VSL_DEFINE_MOCK_METHOD(hasChildNodes)

		VSL_SET_VALIDVALUE(hasChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ownerDocumentValidValues
	{
		/*[out,retval]*/ IXMLDOMDocument** DOMDocument;
		HRESULT retValue;
	};

	STDMETHOD(get_ownerDocument)(
		/*[out,retval]*/ IXMLDOMDocument** DOMDocument)
	{
		VSL_DEFINE_MOCK_METHOD(get_ownerDocument)

		VSL_SET_VALIDVALUE_INTERFACE(DOMDocument);

		VSL_RETURN_VALIDVALUES();
	}
	struct cloneNodeValidValues
	{
		/*[in]*/ VARIANT_BOOL deep;
		/*[out,retval]*/ IXMLDOMNode** cloneRoot;
		HRESULT retValue;
	};

	STDMETHOD(cloneNode)(
		/*[in]*/ VARIANT_BOOL deep,
		/*[out,retval]*/ IXMLDOMNode** cloneRoot)
	{
		VSL_DEFINE_MOCK_METHOD(cloneNode)

		VSL_CHECK_VALIDVALUE(deep);

		VSL_SET_VALIDVALUE_INTERFACE(cloneRoot);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeTypeStringValidValues
	{
		/*[retval,out]*/ BSTR* nodeType;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeTypeString)(
		/*[retval,out]*/ BSTR* nodeType)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeTypeString)

		VSL_SET_VALIDVALUE_BSTR(nodeType);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_textValidValues
	{
		/*[retval,out]*/ BSTR* text;
		HRESULT retValue;
	};

	STDMETHOD(get_text)(
		/*[retval,out]*/ BSTR* text)
	{
		VSL_DEFINE_MOCK_METHOD(get_text)

		VSL_SET_VALIDVALUE_BSTR(text);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_textValidValues
	{
		/*[in]*/ BSTR text;
		HRESULT retValue;
	};

	STDMETHOD(put_text)(
		/*[in]*/ BSTR text)
	{
		VSL_DEFINE_MOCK_METHOD(put_text)

		VSL_CHECK_VALIDVALUE_BSTR(text);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_specifiedValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* isSpecified;
		HRESULT retValue;
	};

	STDMETHOD(get_specified)(
		/*[out,retval]*/ VARIANT_BOOL* isSpecified)
	{
		VSL_DEFINE_MOCK_METHOD(get_specified)

		VSL_SET_VALIDVALUE(isSpecified);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_definitionValidValues
	{
		/*[retval,out]*/ IXMLDOMNode** definitionNode;
		HRESULT retValue;
	};

	STDMETHOD(get_definition)(
		/*[retval,out]*/ IXMLDOMNode** definitionNode)
	{
		VSL_DEFINE_MOCK_METHOD(get_definition)

		VSL_SET_VALIDVALUE_INTERFACE(definitionNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeTypedValueValidValues
	{
		/*[retval,out]*/ VARIANT* typedValue;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeTypedValue)(
		/*[retval,out]*/ VARIANT* typedValue)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeTypedValue)

		VSL_SET_VALIDVALUE_VARIANT(typedValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_nodeTypedValueValidValues
	{
		/*[in]*/ VARIANT typedValue;
		HRESULT retValue;
	};

	STDMETHOD(put_nodeTypedValue)(
		/*[in]*/ VARIANT typedValue)
	{
		VSL_DEFINE_MOCK_METHOD(put_nodeTypedValue)

		VSL_CHECK_VALIDVALUE(typedValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_dataTypeValidValues
	{
		/*[retval,out]*/ VARIANT* dataTypeName;
		HRESULT retValue;
	};

	STDMETHOD(get_dataType)(
		/*[retval,out]*/ VARIANT* dataTypeName)
	{
		VSL_DEFINE_MOCK_METHOD(get_dataType)

		VSL_SET_VALIDVALUE_VARIANT(dataTypeName);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_dataTypeValidValues
	{
		/*[in]*/ BSTR dataTypeName;
		HRESULT retValue;
	};

	STDMETHOD(put_dataType)(
		/*[in]*/ BSTR dataTypeName)
	{
		VSL_DEFINE_MOCK_METHOD(put_dataType)

		VSL_CHECK_VALIDVALUE_BSTR(dataTypeName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_xmlValidValues
	{
		/*[retval,out]*/ BSTR* xmlString;
		HRESULT retValue;
	};

	STDMETHOD(get_xml)(
		/*[retval,out]*/ BSTR* xmlString)
	{
		VSL_DEFINE_MOCK_METHOD(get_xml)

		VSL_SET_VALIDVALUE_BSTR(xmlString);

		VSL_RETURN_VALIDVALUES();
	}
	struct transformNodeValidValues
	{
		/*[in]*/ IXMLDOMNode* stylesheet;
		/*[retval,out]*/ BSTR* xmlString;
		HRESULT retValue;
	};

	STDMETHOD(transformNode)(
		/*[in]*/ IXMLDOMNode* stylesheet,
		/*[retval,out]*/ BSTR* xmlString)
	{
		VSL_DEFINE_MOCK_METHOD(transformNode)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(stylesheet);

		VSL_SET_VALIDVALUE_BSTR(xmlString);

		VSL_RETURN_VALIDVALUES();
	}
	struct selectNodesValidValues
	{
		/*[in]*/ BSTR queryString;
		/*[retval,out]*/ IXMLDOMNodeList** resultList;
		HRESULT retValue;
	};

	STDMETHOD(selectNodes)(
		/*[in]*/ BSTR queryString,
		/*[retval,out]*/ IXMLDOMNodeList** resultList)
	{
		VSL_DEFINE_MOCK_METHOD(selectNodes)

		VSL_CHECK_VALIDVALUE_BSTR(queryString);

		VSL_SET_VALIDVALUE_INTERFACE(resultList);

		VSL_RETURN_VALIDVALUES();
	}
	struct selectSingleNodeValidValues
	{
		/*[in]*/ BSTR queryString;
		/*[retval,out]*/ IXMLDOMNode** resultNode;
		HRESULT retValue;
	};

	STDMETHOD(selectSingleNode)(
		/*[in]*/ BSTR queryString,
		/*[retval,out]*/ IXMLDOMNode** resultNode)
	{
		VSL_DEFINE_MOCK_METHOD(selectSingleNode)

		VSL_CHECK_VALIDVALUE_BSTR(queryString);

		VSL_SET_VALIDVALUE_INTERFACE(resultNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_parsedValidValues
	{
		/*[retval,out]*/ VARIANT_BOOL* isParsed;
		HRESULT retValue;
	};

	STDMETHOD(get_parsed)(
		/*[retval,out]*/ VARIANT_BOOL* isParsed)
	{
		VSL_DEFINE_MOCK_METHOD(get_parsed)

		VSL_SET_VALIDVALUE(isParsed);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_namespaceURIValidValues
	{
		/*[retval,out]*/ BSTR* namespaceURI;
		HRESULT retValue;
	};

	STDMETHOD(get_namespaceURI)(
		/*[retval,out]*/ BSTR* namespaceURI)
	{
		VSL_DEFINE_MOCK_METHOD(get_namespaceURI)

		VSL_SET_VALIDVALUE_BSTR(namespaceURI);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_prefixValidValues
	{
		/*[retval,out]*/ BSTR* prefixString;
		HRESULT retValue;
	};

	STDMETHOD(get_prefix)(
		/*[retval,out]*/ BSTR* prefixString)
	{
		VSL_DEFINE_MOCK_METHOD(get_prefix)

		VSL_SET_VALIDVALUE_BSTR(prefixString);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_baseNameValidValues
	{
		/*[retval,out]*/ BSTR* nameString;
		HRESULT retValue;
	};

	STDMETHOD(get_baseName)(
		/*[retval,out]*/ BSTR* nameString)
	{
		VSL_DEFINE_MOCK_METHOD(get_baseName)

		VSL_SET_VALIDVALUE_BSTR(nameString);

		VSL_RETURN_VALIDVALUES();
	}
	struct transformNodeToObjectValidValues
	{
		/*[in]*/ IXMLDOMNode* stylesheet;
		/*[in]*/ VARIANT outputObject;
		HRESULT retValue;
	};

	STDMETHOD(transformNodeToObject)(
		/*[in]*/ IXMLDOMNode* stylesheet,
		/*[in]*/ VARIANT outputObject)
	{
		VSL_DEFINE_MOCK_METHOD(transformNodeToObject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(stylesheet);

		VSL_CHECK_VALIDVALUE(outputObject);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IXMLDOMDOCUMENTFRAGMENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIXMLDOMEntity.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IXMLDOMENTITY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IXMLDOMENTITY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "XmlDom.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IXMLDOMEntityNotImpl :
	public IXMLDOMEntity
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IXMLDOMEntityNotImpl)

public:

	typedef IXMLDOMEntity Interface;

	STDMETHOD(get_publicId)(
		/*[out,retval]*/ VARIANT* /*publicID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_systemId)(
		/*[out,retval]*/ VARIANT* /*systemID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_notationName)(
		/*[out,retval]*/ BSTR* /*name*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeName)(
		/*[out,retval]*/ BSTR* /*name*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeValue)(
		/*[out,retval]*/ VARIANT* /*value*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_nodeValue)(
		/*[in]*/ VARIANT /*value*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeType)(
		/*[out,retval]*/ DOMNodeType* /*type*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_parentNode)(
		/*[out,retval]*/ IXMLDOMNode** /*parent*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_childNodes)(
		/*[out,retval]*/ IXMLDOMNodeList** /*childList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_firstChild)(
		/*[out,retval]*/ IXMLDOMNode** /*firstChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_lastChild)(
		/*[out,retval]*/ IXMLDOMNode** /*lastChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_previousSibling)(
		/*[out,retval]*/ IXMLDOMNode** /*previousSibling*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nextSibling)(
		/*[out,retval]*/ IXMLDOMNode** /*nextSibling*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_attributes)(
		/*[out,retval]*/ IXMLDOMNamedNodeMap** /*attributeMap*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(insertBefore)(
		/*[in]*/ IXMLDOMNode* /*newChild*/,
		/*[in]*/ VARIANT /*refChild*/,
		/*[out,retval]*/ IXMLDOMNode** /*outNewChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(replaceChild)(
		/*[in]*/ IXMLDOMNode* /*newChild*/,
		/*[in]*/ IXMLDOMNode* /*oldChild*/,
		/*[out,retval]*/ IXMLDOMNode** /*outOldChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(removeChild)(
		/*[in]*/ IXMLDOMNode* /*childNode*/,
		/*[out,retval]*/ IXMLDOMNode** /*oldChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(appendChild)(
		/*[in]*/ IXMLDOMNode* /*newChild*/,
		/*[out,retval]*/ IXMLDOMNode** /*outNewChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(hasChildNodes)(
		/*[out,retval]*/ VARIANT_BOOL* /*hasChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ownerDocument)(
		/*[out,retval]*/ IXMLDOMDocument** /*DOMDocument*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(cloneNode)(
		/*[in]*/ VARIANT_BOOL /*deep*/,
		/*[out,retval]*/ IXMLDOMNode** /*cloneRoot*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeTypeString)(
		/*[retval,out]*/ BSTR* /*nodeType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_text)(
		/*[retval,out]*/ BSTR* /*text*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_text)(
		/*[in]*/ BSTR /*text*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_specified)(
		/*[out,retval]*/ VARIANT_BOOL* /*isSpecified*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_definition)(
		/*[retval,out]*/ IXMLDOMNode** /*definitionNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeTypedValue)(
		/*[retval,out]*/ VARIANT* /*typedValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_nodeTypedValue)(
		/*[in]*/ VARIANT /*typedValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_dataType)(
		/*[retval,out]*/ VARIANT* /*dataTypeName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_dataType)(
		/*[in]*/ BSTR /*dataTypeName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_xml)(
		/*[retval,out]*/ BSTR* /*xmlString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(transformNode)(
		/*[in]*/ IXMLDOMNode* /*stylesheet*/,
		/*[retval,out]*/ BSTR* /*xmlString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(selectNodes)(
		/*[in]*/ BSTR /*queryString*/,
		/*[retval,out]*/ IXMLDOMNodeList** /*resultList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(selectSingleNode)(
		/*[in]*/ BSTR /*queryString*/,
		/*[retval,out]*/ IXMLDOMNode** /*resultNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_parsed)(
		/*[retval,out]*/ VARIANT_BOOL* /*isParsed*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_namespaceURI)(
		/*[retval,out]*/ BSTR* /*namespaceURI*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_prefix)(
		/*[retval,out]*/ BSTR* /*prefixString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_baseName)(
		/*[retval,out]*/ BSTR* /*nameString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(transformNodeToObject)(
		/*[in]*/ IXMLDOMNode* /*stylesheet*/,
		/*[in]*/ VARIANT /*outputObject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class IXMLDOMEntityMockImpl :
	public IXMLDOMEntity,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IXMLDOMEntityMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IXMLDOMEntityMockImpl)

	typedef IXMLDOMEntity Interface;
	struct get_publicIdValidValues
	{
		/*[out,retval]*/ VARIANT* publicID;
		HRESULT retValue;
	};

	STDMETHOD(get_publicId)(
		/*[out,retval]*/ VARIANT* publicID)
	{
		VSL_DEFINE_MOCK_METHOD(get_publicId)

		VSL_SET_VALIDVALUE_VARIANT(publicID);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_systemIdValidValues
	{
		/*[out,retval]*/ VARIANT* systemID;
		HRESULT retValue;
	};

	STDMETHOD(get_systemId)(
		/*[out,retval]*/ VARIANT* systemID)
	{
		VSL_DEFINE_MOCK_METHOD(get_systemId)

		VSL_SET_VALIDVALUE_VARIANT(systemID);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_notationNameValidValues
	{
		/*[out,retval]*/ BSTR* name;
		HRESULT retValue;
	};

	STDMETHOD(get_notationName)(
		/*[out,retval]*/ BSTR* name)
	{
		VSL_DEFINE_MOCK_METHOD(get_notationName)

		VSL_SET_VALIDVALUE_BSTR(name);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeNameValidValues
	{
		/*[out,retval]*/ BSTR* name;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeName)(
		/*[out,retval]*/ BSTR* name)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeName)

		VSL_SET_VALIDVALUE_BSTR(name);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeValueValidValues
	{
		/*[out,retval]*/ VARIANT* value;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeValue)(
		/*[out,retval]*/ VARIANT* value)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeValue)

		VSL_SET_VALIDVALUE_VARIANT(value);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_nodeValueValidValues
	{
		/*[in]*/ VARIANT value;
		HRESULT retValue;
	};

	STDMETHOD(put_nodeValue)(
		/*[in]*/ VARIANT value)
	{
		VSL_DEFINE_MOCK_METHOD(put_nodeValue)

		VSL_CHECK_VALIDVALUE(value);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeTypeValidValues
	{
		/*[out,retval]*/ DOMNodeType* type;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeType)(
		/*[out,retval]*/ DOMNodeType* type)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeType)

		VSL_SET_VALIDVALUE(type);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_parentNodeValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** parent;
		HRESULT retValue;
	};

	STDMETHOD(get_parentNode)(
		/*[out,retval]*/ IXMLDOMNode** parent)
	{
		VSL_DEFINE_MOCK_METHOD(get_parentNode)

		VSL_SET_VALIDVALUE_INTERFACE(parent);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_childNodesValidValues
	{
		/*[out,retval]*/ IXMLDOMNodeList** childList;
		HRESULT retValue;
	};

	STDMETHOD(get_childNodes)(
		/*[out,retval]*/ IXMLDOMNodeList** childList)
	{
		VSL_DEFINE_MOCK_METHOD(get_childNodes)

		VSL_SET_VALIDVALUE_INTERFACE(childList);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_firstChildValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** firstChild;
		HRESULT retValue;
	};

	STDMETHOD(get_firstChild)(
		/*[out,retval]*/ IXMLDOMNode** firstChild)
	{
		VSL_DEFINE_MOCK_METHOD(get_firstChild)

		VSL_SET_VALIDVALUE_INTERFACE(firstChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_lastChildValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** lastChild;
		HRESULT retValue;
	};

	STDMETHOD(get_lastChild)(
		/*[out,retval]*/ IXMLDOMNode** lastChild)
	{
		VSL_DEFINE_MOCK_METHOD(get_lastChild)

		VSL_SET_VALIDVALUE_INTERFACE(lastChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_previousSiblingValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** previousSibling;
		HRESULT retValue;
	};

	STDMETHOD(get_previousSibling)(
		/*[out,retval]*/ IXMLDOMNode** previousSibling)
	{
		VSL_DEFINE_MOCK_METHOD(get_previousSibling)

		VSL_SET_VALIDVALUE_INTERFACE(previousSibling);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nextSiblingValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** nextSibling;
		HRESULT retValue;
	};

	STDMETHOD(get_nextSibling)(
		/*[out,retval]*/ IXMLDOMNode** nextSibling)
	{
		VSL_DEFINE_MOCK_METHOD(get_nextSibling)

		VSL_SET_VALIDVALUE_INTERFACE(nextSibling);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_attributesValidValues
	{
		/*[out,retval]*/ IXMLDOMNamedNodeMap** attributeMap;
		HRESULT retValue;
	};

	STDMETHOD(get_attributes)(
		/*[out,retval]*/ IXMLDOMNamedNodeMap** attributeMap)
	{
		VSL_DEFINE_MOCK_METHOD(get_attributes)

		VSL_SET_VALIDVALUE_INTERFACE(attributeMap);

		VSL_RETURN_VALIDVALUES();
	}
	struct insertBeforeValidValues
	{
		/*[in]*/ IXMLDOMNode* newChild;
		/*[in]*/ VARIANT refChild;
		/*[out,retval]*/ IXMLDOMNode** outNewChild;
		HRESULT retValue;
	};

	STDMETHOD(insertBefore)(
		/*[in]*/ IXMLDOMNode* newChild,
		/*[in]*/ VARIANT refChild,
		/*[out,retval]*/ IXMLDOMNode** outNewChild)
	{
		VSL_DEFINE_MOCK_METHOD(insertBefore)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(newChild);

		VSL_CHECK_VALIDVALUE(refChild);

		VSL_SET_VALIDVALUE_INTERFACE(outNewChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct replaceChildValidValues
	{
		/*[in]*/ IXMLDOMNode* newChild;
		/*[in]*/ IXMLDOMNode* oldChild;
		/*[out,retval]*/ IXMLDOMNode** outOldChild;
		HRESULT retValue;
	};

	STDMETHOD(replaceChild)(
		/*[in]*/ IXMLDOMNode* newChild,
		/*[in]*/ IXMLDOMNode* oldChild,
		/*[out,retval]*/ IXMLDOMNode** outOldChild)
	{
		VSL_DEFINE_MOCK_METHOD(replaceChild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(newChild);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(oldChild);

		VSL_SET_VALIDVALUE_INTERFACE(outOldChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct removeChildValidValues
	{
		/*[in]*/ IXMLDOMNode* childNode;
		/*[out,retval]*/ IXMLDOMNode** oldChild;
		HRESULT retValue;
	};

	STDMETHOD(removeChild)(
		/*[in]*/ IXMLDOMNode* childNode,
		/*[out,retval]*/ IXMLDOMNode** oldChild)
	{
		VSL_DEFINE_MOCK_METHOD(removeChild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(childNode);

		VSL_SET_VALIDVALUE_INTERFACE(oldChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct appendChildValidValues
	{
		/*[in]*/ IXMLDOMNode* newChild;
		/*[out,retval]*/ IXMLDOMNode** outNewChild;
		HRESULT retValue;
	};

	STDMETHOD(appendChild)(
		/*[in]*/ IXMLDOMNode* newChild,
		/*[out,retval]*/ IXMLDOMNode** outNewChild)
	{
		VSL_DEFINE_MOCK_METHOD(appendChild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(newChild);

		VSL_SET_VALIDVALUE_INTERFACE(outNewChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct hasChildNodesValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* hasChild;
		HRESULT retValue;
	};

	STDMETHOD(hasChildNodes)(
		/*[out,retval]*/ VARIANT_BOOL* hasChild)
	{
		VSL_DEFINE_MOCK_METHOD(hasChildNodes)

		VSL_SET_VALIDVALUE(hasChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ownerDocumentValidValues
	{
		/*[out,retval]*/ IXMLDOMDocument** DOMDocument;
		HRESULT retValue;
	};

	STDMETHOD(get_ownerDocument)(
		/*[out,retval]*/ IXMLDOMDocument** DOMDocument)
	{
		VSL_DEFINE_MOCK_METHOD(get_ownerDocument)

		VSL_SET_VALIDVALUE_INTERFACE(DOMDocument);

		VSL_RETURN_VALIDVALUES();
	}
	struct cloneNodeValidValues
	{
		/*[in]*/ VARIANT_BOOL deep;
		/*[out,retval]*/ IXMLDOMNode** cloneRoot;
		HRESULT retValue;
	};

	STDMETHOD(cloneNode)(
		/*[in]*/ VARIANT_BOOL deep,
		/*[out,retval]*/ IXMLDOMNode** cloneRoot)
	{
		VSL_DEFINE_MOCK_METHOD(cloneNode)

		VSL_CHECK_VALIDVALUE(deep);

		VSL_SET_VALIDVALUE_INTERFACE(cloneRoot);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeTypeStringValidValues
	{
		/*[retval,out]*/ BSTR* nodeType;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeTypeString)(
		/*[retval,out]*/ BSTR* nodeType)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeTypeString)

		VSL_SET_VALIDVALUE_BSTR(nodeType);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_textValidValues
	{
		/*[retval,out]*/ BSTR* text;
		HRESULT retValue;
	};

	STDMETHOD(get_text)(
		/*[retval,out]*/ BSTR* text)
	{
		VSL_DEFINE_MOCK_METHOD(get_text)

		VSL_SET_VALIDVALUE_BSTR(text);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_textValidValues
	{
		/*[in]*/ BSTR text;
		HRESULT retValue;
	};

	STDMETHOD(put_text)(
		/*[in]*/ BSTR text)
	{
		VSL_DEFINE_MOCK_METHOD(put_text)

		VSL_CHECK_VALIDVALUE_BSTR(text);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_specifiedValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* isSpecified;
		HRESULT retValue;
	};

	STDMETHOD(get_specified)(
		/*[out,retval]*/ VARIANT_BOOL* isSpecified)
	{
		VSL_DEFINE_MOCK_METHOD(get_specified)

		VSL_SET_VALIDVALUE(isSpecified);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_definitionValidValues
	{
		/*[retval,out]*/ IXMLDOMNode** definitionNode;
		HRESULT retValue;
	};

	STDMETHOD(get_definition)(
		/*[retval,out]*/ IXMLDOMNode** definitionNode)
	{
		VSL_DEFINE_MOCK_METHOD(get_definition)

		VSL_SET_VALIDVALUE_INTERFACE(definitionNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeTypedValueValidValues
	{
		/*[retval,out]*/ VARIANT* typedValue;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeTypedValue)(
		/*[retval,out]*/ VARIANT* typedValue)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeTypedValue)

		VSL_SET_VALIDVALUE_VARIANT(typedValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_nodeTypedValueValidValues
	{
		/*[in]*/ VARIANT typedValue;
		HRESULT retValue;
	};

	STDMETHOD(put_nodeTypedValue)(
		/*[in]*/ VARIANT typedValue)
	{
		VSL_DEFINE_MOCK_METHOD(put_nodeTypedValue)

		VSL_CHECK_VALIDVALUE(typedValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_dataTypeValidValues
	{
		/*[retval,out]*/ VARIANT* dataTypeName;
		HRESULT retValue;
	};

	STDMETHOD(get_dataType)(
		/*[retval,out]*/ VARIANT* dataTypeName)
	{
		VSL_DEFINE_MOCK_METHOD(get_dataType)

		VSL_SET_VALIDVALUE_VARIANT(dataTypeName);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_dataTypeValidValues
	{
		/*[in]*/ BSTR dataTypeName;
		HRESULT retValue;
	};

	STDMETHOD(put_dataType)(
		/*[in]*/ BSTR dataTypeName)
	{
		VSL_DEFINE_MOCK_METHOD(put_dataType)

		VSL_CHECK_VALIDVALUE_BSTR(dataTypeName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_xmlValidValues
	{
		/*[retval,out]*/ BSTR* xmlString;
		HRESULT retValue;
	};

	STDMETHOD(get_xml)(
		/*[retval,out]*/ BSTR* xmlString)
	{
		VSL_DEFINE_MOCK_METHOD(get_xml)

		VSL_SET_VALIDVALUE_BSTR(xmlString);

		VSL_RETURN_VALIDVALUES();
	}
	struct transformNodeValidValues
	{
		/*[in]*/ IXMLDOMNode* stylesheet;
		/*[retval,out]*/ BSTR* xmlString;
		HRESULT retValue;
	};

	STDMETHOD(transformNode)(
		/*[in]*/ IXMLDOMNode* stylesheet,
		/*[retval,out]*/ BSTR* xmlString)
	{
		VSL_DEFINE_MOCK_METHOD(transformNode)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(stylesheet);

		VSL_SET_VALIDVALUE_BSTR(xmlString);

		VSL_RETURN_VALIDVALUES();
	}
	struct selectNodesValidValues
	{
		/*[in]*/ BSTR queryString;
		/*[retval,out]*/ IXMLDOMNodeList** resultList;
		HRESULT retValue;
	};

	STDMETHOD(selectNodes)(
		/*[in]*/ BSTR queryString,
		/*[retval,out]*/ IXMLDOMNodeList** resultList)
	{
		VSL_DEFINE_MOCK_METHOD(selectNodes)

		VSL_CHECK_VALIDVALUE_BSTR(queryString);

		VSL_SET_VALIDVALUE_INTERFACE(resultList);

		VSL_RETURN_VALIDVALUES();
	}
	struct selectSingleNodeValidValues
	{
		/*[in]*/ BSTR queryString;
		/*[retval,out]*/ IXMLDOMNode** resultNode;
		HRESULT retValue;
	};

	STDMETHOD(selectSingleNode)(
		/*[in]*/ BSTR queryString,
		/*[retval,out]*/ IXMLDOMNode** resultNode)
	{
		VSL_DEFINE_MOCK_METHOD(selectSingleNode)

		VSL_CHECK_VALIDVALUE_BSTR(queryString);

		VSL_SET_VALIDVALUE_INTERFACE(resultNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_parsedValidValues
	{
		/*[retval,out]*/ VARIANT_BOOL* isParsed;
		HRESULT retValue;
	};

	STDMETHOD(get_parsed)(
		/*[retval,out]*/ VARIANT_BOOL* isParsed)
	{
		VSL_DEFINE_MOCK_METHOD(get_parsed)

		VSL_SET_VALIDVALUE(isParsed);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_namespaceURIValidValues
	{
		/*[retval,out]*/ BSTR* namespaceURI;
		HRESULT retValue;
	};

	STDMETHOD(get_namespaceURI)(
		/*[retval,out]*/ BSTR* namespaceURI)
	{
		VSL_DEFINE_MOCK_METHOD(get_namespaceURI)

		VSL_SET_VALIDVALUE_BSTR(namespaceURI);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_prefixValidValues
	{
		/*[retval,out]*/ BSTR* prefixString;
		HRESULT retValue;
	};

	STDMETHOD(get_prefix)(
		/*[retval,out]*/ BSTR* prefixString)
	{
		VSL_DEFINE_MOCK_METHOD(get_prefix)

		VSL_SET_VALIDVALUE_BSTR(prefixString);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_baseNameValidValues
	{
		/*[retval,out]*/ BSTR* nameString;
		HRESULT retValue;
	};

	STDMETHOD(get_baseName)(
		/*[retval,out]*/ BSTR* nameString)
	{
		VSL_DEFINE_MOCK_METHOD(get_baseName)

		VSL_SET_VALIDVALUE_BSTR(nameString);

		VSL_RETURN_VALIDVALUES();
	}
	struct transformNodeToObjectValidValues
	{
		/*[in]*/ IXMLDOMNode* stylesheet;
		/*[in]*/ VARIANT outputObject;
		HRESULT retValue;
	};

	STDMETHOD(transformNodeToObject)(
		/*[in]*/ IXMLDOMNode* stylesheet,
		/*[in]*/ VARIANT outputObject)
	{
		VSL_DEFINE_MOCK_METHOD(transformNodeToObject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(stylesheet);

		VSL_CHECK_VALIDVALUE(outputObject);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IXMLDOMENTITY_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIXMLDOMImplementation.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IXMLDOMIMPLEMENTATION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IXMLDOMIMPLEMENTATION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "XmlDom.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IXMLDOMImplementationNotImpl :
	public IXMLDOMImplementation
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IXMLDOMImplementationNotImpl)

public:

	typedef IXMLDOMImplementation Interface;

	STDMETHOD(hasFeature)(
		/*[in]*/ BSTR /*feature*/,
		/*[in]*/ BSTR /*version*/,
		/*[out,retval]*/ VARIANT_BOOL* /*hasFeature*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class IXMLDOMImplementationMockImpl :
	public IXMLDOMImplementation,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IXMLDOMImplementationMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IXMLDOMImplementationMockImpl)

	typedef IXMLDOMImplementation Interface;
	struct hasFeatureValidValues
	{
		/*[in]*/ BSTR feature;
		/*[in]*/ BSTR version;
		/*[out,retval]*/ VARIANT_BOOL* hasFeature;
		HRESULT retValue;
	};

	STDMETHOD(hasFeature)(
		/*[in]*/ BSTR feature,
		/*[in]*/ BSTR version,
		/*[out,retval]*/ VARIANT_BOOL* hasFeature)
	{
		VSL_DEFINE_MOCK_METHOD(hasFeature)

		VSL_CHECK_VALIDVALUE_BSTR(feature);

		VSL_CHECK_VALIDVALUE_BSTR(version);

		VSL_SET_VALIDVALUE(hasFeature);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IXMLDOMIMPLEMENTATION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIXMLDOMEntityReference.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IXMLDOMENTITYREFERENCE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IXMLDOMENTITYREFERENCE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "XmlDom.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IXMLDOMEntityReferenceNotImpl :
	public IXMLDOMEntityReference
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IXMLDOMEntityReferenceNotImpl)

public:

	typedef IXMLDOMEntityReference Interface;

	STDMETHOD(get_nodeName)(
		/*[out,retval]*/ BSTR* /*name*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeValue)(
		/*[out,retval]*/ VARIANT* /*value*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_nodeValue)(
		/*[in]*/ VARIANT /*value*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeType)(
		/*[out,retval]*/ DOMNodeType* /*type*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_parentNode)(
		/*[out,retval]*/ IXMLDOMNode** /*parent*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_childNodes)(
		/*[out,retval]*/ IXMLDOMNodeList** /*childList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_firstChild)(
		/*[out,retval]*/ IXMLDOMNode** /*firstChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_lastChild)(
		/*[out,retval]*/ IXMLDOMNode** /*lastChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_previousSibling)(
		/*[out,retval]*/ IXMLDOMNode** /*previousSibling*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nextSibling)(
		/*[out,retval]*/ IXMLDOMNode** /*nextSibling*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_attributes)(
		/*[out,retval]*/ IXMLDOMNamedNodeMap** /*attributeMap*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(insertBefore)(
		/*[in]*/ IXMLDOMNode* /*newChild*/,
		/*[in]*/ VARIANT /*refChild*/,
		/*[out,retval]*/ IXMLDOMNode** /*outNewChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(replaceChild)(
		/*[in]*/ IXMLDOMNode* /*newChild*/,
		/*[in]*/ IXMLDOMNode* /*oldChild*/,
		/*[out,retval]*/ IXMLDOMNode** /*outOldChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(removeChild)(
		/*[in]*/ IXMLDOMNode* /*childNode*/,
		/*[out,retval]*/ IXMLDOMNode** /*oldChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(appendChild)(
		/*[in]*/ IXMLDOMNode* /*newChild*/,
		/*[out,retval]*/ IXMLDOMNode** /*outNewChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(hasChildNodes)(
		/*[out,retval]*/ VARIANT_BOOL* /*hasChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ownerDocument)(
		/*[out,retval]*/ IXMLDOMDocument** /*DOMDocument*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(cloneNode)(
		/*[in]*/ VARIANT_BOOL /*deep*/,
		/*[out,retval]*/ IXMLDOMNode** /*cloneRoot*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeTypeString)(
		/*[retval,out]*/ BSTR* /*nodeType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_text)(
		/*[retval,out]*/ BSTR* /*text*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_text)(
		/*[in]*/ BSTR /*text*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_specified)(
		/*[out,retval]*/ VARIANT_BOOL* /*isSpecified*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_definition)(
		/*[retval,out]*/ IXMLDOMNode** /*definitionNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeTypedValue)(
		/*[retval,out]*/ VARIANT* /*typedValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_nodeTypedValue)(
		/*[in]*/ VARIANT /*typedValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_dataType)(
		/*[retval,out]*/ VARIANT* /*dataTypeName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_dataType)(
		/*[in]*/ BSTR /*dataTypeName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_xml)(
		/*[retval,out]*/ BSTR* /*xmlString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(transformNode)(
		/*[in]*/ IXMLDOMNode* /*stylesheet*/,
		/*[retval,out]*/ BSTR* /*xmlString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(selectNodes)(
		/*[in]*/ BSTR /*queryString*/,
		/*[retval,out]*/ IXMLDOMNodeList** /*resultList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(selectSingleNode)(
		/*[in]*/ BSTR /*queryString*/,
		/*[retval,out]*/ IXMLDOMNode** /*resultNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_parsed)(
		/*[retval,out]*/ VARIANT_BOOL* /*isParsed*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_namespaceURI)(
		/*[retval,out]*/ BSTR* /*namespaceURI*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_prefix)(
		/*[retval,out]*/ BSTR* /*prefixString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_baseName)(
		/*[retval,out]*/ BSTR* /*nameString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(transformNodeToObject)(
		/*[in]*/ IXMLDOMNode* /*stylesheet*/,
		/*[in]*/ VARIANT /*outputObject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class IXMLDOMEntityReferenceMockImpl :
	public IXMLDOMEntityReference,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IXMLDOMEntityReferenceMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IXMLDOMEntityReferenceMockImpl)

	typedef IXMLDOMEntityReference Interface;
	struct get_nodeNameValidValues
	{
		/*[out,retval]*/ BSTR* name;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeName)(
		/*[out,retval]*/ BSTR* name)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeName)

		VSL_SET_VALIDVALUE_BSTR(name);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeValueValidValues
	{
		/*[out,retval]*/ VARIANT* value;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeValue)(
		/*[out,retval]*/ VARIANT* value)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeValue)

		VSL_SET_VALIDVALUE_VARIANT(value);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_nodeValueValidValues
	{
		/*[in]*/ VARIANT value;
		HRESULT retValue;
	};

	STDMETHOD(put_nodeValue)(
		/*[in]*/ VARIANT value)
	{
		VSL_DEFINE_MOCK_METHOD(put_nodeValue)

		VSL_CHECK_VALIDVALUE(value);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeTypeValidValues
	{
		/*[out,retval]*/ DOMNodeType* type;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeType)(
		/*[out,retval]*/ DOMNodeType* type)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeType)

		VSL_SET_VALIDVALUE(type);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_parentNodeValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** parent;
		HRESULT retValue;
	};

	STDMETHOD(get_parentNode)(
		/*[out,retval]*/ IXMLDOMNode** parent)
	{
		VSL_DEFINE_MOCK_METHOD(get_parentNode)

		VSL_SET_VALIDVALUE_INTERFACE(parent);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_childNodesValidValues
	{
		/*[out,retval]*/ IXMLDOMNodeList** childList;
		HRESULT retValue;
	};

	STDMETHOD(get_childNodes)(
		/*[out,retval]*/ IXMLDOMNodeList** childList)
	{
		VSL_DEFINE_MOCK_METHOD(get_childNodes)

		VSL_SET_VALIDVALUE_INTERFACE(childList);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_firstChildValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** firstChild;
		HRESULT retValue;
	};

	STDMETHOD(get_firstChild)(
		/*[out,retval]*/ IXMLDOMNode** firstChild)
	{
		VSL_DEFINE_MOCK_METHOD(get_firstChild)

		VSL_SET_VALIDVALUE_INTERFACE(firstChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_lastChildValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** lastChild;
		HRESULT retValue;
	};

	STDMETHOD(get_lastChild)(
		/*[out,retval]*/ IXMLDOMNode** lastChild)
	{
		VSL_DEFINE_MOCK_METHOD(get_lastChild)

		VSL_SET_VALIDVALUE_INTERFACE(lastChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_previousSiblingValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** previousSibling;
		HRESULT retValue;
	};

	STDMETHOD(get_previousSibling)(
		/*[out,retval]*/ IXMLDOMNode** previousSibling)
	{
		VSL_DEFINE_MOCK_METHOD(get_previousSibling)

		VSL_SET_VALIDVALUE_INTERFACE(previousSibling);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nextSiblingValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** nextSibling;
		HRESULT retValue;
	};

	STDMETHOD(get_nextSibling)(
		/*[out,retval]*/ IXMLDOMNode** nextSibling)
	{
		VSL_DEFINE_MOCK_METHOD(get_nextSibling)

		VSL_SET_VALIDVALUE_INTERFACE(nextSibling);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_attributesValidValues
	{
		/*[out,retval]*/ IXMLDOMNamedNodeMap** attributeMap;
		HRESULT retValue;
	};

	STDMETHOD(get_attributes)(
		/*[out,retval]*/ IXMLDOMNamedNodeMap** attributeMap)
	{
		VSL_DEFINE_MOCK_METHOD(get_attributes)

		VSL_SET_VALIDVALUE_INTERFACE(attributeMap);

		VSL_RETURN_VALIDVALUES();
	}
	struct insertBeforeValidValues
	{
		/*[in]*/ IXMLDOMNode* newChild;
		/*[in]*/ VARIANT refChild;
		/*[out,retval]*/ IXMLDOMNode** outNewChild;
		HRESULT retValue;
	};

	STDMETHOD(insertBefore)(
		/*[in]*/ IXMLDOMNode* newChild,
		/*[in]*/ VARIANT refChild,
		/*[out,retval]*/ IXMLDOMNode** outNewChild)
	{
		VSL_DEFINE_MOCK_METHOD(insertBefore)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(newChild);

		VSL_CHECK_VALIDVALUE(refChild);

		VSL_SET_VALIDVALUE_INTERFACE(outNewChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct replaceChildValidValues
	{
		/*[in]*/ IXMLDOMNode* newChild;
		/*[in]*/ IXMLDOMNode* oldChild;
		/*[out,retval]*/ IXMLDOMNode** outOldChild;
		HRESULT retValue;
	};

	STDMETHOD(replaceChild)(
		/*[in]*/ IXMLDOMNode* newChild,
		/*[in]*/ IXMLDOMNode* oldChild,
		/*[out,retval]*/ IXMLDOMNode** outOldChild)
	{
		VSL_DEFINE_MOCK_METHOD(replaceChild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(newChild);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(oldChild);

		VSL_SET_VALIDVALUE_INTERFACE(outOldChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct removeChildValidValues
	{
		/*[in]*/ IXMLDOMNode* childNode;
		/*[out,retval]*/ IXMLDOMNode** oldChild;
		HRESULT retValue;
	};

	STDMETHOD(removeChild)(
		/*[in]*/ IXMLDOMNode* childNode,
		/*[out,retval]*/ IXMLDOMNode** oldChild)
	{
		VSL_DEFINE_MOCK_METHOD(removeChild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(childNode);

		VSL_SET_VALIDVALUE_INTERFACE(oldChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct appendChildValidValues
	{
		/*[in]*/ IXMLDOMNode* newChild;
		/*[out,retval]*/ IXMLDOMNode** outNewChild;
		HRESULT retValue;
	};

	STDMETHOD(appendChild)(
		/*[in]*/ IXMLDOMNode* newChild,
		/*[out,retval]*/ IXMLDOMNode** outNewChild)
	{
		VSL_DEFINE_MOCK_METHOD(appendChild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(newChild);

		VSL_SET_VALIDVALUE_INTERFACE(outNewChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct hasChildNodesValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* hasChild;
		HRESULT retValue;
	};

	STDMETHOD(hasChildNodes)(
		/*[out,retval]*/ VARIANT_BOOL* hasChild)
	{
		VSL_DEFINE_MOCK_METHOD(hasChildNodes)

		VSL_SET_VALIDVALUE(hasChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ownerDocumentValidValues
	{
		/*[out,retval]*/ IXMLDOMDocument** DOMDocument;
		HRESULT retValue;
	};

	STDMETHOD(get_ownerDocument)(
		/*[out,retval]*/ IXMLDOMDocument** DOMDocument)
	{
		VSL_DEFINE_MOCK_METHOD(get_ownerDocument)

		VSL_SET_VALIDVALUE_INTERFACE(DOMDocument);

		VSL_RETURN_VALIDVALUES();
	}
	struct cloneNodeValidValues
	{
		/*[in]*/ VARIANT_BOOL deep;
		/*[out,retval]*/ IXMLDOMNode** cloneRoot;
		HRESULT retValue;
	};

	STDMETHOD(cloneNode)(
		/*[in]*/ VARIANT_BOOL deep,
		/*[out,retval]*/ IXMLDOMNode** cloneRoot)
	{
		VSL_DEFINE_MOCK_METHOD(cloneNode)

		VSL_CHECK_VALIDVALUE(deep);

		VSL_SET_VALIDVALUE_INTERFACE(cloneRoot);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeTypeStringValidValues
	{
		/*[retval,out]*/ BSTR* nodeType;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeTypeString)(
		/*[retval,out]*/ BSTR* nodeType)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeTypeString)

		VSL_SET_VALIDVALUE_BSTR(nodeType);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_textValidValues
	{
		/*[retval,out]*/ BSTR* text;
		HRESULT retValue;
	};

	STDMETHOD(get_text)(
		/*[retval,out]*/ BSTR* text)
	{
		VSL_DEFINE_MOCK_METHOD(get_text)

		VSL_SET_VALIDVALUE_BSTR(text);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_textValidValues
	{
		/*[in]*/ BSTR text;
		HRESULT retValue;
	};

	STDMETHOD(put_text)(
		/*[in]*/ BSTR text)
	{
		VSL_DEFINE_MOCK_METHOD(put_text)

		VSL_CHECK_VALIDVALUE_BSTR(text);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_specifiedValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* isSpecified;
		HRESULT retValue;
	};

	STDMETHOD(get_specified)(
		/*[out,retval]*/ VARIANT_BOOL* isSpecified)
	{
		VSL_DEFINE_MOCK_METHOD(get_specified)

		VSL_SET_VALIDVALUE(isSpecified);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_definitionValidValues
	{
		/*[retval,out]*/ IXMLDOMNode** definitionNode;
		HRESULT retValue;
	};

	STDMETHOD(get_definition)(
		/*[retval,out]*/ IXMLDOMNode** definitionNode)
	{
		VSL_DEFINE_MOCK_METHOD(get_definition)

		VSL_SET_VALIDVALUE_INTERFACE(definitionNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeTypedValueValidValues
	{
		/*[retval,out]*/ VARIANT* typedValue;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeTypedValue)(
		/*[retval,out]*/ VARIANT* typedValue)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeTypedValue)

		VSL_SET_VALIDVALUE_VARIANT(typedValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_nodeTypedValueValidValues
	{
		/*[in]*/ VARIANT typedValue;
		HRESULT retValue;
	};

	STDMETHOD(put_nodeTypedValue)(
		/*[in]*/ VARIANT typedValue)
	{
		VSL_DEFINE_MOCK_METHOD(put_nodeTypedValue)

		VSL_CHECK_VALIDVALUE(typedValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_dataTypeValidValues
	{
		/*[retval,out]*/ VARIANT* dataTypeName;
		HRESULT retValue;
	};

	STDMETHOD(get_dataType)(
		/*[retval,out]*/ VARIANT* dataTypeName)
	{
		VSL_DEFINE_MOCK_METHOD(get_dataType)

		VSL_SET_VALIDVALUE_VARIANT(dataTypeName);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_dataTypeValidValues
	{
		/*[in]*/ BSTR dataTypeName;
		HRESULT retValue;
	};

	STDMETHOD(put_dataType)(
		/*[in]*/ BSTR dataTypeName)
	{
		VSL_DEFINE_MOCK_METHOD(put_dataType)

		VSL_CHECK_VALIDVALUE_BSTR(dataTypeName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_xmlValidValues
	{
		/*[retval,out]*/ BSTR* xmlString;
		HRESULT retValue;
	};

	STDMETHOD(get_xml)(
		/*[retval,out]*/ BSTR* xmlString)
	{
		VSL_DEFINE_MOCK_METHOD(get_xml)

		VSL_SET_VALIDVALUE_BSTR(xmlString);

		VSL_RETURN_VALIDVALUES();
	}
	struct transformNodeValidValues
	{
		/*[in]*/ IXMLDOMNode* stylesheet;
		/*[retval,out]*/ BSTR* xmlString;
		HRESULT retValue;
	};

	STDMETHOD(transformNode)(
		/*[in]*/ IXMLDOMNode* stylesheet,
		/*[retval,out]*/ BSTR* xmlString)
	{
		VSL_DEFINE_MOCK_METHOD(transformNode)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(stylesheet);

		VSL_SET_VALIDVALUE_BSTR(xmlString);

		VSL_RETURN_VALIDVALUES();
	}
	struct selectNodesValidValues
	{
		/*[in]*/ BSTR queryString;
		/*[retval,out]*/ IXMLDOMNodeList** resultList;
		HRESULT retValue;
	};

	STDMETHOD(selectNodes)(
		/*[in]*/ BSTR queryString,
		/*[retval,out]*/ IXMLDOMNodeList** resultList)
	{
		VSL_DEFINE_MOCK_METHOD(selectNodes)

		VSL_CHECK_VALIDVALUE_BSTR(queryString);

		VSL_SET_VALIDVALUE_INTERFACE(resultList);

		VSL_RETURN_VALIDVALUES();
	}
	struct selectSingleNodeValidValues
	{
		/*[in]*/ BSTR queryString;
		/*[retval,out]*/ IXMLDOMNode** resultNode;
		HRESULT retValue;
	};

	STDMETHOD(selectSingleNode)(
		/*[in]*/ BSTR queryString,
		/*[retval,out]*/ IXMLDOMNode** resultNode)
	{
		VSL_DEFINE_MOCK_METHOD(selectSingleNode)

		VSL_CHECK_VALIDVALUE_BSTR(queryString);

		VSL_SET_VALIDVALUE_INTERFACE(resultNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_parsedValidValues
	{
		/*[retval,out]*/ VARIANT_BOOL* isParsed;
		HRESULT retValue;
	};

	STDMETHOD(get_parsed)(
		/*[retval,out]*/ VARIANT_BOOL* isParsed)
	{
		VSL_DEFINE_MOCK_METHOD(get_parsed)

		VSL_SET_VALIDVALUE(isParsed);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_namespaceURIValidValues
	{
		/*[retval,out]*/ BSTR* namespaceURI;
		HRESULT retValue;
	};

	STDMETHOD(get_namespaceURI)(
		/*[retval,out]*/ BSTR* namespaceURI)
	{
		VSL_DEFINE_MOCK_METHOD(get_namespaceURI)

		VSL_SET_VALIDVALUE_BSTR(namespaceURI);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_prefixValidValues
	{
		/*[retval,out]*/ BSTR* prefixString;
		HRESULT retValue;
	};

	STDMETHOD(get_prefix)(
		/*[retval,out]*/ BSTR* prefixString)
	{
		VSL_DEFINE_MOCK_METHOD(get_prefix)

		VSL_SET_VALIDVALUE_BSTR(prefixString);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_baseNameValidValues
	{
		/*[retval,out]*/ BSTR* nameString;
		HRESULT retValue;
	};

	STDMETHOD(get_baseName)(
		/*[retval,out]*/ BSTR* nameString)
	{
		VSL_DEFINE_MOCK_METHOD(get_baseName)

		VSL_SET_VALIDVALUE_BSTR(nameString);

		VSL_RETURN_VALIDVALUES();
	}
	struct transformNodeToObjectValidValues
	{
		/*[in]*/ IXMLDOMNode* stylesheet;
		/*[in]*/ VARIANT outputObject;
		HRESULT retValue;
	};

	STDMETHOD(transformNodeToObject)(
		/*[in]*/ IXMLDOMNode* stylesheet,
		/*[in]*/ VARIANT outputObject)
	{
		VSL_DEFINE_MOCK_METHOD(transformNodeToObject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(stylesheet);

		VSL_CHECK_VALIDVALUE(outputObject);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IXMLDOMENTITYREFERENCE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIXMLDOMElement.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IXMLDOMELEMENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IXMLDOMELEMENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "XmlDom.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IXMLDOMElementNotImpl :
	public IXMLDOMElement
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IXMLDOMElementNotImpl)

public:

	typedef IXMLDOMElement Interface;

	STDMETHOD(get_tagName)(
		/*[out,retval]*/ BSTR* /*tagName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(getAttribute)(
		/*[in]*/ BSTR /*name*/,
		/*[out,retval]*/ VARIANT* /*value*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(setAttribute)(
		/*[in]*/ BSTR /*name*/,
		/*[in]*/ VARIANT /*value*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(removeAttribute)(
		/*[in]*/ BSTR /*name*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(getAttributeNode)(
		/*[in]*/ BSTR /*name*/,
		/*[out,retval]*/ IXMLDOMAttribute** /*attributeNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(setAttributeNode)(
		/*[in]*/ IXMLDOMAttribute* /*DOMAttribute*/,
		/*[out,retval]*/ IXMLDOMAttribute** /*attributeNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(removeAttributeNode)(
		/*[in]*/ IXMLDOMAttribute* /*DOMAttribute*/,
		/*[out,retval]*/ IXMLDOMAttribute** /*attributeNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(getElementsByTagName)(
		/*[in]*/ BSTR /*tagName*/,
		/*[out,retval]*/ IXMLDOMNodeList** /*resultList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(normalize)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeName)(
		/*[out,retval]*/ BSTR* /*name*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeValue)(
		/*[out,retval]*/ VARIANT* /*value*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_nodeValue)(
		/*[in]*/ VARIANT /*value*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeType)(
		/*[out,retval]*/ DOMNodeType* /*type*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_parentNode)(
		/*[out,retval]*/ IXMLDOMNode** /*parent*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_childNodes)(
		/*[out,retval]*/ IXMLDOMNodeList** /*childList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_firstChild)(
		/*[out,retval]*/ IXMLDOMNode** /*firstChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_lastChild)(
		/*[out,retval]*/ IXMLDOMNode** /*lastChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_previousSibling)(
		/*[out,retval]*/ IXMLDOMNode** /*previousSibling*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nextSibling)(
		/*[out,retval]*/ IXMLDOMNode** /*nextSibling*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_attributes)(
		/*[out,retval]*/ IXMLDOMNamedNodeMap** /*attributeMap*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(insertBefore)(
		/*[in]*/ IXMLDOMNode* /*newChild*/,
		/*[in]*/ VARIANT /*refChild*/,
		/*[out,retval]*/ IXMLDOMNode** /*outNewChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(replaceChild)(
		/*[in]*/ IXMLDOMNode* /*newChild*/,
		/*[in]*/ IXMLDOMNode* /*oldChild*/,
		/*[out,retval]*/ IXMLDOMNode** /*outOldChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(removeChild)(
		/*[in]*/ IXMLDOMNode* /*childNode*/,
		/*[out,retval]*/ IXMLDOMNode** /*oldChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(appendChild)(
		/*[in]*/ IXMLDOMNode* /*newChild*/,
		/*[out,retval]*/ IXMLDOMNode** /*outNewChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(hasChildNodes)(
		/*[out,retval]*/ VARIANT_BOOL* /*hasChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ownerDocument)(
		/*[out,retval]*/ IXMLDOMDocument** /*DOMDocument*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(cloneNode)(
		/*[in]*/ VARIANT_BOOL /*deep*/,
		/*[out,retval]*/ IXMLDOMNode** /*cloneRoot*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeTypeString)(
		/*[retval,out]*/ BSTR* /*nodeType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_text)(
		/*[retval,out]*/ BSTR* /*text*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_text)(
		/*[in]*/ BSTR /*text*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_specified)(
		/*[out,retval]*/ VARIANT_BOOL* /*isSpecified*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_definition)(
		/*[retval,out]*/ IXMLDOMNode** /*definitionNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeTypedValue)(
		/*[retval,out]*/ VARIANT* /*typedValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_nodeTypedValue)(
		/*[in]*/ VARIANT /*typedValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_dataType)(
		/*[retval,out]*/ VARIANT* /*dataTypeName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_dataType)(
		/*[in]*/ BSTR /*dataTypeName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_xml)(
		/*[retval,out]*/ BSTR* /*xmlString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(transformNode)(
		/*[in]*/ IXMLDOMNode* /*stylesheet*/,
		/*[retval,out]*/ BSTR* /*xmlString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(selectNodes)(
		/*[in]*/ BSTR /*queryString*/,
		/*[retval,out]*/ IXMLDOMNodeList** /*resultList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(selectSingleNode)(
		/*[in]*/ BSTR /*queryString*/,
		/*[retval,out]*/ IXMLDOMNode** /*resultNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_parsed)(
		/*[retval,out]*/ VARIANT_BOOL* /*isParsed*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_namespaceURI)(
		/*[retval,out]*/ BSTR* /*namespaceURI*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_prefix)(
		/*[retval,out]*/ BSTR* /*prefixString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_baseName)(
		/*[retval,out]*/ BSTR* /*nameString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(transformNodeToObject)(
		/*[in]*/ IXMLDOMNode* /*stylesheet*/,
		/*[in]*/ VARIANT /*outputObject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class IXMLDOMElementMockImpl :
	public IXMLDOMElement,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IXMLDOMElementMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IXMLDOMElementMockImpl)

	typedef IXMLDOMElement Interface;
	struct get_tagNameValidValues
	{
		/*[out,retval]*/ BSTR* tagName;
		HRESULT retValue;
	};

	STDMETHOD(get_tagName)(
		/*[out,retval]*/ BSTR* tagName)
	{
		VSL_DEFINE_MOCK_METHOD(get_tagName)

		VSL_SET_VALIDVALUE_BSTR(tagName);

		VSL_RETURN_VALIDVALUES();
	}
	struct getAttributeValidValues
	{
		/*[in]*/ BSTR name;
		/*[out,retval]*/ VARIANT* value;
		HRESULT retValue;
	};

	STDMETHOD(getAttribute)(
		/*[in]*/ BSTR name,
		/*[out,retval]*/ VARIANT* value)
	{
		VSL_DEFINE_MOCK_METHOD(getAttribute)

		VSL_CHECK_VALIDVALUE_BSTR(name);

		VSL_SET_VALIDVALUE_VARIANT(value);

		VSL_RETURN_VALIDVALUES();
	}
	struct setAttributeValidValues
	{
		/*[in]*/ BSTR name;
		/*[in]*/ VARIANT value;
		HRESULT retValue;
	};

	STDMETHOD(setAttribute)(
		/*[in]*/ BSTR name,
		/*[in]*/ VARIANT value)
	{
		VSL_DEFINE_MOCK_METHOD(setAttribute)

		VSL_CHECK_VALIDVALUE_BSTR(name);

		VSL_CHECK_VALIDVALUE(value);

		VSL_RETURN_VALIDVALUES();
	}
	struct removeAttributeValidValues
	{
		/*[in]*/ BSTR name;
		HRESULT retValue;
	};

	STDMETHOD(removeAttribute)(
		/*[in]*/ BSTR name)
	{
		VSL_DEFINE_MOCK_METHOD(removeAttribute)

		VSL_CHECK_VALIDVALUE_BSTR(name);

		VSL_RETURN_VALIDVALUES();
	}
	struct getAttributeNodeValidValues
	{
		/*[in]*/ BSTR name;
		/*[out,retval]*/ IXMLDOMAttribute** attributeNode;
		HRESULT retValue;
	};

	STDMETHOD(getAttributeNode)(
		/*[in]*/ BSTR name,
		/*[out,retval]*/ IXMLDOMAttribute** attributeNode)
	{
		VSL_DEFINE_MOCK_METHOD(getAttributeNode)

		VSL_CHECK_VALIDVALUE_BSTR(name);

		VSL_SET_VALIDVALUE_INTERFACE(attributeNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct setAttributeNodeValidValues
	{
		/*[in]*/ IXMLDOMAttribute* DOMAttribute;
		/*[out,retval]*/ IXMLDOMAttribute** attributeNode;
		HRESULT retValue;
	};

	STDMETHOD(setAttributeNode)(
		/*[in]*/ IXMLDOMAttribute* DOMAttribute,
		/*[out,retval]*/ IXMLDOMAttribute** attributeNode)
	{
		VSL_DEFINE_MOCK_METHOD(setAttributeNode)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(DOMAttribute);

		VSL_SET_VALIDVALUE_INTERFACE(attributeNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct removeAttributeNodeValidValues
	{
		/*[in]*/ IXMLDOMAttribute* DOMAttribute;
		/*[out,retval]*/ IXMLDOMAttribute** attributeNode;
		HRESULT retValue;
	};

	STDMETHOD(removeAttributeNode)(
		/*[in]*/ IXMLDOMAttribute* DOMAttribute,
		/*[out,retval]*/ IXMLDOMAttribute** attributeNode)
	{
		VSL_DEFINE_MOCK_METHOD(removeAttributeNode)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(DOMAttribute);

		VSL_SET_VALIDVALUE_INTERFACE(attributeNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct getElementsByTagNameValidValues
	{
		/*[in]*/ BSTR tagName;
		/*[out,retval]*/ IXMLDOMNodeList** resultList;
		HRESULT retValue;
	};

	STDMETHOD(getElementsByTagName)(
		/*[in]*/ BSTR tagName,
		/*[out,retval]*/ IXMLDOMNodeList** resultList)
	{
		VSL_DEFINE_MOCK_METHOD(getElementsByTagName)

		VSL_CHECK_VALIDVALUE_BSTR(tagName);

		VSL_SET_VALIDVALUE_INTERFACE(resultList);

		VSL_RETURN_VALIDVALUES();
	}
	struct normalizeValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(normalize)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(normalize)

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeNameValidValues
	{
		/*[out,retval]*/ BSTR* name;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeName)(
		/*[out,retval]*/ BSTR* name)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeName)

		VSL_SET_VALIDVALUE_BSTR(name);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeValueValidValues
	{
		/*[out,retval]*/ VARIANT* value;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeValue)(
		/*[out,retval]*/ VARIANT* value)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeValue)

		VSL_SET_VALIDVALUE_VARIANT(value);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_nodeValueValidValues
	{
		/*[in]*/ VARIANT value;
		HRESULT retValue;
	};

	STDMETHOD(put_nodeValue)(
		/*[in]*/ VARIANT value)
	{
		VSL_DEFINE_MOCK_METHOD(put_nodeValue)

		VSL_CHECK_VALIDVALUE(value);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeTypeValidValues
	{
		/*[out,retval]*/ DOMNodeType* type;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeType)(
		/*[out,retval]*/ DOMNodeType* type)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeType)

		VSL_SET_VALIDVALUE(type);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_parentNodeValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** parent;
		HRESULT retValue;
	};

	STDMETHOD(get_parentNode)(
		/*[out,retval]*/ IXMLDOMNode** parent)
	{
		VSL_DEFINE_MOCK_METHOD(get_parentNode)

		VSL_SET_VALIDVALUE_INTERFACE(parent);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_childNodesValidValues
	{
		/*[out,retval]*/ IXMLDOMNodeList** childList;
		HRESULT retValue;
	};

	STDMETHOD(get_childNodes)(
		/*[out,retval]*/ IXMLDOMNodeList** childList)
	{
		VSL_DEFINE_MOCK_METHOD(get_childNodes)

		VSL_SET_VALIDVALUE_INTERFACE(childList);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_firstChildValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** firstChild;
		HRESULT retValue;
	};

	STDMETHOD(get_firstChild)(
		/*[out,retval]*/ IXMLDOMNode** firstChild)
	{
		VSL_DEFINE_MOCK_METHOD(get_firstChild)

		VSL_SET_VALIDVALUE_INTERFACE(firstChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_lastChildValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** lastChild;
		HRESULT retValue;
	};

	STDMETHOD(get_lastChild)(
		/*[out,retval]*/ IXMLDOMNode** lastChild)
	{
		VSL_DEFINE_MOCK_METHOD(get_lastChild)

		VSL_SET_VALIDVALUE_INTERFACE(lastChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_previousSiblingValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** previousSibling;
		HRESULT retValue;
	};

	STDMETHOD(get_previousSibling)(
		/*[out,retval]*/ IXMLDOMNode** previousSibling)
	{
		VSL_DEFINE_MOCK_METHOD(get_previousSibling)

		VSL_SET_VALIDVALUE_INTERFACE(previousSibling);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nextSiblingValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** nextSibling;
		HRESULT retValue;
	};

	STDMETHOD(get_nextSibling)(
		/*[out,retval]*/ IXMLDOMNode** nextSibling)
	{
		VSL_DEFINE_MOCK_METHOD(get_nextSibling)

		VSL_SET_VALIDVALUE_INTERFACE(nextSibling);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_attributesValidValues
	{
		/*[out,retval]*/ IXMLDOMNamedNodeMap** attributeMap;
		HRESULT retValue;
	};

	STDMETHOD(get_attributes)(
		/*[out,retval]*/ IXMLDOMNamedNodeMap** attributeMap)
	{
		VSL_DEFINE_MOCK_METHOD(get_attributes)

		VSL_SET_VALIDVALUE_INTERFACE(attributeMap);

		VSL_RETURN_VALIDVALUES();
	}
	struct insertBeforeValidValues
	{
		/*[in]*/ IXMLDOMNode* newChild;
		/*[in]*/ VARIANT refChild;
		/*[out,retval]*/ IXMLDOMNode** outNewChild;
		HRESULT retValue;
	};

	STDMETHOD(insertBefore)(
		/*[in]*/ IXMLDOMNode* newChild,
		/*[in]*/ VARIANT refChild,
		/*[out,retval]*/ IXMLDOMNode** outNewChild)
	{
		VSL_DEFINE_MOCK_METHOD(insertBefore)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(newChild);

		VSL_CHECK_VALIDVALUE(refChild);

		VSL_SET_VALIDVALUE_INTERFACE(outNewChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct replaceChildValidValues
	{
		/*[in]*/ IXMLDOMNode* newChild;
		/*[in]*/ IXMLDOMNode* oldChild;
		/*[out,retval]*/ IXMLDOMNode** outOldChild;
		HRESULT retValue;
	};

	STDMETHOD(replaceChild)(
		/*[in]*/ IXMLDOMNode* newChild,
		/*[in]*/ IXMLDOMNode* oldChild,
		/*[out,retval]*/ IXMLDOMNode** outOldChild)
	{
		VSL_DEFINE_MOCK_METHOD(replaceChild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(newChild);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(oldChild);

		VSL_SET_VALIDVALUE_INTERFACE(outOldChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct removeChildValidValues
	{
		/*[in]*/ IXMLDOMNode* childNode;
		/*[out,retval]*/ IXMLDOMNode** oldChild;
		HRESULT retValue;
	};

	STDMETHOD(removeChild)(
		/*[in]*/ IXMLDOMNode* childNode,
		/*[out,retval]*/ IXMLDOMNode** oldChild)
	{
		VSL_DEFINE_MOCK_METHOD(removeChild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(childNode);

		VSL_SET_VALIDVALUE_INTERFACE(oldChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct appendChildValidValues
	{
		/*[in]*/ IXMLDOMNode* newChild;
		/*[out,retval]*/ IXMLDOMNode** outNewChild;
		HRESULT retValue;
	};

	STDMETHOD(appendChild)(
		/*[in]*/ IXMLDOMNode* newChild,
		/*[out,retval]*/ IXMLDOMNode** outNewChild)
	{
		VSL_DEFINE_MOCK_METHOD(appendChild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(newChild);

		VSL_SET_VALIDVALUE_INTERFACE(outNewChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct hasChildNodesValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* hasChild;
		HRESULT retValue;
	};

	STDMETHOD(hasChildNodes)(
		/*[out,retval]*/ VARIANT_BOOL* hasChild)
	{
		VSL_DEFINE_MOCK_METHOD(hasChildNodes)

		VSL_SET_VALIDVALUE(hasChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ownerDocumentValidValues
	{
		/*[out,retval]*/ IXMLDOMDocument** DOMDocument;
		HRESULT retValue;
	};

	STDMETHOD(get_ownerDocument)(
		/*[out,retval]*/ IXMLDOMDocument** DOMDocument)
	{
		VSL_DEFINE_MOCK_METHOD(get_ownerDocument)

		VSL_SET_VALIDVALUE_INTERFACE(DOMDocument);

		VSL_RETURN_VALIDVALUES();
	}
	struct cloneNodeValidValues
	{
		/*[in]*/ VARIANT_BOOL deep;
		/*[out,retval]*/ IXMLDOMNode** cloneRoot;
		HRESULT retValue;
	};

	STDMETHOD(cloneNode)(
		/*[in]*/ VARIANT_BOOL deep,
		/*[out,retval]*/ IXMLDOMNode** cloneRoot)
	{
		VSL_DEFINE_MOCK_METHOD(cloneNode)

		VSL_CHECK_VALIDVALUE(deep);

		VSL_SET_VALIDVALUE_INTERFACE(cloneRoot);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeTypeStringValidValues
	{
		/*[retval,out]*/ BSTR* nodeType;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeTypeString)(
		/*[retval,out]*/ BSTR* nodeType)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeTypeString)

		VSL_SET_VALIDVALUE_BSTR(nodeType);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_textValidValues
	{
		/*[retval,out]*/ BSTR* text;
		HRESULT retValue;
	};

	STDMETHOD(get_text)(
		/*[retval,out]*/ BSTR* text)
	{
		VSL_DEFINE_MOCK_METHOD(get_text)

		VSL_SET_VALIDVALUE_BSTR(text);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_textValidValues
	{
		/*[in]*/ BSTR text;
		HRESULT retValue;
	};

	STDMETHOD(put_text)(
		/*[in]*/ BSTR text)
	{
		VSL_DEFINE_MOCK_METHOD(put_text)

		VSL_CHECK_VALIDVALUE_BSTR(text);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_specifiedValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* isSpecified;
		HRESULT retValue;
	};

	STDMETHOD(get_specified)(
		/*[out,retval]*/ VARIANT_BOOL* isSpecified)
	{
		VSL_DEFINE_MOCK_METHOD(get_specified)

		VSL_SET_VALIDVALUE(isSpecified);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_definitionValidValues
	{
		/*[retval,out]*/ IXMLDOMNode** definitionNode;
		HRESULT retValue;
	};

	STDMETHOD(get_definition)(
		/*[retval,out]*/ IXMLDOMNode** definitionNode)
	{
		VSL_DEFINE_MOCK_METHOD(get_definition)

		VSL_SET_VALIDVALUE_INTERFACE(definitionNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeTypedValueValidValues
	{
		/*[retval,out]*/ VARIANT* typedValue;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeTypedValue)(
		/*[retval,out]*/ VARIANT* typedValue)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeTypedValue)

		VSL_SET_VALIDVALUE_VARIANT(typedValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_nodeTypedValueValidValues
	{
		/*[in]*/ VARIANT typedValue;
		HRESULT retValue;
	};

	STDMETHOD(put_nodeTypedValue)(
		/*[in]*/ VARIANT typedValue)
	{
		VSL_DEFINE_MOCK_METHOD(put_nodeTypedValue)

		VSL_CHECK_VALIDVALUE(typedValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_dataTypeValidValues
	{
		/*[retval,out]*/ VARIANT* dataTypeName;
		HRESULT retValue;
	};

	STDMETHOD(get_dataType)(
		/*[retval,out]*/ VARIANT* dataTypeName)
	{
		VSL_DEFINE_MOCK_METHOD(get_dataType)

		VSL_SET_VALIDVALUE_VARIANT(dataTypeName);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_dataTypeValidValues
	{
		/*[in]*/ BSTR dataTypeName;
		HRESULT retValue;
	};

	STDMETHOD(put_dataType)(
		/*[in]*/ BSTR dataTypeName)
	{
		VSL_DEFINE_MOCK_METHOD(put_dataType)

		VSL_CHECK_VALIDVALUE_BSTR(dataTypeName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_xmlValidValues
	{
		/*[retval,out]*/ BSTR* xmlString;
		HRESULT retValue;
	};

	STDMETHOD(get_xml)(
		/*[retval,out]*/ BSTR* xmlString)
	{
		VSL_DEFINE_MOCK_METHOD(get_xml)

		VSL_SET_VALIDVALUE_BSTR(xmlString);

		VSL_RETURN_VALIDVALUES();
	}
	struct transformNodeValidValues
	{
		/*[in]*/ IXMLDOMNode* stylesheet;
		/*[retval,out]*/ BSTR* xmlString;
		HRESULT retValue;
	};

	STDMETHOD(transformNode)(
		/*[in]*/ IXMLDOMNode* stylesheet,
		/*[retval,out]*/ BSTR* xmlString)
	{
		VSL_DEFINE_MOCK_METHOD(transformNode)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(stylesheet);

		VSL_SET_VALIDVALUE_BSTR(xmlString);

		VSL_RETURN_VALIDVALUES();
	}
	struct selectNodesValidValues
	{
		/*[in]*/ BSTR queryString;
		/*[retval,out]*/ IXMLDOMNodeList** resultList;
		HRESULT retValue;
	};

	STDMETHOD(selectNodes)(
		/*[in]*/ BSTR queryString,
		/*[retval,out]*/ IXMLDOMNodeList** resultList)
	{
		VSL_DEFINE_MOCK_METHOD(selectNodes)

		VSL_CHECK_VALIDVALUE_BSTR(queryString);

		VSL_SET_VALIDVALUE_INTERFACE(resultList);

		VSL_RETURN_VALIDVALUES();
	}
	struct selectSingleNodeValidValues
	{
		/*[in]*/ BSTR queryString;
		/*[retval,out]*/ IXMLDOMNode** resultNode;
		HRESULT retValue;
	};

	STDMETHOD(selectSingleNode)(
		/*[in]*/ BSTR queryString,
		/*[retval,out]*/ IXMLDOMNode** resultNode)
	{
		VSL_DEFINE_MOCK_METHOD(selectSingleNode)

		VSL_CHECK_VALIDVALUE_BSTR(queryString);

		VSL_SET_VALIDVALUE_INTERFACE(resultNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_parsedValidValues
	{
		/*[retval,out]*/ VARIANT_BOOL* isParsed;
		HRESULT retValue;
	};

	STDMETHOD(get_parsed)(
		/*[retval,out]*/ VARIANT_BOOL* isParsed)
	{
		VSL_DEFINE_MOCK_METHOD(get_parsed)

		VSL_SET_VALIDVALUE(isParsed);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_namespaceURIValidValues
	{
		/*[retval,out]*/ BSTR* namespaceURI;
		HRESULT retValue;
	};

	STDMETHOD(get_namespaceURI)(
		/*[retval,out]*/ BSTR* namespaceURI)
	{
		VSL_DEFINE_MOCK_METHOD(get_namespaceURI)

		VSL_SET_VALIDVALUE_BSTR(namespaceURI);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_prefixValidValues
	{
		/*[retval,out]*/ BSTR* prefixString;
		HRESULT retValue;
	};

	STDMETHOD(get_prefix)(
		/*[retval,out]*/ BSTR* prefixString)
	{
		VSL_DEFINE_MOCK_METHOD(get_prefix)

		VSL_SET_VALIDVALUE_BSTR(prefixString);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_baseNameValidValues
	{
		/*[retval,out]*/ BSTR* nameString;
		HRESULT retValue;
	};

	STDMETHOD(get_baseName)(
		/*[retval,out]*/ BSTR* nameString)
	{
		VSL_DEFINE_MOCK_METHOD(get_baseName)

		VSL_SET_VALIDVALUE_BSTR(nameString);

		VSL_RETURN_VALIDVALUES();
	}
	struct transformNodeToObjectValidValues
	{
		/*[in]*/ IXMLDOMNode* stylesheet;
		/*[in]*/ VARIANT outputObject;
		HRESULT retValue;
	};

	STDMETHOD(transformNodeToObject)(
		/*[in]*/ IXMLDOMNode* stylesheet,
		/*[in]*/ VARIANT outputObject)
	{
		VSL_DEFINE_MOCK_METHOD(transformNodeToObject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(stylesheet);

		VSL_CHECK_VALIDVALUE(outputObject);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IXMLDOMELEMENT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIXMLDOMNode.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IXMLDOMNODE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IXMLDOMNODE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "XmlDom.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IXMLDOMNodeNotImpl :
	public IXMLDOMNode
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IXMLDOMNodeNotImpl)

public:

	typedef IXMLDOMNode Interface;

	STDMETHOD(get_nodeName)(
		/*[out,retval]*/ BSTR* /*name*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeValue)(
		/*[out,retval]*/ VARIANT* /*value*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_nodeValue)(
		/*[in]*/ VARIANT /*value*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeType)(
		/*[out,retval]*/ DOMNodeType* /*type*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_parentNode)(
		/*[out,retval]*/ IXMLDOMNode** /*parent*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_childNodes)(
		/*[out,retval]*/ IXMLDOMNodeList** /*childList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_firstChild)(
		/*[out,retval]*/ IXMLDOMNode** /*firstChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_lastChild)(
		/*[out,retval]*/ IXMLDOMNode** /*lastChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_previousSibling)(
		/*[out,retval]*/ IXMLDOMNode** /*previousSibling*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nextSibling)(
		/*[out,retval]*/ IXMLDOMNode** /*nextSibling*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_attributes)(
		/*[out,retval]*/ IXMLDOMNamedNodeMap** /*attributeMap*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(insertBefore)(
		/*[in]*/ IXMLDOMNode* /*newChild*/,
		/*[in]*/ VARIANT /*refChild*/,
		/*[out,retval]*/ IXMLDOMNode** /*outNewChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(replaceChild)(
		/*[in]*/ IXMLDOMNode* /*newChild*/,
		/*[in]*/ IXMLDOMNode* /*oldChild*/,
		/*[out,retval]*/ IXMLDOMNode** /*outOldChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(removeChild)(
		/*[in]*/ IXMLDOMNode* /*childNode*/,
		/*[out,retval]*/ IXMLDOMNode** /*oldChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(appendChild)(
		/*[in]*/ IXMLDOMNode* /*newChild*/,
		/*[out,retval]*/ IXMLDOMNode** /*outNewChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(hasChildNodes)(
		/*[out,retval]*/ VARIANT_BOOL* /*hasChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ownerDocument)(
		/*[out,retval]*/ IXMLDOMDocument** /*DOMDocument*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(cloneNode)(
		/*[in]*/ VARIANT_BOOL /*deep*/,
		/*[out,retval]*/ IXMLDOMNode** /*cloneRoot*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeTypeString)(
		/*[retval,out]*/ BSTR* /*nodeType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_text)(
		/*[retval,out]*/ BSTR* /*text*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_text)(
		/*[in]*/ BSTR /*text*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_specified)(
		/*[out,retval]*/ VARIANT_BOOL* /*isSpecified*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_definition)(
		/*[retval,out]*/ IXMLDOMNode** /*definitionNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeTypedValue)(
		/*[retval,out]*/ VARIANT* /*typedValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_nodeTypedValue)(
		/*[in]*/ VARIANT /*typedValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_dataType)(
		/*[retval,out]*/ VARIANT* /*dataTypeName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_dataType)(
		/*[in]*/ BSTR /*dataTypeName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_xml)(
		/*[retval,out]*/ BSTR* /*xmlString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(transformNode)(
		/*[in]*/ IXMLDOMNode* /*stylesheet*/,
		/*[retval,out]*/ BSTR* /*xmlString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(selectNodes)(
		/*[in]*/ BSTR /*queryString*/,
		/*[retval,out]*/ IXMLDOMNodeList** /*resultList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(selectSingleNode)(
		/*[in]*/ BSTR /*queryString*/,
		/*[retval,out]*/ IXMLDOMNode** /*resultNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_parsed)(
		/*[retval,out]*/ VARIANT_BOOL* /*isParsed*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_namespaceURI)(
		/*[retval,out]*/ BSTR* /*namespaceURI*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_prefix)(
		/*[retval,out]*/ BSTR* /*prefixString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_baseName)(
		/*[retval,out]*/ BSTR* /*nameString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(transformNodeToObject)(
		/*[in]*/ IXMLDOMNode* /*stylesheet*/,
		/*[in]*/ VARIANT /*outputObject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class IXMLDOMNodeMockImpl :
	public IXMLDOMNode,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IXMLDOMNodeMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IXMLDOMNodeMockImpl)

	typedef IXMLDOMNode Interface;
	struct get_nodeNameValidValues
	{
		/*[out,retval]*/ BSTR* name;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeName)(
		/*[out,retval]*/ BSTR* name)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeName)

		VSL_SET_VALIDVALUE_BSTR(name);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeValueValidValues
	{
		/*[out,retval]*/ VARIANT* value;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeValue)(
		/*[out,retval]*/ VARIANT* value)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeValue)

		VSL_SET_VALIDVALUE_VARIANT(value);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_nodeValueValidValues
	{
		/*[in]*/ VARIANT value;
		HRESULT retValue;
	};

	STDMETHOD(put_nodeValue)(
		/*[in]*/ VARIANT value)
	{
		VSL_DEFINE_MOCK_METHOD(put_nodeValue)

		VSL_CHECK_VALIDVALUE(value);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeTypeValidValues
	{
		/*[out,retval]*/ DOMNodeType* type;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeType)(
		/*[out,retval]*/ DOMNodeType* type)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeType)

		VSL_SET_VALIDVALUE(type);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_parentNodeValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** parent;
		HRESULT retValue;
	};

	STDMETHOD(get_parentNode)(
		/*[out,retval]*/ IXMLDOMNode** parent)
	{
		VSL_DEFINE_MOCK_METHOD(get_parentNode)

		VSL_SET_VALIDVALUE_INTERFACE(parent);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_childNodesValidValues
	{
		/*[out,retval]*/ IXMLDOMNodeList** childList;
		HRESULT retValue;
	};

	STDMETHOD(get_childNodes)(
		/*[out,retval]*/ IXMLDOMNodeList** childList)
	{
		VSL_DEFINE_MOCK_METHOD(get_childNodes)

		VSL_SET_VALIDVALUE_INTERFACE(childList);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_firstChildValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** firstChild;
		HRESULT retValue;
	};

	STDMETHOD(get_firstChild)(
		/*[out,retval]*/ IXMLDOMNode** firstChild)
	{
		VSL_DEFINE_MOCK_METHOD(get_firstChild)

		VSL_SET_VALIDVALUE_INTERFACE(firstChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_lastChildValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** lastChild;
		HRESULT retValue;
	};

	STDMETHOD(get_lastChild)(
		/*[out,retval]*/ IXMLDOMNode** lastChild)
	{
		VSL_DEFINE_MOCK_METHOD(get_lastChild)

		VSL_SET_VALIDVALUE_INTERFACE(lastChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_previousSiblingValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** previousSibling;
		HRESULT retValue;
	};

	STDMETHOD(get_previousSibling)(
		/*[out,retval]*/ IXMLDOMNode** previousSibling)
	{
		VSL_DEFINE_MOCK_METHOD(get_previousSibling)

		VSL_SET_VALIDVALUE_INTERFACE(previousSibling);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nextSiblingValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** nextSibling;
		HRESULT retValue;
	};

	STDMETHOD(get_nextSibling)(
		/*[out,retval]*/ IXMLDOMNode** nextSibling)
	{
		VSL_DEFINE_MOCK_METHOD(get_nextSibling)

		VSL_SET_VALIDVALUE_INTERFACE(nextSibling);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_attributesValidValues
	{
		/*[out,retval]*/ IXMLDOMNamedNodeMap** attributeMap;
		HRESULT retValue;
	};

	STDMETHOD(get_attributes)(
		/*[out,retval]*/ IXMLDOMNamedNodeMap** attributeMap)
	{
		VSL_DEFINE_MOCK_METHOD(get_attributes)

		VSL_SET_VALIDVALUE_INTERFACE(attributeMap);

		VSL_RETURN_VALIDVALUES();
	}
	struct insertBeforeValidValues
	{
		/*[in]*/ IXMLDOMNode* newChild;
		/*[in]*/ VARIANT refChild;
		/*[out,retval]*/ IXMLDOMNode** outNewChild;
		HRESULT retValue;
	};

	STDMETHOD(insertBefore)(
		/*[in]*/ IXMLDOMNode* newChild,
		/*[in]*/ VARIANT refChild,
		/*[out,retval]*/ IXMLDOMNode** outNewChild)
	{
		VSL_DEFINE_MOCK_METHOD(insertBefore)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(newChild);

		VSL_CHECK_VALIDVALUE(refChild);

		VSL_SET_VALIDVALUE_INTERFACE(outNewChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct replaceChildValidValues
	{
		/*[in]*/ IXMLDOMNode* newChild;
		/*[in]*/ IXMLDOMNode* oldChild;
		/*[out,retval]*/ IXMLDOMNode** outOldChild;
		HRESULT retValue;
	};

	STDMETHOD(replaceChild)(
		/*[in]*/ IXMLDOMNode* newChild,
		/*[in]*/ IXMLDOMNode* oldChild,
		/*[out,retval]*/ IXMLDOMNode** outOldChild)
	{
		VSL_DEFINE_MOCK_METHOD(replaceChild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(newChild);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(oldChild);

		VSL_SET_VALIDVALUE_INTERFACE(outOldChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct removeChildValidValues
	{
		/*[in]*/ IXMLDOMNode* childNode;
		/*[out,retval]*/ IXMLDOMNode** oldChild;
		HRESULT retValue;
	};

	STDMETHOD(removeChild)(
		/*[in]*/ IXMLDOMNode* childNode,
		/*[out,retval]*/ IXMLDOMNode** oldChild)
	{
		VSL_DEFINE_MOCK_METHOD(removeChild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(childNode);

		VSL_SET_VALIDVALUE_INTERFACE(oldChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct appendChildValidValues
	{
		/*[in]*/ IXMLDOMNode* newChild;
		/*[out,retval]*/ IXMLDOMNode** outNewChild;
		HRESULT retValue;
	};

	STDMETHOD(appendChild)(
		/*[in]*/ IXMLDOMNode* newChild,
		/*[out,retval]*/ IXMLDOMNode** outNewChild)
	{
		VSL_DEFINE_MOCK_METHOD(appendChild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(newChild);

		VSL_SET_VALIDVALUE_INTERFACE(outNewChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct hasChildNodesValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* hasChild;
		HRESULT retValue;
	};

	STDMETHOD(hasChildNodes)(
		/*[out,retval]*/ VARIANT_BOOL* hasChild)
	{
		VSL_DEFINE_MOCK_METHOD(hasChildNodes)

		VSL_SET_VALIDVALUE(hasChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ownerDocumentValidValues
	{
		/*[out,retval]*/ IXMLDOMDocument** DOMDocument;
		HRESULT retValue;
	};

	STDMETHOD(get_ownerDocument)(
		/*[out,retval]*/ IXMLDOMDocument** DOMDocument)
	{
		VSL_DEFINE_MOCK_METHOD(get_ownerDocument)

		VSL_SET_VALIDVALUE_INTERFACE(DOMDocument);

		VSL_RETURN_VALIDVALUES();
	}
	struct cloneNodeValidValues
	{
		/*[in]*/ VARIANT_BOOL deep;
		/*[out,retval]*/ IXMLDOMNode** cloneRoot;
		HRESULT retValue;
	};

	STDMETHOD(cloneNode)(
		/*[in]*/ VARIANT_BOOL deep,
		/*[out,retval]*/ IXMLDOMNode** cloneRoot)
	{
		VSL_DEFINE_MOCK_METHOD(cloneNode)

		VSL_CHECK_VALIDVALUE(deep);

		VSL_SET_VALIDVALUE_INTERFACE(cloneRoot);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeTypeStringValidValues
	{
		/*[retval,out]*/ BSTR* nodeType;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeTypeString)(
		/*[retval,out]*/ BSTR* nodeType)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeTypeString)

		VSL_SET_VALIDVALUE_BSTR(nodeType);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_textValidValues
	{
		/*[retval,out]*/ BSTR* text;
		HRESULT retValue;
	};

	STDMETHOD(get_text)(
		/*[retval,out]*/ BSTR* text)
	{
		VSL_DEFINE_MOCK_METHOD(get_text)

		VSL_SET_VALIDVALUE_BSTR(text);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_textValidValues
	{
		/*[in]*/ BSTR text;
		HRESULT retValue;
	};

	STDMETHOD(put_text)(
		/*[in]*/ BSTR text)
	{
		VSL_DEFINE_MOCK_METHOD(put_text)

		VSL_CHECK_VALIDVALUE_BSTR(text);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_specifiedValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* isSpecified;
		HRESULT retValue;
	};

	STDMETHOD(get_specified)(
		/*[out,retval]*/ VARIANT_BOOL* isSpecified)
	{
		VSL_DEFINE_MOCK_METHOD(get_specified)

		VSL_SET_VALIDVALUE(isSpecified);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_definitionValidValues
	{
		/*[retval,out]*/ IXMLDOMNode** definitionNode;
		HRESULT retValue;
	};

	STDMETHOD(get_definition)(
		/*[retval,out]*/ IXMLDOMNode** definitionNode)
	{
		VSL_DEFINE_MOCK_METHOD(get_definition)

		VSL_SET_VALIDVALUE_INTERFACE(definitionNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeTypedValueValidValues
	{
		/*[retval,out]*/ VARIANT* typedValue;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeTypedValue)(
		/*[retval,out]*/ VARIANT* typedValue)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeTypedValue)

		VSL_SET_VALIDVALUE_VARIANT(typedValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_nodeTypedValueValidValues
	{
		/*[in]*/ VARIANT typedValue;
		HRESULT retValue;
	};

	STDMETHOD(put_nodeTypedValue)(
		/*[in]*/ VARIANT typedValue)
	{
		VSL_DEFINE_MOCK_METHOD(put_nodeTypedValue)

		VSL_CHECK_VALIDVALUE(typedValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_dataTypeValidValues
	{
		/*[retval,out]*/ VARIANT* dataTypeName;
		HRESULT retValue;
	};

	STDMETHOD(get_dataType)(
		/*[retval,out]*/ VARIANT* dataTypeName)
	{
		VSL_DEFINE_MOCK_METHOD(get_dataType)

		VSL_SET_VALIDVALUE_VARIANT(dataTypeName);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_dataTypeValidValues
	{
		/*[in]*/ BSTR dataTypeName;
		HRESULT retValue;
	};

	STDMETHOD(put_dataType)(
		/*[in]*/ BSTR dataTypeName)
	{
		VSL_DEFINE_MOCK_METHOD(put_dataType)

		VSL_CHECK_VALIDVALUE_BSTR(dataTypeName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_xmlValidValues
	{
		/*[retval,out]*/ BSTR* xmlString;
		HRESULT retValue;
	};

	STDMETHOD(get_xml)(
		/*[retval,out]*/ BSTR* xmlString)
	{
		VSL_DEFINE_MOCK_METHOD(get_xml)

		VSL_SET_VALIDVALUE_BSTR(xmlString);

		VSL_RETURN_VALIDVALUES();
	}
	struct transformNodeValidValues
	{
		/*[in]*/ IXMLDOMNode* stylesheet;
		/*[retval,out]*/ BSTR* xmlString;
		HRESULT retValue;
	};

	STDMETHOD(transformNode)(
		/*[in]*/ IXMLDOMNode* stylesheet,
		/*[retval,out]*/ BSTR* xmlString)
	{
		VSL_DEFINE_MOCK_METHOD(transformNode)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(stylesheet);

		VSL_SET_VALIDVALUE_BSTR(xmlString);

		VSL_RETURN_VALIDVALUES();
	}
	struct selectNodesValidValues
	{
		/*[in]*/ BSTR queryString;
		/*[retval,out]*/ IXMLDOMNodeList** resultList;
		HRESULT retValue;
	};

	STDMETHOD(selectNodes)(
		/*[in]*/ BSTR queryString,
		/*[retval,out]*/ IXMLDOMNodeList** resultList)
	{
		VSL_DEFINE_MOCK_METHOD(selectNodes)

		VSL_CHECK_VALIDVALUE_BSTR(queryString);

		VSL_SET_VALIDVALUE_INTERFACE(resultList);

		VSL_RETURN_VALIDVALUES();
	}
	struct selectSingleNodeValidValues
	{
		/*[in]*/ BSTR queryString;
		/*[retval,out]*/ IXMLDOMNode** resultNode;
		HRESULT retValue;
	};

	STDMETHOD(selectSingleNode)(
		/*[in]*/ BSTR queryString,
		/*[retval,out]*/ IXMLDOMNode** resultNode)
	{
		VSL_DEFINE_MOCK_METHOD(selectSingleNode)

		VSL_CHECK_VALIDVALUE_BSTR(queryString);

		VSL_SET_VALIDVALUE_INTERFACE(resultNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_parsedValidValues
	{
		/*[retval,out]*/ VARIANT_BOOL* isParsed;
		HRESULT retValue;
	};

	STDMETHOD(get_parsed)(
		/*[retval,out]*/ VARIANT_BOOL* isParsed)
	{
		VSL_DEFINE_MOCK_METHOD(get_parsed)

		VSL_SET_VALIDVALUE(isParsed);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_namespaceURIValidValues
	{
		/*[retval,out]*/ BSTR* namespaceURI;
		HRESULT retValue;
	};

	STDMETHOD(get_namespaceURI)(
		/*[retval,out]*/ BSTR* namespaceURI)
	{
		VSL_DEFINE_MOCK_METHOD(get_namespaceURI)

		VSL_SET_VALIDVALUE_BSTR(namespaceURI);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_prefixValidValues
	{
		/*[retval,out]*/ BSTR* prefixString;
		HRESULT retValue;
	};

	STDMETHOD(get_prefix)(
		/*[retval,out]*/ BSTR* prefixString)
	{
		VSL_DEFINE_MOCK_METHOD(get_prefix)

		VSL_SET_VALIDVALUE_BSTR(prefixString);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_baseNameValidValues
	{
		/*[retval,out]*/ BSTR* nameString;
		HRESULT retValue;
	};

	STDMETHOD(get_baseName)(
		/*[retval,out]*/ BSTR* nameString)
	{
		VSL_DEFINE_MOCK_METHOD(get_baseName)

		VSL_SET_VALIDVALUE_BSTR(nameString);

		VSL_RETURN_VALIDVALUES();
	}
	struct transformNodeToObjectValidValues
	{
		/*[in]*/ IXMLDOMNode* stylesheet;
		/*[in]*/ VARIANT outputObject;
		HRESULT retValue;
	};

	STDMETHOD(transformNodeToObject)(
		/*[in]*/ IXMLDOMNode* stylesheet,
		/*[in]*/ VARIANT outputObject)
	{
		VSL_DEFINE_MOCK_METHOD(transformNodeToObject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(stylesheet);

		VSL_CHECK_VALIDVALUE(outputObject);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IXMLDOMNODE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIXMLDOMNodeList.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IXMLDOMNODELIST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IXMLDOMNODELIST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "XmlDom.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IXMLDOMNodeListNotImpl :
	public IXMLDOMNodeList
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IXMLDOMNodeListNotImpl)

public:

	typedef IXMLDOMNodeList Interface;

	STDMETHOD(get_item)(
		/*[in]*/ long /*index*/,
		/*[out,retval]*/ IXMLDOMNode** /*listItem*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_length)(
		/*[out,retval]*/ long* /*listLength*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(nextNode)(
		/*[out,retval]*/ IXMLDOMNode** /*nextItem*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get__newEnum)(
		/*[retval,out]*/ IUnknown** /*ppUnk*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class IXMLDOMNodeListMockImpl :
	public IXMLDOMNodeList,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IXMLDOMNodeListMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IXMLDOMNodeListMockImpl)

	typedef IXMLDOMNodeList Interface;
	struct get_itemValidValues
	{
		/*[in]*/ long index;
		/*[out,retval]*/ IXMLDOMNode** listItem;
		HRESULT retValue;
	};

	STDMETHOD(get_item)(
		/*[in]*/ long index,
		/*[out,retval]*/ IXMLDOMNode** listItem)
	{
		VSL_DEFINE_MOCK_METHOD(get_item)

		VSL_CHECK_VALIDVALUE(index);

		VSL_SET_VALIDVALUE_INTERFACE(listItem);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_lengthValidValues
	{
		/*[out,retval]*/ long* listLength;
		HRESULT retValue;
	};

	STDMETHOD(get_length)(
		/*[out,retval]*/ long* listLength)
	{
		VSL_DEFINE_MOCK_METHOD(get_length)

		VSL_SET_VALIDVALUE(listLength);

		VSL_RETURN_VALIDVALUES();
	}
	struct nextNodeValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** nextItem;
		HRESULT retValue;
	};

	STDMETHOD(nextNode)(
		/*[out,retval]*/ IXMLDOMNode** nextItem)
	{
		VSL_DEFINE_MOCK_METHOD(nextNode)

		VSL_SET_VALIDVALUE_INTERFACE(nextItem);

		VSL_RETURN_VALIDVALUES();
	}
	struct resetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct get__newEnumValidValues
	{
		/*[retval,out]*/ IUnknown** ppUnk;
		HRESULT retValue;
	};

	STDMETHOD(get__newEnum)(
		/*[retval,out]*/ IUnknown** ppUnk)
	{
		VSL_DEFINE_MOCK_METHOD(get__newEnum)

		VSL_SET_VALIDVALUE_INTERFACE(ppUnk);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IXMLDOMNODELIST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIXMLDOMNamedNodeMap.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IXMLDOMNAMEDNODEMAP_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IXMLDOMNAMEDNODEMAP_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "XmlDom.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IXMLDOMNamedNodeMapNotImpl :
	public IXMLDOMNamedNodeMap
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IXMLDOMNamedNodeMapNotImpl)

public:

	typedef IXMLDOMNamedNodeMap Interface;

	STDMETHOD(getNamedItem)(
		/*[in]*/ BSTR /*name*/,
		/*[out,retval]*/ IXMLDOMNode** /*namedItem*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(setNamedItem)(
		/*[in]*/ IXMLDOMNode* /*newItem*/,
		/*[out,retval]*/ IXMLDOMNode** /*nameItem*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(removeNamedItem)(
		/*[in]*/ BSTR /*name*/,
		/*[out,retval]*/ IXMLDOMNode** /*namedItem*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_item)(
		/*[in]*/ long /*index*/,
		/*[out,retval]*/ IXMLDOMNode** /*listItem*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_length)(
		/*[out,retval]*/ long* /*listLength*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(getQualifiedItem)(
		/*[in]*/ BSTR /*baseName*/,
		/*[in]*/ BSTR /*namespaceURI*/,
		/*[out,retval]*/ IXMLDOMNode** /*qualifiedItem*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(removeQualifiedItem)(
		/*[in]*/ BSTR /*baseName*/,
		/*[in]*/ BSTR /*namespaceURI*/,
		/*[out,retval]*/ IXMLDOMNode** /*qualifiedItem*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(nextNode)(
		/*[out,retval]*/ IXMLDOMNode** /*nextItem*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(reset)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get__newEnum)(
		/*[retval,out]*/ IUnknown** /*ppUnk*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class IXMLDOMNamedNodeMapMockImpl :
	public IXMLDOMNamedNodeMap,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IXMLDOMNamedNodeMapMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IXMLDOMNamedNodeMapMockImpl)

	typedef IXMLDOMNamedNodeMap Interface;
	struct getNamedItemValidValues
	{
		/*[in]*/ BSTR name;
		/*[out,retval]*/ IXMLDOMNode** namedItem;
		HRESULT retValue;
	};

	STDMETHOD(getNamedItem)(
		/*[in]*/ BSTR name,
		/*[out,retval]*/ IXMLDOMNode** namedItem)
	{
		VSL_DEFINE_MOCK_METHOD(getNamedItem)

		VSL_CHECK_VALIDVALUE_BSTR(name);

		VSL_SET_VALIDVALUE_INTERFACE(namedItem);

		VSL_RETURN_VALIDVALUES();
	}
	struct setNamedItemValidValues
	{
		/*[in]*/ IXMLDOMNode* newItem;
		/*[out,retval]*/ IXMLDOMNode** nameItem;
		HRESULT retValue;
	};

	STDMETHOD(setNamedItem)(
		/*[in]*/ IXMLDOMNode* newItem,
		/*[out,retval]*/ IXMLDOMNode** nameItem)
	{
		VSL_DEFINE_MOCK_METHOD(setNamedItem)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(newItem);

		VSL_SET_VALIDVALUE_INTERFACE(nameItem);

		VSL_RETURN_VALIDVALUES();
	}
	struct removeNamedItemValidValues
	{
		/*[in]*/ BSTR name;
		/*[out,retval]*/ IXMLDOMNode** namedItem;
		HRESULT retValue;
	};

	STDMETHOD(removeNamedItem)(
		/*[in]*/ BSTR name,
		/*[out,retval]*/ IXMLDOMNode** namedItem)
	{
		VSL_DEFINE_MOCK_METHOD(removeNamedItem)

		VSL_CHECK_VALIDVALUE_BSTR(name);

		VSL_SET_VALIDVALUE_INTERFACE(namedItem);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_itemValidValues
	{
		/*[in]*/ long index;
		/*[out,retval]*/ IXMLDOMNode** listItem;
		HRESULT retValue;
	};

	STDMETHOD(get_item)(
		/*[in]*/ long index,
		/*[out,retval]*/ IXMLDOMNode** listItem)
	{
		VSL_DEFINE_MOCK_METHOD(get_item)

		VSL_CHECK_VALIDVALUE(index);

		VSL_SET_VALIDVALUE_INTERFACE(listItem);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_lengthValidValues
	{
		/*[out,retval]*/ long* listLength;
		HRESULT retValue;
	};

	STDMETHOD(get_length)(
		/*[out,retval]*/ long* listLength)
	{
		VSL_DEFINE_MOCK_METHOD(get_length)

		VSL_SET_VALIDVALUE(listLength);

		VSL_RETURN_VALIDVALUES();
	}
	struct getQualifiedItemValidValues
	{
		/*[in]*/ BSTR baseName;
		/*[in]*/ BSTR namespaceURI;
		/*[out,retval]*/ IXMLDOMNode** qualifiedItem;
		HRESULT retValue;
	};

	STDMETHOD(getQualifiedItem)(
		/*[in]*/ BSTR baseName,
		/*[in]*/ BSTR namespaceURI,
		/*[out,retval]*/ IXMLDOMNode** qualifiedItem)
	{
		VSL_DEFINE_MOCK_METHOD(getQualifiedItem)

		VSL_CHECK_VALIDVALUE_BSTR(baseName);

		VSL_CHECK_VALIDVALUE_BSTR(namespaceURI);

		VSL_SET_VALIDVALUE_INTERFACE(qualifiedItem);

		VSL_RETURN_VALIDVALUES();
	}
	struct removeQualifiedItemValidValues
	{
		/*[in]*/ BSTR baseName;
		/*[in]*/ BSTR namespaceURI;
		/*[out,retval]*/ IXMLDOMNode** qualifiedItem;
		HRESULT retValue;
	};

	STDMETHOD(removeQualifiedItem)(
		/*[in]*/ BSTR baseName,
		/*[in]*/ BSTR namespaceURI,
		/*[out,retval]*/ IXMLDOMNode** qualifiedItem)
	{
		VSL_DEFINE_MOCK_METHOD(removeQualifiedItem)

		VSL_CHECK_VALIDVALUE_BSTR(baseName);

		VSL_CHECK_VALIDVALUE_BSTR(namespaceURI);

		VSL_SET_VALIDVALUE_INTERFACE(qualifiedItem);

		VSL_RETURN_VALIDVALUES();
	}
	struct nextNodeValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** nextItem;
		HRESULT retValue;
	};

	STDMETHOD(nextNode)(
		/*[out,retval]*/ IXMLDOMNode** nextItem)
	{
		VSL_DEFINE_MOCK_METHOD(nextNode)

		VSL_SET_VALIDVALUE_INTERFACE(nextItem);

		VSL_RETURN_VALIDVALUES();
	}
	struct resetValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(reset)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(reset)

		VSL_RETURN_VALIDVALUES();
	}
	struct get__newEnumValidValues
	{
		/*[retval,out]*/ IUnknown** ppUnk;
		HRESULT retValue;
	};

	STDMETHOD(get__newEnum)(
		/*[retval,out]*/ IUnknown** ppUnk)
	{
		VSL_DEFINE_MOCK_METHOD(get__newEnum)

		VSL_SET_VALIDVALUE_INTERFACE(ppUnk);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IXMLDOMNAMEDNODEMAP_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIXMLDOMParseError.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IXMLDOMPARSEERROR_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IXMLDOMPARSEERROR_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "XmlDom.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IXMLDOMParseErrorNotImpl :
	public IXMLDOMParseError
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IXMLDOMParseErrorNotImpl)

public:

	typedef IXMLDOMParseError Interface;

	STDMETHOD(get_errorCode)(
		/*[retval,out]*/ long* /*errorCode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_url)(
		/*[retval,out]*/ BSTR* /*urlString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_reason)(
		/*[retval,out]*/ BSTR* /*reasonString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_srcText)(
		/*[retval,out]*/ BSTR* /*sourceString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_line)(
		/*[retval,out]*/ long* /*lineNumber*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_linepos)(
		/*[retval,out]*/ long* /*linePosition*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_filepos)(
		/*[retval,out]*/ long* /*filePosition*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class IXMLDOMParseErrorMockImpl :
	public IXMLDOMParseError,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IXMLDOMParseErrorMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IXMLDOMParseErrorMockImpl)

	typedef IXMLDOMParseError Interface;
	struct get_errorCodeValidValues
	{
		/*[retval,out]*/ long* errorCode;
		HRESULT retValue;
	};

	STDMETHOD(get_errorCode)(
		/*[retval,out]*/ long* errorCode)
	{
		VSL_DEFINE_MOCK_METHOD(get_errorCode)

		VSL_SET_VALIDVALUE(errorCode);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_urlValidValues
	{
		/*[retval,out]*/ BSTR* urlString;
		HRESULT retValue;
	};

	STDMETHOD(get_url)(
		/*[retval,out]*/ BSTR* urlString)
	{
		VSL_DEFINE_MOCK_METHOD(get_url)

		VSL_SET_VALIDVALUE_BSTR(urlString);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_reasonValidValues
	{
		/*[retval,out]*/ BSTR* reasonString;
		HRESULT retValue;
	};

	STDMETHOD(get_reason)(
		/*[retval,out]*/ BSTR* reasonString)
	{
		VSL_DEFINE_MOCK_METHOD(get_reason)

		VSL_SET_VALIDVALUE_BSTR(reasonString);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_srcTextValidValues
	{
		/*[retval,out]*/ BSTR* sourceString;
		HRESULT retValue;
	};

	STDMETHOD(get_srcText)(
		/*[retval,out]*/ BSTR* sourceString)
	{
		VSL_DEFINE_MOCK_METHOD(get_srcText)

		VSL_SET_VALIDVALUE_BSTR(sourceString);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_lineValidValues
	{
		/*[retval,out]*/ long* lineNumber;
		HRESULT retValue;
	};

	STDMETHOD(get_line)(
		/*[retval,out]*/ long* lineNumber)
	{
		VSL_DEFINE_MOCK_METHOD(get_line)

		VSL_SET_VALIDVALUE(lineNumber);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_lineposValidValues
	{
		/*[retval,out]*/ long* linePosition;
		HRESULT retValue;
	};

	STDMETHOD(get_linepos)(
		/*[retval,out]*/ long* linePosition)
	{
		VSL_DEFINE_MOCK_METHOD(get_linepos)

		VSL_SET_VALIDVALUE(linePosition);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_fileposValidValues
	{
		/*[retval,out]*/ long* filePosition;
		HRESULT retValue;
	};

	STDMETHOD(get_filepos)(
		/*[retval,out]*/ long* filePosition)
	{
		VSL_DEFINE_MOCK_METHOD(get_filepos)

		VSL_SET_VALIDVALUE(filePosition);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IXMLDOMPARSEERROR_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIXMLDOMNotation.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IXMLDOMNOTATION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IXMLDOMNOTATION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "XmlDom.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IXMLDOMNotationNotImpl :
	public IXMLDOMNotation
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IXMLDOMNotationNotImpl)

public:

	typedef IXMLDOMNotation Interface;

	STDMETHOD(get_publicId)(
		/*[out,retval]*/ VARIANT* /*publicID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_systemId)(
		/*[out,retval]*/ VARIANT* /*systemID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeName)(
		/*[out,retval]*/ BSTR* /*name*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeValue)(
		/*[out,retval]*/ VARIANT* /*value*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_nodeValue)(
		/*[in]*/ VARIANT /*value*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeType)(
		/*[out,retval]*/ DOMNodeType* /*type*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_parentNode)(
		/*[out,retval]*/ IXMLDOMNode** /*parent*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_childNodes)(
		/*[out,retval]*/ IXMLDOMNodeList** /*childList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_firstChild)(
		/*[out,retval]*/ IXMLDOMNode** /*firstChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_lastChild)(
		/*[out,retval]*/ IXMLDOMNode** /*lastChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_previousSibling)(
		/*[out,retval]*/ IXMLDOMNode** /*previousSibling*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nextSibling)(
		/*[out,retval]*/ IXMLDOMNode** /*nextSibling*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_attributes)(
		/*[out,retval]*/ IXMLDOMNamedNodeMap** /*attributeMap*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(insertBefore)(
		/*[in]*/ IXMLDOMNode* /*newChild*/,
		/*[in]*/ VARIANT /*refChild*/,
		/*[out,retval]*/ IXMLDOMNode** /*outNewChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(replaceChild)(
		/*[in]*/ IXMLDOMNode* /*newChild*/,
		/*[in]*/ IXMLDOMNode* /*oldChild*/,
		/*[out,retval]*/ IXMLDOMNode** /*outOldChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(removeChild)(
		/*[in]*/ IXMLDOMNode* /*childNode*/,
		/*[out,retval]*/ IXMLDOMNode** /*oldChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(appendChild)(
		/*[in]*/ IXMLDOMNode* /*newChild*/,
		/*[out,retval]*/ IXMLDOMNode** /*outNewChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(hasChildNodes)(
		/*[out,retval]*/ VARIANT_BOOL* /*hasChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ownerDocument)(
		/*[out,retval]*/ IXMLDOMDocument** /*DOMDocument*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(cloneNode)(
		/*[in]*/ VARIANT_BOOL /*deep*/,
		/*[out,retval]*/ IXMLDOMNode** /*cloneRoot*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeTypeString)(
		/*[retval,out]*/ BSTR* /*nodeType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_text)(
		/*[retval,out]*/ BSTR* /*text*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_text)(
		/*[in]*/ BSTR /*text*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_specified)(
		/*[out,retval]*/ VARIANT_BOOL* /*isSpecified*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_definition)(
		/*[retval,out]*/ IXMLDOMNode** /*definitionNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeTypedValue)(
		/*[retval,out]*/ VARIANT* /*typedValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_nodeTypedValue)(
		/*[in]*/ VARIANT /*typedValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_dataType)(
		/*[retval,out]*/ VARIANT* /*dataTypeName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_dataType)(
		/*[in]*/ BSTR /*dataTypeName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_xml)(
		/*[retval,out]*/ BSTR* /*xmlString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(transformNode)(
		/*[in]*/ IXMLDOMNode* /*stylesheet*/,
		/*[retval,out]*/ BSTR* /*xmlString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(selectNodes)(
		/*[in]*/ BSTR /*queryString*/,
		/*[retval,out]*/ IXMLDOMNodeList** /*resultList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(selectSingleNode)(
		/*[in]*/ BSTR /*queryString*/,
		/*[retval,out]*/ IXMLDOMNode** /*resultNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_parsed)(
		/*[retval,out]*/ VARIANT_BOOL* /*isParsed*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_namespaceURI)(
		/*[retval,out]*/ BSTR* /*namespaceURI*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_prefix)(
		/*[retval,out]*/ BSTR* /*prefixString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_baseName)(
		/*[retval,out]*/ BSTR* /*nameString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(transformNodeToObject)(
		/*[in]*/ IXMLDOMNode* /*stylesheet*/,
		/*[in]*/ VARIANT /*outputObject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class IXMLDOMNotationMockImpl :
	public IXMLDOMNotation,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IXMLDOMNotationMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IXMLDOMNotationMockImpl)

	typedef IXMLDOMNotation Interface;
	struct get_publicIdValidValues
	{
		/*[out,retval]*/ VARIANT* publicID;
		HRESULT retValue;
	};

	STDMETHOD(get_publicId)(
		/*[out,retval]*/ VARIANT* publicID)
	{
		VSL_DEFINE_MOCK_METHOD(get_publicId)

		VSL_SET_VALIDVALUE_VARIANT(publicID);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_systemIdValidValues
	{
		/*[out,retval]*/ VARIANT* systemID;
		HRESULT retValue;
	};

	STDMETHOD(get_systemId)(
		/*[out,retval]*/ VARIANT* systemID)
	{
		VSL_DEFINE_MOCK_METHOD(get_systemId)

		VSL_SET_VALIDVALUE_VARIANT(systemID);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeNameValidValues
	{
		/*[out,retval]*/ BSTR* name;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeName)(
		/*[out,retval]*/ BSTR* name)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeName)

		VSL_SET_VALIDVALUE_BSTR(name);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeValueValidValues
	{
		/*[out,retval]*/ VARIANT* value;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeValue)(
		/*[out,retval]*/ VARIANT* value)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeValue)

		VSL_SET_VALIDVALUE_VARIANT(value);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_nodeValueValidValues
	{
		/*[in]*/ VARIANT value;
		HRESULT retValue;
	};

	STDMETHOD(put_nodeValue)(
		/*[in]*/ VARIANT value)
	{
		VSL_DEFINE_MOCK_METHOD(put_nodeValue)

		VSL_CHECK_VALIDVALUE(value);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeTypeValidValues
	{
		/*[out,retval]*/ DOMNodeType* type;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeType)(
		/*[out,retval]*/ DOMNodeType* type)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeType)

		VSL_SET_VALIDVALUE(type);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_parentNodeValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** parent;
		HRESULT retValue;
	};

	STDMETHOD(get_parentNode)(
		/*[out,retval]*/ IXMLDOMNode** parent)
	{
		VSL_DEFINE_MOCK_METHOD(get_parentNode)

		VSL_SET_VALIDVALUE_INTERFACE(parent);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_childNodesValidValues
	{
		/*[out,retval]*/ IXMLDOMNodeList** childList;
		HRESULT retValue;
	};

	STDMETHOD(get_childNodes)(
		/*[out,retval]*/ IXMLDOMNodeList** childList)
	{
		VSL_DEFINE_MOCK_METHOD(get_childNodes)

		VSL_SET_VALIDVALUE_INTERFACE(childList);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_firstChildValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** firstChild;
		HRESULT retValue;
	};

	STDMETHOD(get_firstChild)(
		/*[out,retval]*/ IXMLDOMNode** firstChild)
	{
		VSL_DEFINE_MOCK_METHOD(get_firstChild)

		VSL_SET_VALIDVALUE_INTERFACE(firstChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_lastChildValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** lastChild;
		HRESULT retValue;
	};

	STDMETHOD(get_lastChild)(
		/*[out,retval]*/ IXMLDOMNode** lastChild)
	{
		VSL_DEFINE_MOCK_METHOD(get_lastChild)

		VSL_SET_VALIDVALUE_INTERFACE(lastChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_previousSiblingValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** previousSibling;
		HRESULT retValue;
	};

	STDMETHOD(get_previousSibling)(
		/*[out,retval]*/ IXMLDOMNode** previousSibling)
	{
		VSL_DEFINE_MOCK_METHOD(get_previousSibling)

		VSL_SET_VALIDVALUE_INTERFACE(previousSibling);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nextSiblingValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** nextSibling;
		HRESULT retValue;
	};

	STDMETHOD(get_nextSibling)(
		/*[out,retval]*/ IXMLDOMNode** nextSibling)
	{
		VSL_DEFINE_MOCK_METHOD(get_nextSibling)

		VSL_SET_VALIDVALUE_INTERFACE(nextSibling);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_attributesValidValues
	{
		/*[out,retval]*/ IXMLDOMNamedNodeMap** attributeMap;
		HRESULT retValue;
	};

	STDMETHOD(get_attributes)(
		/*[out,retval]*/ IXMLDOMNamedNodeMap** attributeMap)
	{
		VSL_DEFINE_MOCK_METHOD(get_attributes)

		VSL_SET_VALIDVALUE_INTERFACE(attributeMap);

		VSL_RETURN_VALIDVALUES();
	}
	struct insertBeforeValidValues
	{
		/*[in]*/ IXMLDOMNode* newChild;
		/*[in]*/ VARIANT refChild;
		/*[out,retval]*/ IXMLDOMNode** outNewChild;
		HRESULT retValue;
	};

	STDMETHOD(insertBefore)(
		/*[in]*/ IXMLDOMNode* newChild,
		/*[in]*/ VARIANT refChild,
		/*[out,retval]*/ IXMLDOMNode** outNewChild)
	{
		VSL_DEFINE_MOCK_METHOD(insertBefore)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(newChild);

		VSL_CHECK_VALIDVALUE(refChild);

		VSL_SET_VALIDVALUE_INTERFACE(outNewChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct replaceChildValidValues
	{
		/*[in]*/ IXMLDOMNode* newChild;
		/*[in]*/ IXMLDOMNode* oldChild;
		/*[out,retval]*/ IXMLDOMNode** outOldChild;
		HRESULT retValue;
	};

	STDMETHOD(replaceChild)(
		/*[in]*/ IXMLDOMNode* newChild,
		/*[in]*/ IXMLDOMNode* oldChild,
		/*[out,retval]*/ IXMLDOMNode** outOldChild)
	{
		VSL_DEFINE_MOCK_METHOD(replaceChild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(newChild);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(oldChild);

		VSL_SET_VALIDVALUE_INTERFACE(outOldChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct removeChildValidValues
	{
		/*[in]*/ IXMLDOMNode* childNode;
		/*[out,retval]*/ IXMLDOMNode** oldChild;
		HRESULT retValue;
	};

	STDMETHOD(removeChild)(
		/*[in]*/ IXMLDOMNode* childNode,
		/*[out,retval]*/ IXMLDOMNode** oldChild)
	{
		VSL_DEFINE_MOCK_METHOD(removeChild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(childNode);

		VSL_SET_VALIDVALUE_INTERFACE(oldChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct appendChildValidValues
	{
		/*[in]*/ IXMLDOMNode* newChild;
		/*[out,retval]*/ IXMLDOMNode** outNewChild;
		HRESULT retValue;
	};

	STDMETHOD(appendChild)(
		/*[in]*/ IXMLDOMNode* newChild,
		/*[out,retval]*/ IXMLDOMNode** outNewChild)
	{
		VSL_DEFINE_MOCK_METHOD(appendChild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(newChild);

		VSL_SET_VALIDVALUE_INTERFACE(outNewChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct hasChildNodesValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* hasChild;
		HRESULT retValue;
	};

	STDMETHOD(hasChildNodes)(
		/*[out,retval]*/ VARIANT_BOOL* hasChild)
	{
		VSL_DEFINE_MOCK_METHOD(hasChildNodes)

		VSL_SET_VALIDVALUE(hasChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ownerDocumentValidValues
	{
		/*[out,retval]*/ IXMLDOMDocument** DOMDocument;
		HRESULT retValue;
	};

	STDMETHOD(get_ownerDocument)(
		/*[out,retval]*/ IXMLDOMDocument** DOMDocument)
	{
		VSL_DEFINE_MOCK_METHOD(get_ownerDocument)

		VSL_SET_VALIDVALUE_INTERFACE(DOMDocument);

		VSL_RETURN_VALIDVALUES();
	}
	struct cloneNodeValidValues
	{
		/*[in]*/ VARIANT_BOOL deep;
		/*[out,retval]*/ IXMLDOMNode** cloneRoot;
		HRESULT retValue;
	};

	STDMETHOD(cloneNode)(
		/*[in]*/ VARIANT_BOOL deep,
		/*[out,retval]*/ IXMLDOMNode** cloneRoot)
	{
		VSL_DEFINE_MOCK_METHOD(cloneNode)

		VSL_CHECK_VALIDVALUE(deep);

		VSL_SET_VALIDVALUE_INTERFACE(cloneRoot);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeTypeStringValidValues
	{
		/*[retval,out]*/ BSTR* nodeType;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeTypeString)(
		/*[retval,out]*/ BSTR* nodeType)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeTypeString)

		VSL_SET_VALIDVALUE_BSTR(nodeType);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_textValidValues
	{
		/*[retval,out]*/ BSTR* text;
		HRESULT retValue;
	};

	STDMETHOD(get_text)(
		/*[retval,out]*/ BSTR* text)
	{
		VSL_DEFINE_MOCK_METHOD(get_text)

		VSL_SET_VALIDVALUE_BSTR(text);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_textValidValues
	{
		/*[in]*/ BSTR text;
		HRESULT retValue;
	};

	STDMETHOD(put_text)(
		/*[in]*/ BSTR text)
	{
		VSL_DEFINE_MOCK_METHOD(put_text)

		VSL_CHECK_VALIDVALUE_BSTR(text);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_specifiedValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* isSpecified;
		HRESULT retValue;
	};

	STDMETHOD(get_specified)(
		/*[out,retval]*/ VARIANT_BOOL* isSpecified)
	{
		VSL_DEFINE_MOCK_METHOD(get_specified)

		VSL_SET_VALIDVALUE(isSpecified);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_definitionValidValues
	{
		/*[retval,out]*/ IXMLDOMNode** definitionNode;
		HRESULT retValue;
	};

	STDMETHOD(get_definition)(
		/*[retval,out]*/ IXMLDOMNode** definitionNode)
	{
		VSL_DEFINE_MOCK_METHOD(get_definition)

		VSL_SET_VALIDVALUE_INTERFACE(definitionNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeTypedValueValidValues
	{
		/*[retval,out]*/ VARIANT* typedValue;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeTypedValue)(
		/*[retval,out]*/ VARIANT* typedValue)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeTypedValue)

		VSL_SET_VALIDVALUE_VARIANT(typedValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_nodeTypedValueValidValues
	{
		/*[in]*/ VARIANT typedValue;
		HRESULT retValue;
	};

	STDMETHOD(put_nodeTypedValue)(
		/*[in]*/ VARIANT typedValue)
	{
		VSL_DEFINE_MOCK_METHOD(put_nodeTypedValue)

		VSL_CHECK_VALIDVALUE(typedValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_dataTypeValidValues
	{
		/*[retval,out]*/ VARIANT* dataTypeName;
		HRESULT retValue;
	};

	STDMETHOD(get_dataType)(
		/*[retval,out]*/ VARIANT* dataTypeName)
	{
		VSL_DEFINE_MOCK_METHOD(get_dataType)

		VSL_SET_VALIDVALUE_VARIANT(dataTypeName);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_dataTypeValidValues
	{
		/*[in]*/ BSTR dataTypeName;
		HRESULT retValue;
	};

	STDMETHOD(put_dataType)(
		/*[in]*/ BSTR dataTypeName)
	{
		VSL_DEFINE_MOCK_METHOD(put_dataType)

		VSL_CHECK_VALIDVALUE_BSTR(dataTypeName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_xmlValidValues
	{
		/*[retval,out]*/ BSTR* xmlString;
		HRESULT retValue;
	};

	STDMETHOD(get_xml)(
		/*[retval,out]*/ BSTR* xmlString)
	{
		VSL_DEFINE_MOCK_METHOD(get_xml)

		VSL_SET_VALIDVALUE_BSTR(xmlString);

		VSL_RETURN_VALIDVALUES();
	}
	struct transformNodeValidValues
	{
		/*[in]*/ IXMLDOMNode* stylesheet;
		/*[retval,out]*/ BSTR* xmlString;
		HRESULT retValue;
	};

	STDMETHOD(transformNode)(
		/*[in]*/ IXMLDOMNode* stylesheet,
		/*[retval,out]*/ BSTR* xmlString)
	{
		VSL_DEFINE_MOCK_METHOD(transformNode)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(stylesheet);

		VSL_SET_VALIDVALUE_BSTR(xmlString);

		VSL_RETURN_VALIDVALUES();
	}
	struct selectNodesValidValues
	{
		/*[in]*/ BSTR queryString;
		/*[retval,out]*/ IXMLDOMNodeList** resultList;
		HRESULT retValue;
	};

	STDMETHOD(selectNodes)(
		/*[in]*/ BSTR queryString,
		/*[retval,out]*/ IXMLDOMNodeList** resultList)
	{
		VSL_DEFINE_MOCK_METHOD(selectNodes)

		VSL_CHECK_VALIDVALUE_BSTR(queryString);

		VSL_SET_VALIDVALUE_INTERFACE(resultList);

		VSL_RETURN_VALIDVALUES();
	}
	struct selectSingleNodeValidValues
	{
		/*[in]*/ BSTR queryString;
		/*[retval,out]*/ IXMLDOMNode** resultNode;
		HRESULT retValue;
	};

	STDMETHOD(selectSingleNode)(
		/*[in]*/ BSTR queryString,
		/*[retval,out]*/ IXMLDOMNode** resultNode)
	{
		VSL_DEFINE_MOCK_METHOD(selectSingleNode)

		VSL_CHECK_VALIDVALUE_BSTR(queryString);

		VSL_SET_VALIDVALUE_INTERFACE(resultNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_parsedValidValues
	{
		/*[retval,out]*/ VARIANT_BOOL* isParsed;
		HRESULT retValue;
	};

	STDMETHOD(get_parsed)(
		/*[retval,out]*/ VARIANT_BOOL* isParsed)
	{
		VSL_DEFINE_MOCK_METHOD(get_parsed)

		VSL_SET_VALIDVALUE(isParsed);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_namespaceURIValidValues
	{
		/*[retval,out]*/ BSTR* namespaceURI;
		HRESULT retValue;
	};

	STDMETHOD(get_namespaceURI)(
		/*[retval,out]*/ BSTR* namespaceURI)
	{
		VSL_DEFINE_MOCK_METHOD(get_namespaceURI)

		VSL_SET_VALIDVALUE_BSTR(namespaceURI);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_prefixValidValues
	{
		/*[retval,out]*/ BSTR* prefixString;
		HRESULT retValue;
	};

	STDMETHOD(get_prefix)(
		/*[retval,out]*/ BSTR* prefixString)
	{
		VSL_DEFINE_MOCK_METHOD(get_prefix)

		VSL_SET_VALIDVALUE_BSTR(prefixString);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_baseNameValidValues
	{
		/*[retval,out]*/ BSTR* nameString;
		HRESULT retValue;
	};

	STDMETHOD(get_baseName)(
		/*[retval,out]*/ BSTR* nameString)
	{
		VSL_DEFINE_MOCK_METHOD(get_baseName)

		VSL_SET_VALIDVALUE_BSTR(nameString);

		VSL_RETURN_VALIDVALUES();
	}
	struct transformNodeToObjectValidValues
	{
		/*[in]*/ IXMLDOMNode* stylesheet;
		/*[in]*/ VARIANT outputObject;
		HRESULT retValue;
	};

	STDMETHOD(transformNodeToObject)(
		/*[in]*/ IXMLDOMNode* stylesheet,
		/*[in]*/ VARIANT outputObject)
	{
		VSL_DEFINE_MOCK_METHOD(transformNodeToObject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(stylesheet);

		VSL_CHECK_VALIDVALUE(outputObject);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IXMLDOMNOTATION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIXMLDOMText.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IXMLDOMTEXT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IXMLDOMTEXT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "XmlDom.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IXMLDOMTextNotImpl :
	public IXMLDOMText
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IXMLDOMTextNotImpl)

public:

	typedef IXMLDOMText Interface;

	STDMETHOD(splitText)(
		/*[in]*/ long /*offset*/,
		/*[out,retval]*/ IXMLDOMText** /*rightHandTextNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_data)(
		/*[out,retval]*/ BSTR* /*data*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_data)(
		/*[in]*/ BSTR /*data*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_length)(
		/*[out,retval]*/ long* /*dataLength*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(substringData)(
		/*[in]*/ long /*offset*/,
		/*[in]*/ long /*count*/,
		/*[out,retval]*/ BSTR* /*data*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(appendData)(
		/*[in]*/ BSTR /*data*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(insertData)(
		/*[in]*/ long /*offset*/,
		/*[in]*/ BSTR /*data*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(deleteData)(
		/*[in]*/ long /*offset*/,
		/*[in]*/ long /*count*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(replaceData)(
		/*[in]*/ long /*offset*/,
		/*[in]*/ long /*count*/,
		/*[in]*/ BSTR /*data*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeName)(
		/*[out,retval]*/ BSTR* /*name*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeValue)(
		/*[out,retval]*/ VARIANT* /*value*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_nodeValue)(
		/*[in]*/ VARIANT /*value*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeType)(
		/*[out,retval]*/ DOMNodeType* /*type*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_parentNode)(
		/*[out,retval]*/ IXMLDOMNode** /*parent*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_childNodes)(
		/*[out,retval]*/ IXMLDOMNodeList** /*childList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_firstChild)(
		/*[out,retval]*/ IXMLDOMNode** /*firstChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_lastChild)(
		/*[out,retval]*/ IXMLDOMNode** /*lastChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_previousSibling)(
		/*[out,retval]*/ IXMLDOMNode** /*previousSibling*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nextSibling)(
		/*[out,retval]*/ IXMLDOMNode** /*nextSibling*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_attributes)(
		/*[out,retval]*/ IXMLDOMNamedNodeMap** /*attributeMap*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(insertBefore)(
		/*[in]*/ IXMLDOMNode* /*newChild*/,
		/*[in]*/ VARIANT /*refChild*/,
		/*[out,retval]*/ IXMLDOMNode** /*outNewChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(replaceChild)(
		/*[in]*/ IXMLDOMNode* /*newChild*/,
		/*[in]*/ IXMLDOMNode* /*oldChild*/,
		/*[out,retval]*/ IXMLDOMNode** /*outOldChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(removeChild)(
		/*[in]*/ IXMLDOMNode* /*childNode*/,
		/*[out,retval]*/ IXMLDOMNode** /*oldChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(appendChild)(
		/*[in]*/ IXMLDOMNode* /*newChild*/,
		/*[out,retval]*/ IXMLDOMNode** /*outNewChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(hasChildNodes)(
		/*[out,retval]*/ VARIANT_BOOL* /*hasChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ownerDocument)(
		/*[out,retval]*/ IXMLDOMDocument** /*DOMDocument*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(cloneNode)(
		/*[in]*/ VARIANT_BOOL /*deep*/,
		/*[out,retval]*/ IXMLDOMNode** /*cloneRoot*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeTypeString)(
		/*[retval,out]*/ BSTR* /*nodeType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_text)(
		/*[retval,out]*/ BSTR* /*text*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_text)(
		/*[in]*/ BSTR /*text*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_specified)(
		/*[out,retval]*/ VARIANT_BOOL* /*isSpecified*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_definition)(
		/*[retval,out]*/ IXMLDOMNode** /*definitionNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeTypedValue)(
		/*[retval,out]*/ VARIANT* /*typedValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_nodeTypedValue)(
		/*[in]*/ VARIANT /*typedValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_dataType)(
		/*[retval,out]*/ VARIANT* /*dataTypeName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_dataType)(
		/*[in]*/ BSTR /*dataTypeName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_xml)(
		/*[retval,out]*/ BSTR* /*xmlString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(transformNode)(
		/*[in]*/ IXMLDOMNode* /*stylesheet*/,
		/*[retval,out]*/ BSTR* /*xmlString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(selectNodes)(
		/*[in]*/ BSTR /*queryString*/,
		/*[retval,out]*/ IXMLDOMNodeList** /*resultList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(selectSingleNode)(
		/*[in]*/ BSTR /*queryString*/,
		/*[retval,out]*/ IXMLDOMNode** /*resultNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_parsed)(
		/*[retval,out]*/ VARIANT_BOOL* /*isParsed*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_namespaceURI)(
		/*[retval,out]*/ BSTR* /*namespaceURI*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_prefix)(
		/*[retval,out]*/ BSTR* /*prefixString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_baseName)(
		/*[retval,out]*/ BSTR* /*nameString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(transformNodeToObject)(
		/*[in]*/ IXMLDOMNode* /*stylesheet*/,
		/*[in]*/ VARIANT /*outputObject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class IXMLDOMTextMockImpl :
	public IXMLDOMText,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IXMLDOMTextMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IXMLDOMTextMockImpl)

	typedef IXMLDOMText Interface;
	struct splitTextValidValues
	{
		/*[in]*/ long offset;
		/*[out,retval]*/ IXMLDOMText** rightHandTextNode;
		HRESULT retValue;
	};

	STDMETHOD(splitText)(
		/*[in]*/ long offset,
		/*[out,retval]*/ IXMLDOMText** rightHandTextNode)
	{
		VSL_DEFINE_MOCK_METHOD(splitText)

		VSL_CHECK_VALIDVALUE(offset);

		VSL_SET_VALIDVALUE_INTERFACE(rightHandTextNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_dataValidValues
	{
		/*[out,retval]*/ BSTR* data;
		HRESULT retValue;
	};

	STDMETHOD(get_data)(
		/*[out,retval]*/ BSTR* data)
	{
		VSL_DEFINE_MOCK_METHOD(get_data)

		VSL_SET_VALIDVALUE_BSTR(data);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_dataValidValues
	{
		/*[in]*/ BSTR data;
		HRESULT retValue;
	};

	STDMETHOD(put_data)(
		/*[in]*/ BSTR data)
	{
		VSL_DEFINE_MOCK_METHOD(put_data)

		VSL_CHECK_VALIDVALUE_BSTR(data);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_lengthValidValues
	{
		/*[out,retval]*/ long* dataLength;
		HRESULT retValue;
	};

	STDMETHOD(get_length)(
		/*[out,retval]*/ long* dataLength)
	{
		VSL_DEFINE_MOCK_METHOD(get_length)

		VSL_SET_VALIDVALUE(dataLength);

		VSL_RETURN_VALIDVALUES();
	}
	struct substringDataValidValues
	{
		/*[in]*/ long offset;
		/*[in]*/ long count;
		/*[out,retval]*/ BSTR* data;
		HRESULT retValue;
	};

	STDMETHOD(substringData)(
		/*[in]*/ long offset,
		/*[in]*/ long count,
		/*[out,retval]*/ BSTR* data)
	{
		VSL_DEFINE_MOCK_METHOD(substringData)

		VSL_CHECK_VALIDVALUE(offset);

		VSL_CHECK_VALIDVALUE(count);

		VSL_SET_VALIDVALUE_BSTR(data);

		VSL_RETURN_VALIDVALUES();
	}
	struct appendDataValidValues
	{
		/*[in]*/ BSTR data;
		HRESULT retValue;
	};

	STDMETHOD(appendData)(
		/*[in]*/ BSTR data)
	{
		VSL_DEFINE_MOCK_METHOD(appendData)

		VSL_CHECK_VALIDVALUE_BSTR(data);

		VSL_RETURN_VALIDVALUES();
	}
	struct insertDataValidValues
	{
		/*[in]*/ long offset;
		/*[in]*/ BSTR data;
		HRESULT retValue;
	};

	STDMETHOD(insertData)(
		/*[in]*/ long offset,
		/*[in]*/ BSTR data)
	{
		VSL_DEFINE_MOCK_METHOD(insertData)

		VSL_CHECK_VALIDVALUE(offset);

		VSL_CHECK_VALIDVALUE_BSTR(data);

		VSL_RETURN_VALIDVALUES();
	}
	struct deleteDataValidValues
	{
		/*[in]*/ long offset;
		/*[in]*/ long count;
		HRESULT retValue;
	};

	STDMETHOD(deleteData)(
		/*[in]*/ long offset,
		/*[in]*/ long count)
	{
		VSL_DEFINE_MOCK_METHOD(deleteData)

		VSL_CHECK_VALIDVALUE(offset);

		VSL_CHECK_VALIDVALUE(count);

		VSL_RETURN_VALIDVALUES();
	}
	struct replaceDataValidValues
	{
		/*[in]*/ long offset;
		/*[in]*/ long count;
		/*[in]*/ BSTR data;
		HRESULT retValue;
	};

	STDMETHOD(replaceData)(
		/*[in]*/ long offset,
		/*[in]*/ long count,
		/*[in]*/ BSTR data)
	{
		VSL_DEFINE_MOCK_METHOD(replaceData)

		VSL_CHECK_VALIDVALUE(offset);

		VSL_CHECK_VALIDVALUE(count);

		VSL_CHECK_VALIDVALUE_BSTR(data);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeNameValidValues
	{
		/*[out,retval]*/ BSTR* name;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeName)(
		/*[out,retval]*/ BSTR* name)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeName)

		VSL_SET_VALIDVALUE_BSTR(name);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeValueValidValues
	{
		/*[out,retval]*/ VARIANT* value;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeValue)(
		/*[out,retval]*/ VARIANT* value)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeValue)

		VSL_SET_VALIDVALUE_VARIANT(value);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_nodeValueValidValues
	{
		/*[in]*/ VARIANT value;
		HRESULT retValue;
	};

	STDMETHOD(put_nodeValue)(
		/*[in]*/ VARIANT value)
	{
		VSL_DEFINE_MOCK_METHOD(put_nodeValue)

		VSL_CHECK_VALIDVALUE(value);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeTypeValidValues
	{
		/*[out,retval]*/ DOMNodeType* type;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeType)(
		/*[out,retval]*/ DOMNodeType* type)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeType)

		VSL_SET_VALIDVALUE(type);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_parentNodeValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** parent;
		HRESULT retValue;
	};

	STDMETHOD(get_parentNode)(
		/*[out,retval]*/ IXMLDOMNode** parent)
	{
		VSL_DEFINE_MOCK_METHOD(get_parentNode)

		VSL_SET_VALIDVALUE_INTERFACE(parent);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_childNodesValidValues
	{
		/*[out,retval]*/ IXMLDOMNodeList** childList;
		HRESULT retValue;
	};

	STDMETHOD(get_childNodes)(
		/*[out,retval]*/ IXMLDOMNodeList** childList)
	{
		VSL_DEFINE_MOCK_METHOD(get_childNodes)

		VSL_SET_VALIDVALUE_INTERFACE(childList);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_firstChildValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** firstChild;
		HRESULT retValue;
	};

	STDMETHOD(get_firstChild)(
		/*[out,retval]*/ IXMLDOMNode** firstChild)
	{
		VSL_DEFINE_MOCK_METHOD(get_firstChild)

		VSL_SET_VALIDVALUE_INTERFACE(firstChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_lastChildValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** lastChild;
		HRESULT retValue;
	};

	STDMETHOD(get_lastChild)(
		/*[out,retval]*/ IXMLDOMNode** lastChild)
	{
		VSL_DEFINE_MOCK_METHOD(get_lastChild)

		VSL_SET_VALIDVALUE_INTERFACE(lastChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_previousSiblingValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** previousSibling;
		HRESULT retValue;
	};

	STDMETHOD(get_previousSibling)(
		/*[out,retval]*/ IXMLDOMNode** previousSibling)
	{
		VSL_DEFINE_MOCK_METHOD(get_previousSibling)

		VSL_SET_VALIDVALUE_INTERFACE(previousSibling);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nextSiblingValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** nextSibling;
		HRESULT retValue;
	};

	STDMETHOD(get_nextSibling)(
		/*[out,retval]*/ IXMLDOMNode** nextSibling)
	{
		VSL_DEFINE_MOCK_METHOD(get_nextSibling)

		VSL_SET_VALIDVALUE_INTERFACE(nextSibling);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_attributesValidValues
	{
		/*[out,retval]*/ IXMLDOMNamedNodeMap** attributeMap;
		HRESULT retValue;
	};

	STDMETHOD(get_attributes)(
		/*[out,retval]*/ IXMLDOMNamedNodeMap** attributeMap)
	{
		VSL_DEFINE_MOCK_METHOD(get_attributes)

		VSL_SET_VALIDVALUE_INTERFACE(attributeMap);

		VSL_RETURN_VALIDVALUES();
	}
	struct insertBeforeValidValues
	{
		/*[in]*/ IXMLDOMNode* newChild;
		/*[in]*/ VARIANT refChild;
		/*[out,retval]*/ IXMLDOMNode** outNewChild;
		HRESULT retValue;
	};

	STDMETHOD(insertBefore)(
		/*[in]*/ IXMLDOMNode* newChild,
		/*[in]*/ VARIANT refChild,
		/*[out,retval]*/ IXMLDOMNode** outNewChild)
	{
		VSL_DEFINE_MOCK_METHOD(insertBefore)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(newChild);

		VSL_CHECK_VALIDVALUE(refChild);

		VSL_SET_VALIDVALUE_INTERFACE(outNewChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct replaceChildValidValues
	{
		/*[in]*/ IXMLDOMNode* newChild;
		/*[in]*/ IXMLDOMNode* oldChild;
		/*[out,retval]*/ IXMLDOMNode** outOldChild;
		HRESULT retValue;
	};

	STDMETHOD(replaceChild)(
		/*[in]*/ IXMLDOMNode* newChild,
		/*[in]*/ IXMLDOMNode* oldChild,
		/*[out,retval]*/ IXMLDOMNode** outOldChild)
	{
		VSL_DEFINE_MOCK_METHOD(replaceChild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(newChild);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(oldChild);

		VSL_SET_VALIDVALUE_INTERFACE(outOldChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct removeChildValidValues
	{
		/*[in]*/ IXMLDOMNode* childNode;
		/*[out,retval]*/ IXMLDOMNode** oldChild;
		HRESULT retValue;
	};

	STDMETHOD(removeChild)(
		/*[in]*/ IXMLDOMNode* childNode,
		/*[out,retval]*/ IXMLDOMNode** oldChild)
	{
		VSL_DEFINE_MOCK_METHOD(removeChild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(childNode);

		VSL_SET_VALIDVALUE_INTERFACE(oldChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct appendChildValidValues
	{
		/*[in]*/ IXMLDOMNode* newChild;
		/*[out,retval]*/ IXMLDOMNode** outNewChild;
		HRESULT retValue;
	};

	STDMETHOD(appendChild)(
		/*[in]*/ IXMLDOMNode* newChild,
		/*[out,retval]*/ IXMLDOMNode** outNewChild)
	{
		VSL_DEFINE_MOCK_METHOD(appendChild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(newChild);

		VSL_SET_VALIDVALUE_INTERFACE(outNewChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct hasChildNodesValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* hasChild;
		HRESULT retValue;
	};

	STDMETHOD(hasChildNodes)(
		/*[out,retval]*/ VARIANT_BOOL* hasChild)
	{
		VSL_DEFINE_MOCK_METHOD(hasChildNodes)

		VSL_SET_VALIDVALUE(hasChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ownerDocumentValidValues
	{
		/*[out,retval]*/ IXMLDOMDocument** DOMDocument;
		HRESULT retValue;
	};

	STDMETHOD(get_ownerDocument)(
		/*[out,retval]*/ IXMLDOMDocument** DOMDocument)
	{
		VSL_DEFINE_MOCK_METHOD(get_ownerDocument)

		VSL_SET_VALIDVALUE_INTERFACE(DOMDocument);

		VSL_RETURN_VALIDVALUES();
	}
	struct cloneNodeValidValues
	{
		/*[in]*/ VARIANT_BOOL deep;
		/*[out,retval]*/ IXMLDOMNode** cloneRoot;
		HRESULT retValue;
	};

	STDMETHOD(cloneNode)(
		/*[in]*/ VARIANT_BOOL deep,
		/*[out,retval]*/ IXMLDOMNode** cloneRoot)
	{
		VSL_DEFINE_MOCK_METHOD(cloneNode)

		VSL_CHECK_VALIDVALUE(deep);

		VSL_SET_VALIDVALUE_INTERFACE(cloneRoot);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeTypeStringValidValues
	{
		/*[retval,out]*/ BSTR* nodeType;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeTypeString)(
		/*[retval,out]*/ BSTR* nodeType)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeTypeString)

		VSL_SET_VALIDVALUE_BSTR(nodeType);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_textValidValues
	{
		/*[retval,out]*/ BSTR* text;
		HRESULT retValue;
	};

	STDMETHOD(get_text)(
		/*[retval,out]*/ BSTR* text)
	{
		VSL_DEFINE_MOCK_METHOD(get_text)

		VSL_SET_VALIDVALUE_BSTR(text);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_textValidValues
	{
		/*[in]*/ BSTR text;
		HRESULT retValue;
	};

	STDMETHOD(put_text)(
		/*[in]*/ BSTR text)
	{
		VSL_DEFINE_MOCK_METHOD(put_text)

		VSL_CHECK_VALIDVALUE_BSTR(text);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_specifiedValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* isSpecified;
		HRESULT retValue;
	};

	STDMETHOD(get_specified)(
		/*[out,retval]*/ VARIANT_BOOL* isSpecified)
	{
		VSL_DEFINE_MOCK_METHOD(get_specified)

		VSL_SET_VALIDVALUE(isSpecified);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_definitionValidValues
	{
		/*[retval,out]*/ IXMLDOMNode** definitionNode;
		HRESULT retValue;
	};

	STDMETHOD(get_definition)(
		/*[retval,out]*/ IXMLDOMNode** definitionNode)
	{
		VSL_DEFINE_MOCK_METHOD(get_definition)

		VSL_SET_VALIDVALUE_INTERFACE(definitionNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeTypedValueValidValues
	{
		/*[retval,out]*/ VARIANT* typedValue;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeTypedValue)(
		/*[retval,out]*/ VARIANT* typedValue)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeTypedValue)

		VSL_SET_VALIDVALUE_VARIANT(typedValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_nodeTypedValueValidValues
	{
		/*[in]*/ VARIANT typedValue;
		HRESULT retValue;
	};

	STDMETHOD(put_nodeTypedValue)(
		/*[in]*/ VARIANT typedValue)
	{
		VSL_DEFINE_MOCK_METHOD(put_nodeTypedValue)

		VSL_CHECK_VALIDVALUE(typedValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_dataTypeValidValues
	{
		/*[retval,out]*/ VARIANT* dataTypeName;
		HRESULT retValue;
	};

	STDMETHOD(get_dataType)(
		/*[retval,out]*/ VARIANT* dataTypeName)
	{
		VSL_DEFINE_MOCK_METHOD(get_dataType)

		VSL_SET_VALIDVALUE_VARIANT(dataTypeName);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_dataTypeValidValues
	{
		/*[in]*/ BSTR dataTypeName;
		HRESULT retValue;
	};

	STDMETHOD(put_dataType)(
		/*[in]*/ BSTR dataTypeName)
	{
		VSL_DEFINE_MOCK_METHOD(put_dataType)

		VSL_CHECK_VALIDVALUE_BSTR(dataTypeName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_xmlValidValues
	{
		/*[retval,out]*/ BSTR* xmlString;
		HRESULT retValue;
	};

	STDMETHOD(get_xml)(
		/*[retval,out]*/ BSTR* xmlString)
	{
		VSL_DEFINE_MOCK_METHOD(get_xml)

		VSL_SET_VALIDVALUE_BSTR(xmlString);

		VSL_RETURN_VALIDVALUES();
	}
	struct transformNodeValidValues
	{
		/*[in]*/ IXMLDOMNode* stylesheet;
		/*[retval,out]*/ BSTR* xmlString;
		HRESULT retValue;
	};

	STDMETHOD(transformNode)(
		/*[in]*/ IXMLDOMNode* stylesheet,
		/*[retval,out]*/ BSTR* xmlString)
	{
		VSL_DEFINE_MOCK_METHOD(transformNode)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(stylesheet);

		VSL_SET_VALIDVALUE_BSTR(xmlString);

		VSL_RETURN_VALIDVALUES();
	}
	struct selectNodesValidValues
	{
		/*[in]*/ BSTR queryString;
		/*[retval,out]*/ IXMLDOMNodeList** resultList;
		HRESULT retValue;
	};

	STDMETHOD(selectNodes)(
		/*[in]*/ BSTR queryString,
		/*[retval,out]*/ IXMLDOMNodeList** resultList)
	{
		VSL_DEFINE_MOCK_METHOD(selectNodes)

		VSL_CHECK_VALIDVALUE_BSTR(queryString);

		VSL_SET_VALIDVALUE_INTERFACE(resultList);

		VSL_RETURN_VALIDVALUES();
	}
	struct selectSingleNodeValidValues
	{
		/*[in]*/ BSTR queryString;
		/*[retval,out]*/ IXMLDOMNode** resultNode;
		HRESULT retValue;
	};

	STDMETHOD(selectSingleNode)(
		/*[in]*/ BSTR queryString,
		/*[retval,out]*/ IXMLDOMNode** resultNode)
	{
		VSL_DEFINE_MOCK_METHOD(selectSingleNode)

		VSL_CHECK_VALIDVALUE_BSTR(queryString);

		VSL_SET_VALIDVALUE_INTERFACE(resultNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_parsedValidValues
	{
		/*[retval,out]*/ VARIANT_BOOL* isParsed;
		HRESULT retValue;
	};

	STDMETHOD(get_parsed)(
		/*[retval,out]*/ VARIANT_BOOL* isParsed)
	{
		VSL_DEFINE_MOCK_METHOD(get_parsed)

		VSL_SET_VALIDVALUE(isParsed);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_namespaceURIValidValues
	{
		/*[retval,out]*/ BSTR* namespaceURI;
		HRESULT retValue;
	};

	STDMETHOD(get_namespaceURI)(
		/*[retval,out]*/ BSTR* namespaceURI)
	{
		VSL_DEFINE_MOCK_METHOD(get_namespaceURI)

		VSL_SET_VALIDVALUE_BSTR(namespaceURI);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_prefixValidValues
	{
		/*[retval,out]*/ BSTR* prefixString;
		HRESULT retValue;
	};

	STDMETHOD(get_prefix)(
		/*[retval,out]*/ BSTR* prefixString)
	{
		VSL_DEFINE_MOCK_METHOD(get_prefix)

		VSL_SET_VALIDVALUE_BSTR(prefixString);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_baseNameValidValues
	{
		/*[retval,out]*/ BSTR* nameString;
		HRESULT retValue;
	};

	STDMETHOD(get_baseName)(
		/*[retval,out]*/ BSTR* nameString)
	{
		VSL_DEFINE_MOCK_METHOD(get_baseName)

		VSL_SET_VALIDVALUE_BSTR(nameString);

		VSL_RETURN_VALIDVALUES();
	}
	struct transformNodeToObjectValidValues
	{
		/*[in]*/ IXMLDOMNode* stylesheet;
		/*[in]*/ VARIANT outputObject;
		HRESULT retValue;
	};

	STDMETHOD(transformNodeToObject)(
		/*[in]*/ IXMLDOMNode* stylesheet,
		/*[in]*/ VARIANT outputObject)
	{
		VSL_DEFINE_MOCK_METHOD(transformNodeToObject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(stylesheet);

		VSL_CHECK_VALIDVALUE(outputObject);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IXMLDOMTEXT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIXMLDOMProcessingInstruction.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IXMLDOMPROCESSINGINSTRUCTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IXMLDOMPROCESSINGINSTRUCTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "XmlDom.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IXMLDOMProcessingInstructionNotImpl :
	public IXMLDOMProcessingInstruction
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IXMLDOMProcessingInstructionNotImpl)

public:

	typedef IXMLDOMProcessingInstruction Interface;

	STDMETHOD(get_target)(
		/*[out,retval]*/ BSTR* /*name*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_data)(
		/*[out,retval]*/ BSTR* /*value*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_data)(
		/*[in]*/ BSTR /*value*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeName)(
		/*[out,retval]*/ BSTR* /*name*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeValue)(
		/*[out,retval]*/ VARIANT* /*value*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_nodeValue)(
		/*[in]*/ VARIANT /*value*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeType)(
		/*[out,retval]*/ DOMNodeType* /*type*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_parentNode)(
		/*[out,retval]*/ IXMLDOMNode** /*parent*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_childNodes)(
		/*[out,retval]*/ IXMLDOMNodeList** /*childList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_firstChild)(
		/*[out,retval]*/ IXMLDOMNode** /*firstChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_lastChild)(
		/*[out,retval]*/ IXMLDOMNode** /*lastChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_previousSibling)(
		/*[out,retval]*/ IXMLDOMNode** /*previousSibling*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nextSibling)(
		/*[out,retval]*/ IXMLDOMNode** /*nextSibling*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_attributes)(
		/*[out,retval]*/ IXMLDOMNamedNodeMap** /*attributeMap*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(insertBefore)(
		/*[in]*/ IXMLDOMNode* /*newChild*/,
		/*[in]*/ VARIANT /*refChild*/,
		/*[out,retval]*/ IXMLDOMNode** /*outNewChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(replaceChild)(
		/*[in]*/ IXMLDOMNode* /*newChild*/,
		/*[in]*/ IXMLDOMNode* /*oldChild*/,
		/*[out,retval]*/ IXMLDOMNode** /*outOldChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(removeChild)(
		/*[in]*/ IXMLDOMNode* /*childNode*/,
		/*[out,retval]*/ IXMLDOMNode** /*oldChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(appendChild)(
		/*[in]*/ IXMLDOMNode* /*newChild*/,
		/*[out,retval]*/ IXMLDOMNode** /*outNewChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(hasChildNodes)(
		/*[out,retval]*/ VARIANT_BOOL* /*hasChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ownerDocument)(
		/*[out,retval]*/ IXMLDOMDocument** /*DOMDocument*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(cloneNode)(
		/*[in]*/ VARIANT_BOOL /*deep*/,
		/*[out,retval]*/ IXMLDOMNode** /*cloneRoot*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeTypeString)(
		/*[retval,out]*/ BSTR* /*nodeType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_text)(
		/*[retval,out]*/ BSTR* /*text*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_text)(
		/*[in]*/ BSTR /*text*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_specified)(
		/*[out,retval]*/ VARIANT_BOOL* /*isSpecified*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_definition)(
		/*[retval,out]*/ IXMLDOMNode** /*definitionNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeTypedValue)(
		/*[retval,out]*/ VARIANT* /*typedValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_nodeTypedValue)(
		/*[in]*/ VARIANT /*typedValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_dataType)(
		/*[retval,out]*/ VARIANT* /*dataTypeName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_dataType)(
		/*[in]*/ BSTR /*dataTypeName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_xml)(
		/*[retval,out]*/ BSTR* /*xmlString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(transformNode)(
		/*[in]*/ IXMLDOMNode* /*stylesheet*/,
		/*[retval,out]*/ BSTR* /*xmlString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(selectNodes)(
		/*[in]*/ BSTR /*queryString*/,
		/*[retval,out]*/ IXMLDOMNodeList** /*resultList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(selectSingleNode)(
		/*[in]*/ BSTR /*queryString*/,
		/*[retval,out]*/ IXMLDOMNode** /*resultNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_parsed)(
		/*[retval,out]*/ VARIANT_BOOL* /*isParsed*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_namespaceURI)(
		/*[retval,out]*/ BSTR* /*namespaceURI*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_prefix)(
		/*[retval,out]*/ BSTR* /*prefixString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_baseName)(
		/*[retval,out]*/ BSTR* /*nameString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(transformNodeToObject)(
		/*[in]*/ IXMLDOMNode* /*stylesheet*/,
		/*[in]*/ VARIANT /*outputObject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class IXMLDOMProcessingInstructionMockImpl :
	public IXMLDOMProcessingInstruction,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IXMLDOMProcessingInstructionMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IXMLDOMProcessingInstructionMockImpl)

	typedef IXMLDOMProcessingInstruction Interface;
	struct get_targetValidValues
	{
		/*[out,retval]*/ BSTR* name;
		HRESULT retValue;
	};

	STDMETHOD(get_target)(
		/*[out,retval]*/ BSTR* name)
	{
		VSL_DEFINE_MOCK_METHOD(get_target)

		VSL_SET_VALIDVALUE_BSTR(name);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_dataValidValues
	{
		/*[out,retval]*/ BSTR* value;
		HRESULT retValue;
	};

	STDMETHOD(get_data)(
		/*[out,retval]*/ BSTR* value)
	{
		VSL_DEFINE_MOCK_METHOD(get_data)

		VSL_SET_VALIDVALUE_BSTR(value);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_dataValidValues
	{
		/*[in]*/ BSTR value;
		HRESULT retValue;
	};

	STDMETHOD(put_data)(
		/*[in]*/ BSTR value)
	{
		VSL_DEFINE_MOCK_METHOD(put_data)

		VSL_CHECK_VALIDVALUE_BSTR(value);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeNameValidValues
	{
		/*[out,retval]*/ BSTR* name;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeName)(
		/*[out,retval]*/ BSTR* name)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeName)

		VSL_SET_VALIDVALUE_BSTR(name);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeValueValidValues
	{
		/*[out,retval]*/ VARIANT* value;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeValue)(
		/*[out,retval]*/ VARIANT* value)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeValue)

		VSL_SET_VALIDVALUE_VARIANT(value);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_nodeValueValidValues
	{
		/*[in]*/ VARIANT value;
		HRESULT retValue;
	};

	STDMETHOD(put_nodeValue)(
		/*[in]*/ VARIANT value)
	{
		VSL_DEFINE_MOCK_METHOD(put_nodeValue)

		VSL_CHECK_VALIDVALUE(value);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeTypeValidValues
	{
		/*[out,retval]*/ DOMNodeType* type;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeType)(
		/*[out,retval]*/ DOMNodeType* type)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeType)

		VSL_SET_VALIDVALUE(type);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_parentNodeValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** parent;
		HRESULT retValue;
	};

	STDMETHOD(get_parentNode)(
		/*[out,retval]*/ IXMLDOMNode** parent)
	{
		VSL_DEFINE_MOCK_METHOD(get_parentNode)

		VSL_SET_VALIDVALUE_INTERFACE(parent);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_childNodesValidValues
	{
		/*[out,retval]*/ IXMLDOMNodeList** childList;
		HRESULT retValue;
	};

	STDMETHOD(get_childNodes)(
		/*[out,retval]*/ IXMLDOMNodeList** childList)
	{
		VSL_DEFINE_MOCK_METHOD(get_childNodes)

		VSL_SET_VALIDVALUE_INTERFACE(childList);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_firstChildValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** firstChild;
		HRESULT retValue;
	};

	STDMETHOD(get_firstChild)(
		/*[out,retval]*/ IXMLDOMNode** firstChild)
	{
		VSL_DEFINE_MOCK_METHOD(get_firstChild)

		VSL_SET_VALIDVALUE_INTERFACE(firstChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_lastChildValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** lastChild;
		HRESULT retValue;
	};

	STDMETHOD(get_lastChild)(
		/*[out,retval]*/ IXMLDOMNode** lastChild)
	{
		VSL_DEFINE_MOCK_METHOD(get_lastChild)

		VSL_SET_VALIDVALUE_INTERFACE(lastChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_previousSiblingValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** previousSibling;
		HRESULT retValue;
	};

	STDMETHOD(get_previousSibling)(
		/*[out,retval]*/ IXMLDOMNode** previousSibling)
	{
		VSL_DEFINE_MOCK_METHOD(get_previousSibling)

		VSL_SET_VALIDVALUE_INTERFACE(previousSibling);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nextSiblingValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** nextSibling;
		HRESULT retValue;
	};

	STDMETHOD(get_nextSibling)(
		/*[out,retval]*/ IXMLDOMNode** nextSibling)
	{
		VSL_DEFINE_MOCK_METHOD(get_nextSibling)

		VSL_SET_VALIDVALUE_INTERFACE(nextSibling);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_attributesValidValues
	{
		/*[out,retval]*/ IXMLDOMNamedNodeMap** attributeMap;
		HRESULT retValue;
	};

	STDMETHOD(get_attributes)(
		/*[out,retval]*/ IXMLDOMNamedNodeMap** attributeMap)
	{
		VSL_DEFINE_MOCK_METHOD(get_attributes)

		VSL_SET_VALIDVALUE_INTERFACE(attributeMap);

		VSL_RETURN_VALIDVALUES();
	}
	struct insertBeforeValidValues
	{
		/*[in]*/ IXMLDOMNode* newChild;
		/*[in]*/ VARIANT refChild;
		/*[out,retval]*/ IXMLDOMNode** outNewChild;
		HRESULT retValue;
	};

	STDMETHOD(insertBefore)(
		/*[in]*/ IXMLDOMNode* newChild,
		/*[in]*/ VARIANT refChild,
		/*[out,retval]*/ IXMLDOMNode** outNewChild)
	{
		VSL_DEFINE_MOCK_METHOD(insertBefore)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(newChild);

		VSL_CHECK_VALIDVALUE(refChild);

		VSL_SET_VALIDVALUE_INTERFACE(outNewChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct replaceChildValidValues
	{
		/*[in]*/ IXMLDOMNode* newChild;
		/*[in]*/ IXMLDOMNode* oldChild;
		/*[out,retval]*/ IXMLDOMNode** outOldChild;
		HRESULT retValue;
	};

	STDMETHOD(replaceChild)(
		/*[in]*/ IXMLDOMNode* newChild,
		/*[in]*/ IXMLDOMNode* oldChild,
		/*[out,retval]*/ IXMLDOMNode** outOldChild)
	{
		VSL_DEFINE_MOCK_METHOD(replaceChild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(newChild);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(oldChild);

		VSL_SET_VALIDVALUE_INTERFACE(outOldChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct removeChildValidValues
	{
		/*[in]*/ IXMLDOMNode* childNode;
		/*[out,retval]*/ IXMLDOMNode** oldChild;
		HRESULT retValue;
	};

	STDMETHOD(removeChild)(
		/*[in]*/ IXMLDOMNode* childNode,
		/*[out,retval]*/ IXMLDOMNode** oldChild)
	{
		VSL_DEFINE_MOCK_METHOD(removeChild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(childNode);

		VSL_SET_VALIDVALUE_INTERFACE(oldChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct appendChildValidValues
	{
		/*[in]*/ IXMLDOMNode* newChild;
		/*[out,retval]*/ IXMLDOMNode** outNewChild;
		HRESULT retValue;
	};

	STDMETHOD(appendChild)(
		/*[in]*/ IXMLDOMNode* newChild,
		/*[out,retval]*/ IXMLDOMNode** outNewChild)
	{
		VSL_DEFINE_MOCK_METHOD(appendChild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(newChild);

		VSL_SET_VALIDVALUE_INTERFACE(outNewChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct hasChildNodesValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* hasChild;
		HRESULT retValue;
	};

	STDMETHOD(hasChildNodes)(
		/*[out,retval]*/ VARIANT_BOOL* hasChild)
	{
		VSL_DEFINE_MOCK_METHOD(hasChildNodes)

		VSL_SET_VALIDVALUE(hasChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ownerDocumentValidValues
	{
		/*[out,retval]*/ IXMLDOMDocument** DOMDocument;
		HRESULT retValue;
	};

	STDMETHOD(get_ownerDocument)(
		/*[out,retval]*/ IXMLDOMDocument** DOMDocument)
	{
		VSL_DEFINE_MOCK_METHOD(get_ownerDocument)

		VSL_SET_VALIDVALUE_INTERFACE(DOMDocument);

		VSL_RETURN_VALIDVALUES();
	}
	struct cloneNodeValidValues
	{
		/*[in]*/ VARIANT_BOOL deep;
		/*[out,retval]*/ IXMLDOMNode** cloneRoot;
		HRESULT retValue;
	};

	STDMETHOD(cloneNode)(
		/*[in]*/ VARIANT_BOOL deep,
		/*[out,retval]*/ IXMLDOMNode** cloneRoot)
	{
		VSL_DEFINE_MOCK_METHOD(cloneNode)

		VSL_CHECK_VALIDVALUE(deep);

		VSL_SET_VALIDVALUE_INTERFACE(cloneRoot);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeTypeStringValidValues
	{
		/*[retval,out]*/ BSTR* nodeType;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeTypeString)(
		/*[retval,out]*/ BSTR* nodeType)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeTypeString)

		VSL_SET_VALIDVALUE_BSTR(nodeType);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_textValidValues
	{
		/*[retval,out]*/ BSTR* text;
		HRESULT retValue;
	};

	STDMETHOD(get_text)(
		/*[retval,out]*/ BSTR* text)
	{
		VSL_DEFINE_MOCK_METHOD(get_text)

		VSL_SET_VALIDVALUE_BSTR(text);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_textValidValues
	{
		/*[in]*/ BSTR text;
		HRESULT retValue;
	};

	STDMETHOD(put_text)(
		/*[in]*/ BSTR text)
	{
		VSL_DEFINE_MOCK_METHOD(put_text)

		VSL_CHECK_VALIDVALUE_BSTR(text);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_specifiedValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* isSpecified;
		HRESULT retValue;
	};

	STDMETHOD(get_specified)(
		/*[out,retval]*/ VARIANT_BOOL* isSpecified)
	{
		VSL_DEFINE_MOCK_METHOD(get_specified)

		VSL_SET_VALIDVALUE(isSpecified);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_definitionValidValues
	{
		/*[retval,out]*/ IXMLDOMNode** definitionNode;
		HRESULT retValue;
	};

	STDMETHOD(get_definition)(
		/*[retval,out]*/ IXMLDOMNode** definitionNode)
	{
		VSL_DEFINE_MOCK_METHOD(get_definition)

		VSL_SET_VALIDVALUE_INTERFACE(definitionNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeTypedValueValidValues
	{
		/*[retval,out]*/ VARIANT* typedValue;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeTypedValue)(
		/*[retval,out]*/ VARIANT* typedValue)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeTypedValue)

		VSL_SET_VALIDVALUE_VARIANT(typedValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_nodeTypedValueValidValues
	{
		/*[in]*/ VARIANT typedValue;
		HRESULT retValue;
	};

	STDMETHOD(put_nodeTypedValue)(
		/*[in]*/ VARIANT typedValue)
	{
		VSL_DEFINE_MOCK_METHOD(put_nodeTypedValue)

		VSL_CHECK_VALIDVALUE(typedValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_dataTypeValidValues
	{
		/*[retval,out]*/ VARIANT* dataTypeName;
		HRESULT retValue;
	};

	STDMETHOD(get_dataType)(
		/*[retval,out]*/ VARIANT* dataTypeName)
	{
		VSL_DEFINE_MOCK_METHOD(get_dataType)

		VSL_SET_VALIDVALUE_VARIANT(dataTypeName);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_dataTypeValidValues
	{
		/*[in]*/ BSTR dataTypeName;
		HRESULT retValue;
	};

	STDMETHOD(put_dataType)(
		/*[in]*/ BSTR dataTypeName)
	{
		VSL_DEFINE_MOCK_METHOD(put_dataType)

		VSL_CHECK_VALIDVALUE_BSTR(dataTypeName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_xmlValidValues
	{
		/*[retval,out]*/ BSTR* xmlString;
		HRESULT retValue;
	};

	STDMETHOD(get_xml)(
		/*[retval,out]*/ BSTR* xmlString)
	{
		VSL_DEFINE_MOCK_METHOD(get_xml)

		VSL_SET_VALIDVALUE_BSTR(xmlString);

		VSL_RETURN_VALIDVALUES();
	}
	struct transformNodeValidValues
	{
		/*[in]*/ IXMLDOMNode* stylesheet;
		/*[retval,out]*/ BSTR* xmlString;
		HRESULT retValue;
	};

	STDMETHOD(transformNode)(
		/*[in]*/ IXMLDOMNode* stylesheet,
		/*[retval,out]*/ BSTR* xmlString)
	{
		VSL_DEFINE_MOCK_METHOD(transformNode)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(stylesheet);

		VSL_SET_VALIDVALUE_BSTR(xmlString);

		VSL_RETURN_VALIDVALUES();
	}
	struct selectNodesValidValues
	{
		/*[in]*/ BSTR queryString;
		/*[retval,out]*/ IXMLDOMNodeList** resultList;
		HRESULT retValue;
	};

	STDMETHOD(selectNodes)(
		/*[in]*/ BSTR queryString,
		/*[retval,out]*/ IXMLDOMNodeList** resultList)
	{
		VSL_DEFINE_MOCK_METHOD(selectNodes)

		VSL_CHECK_VALIDVALUE_BSTR(queryString);

		VSL_SET_VALIDVALUE_INTERFACE(resultList);

		VSL_RETURN_VALIDVALUES();
	}
	struct selectSingleNodeValidValues
	{
		/*[in]*/ BSTR queryString;
		/*[retval,out]*/ IXMLDOMNode** resultNode;
		HRESULT retValue;
	};

	STDMETHOD(selectSingleNode)(
		/*[in]*/ BSTR queryString,
		/*[retval,out]*/ IXMLDOMNode** resultNode)
	{
		VSL_DEFINE_MOCK_METHOD(selectSingleNode)

		VSL_CHECK_VALIDVALUE_BSTR(queryString);

		VSL_SET_VALIDVALUE_INTERFACE(resultNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_parsedValidValues
	{
		/*[retval,out]*/ VARIANT_BOOL* isParsed;
		HRESULT retValue;
	};

	STDMETHOD(get_parsed)(
		/*[retval,out]*/ VARIANT_BOOL* isParsed)
	{
		VSL_DEFINE_MOCK_METHOD(get_parsed)

		VSL_SET_VALIDVALUE(isParsed);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_namespaceURIValidValues
	{
		/*[retval,out]*/ BSTR* namespaceURI;
		HRESULT retValue;
	};

	STDMETHOD(get_namespaceURI)(
		/*[retval,out]*/ BSTR* namespaceURI)
	{
		VSL_DEFINE_MOCK_METHOD(get_namespaceURI)

		VSL_SET_VALIDVALUE_BSTR(namespaceURI);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_prefixValidValues
	{
		/*[retval,out]*/ BSTR* prefixString;
		HRESULT retValue;
	};

	STDMETHOD(get_prefix)(
		/*[retval,out]*/ BSTR* prefixString)
	{
		VSL_DEFINE_MOCK_METHOD(get_prefix)

		VSL_SET_VALIDVALUE_BSTR(prefixString);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_baseNameValidValues
	{
		/*[retval,out]*/ BSTR* nameString;
		HRESULT retValue;
	};

	STDMETHOD(get_baseName)(
		/*[retval,out]*/ BSTR* nameString)
	{
		VSL_DEFINE_MOCK_METHOD(get_baseName)

		VSL_SET_VALIDVALUE_BSTR(nameString);

		VSL_RETURN_VALIDVALUES();
	}
	struct transformNodeToObjectValidValues
	{
		/*[in]*/ IXMLDOMNode* stylesheet;
		/*[in]*/ VARIANT outputObject;
		HRESULT retValue;
	};

	STDMETHOD(transformNodeToObject)(
		/*[in]*/ IXMLDOMNode* stylesheet,
		/*[in]*/ VARIANT outputObject)
	{
		VSL_DEFINE_MOCK_METHOD(transformNodeToObject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(stylesheet);

		VSL_CHECK_VALIDVALUE(outputObject);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IXMLDOMPROCESSINGINSTRUCTION_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIXMLHttpRequest.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IXMLHTTPREQUEST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IXMLHTTPREQUEST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "XmlDom.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IXMLHttpRequestNotImpl :
	public IXMLHttpRequest
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IXMLHttpRequestNotImpl)

public:

	typedef IXMLHttpRequest Interface;

	STDMETHOD(open)(
		/*[in]*/ BSTR /*bstrMethod*/,
		/*[in]*/ BSTR /*bstrUrl*/,
		/*[in,optional]*/ VARIANT /*varAsync*/,
		/*[in,optional]*/ VARIANT /*bstrUser*/,
		/*[in,optional]*/ VARIANT /*bstrPassword*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(setRequestHeader)(
		/*[in]*/ BSTR /*bstrHeader*/,
		/*[in]*/ BSTR /*bstrValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(getResponseHeader)(
		/*[in]*/ BSTR /*bstrHeader*/,
		/*[out,retval]*/ BSTR* /*pbstrValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(getAllResponseHeaders)(
		/*[out,retval]*/ BSTR* /*pbstrHeaders*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(send)(
		/*[in,optional]*/ VARIANT /*varBody*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(abort)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_status)(
		/*[out,retval]*/ long* /*plStatus*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_statusText)(
		/*[out,retval]*/ BSTR* /*pbstrStatus*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_responseXML)(
		/*[out,retval]*/ IDispatch** /*ppBody*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_responseText)(
		/*[out,retval]*/ BSTR* /*pbstrBody*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_responseBody)(
		/*[out,retval]*/ VARIANT* /*pvarBody*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_responseStream)(
		/*[out,retval]*/ VARIANT* /*pvarBody*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_readyState)(
		/*[out,retval]*/ long* /*plState*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_onreadystatechange)(
		/*[in]*/ IDispatch* /*pReadyStateSink*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class IXMLHttpRequestMockImpl :
	public IXMLHttpRequest,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IXMLHttpRequestMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IXMLHttpRequestMockImpl)

	typedef IXMLHttpRequest Interface;
	struct openValidValues
	{
		/*[in]*/ BSTR bstrMethod;
		/*[in]*/ BSTR bstrUrl;
		/*[in,optional]*/ VARIANT varAsync;
		/*[in,optional]*/ VARIANT bstrUser;
		/*[in,optional]*/ VARIANT bstrPassword;
		HRESULT retValue;
	};

	STDMETHOD(open)(
		/*[in]*/ BSTR bstrMethod,
		/*[in]*/ BSTR bstrUrl,
		/*[in,optional]*/ VARIANT varAsync,
		/*[in,optional]*/ VARIANT bstrUser,
		/*[in,optional]*/ VARIANT bstrPassword)
	{
		VSL_DEFINE_MOCK_METHOD(open)

		VSL_CHECK_VALIDVALUE_BSTR(bstrMethod);

		VSL_CHECK_VALIDVALUE_BSTR(bstrUrl);

		VSL_CHECK_VALIDVALUE(varAsync);

		VSL_CHECK_VALIDVALUE(bstrUser);

		VSL_CHECK_VALIDVALUE(bstrPassword);

		VSL_RETURN_VALIDVALUES();
	}
	struct setRequestHeaderValidValues
	{
		/*[in]*/ BSTR bstrHeader;
		/*[in]*/ BSTR bstrValue;
		HRESULT retValue;
	};

	STDMETHOD(setRequestHeader)(
		/*[in]*/ BSTR bstrHeader,
		/*[in]*/ BSTR bstrValue)
	{
		VSL_DEFINE_MOCK_METHOD(setRequestHeader)

		VSL_CHECK_VALIDVALUE_BSTR(bstrHeader);

		VSL_CHECK_VALIDVALUE_BSTR(bstrValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct getResponseHeaderValidValues
	{
		/*[in]*/ BSTR bstrHeader;
		/*[out,retval]*/ BSTR* pbstrValue;
		HRESULT retValue;
	};

	STDMETHOD(getResponseHeader)(
		/*[in]*/ BSTR bstrHeader,
		/*[out,retval]*/ BSTR* pbstrValue)
	{
		VSL_DEFINE_MOCK_METHOD(getResponseHeader)

		VSL_CHECK_VALIDVALUE_BSTR(bstrHeader);

		VSL_SET_VALIDVALUE_BSTR(pbstrValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct getAllResponseHeadersValidValues
	{
		/*[out,retval]*/ BSTR* pbstrHeaders;
		HRESULT retValue;
	};

	STDMETHOD(getAllResponseHeaders)(
		/*[out,retval]*/ BSTR* pbstrHeaders)
	{
		VSL_DEFINE_MOCK_METHOD(getAllResponseHeaders)

		VSL_SET_VALIDVALUE_BSTR(pbstrHeaders);

		VSL_RETURN_VALIDVALUES();
	}
	struct sendValidValues
	{
		/*[in,optional]*/ VARIANT varBody;
		HRESULT retValue;
	};

	STDMETHOD(send)(
		/*[in,optional]*/ VARIANT varBody)
	{
		VSL_DEFINE_MOCK_METHOD(send)

		VSL_CHECK_VALIDVALUE(varBody);

		VSL_RETURN_VALIDVALUES();
	}
	struct abortValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(abort)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(abort)

		VSL_RETURN_VALIDVALUES();
	}
	struct get_statusValidValues
	{
		/*[out,retval]*/ long* plStatus;
		HRESULT retValue;
	};

	STDMETHOD(get_status)(
		/*[out,retval]*/ long* plStatus)
	{
		VSL_DEFINE_MOCK_METHOD(get_status)

		VSL_SET_VALIDVALUE(plStatus);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_statusTextValidValues
	{
		/*[out,retval]*/ BSTR* pbstrStatus;
		HRESULT retValue;
	};

	STDMETHOD(get_statusText)(
		/*[out,retval]*/ BSTR* pbstrStatus)
	{
		VSL_DEFINE_MOCK_METHOD(get_statusText)

		VSL_SET_VALIDVALUE_BSTR(pbstrStatus);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_responseXMLValidValues
	{
		/*[out,retval]*/ IDispatch** ppBody;
		HRESULT retValue;
	};

	STDMETHOD(get_responseXML)(
		/*[out,retval]*/ IDispatch** ppBody)
	{
		VSL_DEFINE_MOCK_METHOD(get_responseXML)

		VSL_SET_VALIDVALUE_INTERFACE(ppBody);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_responseTextValidValues
	{
		/*[out,retval]*/ BSTR* pbstrBody;
		HRESULT retValue;
	};

	STDMETHOD(get_responseText)(
		/*[out,retval]*/ BSTR* pbstrBody)
	{
		VSL_DEFINE_MOCK_METHOD(get_responseText)

		VSL_SET_VALIDVALUE_BSTR(pbstrBody);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_responseBodyValidValues
	{
		/*[out,retval]*/ VARIANT* pvarBody;
		HRESULT retValue;
	};

	STDMETHOD(get_responseBody)(
		/*[out,retval]*/ VARIANT* pvarBody)
	{
		VSL_DEFINE_MOCK_METHOD(get_responseBody)

		VSL_SET_VALIDVALUE_VARIANT(pvarBody);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_responseStreamValidValues
	{
		/*[out,retval]*/ VARIANT* pvarBody;
		HRESULT retValue;
	};

	STDMETHOD(get_responseStream)(
		/*[out,retval]*/ VARIANT* pvarBody)
	{
		VSL_DEFINE_MOCK_METHOD(get_responseStream)

		VSL_SET_VALIDVALUE_VARIANT(pvarBody);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_readyStateValidValues
	{
		/*[out,retval]*/ long* plState;
		HRESULT retValue;
	};

	STDMETHOD(get_readyState)(
		/*[out,retval]*/ long* plState)
	{
		VSL_DEFINE_MOCK_METHOD(get_readyState)

		VSL_SET_VALIDVALUE(plState);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_onreadystatechangeValidValues
	{
		/*[in]*/ IDispatch* pReadyStateSink;
		HRESULT retValue;
	};

	STDMETHOD(put_onreadystatechange)(
		/*[in]*/ IDispatch* pReadyStateSink)
	{
		VSL_DEFINE_MOCK_METHOD(put_onreadystatechange)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pReadyStateSink);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IXMLHTTPREQUEST_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockJSharpProjectConfigurationProperties3.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef JSHARPPROJECTCONFIGURATIONPROPERTIES3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define JSHARPPROJECTCONFIGURATIONPROPERTIES3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vslangproj80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class JSharpProjectConfigurationProperties3NotImpl :
	public JSharpProjectConfigurationProperties3
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(JSharpProjectConfigurationProperties3NotImpl)

public:

	typedef JSharpProjectConfigurationProperties3 Interface;

	STDMETHOD(get_CodePage)(
		/*[out,retval]*/ BSTR* /*pbstrCodePage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_CodePage)(
		/*[in]*/ BSTR /*CodePage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_JCPA)(
		/*[out,retval]*/ BSTR* /*pbstrJCPA*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_JCPA)(
		/*[in]*/ BSTR /*JCPA*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DisableLangXtns)(
		/*[out,retval]*/ prjDisableLangXtns* /*pDisableLangXtns*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DisableLangXtns)(
		/*[in]*/ prjDisableLangXtns /*DisableLangXtns*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_SecureScoping)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbSecureScoping*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_SecureScoping)(
		/*[in]*/ VARIANT_BOOL /*bSecureScoping*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DebugInfo)(
		/*[out,retval]*/ BSTR* /*pbstrDebugInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DebugInfo)(
		/*[in]*/ BSTR /*DebugInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_PlatformTarget)(
		/*[out,retval]*/ BSTR* /*pbstrPlatformTarget*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_PlatformTarget)(
		/*[in]*/ BSTR /*PlatformTarget*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_TreatSpecificWarningsAsErrors)(
		/*[out,retval]*/ BSTR* /*pbstrWarningsAsErrors*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_TreatSpecificWarningsAsErrors)(
		/*[in]*/ BSTR /*WarningsAsErrors*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_RunCodeAnalysis)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbRunCodeAnalysis*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_RunCodeAnalysis)(
		/*[in]*/ VARIANT_BOOL /*RunCodeAnalysis*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CodeAnalysisLogFile)(
		/*[out,retval]*/ BSTR* /*pbstrCodeAnalysisLogFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_CodeAnalysisLogFile)(
		/*[in]*/ BSTR /*CodeAnalysisLogFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CodeAnalysisRuleAssemblies)(
		/*[out,retval]*/ BSTR* /*pbstrCodeAnalysisRuleAssemblies*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_CodeAnalysisRuleAssemblies)(
		/*[in]*/ BSTR /*CodeAnalysisRuleAssemblies*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CodeAnalysisInputAssembly)(
		/*[out,retval]*/ BSTR* /*pbstrCodeAnalysisInputAssembly*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_CodeAnalysisInputAssembly)(
		/*[in]*/ BSTR /*CodeAnalysisInputAssembly*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CodeAnalysisRules)(
		/*[out,retval]*/ BSTR* /*pbstrCodeAnalysisRules*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_CodeAnalysisRules)(
		/*[in]*/ BSTR /*CodeAnalysisRules*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CodeAnalysisSpellCheckLanguages)(
		/*[out,retval]*/ BSTR* /*pbstrCodeAnalysisSpellCheckLanguages*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_CodeAnalysisSpellCheckLanguages)(
		/*[in]*/ BSTR /*CodeAnalysisSpellCheckLanguages*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CodeAnalysisUseTypeNameInSuppression)(
		/*[out,retval]*/ VARIANT_BOOL* /*bUseTypeNameInSuppression*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_CodeAnalysisUseTypeNameInSuppression)(
		/*[in]*/ VARIANT_BOOL /*UseTypeNameInSuppression*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CodeAnalysisModuleSuppressionsFile)(
		/*[out,retval]*/ BSTR* /*pbstrCodeAnalysisModuleSuppressionsFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_CodeAnalysisModuleSuppressionsFile)(
		/*[in]*/ BSTR /*CodeAnalysisModuleSuppressionsFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_UseVSHostingProcess)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbUseVSHostingProcess*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_UseVSHostingProcess)(
		/*[in]*/ VARIANT_BOOL /*UseVSHostingProcess*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_GenerateSerializationAssemblies)(
		/*[out,retval]*/ sgenGenerationOption* /*pSgenGenerationOption*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_GenerateSerializationAssemblies)(
		/*[in]*/ sgenGenerationOption /*SgenGenerationOption*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_NoWarn)(
		/*[out,retval]*/ BSTR* /*pbstrWarnings*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_NoWarn)(
		/*[in]*/ BSTR /*bstrWarnings*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_NoStdLib)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbNoStdLib*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_NoStdLib)(
		/*[in]*/ VARIANT_BOOL /*bNoStdLib*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get___id)(
		/*[out,retval]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DebugSymbols)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbGenerate*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DebugSymbols)(
		/*[in]*/ VARIANT_BOOL /*bGenerate*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DefineDebug)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbDefineDebug*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DefineDebug)(
		/*[in]*/ VARIANT_BOOL /*bDefineDebug*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DefineTrace)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbDefineTrace*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DefineTrace)(
		/*[in]*/ VARIANT_BOOL /*bDefineTrace*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_OutputPath)(
		/*[out,retval]*/ BSTR* /*pbstrOutputPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_OutputPath)(
		/*[in]*/ BSTR /*bstrOutputPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_IntermediatePath)(
		/*[out,retval]*/ BSTR* /*pbstrIntermediatePath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_IntermediatePath)(
		/*[in]*/ BSTR /*bstrIntermediatePath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DefineConstants)(
		/*[out,retval]*/ BSTR* /*pbstrDefineConstants*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DefineConstants)(
		/*[in]*/ BSTR /*bstrDefineConstants*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_RemoveIntegerChecks)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbRemoveIntegerChecks*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_RemoveIntegerChecks)(
		/*[in]*/ VARIANT_BOOL /*bRemoveIntegerChecks*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_BaseAddress)(
		/*[out,retval]*/ DWORD* /*pdwBaseAddress*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_BaseAddress)(
		/*[in]*/ DWORD /*dwBaseAddress*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_AllowUnsafeBlocks)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbUnsafe*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_AllowUnsafeBlocks)(
		/*[in]*/ VARIANT_BOOL /*bUnsafe*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CheckForOverflowUnderflow)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbCheckForOverflowUnderflow*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_CheckForOverflowUnderflow)(
		/*[in]*/ VARIANT_BOOL /*bCheckForOverflowUnderflow*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DocumentationFile)(
		/*[out,retval]*/ BSTR* /*pbstrDocumentationFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DocumentationFile)(
		/*[in]*/ BSTR /*bstrDocumentationFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Optimize)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbOptimize*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_Optimize)(
		/*[in]*/ VARIANT_BOOL /*bCheckForOverflowUnderflow*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_IncrementalBuild)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbIncrementalBuild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_IncrementalBuild)(
		/*[in]*/ VARIANT_BOOL /*bIncrementalBuild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_StartProgram)(
		/*[out,retval]*/ BSTR* /*pbstrStartProgram*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_StartProgram)(
		/*[in]*/ BSTR /*bstrStartProgram*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_StartWorkingDirectory)(
		/*[out,retval]*/ BSTR* /*pbstrStartWorkingDirectory*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_StartWorkingDirectory)(
		/*[in]*/ BSTR /*bstrStartWorkingDirectory*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_StartURL)(
		/*[out,retval]*/ BSTR* /*pbstrStartURL*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_StartURL)(
		/*[in]*/ BSTR /*bstrStartURL*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_StartPage)(
		/*[out,retval]*/ BSTR* /*pbstrStartPage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_StartPage)(
		/*[in]*/ BSTR /*bstrStartPage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_StartArguments)(
		/*[out,retval]*/ BSTR* /*pbstrStartArguments*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_StartArguments)(
		/*[in]*/ BSTR /*bstrStartArguments*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_StartWithIE)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbStartWithIE*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_StartWithIE)(
		/*[in]*/ VARIANT_BOOL /*bStartWithIE*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_EnableASPDebugging)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbEnableASPDebugging*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_EnableASPDebugging)(
		/*[in]*/ VARIANT_BOOL /*bEnableASPDebugging*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_EnableASPXDebugging)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbEnableASPXDebugging*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_EnableASPXDebugging)(
		/*[in]*/ VARIANT_BOOL /*bEnableASPXDebugging*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_EnableUnmanagedDebugging)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbEnableUnmanagedDebugging*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_EnableUnmanagedDebugging)(
		/*[in]*/ VARIANT_BOOL /*bEnableUnmanagedDebugging*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_StartAction)(
		/*[out,retval]*/ prjStartAction* /*pdebugStartMode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_StartAction)(
		/*[in]*/ prjStartAction /*debugStartMode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Extender)(
		/*[in]*/ BSTR /*ExtenderName*/,
		/*[out,retval]*/ IDispatch** /*Extender*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ExtenderNames)(
		/*[out,retval]*/ VARIANT* /*ExtenderNames*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ExtenderCATID)(
		/*[out,retval]*/ BSTR* /*pRetval*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_WarningLevel)(
		/*[out,retval]*/ prjWarningLevel* /*pWarningLeve*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_WarningLevel)(
		/*[in]*/ prjWarningLevel /*warningLevel*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_TreatWarningsAsErrors)(
		/*[out,retval]*/ VARIANT_BOOL* /*pWarningAsError*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_TreatWarningsAsErrors)(
		/*[in]*/ VARIANT_BOOL /*warningAsError*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_EnableSQLServerDebugging)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbEnableSQLServerDebugging*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_EnableSQLServerDebugging)(
		/*[in]*/ VARIANT_BOOL /*bEnableSQLServerDebugging*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_FileAlignment)(
		/*[out,retval]*/ DWORD* /*pdwFileAlignment*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_FileAlignment)(
		/*[in]*/ DWORD /*dwFileAlignment*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_RegisterForComInterop)(
		/*[out,retval]*/ VARIANT_BOOL* /*pVal*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_RegisterForComInterop)(
		/*[in]*/ VARIANT_BOOL /*val*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ConfigurationOverrideFile)(
		/*[out,retval]*/ BSTR* /*pbstrConfigFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_ConfigurationOverrideFile)(
		/*[in]*/ BSTR /*bstrConfigFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_RemoteDebugEnabled)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbEnableRemoteLaunch*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_RemoteDebugEnabled)(
		/*[in]*/ VARIANT_BOOL /*bEnableRemoteLaunch*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_RemoteDebugMachine)(
		/*[out,retval]*/ BSTR* /*pbstrRemoteLaunchMach*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_RemoteDebugMachine)(
		/*[in]*/ BSTR /*bstrRemoteLaunchMach*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class JSharpProjectConfigurationProperties3MockImpl :
	public JSharpProjectConfigurationProperties3,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(JSharpProjectConfigurationProperties3MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(JSharpProjectConfigurationProperties3MockImpl)

	typedef JSharpProjectConfigurationProperties3 Interface;
	struct get_CodePageValidValues
	{
		/*[out,retval]*/ BSTR* pbstrCodePage;
		HRESULT retValue;
	};

	STDMETHOD(get_CodePage)(
		/*[out,retval]*/ BSTR* pbstrCodePage)
	{
		VSL_DEFINE_MOCK_METHOD(get_CodePage)

		VSL_SET_VALIDVALUE_BSTR(pbstrCodePage);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_CodePageValidValues
	{
		/*[in]*/ BSTR CodePage;
		HRESULT retValue;
	};

	STDMETHOD(put_CodePage)(
		/*[in]*/ BSTR CodePage)
	{
		VSL_DEFINE_MOCK_METHOD(put_CodePage)

		VSL_CHECK_VALIDVALUE_BSTR(CodePage);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_JCPAValidValues
	{
		/*[out,retval]*/ BSTR* pbstrJCPA;
		HRESULT retValue;
	};

	STDMETHOD(get_JCPA)(
		/*[out,retval]*/ BSTR* pbstrJCPA)
	{
		VSL_DEFINE_MOCK_METHOD(get_JCPA)

		VSL_SET_VALIDVALUE_BSTR(pbstrJCPA);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_JCPAValidValues
	{
		/*[in]*/ BSTR JCPA;
		HRESULT retValue;
	};

	STDMETHOD(put_JCPA)(
		/*[in]*/ BSTR JCPA)
	{
		VSL_DEFINE_MOCK_METHOD(put_JCPA)

		VSL_CHECK_VALIDVALUE_BSTR(JCPA);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DisableLangXtnsValidValues
	{
		/*[out,retval]*/ prjDisableLangXtns* pDisableLangXtns;
		HRESULT retValue;
	};

	STDMETHOD(get_DisableLangXtns)(
		/*[out,retval]*/ prjDisableLangXtns* pDisableLangXtns)
	{
		VSL_DEFINE_MOCK_METHOD(get_DisableLangXtns)

		VSL_SET_VALIDVALUE(pDisableLangXtns);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DisableLangXtnsValidValues
	{
		/*[in]*/ prjDisableLangXtns DisableLangXtns;
		HRESULT retValue;
	};

	STDMETHOD(put_DisableLangXtns)(
		/*[in]*/ prjDisableLangXtns DisableLangXtns)
	{
		VSL_DEFINE_MOCK_METHOD(put_DisableLangXtns)

		VSL_CHECK_VALIDVALUE(DisableLangXtns);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_SecureScopingValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbSecureScoping;
		HRESULT retValue;
	};

	STDMETHOD(get_SecureScoping)(
		/*[out,retval]*/ VARIANT_BOOL* pbSecureScoping)
	{
		VSL_DEFINE_MOCK_METHOD(get_SecureScoping)

		VSL_SET_VALIDVALUE(pbSecureScoping);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_SecureScopingValidValues
	{
		/*[in]*/ VARIANT_BOOL bSecureScoping;
		HRESULT retValue;
	};

	STDMETHOD(put_SecureScoping)(
		/*[in]*/ VARIANT_BOOL bSecureScoping)
	{
		VSL_DEFINE_MOCK_METHOD(put_SecureScoping)

		VSL_CHECK_VALIDVALUE(bSecureScoping);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DebugInfoValidValues
	{
		/*[out,retval]*/ BSTR* pbstrDebugInfo;
		HRESULT retValue;
	};

	STDMETHOD(get_DebugInfo)(
		/*[out,retval]*/ BSTR* pbstrDebugInfo)
	{
		VSL_DEFINE_MOCK_METHOD(get_DebugInfo)

		VSL_SET_VALIDVALUE_BSTR(pbstrDebugInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DebugInfoValidValues
	{
		/*[in]*/ BSTR DebugInfo;
		HRESULT retValue;
	};

	STDMETHOD(put_DebugInfo)(
		/*[in]*/ BSTR DebugInfo)
	{
		VSL_DEFINE_MOCK_METHOD(put_DebugInfo)

		VSL_CHECK_VALIDVALUE_BSTR(DebugInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_PlatformTargetValidValues
	{
		/*[out,retval]*/ BSTR* pbstrPlatformTarget;
		HRESULT retValue;
	};

	STDMETHOD(get_PlatformTarget)(
		/*[out,retval]*/ BSTR* pbstrPlatformTarget)
	{
		VSL_DEFINE_MOCK_METHOD(get_PlatformTarget)

		VSL_SET_VALIDVALUE_BSTR(pbstrPlatformTarget);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_PlatformTargetValidValues
	{
		/*[in]*/ BSTR PlatformTarget;
		HRESULT retValue;
	};

	STDMETHOD(put_PlatformTarget)(
		/*[in]*/ BSTR PlatformTarget)
	{
		VSL_DEFINE_MOCK_METHOD(put_PlatformTarget)

		VSL_CHECK_VALIDVALUE_BSTR(PlatformTarget);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_TreatSpecificWarningsAsErrorsValidValues
	{
		/*[out,retval]*/ BSTR* pbstrWarningsAsErrors;
		HRESULT retValue;
	};

	STDMETHOD(get_TreatSpecificWarningsAsErrors)(
		/*[out,retval]*/ BSTR* pbstrWarningsAsErrors)
	{
		VSL_DEFINE_MOCK_METHOD(get_TreatSpecificWarningsAsErrors)

		VSL_SET_VALIDVALUE_BSTR(pbstrWarningsAsErrors);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_TreatSpecificWarningsAsErrorsValidValues
	{
		/*[in]*/ BSTR WarningsAsErrors;
		HRESULT retValue;
	};

	STDMETHOD(put_TreatSpecificWarningsAsErrors)(
		/*[in]*/ BSTR WarningsAsErrors)
	{
		VSL_DEFINE_MOCK_METHOD(put_TreatSpecificWarningsAsErrors)

		VSL_CHECK_VALIDVALUE_BSTR(WarningsAsErrors);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_RunCodeAnalysisValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbRunCodeAnalysis;
		HRESULT retValue;
	};

	STDMETHOD(get_RunCodeAnalysis)(
		/*[out,retval]*/ VARIANT_BOOL* pbRunCodeAnalysis)
	{
		VSL_DEFINE_MOCK_METHOD(get_RunCodeAnalysis)

		VSL_SET_VALIDVALUE(pbRunCodeAnalysis);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_RunCodeAnalysisValidValues
	{
		/*[in]*/ VARIANT_BOOL RunCodeAnalysis;
		HRESULT retValue;
	};

	STDMETHOD(put_RunCodeAnalysis)(
		/*[in]*/ VARIANT_BOOL RunCodeAnalysis)
	{
		VSL_DEFINE_MOCK_METHOD(put_RunCodeAnalysis)

		VSL_CHECK_VALIDVALUE(RunCodeAnalysis);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CodeAnalysisLogFileValidValues
	{
		/*[out,retval]*/ BSTR* pbstrCodeAnalysisLogFile;
		HRESULT retValue;
	};

	STDMETHOD(get_CodeAnalysisLogFile)(
		/*[out,retval]*/ BSTR* pbstrCodeAnalysisLogFile)
	{
		VSL_DEFINE_MOCK_METHOD(get_CodeAnalysisLogFile)

		VSL_SET_VALIDVALUE_BSTR(pbstrCodeAnalysisLogFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_CodeAnalysisLogFileValidValues
	{
		/*[in]*/ BSTR CodeAnalysisLogFile;
		HRESULT retValue;
	};

	STDMETHOD(put_CodeAnalysisLogFile)(
		/*[in]*/ BSTR CodeAnalysisLogFile)
	{
		VSL_DEFINE_MOCK_METHOD(put_CodeAnalysisLogFile)

		VSL_CHECK_VALIDVALUE_BSTR(CodeAnalysisLogFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CodeAnalysisRuleAssembliesValidValues
	{
		/*[out,retval]*/ BSTR* pbstrCodeAnalysisRuleAssemblies;
		HRESULT retValue;
	};

	STDMETHOD(get_CodeAnalysisRuleAssemblies)(
		/*[out,retval]*/ BSTR* pbstrCodeAnalysisRuleAssemblies)
	{
		VSL_DEFINE_MOCK_METHOD(get_CodeAnalysisRuleAssemblies)

		VSL_SET_VALIDVALUE_BSTR(pbstrCodeAnalysisRuleAssemblies);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_CodeAnalysisRuleAssembliesValidValues
	{
		/*[in]*/ BSTR CodeAnalysisRuleAssemblies;
		HRESULT retValue;
	};

	STDMETHOD(put_CodeAnalysisRuleAssemblies)(
		/*[in]*/ BSTR CodeAnalysisRuleAssemblies)
	{
		VSL_DEFINE_MOCK_METHOD(put_CodeAnalysisRuleAssemblies)

		VSL_CHECK_VALIDVALUE_BSTR(CodeAnalysisRuleAssemblies);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CodeAnalysisInputAssemblyValidValues
	{
		/*[out,retval]*/ BSTR* pbstrCodeAnalysisInputAssembly;
		HRESULT retValue;
	};

	STDMETHOD(get_CodeAnalysisInputAssembly)(
		/*[out,retval]*/ BSTR* pbstrCodeAnalysisInputAssembly)
	{
		VSL_DEFINE_MOCK_METHOD(get_CodeAnalysisInputAssembly)

		VSL_SET_VALIDVALUE_BSTR(pbstrCodeAnalysisInputAssembly);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_CodeAnalysisInputAssemblyValidValues
	{
		/*[in]*/ BSTR CodeAnalysisInputAssembly;
		HRESULT retValue;
	};

	STDMETHOD(put_CodeAnalysisInputAssembly)(
		/*[in]*/ BSTR CodeAnalysisInputAssembly)
	{
		VSL_DEFINE_MOCK_METHOD(put_CodeAnalysisInputAssembly)

		VSL_CHECK_VALIDVALUE_BSTR(CodeAnalysisInputAssembly);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CodeAnalysisRulesValidValues
	{
		/*[out,retval]*/ BSTR* pbstrCodeAnalysisRules;
		HRESULT retValue;
	};

	STDMETHOD(get_CodeAnalysisRules)(
		/*[out,retval]*/ BSTR* pbstrCodeAnalysisRules)
	{
		VSL_DEFINE_MOCK_METHOD(get_CodeAnalysisRules)

		VSL_SET_VALIDVALUE_BSTR(pbstrCodeAnalysisRules);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_CodeAnalysisRulesValidValues
	{
		/*[in]*/ BSTR CodeAnalysisRules;
		HRESULT retValue;
	};

	STDMETHOD(put_CodeAnalysisRules)(
		/*[in]*/ BSTR CodeAnalysisRules)
	{
		VSL_DEFINE_MOCK_METHOD(put_CodeAnalysisRules)

		VSL_CHECK_VALIDVALUE_BSTR(CodeAnalysisRules);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CodeAnalysisSpellCheckLanguagesValidValues
	{
		/*[out,retval]*/ BSTR* pbstrCodeAnalysisSpellCheckLanguages;
		HRESULT retValue;
	};

	STDMETHOD(get_CodeAnalysisSpellCheckLanguages)(
		/*[out,retval]*/ BSTR* pbstrCodeAnalysisSpellCheckLanguages)
	{
		VSL_DEFINE_MOCK_METHOD(get_CodeAnalysisSpellCheckLanguages)

		VSL_SET_VALIDVALUE_BSTR(pbstrCodeAnalysisSpellCheckLanguages);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_CodeAnalysisSpellCheckLanguagesValidValues
	{
		/*[in]*/ BSTR CodeAnalysisSpellCheckLanguages;
		HRESULT retValue;
	};

	STDMETHOD(put_CodeAnalysisSpellCheckLanguages)(
		/*[in]*/ BSTR CodeAnalysisSpellCheckLanguages)
	{
		VSL_DEFINE_MOCK_METHOD(put_CodeAnalysisSpellCheckLanguages)

		VSL_CHECK_VALIDVALUE_BSTR(CodeAnalysisSpellCheckLanguages);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CodeAnalysisUseTypeNameInSuppressionValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* bUseTypeNameInSuppression;
		HRESULT retValue;
	};

	STDMETHOD(get_CodeAnalysisUseTypeNameInSuppression)(
		/*[out,retval]*/ VARIANT_BOOL* bUseTypeNameInSuppression)
	{
		VSL_DEFINE_MOCK_METHOD(get_CodeAnalysisUseTypeNameInSuppression)

		VSL_SET_VALIDVALUE(bUseTypeNameInSuppression);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_CodeAnalysisUseTypeNameInSuppressionValidValues
	{
		/*[in]*/ VARIANT_BOOL UseTypeNameInSuppression;
		HRESULT retValue;
	};

	STDMETHOD(put_CodeAnalysisUseTypeNameInSuppression)(
		/*[in]*/ VARIANT_BOOL UseTypeNameInSuppression)
	{
		VSL_DEFINE_MOCK_METHOD(put_CodeAnalysisUseTypeNameInSuppression)

		VSL_CHECK_VALIDVALUE(UseTypeNameInSuppression);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CodeAnalysisModuleSuppressionsFileValidValues
	{
		/*[out,retval]*/ BSTR* pbstrCodeAnalysisModuleSuppressionsFile;
		HRESULT retValue;
	};

	STDMETHOD(get_CodeAnalysisModuleSuppressionsFile)(
		/*[out,retval]*/ BSTR* pbstrCodeAnalysisModuleSuppressionsFile)
	{
		VSL_DEFINE_MOCK_METHOD(get_CodeAnalysisModuleSuppressionsFile)

		VSL_SET_VALIDVALUE_BSTR(pbstrCodeAnalysisModuleSuppressionsFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_CodeAnalysisModuleSuppressionsFileValidValues
	{
		/*[in]*/ BSTR CodeAnalysisModuleSuppressionsFile;
		HRESULT retValue;
	};

	STDMETHOD(put_CodeAnalysisModuleSuppressionsFile)(
		/*[in]*/ BSTR CodeAnalysisModuleSuppressionsFile)
	{
		VSL_DEFINE_MOCK_METHOD(put_CodeAnalysisModuleSuppressionsFile)

		VSL_CHECK_VALIDVALUE_BSTR(CodeAnalysisModuleSuppressionsFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_UseVSHostingProcessValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbUseVSHostingProcess;
		HRESULT retValue;
	};

	STDMETHOD(get_UseVSHostingProcess)(
		/*[out,retval]*/ VARIANT_BOOL* pbUseVSHostingProcess)
	{
		VSL_DEFINE_MOCK_METHOD(get_UseVSHostingProcess)

		VSL_SET_VALIDVALUE(pbUseVSHostingProcess);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_UseVSHostingProcessValidValues
	{
		/*[in]*/ VARIANT_BOOL UseVSHostingProcess;
		HRESULT retValue;
	};

	STDMETHOD(put_UseVSHostingProcess)(
		/*[in]*/ VARIANT_BOOL UseVSHostingProcess)
	{
		VSL_DEFINE_MOCK_METHOD(put_UseVSHostingProcess)

		VSL_CHECK_VALIDVALUE(UseVSHostingProcess);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_GenerateSerializationAssembliesValidValues
	{
		/*[out,retval]*/ sgenGenerationOption* pSgenGenerationOption;
		HRESULT retValue;
	};

	STDMETHOD(get_GenerateSerializationAssemblies)(
		/*[out,retval]*/ sgenGenerationOption* pSgenGenerationOption)
	{
		VSL_DEFINE_MOCK_METHOD(get_GenerateSerializationAssemblies)

		VSL_SET_VALIDVALUE(pSgenGenerationOption);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_GenerateSerializationAssembliesValidValues
	{
		/*[in]*/ sgenGenerationOption SgenGenerationOption;
		HRESULT retValue;
	};

	STDMETHOD(put_GenerateSerializationAssemblies)(
		/*[in]*/ sgenGenerationOption SgenGenerationOption)
	{
		VSL_DEFINE_MOCK_METHOD(put_GenerateSerializationAssemblies)

		VSL_CHECK_VALIDVALUE(SgenGenerationOption);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_NoWarnValidValues
	{
		/*[out,retval]*/ BSTR* pbstrWarnings;
		HRESULT retValue;
	};

	STDMETHOD(get_NoWarn)(
		/*[out,retval]*/ BSTR* pbstrWarnings)
	{
		VSL_DEFINE_MOCK_METHOD(get_NoWarn)

		VSL_SET_VALIDVALUE_BSTR(pbstrWarnings);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_NoWarnValidValues
	{
		/*[in]*/ BSTR bstrWarnings;
		HRESULT retValue;
	};

	STDMETHOD(put_NoWarn)(
		/*[in]*/ BSTR bstrWarnings)
	{
		VSL_DEFINE_MOCK_METHOD(put_NoWarn)

		VSL_CHECK_VALIDVALUE_BSTR(bstrWarnings);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_NoStdLibValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbNoStdLib;
		HRESULT retValue;
	};

	STDMETHOD(get_NoStdLib)(
		/*[out,retval]*/ VARIANT_BOOL* pbNoStdLib)
	{
		VSL_DEFINE_MOCK_METHOD(get_NoStdLib)

		VSL_SET_VALIDVALUE(pbNoStdLib);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_NoStdLibValidValues
	{
		/*[in]*/ VARIANT_BOOL bNoStdLib;
		HRESULT retValue;
	};

	STDMETHOD(put_NoStdLib)(
		/*[in]*/ VARIANT_BOOL bNoStdLib)
	{
		VSL_DEFINE_MOCK_METHOD(put_NoStdLib)

		VSL_CHECK_VALIDVALUE(bNoStdLib);

		VSL_RETURN_VALIDVALUES();
	}
	struct get___idValidValues
	{
		/*[out,retval]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(get___id)(
		/*[out,retval]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(get___id)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DebugSymbolsValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbGenerate;
		HRESULT retValue;
	};

	STDMETHOD(get_DebugSymbols)(
		/*[out,retval]*/ VARIANT_BOOL* pbGenerate)
	{
		VSL_DEFINE_MOCK_METHOD(get_DebugSymbols)

		VSL_SET_VALIDVALUE(pbGenerate);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DebugSymbolsValidValues
	{
		/*[in]*/ VARIANT_BOOL bGenerate;
		HRESULT retValue;
	};

	STDMETHOD(put_DebugSymbols)(
		/*[in]*/ VARIANT_BOOL bGenerate)
	{
		VSL_DEFINE_MOCK_METHOD(put_DebugSymbols)

		VSL_CHECK_VALIDVALUE(bGenerate);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DefineDebugValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbDefineDebug;
		HRESULT retValue;
	};

	STDMETHOD(get_DefineDebug)(
		/*[out,retval]*/ VARIANT_BOOL* pbDefineDebug)
	{
		VSL_DEFINE_MOCK_METHOD(get_DefineDebug)

		VSL_SET_VALIDVALUE(pbDefineDebug);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DefineDebugValidValues
	{
		/*[in]*/ VARIANT_BOOL bDefineDebug;
		HRESULT retValue;
	};

	STDMETHOD(put_DefineDebug)(
		/*[in]*/ VARIANT_BOOL bDefineDebug)
	{
		VSL_DEFINE_MOCK_METHOD(put_DefineDebug)

		VSL_CHECK_VALIDVALUE(bDefineDebug);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DefineTraceValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbDefineTrace;
		HRESULT retValue;
	};

	STDMETHOD(get_DefineTrace)(
		/*[out,retval]*/ VARIANT_BOOL* pbDefineTrace)
	{
		VSL_DEFINE_MOCK_METHOD(get_DefineTrace)

		VSL_SET_VALIDVALUE(pbDefineTrace);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DefineTraceValidValues
	{
		/*[in]*/ VARIANT_BOOL bDefineTrace;
		HRESULT retValue;
	};

	STDMETHOD(put_DefineTrace)(
		/*[in]*/ VARIANT_BOOL bDefineTrace)
	{
		VSL_DEFINE_MOCK_METHOD(put_DefineTrace)

		VSL_CHECK_VALIDVALUE(bDefineTrace);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_OutputPathValidValues
	{
		/*[out,retval]*/ BSTR* pbstrOutputPath;
		HRESULT retValue;
	};

	STDMETHOD(get_OutputPath)(
		/*[out,retval]*/ BSTR* pbstrOutputPath)
	{
		VSL_DEFINE_MOCK_METHOD(get_OutputPath)

		VSL_SET_VALIDVALUE_BSTR(pbstrOutputPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_OutputPathValidValues
	{
		/*[in]*/ BSTR bstrOutputPath;
		HRESULT retValue;
	};

	STDMETHOD(put_OutputPath)(
		/*[in]*/ BSTR bstrOutputPath)
	{
		VSL_DEFINE_MOCK_METHOD(put_OutputPath)

		VSL_CHECK_VALIDVALUE_BSTR(bstrOutputPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IntermediatePathValidValues
	{
		/*[out,retval]*/ BSTR* pbstrIntermediatePath;
		HRESULT retValue;
	};

	STDMETHOD(get_IntermediatePath)(
		/*[out,retval]*/ BSTR* pbstrIntermediatePath)
	{
		VSL_DEFINE_MOCK_METHOD(get_IntermediatePath)

		VSL_SET_VALIDVALUE_BSTR(pbstrIntermediatePath);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_IntermediatePathValidValues
	{
		/*[in]*/ BSTR bstrIntermediatePath;
		HRESULT retValue;
	};

	STDMETHOD(put_IntermediatePath)(
		/*[in]*/ BSTR bstrIntermediatePath)
	{
		VSL_DEFINE_MOCK_METHOD(put_IntermediatePath)

		VSL_CHECK_VALIDVALUE_BSTR(bstrIntermediatePath);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DefineConstantsValidValues
	{
		/*[out,retval]*/ BSTR* pbstrDefineConstants;
		HRESULT retValue;
	};

	STDMETHOD(get_DefineConstants)(
		/*[out,retval]*/ BSTR* pbstrDefineConstants)
	{
		VSL_DEFINE_MOCK_METHOD(get_DefineConstants)

		VSL_SET_VALIDVALUE_BSTR(pbstrDefineConstants);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DefineConstantsValidValues
	{
		/*[in]*/ BSTR bstrDefineConstants;
		HRESULT retValue;
	};

	STDMETHOD(put_DefineConstants)(
		/*[in]*/ BSTR bstrDefineConstants)
	{
		VSL_DEFINE_MOCK_METHOD(put_DefineConstants)

		VSL_CHECK_VALIDVALUE_BSTR(bstrDefineConstants);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_RemoveIntegerChecksValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbRemoveIntegerChecks;
		HRESULT retValue;
	};

	STDMETHOD(get_RemoveIntegerChecks)(
		/*[out,retval]*/ VARIANT_BOOL* pbRemoveIntegerChecks)
	{
		VSL_DEFINE_MOCK_METHOD(get_RemoveIntegerChecks)

		VSL_SET_VALIDVALUE(pbRemoveIntegerChecks);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_RemoveIntegerChecksValidValues
	{
		/*[in]*/ VARIANT_BOOL bRemoveIntegerChecks;
		HRESULT retValue;
	};

	STDMETHOD(put_RemoveIntegerChecks)(
		/*[in]*/ VARIANT_BOOL bRemoveIntegerChecks)
	{
		VSL_DEFINE_MOCK_METHOD(put_RemoveIntegerChecks)

		VSL_CHECK_VALIDVALUE(bRemoveIntegerChecks);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_BaseAddressValidValues
	{
		/*[out,retval]*/ DWORD* pdwBaseAddress;
		HRESULT retValue;
	};

	STDMETHOD(get_BaseAddress)(
		/*[out,retval]*/ DWORD* pdwBaseAddress)
	{
		VSL_DEFINE_MOCK_METHOD(get_BaseAddress)

		VSL_SET_VALIDVALUE(pdwBaseAddress);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_BaseAddressValidValues
	{
		/*[in]*/ DWORD dwBaseAddress;
		HRESULT retValue;
	};

	STDMETHOD(put_BaseAddress)(
		/*[in]*/ DWORD dwBaseAddress)
	{
		VSL_DEFINE_MOCK_METHOD(put_BaseAddress)

		VSL_CHECK_VALIDVALUE(dwBaseAddress);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_AllowUnsafeBlocksValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbUnsafe;
		HRESULT retValue;
	};

	STDMETHOD(get_AllowUnsafeBlocks)(
		/*[out,retval]*/ VARIANT_BOOL* pbUnsafe)
	{
		VSL_DEFINE_MOCK_METHOD(get_AllowUnsafeBlocks)

		VSL_SET_VALIDVALUE(pbUnsafe);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_AllowUnsafeBlocksValidValues
	{
		/*[in]*/ VARIANT_BOOL bUnsafe;
		HRESULT retValue;
	};

	STDMETHOD(put_AllowUnsafeBlocks)(
		/*[in]*/ VARIANT_BOOL bUnsafe)
	{
		VSL_DEFINE_MOCK_METHOD(put_AllowUnsafeBlocks)

		VSL_CHECK_VALIDVALUE(bUnsafe);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CheckForOverflowUnderflowValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbCheckForOverflowUnderflow;
		HRESULT retValue;
	};

	STDMETHOD(get_CheckForOverflowUnderflow)(
		/*[out,retval]*/ VARIANT_BOOL* pbCheckForOverflowUnderflow)
	{
		VSL_DEFINE_MOCK_METHOD(get_CheckForOverflowUnderflow)

		VSL_SET_VALIDVALUE(pbCheckForOverflowUnderflow);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_CheckForOverflowUnderflowValidValues
	{
		/*[in]*/ VARIANT_BOOL bCheckForOverflowUnderflow;
		HRESULT retValue;
	};

	STDMETHOD(put_CheckForOverflowUnderflow)(
		/*[in]*/ VARIANT_BOOL bCheckForOverflowUnderflow)
	{
		VSL_DEFINE_MOCK_METHOD(put_CheckForOverflowUnderflow)

		VSL_CHECK_VALIDVALUE(bCheckForOverflowUnderflow);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DocumentationFileValidValues
	{
		/*[out,retval]*/ BSTR* pbstrDocumentationFile;
		HRESULT retValue;
	};

	STDMETHOD(get_DocumentationFile)(
		/*[out,retval]*/ BSTR* pbstrDocumentationFile)
	{
		VSL_DEFINE_MOCK_METHOD(get_DocumentationFile)

		VSL_SET_VALIDVALUE_BSTR(pbstrDocumentationFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DocumentationFileValidValues
	{
		/*[in]*/ BSTR bstrDocumentationFile;
		HRESULT retValue;
	};

	STDMETHOD(put_DocumentationFile)(
		/*[in]*/ BSTR bstrDocumentationFile)
	{
		VSL_DEFINE_MOCK_METHOD(put_DocumentationFile)

		VSL_CHECK_VALIDVALUE_BSTR(bstrDocumentationFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_OptimizeValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbOptimize;
		HRESULT retValue;
	};

	STDMETHOD(get_Optimize)(
		/*[out,retval]*/ VARIANT_BOOL* pbOptimize)
	{
		VSL_DEFINE_MOCK_METHOD(get_Optimize)

		VSL_SET_VALIDVALUE(pbOptimize);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_OptimizeValidValues
	{
		/*[in]*/ VARIANT_BOOL bCheckForOverflowUnderflow;
		HRESULT retValue;
	};

	STDMETHOD(put_Optimize)(
		/*[in]*/ VARIANT_BOOL bCheckForOverflowUnderflow)
	{
		VSL_DEFINE_MOCK_METHOD(put_Optimize)

		VSL_CHECK_VALIDVALUE(bCheckForOverflowUnderflow);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IncrementalBuildValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbIncrementalBuild;
		HRESULT retValue;
	};

	STDMETHOD(get_IncrementalBuild)(
		/*[out,retval]*/ VARIANT_BOOL* pbIncrementalBuild)
	{
		VSL_DEFINE_MOCK_METHOD(get_IncrementalBuild)

		VSL_SET_VALIDVALUE(pbIncrementalBuild);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_IncrementalBuildValidValues
	{
		/*[in]*/ VARIANT_BOOL bIncrementalBuild;
		HRESULT retValue;
	};

	STDMETHOD(put_IncrementalBuild)(
		/*[in]*/ VARIANT_BOOL bIncrementalBuild)
	{
		VSL_DEFINE_MOCK_METHOD(put_IncrementalBuild)

		VSL_CHECK_VALIDVALUE(bIncrementalBuild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_StartProgramValidValues
	{
		/*[out,retval]*/ BSTR* pbstrStartProgram;
		HRESULT retValue;
	};

	STDMETHOD(get_StartProgram)(
		/*[out,retval]*/ BSTR* pbstrStartProgram)
	{
		VSL_DEFINE_MOCK_METHOD(get_StartProgram)

		VSL_SET_VALIDVALUE_BSTR(pbstrStartProgram);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_StartProgramValidValues
	{
		/*[in]*/ BSTR bstrStartProgram;
		HRESULT retValue;
	};

	STDMETHOD(put_StartProgram)(
		/*[in]*/ BSTR bstrStartProgram)
	{
		VSL_DEFINE_MOCK_METHOD(put_StartProgram)

		VSL_CHECK_VALIDVALUE_BSTR(bstrStartProgram);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_StartWorkingDirectoryValidValues
	{
		/*[out,retval]*/ BSTR* pbstrStartWorkingDirectory;
		HRESULT retValue;
	};

	STDMETHOD(get_StartWorkingDirectory)(
		/*[out,retval]*/ BSTR* pbstrStartWorkingDirectory)
	{
		VSL_DEFINE_MOCK_METHOD(get_StartWorkingDirectory)

		VSL_SET_VALIDVALUE_BSTR(pbstrStartWorkingDirectory);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_StartWorkingDirectoryValidValues
	{
		/*[in]*/ BSTR bstrStartWorkingDirectory;
		HRESULT retValue;
	};

	STDMETHOD(put_StartWorkingDirectory)(
		/*[in]*/ BSTR bstrStartWorkingDirectory)
	{
		VSL_DEFINE_MOCK_METHOD(put_StartWorkingDirectory)

		VSL_CHECK_VALIDVALUE_BSTR(bstrStartWorkingDirectory);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_StartURLValidValues
	{
		/*[out,retval]*/ BSTR* pbstrStartURL;
		HRESULT retValue;
	};

	STDMETHOD(get_StartURL)(
		/*[out,retval]*/ BSTR* pbstrStartURL)
	{
		VSL_DEFINE_MOCK_METHOD(get_StartURL)

		VSL_SET_VALIDVALUE_BSTR(pbstrStartURL);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_StartURLValidValues
	{
		/*[in]*/ BSTR bstrStartURL;
		HRESULT retValue;
	};

	STDMETHOD(put_StartURL)(
		/*[in]*/ BSTR bstrStartURL)
	{
		VSL_DEFINE_MOCK_METHOD(put_StartURL)

		VSL_CHECK_VALIDVALUE_BSTR(bstrStartURL);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_StartPageValidValues
	{
		/*[out,retval]*/ BSTR* pbstrStartPage;
		HRESULT retValue;
	};

	STDMETHOD(get_StartPage)(
		/*[out,retval]*/ BSTR* pbstrStartPage)
	{
		VSL_DEFINE_MOCK_METHOD(get_StartPage)

		VSL_SET_VALIDVALUE_BSTR(pbstrStartPage);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_StartPageValidValues
	{
		/*[in]*/ BSTR bstrStartPage;
		HRESULT retValue;
	};

	STDMETHOD(put_StartPage)(
		/*[in]*/ BSTR bstrStartPage)
	{
		VSL_DEFINE_MOCK_METHOD(put_StartPage)

		VSL_CHECK_VALIDVALUE_BSTR(bstrStartPage);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_StartArgumentsValidValues
	{
		/*[out,retval]*/ BSTR* pbstrStartArguments;
		HRESULT retValue;
	};

	STDMETHOD(get_StartArguments)(
		/*[out,retval]*/ BSTR* pbstrStartArguments)
	{
		VSL_DEFINE_MOCK_METHOD(get_StartArguments)

		VSL_SET_VALIDVALUE_BSTR(pbstrStartArguments);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_StartArgumentsValidValues
	{
		/*[in]*/ BSTR bstrStartArguments;
		HRESULT retValue;
	};

	STDMETHOD(put_StartArguments)(
		/*[in]*/ BSTR bstrStartArguments)
	{
		VSL_DEFINE_MOCK_METHOD(put_StartArguments)

		VSL_CHECK_VALIDVALUE_BSTR(bstrStartArguments);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_StartWithIEValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbStartWithIE;
		HRESULT retValue;
	};

	STDMETHOD(get_StartWithIE)(
		/*[out,retval]*/ VARIANT_BOOL* pbStartWithIE)
	{
		VSL_DEFINE_MOCK_METHOD(get_StartWithIE)

		VSL_SET_VALIDVALUE(pbStartWithIE);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_StartWithIEValidValues
	{
		/*[in]*/ VARIANT_BOOL bStartWithIE;
		HRESULT retValue;
	};

	STDMETHOD(put_StartWithIE)(
		/*[in]*/ VARIANT_BOOL bStartWithIE)
	{
		VSL_DEFINE_MOCK_METHOD(put_StartWithIE)

		VSL_CHECK_VALIDVALUE(bStartWithIE);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_EnableASPDebuggingValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbEnableASPDebugging;
		HRESULT retValue;
	};

	STDMETHOD(get_EnableASPDebugging)(
		/*[out,retval]*/ VARIANT_BOOL* pbEnableASPDebugging)
	{
		VSL_DEFINE_MOCK_METHOD(get_EnableASPDebugging)

		VSL_SET_VALIDVALUE(pbEnableASPDebugging);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_EnableASPDebuggingValidValues
	{
		/*[in]*/ VARIANT_BOOL bEnableASPDebugging;
		HRESULT retValue;
	};

	STDMETHOD(put_EnableASPDebugging)(
		/*[in]*/ VARIANT_BOOL bEnableASPDebugging)
	{
		VSL_DEFINE_MOCK_METHOD(put_EnableASPDebugging)

		VSL_CHECK_VALIDVALUE(bEnableASPDebugging);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_EnableASPXDebuggingValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbEnableASPXDebugging;
		HRESULT retValue;
	};

	STDMETHOD(get_EnableASPXDebugging)(
		/*[out,retval]*/ VARIANT_BOOL* pbEnableASPXDebugging)
	{
		VSL_DEFINE_MOCK_METHOD(get_EnableASPXDebugging)

		VSL_SET_VALIDVALUE(pbEnableASPXDebugging);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_EnableASPXDebuggingValidValues
	{
		/*[in]*/ VARIANT_BOOL bEnableASPXDebugging;
		HRESULT retValue;
	};

	STDMETHOD(put_EnableASPXDebugging)(
		/*[in]*/ VARIANT_BOOL bEnableASPXDebugging)
	{
		VSL_DEFINE_MOCK_METHOD(put_EnableASPXDebugging)

		VSL_CHECK_VALIDVALUE(bEnableASPXDebugging);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_EnableUnmanagedDebuggingValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbEnableUnmanagedDebugging;
		HRESULT retValue;
	};

	STDMETHOD(get_EnableUnmanagedDebugging)(
		/*[out,retval]*/ VARIANT_BOOL* pbEnableUnmanagedDebugging)
	{
		VSL_DEFINE_MOCK_METHOD(get_EnableUnmanagedDebugging)

		VSL_SET_VALIDVALUE(pbEnableUnmanagedDebugging);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_EnableUnmanagedDebuggingValidValues
	{
		/*[in]*/ VARIANT_BOOL bEnableUnmanagedDebugging;
		HRESULT retValue;
	};

	STDMETHOD(put_EnableUnmanagedDebugging)(
		/*[in]*/ VARIANT_BOOL bEnableUnmanagedDebugging)
	{
		VSL_DEFINE_MOCK_METHOD(put_EnableUnmanagedDebugging)

		VSL_CHECK_VALIDVALUE(bEnableUnmanagedDebugging);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_StartActionValidValues
	{
		/*[out,retval]*/ prjStartAction* pdebugStartMode;
		HRESULT retValue;
	};

	STDMETHOD(get_StartAction)(
		/*[out,retval]*/ prjStartAction* pdebugStartMode)
	{
		VSL_DEFINE_MOCK_METHOD(get_StartAction)

		VSL_SET_VALIDVALUE(pdebugStartMode);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_StartActionValidValues
	{
		/*[in]*/ prjStartAction debugStartMode;
		HRESULT retValue;
	};

	STDMETHOD(put_StartAction)(
		/*[in]*/ prjStartAction debugStartMode)
	{
		VSL_DEFINE_MOCK_METHOD(put_StartAction)

		VSL_CHECK_VALIDVALUE(debugStartMode);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderValidValues
	{
		/*[in]*/ BSTR ExtenderName;
		/*[out,retval]*/ IDispatch** Extender;
		HRESULT retValue;
	};

	STDMETHOD(get_Extender)(
		/*[in]*/ BSTR ExtenderName,
		/*[out,retval]*/ IDispatch** Extender)
	{
		VSL_DEFINE_MOCK_METHOD(get_Extender)

		VSL_CHECK_VALIDVALUE_BSTR(ExtenderName);

		VSL_SET_VALIDVALUE_INTERFACE(Extender);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderNamesValidValues
	{
		/*[out,retval]*/ VARIANT* ExtenderNames;
		HRESULT retValue;
	};

	STDMETHOD(get_ExtenderNames)(
		/*[out,retval]*/ VARIANT* ExtenderNames)
	{
		VSL_DEFINE_MOCK_METHOD(get_ExtenderNames)

		VSL_SET_VALIDVALUE_VARIANT(ExtenderNames);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderCATIDValidValues
	{
		/*[out,retval]*/ BSTR* pRetval;
		HRESULT retValue;
	};

	STDMETHOD(get_ExtenderCATID)(
		/*[out,retval]*/ BSTR* pRetval)
	{
		VSL_DEFINE_MOCK_METHOD(get_ExtenderCATID)

		VSL_SET_VALIDVALUE_BSTR(pRetval);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_WarningLevelValidValues
	{
		/*[out,retval]*/ prjWarningLevel* pWarningLeve;
		HRESULT retValue;
	};

	STDMETHOD(get_WarningLevel)(
		/*[out,retval]*/ prjWarningLevel* pWarningLeve)
	{
		VSL_DEFINE_MOCK_METHOD(get_WarningLevel)

		VSL_SET_VALIDVALUE(pWarningLeve);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_WarningLevelValidValues
	{
		/*[in]*/ prjWarningLevel warningLevel;
		HRESULT retValue;
	};

	STDMETHOD(put_WarningLevel)(
		/*[in]*/ prjWarningLevel warningLevel)
	{
		VSL_DEFINE_MOCK_METHOD(put_WarningLevel)

		VSL_CHECK_VALIDVALUE(warningLevel);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_TreatWarningsAsErrorsValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pWarningAsError;
		HRESULT retValue;
	};

	STDMETHOD(get_TreatWarningsAsErrors)(
		/*[out,retval]*/ VARIANT_BOOL* pWarningAsError)
	{
		VSL_DEFINE_MOCK_METHOD(get_TreatWarningsAsErrors)

		VSL_SET_VALIDVALUE(pWarningAsError);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_TreatWarningsAsErrorsValidValues
	{
		/*[in]*/ VARIANT_BOOL warningAsError;
		HRESULT retValue;
	};

	STDMETHOD(put_TreatWarningsAsErrors)(
		/*[in]*/ VARIANT_BOOL warningAsError)
	{
		VSL_DEFINE_MOCK_METHOD(put_TreatWarningsAsErrors)

		VSL_CHECK_VALIDVALUE(warningAsError);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_EnableSQLServerDebuggingValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbEnableSQLServerDebugging;
		HRESULT retValue;
	};

	STDMETHOD(get_EnableSQLServerDebugging)(
		/*[out,retval]*/ VARIANT_BOOL* pbEnableSQLServerDebugging)
	{
		VSL_DEFINE_MOCK_METHOD(get_EnableSQLServerDebugging)

		VSL_SET_VALIDVALUE(pbEnableSQLServerDebugging);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_EnableSQLServerDebuggingValidValues
	{
		/*[in]*/ VARIANT_BOOL bEnableSQLServerDebugging;
		HRESULT retValue;
	};

	STDMETHOD(put_EnableSQLServerDebugging)(
		/*[in]*/ VARIANT_BOOL bEnableSQLServerDebugging)
	{
		VSL_DEFINE_MOCK_METHOD(put_EnableSQLServerDebugging)

		VSL_CHECK_VALIDVALUE(bEnableSQLServerDebugging);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_FileAlignmentValidValues
	{
		/*[out,retval]*/ DWORD* pdwFileAlignment;
		HRESULT retValue;
	};

	STDMETHOD(get_FileAlignment)(
		/*[out,retval]*/ DWORD* pdwFileAlignment)
	{
		VSL_DEFINE_MOCK_METHOD(get_FileAlignment)

		VSL_SET_VALIDVALUE(pdwFileAlignment);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_FileAlignmentValidValues
	{
		/*[in]*/ DWORD dwFileAlignment;
		HRESULT retValue;
	};

	STDMETHOD(put_FileAlignment)(
		/*[in]*/ DWORD dwFileAlignment)
	{
		VSL_DEFINE_MOCK_METHOD(put_FileAlignment)

		VSL_CHECK_VALIDVALUE(dwFileAlignment);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_RegisterForComInteropValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pVal;
		HRESULT retValue;
	};

	STDMETHOD(get_RegisterForComInterop)(
		/*[out,retval]*/ VARIANT_BOOL* pVal)
	{
		VSL_DEFINE_MOCK_METHOD(get_RegisterForComInterop)

		VSL_SET_VALIDVALUE(pVal);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_RegisterForComInteropValidValues
	{
		/*[in]*/ VARIANT_BOOL val;
		HRESULT retValue;
	};

	STDMETHOD(put_RegisterForComInterop)(
		/*[in]*/ VARIANT_BOOL val)
	{
		VSL_DEFINE_MOCK_METHOD(put_RegisterForComInterop)

		VSL_CHECK_VALIDVALUE(val);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ConfigurationOverrideFileValidValues
	{
		/*[out,retval]*/ BSTR* pbstrConfigFile;
		HRESULT retValue;
	};

	STDMETHOD(get_ConfigurationOverrideFile)(
		/*[out,retval]*/ BSTR* pbstrConfigFile)
	{
		VSL_DEFINE_MOCK_METHOD(get_ConfigurationOverrideFile)

		VSL_SET_VALIDVALUE_BSTR(pbstrConfigFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_ConfigurationOverrideFileValidValues
	{
		/*[in]*/ BSTR bstrConfigFile;
		HRESULT retValue;
	};

	STDMETHOD(put_ConfigurationOverrideFile)(
		/*[in]*/ BSTR bstrConfigFile)
	{
		VSL_DEFINE_MOCK_METHOD(put_ConfigurationOverrideFile)

		VSL_CHECK_VALIDVALUE_BSTR(bstrConfigFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_RemoteDebugEnabledValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbEnableRemoteLaunch;
		HRESULT retValue;
	};

	STDMETHOD(get_RemoteDebugEnabled)(
		/*[out,retval]*/ VARIANT_BOOL* pbEnableRemoteLaunch)
	{
		VSL_DEFINE_MOCK_METHOD(get_RemoteDebugEnabled)

		VSL_SET_VALIDVALUE(pbEnableRemoteLaunch);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_RemoteDebugEnabledValidValues
	{
		/*[in]*/ VARIANT_BOOL bEnableRemoteLaunch;
		HRESULT retValue;
	};

	STDMETHOD(put_RemoteDebugEnabled)(
		/*[in]*/ VARIANT_BOOL bEnableRemoteLaunch)
	{
		VSL_DEFINE_MOCK_METHOD(put_RemoteDebugEnabled)

		VSL_CHECK_VALIDVALUE(bEnableRemoteLaunch);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_RemoteDebugMachineValidValues
	{
		/*[out,retval]*/ BSTR* pbstrRemoteLaunchMach;
		HRESULT retValue;
	};

	STDMETHOD(get_RemoteDebugMachine)(
		/*[out,retval]*/ BSTR* pbstrRemoteLaunchMach)
	{
		VSL_DEFINE_MOCK_METHOD(get_RemoteDebugMachine)

		VSL_SET_VALIDVALUE_BSTR(pbstrRemoteLaunchMach);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_RemoteDebugMachineValidValues
	{
		/*[in]*/ BSTR bstrRemoteLaunchMach;
		HRESULT retValue;
	};

	STDMETHOD(put_RemoteDebugMachine)(
		/*[in]*/ BSTR bstrRemoteLaunchMach)
	{
		VSL_DEFINE_MOCK_METHOD(put_RemoteDebugMachine)

		VSL_CHECK_VALIDVALUE_BSTR(bstrRemoteLaunchMach);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // JSHARPPROJECTCONFIGURATIONPROPERTIES3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockIXTLRuntime.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef IXTLRUNTIME_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define IXTLRUNTIME_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "XmlDom.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class IXTLRuntimeNotImpl :
	public IXTLRuntime
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IXTLRuntimeNotImpl)

public:

	typedef IXTLRuntime Interface;

	STDMETHOD(uniqueID)(
		/*[in]*/ IXMLDOMNode* /*pNode*/,
		/*[out,retval]*/ long* /*pID*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(depth)(
		/*[in]*/ IXMLDOMNode* /*pNode*/,
		/*[out,retval]*/ long* /*pDepth*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(childNumber)(
		/*[in]*/ IXMLDOMNode* /*pNode*/,
		/*[out,retval]*/ long* /*pNumber*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(ancestorChildNumber)(
		/*[in]*/ BSTR /*bstrNodeName*/,
		/*[in]*/ IXMLDOMNode* /*pNode*/,
		/*[out,retval]*/ long* /*pNumber*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(absoluteChildNumber)(
		/*[in]*/ IXMLDOMNode* /*pNode*/,
		/*[out,retval]*/ long* /*pNumber*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(formatIndex)(
		/*[in]*/ long /*lIndex*/,
		/*[in]*/ BSTR /*bstrFormat*/,
		/*[out,retval]*/ BSTR* /*pbstrFormattedString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(formatNumber)(
		/*[in]*/ double /*dblNumber*/,
		/*[in]*/ BSTR /*bstrFormat*/,
		/*[out,retval]*/ BSTR* /*pbstrFormattedString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(formatDate)(
		/*[in]*/ VARIANT /*varDate*/,
		/*[in]*/ BSTR /*bstrFormat*/,
		/*[in,optional]*/ VARIANT /*varDestLocale*/,
		/*[out,retval]*/ BSTR* /*pbstrFormattedString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(formatTime)(
		/*[in]*/ VARIANT /*varTime*/,
		/*[in]*/ BSTR /*bstrFormat*/,
		/*[in,optional]*/ VARIANT /*varDestLocale*/,
		/*[out,retval]*/ BSTR* /*pbstrFormattedString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeName)(
		/*[out,retval]*/ BSTR* /*name*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeValue)(
		/*[out,retval]*/ VARIANT* /*value*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_nodeValue)(
		/*[in]*/ VARIANT /*value*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeType)(
		/*[out,retval]*/ DOMNodeType* /*type*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_parentNode)(
		/*[out,retval]*/ IXMLDOMNode** /*parent*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_childNodes)(
		/*[out,retval]*/ IXMLDOMNodeList** /*childList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_firstChild)(
		/*[out,retval]*/ IXMLDOMNode** /*firstChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_lastChild)(
		/*[out,retval]*/ IXMLDOMNode** /*lastChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_previousSibling)(
		/*[out,retval]*/ IXMLDOMNode** /*previousSibling*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nextSibling)(
		/*[out,retval]*/ IXMLDOMNode** /*nextSibling*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_attributes)(
		/*[out,retval]*/ IXMLDOMNamedNodeMap** /*attributeMap*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(insertBefore)(
		/*[in]*/ IXMLDOMNode* /*newChild*/,
		/*[in]*/ VARIANT /*refChild*/,
		/*[out,retval]*/ IXMLDOMNode** /*outNewChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(replaceChild)(
		/*[in]*/ IXMLDOMNode* /*newChild*/,
		/*[in]*/ IXMLDOMNode* /*oldChild*/,
		/*[out,retval]*/ IXMLDOMNode** /*outOldChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(removeChild)(
		/*[in]*/ IXMLDOMNode* /*childNode*/,
		/*[out,retval]*/ IXMLDOMNode** /*oldChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(appendChild)(
		/*[in]*/ IXMLDOMNode* /*newChild*/,
		/*[out,retval]*/ IXMLDOMNode** /*outNewChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(hasChildNodes)(
		/*[out,retval]*/ VARIANT_BOOL* /*hasChild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ownerDocument)(
		/*[out,retval]*/ IXMLDOMDocument** /*DOMDocument*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(cloneNode)(
		/*[in]*/ VARIANT_BOOL /*deep*/,
		/*[out,retval]*/ IXMLDOMNode** /*cloneRoot*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeTypeString)(
		/*[retval,out]*/ BSTR* /*nodeType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_text)(
		/*[retval,out]*/ BSTR* /*text*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_text)(
		/*[in]*/ BSTR /*text*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_specified)(
		/*[out,retval]*/ VARIANT_BOOL* /*isSpecified*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_definition)(
		/*[retval,out]*/ IXMLDOMNode** /*definitionNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_nodeTypedValue)(
		/*[retval,out]*/ VARIANT* /*typedValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_nodeTypedValue)(
		/*[in]*/ VARIANT /*typedValue*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_dataType)(
		/*[retval,out]*/ VARIANT* /*dataTypeName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_dataType)(
		/*[in]*/ BSTR /*dataTypeName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_xml)(
		/*[retval,out]*/ BSTR* /*xmlString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(transformNode)(
		/*[in]*/ IXMLDOMNode* /*stylesheet*/,
		/*[retval,out]*/ BSTR* /*xmlString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(selectNodes)(
		/*[in]*/ BSTR /*queryString*/,
		/*[retval,out]*/ IXMLDOMNodeList** /*resultList*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(selectSingleNode)(
		/*[in]*/ BSTR /*queryString*/,
		/*[retval,out]*/ IXMLDOMNode** /*resultNode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_parsed)(
		/*[retval,out]*/ VARIANT_BOOL* /*isParsed*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_namespaceURI)(
		/*[retval,out]*/ BSTR* /*namespaceURI*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_prefix)(
		/*[retval,out]*/ BSTR* /*prefixString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_baseName)(
		/*[retval,out]*/ BSTR* /*nameString*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(transformNodeToObject)(
		/*[in]*/ IXMLDOMNode* /*stylesheet*/,
		/*[in]*/ VARIANT /*outputObject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class IXTLRuntimeMockImpl :
	public IXTLRuntime,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(IXTLRuntimeMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IXTLRuntimeMockImpl)

	typedef IXTLRuntime Interface;
	struct uniqueIDValidValues
	{
		/*[in]*/ IXMLDOMNode* pNode;
		/*[out,retval]*/ long* pID;
		HRESULT retValue;
	};

	STDMETHOD(uniqueID)(
		/*[in]*/ IXMLDOMNode* pNode,
		/*[out,retval]*/ long* pID)
	{
		VSL_DEFINE_MOCK_METHOD(uniqueID)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pNode);

		VSL_SET_VALIDVALUE(pID);

		VSL_RETURN_VALIDVALUES();
	}
	struct depthValidValues
	{
		/*[in]*/ IXMLDOMNode* pNode;
		/*[out,retval]*/ long* pDepth;
		HRESULT retValue;
	};

	STDMETHOD(depth)(
		/*[in]*/ IXMLDOMNode* pNode,
		/*[out,retval]*/ long* pDepth)
	{
		VSL_DEFINE_MOCK_METHOD(depth)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pNode);

		VSL_SET_VALIDVALUE(pDepth);

		VSL_RETURN_VALIDVALUES();
	}
	struct childNumberValidValues
	{
		/*[in]*/ IXMLDOMNode* pNode;
		/*[out,retval]*/ long* pNumber;
		HRESULT retValue;
	};

	STDMETHOD(childNumber)(
		/*[in]*/ IXMLDOMNode* pNode,
		/*[out,retval]*/ long* pNumber)
	{
		VSL_DEFINE_MOCK_METHOD(childNumber)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pNode);

		VSL_SET_VALIDVALUE(pNumber);

		VSL_RETURN_VALIDVALUES();
	}
	struct ancestorChildNumberValidValues
	{
		/*[in]*/ BSTR bstrNodeName;
		/*[in]*/ IXMLDOMNode* pNode;
		/*[out,retval]*/ long* pNumber;
		HRESULT retValue;
	};

	STDMETHOD(ancestorChildNumber)(
		/*[in]*/ BSTR bstrNodeName,
		/*[in]*/ IXMLDOMNode* pNode,
		/*[out,retval]*/ long* pNumber)
	{
		VSL_DEFINE_MOCK_METHOD(ancestorChildNumber)

		VSL_CHECK_VALIDVALUE_BSTR(bstrNodeName);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pNode);

		VSL_SET_VALIDVALUE(pNumber);

		VSL_RETURN_VALIDVALUES();
	}
	struct absoluteChildNumberValidValues
	{
		/*[in]*/ IXMLDOMNode* pNode;
		/*[out,retval]*/ long* pNumber;
		HRESULT retValue;
	};

	STDMETHOD(absoluteChildNumber)(
		/*[in]*/ IXMLDOMNode* pNode,
		/*[out,retval]*/ long* pNumber)
	{
		VSL_DEFINE_MOCK_METHOD(absoluteChildNumber)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pNode);

		VSL_SET_VALIDVALUE(pNumber);

		VSL_RETURN_VALIDVALUES();
	}
	struct formatIndexValidValues
	{
		/*[in]*/ long lIndex;
		/*[in]*/ BSTR bstrFormat;
		/*[out,retval]*/ BSTR* pbstrFormattedString;
		HRESULT retValue;
	};

	STDMETHOD(formatIndex)(
		/*[in]*/ long lIndex,
		/*[in]*/ BSTR bstrFormat,
		/*[out,retval]*/ BSTR* pbstrFormattedString)
	{
		VSL_DEFINE_MOCK_METHOD(formatIndex)

		VSL_CHECK_VALIDVALUE(lIndex);

		VSL_CHECK_VALIDVALUE_BSTR(bstrFormat);

		VSL_SET_VALIDVALUE_BSTR(pbstrFormattedString);

		VSL_RETURN_VALIDVALUES();
	}
	struct formatNumberValidValues
	{
		/*[in]*/ double dblNumber;
		/*[in]*/ BSTR bstrFormat;
		/*[out,retval]*/ BSTR* pbstrFormattedString;
		HRESULT retValue;
	};

	STDMETHOD(formatNumber)(
		/*[in]*/ double dblNumber,
		/*[in]*/ BSTR bstrFormat,
		/*[out,retval]*/ BSTR* pbstrFormattedString)
	{
		VSL_DEFINE_MOCK_METHOD(formatNumber)

		VSL_CHECK_VALIDVALUE(dblNumber);

		VSL_CHECK_VALIDVALUE_BSTR(bstrFormat);

		VSL_SET_VALIDVALUE_BSTR(pbstrFormattedString);

		VSL_RETURN_VALIDVALUES();
	}
	struct formatDateValidValues
	{
		/*[in]*/ VARIANT varDate;
		/*[in]*/ BSTR bstrFormat;
		/*[in,optional]*/ VARIANT varDestLocale;
		/*[out,retval]*/ BSTR* pbstrFormattedString;
		HRESULT retValue;
	};

	STDMETHOD(formatDate)(
		/*[in]*/ VARIANT varDate,
		/*[in]*/ BSTR bstrFormat,
		/*[in,optional]*/ VARIANT varDestLocale,
		/*[out,retval]*/ BSTR* pbstrFormattedString)
	{
		VSL_DEFINE_MOCK_METHOD(formatDate)

		VSL_CHECK_VALIDVALUE(varDate);

		VSL_CHECK_VALIDVALUE_BSTR(bstrFormat);

		VSL_CHECK_VALIDVALUE(varDestLocale);

		VSL_SET_VALIDVALUE_BSTR(pbstrFormattedString);

		VSL_RETURN_VALIDVALUES();
	}
	struct formatTimeValidValues
	{
		/*[in]*/ VARIANT varTime;
		/*[in]*/ BSTR bstrFormat;
		/*[in,optional]*/ VARIANT varDestLocale;
		/*[out,retval]*/ BSTR* pbstrFormattedString;
		HRESULT retValue;
	};

	STDMETHOD(formatTime)(
		/*[in]*/ VARIANT varTime,
		/*[in]*/ BSTR bstrFormat,
		/*[in,optional]*/ VARIANT varDestLocale,
		/*[out,retval]*/ BSTR* pbstrFormattedString)
	{
		VSL_DEFINE_MOCK_METHOD(formatTime)

		VSL_CHECK_VALIDVALUE(varTime);

		VSL_CHECK_VALIDVALUE_BSTR(bstrFormat);

		VSL_CHECK_VALIDVALUE(varDestLocale);

		VSL_SET_VALIDVALUE_BSTR(pbstrFormattedString);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeNameValidValues
	{
		/*[out,retval]*/ BSTR* name;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeName)(
		/*[out,retval]*/ BSTR* name)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeName)

		VSL_SET_VALIDVALUE_BSTR(name);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeValueValidValues
	{
		/*[out,retval]*/ VARIANT* value;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeValue)(
		/*[out,retval]*/ VARIANT* value)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeValue)

		VSL_SET_VALIDVALUE_VARIANT(value);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_nodeValueValidValues
	{
		/*[in]*/ VARIANT value;
		HRESULT retValue;
	};

	STDMETHOD(put_nodeValue)(
		/*[in]*/ VARIANT value)
	{
		VSL_DEFINE_MOCK_METHOD(put_nodeValue)

		VSL_CHECK_VALIDVALUE(value);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeTypeValidValues
	{
		/*[out,retval]*/ DOMNodeType* type;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeType)(
		/*[out,retval]*/ DOMNodeType* type)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeType)

		VSL_SET_VALIDVALUE(type);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_parentNodeValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** parent;
		HRESULT retValue;
	};

	STDMETHOD(get_parentNode)(
		/*[out,retval]*/ IXMLDOMNode** parent)
	{
		VSL_DEFINE_MOCK_METHOD(get_parentNode)

		VSL_SET_VALIDVALUE_INTERFACE(parent);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_childNodesValidValues
	{
		/*[out,retval]*/ IXMLDOMNodeList** childList;
		HRESULT retValue;
	};

	STDMETHOD(get_childNodes)(
		/*[out,retval]*/ IXMLDOMNodeList** childList)
	{
		VSL_DEFINE_MOCK_METHOD(get_childNodes)

		VSL_SET_VALIDVALUE_INTERFACE(childList);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_firstChildValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** firstChild;
		HRESULT retValue;
	};

	STDMETHOD(get_firstChild)(
		/*[out,retval]*/ IXMLDOMNode** firstChild)
	{
		VSL_DEFINE_MOCK_METHOD(get_firstChild)

		VSL_SET_VALIDVALUE_INTERFACE(firstChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_lastChildValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** lastChild;
		HRESULT retValue;
	};

	STDMETHOD(get_lastChild)(
		/*[out,retval]*/ IXMLDOMNode** lastChild)
	{
		VSL_DEFINE_MOCK_METHOD(get_lastChild)

		VSL_SET_VALIDVALUE_INTERFACE(lastChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_previousSiblingValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** previousSibling;
		HRESULT retValue;
	};

	STDMETHOD(get_previousSibling)(
		/*[out,retval]*/ IXMLDOMNode** previousSibling)
	{
		VSL_DEFINE_MOCK_METHOD(get_previousSibling)

		VSL_SET_VALIDVALUE_INTERFACE(previousSibling);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nextSiblingValidValues
	{
		/*[out,retval]*/ IXMLDOMNode** nextSibling;
		HRESULT retValue;
	};

	STDMETHOD(get_nextSibling)(
		/*[out,retval]*/ IXMLDOMNode** nextSibling)
	{
		VSL_DEFINE_MOCK_METHOD(get_nextSibling)

		VSL_SET_VALIDVALUE_INTERFACE(nextSibling);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_attributesValidValues
	{
		/*[out,retval]*/ IXMLDOMNamedNodeMap** attributeMap;
		HRESULT retValue;
	};

	STDMETHOD(get_attributes)(
		/*[out,retval]*/ IXMLDOMNamedNodeMap** attributeMap)
	{
		VSL_DEFINE_MOCK_METHOD(get_attributes)

		VSL_SET_VALIDVALUE_INTERFACE(attributeMap);

		VSL_RETURN_VALIDVALUES();
	}
	struct insertBeforeValidValues
	{
		/*[in]*/ IXMLDOMNode* newChild;
		/*[in]*/ VARIANT refChild;
		/*[out,retval]*/ IXMLDOMNode** outNewChild;
		HRESULT retValue;
	};

	STDMETHOD(insertBefore)(
		/*[in]*/ IXMLDOMNode* newChild,
		/*[in]*/ VARIANT refChild,
		/*[out,retval]*/ IXMLDOMNode** outNewChild)
	{
		VSL_DEFINE_MOCK_METHOD(insertBefore)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(newChild);

		VSL_CHECK_VALIDVALUE(refChild);

		VSL_SET_VALIDVALUE_INTERFACE(outNewChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct replaceChildValidValues
	{
		/*[in]*/ IXMLDOMNode* newChild;
		/*[in]*/ IXMLDOMNode* oldChild;
		/*[out,retval]*/ IXMLDOMNode** outOldChild;
		HRESULT retValue;
	};

	STDMETHOD(replaceChild)(
		/*[in]*/ IXMLDOMNode* newChild,
		/*[in]*/ IXMLDOMNode* oldChild,
		/*[out,retval]*/ IXMLDOMNode** outOldChild)
	{
		VSL_DEFINE_MOCK_METHOD(replaceChild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(newChild);

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(oldChild);

		VSL_SET_VALIDVALUE_INTERFACE(outOldChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct removeChildValidValues
	{
		/*[in]*/ IXMLDOMNode* childNode;
		/*[out,retval]*/ IXMLDOMNode** oldChild;
		HRESULT retValue;
	};

	STDMETHOD(removeChild)(
		/*[in]*/ IXMLDOMNode* childNode,
		/*[out,retval]*/ IXMLDOMNode** oldChild)
	{
		VSL_DEFINE_MOCK_METHOD(removeChild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(childNode);

		VSL_SET_VALIDVALUE_INTERFACE(oldChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct appendChildValidValues
	{
		/*[in]*/ IXMLDOMNode* newChild;
		/*[out,retval]*/ IXMLDOMNode** outNewChild;
		HRESULT retValue;
	};

	STDMETHOD(appendChild)(
		/*[in]*/ IXMLDOMNode* newChild,
		/*[out,retval]*/ IXMLDOMNode** outNewChild)
	{
		VSL_DEFINE_MOCK_METHOD(appendChild)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(newChild);

		VSL_SET_VALIDVALUE_INTERFACE(outNewChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct hasChildNodesValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* hasChild;
		HRESULT retValue;
	};

	STDMETHOD(hasChildNodes)(
		/*[out,retval]*/ VARIANT_BOOL* hasChild)
	{
		VSL_DEFINE_MOCK_METHOD(hasChildNodes)

		VSL_SET_VALIDVALUE(hasChild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ownerDocumentValidValues
	{
		/*[out,retval]*/ IXMLDOMDocument** DOMDocument;
		HRESULT retValue;
	};

	STDMETHOD(get_ownerDocument)(
		/*[out,retval]*/ IXMLDOMDocument** DOMDocument)
	{
		VSL_DEFINE_MOCK_METHOD(get_ownerDocument)

		VSL_SET_VALIDVALUE_INTERFACE(DOMDocument);

		VSL_RETURN_VALIDVALUES();
	}
	struct cloneNodeValidValues
	{
		/*[in]*/ VARIANT_BOOL deep;
		/*[out,retval]*/ IXMLDOMNode** cloneRoot;
		HRESULT retValue;
	};

	STDMETHOD(cloneNode)(
		/*[in]*/ VARIANT_BOOL deep,
		/*[out,retval]*/ IXMLDOMNode** cloneRoot)
	{
		VSL_DEFINE_MOCK_METHOD(cloneNode)

		VSL_CHECK_VALIDVALUE(deep);

		VSL_SET_VALIDVALUE_INTERFACE(cloneRoot);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeTypeStringValidValues
	{
		/*[retval,out]*/ BSTR* nodeType;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeTypeString)(
		/*[retval,out]*/ BSTR* nodeType)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeTypeString)

		VSL_SET_VALIDVALUE_BSTR(nodeType);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_textValidValues
	{
		/*[retval,out]*/ BSTR* text;
		HRESULT retValue;
	};

	STDMETHOD(get_text)(
		/*[retval,out]*/ BSTR* text)
	{
		VSL_DEFINE_MOCK_METHOD(get_text)

		VSL_SET_VALIDVALUE_BSTR(text);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_textValidValues
	{
		/*[in]*/ BSTR text;
		HRESULT retValue;
	};

	STDMETHOD(put_text)(
		/*[in]*/ BSTR text)
	{
		VSL_DEFINE_MOCK_METHOD(put_text)

		VSL_CHECK_VALIDVALUE_BSTR(text);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_specifiedValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* isSpecified;
		HRESULT retValue;
	};

	STDMETHOD(get_specified)(
		/*[out,retval]*/ VARIANT_BOOL* isSpecified)
	{
		VSL_DEFINE_MOCK_METHOD(get_specified)

		VSL_SET_VALIDVALUE(isSpecified);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_definitionValidValues
	{
		/*[retval,out]*/ IXMLDOMNode** definitionNode;
		HRESULT retValue;
	};

	STDMETHOD(get_definition)(
		/*[retval,out]*/ IXMLDOMNode** definitionNode)
	{
		VSL_DEFINE_MOCK_METHOD(get_definition)

		VSL_SET_VALIDVALUE_INTERFACE(definitionNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_nodeTypedValueValidValues
	{
		/*[retval,out]*/ VARIANT* typedValue;
		HRESULT retValue;
	};

	STDMETHOD(get_nodeTypedValue)(
		/*[retval,out]*/ VARIANT* typedValue)
	{
		VSL_DEFINE_MOCK_METHOD(get_nodeTypedValue)

		VSL_SET_VALIDVALUE_VARIANT(typedValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_nodeTypedValueValidValues
	{
		/*[in]*/ VARIANT typedValue;
		HRESULT retValue;
	};

	STDMETHOD(put_nodeTypedValue)(
		/*[in]*/ VARIANT typedValue)
	{
		VSL_DEFINE_MOCK_METHOD(put_nodeTypedValue)

		VSL_CHECK_VALIDVALUE(typedValue);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_dataTypeValidValues
	{
		/*[retval,out]*/ VARIANT* dataTypeName;
		HRESULT retValue;
	};

	STDMETHOD(get_dataType)(
		/*[retval,out]*/ VARIANT* dataTypeName)
	{
		VSL_DEFINE_MOCK_METHOD(get_dataType)

		VSL_SET_VALIDVALUE_VARIANT(dataTypeName);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_dataTypeValidValues
	{
		/*[in]*/ BSTR dataTypeName;
		HRESULT retValue;
	};

	STDMETHOD(put_dataType)(
		/*[in]*/ BSTR dataTypeName)
	{
		VSL_DEFINE_MOCK_METHOD(put_dataType)

		VSL_CHECK_VALIDVALUE_BSTR(dataTypeName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_xmlValidValues
	{
		/*[retval,out]*/ BSTR* xmlString;
		HRESULT retValue;
	};

	STDMETHOD(get_xml)(
		/*[retval,out]*/ BSTR* xmlString)
	{
		VSL_DEFINE_MOCK_METHOD(get_xml)

		VSL_SET_VALIDVALUE_BSTR(xmlString);

		VSL_RETURN_VALIDVALUES();
	}
	struct transformNodeValidValues
	{
		/*[in]*/ IXMLDOMNode* stylesheet;
		/*[retval,out]*/ BSTR* xmlString;
		HRESULT retValue;
	};

	STDMETHOD(transformNode)(
		/*[in]*/ IXMLDOMNode* stylesheet,
		/*[retval,out]*/ BSTR* xmlString)
	{
		VSL_DEFINE_MOCK_METHOD(transformNode)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(stylesheet);

		VSL_SET_VALIDVALUE_BSTR(xmlString);

		VSL_RETURN_VALIDVALUES();
	}
	struct selectNodesValidValues
	{
		/*[in]*/ BSTR queryString;
		/*[retval,out]*/ IXMLDOMNodeList** resultList;
		HRESULT retValue;
	};

	STDMETHOD(selectNodes)(
		/*[in]*/ BSTR queryString,
		/*[retval,out]*/ IXMLDOMNodeList** resultList)
	{
		VSL_DEFINE_MOCK_METHOD(selectNodes)

		VSL_CHECK_VALIDVALUE_BSTR(queryString);

		VSL_SET_VALIDVALUE_INTERFACE(resultList);

		VSL_RETURN_VALIDVALUES();
	}
	struct selectSingleNodeValidValues
	{
		/*[in]*/ BSTR queryString;
		/*[retval,out]*/ IXMLDOMNode** resultNode;
		HRESULT retValue;
	};

	STDMETHOD(selectSingleNode)(
		/*[in]*/ BSTR queryString,
		/*[retval,out]*/ IXMLDOMNode** resultNode)
	{
		VSL_DEFINE_MOCK_METHOD(selectSingleNode)

		VSL_CHECK_VALIDVALUE_BSTR(queryString);

		VSL_SET_VALIDVALUE_INTERFACE(resultNode);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_parsedValidValues
	{
		/*[retval,out]*/ VARIANT_BOOL* isParsed;
		HRESULT retValue;
	};

	STDMETHOD(get_parsed)(
		/*[retval,out]*/ VARIANT_BOOL* isParsed)
	{
		VSL_DEFINE_MOCK_METHOD(get_parsed)

		VSL_SET_VALIDVALUE(isParsed);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_namespaceURIValidValues
	{
		/*[retval,out]*/ BSTR* namespaceURI;
		HRESULT retValue;
	};

	STDMETHOD(get_namespaceURI)(
		/*[retval,out]*/ BSTR* namespaceURI)
	{
		VSL_DEFINE_MOCK_METHOD(get_namespaceURI)

		VSL_SET_VALIDVALUE_BSTR(namespaceURI);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_prefixValidValues
	{
		/*[retval,out]*/ BSTR* prefixString;
		HRESULT retValue;
	};

	STDMETHOD(get_prefix)(
		/*[retval,out]*/ BSTR* prefixString)
	{
		VSL_DEFINE_MOCK_METHOD(get_prefix)

		VSL_SET_VALIDVALUE_BSTR(prefixString);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_baseNameValidValues
	{
		/*[retval,out]*/ BSTR* nameString;
		HRESULT retValue;
	};

	STDMETHOD(get_baseName)(
		/*[retval,out]*/ BSTR* nameString)
	{
		VSL_DEFINE_MOCK_METHOD(get_baseName)

		VSL_SET_VALIDVALUE_BSTR(nameString);

		VSL_RETURN_VALIDVALUES();
	}
	struct transformNodeToObjectValidValues
	{
		/*[in]*/ IXMLDOMNode* stylesheet;
		/*[in]*/ VARIANT outputObject;
		HRESULT retValue;
	};

	STDMETHOD(transformNodeToObject)(
		/*[in]*/ IXMLDOMNode* stylesheet,
		/*[in]*/ VARIANT outputObject)
	{
		VSL_DEFINE_MOCK_METHOD(transformNodeToObject)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(stylesheet);

		VSL_CHECK_VALIDVALUE(outputObject);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // IXTLRUNTIME_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockProjectConfigurationProperties.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef PROJECTCONFIGURATIONPROPERTIES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define PROJECTCONFIGURATIONPROPERTIES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vslangproj.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ProjectConfigurationPropertiesNotImpl :
	public ProjectConfigurationProperties
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ProjectConfigurationPropertiesNotImpl)

public:

	typedef ProjectConfigurationProperties Interface;

	STDMETHOD(get___id)(
		/*[out,retval]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DebugSymbols)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbGenerate*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DebugSymbols)(
		/*[in]*/ VARIANT_BOOL /*bGenerate*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DefineDebug)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbDefineDebug*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DefineDebug)(
		/*[in]*/ VARIANT_BOOL /*bDefineDebug*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DefineTrace)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbDefineTrace*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DefineTrace)(
		/*[in]*/ VARIANT_BOOL /*bDefineTrace*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_OutputPath)(
		/*[out,retval]*/ BSTR* /*pbstrOutputPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_OutputPath)(
		/*[in]*/ BSTR /*bstrOutputPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_IntermediatePath)(
		/*[out,retval]*/ BSTR* /*pbstrIntermediatePath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_IntermediatePath)(
		/*[in]*/ BSTR /*bstrIntermediatePath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DefineConstants)(
		/*[out,retval]*/ BSTR* /*pbstrDefineConstants*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DefineConstants)(
		/*[in]*/ BSTR /*bstrDefineConstants*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_RemoveIntegerChecks)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbRemoveIntegerChecks*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_RemoveIntegerChecks)(
		/*[in]*/ VARIANT_BOOL /*bRemoveIntegerChecks*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_BaseAddress)(
		/*[out,retval]*/ DWORD* /*pdwBaseAddress*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_BaseAddress)(
		/*[in]*/ DWORD /*dwBaseAddress*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_AllowUnsafeBlocks)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbUnsafe*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_AllowUnsafeBlocks)(
		/*[in]*/ VARIANT_BOOL /*bUnsafe*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CheckForOverflowUnderflow)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbCheckForOverflowUnderflow*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_CheckForOverflowUnderflow)(
		/*[in]*/ VARIANT_BOOL /*bCheckForOverflowUnderflow*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DocumentationFile)(
		/*[out,retval]*/ BSTR* /*pbstrDocumentationFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DocumentationFile)(
		/*[in]*/ BSTR /*bstrDocumentationFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Optimize)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbOptimize*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_Optimize)(
		/*[in]*/ VARIANT_BOOL /*bCheckForOverflowUnderflow*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_IncrementalBuild)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbIncrementalBuild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_IncrementalBuild)(
		/*[in]*/ VARIANT_BOOL /*bIncrementalBuild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_StartProgram)(
		/*[out,retval]*/ BSTR* /*pbstrStartProgram*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_StartProgram)(
		/*[in]*/ BSTR /*bstrStartProgram*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_StartWorkingDirectory)(
		/*[out,retval]*/ BSTR* /*pbstrStartWorkingDirectory*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_StartWorkingDirectory)(
		/*[in]*/ BSTR /*bstrStartWorkingDirectory*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_StartURL)(
		/*[out,retval]*/ BSTR* /*pbstrStartURL*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_StartURL)(
		/*[in]*/ BSTR /*bstrStartURL*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_StartPage)(
		/*[out,retval]*/ BSTR* /*pbstrStartPage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_StartPage)(
		/*[in]*/ BSTR /*bstrStartPage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_StartArguments)(
		/*[out,retval]*/ BSTR* /*pbstrStartArguments*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_StartArguments)(
		/*[in]*/ BSTR /*bstrStartArguments*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_StartWithIE)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbStartWithIE*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_StartWithIE)(
		/*[in]*/ VARIANT_BOOL /*bStartWithIE*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_EnableASPDebugging)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbEnableASPDebugging*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_EnableASPDebugging)(
		/*[in]*/ VARIANT_BOOL /*bEnableASPDebugging*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_EnableASPXDebugging)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbEnableASPXDebugging*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_EnableASPXDebugging)(
		/*[in]*/ VARIANT_BOOL /*bEnableASPXDebugging*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_EnableUnmanagedDebugging)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbEnableUnmanagedDebugging*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_EnableUnmanagedDebugging)(
		/*[in]*/ VARIANT_BOOL /*bEnableUnmanagedDebugging*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_StartAction)(
		/*[out,retval]*/ prjStartAction* /*pdebugStartMode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_StartAction)(
		/*[in]*/ prjStartAction /*debugStartMode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Extender)(
		/*[in]*/ BSTR /*ExtenderName*/,
		/*[out,retval]*/ IDispatch** /*Extender*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ExtenderNames)(
		/*[out,retval]*/ VARIANT* /*ExtenderNames*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ExtenderCATID)(
		/*[out,retval]*/ BSTR* /*pRetval*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_WarningLevel)(
		/*[out,retval]*/ prjWarningLevel* /*pWarningLeve*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_WarningLevel)(
		/*[in]*/ prjWarningLevel /*warningLevel*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_TreatWarningsAsErrors)(
		/*[out,retval]*/ VARIANT_BOOL* /*pWarningAsError*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_TreatWarningsAsErrors)(
		/*[in]*/ VARIANT_BOOL /*warningAsError*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_EnableSQLServerDebugging)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbEnableSQLServerDebugging*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_EnableSQLServerDebugging)(
		/*[in]*/ VARIANT_BOOL /*bEnableSQLServerDebugging*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_FileAlignment)(
		/*[out,retval]*/ DWORD* /*pdwFileAlignment*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_FileAlignment)(
		/*[in]*/ DWORD /*dwFileAlignment*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_RegisterForComInterop)(
		/*[out,retval]*/ VARIANT_BOOL* /*pVal*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_RegisterForComInterop)(
		/*[in]*/ VARIANT_BOOL /*val*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ConfigurationOverrideFile)(
		/*[out,retval]*/ BSTR* /*pbstrConfigFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_ConfigurationOverrideFile)(
		/*[in]*/ BSTR /*bstrConfigFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_RemoteDebugEnabled)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbEnableRemoteLaunch*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_RemoteDebugEnabled)(
		/*[in]*/ VARIANT_BOOL /*bEnableRemoteLaunch*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_RemoteDebugMachine)(
		/*[out,retval]*/ BSTR* /*pbstrRemoteLaunchMach*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_RemoteDebugMachine)(
		/*[in]*/ BSTR /*bstrRemoteLaunchMach*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class ProjectConfigurationPropertiesMockImpl :
	public ProjectConfigurationProperties,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ProjectConfigurationPropertiesMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ProjectConfigurationPropertiesMockImpl)

	typedef ProjectConfigurationProperties Interface;
	struct get___idValidValues
	{
		/*[out,retval]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(get___id)(
		/*[out,retval]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(get___id)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DebugSymbolsValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbGenerate;
		HRESULT retValue;
	};

	STDMETHOD(get_DebugSymbols)(
		/*[out,retval]*/ VARIANT_BOOL* pbGenerate)
	{
		VSL_DEFINE_MOCK_METHOD(get_DebugSymbols)

		VSL_SET_VALIDVALUE(pbGenerate);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DebugSymbolsValidValues
	{
		/*[in]*/ VARIANT_BOOL bGenerate;
		HRESULT retValue;
	};

	STDMETHOD(put_DebugSymbols)(
		/*[in]*/ VARIANT_BOOL bGenerate)
	{
		VSL_DEFINE_MOCK_METHOD(put_DebugSymbols)

		VSL_CHECK_VALIDVALUE(bGenerate);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DefineDebugValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbDefineDebug;
		HRESULT retValue;
	};

	STDMETHOD(get_DefineDebug)(
		/*[out,retval]*/ VARIANT_BOOL* pbDefineDebug)
	{
		VSL_DEFINE_MOCK_METHOD(get_DefineDebug)

		VSL_SET_VALIDVALUE(pbDefineDebug);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DefineDebugValidValues
	{
		/*[in]*/ VARIANT_BOOL bDefineDebug;
		HRESULT retValue;
	};

	STDMETHOD(put_DefineDebug)(
		/*[in]*/ VARIANT_BOOL bDefineDebug)
	{
		VSL_DEFINE_MOCK_METHOD(put_DefineDebug)

		VSL_CHECK_VALIDVALUE(bDefineDebug);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DefineTraceValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbDefineTrace;
		HRESULT retValue;
	};

	STDMETHOD(get_DefineTrace)(
		/*[out,retval]*/ VARIANT_BOOL* pbDefineTrace)
	{
		VSL_DEFINE_MOCK_METHOD(get_DefineTrace)

		VSL_SET_VALIDVALUE(pbDefineTrace);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DefineTraceValidValues
	{
		/*[in]*/ VARIANT_BOOL bDefineTrace;
		HRESULT retValue;
	};

	STDMETHOD(put_DefineTrace)(
		/*[in]*/ VARIANT_BOOL bDefineTrace)
	{
		VSL_DEFINE_MOCK_METHOD(put_DefineTrace)

		VSL_CHECK_VALIDVALUE(bDefineTrace);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_OutputPathValidValues
	{
		/*[out,retval]*/ BSTR* pbstrOutputPath;
		HRESULT retValue;
	};

	STDMETHOD(get_OutputPath)(
		/*[out,retval]*/ BSTR* pbstrOutputPath)
	{
		VSL_DEFINE_MOCK_METHOD(get_OutputPath)

		VSL_SET_VALIDVALUE_BSTR(pbstrOutputPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_OutputPathValidValues
	{
		/*[in]*/ BSTR bstrOutputPath;
		HRESULT retValue;
	};

	STDMETHOD(put_OutputPath)(
		/*[in]*/ BSTR bstrOutputPath)
	{
		VSL_DEFINE_MOCK_METHOD(put_OutputPath)

		VSL_CHECK_VALIDVALUE_BSTR(bstrOutputPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IntermediatePathValidValues
	{
		/*[out,retval]*/ BSTR* pbstrIntermediatePath;
		HRESULT retValue;
	};

	STDMETHOD(get_IntermediatePath)(
		/*[out,retval]*/ BSTR* pbstrIntermediatePath)
	{
		VSL_DEFINE_MOCK_METHOD(get_IntermediatePath)

		VSL_SET_VALIDVALUE_BSTR(pbstrIntermediatePath);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_IntermediatePathValidValues
	{
		/*[in]*/ BSTR bstrIntermediatePath;
		HRESULT retValue;
	};

	STDMETHOD(put_IntermediatePath)(
		/*[in]*/ BSTR bstrIntermediatePath)
	{
		VSL_DEFINE_MOCK_METHOD(put_IntermediatePath)

		VSL_CHECK_VALIDVALUE_BSTR(bstrIntermediatePath);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DefineConstantsValidValues
	{
		/*[out,retval]*/ BSTR* pbstrDefineConstants;
		HRESULT retValue;
	};

	STDMETHOD(get_DefineConstants)(
		/*[out,retval]*/ BSTR* pbstrDefineConstants)
	{
		VSL_DEFINE_MOCK_METHOD(get_DefineConstants)

		VSL_SET_VALIDVALUE_BSTR(pbstrDefineConstants);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DefineConstantsValidValues
	{
		/*[in]*/ BSTR bstrDefineConstants;
		HRESULT retValue;
	};

	STDMETHOD(put_DefineConstants)(
		/*[in]*/ BSTR bstrDefineConstants)
	{
		VSL_DEFINE_MOCK_METHOD(put_DefineConstants)

		VSL_CHECK_VALIDVALUE_BSTR(bstrDefineConstants);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_RemoveIntegerChecksValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbRemoveIntegerChecks;
		HRESULT retValue;
	};

	STDMETHOD(get_RemoveIntegerChecks)(
		/*[out,retval]*/ VARIANT_BOOL* pbRemoveIntegerChecks)
	{
		VSL_DEFINE_MOCK_METHOD(get_RemoveIntegerChecks)

		VSL_SET_VALIDVALUE(pbRemoveIntegerChecks);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_RemoveIntegerChecksValidValues
	{
		/*[in]*/ VARIANT_BOOL bRemoveIntegerChecks;
		HRESULT retValue;
	};

	STDMETHOD(put_RemoveIntegerChecks)(
		/*[in]*/ VARIANT_BOOL bRemoveIntegerChecks)
	{
		VSL_DEFINE_MOCK_METHOD(put_RemoveIntegerChecks)

		VSL_CHECK_VALIDVALUE(bRemoveIntegerChecks);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_BaseAddressValidValues
	{
		/*[out,retval]*/ DWORD* pdwBaseAddress;
		HRESULT retValue;
	};

	STDMETHOD(get_BaseAddress)(
		/*[out,retval]*/ DWORD* pdwBaseAddress)
	{
		VSL_DEFINE_MOCK_METHOD(get_BaseAddress)

		VSL_SET_VALIDVALUE(pdwBaseAddress);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_BaseAddressValidValues
	{
		/*[in]*/ DWORD dwBaseAddress;
		HRESULT retValue;
	};

	STDMETHOD(put_BaseAddress)(
		/*[in]*/ DWORD dwBaseAddress)
	{
		VSL_DEFINE_MOCK_METHOD(put_BaseAddress)

		VSL_CHECK_VALIDVALUE(dwBaseAddress);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_AllowUnsafeBlocksValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbUnsafe;
		HRESULT retValue;
	};

	STDMETHOD(get_AllowUnsafeBlocks)(
		/*[out,retval]*/ VARIANT_BOOL* pbUnsafe)
	{
		VSL_DEFINE_MOCK_METHOD(get_AllowUnsafeBlocks)

		VSL_SET_VALIDVALUE(pbUnsafe);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_AllowUnsafeBlocksValidValues
	{
		/*[in]*/ VARIANT_BOOL bUnsafe;
		HRESULT retValue;
	};

	STDMETHOD(put_AllowUnsafeBlocks)(
		/*[in]*/ VARIANT_BOOL bUnsafe)
	{
		VSL_DEFINE_MOCK_METHOD(put_AllowUnsafeBlocks)

		VSL_CHECK_VALIDVALUE(bUnsafe);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CheckForOverflowUnderflowValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbCheckForOverflowUnderflow;
		HRESULT retValue;
	};

	STDMETHOD(get_CheckForOverflowUnderflow)(
		/*[out,retval]*/ VARIANT_BOOL* pbCheckForOverflowUnderflow)
	{
		VSL_DEFINE_MOCK_METHOD(get_CheckForOverflowUnderflow)

		VSL_SET_VALIDVALUE(pbCheckForOverflowUnderflow);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_CheckForOverflowUnderflowValidValues
	{
		/*[in]*/ VARIANT_BOOL bCheckForOverflowUnderflow;
		HRESULT retValue;
	};

	STDMETHOD(put_CheckForOverflowUnderflow)(
		/*[in]*/ VARIANT_BOOL bCheckForOverflowUnderflow)
	{
		VSL_DEFINE_MOCK_METHOD(put_CheckForOverflowUnderflow)

		VSL_CHECK_VALIDVALUE(bCheckForOverflowUnderflow);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DocumentationFileValidValues
	{
		/*[out,retval]*/ BSTR* pbstrDocumentationFile;
		HRESULT retValue;
	};

	STDMETHOD(get_DocumentationFile)(
		/*[out,retval]*/ BSTR* pbstrDocumentationFile)
	{
		VSL_DEFINE_MOCK_METHOD(get_DocumentationFile)

		VSL_SET_VALIDVALUE_BSTR(pbstrDocumentationFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DocumentationFileValidValues
	{
		/*[in]*/ BSTR bstrDocumentationFile;
		HRESULT retValue;
	};

	STDMETHOD(put_DocumentationFile)(
		/*[in]*/ BSTR bstrDocumentationFile)
	{
		VSL_DEFINE_MOCK_METHOD(put_DocumentationFile)

		VSL_CHECK_VALIDVALUE_BSTR(bstrDocumentationFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_OptimizeValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbOptimize;
		HRESULT retValue;
	};

	STDMETHOD(get_Optimize)(
		/*[out,retval]*/ VARIANT_BOOL* pbOptimize)
	{
		VSL_DEFINE_MOCK_METHOD(get_Optimize)

		VSL_SET_VALIDVALUE(pbOptimize);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_OptimizeValidValues
	{
		/*[in]*/ VARIANT_BOOL bCheckForOverflowUnderflow;
		HRESULT retValue;
	};

	STDMETHOD(put_Optimize)(
		/*[in]*/ VARIANT_BOOL bCheckForOverflowUnderflow)
	{
		VSL_DEFINE_MOCK_METHOD(put_Optimize)

		VSL_CHECK_VALIDVALUE(bCheckForOverflowUnderflow);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IncrementalBuildValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbIncrementalBuild;
		HRESULT retValue;
	};

	STDMETHOD(get_IncrementalBuild)(
		/*[out,retval]*/ VARIANT_BOOL* pbIncrementalBuild)
	{
		VSL_DEFINE_MOCK_METHOD(get_IncrementalBuild)

		VSL_SET_VALIDVALUE(pbIncrementalBuild);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_IncrementalBuildValidValues
	{
		/*[in]*/ VARIANT_BOOL bIncrementalBuild;
		HRESULT retValue;
	};

	STDMETHOD(put_IncrementalBuild)(
		/*[in]*/ VARIANT_BOOL bIncrementalBuild)
	{
		VSL_DEFINE_MOCK_METHOD(put_IncrementalBuild)

		VSL_CHECK_VALIDVALUE(bIncrementalBuild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_StartProgramValidValues
	{
		/*[out,retval]*/ BSTR* pbstrStartProgram;
		HRESULT retValue;
	};

	STDMETHOD(get_StartProgram)(
		/*[out,retval]*/ BSTR* pbstrStartProgram)
	{
		VSL_DEFINE_MOCK_METHOD(get_StartProgram)

		VSL_SET_VALIDVALUE_BSTR(pbstrStartProgram);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_StartProgramValidValues
	{
		/*[in]*/ BSTR bstrStartProgram;
		HRESULT retValue;
	};

	STDMETHOD(put_StartProgram)(
		/*[in]*/ BSTR bstrStartProgram)
	{
		VSL_DEFINE_MOCK_METHOD(put_StartProgram)

		VSL_CHECK_VALIDVALUE_BSTR(bstrStartProgram);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_StartWorkingDirectoryValidValues
	{
		/*[out,retval]*/ BSTR* pbstrStartWorkingDirectory;
		HRESULT retValue;
	};

	STDMETHOD(get_StartWorkingDirectory)(
		/*[out,retval]*/ BSTR* pbstrStartWorkingDirectory)
	{
		VSL_DEFINE_MOCK_METHOD(get_StartWorkingDirectory)

		VSL_SET_VALIDVALUE_BSTR(pbstrStartWorkingDirectory);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_StartWorkingDirectoryValidValues
	{
		/*[in]*/ BSTR bstrStartWorkingDirectory;
		HRESULT retValue;
	};

	STDMETHOD(put_StartWorkingDirectory)(
		/*[in]*/ BSTR bstrStartWorkingDirectory)
	{
		VSL_DEFINE_MOCK_METHOD(put_StartWorkingDirectory)

		VSL_CHECK_VALIDVALUE_BSTR(bstrStartWorkingDirectory);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_StartURLValidValues
	{
		/*[out,retval]*/ BSTR* pbstrStartURL;
		HRESULT retValue;
	};

	STDMETHOD(get_StartURL)(
		/*[out,retval]*/ BSTR* pbstrStartURL)
	{
		VSL_DEFINE_MOCK_METHOD(get_StartURL)

		VSL_SET_VALIDVALUE_BSTR(pbstrStartURL);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_StartURLValidValues
	{
		/*[in]*/ BSTR bstrStartURL;
		HRESULT retValue;
	};

	STDMETHOD(put_StartURL)(
		/*[in]*/ BSTR bstrStartURL)
	{
		VSL_DEFINE_MOCK_METHOD(put_StartURL)

		VSL_CHECK_VALIDVALUE_BSTR(bstrStartURL);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_StartPageValidValues
	{
		/*[out,retval]*/ BSTR* pbstrStartPage;
		HRESULT retValue;
	};

	STDMETHOD(get_StartPage)(
		/*[out,retval]*/ BSTR* pbstrStartPage)
	{
		VSL_DEFINE_MOCK_METHOD(get_StartPage)

		VSL_SET_VALIDVALUE_BSTR(pbstrStartPage);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_StartPageValidValues
	{
		/*[in]*/ BSTR bstrStartPage;
		HRESULT retValue;
	};

	STDMETHOD(put_StartPage)(
		/*[in]*/ BSTR bstrStartPage)
	{
		VSL_DEFINE_MOCK_METHOD(put_StartPage)

		VSL_CHECK_VALIDVALUE_BSTR(bstrStartPage);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_StartArgumentsValidValues
	{
		/*[out,retval]*/ BSTR* pbstrStartArguments;
		HRESULT retValue;
	};

	STDMETHOD(get_StartArguments)(
		/*[out,retval]*/ BSTR* pbstrStartArguments)
	{
		VSL_DEFINE_MOCK_METHOD(get_StartArguments)

		VSL_SET_VALIDVALUE_BSTR(pbstrStartArguments);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_StartArgumentsValidValues
	{
		/*[in]*/ BSTR bstrStartArguments;
		HRESULT retValue;
	};

	STDMETHOD(put_StartArguments)(
		/*[in]*/ BSTR bstrStartArguments)
	{
		VSL_DEFINE_MOCK_METHOD(put_StartArguments)

		VSL_CHECK_VALIDVALUE_BSTR(bstrStartArguments);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_StartWithIEValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbStartWithIE;
		HRESULT retValue;
	};

	STDMETHOD(get_StartWithIE)(
		/*[out,retval]*/ VARIANT_BOOL* pbStartWithIE)
	{
		VSL_DEFINE_MOCK_METHOD(get_StartWithIE)

		VSL_SET_VALIDVALUE(pbStartWithIE);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_StartWithIEValidValues
	{
		/*[in]*/ VARIANT_BOOL bStartWithIE;
		HRESULT retValue;
	};

	STDMETHOD(put_StartWithIE)(
		/*[in]*/ VARIANT_BOOL bStartWithIE)
	{
		VSL_DEFINE_MOCK_METHOD(put_StartWithIE)

		VSL_CHECK_VALIDVALUE(bStartWithIE);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_EnableASPDebuggingValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbEnableASPDebugging;
		HRESULT retValue;
	};

	STDMETHOD(get_EnableASPDebugging)(
		/*[out,retval]*/ VARIANT_BOOL* pbEnableASPDebugging)
	{
		VSL_DEFINE_MOCK_METHOD(get_EnableASPDebugging)

		VSL_SET_VALIDVALUE(pbEnableASPDebugging);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_EnableASPDebuggingValidValues
	{
		/*[in]*/ VARIANT_BOOL bEnableASPDebugging;
		HRESULT retValue;
	};

	STDMETHOD(put_EnableASPDebugging)(
		/*[in]*/ VARIANT_BOOL bEnableASPDebugging)
	{
		VSL_DEFINE_MOCK_METHOD(put_EnableASPDebugging)

		VSL_CHECK_VALIDVALUE(bEnableASPDebugging);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_EnableASPXDebuggingValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbEnableASPXDebugging;
		HRESULT retValue;
	};

	STDMETHOD(get_EnableASPXDebugging)(
		/*[out,retval]*/ VARIANT_BOOL* pbEnableASPXDebugging)
	{
		VSL_DEFINE_MOCK_METHOD(get_EnableASPXDebugging)

		VSL_SET_VALIDVALUE(pbEnableASPXDebugging);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_EnableASPXDebuggingValidValues
	{
		/*[in]*/ VARIANT_BOOL bEnableASPXDebugging;
		HRESULT retValue;
	};

	STDMETHOD(put_EnableASPXDebugging)(
		/*[in]*/ VARIANT_BOOL bEnableASPXDebugging)
	{
		VSL_DEFINE_MOCK_METHOD(put_EnableASPXDebugging)

		VSL_CHECK_VALIDVALUE(bEnableASPXDebugging);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_EnableUnmanagedDebuggingValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbEnableUnmanagedDebugging;
		HRESULT retValue;
	};

	STDMETHOD(get_EnableUnmanagedDebugging)(
		/*[out,retval]*/ VARIANT_BOOL* pbEnableUnmanagedDebugging)
	{
		VSL_DEFINE_MOCK_METHOD(get_EnableUnmanagedDebugging)

		VSL_SET_VALIDVALUE(pbEnableUnmanagedDebugging);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_EnableUnmanagedDebuggingValidValues
	{
		/*[in]*/ VARIANT_BOOL bEnableUnmanagedDebugging;
		HRESULT retValue;
	};

	STDMETHOD(put_EnableUnmanagedDebugging)(
		/*[in]*/ VARIANT_BOOL bEnableUnmanagedDebugging)
	{
		VSL_DEFINE_MOCK_METHOD(put_EnableUnmanagedDebugging)

		VSL_CHECK_VALIDVALUE(bEnableUnmanagedDebugging);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_StartActionValidValues
	{
		/*[out,retval]*/ prjStartAction* pdebugStartMode;
		HRESULT retValue;
	};

	STDMETHOD(get_StartAction)(
		/*[out,retval]*/ prjStartAction* pdebugStartMode)
	{
		VSL_DEFINE_MOCK_METHOD(get_StartAction)

		VSL_SET_VALIDVALUE(pdebugStartMode);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_StartActionValidValues
	{
		/*[in]*/ prjStartAction debugStartMode;
		HRESULT retValue;
	};

	STDMETHOD(put_StartAction)(
		/*[in]*/ prjStartAction debugStartMode)
	{
		VSL_DEFINE_MOCK_METHOD(put_StartAction)

		VSL_CHECK_VALIDVALUE(debugStartMode);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderValidValues
	{
		/*[in]*/ BSTR ExtenderName;
		/*[out,retval]*/ IDispatch** Extender;
		HRESULT retValue;
	};

	STDMETHOD(get_Extender)(
		/*[in]*/ BSTR ExtenderName,
		/*[out,retval]*/ IDispatch** Extender)
	{
		VSL_DEFINE_MOCK_METHOD(get_Extender)

		VSL_CHECK_VALIDVALUE_BSTR(ExtenderName);

		VSL_SET_VALIDVALUE_INTERFACE(Extender);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderNamesValidValues
	{
		/*[out,retval]*/ VARIANT* ExtenderNames;
		HRESULT retValue;
	};

	STDMETHOD(get_ExtenderNames)(
		/*[out,retval]*/ VARIANT* ExtenderNames)
	{
		VSL_DEFINE_MOCK_METHOD(get_ExtenderNames)

		VSL_SET_VALIDVALUE_VARIANT(ExtenderNames);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderCATIDValidValues
	{
		/*[out,retval]*/ BSTR* pRetval;
		HRESULT retValue;
	};

	STDMETHOD(get_ExtenderCATID)(
		/*[out,retval]*/ BSTR* pRetval)
	{
		VSL_DEFINE_MOCK_METHOD(get_ExtenderCATID)

		VSL_SET_VALIDVALUE_BSTR(pRetval);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_WarningLevelValidValues
	{
		/*[out,retval]*/ prjWarningLevel* pWarningLeve;
		HRESULT retValue;
	};

	STDMETHOD(get_WarningLevel)(
		/*[out,retval]*/ prjWarningLevel* pWarningLeve)
	{
		VSL_DEFINE_MOCK_METHOD(get_WarningLevel)

		VSL_SET_VALIDVALUE(pWarningLeve);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_WarningLevelValidValues
	{
		/*[in]*/ prjWarningLevel warningLevel;
		HRESULT retValue;
	};

	STDMETHOD(put_WarningLevel)(
		/*[in]*/ prjWarningLevel warningLevel)
	{
		VSL_DEFINE_MOCK_METHOD(put_WarningLevel)

		VSL_CHECK_VALIDVALUE(warningLevel);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_TreatWarningsAsErrorsValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pWarningAsError;
		HRESULT retValue;
	};

	STDMETHOD(get_TreatWarningsAsErrors)(
		/*[out,retval]*/ VARIANT_BOOL* pWarningAsError)
	{
		VSL_DEFINE_MOCK_METHOD(get_TreatWarningsAsErrors)

		VSL_SET_VALIDVALUE(pWarningAsError);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_TreatWarningsAsErrorsValidValues
	{
		/*[in]*/ VARIANT_BOOL warningAsError;
		HRESULT retValue;
	};

	STDMETHOD(put_TreatWarningsAsErrors)(
		/*[in]*/ VARIANT_BOOL warningAsError)
	{
		VSL_DEFINE_MOCK_METHOD(put_TreatWarningsAsErrors)

		VSL_CHECK_VALIDVALUE(warningAsError);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_EnableSQLServerDebuggingValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbEnableSQLServerDebugging;
		HRESULT retValue;
	};

	STDMETHOD(get_EnableSQLServerDebugging)(
		/*[out,retval]*/ VARIANT_BOOL* pbEnableSQLServerDebugging)
	{
		VSL_DEFINE_MOCK_METHOD(get_EnableSQLServerDebugging)

		VSL_SET_VALIDVALUE(pbEnableSQLServerDebugging);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_EnableSQLServerDebuggingValidValues
	{
		/*[in]*/ VARIANT_BOOL bEnableSQLServerDebugging;
		HRESULT retValue;
	};

	STDMETHOD(put_EnableSQLServerDebugging)(
		/*[in]*/ VARIANT_BOOL bEnableSQLServerDebugging)
	{
		VSL_DEFINE_MOCK_METHOD(put_EnableSQLServerDebugging)

		VSL_CHECK_VALIDVALUE(bEnableSQLServerDebugging);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_FileAlignmentValidValues
	{
		/*[out,retval]*/ DWORD* pdwFileAlignment;
		HRESULT retValue;
	};

	STDMETHOD(get_FileAlignment)(
		/*[out,retval]*/ DWORD* pdwFileAlignment)
	{
		VSL_DEFINE_MOCK_METHOD(get_FileAlignment)

		VSL_SET_VALIDVALUE(pdwFileAlignment);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_FileAlignmentValidValues
	{
		/*[in]*/ DWORD dwFileAlignment;
		HRESULT retValue;
	};

	STDMETHOD(put_FileAlignment)(
		/*[in]*/ DWORD dwFileAlignment)
	{
		VSL_DEFINE_MOCK_METHOD(put_FileAlignment)

		VSL_CHECK_VALIDVALUE(dwFileAlignment);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_RegisterForComInteropValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pVal;
		HRESULT retValue;
	};

	STDMETHOD(get_RegisterForComInterop)(
		/*[out,retval]*/ VARIANT_BOOL* pVal)
	{
		VSL_DEFINE_MOCK_METHOD(get_RegisterForComInterop)

		VSL_SET_VALIDVALUE(pVal);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_RegisterForComInteropValidValues
	{
		/*[in]*/ VARIANT_BOOL val;
		HRESULT retValue;
	};

	STDMETHOD(put_RegisterForComInterop)(
		/*[in]*/ VARIANT_BOOL val)
	{
		VSL_DEFINE_MOCK_METHOD(put_RegisterForComInterop)

		VSL_CHECK_VALIDVALUE(val);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ConfigurationOverrideFileValidValues
	{
		/*[out,retval]*/ BSTR* pbstrConfigFile;
		HRESULT retValue;
	};

	STDMETHOD(get_ConfigurationOverrideFile)(
		/*[out,retval]*/ BSTR* pbstrConfigFile)
	{
		VSL_DEFINE_MOCK_METHOD(get_ConfigurationOverrideFile)

		VSL_SET_VALIDVALUE_BSTR(pbstrConfigFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_ConfigurationOverrideFileValidValues
	{
		/*[in]*/ BSTR bstrConfigFile;
		HRESULT retValue;
	};

	STDMETHOD(put_ConfigurationOverrideFile)(
		/*[in]*/ BSTR bstrConfigFile)
	{
		VSL_DEFINE_MOCK_METHOD(put_ConfigurationOverrideFile)

		VSL_CHECK_VALIDVALUE_BSTR(bstrConfigFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_RemoteDebugEnabledValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbEnableRemoteLaunch;
		HRESULT retValue;
	};

	STDMETHOD(get_RemoteDebugEnabled)(
		/*[out,retval]*/ VARIANT_BOOL* pbEnableRemoteLaunch)
	{
		VSL_DEFINE_MOCK_METHOD(get_RemoteDebugEnabled)

		VSL_SET_VALIDVALUE(pbEnableRemoteLaunch);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_RemoteDebugEnabledValidValues
	{
		/*[in]*/ VARIANT_BOOL bEnableRemoteLaunch;
		HRESULT retValue;
	};

	STDMETHOD(put_RemoteDebugEnabled)(
		/*[in]*/ VARIANT_BOOL bEnableRemoteLaunch)
	{
		VSL_DEFINE_MOCK_METHOD(put_RemoteDebugEnabled)

		VSL_CHECK_VALIDVALUE(bEnableRemoteLaunch);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_RemoteDebugMachineValidValues
	{
		/*[out,retval]*/ BSTR* pbstrRemoteLaunchMach;
		HRESULT retValue;
	};

	STDMETHOD(get_RemoteDebugMachine)(
		/*[out,retval]*/ BSTR* pbstrRemoteLaunchMach)
	{
		VSL_DEFINE_MOCK_METHOD(get_RemoteDebugMachine)

		VSL_SET_VALIDVALUE_BSTR(pbstrRemoteLaunchMach);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_RemoteDebugMachineValidValues
	{
		/*[in]*/ BSTR bstrRemoteLaunchMach;
		HRESULT retValue;
	};

	STDMETHOD(put_RemoteDebugMachine)(
		/*[in]*/ BSTR bstrRemoteLaunchMach)
	{
		VSL_DEFINE_MOCK_METHOD(put_RemoteDebugMachine)

		VSL_CHECK_VALIDVALUE_BSTR(bstrRemoteLaunchMach);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // PROJECTCONFIGURATIONPROPERTIES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockProjectConfigurationProperties2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef PROJECTCONFIGURATIONPROPERTIES2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define PROJECTCONFIGURATIONPROPERTIES2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vslangproj2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ProjectConfigurationProperties2NotImpl :
	public ProjectConfigurationProperties2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ProjectConfigurationProperties2NotImpl)

public:

	typedef ProjectConfigurationProperties2 Interface;

	STDMETHOD(get_NoWarn)(
		/*[out,retval]*/ BSTR* /*pbstrWarnings*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_NoWarn)(
		/*[in]*/ BSTR /*bstrWarnings*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_NoStdLib)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbNoStdLib*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_NoStdLib)(
		/*[in]*/ VARIANT_BOOL /*bNoStdLib*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get___id)(
		/*[out,retval]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DebugSymbols)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbGenerate*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DebugSymbols)(
		/*[in]*/ VARIANT_BOOL /*bGenerate*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DefineDebug)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbDefineDebug*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DefineDebug)(
		/*[in]*/ VARIANT_BOOL /*bDefineDebug*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DefineTrace)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbDefineTrace*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DefineTrace)(
		/*[in]*/ VARIANT_BOOL /*bDefineTrace*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_OutputPath)(
		/*[out,retval]*/ BSTR* /*pbstrOutputPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_OutputPath)(
		/*[in]*/ BSTR /*bstrOutputPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_IntermediatePath)(
		/*[out,retval]*/ BSTR* /*pbstrIntermediatePath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_IntermediatePath)(
		/*[in]*/ BSTR /*bstrIntermediatePath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DefineConstants)(
		/*[out,retval]*/ BSTR* /*pbstrDefineConstants*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DefineConstants)(
		/*[in]*/ BSTR /*bstrDefineConstants*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_RemoveIntegerChecks)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbRemoveIntegerChecks*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_RemoveIntegerChecks)(
		/*[in]*/ VARIANT_BOOL /*bRemoveIntegerChecks*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_BaseAddress)(
		/*[out,retval]*/ DWORD* /*pdwBaseAddress*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_BaseAddress)(
		/*[in]*/ DWORD /*dwBaseAddress*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_AllowUnsafeBlocks)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbUnsafe*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_AllowUnsafeBlocks)(
		/*[in]*/ VARIANT_BOOL /*bUnsafe*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CheckForOverflowUnderflow)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbCheckForOverflowUnderflow*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_CheckForOverflowUnderflow)(
		/*[in]*/ VARIANT_BOOL /*bCheckForOverflowUnderflow*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DocumentationFile)(
		/*[out,retval]*/ BSTR* /*pbstrDocumentationFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DocumentationFile)(
		/*[in]*/ BSTR /*bstrDocumentationFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Optimize)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbOptimize*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_Optimize)(
		/*[in]*/ VARIANT_BOOL /*bCheckForOverflowUnderflow*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_IncrementalBuild)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbIncrementalBuild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_IncrementalBuild)(
		/*[in]*/ VARIANT_BOOL /*bIncrementalBuild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_StartProgram)(
		/*[out,retval]*/ BSTR* /*pbstrStartProgram*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_StartProgram)(
		/*[in]*/ BSTR /*bstrStartProgram*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_StartWorkingDirectory)(
		/*[out,retval]*/ BSTR* /*pbstrStartWorkingDirectory*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_StartWorkingDirectory)(
		/*[in]*/ BSTR /*bstrStartWorkingDirectory*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_StartURL)(
		/*[out,retval]*/ BSTR* /*pbstrStartURL*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_StartURL)(
		/*[in]*/ BSTR /*bstrStartURL*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_StartPage)(
		/*[out,retval]*/ BSTR* /*pbstrStartPage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_StartPage)(
		/*[in]*/ BSTR /*bstrStartPage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_StartArguments)(
		/*[out,retval]*/ BSTR* /*pbstrStartArguments*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_StartArguments)(
		/*[in]*/ BSTR /*bstrStartArguments*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_StartWithIE)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbStartWithIE*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_StartWithIE)(
		/*[in]*/ VARIANT_BOOL /*bStartWithIE*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_EnableASPDebugging)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbEnableASPDebugging*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_EnableASPDebugging)(
		/*[in]*/ VARIANT_BOOL /*bEnableASPDebugging*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_EnableASPXDebugging)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbEnableASPXDebugging*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_EnableASPXDebugging)(
		/*[in]*/ VARIANT_BOOL /*bEnableASPXDebugging*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_EnableUnmanagedDebugging)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbEnableUnmanagedDebugging*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_EnableUnmanagedDebugging)(
		/*[in]*/ VARIANT_BOOL /*bEnableUnmanagedDebugging*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_StartAction)(
		/*[out,retval]*/ prjStartAction* /*pdebugStartMode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_StartAction)(
		/*[in]*/ prjStartAction /*debugStartMode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Extender)(
		/*[in]*/ BSTR /*ExtenderName*/,
		/*[out,retval]*/ IDispatch** /*Extender*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ExtenderNames)(
		/*[out,retval]*/ VARIANT* /*ExtenderNames*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ExtenderCATID)(
		/*[out,retval]*/ BSTR* /*pRetval*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_WarningLevel)(
		/*[out,retval]*/ prjWarningLevel* /*pWarningLeve*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_WarningLevel)(
		/*[in]*/ prjWarningLevel /*warningLevel*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_TreatWarningsAsErrors)(
		/*[out,retval]*/ VARIANT_BOOL* /*pWarningAsError*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_TreatWarningsAsErrors)(
		/*[in]*/ VARIANT_BOOL /*warningAsError*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_EnableSQLServerDebugging)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbEnableSQLServerDebugging*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_EnableSQLServerDebugging)(
		/*[in]*/ VARIANT_BOOL /*bEnableSQLServerDebugging*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_FileAlignment)(
		/*[out,retval]*/ DWORD* /*pdwFileAlignment*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_FileAlignment)(
		/*[in]*/ DWORD /*dwFileAlignment*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_RegisterForComInterop)(
		/*[out,retval]*/ VARIANT_BOOL* /*pVal*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_RegisterForComInterop)(
		/*[in]*/ VARIANT_BOOL /*val*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ConfigurationOverrideFile)(
		/*[out,retval]*/ BSTR* /*pbstrConfigFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_ConfigurationOverrideFile)(
		/*[in]*/ BSTR /*bstrConfigFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_RemoteDebugEnabled)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbEnableRemoteLaunch*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_RemoteDebugEnabled)(
		/*[in]*/ VARIANT_BOOL /*bEnableRemoteLaunch*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_RemoteDebugMachine)(
		/*[out,retval]*/ BSTR* /*pbstrRemoteLaunchMach*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_RemoteDebugMachine)(
		/*[in]*/ BSTR /*bstrRemoteLaunchMach*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class ProjectConfigurationProperties2MockImpl :
	public ProjectConfigurationProperties2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ProjectConfigurationProperties2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ProjectConfigurationProperties2MockImpl)

	typedef ProjectConfigurationProperties2 Interface;
	struct get_NoWarnValidValues
	{
		/*[out,retval]*/ BSTR* pbstrWarnings;
		HRESULT retValue;
	};

	STDMETHOD(get_NoWarn)(
		/*[out,retval]*/ BSTR* pbstrWarnings)
	{
		VSL_DEFINE_MOCK_METHOD(get_NoWarn)

		VSL_SET_VALIDVALUE_BSTR(pbstrWarnings);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_NoWarnValidValues
	{
		/*[in]*/ BSTR bstrWarnings;
		HRESULT retValue;
	};

	STDMETHOD(put_NoWarn)(
		/*[in]*/ BSTR bstrWarnings)
	{
		VSL_DEFINE_MOCK_METHOD(put_NoWarn)

		VSL_CHECK_VALIDVALUE_BSTR(bstrWarnings);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_NoStdLibValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbNoStdLib;
		HRESULT retValue;
	};

	STDMETHOD(get_NoStdLib)(
		/*[out,retval]*/ VARIANT_BOOL* pbNoStdLib)
	{
		VSL_DEFINE_MOCK_METHOD(get_NoStdLib)

		VSL_SET_VALIDVALUE(pbNoStdLib);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_NoStdLibValidValues
	{
		/*[in]*/ VARIANT_BOOL bNoStdLib;
		HRESULT retValue;
	};

	STDMETHOD(put_NoStdLib)(
		/*[in]*/ VARIANT_BOOL bNoStdLib)
	{
		VSL_DEFINE_MOCK_METHOD(put_NoStdLib)

		VSL_CHECK_VALIDVALUE(bNoStdLib);

		VSL_RETURN_VALIDVALUES();
	}
	struct get___idValidValues
	{
		/*[out,retval]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(get___id)(
		/*[out,retval]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(get___id)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DebugSymbolsValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbGenerate;
		HRESULT retValue;
	};

	STDMETHOD(get_DebugSymbols)(
		/*[out,retval]*/ VARIANT_BOOL* pbGenerate)
	{
		VSL_DEFINE_MOCK_METHOD(get_DebugSymbols)

		VSL_SET_VALIDVALUE(pbGenerate);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DebugSymbolsValidValues
	{
		/*[in]*/ VARIANT_BOOL bGenerate;
		HRESULT retValue;
	};

	STDMETHOD(put_DebugSymbols)(
		/*[in]*/ VARIANT_BOOL bGenerate)
	{
		VSL_DEFINE_MOCK_METHOD(put_DebugSymbols)

		VSL_CHECK_VALIDVALUE(bGenerate);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DefineDebugValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbDefineDebug;
		HRESULT retValue;
	};

	STDMETHOD(get_DefineDebug)(
		/*[out,retval]*/ VARIANT_BOOL* pbDefineDebug)
	{
		VSL_DEFINE_MOCK_METHOD(get_DefineDebug)

		VSL_SET_VALIDVALUE(pbDefineDebug);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DefineDebugValidValues
	{
		/*[in]*/ VARIANT_BOOL bDefineDebug;
		HRESULT retValue;
	};

	STDMETHOD(put_DefineDebug)(
		/*[in]*/ VARIANT_BOOL bDefineDebug)
	{
		VSL_DEFINE_MOCK_METHOD(put_DefineDebug)

		VSL_CHECK_VALIDVALUE(bDefineDebug);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DefineTraceValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbDefineTrace;
		HRESULT retValue;
	};

	STDMETHOD(get_DefineTrace)(
		/*[out,retval]*/ VARIANT_BOOL* pbDefineTrace)
	{
		VSL_DEFINE_MOCK_METHOD(get_DefineTrace)

		VSL_SET_VALIDVALUE(pbDefineTrace);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DefineTraceValidValues
	{
		/*[in]*/ VARIANT_BOOL bDefineTrace;
		HRESULT retValue;
	};

	STDMETHOD(put_DefineTrace)(
		/*[in]*/ VARIANT_BOOL bDefineTrace)
	{
		VSL_DEFINE_MOCK_METHOD(put_DefineTrace)

		VSL_CHECK_VALIDVALUE(bDefineTrace);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_OutputPathValidValues
	{
		/*[out,retval]*/ BSTR* pbstrOutputPath;
		HRESULT retValue;
	};

	STDMETHOD(get_OutputPath)(
		/*[out,retval]*/ BSTR* pbstrOutputPath)
	{
		VSL_DEFINE_MOCK_METHOD(get_OutputPath)

		VSL_SET_VALIDVALUE_BSTR(pbstrOutputPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_OutputPathValidValues
	{
		/*[in]*/ BSTR bstrOutputPath;
		HRESULT retValue;
	};

	STDMETHOD(put_OutputPath)(
		/*[in]*/ BSTR bstrOutputPath)
	{
		VSL_DEFINE_MOCK_METHOD(put_OutputPath)

		VSL_CHECK_VALIDVALUE_BSTR(bstrOutputPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IntermediatePathValidValues
	{
		/*[out,retval]*/ BSTR* pbstrIntermediatePath;
		HRESULT retValue;
	};

	STDMETHOD(get_IntermediatePath)(
		/*[out,retval]*/ BSTR* pbstrIntermediatePath)
	{
		VSL_DEFINE_MOCK_METHOD(get_IntermediatePath)

		VSL_SET_VALIDVALUE_BSTR(pbstrIntermediatePath);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_IntermediatePathValidValues
	{
		/*[in]*/ BSTR bstrIntermediatePath;
		HRESULT retValue;
	};

	STDMETHOD(put_IntermediatePath)(
		/*[in]*/ BSTR bstrIntermediatePath)
	{
		VSL_DEFINE_MOCK_METHOD(put_IntermediatePath)

		VSL_CHECK_VALIDVALUE_BSTR(bstrIntermediatePath);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DefineConstantsValidValues
	{
		/*[out,retval]*/ BSTR* pbstrDefineConstants;
		HRESULT retValue;
	};

	STDMETHOD(get_DefineConstants)(
		/*[out,retval]*/ BSTR* pbstrDefineConstants)
	{
		VSL_DEFINE_MOCK_METHOD(get_DefineConstants)

		VSL_SET_VALIDVALUE_BSTR(pbstrDefineConstants);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DefineConstantsValidValues
	{
		/*[in]*/ BSTR bstrDefineConstants;
		HRESULT retValue;
	};

	STDMETHOD(put_DefineConstants)(
		/*[in]*/ BSTR bstrDefineConstants)
	{
		VSL_DEFINE_MOCK_METHOD(put_DefineConstants)

		VSL_CHECK_VALIDVALUE_BSTR(bstrDefineConstants);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_RemoveIntegerChecksValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbRemoveIntegerChecks;
		HRESULT retValue;
	};

	STDMETHOD(get_RemoveIntegerChecks)(
		/*[out,retval]*/ VARIANT_BOOL* pbRemoveIntegerChecks)
	{
		VSL_DEFINE_MOCK_METHOD(get_RemoveIntegerChecks)

		VSL_SET_VALIDVALUE(pbRemoveIntegerChecks);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_RemoveIntegerChecksValidValues
	{
		/*[in]*/ VARIANT_BOOL bRemoveIntegerChecks;
		HRESULT retValue;
	};

	STDMETHOD(put_RemoveIntegerChecks)(
		/*[in]*/ VARIANT_BOOL bRemoveIntegerChecks)
	{
		VSL_DEFINE_MOCK_METHOD(put_RemoveIntegerChecks)

		VSL_CHECK_VALIDVALUE(bRemoveIntegerChecks);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_BaseAddressValidValues
	{
		/*[out,retval]*/ DWORD* pdwBaseAddress;
		HRESULT retValue;
	};

	STDMETHOD(get_BaseAddress)(
		/*[out,retval]*/ DWORD* pdwBaseAddress)
	{
		VSL_DEFINE_MOCK_METHOD(get_BaseAddress)

		VSL_SET_VALIDVALUE(pdwBaseAddress);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_BaseAddressValidValues
	{
		/*[in]*/ DWORD dwBaseAddress;
		HRESULT retValue;
	};

	STDMETHOD(put_BaseAddress)(
		/*[in]*/ DWORD dwBaseAddress)
	{
		VSL_DEFINE_MOCK_METHOD(put_BaseAddress)

		VSL_CHECK_VALIDVALUE(dwBaseAddress);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_AllowUnsafeBlocksValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbUnsafe;
		HRESULT retValue;
	};

	STDMETHOD(get_AllowUnsafeBlocks)(
		/*[out,retval]*/ VARIANT_BOOL* pbUnsafe)
	{
		VSL_DEFINE_MOCK_METHOD(get_AllowUnsafeBlocks)

		VSL_SET_VALIDVALUE(pbUnsafe);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_AllowUnsafeBlocksValidValues
	{
		/*[in]*/ VARIANT_BOOL bUnsafe;
		HRESULT retValue;
	};

	STDMETHOD(put_AllowUnsafeBlocks)(
		/*[in]*/ VARIANT_BOOL bUnsafe)
	{
		VSL_DEFINE_MOCK_METHOD(put_AllowUnsafeBlocks)

		VSL_CHECK_VALIDVALUE(bUnsafe);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CheckForOverflowUnderflowValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbCheckForOverflowUnderflow;
		HRESULT retValue;
	};

	STDMETHOD(get_CheckForOverflowUnderflow)(
		/*[out,retval]*/ VARIANT_BOOL* pbCheckForOverflowUnderflow)
	{
		VSL_DEFINE_MOCK_METHOD(get_CheckForOverflowUnderflow)

		VSL_SET_VALIDVALUE(pbCheckForOverflowUnderflow);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_CheckForOverflowUnderflowValidValues
	{
		/*[in]*/ VARIANT_BOOL bCheckForOverflowUnderflow;
		HRESULT retValue;
	};

	STDMETHOD(put_CheckForOverflowUnderflow)(
		/*[in]*/ VARIANT_BOOL bCheckForOverflowUnderflow)
	{
		VSL_DEFINE_MOCK_METHOD(put_CheckForOverflowUnderflow)

		VSL_CHECK_VALIDVALUE(bCheckForOverflowUnderflow);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DocumentationFileValidValues
	{
		/*[out,retval]*/ BSTR* pbstrDocumentationFile;
		HRESULT retValue;
	};

	STDMETHOD(get_DocumentationFile)(
		/*[out,retval]*/ BSTR* pbstrDocumentationFile)
	{
		VSL_DEFINE_MOCK_METHOD(get_DocumentationFile)

		VSL_SET_VALIDVALUE_BSTR(pbstrDocumentationFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DocumentationFileValidValues
	{
		/*[in]*/ BSTR bstrDocumentationFile;
		HRESULT retValue;
	};

	STDMETHOD(put_DocumentationFile)(
		/*[in]*/ BSTR bstrDocumentationFile)
	{
		VSL_DEFINE_MOCK_METHOD(put_DocumentationFile)

		VSL_CHECK_VALIDVALUE_BSTR(bstrDocumentationFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_OptimizeValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbOptimize;
		HRESULT retValue;
	};

	STDMETHOD(get_Optimize)(
		/*[out,retval]*/ VARIANT_BOOL* pbOptimize)
	{
		VSL_DEFINE_MOCK_METHOD(get_Optimize)

		VSL_SET_VALIDVALUE(pbOptimize);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_OptimizeValidValues
	{
		/*[in]*/ VARIANT_BOOL bCheckForOverflowUnderflow;
		HRESULT retValue;
	};

	STDMETHOD(put_Optimize)(
		/*[in]*/ VARIANT_BOOL bCheckForOverflowUnderflow)
	{
		VSL_DEFINE_MOCK_METHOD(put_Optimize)

		VSL_CHECK_VALIDVALUE(bCheckForOverflowUnderflow);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IncrementalBuildValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbIncrementalBuild;
		HRESULT retValue;
	};

	STDMETHOD(get_IncrementalBuild)(
		/*[out,retval]*/ VARIANT_BOOL* pbIncrementalBuild)
	{
		VSL_DEFINE_MOCK_METHOD(get_IncrementalBuild)

		VSL_SET_VALIDVALUE(pbIncrementalBuild);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_IncrementalBuildValidValues
	{
		/*[in]*/ VARIANT_BOOL bIncrementalBuild;
		HRESULT retValue;
	};

	STDMETHOD(put_IncrementalBuild)(
		/*[in]*/ VARIANT_BOOL bIncrementalBuild)
	{
		VSL_DEFINE_MOCK_METHOD(put_IncrementalBuild)

		VSL_CHECK_VALIDVALUE(bIncrementalBuild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_StartProgramValidValues
	{
		/*[out,retval]*/ BSTR* pbstrStartProgram;
		HRESULT retValue;
	};

	STDMETHOD(get_StartProgram)(
		/*[out,retval]*/ BSTR* pbstrStartProgram)
	{
		VSL_DEFINE_MOCK_METHOD(get_StartProgram)

		VSL_SET_VALIDVALUE_BSTR(pbstrStartProgram);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_StartProgramValidValues
	{
		/*[in]*/ BSTR bstrStartProgram;
		HRESULT retValue;
	};

	STDMETHOD(put_StartProgram)(
		/*[in]*/ BSTR bstrStartProgram)
	{
		VSL_DEFINE_MOCK_METHOD(put_StartProgram)

		VSL_CHECK_VALIDVALUE_BSTR(bstrStartProgram);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_StartWorkingDirectoryValidValues
	{
		/*[out,retval]*/ BSTR* pbstrStartWorkingDirectory;
		HRESULT retValue;
	};

	STDMETHOD(get_StartWorkingDirectory)(
		/*[out,retval]*/ BSTR* pbstrStartWorkingDirectory)
	{
		VSL_DEFINE_MOCK_METHOD(get_StartWorkingDirectory)

		VSL_SET_VALIDVALUE_BSTR(pbstrStartWorkingDirectory);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_StartWorkingDirectoryValidValues
	{
		/*[in]*/ BSTR bstrStartWorkingDirectory;
		HRESULT retValue;
	};

	STDMETHOD(put_StartWorkingDirectory)(
		/*[in]*/ BSTR bstrStartWorkingDirectory)
	{
		VSL_DEFINE_MOCK_METHOD(put_StartWorkingDirectory)

		VSL_CHECK_VALIDVALUE_BSTR(bstrStartWorkingDirectory);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_StartURLValidValues
	{
		/*[out,retval]*/ BSTR* pbstrStartURL;
		HRESULT retValue;
	};

	STDMETHOD(get_StartURL)(
		/*[out,retval]*/ BSTR* pbstrStartURL)
	{
		VSL_DEFINE_MOCK_METHOD(get_StartURL)

		VSL_SET_VALIDVALUE_BSTR(pbstrStartURL);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_StartURLValidValues
	{
		/*[in]*/ BSTR bstrStartURL;
		HRESULT retValue;
	};

	STDMETHOD(put_StartURL)(
		/*[in]*/ BSTR bstrStartURL)
	{
		VSL_DEFINE_MOCK_METHOD(put_StartURL)

		VSL_CHECK_VALIDVALUE_BSTR(bstrStartURL);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_StartPageValidValues
	{
		/*[out,retval]*/ BSTR* pbstrStartPage;
		HRESULT retValue;
	};

	STDMETHOD(get_StartPage)(
		/*[out,retval]*/ BSTR* pbstrStartPage)
	{
		VSL_DEFINE_MOCK_METHOD(get_StartPage)

		VSL_SET_VALIDVALUE_BSTR(pbstrStartPage);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_StartPageValidValues
	{
		/*[in]*/ BSTR bstrStartPage;
		HRESULT retValue;
	};

	STDMETHOD(put_StartPage)(
		/*[in]*/ BSTR bstrStartPage)
	{
		VSL_DEFINE_MOCK_METHOD(put_StartPage)

		VSL_CHECK_VALIDVALUE_BSTR(bstrStartPage);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_StartArgumentsValidValues
	{
		/*[out,retval]*/ BSTR* pbstrStartArguments;
		HRESULT retValue;
	};

	STDMETHOD(get_StartArguments)(
		/*[out,retval]*/ BSTR* pbstrStartArguments)
	{
		VSL_DEFINE_MOCK_METHOD(get_StartArguments)

		VSL_SET_VALIDVALUE_BSTR(pbstrStartArguments);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_StartArgumentsValidValues
	{
		/*[in]*/ BSTR bstrStartArguments;
		HRESULT retValue;
	};

	STDMETHOD(put_StartArguments)(
		/*[in]*/ BSTR bstrStartArguments)
	{
		VSL_DEFINE_MOCK_METHOD(put_StartArguments)

		VSL_CHECK_VALIDVALUE_BSTR(bstrStartArguments);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_StartWithIEValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbStartWithIE;
		HRESULT retValue;
	};

	STDMETHOD(get_StartWithIE)(
		/*[out,retval]*/ VARIANT_BOOL* pbStartWithIE)
	{
		VSL_DEFINE_MOCK_METHOD(get_StartWithIE)

		VSL_SET_VALIDVALUE(pbStartWithIE);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_StartWithIEValidValues
	{
		/*[in]*/ VARIANT_BOOL bStartWithIE;
		HRESULT retValue;
	};

	STDMETHOD(put_StartWithIE)(
		/*[in]*/ VARIANT_BOOL bStartWithIE)
	{
		VSL_DEFINE_MOCK_METHOD(put_StartWithIE)

		VSL_CHECK_VALIDVALUE(bStartWithIE);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_EnableASPDebuggingValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbEnableASPDebugging;
		HRESULT retValue;
	};

	STDMETHOD(get_EnableASPDebugging)(
		/*[out,retval]*/ VARIANT_BOOL* pbEnableASPDebugging)
	{
		VSL_DEFINE_MOCK_METHOD(get_EnableASPDebugging)

		VSL_SET_VALIDVALUE(pbEnableASPDebugging);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_EnableASPDebuggingValidValues
	{
		/*[in]*/ VARIANT_BOOL bEnableASPDebugging;
		HRESULT retValue;
	};

	STDMETHOD(put_EnableASPDebugging)(
		/*[in]*/ VARIANT_BOOL bEnableASPDebugging)
	{
		VSL_DEFINE_MOCK_METHOD(put_EnableASPDebugging)

		VSL_CHECK_VALIDVALUE(bEnableASPDebugging);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_EnableASPXDebuggingValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbEnableASPXDebugging;
		HRESULT retValue;
	};

	STDMETHOD(get_EnableASPXDebugging)(
		/*[out,retval]*/ VARIANT_BOOL* pbEnableASPXDebugging)
	{
		VSL_DEFINE_MOCK_METHOD(get_EnableASPXDebugging)

		VSL_SET_VALIDVALUE(pbEnableASPXDebugging);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_EnableASPXDebuggingValidValues
	{
		/*[in]*/ VARIANT_BOOL bEnableASPXDebugging;
		HRESULT retValue;
	};

	STDMETHOD(put_EnableASPXDebugging)(
		/*[in]*/ VARIANT_BOOL bEnableASPXDebugging)
	{
		VSL_DEFINE_MOCK_METHOD(put_EnableASPXDebugging)

		VSL_CHECK_VALIDVALUE(bEnableASPXDebugging);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_EnableUnmanagedDebuggingValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbEnableUnmanagedDebugging;
		HRESULT retValue;
	};

	STDMETHOD(get_EnableUnmanagedDebugging)(
		/*[out,retval]*/ VARIANT_BOOL* pbEnableUnmanagedDebugging)
	{
		VSL_DEFINE_MOCK_METHOD(get_EnableUnmanagedDebugging)

		VSL_SET_VALIDVALUE(pbEnableUnmanagedDebugging);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_EnableUnmanagedDebuggingValidValues
	{
		/*[in]*/ VARIANT_BOOL bEnableUnmanagedDebugging;
		HRESULT retValue;
	};

	STDMETHOD(put_EnableUnmanagedDebugging)(
		/*[in]*/ VARIANT_BOOL bEnableUnmanagedDebugging)
	{
		VSL_DEFINE_MOCK_METHOD(put_EnableUnmanagedDebugging)

		VSL_CHECK_VALIDVALUE(bEnableUnmanagedDebugging);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_StartActionValidValues
	{
		/*[out,retval]*/ prjStartAction* pdebugStartMode;
		HRESULT retValue;
	};

	STDMETHOD(get_StartAction)(
		/*[out,retval]*/ prjStartAction* pdebugStartMode)
	{
		VSL_DEFINE_MOCK_METHOD(get_StartAction)

		VSL_SET_VALIDVALUE(pdebugStartMode);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_StartActionValidValues
	{
		/*[in]*/ prjStartAction debugStartMode;
		HRESULT retValue;
	};

	STDMETHOD(put_StartAction)(
		/*[in]*/ prjStartAction debugStartMode)
	{
		VSL_DEFINE_MOCK_METHOD(put_StartAction)

		VSL_CHECK_VALIDVALUE(debugStartMode);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderValidValues
	{
		/*[in]*/ BSTR ExtenderName;
		/*[out,retval]*/ IDispatch** Extender;
		HRESULT retValue;
	};

	STDMETHOD(get_Extender)(
		/*[in]*/ BSTR ExtenderName,
		/*[out,retval]*/ IDispatch** Extender)
	{
		VSL_DEFINE_MOCK_METHOD(get_Extender)

		VSL_CHECK_VALIDVALUE_BSTR(ExtenderName);

		VSL_SET_VALIDVALUE_INTERFACE(Extender);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderNamesValidValues
	{
		/*[out,retval]*/ VARIANT* ExtenderNames;
		HRESULT retValue;
	};

	STDMETHOD(get_ExtenderNames)(
		/*[out,retval]*/ VARIANT* ExtenderNames)
	{
		VSL_DEFINE_MOCK_METHOD(get_ExtenderNames)

		VSL_SET_VALIDVALUE_VARIANT(ExtenderNames);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderCATIDValidValues
	{
		/*[out,retval]*/ BSTR* pRetval;
		HRESULT retValue;
	};

	STDMETHOD(get_ExtenderCATID)(
		/*[out,retval]*/ BSTR* pRetval)
	{
		VSL_DEFINE_MOCK_METHOD(get_ExtenderCATID)

		VSL_SET_VALIDVALUE_BSTR(pRetval);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_WarningLevelValidValues
	{
		/*[out,retval]*/ prjWarningLevel* pWarningLeve;
		HRESULT retValue;
	};

	STDMETHOD(get_WarningLevel)(
		/*[out,retval]*/ prjWarningLevel* pWarningLeve)
	{
		VSL_DEFINE_MOCK_METHOD(get_WarningLevel)

		VSL_SET_VALIDVALUE(pWarningLeve);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_WarningLevelValidValues
	{
		/*[in]*/ prjWarningLevel warningLevel;
		HRESULT retValue;
	};

	STDMETHOD(put_WarningLevel)(
		/*[in]*/ prjWarningLevel warningLevel)
	{
		VSL_DEFINE_MOCK_METHOD(put_WarningLevel)

		VSL_CHECK_VALIDVALUE(warningLevel);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_TreatWarningsAsErrorsValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pWarningAsError;
		HRESULT retValue;
	};

	STDMETHOD(get_TreatWarningsAsErrors)(
		/*[out,retval]*/ VARIANT_BOOL* pWarningAsError)
	{
		VSL_DEFINE_MOCK_METHOD(get_TreatWarningsAsErrors)

		VSL_SET_VALIDVALUE(pWarningAsError);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_TreatWarningsAsErrorsValidValues
	{
		/*[in]*/ VARIANT_BOOL warningAsError;
		HRESULT retValue;
	};

	STDMETHOD(put_TreatWarningsAsErrors)(
		/*[in]*/ VARIANT_BOOL warningAsError)
	{
		VSL_DEFINE_MOCK_METHOD(put_TreatWarningsAsErrors)

		VSL_CHECK_VALIDVALUE(warningAsError);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_EnableSQLServerDebuggingValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbEnableSQLServerDebugging;
		HRESULT retValue;
	};

	STDMETHOD(get_EnableSQLServerDebugging)(
		/*[out,retval]*/ VARIANT_BOOL* pbEnableSQLServerDebugging)
	{
		VSL_DEFINE_MOCK_METHOD(get_EnableSQLServerDebugging)

		VSL_SET_VALIDVALUE(pbEnableSQLServerDebugging);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_EnableSQLServerDebuggingValidValues
	{
		/*[in]*/ VARIANT_BOOL bEnableSQLServerDebugging;
		HRESULT retValue;
	};

	STDMETHOD(put_EnableSQLServerDebugging)(
		/*[in]*/ VARIANT_BOOL bEnableSQLServerDebugging)
	{
		VSL_DEFINE_MOCK_METHOD(put_EnableSQLServerDebugging)

		VSL_CHECK_VALIDVALUE(bEnableSQLServerDebugging);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_FileAlignmentValidValues
	{
		/*[out,retval]*/ DWORD* pdwFileAlignment;
		HRESULT retValue;
	};

	STDMETHOD(get_FileAlignment)(
		/*[out,retval]*/ DWORD* pdwFileAlignment)
	{
		VSL_DEFINE_MOCK_METHOD(get_FileAlignment)

		VSL_SET_VALIDVALUE(pdwFileAlignment);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_FileAlignmentValidValues
	{
		/*[in]*/ DWORD dwFileAlignment;
		HRESULT retValue;
	};

	STDMETHOD(put_FileAlignment)(
		/*[in]*/ DWORD dwFileAlignment)
	{
		VSL_DEFINE_MOCK_METHOD(put_FileAlignment)

		VSL_CHECK_VALIDVALUE(dwFileAlignment);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_RegisterForComInteropValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pVal;
		HRESULT retValue;
	};

	STDMETHOD(get_RegisterForComInterop)(
		/*[out,retval]*/ VARIANT_BOOL* pVal)
	{
		VSL_DEFINE_MOCK_METHOD(get_RegisterForComInterop)

		VSL_SET_VALIDVALUE(pVal);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_RegisterForComInteropValidValues
	{
		/*[in]*/ VARIANT_BOOL val;
		HRESULT retValue;
	};

	STDMETHOD(put_RegisterForComInterop)(
		/*[in]*/ VARIANT_BOOL val)
	{
		VSL_DEFINE_MOCK_METHOD(put_RegisterForComInterop)

		VSL_CHECK_VALIDVALUE(val);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ConfigurationOverrideFileValidValues
	{
		/*[out,retval]*/ BSTR* pbstrConfigFile;
		HRESULT retValue;
	};

	STDMETHOD(get_ConfigurationOverrideFile)(
		/*[out,retval]*/ BSTR* pbstrConfigFile)
	{
		VSL_DEFINE_MOCK_METHOD(get_ConfigurationOverrideFile)

		VSL_SET_VALIDVALUE_BSTR(pbstrConfigFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_ConfigurationOverrideFileValidValues
	{
		/*[in]*/ BSTR bstrConfigFile;
		HRESULT retValue;
	};

	STDMETHOD(put_ConfigurationOverrideFile)(
		/*[in]*/ BSTR bstrConfigFile)
	{
		VSL_DEFINE_MOCK_METHOD(put_ConfigurationOverrideFile)

		VSL_CHECK_VALIDVALUE_BSTR(bstrConfigFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_RemoteDebugEnabledValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbEnableRemoteLaunch;
		HRESULT retValue;
	};

	STDMETHOD(get_RemoteDebugEnabled)(
		/*[out,retval]*/ VARIANT_BOOL* pbEnableRemoteLaunch)
	{
		VSL_DEFINE_MOCK_METHOD(get_RemoteDebugEnabled)

		VSL_SET_VALIDVALUE(pbEnableRemoteLaunch);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_RemoteDebugEnabledValidValues
	{
		/*[in]*/ VARIANT_BOOL bEnableRemoteLaunch;
		HRESULT retValue;
	};

	STDMETHOD(put_RemoteDebugEnabled)(
		/*[in]*/ VARIANT_BOOL bEnableRemoteLaunch)
	{
		VSL_DEFINE_MOCK_METHOD(put_RemoteDebugEnabled)

		VSL_CHECK_VALIDVALUE(bEnableRemoteLaunch);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_RemoteDebugMachineValidValues
	{
		/*[out,retval]*/ BSTR* pbstrRemoteLaunchMach;
		HRESULT retValue;
	};

	STDMETHOD(get_RemoteDebugMachine)(
		/*[out,retval]*/ BSTR* pbstrRemoteLaunchMach)
	{
		VSL_DEFINE_MOCK_METHOD(get_RemoteDebugMachine)

		VSL_SET_VALIDVALUE_BSTR(pbstrRemoteLaunchMach);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_RemoteDebugMachineValidValues
	{
		/*[in]*/ BSTR bstrRemoteLaunchMach;
		HRESULT retValue;
	};

	STDMETHOD(put_RemoteDebugMachine)(
		/*[in]*/ BSTR bstrRemoteLaunchMach)
	{
		VSL_DEFINE_MOCK_METHOD(put_RemoteDebugMachine)

		VSL_CHECK_VALIDVALUE_BSTR(bstrRemoteLaunchMach);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // PROJECTCONFIGURATIONPROPERTIES2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockProjectConfigurationProperties3.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef PROJECTCONFIGURATIONPROPERTIES3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define PROJECTCONFIGURATIONPROPERTIES3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vslangproj80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ProjectConfigurationProperties3NotImpl :
	public ProjectConfigurationProperties3
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ProjectConfigurationProperties3NotImpl)

public:

	typedef ProjectConfigurationProperties3 Interface;

	STDMETHOD(get_DebugInfo)(
		/*[out,retval]*/ BSTR* /*pbstrDebugInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DebugInfo)(
		/*[in]*/ BSTR /*DebugInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_PlatformTarget)(
		/*[out,retval]*/ BSTR* /*pbstrPlatformTarget*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_PlatformTarget)(
		/*[in]*/ BSTR /*PlatformTarget*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_TreatSpecificWarningsAsErrors)(
		/*[out,retval]*/ BSTR* /*pbstrWarningsAsErrors*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_TreatSpecificWarningsAsErrors)(
		/*[in]*/ BSTR /*WarningsAsErrors*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_RunCodeAnalysis)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbRunCodeAnalysis*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_RunCodeAnalysis)(
		/*[in]*/ VARIANT_BOOL /*RunCodeAnalysis*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CodeAnalysisLogFile)(
		/*[out,retval]*/ BSTR* /*pbstrCodeAnalysisLogFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_CodeAnalysisLogFile)(
		/*[in]*/ BSTR /*CodeAnalysisLogFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CodeAnalysisRuleAssemblies)(
		/*[out,retval]*/ BSTR* /*pbstrCodeAnalysisRuleAssemblies*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_CodeAnalysisRuleAssemblies)(
		/*[in]*/ BSTR /*CodeAnalysisRuleAssemblies*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CodeAnalysisInputAssembly)(
		/*[out,retval]*/ BSTR* /*pbstrCodeAnalysisInputAssembly*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_CodeAnalysisInputAssembly)(
		/*[in]*/ BSTR /*CodeAnalysisInputAssembly*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CodeAnalysisRules)(
		/*[out,retval]*/ BSTR* /*pbstrCodeAnalysisRules*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_CodeAnalysisRules)(
		/*[in]*/ BSTR /*CodeAnalysisRules*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CodeAnalysisSpellCheckLanguages)(
		/*[out,retval]*/ BSTR* /*pbstrCodeAnalysisSpellCheckLanguages*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_CodeAnalysisSpellCheckLanguages)(
		/*[in]*/ BSTR /*CodeAnalysisSpellCheckLanguages*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CodeAnalysisUseTypeNameInSuppression)(
		/*[out,retval]*/ VARIANT_BOOL* /*bUseTypeNameInSuppression*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_CodeAnalysisUseTypeNameInSuppression)(
		/*[in]*/ VARIANT_BOOL /*UseTypeNameInSuppression*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CodeAnalysisModuleSuppressionsFile)(
		/*[out,retval]*/ BSTR* /*pbstrCodeAnalysisModuleSuppressionsFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_CodeAnalysisModuleSuppressionsFile)(
		/*[in]*/ BSTR /*CodeAnalysisModuleSuppressionsFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_UseVSHostingProcess)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbUseVSHostingProcess*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_UseVSHostingProcess)(
		/*[in]*/ VARIANT_BOOL /*UseVSHostingProcess*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_GenerateSerializationAssemblies)(
		/*[out,retval]*/ sgenGenerationOption* /*pSgenGenerationOption*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_GenerateSerializationAssemblies)(
		/*[in]*/ sgenGenerationOption /*SgenGenerationOption*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_NoWarn)(
		/*[out,retval]*/ BSTR* /*pbstrWarnings*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_NoWarn)(
		/*[in]*/ BSTR /*bstrWarnings*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_NoStdLib)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbNoStdLib*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_NoStdLib)(
		/*[in]*/ VARIANT_BOOL /*bNoStdLib*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get___id)(
		/*[out,retval]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DebugSymbols)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbGenerate*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DebugSymbols)(
		/*[in]*/ VARIANT_BOOL /*bGenerate*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DefineDebug)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbDefineDebug*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DefineDebug)(
		/*[in]*/ VARIANT_BOOL /*bDefineDebug*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DefineTrace)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbDefineTrace*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DefineTrace)(
		/*[in]*/ VARIANT_BOOL /*bDefineTrace*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_OutputPath)(
		/*[out,retval]*/ BSTR* /*pbstrOutputPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_OutputPath)(
		/*[in]*/ BSTR /*bstrOutputPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_IntermediatePath)(
		/*[out,retval]*/ BSTR* /*pbstrIntermediatePath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_IntermediatePath)(
		/*[in]*/ BSTR /*bstrIntermediatePath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DefineConstants)(
		/*[out,retval]*/ BSTR* /*pbstrDefineConstants*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DefineConstants)(
		/*[in]*/ BSTR /*bstrDefineConstants*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_RemoveIntegerChecks)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbRemoveIntegerChecks*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_RemoveIntegerChecks)(
		/*[in]*/ VARIANT_BOOL /*bRemoveIntegerChecks*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_BaseAddress)(
		/*[out,retval]*/ DWORD* /*pdwBaseAddress*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_BaseAddress)(
		/*[in]*/ DWORD /*dwBaseAddress*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_AllowUnsafeBlocks)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbUnsafe*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_AllowUnsafeBlocks)(
		/*[in]*/ VARIANT_BOOL /*bUnsafe*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CheckForOverflowUnderflow)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbCheckForOverflowUnderflow*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_CheckForOverflowUnderflow)(
		/*[in]*/ VARIANT_BOOL /*bCheckForOverflowUnderflow*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DocumentationFile)(
		/*[out,retval]*/ BSTR* /*pbstrDocumentationFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DocumentationFile)(
		/*[in]*/ BSTR /*bstrDocumentationFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Optimize)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbOptimize*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_Optimize)(
		/*[in]*/ VARIANT_BOOL /*bCheckForOverflowUnderflow*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_IncrementalBuild)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbIncrementalBuild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_IncrementalBuild)(
		/*[in]*/ VARIANT_BOOL /*bIncrementalBuild*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_StartProgram)(
		/*[out,retval]*/ BSTR* /*pbstrStartProgram*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_StartProgram)(
		/*[in]*/ BSTR /*bstrStartProgram*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_StartWorkingDirectory)(
		/*[out,retval]*/ BSTR* /*pbstrStartWorkingDirectory*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_StartWorkingDirectory)(
		/*[in]*/ BSTR /*bstrStartWorkingDirectory*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_StartURL)(
		/*[out,retval]*/ BSTR* /*pbstrStartURL*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_StartURL)(
		/*[in]*/ BSTR /*bstrStartURL*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_StartPage)(
		/*[out,retval]*/ BSTR* /*pbstrStartPage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_StartPage)(
		/*[in]*/ BSTR /*bstrStartPage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_StartArguments)(
		/*[out,retval]*/ BSTR* /*pbstrStartArguments*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_StartArguments)(
		/*[in]*/ BSTR /*bstrStartArguments*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_StartWithIE)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbStartWithIE*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_StartWithIE)(
		/*[in]*/ VARIANT_BOOL /*bStartWithIE*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_EnableASPDebugging)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbEnableASPDebugging*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_EnableASPDebugging)(
		/*[in]*/ VARIANT_BOOL /*bEnableASPDebugging*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_EnableASPXDebugging)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbEnableASPXDebugging*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_EnableASPXDebugging)(
		/*[in]*/ VARIANT_BOOL /*bEnableASPXDebugging*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_EnableUnmanagedDebugging)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbEnableUnmanagedDebugging*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_EnableUnmanagedDebugging)(
		/*[in]*/ VARIANT_BOOL /*bEnableUnmanagedDebugging*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_StartAction)(
		/*[out,retval]*/ prjStartAction* /*pdebugStartMode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_StartAction)(
		/*[in]*/ prjStartAction /*debugStartMode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Extender)(
		/*[in]*/ BSTR /*ExtenderName*/,
		/*[out,retval]*/ IDispatch** /*Extender*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ExtenderNames)(
		/*[out,retval]*/ VARIANT* /*ExtenderNames*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ExtenderCATID)(
		/*[out,retval]*/ BSTR* /*pRetval*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_WarningLevel)(
		/*[out,retval]*/ prjWarningLevel* /*pWarningLeve*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_WarningLevel)(
		/*[in]*/ prjWarningLevel /*warningLevel*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_TreatWarningsAsErrors)(
		/*[out,retval]*/ VARIANT_BOOL* /*pWarningAsError*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_TreatWarningsAsErrors)(
		/*[in]*/ VARIANT_BOOL /*warningAsError*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_EnableSQLServerDebugging)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbEnableSQLServerDebugging*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_EnableSQLServerDebugging)(
		/*[in]*/ VARIANT_BOOL /*bEnableSQLServerDebugging*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_FileAlignment)(
		/*[out,retval]*/ DWORD* /*pdwFileAlignment*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_FileAlignment)(
		/*[in]*/ DWORD /*dwFileAlignment*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_RegisterForComInterop)(
		/*[out,retval]*/ VARIANT_BOOL* /*pVal*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_RegisterForComInterop)(
		/*[in]*/ VARIANT_BOOL /*val*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ConfigurationOverrideFile)(
		/*[out,retval]*/ BSTR* /*pbstrConfigFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_ConfigurationOverrideFile)(
		/*[in]*/ BSTR /*bstrConfigFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_RemoteDebugEnabled)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbEnableRemoteLaunch*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_RemoteDebugEnabled)(
		/*[in]*/ VARIANT_BOOL /*bEnableRemoteLaunch*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_RemoteDebugMachine)(
		/*[out,retval]*/ BSTR* /*pbstrRemoteLaunchMach*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_RemoteDebugMachine)(
		/*[in]*/ BSTR /*bstrRemoteLaunchMach*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class ProjectConfigurationProperties3MockImpl :
	public ProjectConfigurationProperties3,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ProjectConfigurationProperties3MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ProjectConfigurationProperties3MockImpl)

	typedef ProjectConfigurationProperties3 Interface;
	struct get_DebugInfoValidValues
	{
		/*[out,retval]*/ BSTR* pbstrDebugInfo;
		HRESULT retValue;
	};

	STDMETHOD(get_DebugInfo)(
		/*[out,retval]*/ BSTR* pbstrDebugInfo)
	{
		VSL_DEFINE_MOCK_METHOD(get_DebugInfo)

		VSL_SET_VALIDVALUE_BSTR(pbstrDebugInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DebugInfoValidValues
	{
		/*[in]*/ BSTR DebugInfo;
		HRESULT retValue;
	};

	STDMETHOD(put_DebugInfo)(
		/*[in]*/ BSTR DebugInfo)
	{
		VSL_DEFINE_MOCK_METHOD(put_DebugInfo)

		VSL_CHECK_VALIDVALUE_BSTR(DebugInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_PlatformTargetValidValues
	{
		/*[out,retval]*/ BSTR* pbstrPlatformTarget;
		HRESULT retValue;
	};

	STDMETHOD(get_PlatformTarget)(
		/*[out,retval]*/ BSTR* pbstrPlatformTarget)
	{
		VSL_DEFINE_MOCK_METHOD(get_PlatformTarget)

		VSL_SET_VALIDVALUE_BSTR(pbstrPlatformTarget);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_PlatformTargetValidValues
	{
		/*[in]*/ BSTR PlatformTarget;
		HRESULT retValue;
	};

	STDMETHOD(put_PlatformTarget)(
		/*[in]*/ BSTR PlatformTarget)
	{
		VSL_DEFINE_MOCK_METHOD(put_PlatformTarget)

		VSL_CHECK_VALIDVALUE_BSTR(PlatformTarget);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_TreatSpecificWarningsAsErrorsValidValues
	{
		/*[out,retval]*/ BSTR* pbstrWarningsAsErrors;
		HRESULT retValue;
	};

	STDMETHOD(get_TreatSpecificWarningsAsErrors)(
		/*[out,retval]*/ BSTR* pbstrWarningsAsErrors)
	{
		VSL_DEFINE_MOCK_METHOD(get_TreatSpecificWarningsAsErrors)

		VSL_SET_VALIDVALUE_BSTR(pbstrWarningsAsErrors);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_TreatSpecificWarningsAsErrorsValidValues
	{
		/*[in]*/ BSTR WarningsAsErrors;
		HRESULT retValue;
	};

	STDMETHOD(put_TreatSpecificWarningsAsErrors)(
		/*[in]*/ BSTR WarningsAsErrors)
	{
		VSL_DEFINE_MOCK_METHOD(put_TreatSpecificWarningsAsErrors)

		VSL_CHECK_VALIDVALUE_BSTR(WarningsAsErrors);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_RunCodeAnalysisValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbRunCodeAnalysis;
		HRESULT retValue;
	};

	STDMETHOD(get_RunCodeAnalysis)(
		/*[out,retval]*/ VARIANT_BOOL* pbRunCodeAnalysis)
	{
		VSL_DEFINE_MOCK_METHOD(get_RunCodeAnalysis)

		VSL_SET_VALIDVALUE(pbRunCodeAnalysis);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_RunCodeAnalysisValidValues
	{
		/*[in]*/ VARIANT_BOOL RunCodeAnalysis;
		HRESULT retValue;
	};

	STDMETHOD(put_RunCodeAnalysis)(
		/*[in]*/ VARIANT_BOOL RunCodeAnalysis)
	{
		VSL_DEFINE_MOCK_METHOD(put_RunCodeAnalysis)

		VSL_CHECK_VALIDVALUE(RunCodeAnalysis);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CodeAnalysisLogFileValidValues
	{
		/*[out,retval]*/ BSTR* pbstrCodeAnalysisLogFile;
		HRESULT retValue;
	};

	STDMETHOD(get_CodeAnalysisLogFile)(
		/*[out,retval]*/ BSTR* pbstrCodeAnalysisLogFile)
	{
		VSL_DEFINE_MOCK_METHOD(get_CodeAnalysisLogFile)

		VSL_SET_VALIDVALUE_BSTR(pbstrCodeAnalysisLogFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_CodeAnalysisLogFileValidValues
	{
		/*[in]*/ BSTR CodeAnalysisLogFile;
		HRESULT retValue;
	};

	STDMETHOD(put_CodeAnalysisLogFile)(
		/*[in]*/ BSTR CodeAnalysisLogFile)
	{
		VSL_DEFINE_MOCK_METHOD(put_CodeAnalysisLogFile)

		VSL_CHECK_VALIDVALUE_BSTR(CodeAnalysisLogFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CodeAnalysisRuleAssembliesValidValues
	{
		/*[out,retval]*/ BSTR* pbstrCodeAnalysisRuleAssemblies;
		HRESULT retValue;
	};

	STDMETHOD(get_CodeAnalysisRuleAssemblies)(
		/*[out,retval]*/ BSTR* pbstrCodeAnalysisRuleAssemblies)
	{
		VSL_DEFINE_MOCK_METHOD(get_CodeAnalysisRuleAssemblies)

		VSL_SET_VALIDVALUE_BSTR(pbstrCodeAnalysisRuleAssemblies);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_CodeAnalysisRuleAssembliesValidValues
	{
		/*[in]*/ BSTR CodeAnalysisRuleAssemblies;
		HRESULT retValue;
	};

	STDMETHOD(put_CodeAnalysisRuleAssemblies)(
		/*[in]*/ BSTR CodeAnalysisRuleAssemblies)
	{
		VSL_DEFINE_MOCK_METHOD(put_CodeAnalysisRuleAssemblies)

		VSL_CHECK_VALIDVALUE_BSTR(CodeAnalysisRuleAssemblies);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CodeAnalysisInputAssemblyValidValues
	{
		/*[out,retval]*/ BSTR* pbstrCodeAnalysisInputAssembly;
		HRESULT retValue;
	};

	STDMETHOD(get_CodeAnalysisInputAssembly)(
		/*[out,retval]*/ BSTR* pbstrCodeAnalysisInputAssembly)
	{
		VSL_DEFINE_MOCK_METHOD(get_CodeAnalysisInputAssembly)

		VSL_SET_VALIDVALUE_BSTR(pbstrCodeAnalysisInputAssembly);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_CodeAnalysisInputAssemblyValidValues
	{
		/*[in]*/ BSTR CodeAnalysisInputAssembly;
		HRESULT retValue;
	};

	STDMETHOD(put_CodeAnalysisInputAssembly)(
		/*[in]*/ BSTR CodeAnalysisInputAssembly)
	{
		VSL_DEFINE_MOCK_METHOD(put_CodeAnalysisInputAssembly)

		VSL_CHECK_VALIDVALUE_BSTR(CodeAnalysisInputAssembly);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CodeAnalysisRulesValidValues
	{
		/*[out,retval]*/ BSTR* pbstrCodeAnalysisRules;
		HRESULT retValue;
	};

	STDMETHOD(get_CodeAnalysisRules)(
		/*[out,retval]*/ BSTR* pbstrCodeAnalysisRules)
	{
		VSL_DEFINE_MOCK_METHOD(get_CodeAnalysisRules)

		VSL_SET_VALIDVALUE_BSTR(pbstrCodeAnalysisRules);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_CodeAnalysisRulesValidValues
	{
		/*[in]*/ BSTR CodeAnalysisRules;
		HRESULT retValue;
	};

	STDMETHOD(put_CodeAnalysisRules)(
		/*[in]*/ BSTR CodeAnalysisRules)
	{
		VSL_DEFINE_MOCK_METHOD(put_CodeAnalysisRules)

		VSL_CHECK_VALIDVALUE_BSTR(CodeAnalysisRules);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CodeAnalysisSpellCheckLanguagesValidValues
	{
		/*[out,retval]*/ BSTR* pbstrCodeAnalysisSpellCheckLanguages;
		HRESULT retValue;
	};

	STDMETHOD(get_CodeAnalysisSpellCheckLanguages)(
		/*[out,retval]*/ BSTR* pbstrCodeAnalysisSpellCheckLanguages)
	{
		VSL_DEFINE_MOCK_METHOD(get_CodeAnalysisSpellCheckLanguages)

		VSL_SET_VALIDVALUE_BSTR(pbstrCodeAnalysisSpellCheckLanguages);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_CodeAnalysisSpellCheckLanguagesValidValues
	{
		/*[in]*/ BSTR CodeAnalysisSpellCheckLanguages;
		HRESULT retValue;
	};

	STDMETHOD(put_CodeAnalysisSpellCheckLanguages)(
		/*[in]*/ BSTR CodeAnalysisSpellCheckLanguages)
	{
		VSL_DEFINE_MOCK_METHOD(put_CodeAnalysisSpellCheckLanguages)

		VSL_CHECK_VALIDVALUE_BSTR(CodeAnalysisSpellCheckLanguages);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CodeAnalysisUseTypeNameInSuppressionValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* bUseTypeNameInSuppression;
		HRESULT retValue;
	};

	STDMETHOD(get_CodeAnalysisUseTypeNameInSuppression)(
		/*[out,retval]*/ VARIANT_BOOL* bUseTypeNameInSuppression)
	{
		VSL_DEFINE_MOCK_METHOD(get_CodeAnalysisUseTypeNameInSuppression)

		VSL_SET_VALIDVALUE(bUseTypeNameInSuppression);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_CodeAnalysisUseTypeNameInSuppressionValidValues
	{
		/*[in]*/ VARIANT_BOOL UseTypeNameInSuppression;
		HRESULT retValue;
	};

	STDMETHOD(put_CodeAnalysisUseTypeNameInSuppression)(
		/*[in]*/ VARIANT_BOOL UseTypeNameInSuppression)
	{
		VSL_DEFINE_MOCK_METHOD(put_CodeAnalysisUseTypeNameInSuppression)

		VSL_CHECK_VALIDVALUE(UseTypeNameInSuppression);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CodeAnalysisModuleSuppressionsFileValidValues
	{
		/*[out,retval]*/ BSTR* pbstrCodeAnalysisModuleSuppressionsFile;
		HRESULT retValue;
	};

	STDMETHOD(get_CodeAnalysisModuleSuppressionsFile)(
		/*[out,retval]*/ BSTR* pbstrCodeAnalysisModuleSuppressionsFile)
	{
		VSL_DEFINE_MOCK_METHOD(get_CodeAnalysisModuleSuppressionsFile)

		VSL_SET_VALIDVALUE_BSTR(pbstrCodeAnalysisModuleSuppressionsFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_CodeAnalysisModuleSuppressionsFileValidValues
	{
		/*[in]*/ BSTR CodeAnalysisModuleSuppressionsFile;
		HRESULT retValue;
	};

	STDMETHOD(put_CodeAnalysisModuleSuppressionsFile)(
		/*[in]*/ BSTR CodeAnalysisModuleSuppressionsFile)
	{
		VSL_DEFINE_MOCK_METHOD(put_CodeAnalysisModuleSuppressionsFile)

		VSL_CHECK_VALIDVALUE_BSTR(CodeAnalysisModuleSuppressionsFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_UseVSHostingProcessValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbUseVSHostingProcess;
		HRESULT retValue;
	};

	STDMETHOD(get_UseVSHostingProcess)(
		/*[out,retval]*/ VARIANT_BOOL* pbUseVSHostingProcess)
	{
		VSL_DEFINE_MOCK_METHOD(get_UseVSHostingProcess)

		VSL_SET_VALIDVALUE(pbUseVSHostingProcess);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_UseVSHostingProcessValidValues
	{
		/*[in]*/ VARIANT_BOOL UseVSHostingProcess;
		HRESULT retValue;
	};

	STDMETHOD(put_UseVSHostingProcess)(
		/*[in]*/ VARIANT_BOOL UseVSHostingProcess)
	{
		VSL_DEFINE_MOCK_METHOD(put_UseVSHostingProcess)

		VSL_CHECK_VALIDVALUE(UseVSHostingProcess);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_GenerateSerializationAssembliesValidValues
	{
		/*[out,retval]*/ sgenGenerationOption* pSgenGenerationOption;
		HRESULT retValue;
	};

	STDMETHOD(get_GenerateSerializationAssemblies)(
		/*[out,retval]*/ sgenGenerationOption* pSgenGenerationOption)
	{
		VSL_DEFINE_MOCK_METHOD(get_GenerateSerializationAssemblies)

		VSL_SET_VALIDVALUE(pSgenGenerationOption);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_GenerateSerializationAssembliesValidValues
	{
		/*[in]*/ sgenGenerationOption SgenGenerationOption;
		HRESULT retValue;
	};

	STDMETHOD(put_GenerateSerializationAssemblies)(
		/*[in]*/ sgenGenerationOption SgenGenerationOption)
	{
		VSL_DEFINE_MOCK_METHOD(put_GenerateSerializationAssemblies)

		VSL_CHECK_VALIDVALUE(SgenGenerationOption);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_NoWarnValidValues
	{
		/*[out,retval]*/ BSTR* pbstrWarnings;
		HRESULT retValue;
	};

	STDMETHOD(get_NoWarn)(
		/*[out,retval]*/ BSTR* pbstrWarnings)
	{
		VSL_DEFINE_MOCK_METHOD(get_NoWarn)

		VSL_SET_VALIDVALUE_BSTR(pbstrWarnings);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_NoWarnValidValues
	{
		/*[in]*/ BSTR bstrWarnings;
		HRESULT retValue;
	};

	STDMETHOD(put_NoWarn)(
		/*[in]*/ BSTR bstrWarnings)
	{
		VSL_DEFINE_MOCK_METHOD(put_NoWarn)

		VSL_CHECK_VALIDVALUE_BSTR(bstrWarnings);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_NoStdLibValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbNoStdLib;
		HRESULT retValue;
	};

	STDMETHOD(get_NoStdLib)(
		/*[out,retval]*/ VARIANT_BOOL* pbNoStdLib)
	{
		VSL_DEFINE_MOCK_METHOD(get_NoStdLib)

		VSL_SET_VALIDVALUE(pbNoStdLib);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_NoStdLibValidValues
	{
		/*[in]*/ VARIANT_BOOL bNoStdLib;
		HRESULT retValue;
	};

	STDMETHOD(put_NoStdLib)(
		/*[in]*/ VARIANT_BOOL bNoStdLib)
	{
		VSL_DEFINE_MOCK_METHOD(put_NoStdLib)

		VSL_CHECK_VALIDVALUE(bNoStdLib);

		VSL_RETURN_VALIDVALUES();
	}
	struct get___idValidValues
	{
		/*[out,retval]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(get___id)(
		/*[out,retval]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(get___id)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DebugSymbolsValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbGenerate;
		HRESULT retValue;
	};

	STDMETHOD(get_DebugSymbols)(
		/*[out,retval]*/ VARIANT_BOOL* pbGenerate)
	{
		VSL_DEFINE_MOCK_METHOD(get_DebugSymbols)

		VSL_SET_VALIDVALUE(pbGenerate);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DebugSymbolsValidValues
	{
		/*[in]*/ VARIANT_BOOL bGenerate;
		HRESULT retValue;
	};

	STDMETHOD(put_DebugSymbols)(
		/*[in]*/ VARIANT_BOOL bGenerate)
	{
		VSL_DEFINE_MOCK_METHOD(put_DebugSymbols)

		VSL_CHECK_VALIDVALUE(bGenerate);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DefineDebugValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbDefineDebug;
		HRESULT retValue;
	};

	STDMETHOD(get_DefineDebug)(
		/*[out,retval]*/ VARIANT_BOOL* pbDefineDebug)
	{
		VSL_DEFINE_MOCK_METHOD(get_DefineDebug)

		VSL_SET_VALIDVALUE(pbDefineDebug);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DefineDebugValidValues
	{
		/*[in]*/ VARIANT_BOOL bDefineDebug;
		HRESULT retValue;
	};

	STDMETHOD(put_DefineDebug)(
		/*[in]*/ VARIANT_BOOL bDefineDebug)
	{
		VSL_DEFINE_MOCK_METHOD(put_DefineDebug)

		VSL_CHECK_VALIDVALUE(bDefineDebug);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DefineTraceValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbDefineTrace;
		HRESULT retValue;
	};

	STDMETHOD(get_DefineTrace)(
		/*[out,retval]*/ VARIANT_BOOL* pbDefineTrace)
	{
		VSL_DEFINE_MOCK_METHOD(get_DefineTrace)

		VSL_SET_VALIDVALUE(pbDefineTrace);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DefineTraceValidValues
	{
		/*[in]*/ VARIANT_BOOL bDefineTrace;
		HRESULT retValue;
	};

	STDMETHOD(put_DefineTrace)(
		/*[in]*/ VARIANT_BOOL bDefineTrace)
	{
		VSL_DEFINE_MOCK_METHOD(put_DefineTrace)

		VSL_CHECK_VALIDVALUE(bDefineTrace);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_OutputPathValidValues
	{
		/*[out,retval]*/ BSTR* pbstrOutputPath;
		HRESULT retValue;
	};

	STDMETHOD(get_OutputPath)(
		/*[out,retval]*/ BSTR* pbstrOutputPath)
	{
		VSL_DEFINE_MOCK_METHOD(get_OutputPath)

		VSL_SET_VALIDVALUE_BSTR(pbstrOutputPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_OutputPathValidValues
	{
		/*[in]*/ BSTR bstrOutputPath;
		HRESULT retValue;
	};

	STDMETHOD(put_OutputPath)(
		/*[in]*/ BSTR bstrOutputPath)
	{
		VSL_DEFINE_MOCK_METHOD(put_OutputPath)

		VSL_CHECK_VALIDVALUE_BSTR(bstrOutputPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IntermediatePathValidValues
	{
		/*[out,retval]*/ BSTR* pbstrIntermediatePath;
		HRESULT retValue;
	};

	STDMETHOD(get_IntermediatePath)(
		/*[out,retval]*/ BSTR* pbstrIntermediatePath)
	{
		VSL_DEFINE_MOCK_METHOD(get_IntermediatePath)

		VSL_SET_VALIDVALUE_BSTR(pbstrIntermediatePath);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_IntermediatePathValidValues
	{
		/*[in]*/ BSTR bstrIntermediatePath;
		HRESULT retValue;
	};

	STDMETHOD(put_IntermediatePath)(
		/*[in]*/ BSTR bstrIntermediatePath)
	{
		VSL_DEFINE_MOCK_METHOD(put_IntermediatePath)

		VSL_CHECK_VALIDVALUE_BSTR(bstrIntermediatePath);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DefineConstantsValidValues
	{
		/*[out,retval]*/ BSTR* pbstrDefineConstants;
		HRESULT retValue;
	};

	STDMETHOD(get_DefineConstants)(
		/*[out,retval]*/ BSTR* pbstrDefineConstants)
	{
		VSL_DEFINE_MOCK_METHOD(get_DefineConstants)

		VSL_SET_VALIDVALUE_BSTR(pbstrDefineConstants);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DefineConstantsValidValues
	{
		/*[in]*/ BSTR bstrDefineConstants;
		HRESULT retValue;
	};

	STDMETHOD(put_DefineConstants)(
		/*[in]*/ BSTR bstrDefineConstants)
	{
		VSL_DEFINE_MOCK_METHOD(put_DefineConstants)

		VSL_CHECK_VALIDVALUE_BSTR(bstrDefineConstants);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_RemoveIntegerChecksValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbRemoveIntegerChecks;
		HRESULT retValue;
	};

	STDMETHOD(get_RemoveIntegerChecks)(
		/*[out,retval]*/ VARIANT_BOOL* pbRemoveIntegerChecks)
	{
		VSL_DEFINE_MOCK_METHOD(get_RemoveIntegerChecks)

		VSL_SET_VALIDVALUE(pbRemoveIntegerChecks);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_RemoveIntegerChecksValidValues
	{
		/*[in]*/ VARIANT_BOOL bRemoveIntegerChecks;
		HRESULT retValue;
	};

	STDMETHOD(put_RemoveIntegerChecks)(
		/*[in]*/ VARIANT_BOOL bRemoveIntegerChecks)
	{
		VSL_DEFINE_MOCK_METHOD(put_RemoveIntegerChecks)

		VSL_CHECK_VALIDVALUE(bRemoveIntegerChecks);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_BaseAddressValidValues
	{
		/*[out,retval]*/ DWORD* pdwBaseAddress;
		HRESULT retValue;
	};

	STDMETHOD(get_BaseAddress)(
		/*[out,retval]*/ DWORD* pdwBaseAddress)
	{
		VSL_DEFINE_MOCK_METHOD(get_BaseAddress)

		VSL_SET_VALIDVALUE(pdwBaseAddress);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_BaseAddressValidValues
	{
		/*[in]*/ DWORD dwBaseAddress;
		HRESULT retValue;
	};

	STDMETHOD(put_BaseAddress)(
		/*[in]*/ DWORD dwBaseAddress)
	{
		VSL_DEFINE_MOCK_METHOD(put_BaseAddress)

		VSL_CHECK_VALIDVALUE(dwBaseAddress);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_AllowUnsafeBlocksValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbUnsafe;
		HRESULT retValue;
	};

	STDMETHOD(get_AllowUnsafeBlocks)(
		/*[out,retval]*/ VARIANT_BOOL* pbUnsafe)
	{
		VSL_DEFINE_MOCK_METHOD(get_AllowUnsafeBlocks)

		VSL_SET_VALIDVALUE(pbUnsafe);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_AllowUnsafeBlocksValidValues
	{
		/*[in]*/ VARIANT_BOOL bUnsafe;
		HRESULT retValue;
	};

	STDMETHOD(put_AllowUnsafeBlocks)(
		/*[in]*/ VARIANT_BOOL bUnsafe)
	{
		VSL_DEFINE_MOCK_METHOD(put_AllowUnsafeBlocks)

		VSL_CHECK_VALIDVALUE(bUnsafe);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CheckForOverflowUnderflowValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbCheckForOverflowUnderflow;
		HRESULT retValue;
	};

	STDMETHOD(get_CheckForOverflowUnderflow)(
		/*[out,retval]*/ VARIANT_BOOL* pbCheckForOverflowUnderflow)
	{
		VSL_DEFINE_MOCK_METHOD(get_CheckForOverflowUnderflow)

		VSL_SET_VALIDVALUE(pbCheckForOverflowUnderflow);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_CheckForOverflowUnderflowValidValues
	{
		/*[in]*/ VARIANT_BOOL bCheckForOverflowUnderflow;
		HRESULT retValue;
	};

	STDMETHOD(put_CheckForOverflowUnderflow)(
		/*[in]*/ VARIANT_BOOL bCheckForOverflowUnderflow)
	{
		VSL_DEFINE_MOCK_METHOD(put_CheckForOverflowUnderflow)

		VSL_CHECK_VALIDVALUE(bCheckForOverflowUnderflow);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DocumentationFileValidValues
	{
		/*[out,retval]*/ BSTR* pbstrDocumentationFile;
		HRESULT retValue;
	};

	STDMETHOD(get_DocumentationFile)(
		/*[out,retval]*/ BSTR* pbstrDocumentationFile)
	{
		VSL_DEFINE_MOCK_METHOD(get_DocumentationFile)

		VSL_SET_VALIDVALUE_BSTR(pbstrDocumentationFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DocumentationFileValidValues
	{
		/*[in]*/ BSTR bstrDocumentationFile;
		HRESULT retValue;
	};

	STDMETHOD(put_DocumentationFile)(
		/*[in]*/ BSTR bstrDocumentationFile)
	{
		VSL_DEFINE_MOCK_METHOD(put_DocumentationFile)

		VSL_CHECK_VALIDVALUE_BSTR(bstrDocumentationFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_OptimizeValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbOptimize;
		HRESULT retValue;
	};

	STDMETHOD(get_Optimize)(
		/*[out,retval]*/ VARIANT_BOOL* pbOptimize)
	{
		VSL_DEFINE_MOCK_METHOD(get_Optimize)

		VSL_SET_VALIDVALUE(pbOptimize);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_OptimizeValidValues
	{
		/*[in]*/ VARIANT_BOOL bCheckForOverflowUnderflow;
		HRESULT retValue;
	};

	STDMETHOD(put_Optimize)(
		/*[in]*/ VARIANT_BOOL bCheckForOverflowUnderflow)
	{
		VSL_DEFINE_MOCK_METHOD(put_Optimize)

		VSL_CHECK_VALIDVALUE(bCheckForOverflowUnderflow);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IncrementalBuildValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbIncrementalBuild;
		HRESULT retValue;
	};

	STDMETHOD(get_IncrementalBuild)(
		/*[out,retval]*/ VARIANT_BOOL* pbIncrementalBuild)
	{
		VSL_DEFINE_MOCK_METHOD(get_IncrementalBuild)

		VSL_SET_VALIDVALUE(pbIncrementalBuild);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_IncrementalBuildValidValues
	{
		/*[in]*/ VARIANT_BOOL bIncrementalBuild;
		HRESULT retValue;
	};

	STDMETHOD(put_IncrementalBuild)(
		/*[in]*/ VARIANT_BOOL bIncrementalBuild)
	{
		VSL_DEFINE_MOCK_METHOD(put_IncrementalBuild)

		VSL_CHECK_VALIDVALUE(bIncrementalBuild);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_StartProgramValidValues
	{
		/*[out,retval]*/ BSTR* pbstrStartProgram;
		HRESULT retValue;
	};

	STDMETHOD(get_StartProgram)(
		/*[out,retval]*/ BSTR* pbstrStartProgram)
	{
		VSL_DEFINE_MOCK_METHOD(get_StartProgram)

		VSL_SET_VALIDVALUE_BSTR(pbstrStartProgram);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_StartProgramValidValues
	{
		/*[in]*/ BSTR bstrStartProgram;
		HRESULT retValue;
	};

	STDMETHOD(put_StartProgram)(
		/*[in]*/ BSTR bstrStartProgram)
	{
		VSL_DEFINE_MOCK_METHOD(put_StartProgram)

		VSL_CHECK_VALIDVALUE_BSTR(bstrStartProgram);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_StartWorkingDirectoryValidValues
	{
		/*[out,retval]*/ BSTR* pbstrStartWorkingDirectory;
		HRESULT retValue;
	};

	STDMETHOD(get_StartWorkingDirectory)(
		/*[out,retval]*/ BSTR* pbstrStartWorkingDirectory)
	{
		VSL_DEFINE_MOCK_METHOD(get_StartWorkingDirectory)

		VSL_SET_VALIDVALUE_BSTR(pbstrStartWorkingDirectory);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_StartWorkingDirectoryValidValues
	{
		/*[in]*/ BSTR bstrStartWorkingDirectory;
		HRESULT retValue;
	};

	STDMETHOD(put_StartWorkingDirectory)(
		/*[in]*/ BSTR bstrStartWorkingDirectory)
	{
		VSL_DEFINE_MOCK_METHOD(put_StartWorkingDirectory)

		VSL_CHECK_VALIDVALUE_BSTR(bstrStartWorkingDirectory);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_StartURLValidValues
	{
		/*[out,retval]*/ BSTR* pbstrStartURL;
		HRESULT retValue;
	};

	STDMETHOD(get_StartURL)(
		/*[out,retval]*/ BSTR* pbstrStartURL)
	{
		VSL_DEFINE_MOCK_METHOD(get_StartURL)

		VSL_SET_VALIDVALUE_BSTR(pbstrStartURL);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_StartURLValidValues
	{
		/*[in]*/ BSTR bstrStartURL;
		HRESULT retValue;
	};

	STDMETHOD(put_StartURL)(
		/*[in]*/ BSTR bstrStartURL)
	{
		VSL_DEFINE_MOCK_METHOD(put_StartURL)

		VSL_CHECK_VALIDVALUE_BSTR(bstrStartURL);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_StartPageValidValues
	{
		/*[out,retval]*/ BSTR* pbstrStartPage;
		HRESULT retValue;
	};

	STDMETHOD(get_StartPage)(
		/*[out,retval]*/ BSTR* pbstrStartPage)
	{
		VSL_DEFINE_MOCK_METHOD(get_StartPage)

		VSL_SET_VALIDVALUE_BSTR(pbstrStartPage);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_StartPageValidValues
	{
		/*[in]*/ BSTR bstrStartPage;
		HRESULT retValue;
	};

	STDMETHOD(put_StartPage)(
		/*[in]*/ BSTR bstrStartPage)
	{
		VSL_DEFINE_MOCK_METHOD(put_StartPage)

		VSL_CHECK_VALIDVALUE_BSTR(bstrStartPage);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_StartArgumentsValidValues
	{
		/*[out,retval]*/ BSTR* pbstrStartArguments;
		HRESULT retValue;
	};

	STDMETHOD(get_StartArguments)(
		/*[out,retval]*/ BSTR* pbstrStartArguments)
	{
		VSL_DEFINE_MOCK_METHOD(get_StartArguments)

		VSL_SET_VALIDVALUE_BSTR(pbstrStartArguments);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_StartArgumentsValidValues
	{
		/*[in]*/ BSTR bstrStartArguments;
		HRESULT retValue;
	};

	STDMETHOD(put_StartArguments)(
		/*[in]*/ BSTR bstrStartArguments)
	{
		VSL_DEFINE_MOCK_METHOD(put_StartArguments)

		VSL_CHECK_VALIDVALUE_BSTR(bstrStartArguments);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_StartWithIEValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbStartWithIE;
		HRESULT retValue;
	};

	STDMETHOD(get_StartWithIE)(
		/*[out,retval]*/ VARIANT_BOOL* pbStartWithIE)
	{
		VSL_DEFINE_MOCK_METHOD(get_StartWithIE)

		VSL_SET_VALIDVALUE(pbStartWithIE);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_StartWithIEValidValues
	{
		/*[in]*/ VARIANT_BOOL bStartWithIE;
		HRESULT retValue;
	};

	STDMETHOD(put_StartWithIE)(
		/*[in]*/ VARIANT_BOOL bStartWithIE)
	{
		VSL_DEFINE_MOCK_METHOD(put_StartWithIE)

		VSL_CHECK_VALIDVALUE(bStartWithIE);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_EnableASPDebuggingValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbEnableASPDebugging;
		HRESULT retValue;
	};

	STDMETHOD(get_EnableASPDebugging)(
		/*[out,retval]*/ VARIANT_BOOL* pbEnableASPDebugging)
	{
		VSL_DEFINE_MOCK_METHOD(get_EnableASPDebugging)

		VSL_SET_VALIDVALUE(pbEnableASPDebugging);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_EnableASPDebuggingValidValues
	{
		/*[in]*/ VARIANT_BOOL bEnableASPDebugging;
		HRESULT retValue;
	};

	STDMETHOD(put_EnableASPDebugging)(
		/*[in]*/ VARIANT_BOOL bEnableASPDebugging)
	{
		VSL_DEFINE_MOCK_METHOD(put_EnableASPDebugging)

		VSL_CHECK_VALIDVALUE(bEnableASPDebugging);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_EnableASPXDebuggingValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbEnableASPXDebugging;
		HRESULT retValue;
	};

	STDMETHOD(get_EnableASPXDebugging)(
		/*[out,retval]*/ VARIANT_BOOL* pbEnableASPXDebugging)
	{
		VSL_DEFINE_MOCK_METHOD(get_EnableASPXDebugging)

		VSL_SET_VALIDVALUE(pbEnableASPXDebugging);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_EnableASPXDebuggingValidValues
	{
		/*[in]*/ VARIANT_BOOL bEnableASPXDebugging;
		HRESULT retValue;
	};

	STDMETHOD(put_EnableASPXDebugging)(
		/*[in]*/ VARIANT_BOOL bEnableASPXDebugging)
	{
		VSL_DEFINE_MOCK_METHOD(put_EnableASPXDebugging)

		VSL_CHECK_VALIDVALUE(bEnableASPXDebugging);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_EnableUnmanagedDebuggingValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbEnableUnmanagedDebugging;
		HRESULT retValue;
	};

	STDMETHOD(get_EnableUnmanagedDebugging)(
		/*[out,retval]*/ VARIANT_BOOL* pbEnableUnmanagedDebugging)
	{
		VSL_DEFINE_MOCK_METHOD(get_EnableUnmanagedDebugging)

		VSL_SET_VALIDVALUE(pbEnableUnmanagedDebugging);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_EnableUnmanagedDebuggingValidValues
	{
		/*[in]*/ VARIANT_BOOL bEnableUnmanagedDebugging;
		HRESULT retValue;
	};

	STDMETHOD(put_EnableUnmanagedDebugging)(
		/*[in]*/ VARIANT_BOOL bEnableUnmanagedDebugging)
	{
		VSL_DEFINE_MOCK_METHOD(put_EnableUnmanagedDebugging)

		VSL_CHECK_VALIDVALUE(bEnableUnmanagedDebugging);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_StartActionValidValues
	{
		/*[out,retval]*/ prjStartAction* pdebugStartMode;
		HRESULT retValue;
	};

	STDMETHOD(get_StartAction)(
		/*[out,retval]*/ prjStartAction* pdebugStartMode)
	{
		VSL_DEFINE_MOCK_METHOD(get_StartAction)

		VSL_SET_VALIDVALUE(pdebugStartMode);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_StartActionValidValues
	{
		/*[in]*/ prjStartAction debugStartMode;
		HRESULT retValue;
	};

	STDMETHOD(put_StartAction)(
		/*[in]*/ prjStartAction debugStartMode)
	{
		VSL_DEFINE_MOCK_METHOD(put_StartAction)

		VSL_CHECK_VALIDVALUE(debugStartMode);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderValidValues
	{
		/*[in]*/ BSTR ExtenderName;
		/*[out,retval]*/ IDispatch** Extender;
		HRESULT retValue;
	};

	STDMETHOD(get_Extender)(
		/*[in]*/ BSTR ExtenderName,
		/*[out,retval]*/ IDispatch** Extender)
	{
		VSL_DEFINE_MOCK_METHOD(get_Extender)

		VSL_CHECK_VALIDVALUE_BSTR(ExtenderName);

		VSL_SET_VALIDVALUE_INTERFACE(Extender);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderNamesValidValues
	{
		/*[out,retval]*/ VARIANT* ExtenderNames;
		HRESULT retValue;
	};

	STDMETHOD(get_ExtenderNames)(
		/*[out,retval]*/ VARIANT* ExtenderNames)
	{
		VSL_DEFINE_MOCK_METHOD(get_ExtenderNames)

		VSL_SET_VALIDVALUE_VARIANT(ExtenderNames);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderCATIDValidValues
	{
		/*[out,retval]*/ BSTR* pRetval;
		HRESULT retValue;
	};

	STDMETHOD(get_ExtenderCATID)(
		/*[out,retval]*/ BSTR* pRetval)
	{
		VSL_DEFINE_MOCK_METHOD(get_ExtenderCATID)

		VSL_SET_VALIDVALUE_BSTR(pRetval);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_WarningLevelValidValues
	{
		/*[out,retval]*/ prjWarningLevel* pWarningLeve;
		HRESULT retValue;
	};

	STDMETHOD(get_WarningLevel)(
		/*[out,retval]*/ prjWarningLevel* pWarningLeve)
	{
		VSL_DEFINE_MOCK_METHOD(get_WarningLevel)

		VSL_SET_VALIDVALUE(pWarningLeve);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_WarningLevelValidValues
	{
		/*[in]*/ prjWarningLevel warningLevel;
		HRESULT retValue;
	};

	STDMETHOD(put_WarningLevel)(
		/*[in]*/ prjWarningLevel warningLevel)
	{
		VSL_DEFINE_MOCK_METHOD(put_WarningLevel)

		VSL_CHECK_VALIDVALUE(warningLevel);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_TreatWarningsAsErrorsValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pWarningAsError;
		HRESULT retValue;
	};

	STDMETHOD(get_TreatWarningsAsErrors)(
		/*[out,retval]*/ VARIANT_BOOL* pWarningAsError)
	{
		VSL_DEFINE_MOCK_METHOD(get_TreatWarningsAsErrors)

		VSL_SET_VALIDVALUE(pWarningAsError);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_TreatWarningsAsErrorsValidValues
	{
		/*[in]*/ VARIANT_BOOL warningAsError;
		HRESULT retValue;
	};

	STDMETHOD(put_TreatWarningsAsErrors)(
		/*[in]*/ VARIANT_BOOL warningAsError)
	{
		VSL_DEFINE_MOCK_METHOD(put_TreatWarningsAsErrors)

		VSL_CHECK_VALIDVALUE(warningAsError);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_EnableSQLServerDebuggingValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbEnableSQLServerDebugging;
		HRESULT retValue;
	};

	STDMETHOD(get_EnableSQLServerDebugging)(
		/*[out,retval]*/ VARIANT_BOOL* pbEnableSQLServerDebugging)
	{
		VSL_DEFINE_MOCK_METHOD(get_EnableSQLServerDebugging)

		VSL_SET_VALIDVALUE(pbEnableSQLServerDebugging);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_EnableSQLServerDebuggingValidValues
	{
		/*[in]*/ VARIANT_BOOL bEnableSQLServerDebugging;
		HRESULT retValue;
	};

	STDMETHOD(put_EnableSQLServerDebugging)(
		/*[in]*/ VARIANT_BOOL bEnableSQLServerDebugging)
	{
		VSL_DEFINE_MOCK_METHOD(put_EnableSQLServerDebugging)

		VSL_CHECK_VALIDVALUE(bEnableSQLServerDebugging);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_FileAlignmentValidValues
	{
		/*[out,retval]*/ DWORD* pdwFileAlignment;
		HRESULT retValue;
	};

	STDMETHOD(get_FileAlignment)(
		/*[out,retval]*/ DWORD* pdwFileAlignment)
	{
		VSL_DEFINE_MOCK_METHOD(get_FileAlignment)

		VSL_SET_VALIDVALUE(pdwFileAlignment);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_FileAlignmentValidValues
	{
		/*[in]*/ DWORD dwFileAlignment;
		HRESULT retValue;
	};

	STDMETHOD(put_FileAlignment)(
		/*[in]*/ DWORD dwFileAlignment)
	{
		VSL_DEFINE_MOCK_METHOD(put_FileAlignment)

		VSL_CHECK_VALIDVALUE(dwFileAlignment);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_RegisterForComInteropValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pVal;
		HRESULT retValue;
	};

	STDMETHOD(get_RegisterForComInterop)(
		/*[out,retval]*/ VARIANT_BOOL* pVal)
	{
		VSL_DEFINE_MOCK_METHOD(get_RegisterForComInterop)

		VSL_SET_VALIDVALUE(pVal);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_RegisterForComInteropValidValues
	{
		/*[in]*/ VARIANT_BOOL val;
		HRESULT retValue;
	};

	STDMETHOD(put_RegisterForComInterop)(
		/*[in]*/ VARIANT_BOOL val)
	{
		VSL_DEFINE_MOCK_METHOD(put_RegisterForComInterop)

		VSL_CHECK_VALIDVALUE(val);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ConfigurationOverrideFileValidValues
	{
		/*[out,retval]*/ BSTR* pbstrConfigFile;
		HRESULT retValue;
	};

	STDMETHOD(get_ConfigurationOverrideFile)(
		/*[out,retval]*/ BSTR* pbstrConfigFile)
	{
		VSL_DEFINE_MOCK_METHOD(get_ConfigurationOverrideFile)

		VSL_SET_VALIDVALUE_BSTR(pbstrConfigFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_ConfigurationOverrideFileValidValues
	{
		/*[in]*/ BSTR bstrConfigFile;
		HRESULT retValue;
	};

	STDMETHOD(put_ConfigurationOverrideFile)(
		/*[in]*/ BSTR bstrConfigFile)
	{
		VSL_DEFINE_MOCK_METHOD(put_ConfigurationOverrideFile)

		VSL_CHECK_VALIDVALUE_BSTR(bstrConfigFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_RemoteDebugEnabledValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbEnableRemoteLaunch;
		HRESULT retValue;
	};

	STDMETHOD(get_RemoteDebugEnabled)(
		/*[out,retval]*/ VARIANT_BOOL* pbEnableRemoteLaunch)
	{
		VSL_DEFINE_MOCK_METHOD(get_RemoteDebugEnabled)

		VSL_SET_VALIDVALUE(pbEnableRemoteLaunch);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_RemoteDebugEnabledValidValues
	{
		/*[in]*/ VARIANT_BOOL bEnableRemoteLaunch;
		HRESULT retValue;
	};

	STDMETHOD(put_RemoteDebugEnabled)(
		/*[in]*/ VARIANT_BOOL bEnableRemoteLaunch)
	{
		VSL_DEFINE_MOCK_METHOD(put_RemoteDebugEnabled)

		VSL_CHECK_VALIDVALUE(bEnableRemoteLaunch);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_RemoteDebugMachineValidValues
	{
		/*[out,retval]*/ BSTR* pbstrRemoteLaunchMach;
		HRESULT retValue;
	};

	STDMETHOD(get_RemoteDebugMachine)(
		/*[out,retval]*/ BSTR* pbstrRemoteLaunchMach)
	{
		VSL_DEFINE_MOCK_METHOD(get_RemoteDebugMachine)

		VSL_SET_VALIDVALUE_BSTR(pbstrRemoteLaunchMach);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_RemoteDebugMachineValidValues
	{
		/*[in]*/ BSTR bstrRemoteLaunchMach;
		HRESULT retValue;
	};

	STDMETHOD(put_RemoteDebugMachine)(
		/*[in]*/ BSTR bstrRemoteLaunchMach)
	{
		VSL_DEFINE_MOCK_METHOD(put_RemoteDebugMachine)

		VSL_CHECK_VALIDVALUE_BSTR(bstrRemoteLaunchMach);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // PROJECTCONFIGURATIONPROPERTIES3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockProjectProperties3.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef PROJECTPROPERTIES3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define PROJECTPROPERTIES3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vslangproj80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ProjectProperties3NotImpl :
	public ProjectProperties3
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ProjectProperties3NotImpl)

public:

	typedef ProjectProperties3 Interface;

	STDMETHOD(get_Title)(
		/*[out,retval]*/ BSTR* /*pbstrTitle*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_Title)(
		/*[in]*/ BSTR /*Title*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Description)(
		/*[out,retval]*/ BSTR* /*pbstrDescription*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_Description)(
		/*[in]*/ BSTR /*Description*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Company)(
		/*[out,retval]*/ BSTR* /*pbstrCompany*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_Company)(
		/*[in]*/ BSTR /*Company*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Product)(
		/*[out,retval]*/ BSTR* /*pbstrProduct*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_Product)(
		/*[in]*/ BSTR /*Product*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Copyright)(
		/*[out,retval]*/ BSTR* /*pbstrCopyright*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_Copyright)(
		/*[in]*/ BSTR /*Copyright*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Trademark)(
		/*[out,retval]*/ BSTR* /*pbstrTrademark*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_Trademark)(
		/*[in]*/ BSTR /*Trademark*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_AssemblyType)(
		/*[out,retval]*/ prjAssemblyType* /*pAssemblyType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_AssemblyType)(
		/*[in]*/ prjAssemblyType /*AssemblyType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_TypeComplianceDiagnostics)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbTypeComplianceDiagnostics*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_TypeComplianceDiagnostics)(
		/*[in]*/ VARIANT_BOOL /*TypeComplianceDiagnostics*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Win32ResourceFile)(
		/*[out,retval]*/ BSTR* /*pbstrW32ResourceFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_Win32ResourceFile)(
		/*[in]*/ BSTR /*Win32ResourceFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_AssemblyKeyProviderName)(
		/*[out,retval]*/ BSTR* /*pbstrKeyProviderName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_AssemblyKeyProviderName)(
		/*[in]*/ BSTR /*KeyProviderName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_AssemblyOriginatorKeyFileType)(
		/*[out,retval]*/ DWORD* /*pdwOriginatorKeyFileType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_AssemblyOriginatorKeyFileType)(
		/*[in]*/ DWORD /*OriginatorKeyFileType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_AssemblyVersion)(
		/*[out,retval]*/ BSTR* /*pbstrAssemblyVersion*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_AssemblyVersion)(
		/*[in]*/ BSTR /*AssemblyVersion*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_AssemblyFileVersion)(
		/*[out,retval]*/ BSTR* /*pbstrAssemblyFileVersion*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_AssemblyFileVersion)(
		/*[in]*/ BSTR /*AssemblyFileVersion*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_GenerateManifests)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbGenerateManifests*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_GenerateManifests)(
		/*[in]*/ VARIANT_BOOL /*GenerateManifests*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_EnableSecurityDebugging)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbEnableSecurityDebugging*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_EnableSecurityDebugging)(
		/*[in]*/ VARIANT_BOOL /*EnableSecurityDebugging*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DebugSecurityZoneURL)(
		/*[out,retval]*/ BSTR* /*pbstrSecurityURL*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DebugSecurityZoneURL)(
		/*[in]*/ BSTR /*SecurityURL*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Publish)(
		/*[out,retval]*/ IDispatch** /*ppdispPublish*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ComVisible)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbComVisible*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_ComVisible)(
		/*[in]*/ VARIANT_BOOL /*ComVisible*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_AssemblyGuid)(
		/*[out,retval]*/ BSTR* /*pbstrAssemblyGuid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_AssemblyGuid)(
		/*[in]*/ BSTR /*AssemblyGuid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_NeutralResourcesLanguage)(
		/*[out,retval]*/ BSTR* /*pbstrNeutralResourcesLanguage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_NeutralResourcesLanguage)(
		/*[in]*/ BSTR /*NeutralResourcesLanguage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_SignAssembly)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbSignAssembly*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_SignAssembly)(
		/*[in]*/ VARIANT_BOOL /*SignAssembly*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_SignManifests)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbSignManifests*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_SignManifests)(
		/*[in]*/ VARIANT_BOOL /*bSignManifests*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_TargetZone)(
		/*[out,retval]*/ BSTR* /*pbstrTargetZone*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_TargetZone)(
		/*[in]*/ BSTR /*TargetZone*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ExcludedPermissions)(
		/*[out,retval]*/ BSTR* /*pbstrExcludedPermissions*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_ExcludedPermissions)(
		/*[in]*/ BSTR /*ExcludedPermissions*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ManifestCertificateThumbprint)(
		/*[out,retval]*/ BSTR* /*pbstrManifestCertificateThumbprint*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_ManifestCertificateThumbprint)(
		/*[in]*/ BSTR /*ManifestCertificateThumbprint*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ManifestKeyFile)(
		/*[out,retval]*/ BSTR* /*pbstrManifestKeyFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_ManifestKeyFile)(
		/*[in]*/ BSTR /*ManifestKeyFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ManifestTimestampUrl)(
		/*[out,retval]*/ BSTR* /*pbstrManifestTimestampUrl*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_ManifestTimestampUrl)(
		/*[in]*/ BSTR /*ManifestTimestampUrl*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_PreBuildEvent)(
		/*[out,retval]*/ BSTR* /*pbstrOut*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_PreBuildEvent)(
		/*[in]*/ BSTR /*bstrIn*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_PostBuildEvent)(
		/*[out,retval]*/ BSTR* /*pbstrOut*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_PostBuildEvent)(
		/*[in]*/ BSTR /*bstrIn*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_RunPostBuildEvent)(
		/*[out,retval]*/ prjRunPostBuildEvent* /*pOut*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_RunPostBuildEvent)(
		/*[in]*/ prjRunPostBuildEvent /*run*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_AspnetVersion)(
		/*[out,retval]*/ BSTR* /*pOut*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get___id)(
		/*[out,retval]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get___project)(
		/*[out,retval]*/ IUnknown** /*ppUnk*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_StartupObject)(
		/*[out,retval]*/ BSTR* /*pbstrStartupObject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_StartupObject)(
		/*[in]*/ BSTR /*bstrStartupObject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_OutputType)(
		/*[out,retval]*/ prjOutputType* /*pOutputType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_OutputType)(
		/*[in]*/ prjOutputType /*outputType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_RootNamespace)(
		/*[out,retval]*/ BSTR* /*pbstrRootNamespace*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_RootNamespace)(
		/*[in]*/ BSTR /*bstrRootNamespace*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_AssemblyName)(
		/*[out,retval]*/ BSTR* /*pbstrAssemblyName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_AssemblyName)(
		/*[in]*/ BSTR /*bstrAssemblyName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_AssemblyOriginatorKeyFile)(
		/*[out,retval]*/ BSTR* /*pbstrOriginatorKeyFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_AssemblyOriginatorKeyFile)(
		/*[in]*/ BSTR /*bstrOriginatorKeyFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_AssemblyKeyContainerName)(
		/*[out,retval]*/ BSTR* /*pbstrKeyContainerName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_AssemblyKeyContainerName)(
		/*[in]*/ BSTR /*bstrKeyContainerName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_AssemblyOriginatorKeyMode)(
		/*[out,retval]*/ prjOriginatorKeyMode* /*pOriginatorKeyMode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_AssemblyOriginatorKeyMode)(
		/*[in]*/ prjOriginatorKeyMode /*originatorKeyMode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DelaySign)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbDelaySign*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DelaySign)(
		/*[in]*/ VARIANT_BOOL /*bDelaySign*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_WebServer)(
		/*[out,retval]*/ BSTR* /*pbstrWebServer*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_WebServerVersion)(
		/*[out,retval]*/ BSTR* /*pbstrWebServerVersion*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ServerExtensionsVersion)(
		/*[out,retval]*/ BSTR* /*pbstrServerExtensionsVersion*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_LinkRepair)(
		/*[out,retval]*/ VARIANT_BOOL* /*pLinkRepair*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_LinkRepair)(
		/*[in]*/ VARIANT_BOOL /*linkRepair*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_OfflineURL)(
		/*[out,retval]*/ BSTR* /*pbstrOfflineURL*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_FileSharePath)(
		/*[out,retval]*/ BSTR* /*pbstrFileSharePath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_FileSharePath)(
		/*[in]*/ BSTR /*bstrFileSharePath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ActiveFileSharePath)(
		/*[out,retval]*/ BSTR* /*pbstrFileSharePath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_WebAccessMethod)(
		/*[out,retval]*/ prjWebAccessMethod* /*pWebAccessMethod*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_WebAccessMethod)(
		/*[in]*/ prjWebAccessMethod /*authoringAccessMethod*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ActiveWebAccessMethod)(
		/*[out,retval]*/ prjWebAccessMethod* /*pActiveWebAccessMethod*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DefaultClientScript)(
		/*[out,retval]*/ prjScriptLanguage* /*pScriptLanguage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DefaultClientScript)(
		/*[in]*/ prjScriptLanguage /*scriptLanguage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DefaultTargetSchema)(
		/*[out,retval]*/ prjTargetSchema* /*pTargetSchema*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DefaultTargetSchema)(
		/*[in]*/ prjTargetSchema /*htmlPlatform*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DefaultHTMLPageLayout)(
		/*[out,retval]*/ prjHTMLPageLayout* /*pHTMLPageLayout*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DefaultHTMLPageLayout)(
		/*[in]*/ prjHTMLPageLayout /*htmlPageLayout*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_FileName)(
		/*[out,retval]*/ BSTR* /*pbstrFileName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_FileName)(
		/*[in]*/ BSTR /*bstrFileName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_FullPath)(
		/*[out,retval]*/ BSTR* /*pbstrFullPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_LocalPath)(
		/*[out,retval]*/ BSTR* /*pbstrLocalPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_URL)(
		/*[out,retval]*/ BSTR* /*pbstrURL*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ActiveConfigurationSettings)(
		/*[out,retval]*/ ProjectConfigurationProperties** /*ppVBProjConfigProps*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Extender)(
		/*[in]*/ BSTR /*ExtenderName*/,
		/*[out,retval]*/ IDispatch** /*Extender*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ExtenderNames)(
		/*[out,retval]*/ VARIANT* /*ExtenderNames*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ExtenderCATID)(
		/*[out,retval]*/ BSTR* /*pRetval*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ApplicationIcon)(
		/*[out,retval]*/ BSTR* /*pbstrApplicationIcon*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_ApplicationIcon)(
		/*[in]*/ BSTR /*bstrApplicationIcon*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_OptionStrict)(
		/*[out,retval]*/ prjOptionStrict* /*pOptionStrict*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_OptionStrict)(
		/*[in]*/ prjOptionStrict /*optionStrict*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ReferencePath)(
		/*[out,retval]*/ BSTR* /*pbstrReferencePath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_ReferencePath)(
		/*[in]*/ BSTR /*bstrReferencePath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_OutputFileName)(
		/*[out,retval]*/ BSTR* /*pbstrOutputFileName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_AbsoluteProjectDirectory)(
		/*[out,retval]*/ BSTR* /*pbstrDir*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_OptionExplicit)(
		/*[out,retval]*/ prjOptionExplicit* /*pOptionExplicit*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_OptionExplicit)(
		/*[in]*/ prjOptionExplicit /*optionExplicit*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_OptionCompare)(
		/*[out,retval]*/ prjCompare* /*pOptionCompare*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_OptionCompare)(
		/*[in]*/ prjCompare /*optionCompare*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ProjectType)(
		/*[out,retval]*/ prjProjectType* /*pProjectType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DefaultNamespace)(
		/*[out,retval]*/ BSTR* /*pbstrRootNamespace*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DefaultNamespace)(
		/*[in]*/ BSTR /*bstrRootNamespace*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class ProjectProperties3MockImpl :
	public ProjectProperties3,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ProjectProperties3MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ProjectProperties3MockImpl)

	typedef ProjectProperties3 Interface;
	struct get_TitleValidValues
	{
		/*[out,retval]*/ BSTR* pbstrTitle;
		HRESULT retValue;
	};

	STDMETHOD(get_Title)(
		/*[out,retval]*/ BSTR* pbstrTitle)
	{
		VSL_DEFINE_MOCK_METHOD(get_Title)

		VSL_SET_VALIDVALUE_BSTR(pbstrTitle);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_TitleValidValues
	{
		/*[in]*/ BSTR Title;
		HRESULT retValue;
	};

	STDMETHOD(put_Title)(
		/*[in]*/ BSTR Title)
	{
		VSL_DEFINE_MOCK_METHOD(put_Title)

		VSL_CHECK_VALIDVALUE_BSTR(Title);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DescriptionValidValues
	{
		/*[out,retval]*/ BSTR* pbstrDescription;
		HRESULT retValue;
	};

	STDMETHOD(get_Description)(
		/*[out,retval]*/ BSTR* pbstrDescription)
	{
		VSL_DEFINE_MOCK_METHOD(get_Description)

		VSL_SET_VALIDVALUE_BSTR(pbstrDescription);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DescriptionValidValues
	{
		/*[in]*/ BSTR Description;
		HRESULT retValue;
	};

	STDMETHOD(put_Description)(
		/*[in]*/ BSTR Description)
	{
		VSL_DEFINE_MOCK_METHOD(put_Description)

		VSL_CHECK_VALIDVALUE_BSTR(Description);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CompanyValidValues
	{
		/*[out,retval]*/ BSTR* pbstrCompany;
		HRESULT retValue;
	};

	STDMETHOD(get_Company)(
		/*[out,retval]*/ BSTR* pbstrCompany)
	{
		VSL_DEFINE_MOCK_METHOD(get_Company)

		VSL_SET_VALIDVALUE_BSTR(pbstrCompany);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_CompanyValidValues
	{
		/*[in]*/ BSTR Company;
		HRESULT retValue;
	};

	STDMETHOD(put_Company)(
		/*[in]*/ BSTR Company)
	{
		VSL_DEFINE_MOCK_METHOD(put_Company)

		VSL_CHECK_VALIDVALUE_BSTR(Company);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ProductValidValues
	{
		/*[out,retval]*/ BSTR* pbstrProduct;
		HRESULT retValue;
	};

	STDMETHOD(get_Product)(
		/*[out,retval]*/ BSTR* pbstrProduct)
	{
		VSL_DEFINE_MOCK_METHOD(get_Product)

		VSL_SET_VALIDVALUE_BSTR(pbstrProduct);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_ProductValidValues
	{
		/*[in]*/ BSTR Product;
		HRESULT retValue;
	};

	STDMETHOD(put_Product)(
		/*[in]*/ BSTR Product)
	{
		VSL_DEFINE_MOCK_METHOD(put_Product)

		VSL_CHECK_VALIDVALUE_BSTR(Product);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CopyrightValidValues
	{
		/*[out,retval]*/ BSTR* pbstrCopyright;
		HRESULT retValue;
	};

	STDMETHOD(get_Copyright)(
		/*[out,retval]*/ BSTR* pbstrCopyright)
	{
		VSL_DEFINE_MOCK_METHOD(get_Copyright)

		VSL_SET_VALIDVALUE_BSTR(pbstrCopyright);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_CopyrightValidValues
	{
		/*[in]*/ BSTR Copyright;
		HRESULT retValue;
	};

	STDMETHOD(put_Copyright)(
		/*[in]*/ BSTR Copyright)
	{
		VSL_DEFINE_MOCK_METHOD(put_Copyright)

		VSL_CHECK_VALIDVALUE_BSTR(Copyright);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_TrademarkValidValues
	{
		/*[out,retval]*/ BSTR* pbstrTrademark;
		HRESULT retValue;
	};

	STDMETHOD(get_Trademark)(
		/*[out,retval]*/ BSTR* pbstrTrademark)
	{
		VSL_DEFINE_MOCK_METHOD(get_Trademark)

		VSL_SET_VALIDVALUE_BSTR(pbstrTrademark);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_TrademarkValidValues
	{
		/*[in]*/ BSTR Trademark;
		HRESULT retValue;
	};

	STDMETHOD(put_Trademark)(
		/*[in]*/ BSTR Trademark)
	{
		VSL_DEFINE_MOCK_METHOD(put_Trademark)

		VSL_CHECK_VALIDVALUE_BSTR(Trademark);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_AssemblyTypeValidValues
	{
		/*[out,retval]*/ prjAssemblyType* pAssemblyType;
		HRESULT retValue;
	};

	STDMETHOD(get_AssemblyType)(
		/*[out,retval]*/ prjAssemblyType* pAssemblyType)
	{
		VSL_DEFINE_MOCK_METHOD(get_AssemblyType)

		VSL_SET_VALIDVALUE(pAssemblyType);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_AssemblyTypeValidValues
	{
		/*[in]*/ prjAssemblyType AssemblyType;
		HRESULT retValue;
	};

	STDMETHOD(put_AssemblyType)(
		/*[in]*/ prjAssemblyType AssemblyType)
	{
		VSL_DEFINE_MOCK_METHOD(put_AssemblyType)

		VSL_CHECK_VALIDVALUE(AssemblyType);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_TypeComplianceDiagnosticsValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbTypeComplianceDiagnostics;
		HRESULT retValue;
	};

	STDMETHOD(get_TypeComplianceDiagnostics)(
		/*[out,retval]*/ VARIANT_BOOL* pbTypeComplianceDiagnostics)
	{
		VSL_DEFINE_MOCK_METHOD(get_TypeComplianceDiagnostics)

		VSL_SET_VALIDVALUE(pbTypeComplianceDiagnostics);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_TypeComplianceDiagnosticsValidValues
	{
		/*[in]*/ VARIANT_BOOL TypeComplianceDiagnostics;
		HRESULT retValue;
	};

	STDMETHOD(put_TypeComplianceDiagnostics)(
		/*[in]*/ VARIANT_BOOL TypeComplianceDiagnostics)
	{
		VSL_DEFINE_MOCK_METHOD(put_TypeComplianceDiagnostics)

		VSL_CHECK_VALIDVALUE(TypeComplianceDiagnostics);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_Win32ResourceFileValidValues
	{
		/*[out,retval]*/ BSTR* pbstrW32ResourceFile;
		HRESULT retValue;
	};

	STDMETHOD(get_Win32ResourceFile)(
		/*[out,retval]*/ BSTR* pbstrW32ResourceFile)
	{
		VSL_DEFINE_MOCK_METHOD(get_Win32ResourceFile)

		VSL_SET_VALIDVALUE_BSTR(pbstrW32ResourceFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_Win32ResourceFileValidValues
	{
		/*[in]*/ BSTR Win32ResourceFile;
		HRESULT retValue;
	};

	STDMETHOD(put_Win32ResourceFile)(
		/*[in]*/ BSTR Win32ResourceFile)
	{
		VSL_DEFINE_MOCK_METHOD(put_Win32ResourceFile)

		VSL_CHECK_VALIDVALUE_BSTR(Win32ResourceFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_AssemblyKeyProviderNameValidValues
	{
		/*[out,retval]*/ BSTR* pbstrKeyProviderName;
		HRESULT retValue;
	};

	STDMETHOD(get_AssemblyKeyProviderName)(
		/*[out,retval]*/ BSTR* pbstrKeyProviderName)
	{
		VSL_DEFINE_MOCK_METHOD(get_AssemblyKeyProviderName)

		VSL_SET_VALIDVALUE_BSTR(pbstrKeyProviderName);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_AssemblyKeyProviderNameValidValues
	{
		/*[in]*/ BSTR KeyProviderName;
		HRESULT retValue;
	};

	STDMETHOD(put_AssemblyKeyProviderName)(
		/*[in]*/ BSTR KeyProviderName)
	{
		VSL_DEFINE_MOCK_METHOD(put_AssemblyKeyProviderName)

		VSL_CHECK_VALIDVALUE_BSTR(KeyProviderName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_AssemblyOriginatorKeyFileTypeValidValues
	{
		/*[out,retval]*/ DWORD* pdwOriginatorKeyFileType;
		HRESULT retValue;
	};

	STDMETHOD(get_AssemblyOriginatorKeyFileType)(
		/*[out,retval]*/ DWORD* pdwOriginatorKeyFileType)
	{
		VSL_DEFINE_MOCK_METHOD(get_AssemblyOriginatorKeyFileType)

		VSL_SET_VALIDVALUE(pdwOriginatorKeyFileType);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_AssemblyOriginatorKeyFileTypeValidValues
	{
		/*[in]*/ DWORD OriginatorKeyFileType;
		HRESULT retValue;
	};

	STDMETHOD(put_AssemblyOriginatorKeyFileType)(
		/*[in]*/ DWORD OriginatorKeyFileType)
	{
		VSL_DEFINE_MOCK_METHOD(put_AssemblyOriginatorKeyFileType)

		VSL_CHECK_VALIDVALUE(OriginatorKeyFileType);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_AssemblyVersionValidValues
	{
		/*[out,retval]*/ BSTR* pbstrAssemblyVersion;
		HRESULT retValue;
	};

	STDMETHOD(get_AssemblyVersion)(
		/*[out,retval]*/ BSTR* pbstrAssemblyVersion)
	{
		VSL_DEFINE_MOCK_METHOD(get_AssemblyVersion)

		VSL_SET_VALIDVALUE_BSTR(pbstrAssemblyVersion);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_AssemblyVersionValidValues
	{
		/*[in]*/ BSTR AssemblyVersion;
		HRESULT retValue;
	};

	STDMETHOD(put_AssemblyVersion)(
		/*[in]*/ BSTR AssemblyVersion)
	{
		VSL_DEFINE_MOCK_METHOD(put_AssemblyVersion)

		VSL_CHECK_VALIDVALUE_BSTR(AssemblyVersion);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_AssemblyFileVersionValidValues
	{
		/*[out,retval]*/ BSTR* pbstrAssemblyFileVersion;
		HRESULT retValue;
	};

	STDMETHOD(get_AssemblyFileVersion)(
		/*[out,retval]*/ BSTR* pbstrAssemblyFileVersion)
	{
		VSL_DEFINE_MOCK_METHOD(get_AssemblyFileVersion)

		VSL_SET_VALIDVALUE_BSTR(pbstrAssemblyFileVersion);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_AssemblyFileVersionValidValues
	{
		/*[in]*/ BSTR AssemblyFileVersion;
		HRESULT retValue;
	};

	STDMETHOD(put_AssemblyFileVersion)(
		/*[in]*/ BSTR AssemblyFileVersion)
	{
		VSL_DEFINE_MOCK_METHOD(put_AssemblyFileVersion)

		VSL_CHECK_VALIDVALUE_BSTR(AssemblyFileVersion);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_GenerateManifestsValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbGenerateManifests;
		HRESULT retValue;
	};

	STDMETHOD(get_GenerateManifests)(
		/*[out,retval]*/ VARIANT_BOOL* pbGenerateManifests)
	{
		VSL_DEFINE_MOCK_METHOD(get_GenerateManifests)

		VSL_SET_VALIDVALUE(pbGenerateManifests);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_GenerateManifestsValidValues
	{
		/*[in]*/ VARIANT_BOOL GenerateManifests;
		HRESULT retValue;
	};

	STDMETHOD(put_GenerateManifests)(
		/*[in]*/ VARIANT_BOOL GenerateManifests)
	{
		VSL_DEFINE_MOCK_METHOD(put_GenerateManifests)

		VSL_CHECK_VALIDVALUE(GenerateManifests);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_EnableSecurityDebuggingValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbEnableSecurityDebugging;
		HRESULT retValue;
	};

	STDMETHOD(get_EnableSecurityDebugging)(
		/*[out,retval]*/ VARIANT_BOOL* pbEnableSecurityDebugging)
	{
		VSL_DEFINE_MOCK_METHOD(get_EnableSecurityDebugging)

		VSL_SET_VALIDVALUE(pbEnableSecurityDebugging);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_EnableSecurityDebuggingValidValues
	{
		/*[in]*/ VARIANT_BOOL EnableSecurityDebugging;
		HRESULT retValue;
	};

	STDMETHOD(put_EnableSecurityDebugging)(
		/*[in]*/ VARIANT_BOOL EnableSecurityDebugging)
	{
		VSL_DEFINE_MOCK_METHOD(put_EnableSecurityDebugging)

		VSL_CHECK_VALIDVALUE(EnableSecurityDebugging);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DebugSecurityZoneURLValidValues
	{
		/*[out,retval]*/ BSTR* pbstrSecurityURL;
		HRESULT retValue;
	};

	STDMETHOD(get_DebugSecurityZoneURL)(
		/*[out,retval]*/ BSTR* pbstrSecurityURL)
	{
		VSL_DEFINE_MOCK_METHOD(get_DebugSecurityZoneURL)

		VSL_SET_VALIDVALUE_BSTR(pbstrSecurityURL);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DebugSecurityZoneURLValidValues
	{
		/*[in]*/ BSTR SecurityURL;
		HRESULT retValue;
	};

	STDMETHOD(put_DebugSecurityZoneURL)(
		/*[in]*/ BSTR SecurityURL)
	{
		VSL_DEFINE_MOCK_METHOD(put_DebugSecurityZoneURL)

		VSL_CHECK_VALIDVALUE_BSTR(SecurityURL);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_PublishValidValues
	{
		/*[out,retval]*/ IDispatch** ppdispPublish;
		HRESULT retValue;
	};

	STDMETHOD(get_Publish)(
		/*[out,retval]*/ IDispatch** ppdispPublish)
	{
		VSL_DEFINE_MOCK_METHOD(get_Publish)

		VSL_SET_VALIDVALUE_INTERFACE(ppdispPublish);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ComVisibleValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbComVisible;
		HRESULT retValue;
	};

	STDMETHOD(get_ComVisible)(
		/*[out,retval]*/ VARIANT_BOOL* pbComVisible)
	{
		VSL_DEFINE_MOCK_METHOD(get_ComVisible)

		VSL_SET_VALIDVALUE(pbComVisible);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_ComVisibleValidValues
	{
		/*[in]*/ VARIANT_BOOL ComVisible;
		HRESULT retValue;
	};

	STDMETHOD(put_ComVisible)(
		/*[in]*/ VARIANT_BOOL ComVisible)
	{
		VSL_DEFINE_MOCK_METHOD(put_ComVisible)

		VSL_CHECK_VALIDVALUE(ComVisible);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_AssemblyGuidValidValues
	{
		/*[out,retval]*/ BSTR* pbstrAssemblyGuid;
		HRESULT retValue;
	};

	STDMETHOD(get_AssemblyGuid)(
		/*[out,retval]*/ BSTR* pbstrAssemblyGuid)
	{
		VSL_DEFINE_MOCK_METHOD(get_AssemblyGuid)

		VSL_SET_VALIDVALUE_BSTR(pbstrAssemblyGuid);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_AssemblyGuidValidValues
	{
		/*[in]*/ BSTR AssemblyGuid;
		HRESULT retValue;
	};

	STDMETHOD(put_AssemblyGuid)(
		/*[in]*/ BSTR AssemblyGuid)
	{
		VSL_DEFINE_MOCK_METHOD(put_AssemblyGuid)

		VSL_CHECK_VALIDVALUE_BSTR(AssemblyGuid);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_NeutralResourcesLanguageValidValues
	{
		/*[out,retval]*/ BSTR* pbstrNeutralResourcesLanguage;
		HRESULT retValue;
	};

	STDMETHOD(get_NeutralResourcesLanguage)(
		/*[out,retval]*/ BSTR* pbstrNeutralResourcesLanguage)
	{
		VSL_DEFINE_MOCK_METHOD(get_NeutralResourcesLanguage)

		VSL_SET_VALIDVALUE_BSTR(pbstrNeutralResourcesLanguage);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_NeutralResourcesLanguageValidValues
	{
		/*[in]*/ BSTR NeutralResourcesLanguage;
		HRESULT retValue;
	};

	STDMETHOD(put_NeutralResourcesLanguage)(
		/*[in]*/ BSTR NeutralResourcesLanguage)
	{
		VSL_DEFINE_MOCK_METHOD(put_NeutralResourcesLanguage)

		VSL_CHECK_VALIDVALUE_BSTR(NeutralResourcesLanguage);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_SignAssemblyValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbSignAssembly;
		HRESULT retValue;
	};

	STDMETHOD(get_SignAssembly)(
		/*[out,retval]*/ VARIANT_BOOL* pbSignAssembly)
	{
		VSL_DEFINE_MOCK_METHOD(get_SignAssembly)

		VSL_SET_VALIDVALUE(pbSignAssembly);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_SignAssemblyValidValues
	{
		/*[in]*/ VARIANT_BOOL SignAssembly;
		HRESULT retValue;
	};

	STDMETHOD(put_SignAssembly)(
		/*[in]*/ VARIANT_BOOL SignAssembly)
	{
		VSL_DEFINE_MOCK_METHOD(put_SignAssembly)

		VSL_CHECK_VALIDVALUE(SignAssembly);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_SignManifestsValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbSignManifests;
		HRESULT retValue;
	};

	STDMETHOD(get_SignManifests)(
		/*[out,retval]*/ VARIANT_BOOL* pbSignManifests)
	{
		VSL_DEFINE_MOCK_METHOD(get_SignManifests)

		VSL_SET_VALIDVALUE(pbSignManifests);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_SignManifestsValidValues
	{
		/*[in]*/ VARIANT_BOOL bSignManifests;
		HRESULT retValue;
	};

	STDMETHOD(put_SignManifests)(
		/*[in]*/ VARIANT_BOOL bSignManifests)
	{
		VSL_DEFINE_MOCK_METHOD(put_SignManifests)

		VSL_CHECK_VALIDVALUE(bSignManifests);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_TargetZoneValidValues
	{
		/*[out,retval]*/ BSTR* pbstrTargetZone;
		HRESULT retValue;
	};

	STDMETHOD(get_TargetZone)(
		/*[out,retval]*/ BSTR* pbstrTargetZone)
	{
		VSL_DEFINE_MOCK_METHOD(get_TargetZone)

		VSL_SET_VALIDVALUE_BSTR(pbstrTargetZone);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_TargetZoneValidValues
	{
		/*[in]*/ BSTR TargetZone;
		HRESULT retValue;
	};

	STDMETHOD(put_TargetZone)(
		/*[in]*/ BSTR TargetZone)
	{
		VSL_DEFINE_MOCK_METHOD(put_TargetZone)

		VSL_CHECK_VALIDVALUE_BSTR(TargetZone);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExcludedPermissionsValidValues
	{
		/*[out,retval]*/ BSTR* pbstrExcludedPermissions;
		HRESULT retValue;
	};

	STDMETHOD(get_ExcludedPermissions)(
		/*[out,retval]*/ BSTR* pbstrExcludedPermissions)
	{
		VSL_DEFINE_MOCK_METHOD(get_ExcludedPermissions)

		VSL_SET_VALIDVALUE_BSTR(pbstrExcludedPermissions);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_ExcludedPermissionsValidValues
	{
		/*[in]*/ BSTR ExcludedPermissions;
		HRESULT retValue;
	};

	STDMETHOD(put_ExcludedPermissions)(
		/*[in]*/ BSTR ExcludedPermissions)
	{
		VSL_DEFINE_MOCK_METHOD(put_ExcludedPermissions)

		VSL_CHECK_VALIDVALUE_BSTR(ExcludedPermissions);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ManifestCertificateThumbprintValidValues
	{
		/*[out,retval]*/ BSTR* pbstrManifestCertificateThumbprint;
		HRESULT retValue;
	};

	STDMETHOD(get_ManifestCertificateThumbprint)(
		/*[out,retval]*/ BSTR* pbstrManifestCertificateThumbprint)
	{
		VSL_DEFINE_MOCK_METHOD(get_ManifestCertificateThumbprint)

		VSL_SET_VALIDVALUE_BSTR(pbstrManifestCertificateThumbprint);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_ManifestCertificateThumbprintValidValues
	{
		/*[in]*/ BSTR ManifestCertificateThumbprint;
		HRESULT retValue;
	};

	STDMETHOD(put_ManifestCertificateThumbprint)(
		/*[in]*/ BSTR ManifestCertificateThumbprint)
	{
		VSL_DEFINE_MOCK_METHOD(put_ManifestCertificateThumbprint)

		VSL_CHECK_VALIDVALUE_BSTR(ManifestCertificateThumbprint);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ManifestKeyFileValidValues
	{
		/*[out,retval]*/ BSTR* pbstrManifestKeyFile;
		HRESULT retValue;
	};

	STDMETHOD(get_ManifestKeyFile)(
		/*[out,retval]*/ BSTR* pbstrManifestKeyFile)
	{
		VSL_DEFINE_MOCK_METHOD(get_ManifestKeyFile)

		VSL_SET_VALIDVALUE_BSTR(pbstrManifestKeyFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_ManifestKeyFileValidValues
	{
		/*[in]*/ BSTR ManifestKeyFile;
		HRESULT retValue;
	};

	STDMETHOD(put_ManifestKeyFile)(
		/*[in]*/ BSTR ManifestKeyFile)
	{
		VSL_DEFINE_MOCK_METHOD(put_ManifestKeyFile)

		VSL_CHECK_VALIDVALUE_BSTR(ManifestKeyFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ManifestTimestampUrlValidValues
	{
		/*[out,retval]*/ BSTR* pbstrManifestTimestampUrl;
		HRESULT retValue;
	};

	STDMETHOD(get_ManifestTimestampUrl)(
		/*[out,retval]*/ BSTR* pbstrManifestTimestampUrl)
	{
		VSL_DEFINE_MOCK_METHOD(get_ManifestTimestampUrl)

		VSL_SET_VALIDVALUE_BSTR(pbstrManifestTimestampUrl);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_ManifestTimestampUrlValidValues
	{
		/*[in]*/ BSTR ManifestTimestampUrl;
		HRESULT retValue;
	};

	STDMETHOD(put_ManifestTimestampUrl)(
		/*[in]*/ BSTR ManifestTimestampUrl)
	{
		VSL_DEFINE_MOCK_METHOD(put_ManifestTimestampUrl)

		VSL_CHECK_VALIDVALUE_BSTR(ManifestTimestampUrl);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_PreBuildEventValidValues
	{
		/*[out,retval]*/ BSTR* pbstrOut;
		HRESULT retValue;
	};

	STDMETHOD(get_PreBuildEvent)(
		/*[out,retval]*/ BSTR* pbstrOut)
	{
		VSL_DEFINE_MOCK_METHOD(get_PreBuildEvent)

		VSL_SET_VALIDVALUE_BSTR(pbstrOut);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_PreBuildEventValidValues
	{
		/*[in]*/ BSTR bstrIn;
		HRESULT retValue;
	};

	STDMETHOD(put_PreBuildEvent)(
		/*[in]*/ BSTR bstrIn)
	{
		VSL_DEFINE_MOCK_METHOD(put_PreBuildEvent)

		VSL_CHECK_VALIDVALUE_BSTR(bstrIn);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_PostBuildEventValidValues
	{
		/*[out,retval]*/ BSTR* pbstrOut;
		HRESULT retValue;
	};

	STDMETHOD(get_PostBuildEvent)(
		/*[out,retval]*/ BSTR* pbstrOut)
	{
		VSL_DEFINE_MOCK_METHOD(get_PostBuildEvent)

		VSL_SET_VALIDVALUE_BSTR(pbstrOut);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_PostBuildEventValidValues
	{
		/*[in]*/ BSTR bstrIn;
		HRESULT retValue;
	};

	STDMETHOD(put_PostBuildEvent)(
		/*[in]*/ BSTR bstrIn)
	{
		VSL_DEFINE_MOCK_METHOD(put_PostBuildEvent)

		VSL_CHECK_VALIDVALUE_BSTR(bstrIn);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_RunPostBuildEventValidValues
	{
		/*[out,retval]*/ prjRunPostBuildEvent* pOut;
		HRESULT retValue;
	};

	STDMETHOD(get_RunPostBuildEvent)(
		/*[out,retval]*/ prjRunPostBuildEvent* pOut)
	{
		VSL_DEFINE_MOCK_METHOD(get_RunPostBuildEvent)

		VSL_SET_VALIDVALUE(pOut);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_RunPostBuildEventValidValues
	{
		/*[in]*/ prjRunPostBuildEvent run;
		HRESULT retValue;
	};

	STDMETHOD(put_RunPostBuildEvent)(
		/*[in]*/ prjRunPostBuildEvent run)
	{
		VSL_DEFINE_MOCK_METHOD(put_RunPostBuildEvent)

		VSL_CHECK_VALIDVALUE(run);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_AspnetVersionValidValues
	{
		/*[out,retval]*/ BSTR* pOut;
		HRESULT retValue;
	};

	STDMETHOD(get_AspnetVersion)(
		/*[out,retval]*/ BSTR* pOut)
	{
		VSL_DEFINE_MOCK_METHOD(get_AspnetVersion)

		VSL_SET_VALIDVALUE_BSTR(pOut);

		VSL_RETURN_VALIDVALUES();
	}
	struct get___idValidValues
	{
		/*[out,retval]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(get___id)(
		/*[out,retval]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(get___id)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get___projectValidValues
	{
		/*[out,retval]*/ IUnknown** ppUnk;
		HRESULT retValue;
	};

	STDMETHOD(get___project)(
		/*[out,retval]*/ IUnknown** ppUnk)
	{
		VSL_DEFINE_MOCK_METHOD(get___project)

		VSL_SET_VALIDVALUE_INTERFACE(ppUnk);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_StartupObjectValidValues
	{
		/*[out,retval]*/ BSTR* pbstrStartupObject;
		HRESULT retValue;
	};

	STDMETHOD(get_StartupObject)(
		/*[out,retval]*/ BSTR* pbstrStartupObject)
	{
		VSL_DEFINE_MOCK_METHOD(get_StartupObject)

		VSL_SET_VALIDVALUE_BSTR(pbstrStartupObject);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_StartupObjectValidValues
	{
		/*[in]*/ BSTR bstrStartupObject;
		HRESULT retValue;
	};

	STDMETHOD(put_StartupObject)(
		/*[in]*/ BSTR bstrStartupObject)
	{
		VSL_DEFINE_MOCK_METHOD(put_StartupObject)

		VSL_CHECK_VALIDVALUE_BSTR(bstrStartupObject);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_OutputTypeValidValues
	{
		/*[out,retval]*/ prjOutputType* pOutputType;
		HRESULT retValue;
	};

	STDMETHOD(get_OutputType)(
		/*[out,retval]*/ prjOutputType* pOutputType)
	{
		VSL_DEFINE_MOCK_METHOD(get_OutputType)

		VSL_SET_VALIDVALUE(pOutputType);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_OutputTypeValidValues
	{
		/*[in]*/ prjOutputType outputType;
		HRESULT retValue;
	};

	STDMETHOD(put_OutputType)(
		/*[in]*/ prjOutputType outputType)
	{
		VSL_DEFINE_MOCK_METHOD(put_OutputType)

		VSL_CHECK_VALIDVALUE(outputType);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_RootNamespaceValidValues
	{
		/*[out,retval]*/ BSTR* pbstrRootNamespace;
		HRESULT retValue;
	};

	STDMETHOD(get_RootNamespace)(
		/*[out,retval]*/ BSTR* pbstrRootNamespace)
	{
		VSL_DEFINE_MOCK_METHOD(get_RootNamespace)

		VSL_SET_VALIDVALUE_BSTR(pbstrRootNamespace);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_RootNamespaceValidValues
	{
		/*[in]*/ BSTR bstrRootNamespace;
		HRESULT retValue;
	};

	STDMETHOD(put_RootNamespace)(
		/*[in]*/ BSTR bstrRootNamespace)
	{
		VSL_DEFINE_MOCK_METHOD(put_RootNamespace)

		VSL_CHECK_VALIDVALUE_BSTR(bstrRootNamespace);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_AssemblyNameValidValues
	{
		/*[out,retval]*/ BSTR* pbstrAssemblyName;
		HRESULT retValue;
	};

	STDMETHOD(get_AssemblyName)(
		/*[out,retval]*/ BSTR* pbstrAssemblyName)
	{
		VSL_DEFINE_MOCK_METHOD(get_AssemblyName)

		VSL_SET_VALIDVALUE_BSTR(pbstrAssemblyName);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_AssemblyNameValidValues
	{
		/*[in]*/ BSTR bstrAssemblyName;
		HRESULT retValue;
	};

	STDMETHOD(put_AssemblyName)(
		/*[in]*/ BSTR bstrAssemblyName)
	{
		VSL_DEFINE_MOCK_METHOD(put_AssemblyName)

		VSL_CHECK_VALIDVALUE_BSTR(bstrAssemblyName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_AssemblyOriginatorKeyFileValidValues
	{
		/*[out,retval]*/ BSTR* pbstrOriginatorKeyFile;
		HRESULT retValue;
	};

	STDMETHOD(get_AssemblyOriginatorKeyFile)(
		/*[out,retval]*/ BSTR* pbstrOriginatorKeyFile)
	{
		VSL_DEFINE_MOCK_METHOD(get_AssemblyOriginatorKeyFile)

		VSL_SET_VALIDVALUE_BSTR(pbstrOriginatorKeyFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_AssemblyOriginatorKeyFileValidValues
	{
		/*[in]*/ BSTR bstrOriginatorKeyFile;
		HRESULT retValue;
	};

	STDMETHOD(put_AssemblyOriginatorKeyFile)(
		/*[in]*/ BSTR bstrOriginatorKeyFile)
	{
		VSL_DEFINE_MOCK_METHOD(put_AssemblyOriginatorKeyFile)

		VSL_CHECK_VALIDVALUE_BSTR(bstrOriginatorKeyFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_AssemblyKeyContainerNameValidValues
	{
		/*[out,retval]*/ BSTR* pbstrKeyContainerName;
		HRESULT retValue;
	};

	STDMETHOD(get_AssemblyKeyContainerName)(
		/*[out,retval]*/ BSTR* pbstrKeyContainerName)
	{
		VSL_DEFINE_MOCK_METHOD(get_AssemblyKeyContainerName)

		VSL_SET_VALIDVALUE_BSTR(pbstrKeyContainerName);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_AssemblyKeyContainerNameValidValues
	{
		/*[in]*/ BSTR bstrKeyContainerName;
		HRESULT retValue;
	};

	STDMETHOD(put_AssemblyKeyContainerName)(
		/*[in]*/ BSTR bstrKeyContainerName)
	{
		VSL_DEFINE_MOCK_METHOD(put_AssemblyKeyContainerName)

		VSL_CHECK_VALIDVALUE_BSTR(bstrKeyContainerName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_AssemblyOriginatorKeyModeValidValues
	{
		/*[out,retval]*/ prjOriginatorKeyMode* pOriginatorKeyMode;
		HRESULT retValue;
	};

	STDMETHOD(get_AssemblyOriginatorKeyMode)(
		/*[out,retval]*/ prjOriginatorKeyMode* pOriginatorKeyMode)
	{
		VSL_DEFINE_MOCK_METHOD(get_AssemblyOriginatorKeyMode)

		VSL_SET_VALIDVALUE(pOriginatorKeyMode);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_AssemblyOriginatorKeyModeValidValues
	{
		/*[in]*/ prjOriginatorKeyMode originatorKeyMode;
		HRESULT retValue;
	};

	STDMETHOD(put_AssemblyOriginatorKeyMode)(
		/*[in]*/ prjOriginatorKeyMode originatorKeyMode)
	{
		VSL_DEFINE_MOCK_METHOD(put_AssemblyOriginatorKeyMode)

		VSL_CHECK_VALIDVALUE(originatorKeyMode);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DelaySignValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbDelaySign;
		HRESULT retValue;
	};

	STDMETHOD(get_DelaySign)(
		/*[out,retval]*/ VARIANT_BOOL* pbDelaySign)
	{
		VSL_DEFINE_MOCK_METHOD(get_DelaySign)

		VSL_SET_VALIDVALUE(pbDelaySign);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DelaySignValidValues
	{
		/*[in]*/ VARIANT_BOOL bDelaySign;
		HRESULT retValue;
	};

	STDMETHOD(put_DelaySign)(
		/*[in]*/ VARIANT_BOOL bDelaySign)
	{
		VSL_DEFINE_MOCK_METHOD(put_DelaySign)

		VSL_CHECK_VALIDVALUE(bDelaySign);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_WebServerValidValues
	{
		/*[out,retval]*/ BSTR* pbstrWebServer;
		HRESULT retValue;
	};

	STDMETHOD(get_WebServer)(
		/*[out,retval]*/ BSTR* pbstrWebServer)
	{
		VSL_DEFINE_MOCK_METHOD(get_WebServer)

		VSL_SET_VALIDVALUE_BSTR(pbstrWebServer);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_WebServerVersionValidValues
	{
		/*[out,retval]*/ BSTR* pbstrWebServerVersion;
		HRESULT retValue;
	};

	STDMETHOD(get_WebServerVersion)(
		/*[out,retval]*/ BSTR* pbstrWebServerVersion)
	{
		VSL_DEFINE_MOCK_METHOD(get_WebServerVersion)

		VSL_SET_VALIDVALUE_BSTR(pbstrWebServerVersion);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ServerExtensionsVersionValidValues
	{
		/*[out,retval]*/ BSTR* pbstrServerExtensionsVersion;
		HRESULT retValue;
	};

	STDMETHOD(get_ServerExtensionsVersion)(
		/*[out,retval]*/ BSTR* pbstrServerExtensionsVersion)
	{
		VSL_DEFINE_MOCK_METHOD(get_ServerExtensionsVersion)

		VSL_SET_VALIDVALUE_BSTR(pbstrServerExtensionsVersion);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_LinkRepairValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pLinkRepair;
		HRESULT retValue;
	};

	STDMETHOD(get_LinkRepair)(
		/*[out,retval]*/ VARIANT_BOOL* pLinkRepair)
	{
		VSL_DEFINE_MOCK_METHOD(get_LinkRepair)

		VSL_SET_VALIDVALUE(pLinkRepair);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_LinkRepairValidValues
	{
		/*[in]*/ VARIANT_BOOL linkRepair;
		HRESULT retValue;
	};

	STDMETHOD(put_LinkRepair)(
		/*[in]*/ VARIANT_BOOL linkRepair)
	{
		VSL_DEFINE_MOCK_METHOD(put_LinkRepair)

		VSL_CHECK_VALIDVALUE(linkRepair);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_OfflineURLValidValues
	{
		/*[out,retval]*/ BSTR* pbstrOfflineURL;
		HRESULT retValue;
	};

	STDMETHOD(get_OfflineURL)(
		/*[out,retval]*/ BSTR* pbstrOfflineURL)
	{
		VSL_DEFINE_MOCK_METHOD(get_OfflineURL)

		VSL_SET_VALIDVALUE_BSTR(pbstrOfflineURL);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_FileSharePathValidValues
	{
		/*[out,retval]*/ BSTR* pbstrFileSharePath;
		HRESULT retValue;
	};

	STDMETHOD(get_FileSharePath)(
		/*[out,retval]*/ BSTR* pbstrFileSharePath)
	{
		VSL_DEFINE_MOCK_METHOD(get_FileSharePath)

		VSL_SET_VALIDVALUE_BSTR(pbstrFileSharePath);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_FileSharePathValidValues
	{
		/*[in]*/ BSTR bstrFileSharePath;
		HRESULT retValue;
	};

	STDMETHOD(put_FileSharePath)(
		/*[in]*/ BSTR bstrFileSharePath)
	{
		VSL_DEFINE_MOCK_METHOD(put_FileSharePath)

		VSL_CHECK_VALIDVALUE_BSTR(bstrFileSharePath);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ActiveFileSharePathValidValues
	{
		/*[out,retval]*/ BSTR* pbstrFileSharePath;
		HRESULT retValue;
	};

	STDMETHOD(get_ActiveFileSharePath)(
		/*[out,retval]*/ BSTR* pbstrFileSharePath)
	{
		VSL_DEFINE_MOCK_METHOD(get_ActiveFileSharePath)

		VSL_SET_VALIDVALUE_BSTR(pbstrFileSharePath);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_WebAccessMethodValidValues
	{
		/*[out,retval]*/ prjWebAccessMethod* pWebAccessMethod;
		HRESULT retValue;
	};

	STDMETHOD(get_WebAccessMethod)(
		/*[out,retval]*/ prjWebAccessMethod* pWebAccessMethod)
	{
		VSL_DEFINE_MOCK_METHOD(get_WebAccessMethod)

		VSL_SET_VALIDVALUE(pWebAccessMethod);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_WebAccessMethodValidValues
	{
		/*[in]*/ prjWebAccessMethod authoringAccessMethod;
		HRESULT retValue;
	};

	STDMETHOD(put_WebAccessMethod)(
		/*[in]*/ prjWebAccessMethod authoringAccessMethod)
	{
		VSL_DEFINE_MOCK_METHOD(put_WebAccessMethod)

		VSL_CHECK_VALIDVALUE(authoringAccessMethod);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ActiveWebAccessMethodValidValues
	{
		/*[out,retval]*/ prjWebAccessMethod* pActiveWebAccessMethod;
		HRESULT retValue;
	};

	STDMETHOD(get_ActiveWebAccessMethod)(
		/*[out,retval]*/ prjWebAccessMethod* pActiveWebAccessMethod)
	{
		VSL_DEFINE_MOCK_METHOD(get_ActiveWebAccessMethod)

		VSL_SET_VALIDVALUE(pActiveWebAccessMethod);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DefaultClientScriptValidValues
	{
		/*[out,retval]*/ prjScriptLanguage* pScriptLanguage;
		HRESULT retValue;
	};

	STDMETHOD(get_DefaultClientScript)(
		/*[out,retval]*/ prjScriptLanguage* pScriptLanguage)
	{
		VSL_DEFINE_MOCK_METHOD(get_DefaultClientScript)

		VSL_SET_VALIDVALUE(pScriptLanguage);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DefaultClientScriptValidValues
	{
		/*[in]*/ prjScriptLanguage scriptLanguage;
		HRESULT retValue;
	};

	STDMETHOD(put_DefaultClientScript)(
		/*[in]*/ prjScriptLanguage scriptLanguage)
	{
		VSL_DEFINE_MOCK_METHOD(put_DefaultClientScript)

		VSL_CHECK_VALIDVALUE(scriptLanguage);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DefaultTargetSchemaValidValues
	{
		/*[out,retval]*/ prjTargetSchema* pTargetSchema;
		HRESULT retValue;
	};

	STDMETHOD(get_DefaultTargetSchema)(
		/*[out,retval]*/ prjTargetSchema* pTargetSchema)
	{
		VSL_DEFINE_MOCK_METHOD(get_DefaultTargetSchema)

		VSL_SET_VALIDVALUE(pTargetSchema);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DefaultTargetSchemaValidValues
	{
		/*[in]*/ prjTargetSchema htmlPlatform;
		HRESULT retValue;
	};

	STDMETHOD(put_DefaultTargetSchema)(
		/*[in]*/ prjTargetSchema htmlPlatform)
	{
		VSL_DEFINE_MOCK_METHOD(put_DefaultTargetSchema)

		VSL_CHECK_VALIDVALUE(htmlPlatform);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DefaultHTMLPageLayoutValidValues
	{
		/*[out,retval]*/ prjHTMLPageLayout* pHTMLPageLayout;
		HRESULT retValue;
	};

	STDMETHOD(get_DefaultHTMLPageLayout)(
		/*[out,retval]*/ prjHTMLPageLayout* pHTMLPageLayout)
	{
		VSL_DEFINE_MOCK_METHOD(get_DefaultHTMLPageLayout)

		VSL_SET_VALIDVALUE(pHTMLPageLayout);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DefaultHTMLPageLayoutValidValues
	{
		/*[in]*/ prjHTMLPageLayout htmlPageLayout;
		HRESULT retValue;
	};

	STDMETHOD(put_DefaultHTMLPageLayout)(
		/*[in]*/ prjHTMLPageLayout htmlPageLayout)
	{
		VSL_DEFINE_MOCK_METHOD(put_DefaultHTMLPageLayout)

		VSL_CHECK_VALIDVALUE(htmlPageLayout);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_FileNameValidValues
	{
		/*[out,retval]*/ BSTR* pbstrFileName;
		HRESULT retValue;
	};

	STDMETHOD(get_FileName)(
		/*[out,retval]*/ BSTR* pbstrFileName)
	{
		VSL_DEFINE_MOCK_METHOD(get_FileName)

		VSL_SET_VALIDVALUE_BSTR(pbstrFileName);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_FileNameValidValues
	{
		/*[in]*/ BSTR bstrFileName;
		HRESULT retValue;
	};

	STDMETHOD(put_FileName)(
		/*[in]*/ BSTR bstrFileName)
	{
		VSL_DEFINE_MOCK_METHOD(put_FileName)

		VSL_CHECK_VALIDVALUE_BSTR(bstrFileName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_FullPathValidValues
	{
		/*[out,retval]*/ BSTR* pbstrFullPath;
		HRESULT retValue;
	};

	STDMETHOD(get_FullPath)(
		/*[out,retval]*/ BSTR* pbstrFullPath)
	{
		VSL_DEFINE_MOCK_METHOD(get_FullPath)

		VSL_SET_VALIDVALUE_BSTR(pbstrFullPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_LocalPathValidValues
	{
		/*[out,retval]*/ BSTR* pbstrLocalPath;
		HRESULT retValue;
	};

	STDMETHOD(get_LocalPath)(
		/*[out,retval]*/ BSTR* pbstrLocalPath)
	{
		VSL_DEFINE_MOCK_METHOD(get_LocalPath)

		VSL_SET_VALIDVALUE_BSTR(pbstrLocalPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_URLValidValues
	{
		/*[out,retval]*/ BSTR* pbstrURL;
		HRESULT retValue;
	};

	STDMETHOD(get_URL)(
		/*[out,retval]*/ BSTR* pbstrURL)
	{
		VSL_DEFINE_MOCK_METHOD(get_URL)

		VSL_SET_VALIDVALUE_BSTR(pbstrURL);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ActiveConfigurationSettingsValidValues
	{
		/*[out,retval]*/ ProjectConfigurationProperties** ppVBProjConfigProps;
		HRESULT retValue;
	};

	STDMETHOD(get_ActiveConfigurationSettings)(
		/*[out,retval]*/ ProjectConfigurationProperties** ppVBProjConfigProps)
	{
		VSL_DEFINE_MOCK_METHOD(get_ActiveConfigurationSettings)

		VSL_SET_VALIDVALUE_INTERFACE(ppVBProjConfigProps);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderValidValues
	{
		/*[in]*/ BSTR ExtenderName;
		/*[out,retval]*/ IDispatch** Extender;
		HRESULT retValue;
	};

	STDMETHOD(get_Extender)(
		/*[in]*/ BSTR ExtenderName,
		/*[out,retval]*/ IDispatch** Extender)
	{
		VSL_DEFINE_MOCK_METHOD(get_Extender)

		VSL_CHECK_VALIDVALUE_BSTR(ExtenderName);

		VSL_SET_VALIDVALUE_INTERFACE(Extender);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderNamesValidValues
	{
		/*[out,retval]*/ VARIANT* ExtenderNames;
		HRESULT retValue;
	};

	STDMETHOD(get_ExtenderNames)(
		/*[out,retval]*/ VARIANT* ExtenderNames)
	{
		VSL_DEFINE_MOCK_METHOD(get_ExtenderNames)

		VSL_SET_VALIDVALUE_VARIANT(ExtenderNames);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderCATIDValidValues
	{
		/*[out,retval]*/ BSTR* pRetval;
		HRESULT retValue;
	};

	STDMETHOD(get_ExtenderCATID)(
		/*[out,retval]*/ BSTR* pRetval)
	{
		VSL_DEFINE_MOCK_METHOD(get_ExtenderCATID)

		VSL_SET_VALIDVALUE_BSTR(pRetval);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ApplicationIconValidValues
	{
		/*[out,retval]*/ BSTR* pbstrApplicationIcon;
		HRESULT retValue;
	};

	STDMETHOD(get_ApplicationIcon)(
		/*[out,retval]*/ BSTR* pbstrApplicationIcon)
	{
		VSL_DEFINE_MOCK_METHOD(get_ApplicationIcon)

		VSL_SET_VALIDVALUE_BSTR(pbstrApplicationIcon);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_ApplicationIconValidValues
	{
		/*[in]*/ BSTR bstrApplicationIcon;
		HRESULT retValue;
	};

	STDMETHOD(put_ApplicationIcon)(
		/*[in]*/ BSTR bstrApplicationIcon)
	{
		VSL_DEFINE_MOCK_METHOD(put_ApplicationIcon)

		VSL_CHECK_VALIDVALUE_BSTR(bstrApplicationIcon);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_OptionStrictValidValues
	{
		/*[out,retval]*/ prjOptionStrict* pOptionStrict;
		HRESULT retValue;
	};

	STDMETHOD(get_OptionStrict)(
		/*[out,retval]*/ prjOptionStrict* pOptionStrict)
	{
		VSL_DEFINE_MOCK_METHOD(get_OptionStrict)

		VSL_SET_VALIDVALUE(pOptionStrict);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_OptionStrictValidValues
	{
		/*[in]*/ prjOptionStrict optionStrict;
		HRESULT retValue;
	};

	STDMETHOD(put_OptionStrict)(
		/*[in]*/ prjOptionStrict optionStrict)
	{
		VSL_DEFINE_MOCK_METHOD(put_OptionStrict)

		VSL_CHECK_VALIDVALUE(optionStrict);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ReferencePathValidValues
	{
		/*[out,retval]*/ BSTR* pbstrReferencePath;
		HRESULT retValue;
	};

	STDMETHOD(get_ReferencePath)(
		/*[out,retval]*/ BSTR* pbstrReferencePath)
	{
		VSL_DEFINE_MOCK_METHOD(get_ReferencePath)

		VSL_SET_VALIDVALUE_BSTR(pbstrReferencePath);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_ReferencePathValidValues
	{
		/*[in]*/ BSTR bstrReferencePath;
		HRESULT retValue;
	};

	STDMETHOD(put_ReferencePath)(
		/*[in]*/ BSTR bstrReferencePath)
	{
		VSL_DEFINE_MOCK_METHOD(put_ReferencePath)

		VSL_CHECK_VALIDVALUE_BSTR(bstrReferencePath);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_OutputFileNameValidValues
	{
		/*[out,retval]*/ BSTR* pbstrOutputFileName;
		HRESULT retValue;
	};

	STDMETHOD(get_OutputFileName)(
		/*[out,retval]*/ BSTR* pbstrOutputFileName)
	{
		VSL_DEFINE_MOCK_METHOD(get_OutputFileName)

		VSL_SET_VALIDVALUE_BSTR(pbstrOutputFileName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_AbsoluteProjectDirectoryValidValues
	{
		/*[out,retval]*/ BSTR* pbstrDir;
		HRESULT retValue;
	};

	STDMETHOD(get_AbsoluteProjectDirectory)(
		/*[out,retval]*/ BSTR* pbstrDir)
	{
		VSL_DEFINE_MOCK_METHOD(get_AbsoluteProjectDirectory)

		VSL_SET_VALIDVALUE_BSTR(pbstrDir);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_OptionExplicitValidValues
	{
		/*[out,retval]*/ prjOptionExplicit* pOptionExplicit;
		HRESULT retValue;
	};

	STDMETHOD(get_OptionExplicit)(
		/*[out,retval]*/ prjOptionExplicit* pOptionExplicit)
	{
		VSL_DEFINE_MOCK_METHOD(get_OptionExplicit)

		VSL_SET_VALIDVALUE(pOptionExplicit);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_OptionExplicitValidValues
	{
		/*[in]*/ prjOptionExplicit optionExplicit;
		HRESULT retValue;
	};

	STDMETHOD(put_OptionExplicit)(
		/*[in]*/ prjOptionExplicit optionExplicit)
	{
		VSL_DEFINE_MOCK_METHOD(put_OptionExplicit)

		VSL_CHECK_VALIDVALUE(optionExplicit);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_OptionCompareValidValues
	{
		/*[out,retval]*/ prjCompare* pOptionCompare;
		HRESULT retValue;
	};

	STDMETHOD(get_OptionCompare)(
		/*[out,retval]*/ prjCompare* pOptionCompare)
	{
		VSL_DEFINE_MOCK_METHOD(get_OptionCompare)

		VSL_SET_VALIDVALUE(pOptionCompare);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_OptionCompareValidValues
	{
		/*[in]*/ prjCompare optionCompare;
		HRESULT retValue;
	};

	STDMETHOD(put_OptionCompare)(
		/*[in]*/ prjCompare optionCompare)
	{
		VSL_DEFINE_MOCK_METHOD(put_OptionCompare)

		VSL_CHECK_VALIDVALUE(optionCompare);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ProjectTypeValidValues
	{
		/*[out,retval]*/ prjProjectType* pProjectType;
		HRESULT retValue;
	};

	STDMETHOD(get_ProjectType)(
		/*[out,retval]*/ prjProjectType* pProjectType)
	{
		VSL_DEFINE_MOCK_METHOD(get_ProjectType)

		VSL_SET_VALIDVALUE(pProjectType);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DefaultNamespaceValidValues
	{
		/*[out,retval]*/ BSTR* pbstrRootNamespace;
		HRESULT retValue;
	};

	STDMETHOD(get_DefaultNamespace)(
		/*[out,retval]*/ BSTR* pbstrRootNamespace)
	{
		VSL_DEFINE_MOCK_METHOD(get_DefaultNamespace)

		VSL_SET_VALIDVALUE_BSTR(pbstrRootNamespace);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DefaultNamespaceValidValues
	{
		/*[in]*/ BSTR bstrRootNamespace;
		HRESULT retValue;
	};

	STDMETHOD(put_DefaultNamespace)(
		/*[in]*/ BSTR bstrRootNamespace)
	{
		VSL_DEFINE_MOCK_METHOD(put_DefaultNamespace)

		VSL_CHECK_VALIDVALUE_BSTR(bstrRootNamespace);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // PROJECTPROPERTIES3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockReference2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef REFERENCE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define REFERENCE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vslangproj2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class Reference2NotImpl :
	public Reference2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(Reference2NotImpl)

public:

	typedef Reference2 Interface;

	STDMETHOD(get_RuntimeVersion)(
		/*[out,retval]*/ BSTR* /*pbstrVersion*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DTE)(
		/*[out,retval]*/ DTE** /*ppDTE*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Collection)(
		/*[out,retval]*/ References** /*ppProjectReferences*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ContainingProject)(
		/*[out,retval]*/ Project** /*ppProject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Remove)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Name)(
		/*[out,retval]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Type)(
		/*[out,retval]*/ prjReferenceType* /*pType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Identity)(
		/*[out,retval]*/ BSTR* /*pbstrIdentity*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Path)(
		/*[out,retval]*/ BSTR* /*pbstrPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Description)(
		/*[out,retval]*/ BSTR* /*pbstrDesc*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Culture)(
		/*[out,retval]*/ BSTR* /*pbstrCulture*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_MajorVersion)(
		/*[out,retval]*/ long* /*plMajorVer*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_MinorVersion)(
		/*[out,retval]*/ long* /*plMinorVer*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_RevisionNumber)(
		/*[out,retval]*/ long* /*plRevNo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_BuildNumber)(
		/*[out,retval]*/ long* /*plBuildNo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_StrongName)(
		/*[out,retval]*/ VARIANT_BOOL* /*pfStrongName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_SourceProject)(
		/*[out,retval]*/ Project** /*ppProject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CopyLocal)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbCopyLocal*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_CopyLocal)(
		/*[in]*/ VARIANT_BOOL /*bCopyLocal*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Extender)(
		/*[in]*/ BSTR /*ExtenderName*/,
		/*[out,retval]*/ IDispatch** /*Extender*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ExtenderNames)(
		/*[out,retval]*/ VARIANT* /*ExtenderNames*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ExtenderCATID)(
		/*[out,retval]*/ BSTR* /*pRetval*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_PublicKeyToken)(
		/*[out,retval]*/ BSTR* /*pbstrPublicKeyToken*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Version)(
		/*[out,retval]*/ BSTR* /*pbstrVersion*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class Reference2MockImpl :
	public Reference2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(Reference2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(Reference2MockImpl)

	typedef Reference2 Interface;
	struct get_RuntimeVersionValidValues
	{
		/*[out,retval]*/ BSTR* pbstrVersion;
		HRESULT retValue;
	};

	STDMETHOD(get_RuntimeVersion)(
		/*[out,retval]*/ BSTR* pbstrVersion)
	{
		VSL_DEFINE_MOCK_METHOD(get_RuntimeVersion)

		VSL_SET_VALIDVALUE_BSTR(pbstrVersion);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DTEValidValues
	{
		/*[out,retval]*/ DTE** ppDTE;
		HRESULT retValue;
	};

	STDMETHOD(get_DTE)(
		/*[out,retval]*/ DTE** ppDTE)
	{
		VSL_DEFINE_MOCK_METHOD(get_DTE)

		VSL_SET_VALIDVALUE(ppDTE);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CollectionValidValues
	{
		/*[out,retval]*/ References** ppProjectReferences;
		HRESULT retValue;
	};

	STDMETHOD(get_Collection)(
		/*[out,retval]*/ References** ppProjectReferences)
	{
		VSL_DEFINE_MOCK_METHOD(get_Collection)

		VSL_SET_VALIDVALUE_INTERFACE(ppProjectReferences);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ContainingProjectValidValues
	{
		/*[out,retval]*/ Project** ppProject;
		HRESULT retValue;
	};

	STDMETHOD(get_ContainingProject)(
		/*[out,retval]*/ Project** ppProject)
	{
		VSL_DEFINE_MOCK_METHOD(get_ContainingProject)

		VSL_SET_VALIDVALUE(ppProject);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Remove)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Remove)

		VSL_RETURN_VALIDVALUES();
	}
	struct get_NameValidValues
	{
		/*[out,retval]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(get_Name)(
		/*[out,retval]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(get_Name)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_TypeValidValues
	{
		/*[out,retval]*/ prjReferenceType* pType;
		HRESULT retValue;
	};

	STDMETHOD(get_Type)(
		/*[out,retval]*/ prjReferenceType* pType)
	{
		VSL_DEFINE_MOCK_METHOD(get_Type)

		VSL_SET_VALIDVALUE(pType);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IdentityValidValues
	{
		/*[out,retval]*/ BSTR* pbstrIdentity;
		HRESULT retValue;
	};

	STDMETHOD(get_Identity)(
		/*[out,retval]*/ BSTR* pbstrIdentity)
	{
		VSL_DEFINE_MOCK_METHOD(get_Identity)

		VSL_SET_VALIDVALUE_BSTR(pbstrIdentity);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_PathValidValues
	{
		/*[out,retval]*/ BSTR* pbstrPath;
		HRESULT retValue;
	};

	STDMETHOD(get_Path)(
		/*[out,retval]*/ BSTR* pbstrPath)
	{
		VSL_DEFINE_MOCK_METHOD(get_Path)

		VSL_SET_VALIDVALUE_BSTR(pbstrPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DescriptionValidValues
	{
		/*[out,retval]*/ BSTR* pbstrDesc;
		HRESULT retValue;
	};

	STDMETHOD(get_Description)(
		/*[out,retval]*/ BSTR* pbstrDesc)
	{
		VSL_DEFINE_MOCK_METHOD(get_Description)

		VSL_SET_VALIDVALUE_BSTR(pbstrDesc);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CultureValidValues
	{
		/*[out,retval]*/ BSTR* pbstrCulture;
		HRESULT retValue;
	};

	STDMETHOD(get_Culture)(
		/*[out,retval]*/ BSTR* pbstrCulture)
	{
		VSL_DEFINE_MOCK_METHOD(get_Culture)

		VSL_SET_VALIDVALUE_BSTR(pbstrCulture);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_MajorVersionValidValues
	{
		/*[out,retval]*/ long* plMajorVer;
		HRESULT retValue;
	};

	STDMETHOD(get_MajorVersion)(
		/*[out,retval]*/ long* plMajorVer)
	{
		VSL_DEFINE_MOCK_METHOD(get_MajorVersion)

		VSL_SET_VALIDVALUE(plMajorVer);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_MinorVersionValidValues
	{
		/*[out,retval]*/ long* plMinorVer;
		HRESULT retValue;
	};

	STDMETHOD(get_MinorVersion)(
		/*[out,retval]*/ long* plMinorVer)
	{
		VSL_DEFINE_MOCK_METHOD(get_MinorVersion)

		VSL_SET_VALIDVALUE(plMinorVer);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_RevisionNumberValidValues
	{
		/*[out,retval]*/ long* plRevNo;
		HRESULT retValue;
	};

	STDMETHOD(get_RevisionNumber)(
		/*[out,retval]*/ long* plRevNo)
	{
		VSL_DEFINE_MOCK_METHOD(get_RevisionNumber)

		VSL_SET_VALIDVALUE(plRevNo);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_BuildNumberValidValues
	{
		/*[out,retval]*/ long* plBuildNo;
		HRESULT retValue;
	};

	STDMETHOD(get_BuildNumber)(
		/*[out,retval]*/ long* plBuildNo)
	{
		VSL_DEFINE_MOCK_METHOD(get_BuildNumber)

		VSL_SET_VALIDVALUE(plBuildNo);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_StrongNameValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pfStrongName;
		HRESULT retValue;
	};

	STDMETHOD(get_StrongName)(
		/*[out,retval]*/ VARIANT_BOOL* pfStrongName)
	{
		VSL_DEFINE_MOCK_METHOD(get_StrongName)

		VSL_SET_VALIDVALUE(pfStrongName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_SourceProjectValidValues
	{
		/*[out,retval]*/ Project** ppProject;
		HRESULT retValue;
	};

	STDMETHOD(get_SourceProject)(
		/*[out,retval]*/ Project** ppProject)
	{
		VSL_DEFINE_MOCK_METHOD(get_SourceProject)

		VSL_SET_VALIDVALUE(ppProject);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CopyLocalValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbCopyLocal;
		HRESULT retValue;
	};

	STDMETHOD(get_CopyLocal)(
		/*[out,retval]*/ VARIANT_BOOL* pbCopyLocal)
	{
		VSL_DEFINE_MOCK_METHOD(get_CopyLocal)

		VSL_SET_VALIDVALUE(pbCopyLocal);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_CopyLocalValidValues
	{
		/*[in]*/ VARIANT_BOOL bCopyLocal;
		HRESULT retValue;
	};

	STDMETHOD(put_CopyLocal)(
		/*[in]*/ VARIANT_BOOL bCopyLocal)
	{
		VSL_DEFINE_MOCK_METHOD(put_CopyLocal)

		VSL_CHECK_VALIDVALUE(bCopyLocal);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderValidValues
	{
		/*[in]*/ BSTR ExtenderName;
		/*[out,retval]*/ IDispatch** Extender;
		HRESULT retValue;
	};

	STDMETHOD(get_Extender)(
		/*[in]*/ BSTR ExtenderName,
		/*[out,retval]*/ IDispatch** Extender)
	{
		VSL_DEFINE_MOCK_METHOD(get_Extender)

		VSL_CHECK_VALIDVALUE_BSTR(ExtenderName);

		VSL_SET_VALIDVALUE_INTERFACE(Extender);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderNamesValidValues
	{
		/*[out,retval]*/ VARIANT* ExtenderNames;
		HRESULT retValue;
	};

	STDMETHOD(get_ExtenderNames)(
		/*[out,retval]*/ VARIANT* ExtenderNames)
	{
		VSL_DEFINE_MOCK_METHOD(get_ExtenderNames)

		VSL_SET_VALIDVALUE_VARIANT(ExtenderNames);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderCATIDValidValues
	{
		/*[out,retval]*/ BSTR* pRetval;
		HRESULT retValue;
	};

	STDMETHOD(get_ExtenderCATID)(
		/*[out,retval]*/ BSTR* pRetval)
	{
		VSL_DEFINE_MOCK_METHOD(get_ExtenderCATID)

		VSL_SET_VALIDVALUE_BSTR(pRetval);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_PublicKeyTokenValidValues
	{
		/*[out,retval]*/ BSTR* pbstrPublicKeyToken;
		HRESULT retValue;
	};

	STDMETHOD(get_PublicKeyToken)(
		/*[out,retval]*/ BSTR* pbstrPublicKeyToken)
	{
		VSL_DEFINE_MOCK_METHOD(get_PublicKeyToken)

		VSL_SET_VALIDVALUE_BSTR(pbstrPublicKeyToken);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_VersionValidValues
	{
		/*[out,retval]*/ BSTR* pbstrVersion;
		HRESULT retValue;
	};

	STDMETHOD(get_Version)(
		/*[out,retval]*/ BSTR* pbstrVersion)
	{
		VSL_DEFINE_MOCK_METHOD(get_Version)

		VSL_SET_VALIDVALUE_BSTR(pbstrVersion);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // REFERENCE2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockReference3.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef REFERENCE3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define REFERENCE3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vslangproj80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class Reference3NotImpl :
	public Reference3
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(Reference3NotImpl)

public:

	typedef Reference3 Interface;

	STDMETHOD(get_SpecificVersion)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbSpecificVersion*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_SpecificVersion)(
		/*[in]*/ VARIANT_BOOL /*SpecificVersion*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_SubType)(
		/*[out,retval]*/ BSTR* /*pbstrSubType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_SubType)(
		/*[in]*/ BSTR /*SubType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Isolated)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbIsolated*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_Isolated)(
		/*[in]*/ VARIANT_BOOL /*Isolated*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Aliases)(
		/*[out,retval]*/ BSTR* /*pbstrAliases*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_Aliases)(
		/*[in]*/ BSTR /*Aliases*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_RefType)(
		/*[out,retval]*/ PROJECTREFERENCETYPE* /*pProjRefType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_AutoReferenced)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbAutoReferenced*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Resolved)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbResolved*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_RuntimeVersion)(
		/*[out,retval]*/ BSTR* /*pbstrVersion*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DTE)(
		/*[out,retval]*/ DTE** /*ppDTE*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Collection)(
		/*[out,retval]*/ References** /*ppProjectReferences*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ContainingProject)(
		/*[out,retval]*/ Project** /*ppProject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Remove)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Name)(
		/*[out,retval]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Type)(
		/*[out,retval]*/ prjReferenceType* /*pType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Identity)(
		/*[out,retval]*/ BSTR* /*pbstrIdentity*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Path)(
		/*[out,retval]*/ BSTR* /*pbstrPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Description)(
		/*[out,retval]*/ BSTR* /*pbstrDesc*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Culture)(
		/*[out,retval]*/ BSTR* /*pbstrCulture*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_MajorVersion)(
		/*[out,retval]*/ long* /*plMajorVer*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_MinorVersion)(
		/*[out,retval]*/ long* /*plMinorVer*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_RevisionNumber)(
		/*[out,retval]*/ long* /*plRevNo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_BuildNumber)(
		/*[out,retval]*/ long* /*plBuildNo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_StrongName)(
		/*[out,retval]*/ VARIANT_BOOL* /*pfStrongName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_SourceProject)(
		/*[out,retval]*/ Project** /*ppProject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CopyLocal)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbCopyLocal*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_CopyLocal)(
		/*[in]*/ VARIANT_BOOL /*bCopyLocal*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Extender)(
		/*[in]*/ BSTR /*ExtenderName*/,
		/*[out,retval]*/ IDispatch** /*Extender*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ExtenderNames)(
		/*[out,retval]*/ VARIANT* /*ExtenderNames*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ExtenderCATID)(
		/*[out,retval]*/ BSTR* /*pRetval*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_PublicKeyToken)(
		/*[out,retval]*/ BSTR* /*pbstrPublicKeyToken*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Version)(
		/*[out,retval]*/ BSTR* /*pbstrVersion*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class Reference3MockImpl :
	public Reference3,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(Reference3MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(Reference3MockImpl)

	typedef Reference3 Interface;
	struct get_SpecificVersionValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbSpecificVersion;
		HRESULT retValue;
	};

	STDMETHOD(get_SpecificVersion)(
		/*[out,retval]*/ VARIANT_BOOL* pbSpecificVersion)
	{
		VSL_DEFINE_MOCK_METHOD(get_SpecificVersion)

		VSL_SET_VALIDVALUE(pbSpecificVersion);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_SpecificVersionValidValues
	{
		/*[in]*/ VARIANT_BOOL SpecificVersion;
		HRESULT retValue;
	};

	STDMETHOD(put_SpecificVersion)(
		/*[in]*/ VARIANT_BOOL SpecificVersion)
	{
		VSL_DEFINE_MOCK_METHOD(put_SpecificVersion)

		VSL_CHECK_VALIDVALUE(SpecificVersion);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_SubTypeValidValues
	{
		/*[out,retval]*/ BSTR* pbstrSubType;
		HRESULT retValue;
	};

	STDMETHOD(get_SubType)(
		/*[out,retval]*/ BSTR* pbstrSubType)
	{
		VSL_DEFINE_MOCK_METHOD(get_SubType)

		VSL_SET_VALIDVALUE_BSTR(pbstrSubType);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_SubTypeValidValues
	{
		/*[in]*/ BSTR SubType;
		HRESULT retValue;
	};

	STDMETHOD(put_SubType)(
		/*[in]*/ BSTR SubType)
	{
		VSL_DEFINE_MOCK_METHOD(put_SubType)

		VSL_CHECK_VALIDVALUE_BSTR(SubType);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IsolatedValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbIsolated;
		HRESULT retValue;
	};

	STDMETHOD(get_Isolated)(
		/*[out,retval]*/ VARIANT_BOOL* pbIsolated)
	{
		VSL_DEFINE_MOCK_METHOD(get_Isolated)

		VSL_SET_VALIDVALUE(pbIsolated);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_IsolatedValidValues
	{
		/*[in]*/ VARIANT_BOOL Isolated;
		HRESULT retValue;
	};

	STDMETHOD(put_Isolated)(
		/*[in]*/ VARIANT_BOOL Isolated)
	{
		VSL_DEFINE_MOCK_METHOD(put_Isolated)

		VSL_CHECK_VALIDVALUE(Isolated);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_AliasesValidValues
	{
		/*[out,retval]*/ BSTR* pbstrAliases;
		HRESULT retValue;
	};

	STDMETHOD(get_Aliases)(
		/*[out,retval]*/ BSTR* pbstrAliases)
	{
		VSL_DEFINE_MOCK_METHOD(get_Aliases)

		VSL_SET_VALIDVALUE_BSTR(pbstrAliases);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_AliasesValidValues
	{
		/*[in]*/ BSTR Aliases;
		HRESULT retValue;
	};

	STDMETHOD(put_Aliases)(
		/*[in]*/ BSTR Aliases)
	{
		VSL_DEFINE_MOCK_METHOD(put_Aliases)

		VSL_CHECK_VALIDVALUE_BSTR(Aliases);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_RefTypeValidValues
	{
		/*[out,retval]*/ PROJECTREFERENCETYPE* pProjRefType;
		HRESULT retValue;
	};

	STDMETHOD(get_RefType)(
		/*[out,retval]*/ PROJECTREFERENCETYPE* pProjRefType)
	{
		VSL_DEFINE_MOCK_METHOD(get_RefType)

		VSL_SET_VALIDVALUE(pProjRefType);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_AutoReferencedValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbAutoReferenced;
		HRESULT retValue;
	};

	STDMETHOD(get_AutoReferenced)(
		/*[out,retval]*/ VARIANT_BOOL* pbAutoReferenced)
	{
		VSL_DEFINE_MOCK_METHOD(get_AutoReferenced)

		VSL_SET_VALIDVALUE(pbAutoReferenced);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ResolvedValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbResolved;
		HRESULT retValue;
	};

	STDMETHOD(get_Resolved)(
		/*[out,retval]*/ VARIANT_BOOL* pbResolved)
	{
		VSL_DEFINE_MOCK_METHOD(get_Resolved)

		VSL_SET_VALIDVALUE(pbResolved);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_RuntimeVersionValidValues
	{
		/*[out,retval]*/ BSTR* pbstrVersion;
		HRESULT retValue;
	};

	STDMETHOD(get_RuntimeVersion)(
		/*[out,retval]*/ BSTR* pbstrVersion)
	{
		VSL_DEFINE_MOCK_METHOD(get_RuntimeVersion)

		VSL_SET_VALIDVALUE_BSTR(pbstrVersion);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DTEValidValues
	{
		/*[out,retval]*/ DTE** ppDTE;
		HRESULT retValue;
	};

	STDMETHOD(get_DTE)(
		/*[out,retval]*/ DTE** ppDTE)
	{
		VSL_DEFINE_MOCK_METHOD(get_DTE)

		VSL_SET_VALIDVALUE(ppDTE);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CollectionValidValues
	{
		/*[out,retval]*/ References** ppProjectReferences;
		HRESULT retValue;
	};

	STDMETHOD(get_Collection)(
		/*[out,retval]*/ References** ppProjectReferences)
	{
		VSL_DEFINE_MOCK_METHOD(get_Collection)

		VSL_SET_VALIDVALUE_INTERFACE(ppProjectReferences);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ContainingProjectValidValues
	{
		/*[out,retval]*/ Project** ppProject;
		HRESULT retValue;
	};

	STDMETHOD(get_ContainingProject)(
		/*[out,retval]*/ Project** ppProject)
	{
		VSL_DEFINE_MOCK_METHOD(get_ContainingProject)

		VSL_SET_VALIDVALUE(ppProject);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Remove)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Remove)

		VSL_RETURN_VALIDVALUES();
	}
	struct get_NameValidValues
	{
		/*[out,retval]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(get_Name)(
		/*[out,retval]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(get_Name)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_TypeValidValues
	{
		/*[out,retval]*/ prjReferenceType* pType;
		HRESULT retValue;
	};

	STDMETHOD(get_Type)(
		/*[out,retval]*/ prjReferenceType* pType)
	{
		VSL_DEFINE_MOCK_METHOD(get_Type)

		VSL_SET_VALIDVALUE(pType);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IdentityValidValues
	{
		/*[out,retval]*/ BSTR* pbstrIdentity;
		HRESULT retValue;
	};

	STDMETHOD(get_Identity)(
		/*[out,retval]*/ BSTR* pbstrIdentity)
	{
		VSL_DEFINE_MOCK_METHOD(get_Identity)

		VSL_SET_VALIDVALUE_BSTR(pbstrIdentity);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_PathValidValues
	{
		/*[out,retval]*/ BSTR* pbstrPath;
		HRESULT retValue;
	};

	STDMETHOD(get_Path)(
		/*[out,retval]*/ BSTR* pbstrPath)
	{
		VSL_DEFINE_MOCK_METHOD(get_Path)

		VSL_SET_VALIDVALUE_BSTR(pbstrPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DescriptionValidValues
	{
		/*[out,retval]*/ BSTR* pbstrDesc;
		HRESULT retValue;
	};

	STDMETHOD(get_Description)(
		/*[out,retval]*/ BSTR* pbstrDesc)
	{
		VSL_DEFINE_MOCK_METHOD(get_Description)

		VSL_SET_VALIDVALUE_BSTR(pbstrDesc);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CultureValidValues
	{
		/*[out,retval]*/ BSTR* pbstrCulture;
		HRESULT retValue;
	};

	STDMETHOD(get_Culture)(
		/*[out,retval]*/ BSTR* pbstrCulture)
	{
		VSL_DEFINE_MOCK_METHOD(get_Culture)

		VSL_SET_VALIDVALUE_BSTR(pbstrCulture);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_MajorVersionValidValues
	{
		/*[out,retval]*/ long* plMajorVer;
		HRESULT retValue;
	};

	STDMETHOD(get_MajorVersion)(
		/*[out,retval]*/ long* plMajorVer)
	{
		VSL_DEFINE_MOCK_METHOD(get_MajorVersion)

		VSL_SET_VALIDVALUE(plMajorVer);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_MinorVersionValidValues
	{
		/*[out,retval]*/ long* plMinorVer;
		HRESULT retValue;
	};

	STDMETHOD(get_MinorVersion)(
		/*[out,retval]*/ long* plMinorVer)
	{
		VSL_DEFINE_MOCK_METHOD(get_MinorVersion)

		VSL_SET_VALIDVALUE(plMinorVer);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_RevisionNumberValidValues
	{
		/*[out,retval]*/ long* plRevNo;
		HRESULT retValue;
	};

	STDMETHOD(get_RevisionNumber)(
		/*[out,retval]*/ long* plRevNo)
	{
		VSL_DEFINE_MOCK_METHOD(get_RevisionNumber)

		VSL_SET_VALIDVALUE(plRevNo);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_BuildNumberValidValues
	{
		/*[out,retval]*/ long* plBuildNo;
		HRESULT retValue;
	};

	STDMETHOD(get_BuildNumber)(
		/*[out,retval]*/ long* plBuildNo)
	{
		VSL_DEFINE_MOCK_METHOD(get_BuildNumber)

		VSL_SET_VALIDVALUE(plBuildNo);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_StrongNameValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pfStrongName;
		HRESULT retValue;
	};

	STDMETHOD(get_StrongName)(
		/*[out,retval]*/ VARIANT_BOOL* pfStrongName)
	{
		VSL_DEFINE_MOCK_METHOD(get_StrongName)

		VSL_SET_VALIDVALUE(pfStrongName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_SourceProjectValidValues
	{
		/*[out,retval]*/ Project** ppProject;
		HRESULT retValue;
	};

	STDMETHOD(get_SourceProject)(
		/*[out,retval]*/ Project** ppProject)
	{
		VSL_DEFINE_MOCK_METHOD(get_SourceProject)

		VSL_SET_VALIDVALUE(ppProject);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CopyLocalValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbCopyLocal;
		HRESULT retValue;
	};

	STDMETHOD(get_CopyLocal)(
		/*[out,retval]*/ VARIANT_BOOL* pbCopyLocal)
	{
		VSL_DEFINE_MOCK_METHOD(get_CopyLocal)

		VSL_SET_VALIDVALUE(pbCopyLocal);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_CopyLocalValidValues
	{
		/*[in]*/ VARIANT_BOOL bCopyLocal;
		HRESULT retValue;
	};

	STDMETHOD(put_CopyLocal)(
		/*[in]*/ VARIANT_BOOL bCopyLocal)
	{
		VSL_DEFINE_MOCK_METHOD(put_CopyLocal)

		VSL_CHECK_VALIDVALUE(bCopyLocal);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderValidValues
	{
		/*[in]*/ BSTR ExtenderName;
		/*[out,retval]*/ IDispatch** Extender;
		HRESULT retValue;
	};

	STDMETHOD(get_Extender)(
		/*[in]*/ BSTR ExtenderName,
		/*[out,retval]*/ IDispatch** Extender)
	{
		VSL_DEFINE_MOCK_METHOD(get_Extender)

		VSL_CHECK_VALIDVALUE_BSTR(ExtenderName);

		VSL_SET_VALIDVALUE_INTERFACE(Extender);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderNamesValidValues
	{
		/*[out,retval]*/ VARIANT* ExtenderNames;
		HRESULT retValue;
	};

	STDMETHOD(get_ExtenderNames)(
		/*[out,retval]*/ VARIANT* ExtenderNames)
	{
		VSL_DEFINE_MOCK_METHOD(get_ExtenderNames)

		VSL_SET_VALIDVALUE_VARIANT(ExtenderNames);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderCATIDValidValues
	{
		/*[out,retval]*/ BSTR* pRetval;
		HRESULT retValue;
	};

	STDMETHOD(get_ExtenderCATID)(
		/*[out,retval]*/ BSTR* pRetval)
	{
		VSL_DEFINE_MOCK_METHOD(get_ExtenderCATID)

		VSL_SET_VALIDVALUE_BSTR(pRetval);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_PublicKeyTokenValidValues
	{
		/*[out,retval]*/ BSTR* pbstrPublicKeyToken;
		HRESULT retValue;
	};

	STDMETHOD(get_PublicKeyToken)(
		/*[out,retval]*/ BSTR* pbstrPublicKeyToken)
	{
		VSL_DEFINE_MOCK_METHOD(get_PublicKeyToken)

		VSL_SET_VALIDVALUE_BSTR(pbstrPublicKeyToken);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_VersionValidValues
	{
		/*[out,retval]*/ BSTR* pbstrVersion;
		HRESULT retValue;
	};

	STDMETHOD(get_Version)(
		/*[out,retval]*/ BSTR* pbstrVersion)
	{
		VSL_DEFINE_MOCK_METHOD(get_Version)

		VSL_SET_VALIDVALUE_BSTR(pbstrVersion);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // REFERENCE3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockProjectProperties.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef PROJECTPROPERTIES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define PROJECTPROPERTIES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vslangproj.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ProjectPropertiesNotImpl :
	public ProjectProperties
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ProjectPropertiesNotImpl)

public:

	typedef ProjectProperties Interface;

	STDMETHOD(get___id)(
		/*[out,retval]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get___project)(
		/*[out,retval]*/ IUnknown** /*ppUnk*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_StartupObject)(
		/*[out,retval]*/ BSTR* /*pbstrStartupObject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_StartupObject)(
		/*[in]*/ BSTR /*bstrStartupObject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_OutputType)(
		/*[out,retval]*/ prjOutputType* /*pOutputType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_OutputType)(
		/*[in]*/ prjOutputType /*outputType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_RootNamespace)(
		/*[out,retval]*/ BSTR* /*pbstrRootNamespace*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_RootNamespace)(
		/*[in]*/ BSTR /*bstrRootNamespace*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_AssemblyName)(
		/*[out,retval]*/ BSTR* /*pbstrAssemblyName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_AssemblyName)(
		/*[in]*/ BSTR /*bstrAssemblyName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_AssemblyOriginatorKeyFile)(
		/*[out,retval]*/ BSTR* /*pbstrOriginatorKeyFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_AssemblyOriginatorKeyFile)(
		/*[in]*/ BSTR /*bstrOriginatorKeyFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_AssemblyKeyContainerName)(
		/*[out,retval]*/ BSTR* /*pbstrKeyContainerName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_AssemblyKeyContainerName)(
		/*[in]*/ BSTR /*bstrKeyContainerName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_AssemblyOriginatorKeyMode)(
		/*[out,retval]*/ prjOriginatorKeyMode* /*pOriginatorKeyMode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_AssemblyOriginatorKeyMode)(
		/*[in]*/ prjOriginatorKeyMode /*originatorKeyMode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DelaySign)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbDelaySign*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DelaySign)(
		/*[in]*/ VARIANT_BOOL /*bDelaySign*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_WebServer)(
		/*[out,retval]*/ BSTR* /*pbstrWebServer*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_WebServerVersion)(
		/*[out,retval]*/ BSTR* /*pbstrWebServerVersion*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ServerExtensionsVersion)(
		/*[out,retval]*/ BSTR* /*pbstrServerExtensionsVersion*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_LinkRepair)(
		/*[out,retval]*/ VARIANT_BOOL* /*pLinkRepair*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_LinkRepair)(
		/*[in]*/ VARIANT_BOOL /*linkRepair*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_OfflineURL)(
		/*[out,retval]*/ BSTR* /*pbstrOfflineURL*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_FileSharePath)(
		/*[out,retval]*/ BSTR* /*pbstrFileSharePath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_FileSharePath)(
		/*[in]*/ BSTR /*bstrFileSharePath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ActiveFileSharePath)(
		/*[out,retval]*/ BSTR* /*pbstrFileSharePath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_WebAccessMethod)(
		/*[out,retval]*/ prjWebAccessMethod* /*pWebAccessMethod*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_WebAccessMethod)(
		/*[in]*/ prjWebAccessMethod /*authoringAccessMethod*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ActiveWebAccessMethod)(
		/*[out,retval]*/ prjWebAccessMethod* /*pActiveWebAccessMethod*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DefaultClientScript)(
		/*[out,retval]*/ prjScriptLanguage* /*pScriptLanguage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DefaultClientScript)(
		/*[in]*/ prjScriptLanguage /*scriptLanguage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DefaultTargetSchema)(
		/*[out,retval]*/ prjTargetSchema* /*pTargetSchema*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DefaultTargetSchema)(
		/*[in]*/ prjTargetSchema /*htmlPlatform*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DefaultHTMLPageLayout)(
		/*[out,retval]*/ prjHTMLPageLayout* /*pHTMLPageLayout*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DefaultHTMLPageLayout)(
		/*[in]*/ prjHTMLPageLayout /*htmlPageLayout*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_FileName)(
		/*[out,retval]*/ BSTR* /*pbstrFileName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_FileName)(
		/*[in]*/ BSTR /*bstrFileName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_FullPath)(
		/*[out,retval]*/ BSTR* /*pbstrFullPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_LocalPath)(
		/*[out,retval]*/ BSTR* /*pbstrLocalPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_URL)(
		/*[out,retval]*/ BSTR* /*pbstrURL*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ActiveConfigurationSettings)(
		/*[out,retval]*/ ProjectConfigurationProperties** /*ppVBProjConfigProps*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Extender)(
		/*[in]*/ BSTR /*ExtenderName*/,
		/*[out,retval]*/ IDispatch** /*Extender*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ExtenderNames)(
		/*[out,retval]*/ VARIANT* /*ExtenderNames*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ExtenderCATID)(
		/*[out,retval]*/ BSTR* /*pRetval*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ApplicationIcon)(
		/*[out,retval]*/ BSTR* /*pbstrApplicationIcon*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_ApplicationIcon)(
		/*[in]*/ BSTR /*bstrApplicationIcon*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_OptionStrict)(
		/*[out,retval]*/ prjOptionStrict* /*pOptionStrict*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_OptionStrict)(
		/*[in]*/ prjOptionStrict /*optionStrict*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ReferencePath)(
		/*[out,retval]*/ BSTR* /*pbstrReferencePath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_ReferencePath)(
		/*[in]*/ BSTR /*bstrReferencePath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_OutputFileName)(
		/*[out,retval]*/ BSTR* /*pbstrOutputFileName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_AbsoluteProjectDirectory)(
		/*[out,retval]*/ BSTR* /*pbstrDir*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_OptionExplicit)(
		/*[out,retval]*/ prjOptionExplicit* /*pOptionExplicit*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_OptionExplicit)(
		/*[in]*/ prjOptionExplicit /*optionExplicit*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_OptionCompare)(
		/*[out,retval]*/ prjCompare* /*pOptionCompare*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_OptionCompare)(
		/*[in]*/ prjCompare /*optionCompare*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ProjectType)(
		/*[out,retval]*/ prjProjectType* /*pProjectType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DefaultNamespace)(
		/*[out,retval]*/ BSTR* /*pbstrRootNamespace*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DefaultNamespace)(
		/*[in]*/ BSTR /*bstrRootNamespace*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class ProjectPropertiesMockImpl :
	public ProjectProperties,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ProjectPropertiesMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ProjectPropertiesMockImpl)

	typedef ProjectProperties Interface;
	struct get___idValidValues
	{
		/*[out,retval]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(get___id)(
		/*[out,retval]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(get___id)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get___projectValidValues
	{
		/*[out,retval]*/ IUnknown** ppUnk;
		HRESULT retValue;
	};

	STDMETHOD(get___project)(
		/*[out,retval]*/ IUnknown** ppUnk)
	{
		VSL_DEFINE_MOCK_METHOD(get___project)

		VSL_SET_VALIDVALUE_INTERFACE(ppUnk);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_StartupObjectValidValues
	{
		/*[out,retval]*/ BSTR* pbstrStartupObject;
		HRESULT retValue;
	};

	STDMETHOD(get_StartupObject)(
		/*[out,retval]*/ BSTR* pbstrStartupObject)
	{
		VSL_DEFINE_MOCK_METHOD(get_StartupObject)

		VSL_SET_VALIDVALUE_BSTR(pbstrStartupObject);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_StartupObjectValidValues
	{
		/*[in]*/ BSTR bstrStartupObject;
		HRESULT retValue;
	};

	STDMETHOD(put_StartupObject)(
		/*[in]*/ BSTR bstrStartupObject)
	{
		VSL_DEFINE_MOCK_METHOD(put_StartupObject)

		VSL_CHECK_VALIDVALUE_BSTR(bstrStartupObject);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_OutputTypeValidValues
	{
		/*[out,retval]*/ prjOutputType* pOutputType;
		HRESULT retValue;
	};

	STDMETHOD(get_OutputType)(
		/*[out,retval]*/ prjOutputType* pOutputType)
	{
		VSL_DEFINE_MOCK_METHOD(get_OutputType)

		VSL_SET_VALIDVALUE(pOutputType);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_OutputTypeValidValues
	{
		/*[in]*/ prjOutputType outputType;
		HRESULT retValue;
	};

	STDMETHOD(put_OutputType)(
		/*[in]*/ prjOutputType outputType)
	{
		VSL_DEFINE_MOCK_METHOD(put_OutputType)

		VSL_CHECK_VALIDVALUE(outputType);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_RootNamespaceValidValues
	{
		/*[out,retval]*/ BSTR* pbstrRootNamespace;
		HRESULT retValue;
	};

	STDMETHOD(get_RootNamespace)(
		/*[out,retval]*/ BSTR* pbstrRootNamespace)
	{
		VSL_DEFINE_MOCK_METHOD(get_RootNamespace)

		VSL_SET_VALIDVALUE_BSTR(pbstrRootNamespace);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_RootNamespaceValidValues
	{
		/*[in]*/ BSTR bstrRootNamespace;
		HRESULT retValue;
	};

	STDMETHOD(put_RootNamespace)(
		/*[in]*/ BSTR bstrRootNamespace)
	{
		VSL_DEFINE_MOCK_METHOD(put_RootNamespace)

		VSL_CHECK_VALIDVALUE_BSTR(bstrRootNamespace);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_AssemblyNameValidValues
	{
		/*[out,retval]*/ BSTR* pbstrAssemblyName;
		HRESULT retValue;
	};

	STDMETHOD(get_AssemblyName)(
		/*[out,retval]*/ BSTR* pbstrAssemblyName)
	{
		VSL_DEFINE_MOCK_METHOD(get_AssemblyName)

		VSL_SET_VALIDVALUE_BSTR(pbstrAssemblyName);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_AssemblyNameValidValues
	{
		/*[in]*/ BSTR bstrAssemblyName;
		HRESULT retValue;
	};

	STDMETHOD(put_AssemblyName)(
		/*[in]*/ BSTR bstrAssemblyName)
	{
		VSL_DEFINE_MOCK_METHOD(put_AssemblyName)

		VSL_CHECK_VALIDVALUE_BSTR(bstrAssemblyName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_AssemblyOriginatorKeyFileValidValues
	{
		/*[out,retval]*/ BSTR* pbstrOriginatorKeyFile;
		HRESULT retValue;
	};

	STDMETHOD(get_AssemblyOriginatorKeyFile)(
		/*[out,retval]*/ BSTR* pbstrOriginatorKeyFile)
	{
		VSL_DEFINE_MOCK_METHOD(get_AssemblyOriginatorKeyFile)

		VSL_SET_VALIDVALUE_BSTR(pbstrOriginatorKeyFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_AssemblyOriginatorKeyFileValidValues
	{
		/*[in]*/ BSTR bstrOriginatorKeyFile;
		HRESULT retValue;
	};

	STDMETHOD(put_AssemblyOriginatorKeyFile)(
		/*[in]*/ BSTR bstrOriginatorKeyFile)
	{
		VSL_DEFINE_MOCK_METHOD(put_AssemblyOriginatorKeyFile)

		VSL_CHECK_VALIDVALUE_BSTR(bstrOriginatorKeyFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_AssemblyKeyContainerNameValidValues
	{
		/*[out,retval]*/ BSTR* pbstrKeyContainerName;
		HRESULT retValue;
	};

	STDMETHOD(get_AssemblyKeyContainerName)(
		/*[out,retval]*/ BSTR* pbstrKeyContainerName)
	{
		VSL_DEFINE_MOCK_METHOD(get_AssemblyKeyContainerName)

		VSL_SET_VALIDVALUE_BSTR(pbstrKeyContainerName);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_AssemblyKeyContainerNameValidValues
	{
		/*[in]*/ BSTR bstrKeyContainerName;
		HRESULT retValue;
	};

	STDMETHOD(put_AssemblyKeyContainerName)(
		/*[in]*/ BSTR bstrKeyContainerName)
	{
		VSL_DEFINE_MOCK_METHOD(put_AssemblyKeyContainerName)

		VSL_CHECK_VALIDVALUE_BSTR(bstrKeyContainerName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_AssemblyOriginatorKeyModeValidValues
	{
		/*[out,retval]*/ prjOriginatorKeyMode* pOriginatorKeyMode;
		HRESULT retValue;
	};

	STDMETHOD(get_AssemblyOriginatorKeyMode)(
		/*[out,retval]*/ prjOriginatorKeyMode* pOriginatorKeyMode)
	{
		VSL_DEFINE_MOCK_METHOD(get_AssemblyOriginatorKeyMode)

		VSL_SET_VALIDVALUE(pOriginatorKeyMode);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_AssemblyOriginatorKeyModeValidValues
	{
		/*[in]*/ prjOriginatorKeyMode originatorKeyMode;
		HRESULT retValue;
	};

	STDMETHOD(put_AssemblyOriginatorKeyMode)(
		/*[in]*/ prjOriginatorKeyMode originatorKeyMode)
	{
		VSL_DEFINE_MOCK_METHOD(put_AssemblyOriginatorKeyMode)

		VSL_CHECK_VALIDVALUE(originatorKeyMode);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DelaySignValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbDelaySign;
		HRESULT retValue;
	};

	STDMETHOD(get_DelaySign)(
		/*[out,retval]*/ VARIANT_BOOL* pbDelaySign)
	{
		VSL_DEFINE_MOCK_METHOD(get_DelaySign)

		VSL_SET_VALIDVALUE(pbDelaySign);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DelaySignValidValues
	{
		/*[in]*/ VARIANT_BOOL bDelaySign;
		HRESULT retValue;
	};

	STDMETHOD(put_DelaySign)(
		/*[in]*/ VARIANT_BOOL bDelaySign)
	{
		VSL_DEFINE_MOCK_METHOD(put_DelaySign)

		VSL_CHECK_VALIDVALUE(bDelaySign);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_WebServerValidValues
	{
		/*[out,retval]*/ BSTR* pbstrWebServer;
		HRESULT retValue;
	};

	STDMETHOD(get_WebServer)(
		/*[out,retval]*/ BSTR* pbstrWebServer)
	{
		VSL_DEFINE_MOCK_METHOD(get_WebServer)

		VSL_SET_VALIDVALUE_BSTR(pbstrWebServer);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_WebServerVersionValidValues
	{
		/*[out,retval]*/ BSTR* pbstrWebServerVersion;
		HRESULT retValue;
	};

	STDMETHOD(get_WebServerVersion)(
		/*[out,retval]*/ BSTR* pbstrWebServerVersion)
	{
		VSL_DEFINE_MOCK_METHOD(get_WebServerVersion)

		VSL_SET_VALIDVALUE_BSTR(pbstrWebServerVersion);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ServerExtensionsVersionValidValues
	{
		/*[out,retval]*/ BSTR* pbstrServerExtensionsVersion;
		HRESULT retValue;
	};

	STDMETHOD(get_ServerExtensionsVersion)(
		/*[out,retval]*/ BSTR* pbstrServerExtensionsVersion)
	{
		VSL_DEFINE_MOCK_METHOD(get_ServerExtensionsVersion)

		VSL_SET_VALIDVALUE_BSTR(pbstrServerExtensionsVersion);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_LinkRepairValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pLinkRepair;
		HRESULT retValue;
	};

	STDMETHOD(get_LinkRepair)(
		/*[out,retval]*/ VARIANT_BOOL* pLinkRepair)
	{
		VSL_DEFINE_MOCK_METHOD(get_LinkRepair)

		VSL_SET_VALIDVALUE(pLinkRepair);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_LinkRepairValidValues
	{
		/*[in]*/ VARIANT_BOOL linkRepair;
		HRESULT retValue;
	};

	STDMETHOD(put_LinkRepair)(
		/*[in]*/ VARIANT_BOOL linkRepair)
	{
		VSL_DEFINE_MOCK_METHOD(put_LinkRepair)

		VSL_CHECK_VALIDVALUE(linkRepair);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_OfflineURLValidValues
	{
		/*[out,retval]*/ BSTR* pbstrOfflineURL;
		HRESULT retValue;
	};

	STDMETHOD(get_OfflineURL)(
		/*[out,retval]*/ BSTR* pbstrOfflineURL)
	{
		VSL_DEFINE_MOCK_METHOD(get_OfflineURL)

		VSL_SET_VALIDVALUE_BSTR(pbstrOfflineURL);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_FileSharePathValidValues
	{
		/*[out,retval]*/ BSTR* pbstrFileSharePath;
		HRESULT retValue;
	};

	STDMETHOD(get_FileSharePath)(
		/*[out,retval]*/ BSTR* pbstrFileSharePath)
	{
		VSL_DEFINE_MOCK_METHOD(get_FileSharePath)

		VSL_SET_VALIDVALUE_BSTR(pbstrFileSharePath);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_FileSharePathValidValues
	{
		/*[in]*/ BSTR bstrFileSharePath;
		HRESULT retValue;
	};

	STDMETHOD(put_FileSharePath)(
		/*[in]*/ BSTR bstrFileSharePath)
	{
		VSL_DEFINE_MOCK_METHOD(put_FileSharePath)

		VSL_CHECK_VALIDVALUE_BSTR(bstrFileSharePath);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ActiveFileSharePathValidValues
	{
		/*[out,retval]*/ BSTR* pbstrFileSharePath;
		HRESULT retValue;
	};

	STDMETHOD(get_ActiveFileSharePath)(
		/*[out,retval]*/ BSTR* pbstrFileSharePath)
	{
		VSL_DEFINE_MOCK_METHOD(get_ActiveFileSharePath)

		VSL_SET_VALIDVALUE_BSTR(pbstrFileSharePath);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_WebAccessMethodValidValues
	{
		/*[out,retval]*/ prjWebAccessMethod* pWebAccessMethod;
		HRESULT retValue;
	};

	STDMETHOD(get_WebAccessMethod)(
		/*[out,retval]*/ prjWebAccessMethod* pWebAccessMethod)
	{
		VSL_DEFINE_MOCK_METHOD(get_WebAccessMethod)

		VSL_SET_VALIDVALUE(pWebAccessMethod);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_WebAccessMethodValidValues
	{
		/*[in]*/ prjWebAccessMethod authoringAccessMethod;
		HRESULT retValue;
	};

	STDMETHOD(put_WebAccessMethod)(
		/*[in]*/ prjWebAccessMethod authoringAccessMethod)
	{
		VSL_DEFINE_MOCK_METHOD(put_WebAccessMethod)

		VSL_CHECK_VALIDVALUE(authoringAccessMethod);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ActiveWebAccessMethodValidValues
	{
		/*[out,retval]*/ prjWebAccessMethod* pActiveWebAccessMethod;
		HRESULT retValue;
	};

	STDMETHOD(get_ActiveWebAccessMethod)(
		/*[out,retval]*/ prjWebAccessMethod* pActiveWebAccessMethod)
	{
		VSL_DEFINE_MOCK_METHOD(get_ActiveWebAccessMethod)

		VSL_SET_VALIDVALUE(pActiveWebAccessMethod);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DefaultClientScriptValidValues
	{
		/*[out,retval]*/ prjScriptLanguage* pScriptLanguage;
		HRESULT retValue;
	};

	STDMETHOD(get_DefaultClientScript)(
		/*[out,retval]*/ prjScriptLanguage* pScriptLanguage)
	{
		VSL_DEFINE_MOCK_METHOD(get_DefaultClientScript)

		VSL_SET_VALIDVALUE(pScriptLanguage);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DefaultClientScriptValidValues
	{
		/*[in]*/ prjScriptLanguage scriptLanguage;
		HRESULT retValue;
	};

	STDMETHOD(put_DefaultClientScript)(
		/*[in]*/ prjScriptLanguage scriptLanguage)
	{
		VSL_DEFINE_MOCK_METHOD(put_DefaultClientScript)

		VSL_CHECK_VALIDVALUE(scriptLanguage);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DefaultTargetSchemaValidValues
	{
		/*[out,retval]*/ prjTargetSchema* pTargetSchema;
		HRESULT retValue;
	};

	STDMETHOD(get_DefaultTargetSchema)(
		/*[out,retval]*/ prjTargetSchema* pTargetSchema)
	{
		VSL_DEFINE_MOCK_METHOD(get_DefaultTargetSchema)

		VSL_SET_VALIDVALUE(pTargetSchema);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DefaultTargetSchemaValidValues
	{
		/*[in]*/ prjTargetSchema htmlPlatform;
		HRESULT retValue;
	};

	STDMETHOD(put_DefaultTargetSchema)(
		/*[in]*/ prjTargetSchema htmlPlatform)
	{
		VSL_DEFINE_MOCK_METHOD(put_DefaultTargetSchema)

		VSL_CHECK_VALIDVALUE(htmlPlatform);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DefaultHTMLPageLayoutValidValues
	{
		/*[out,retval]*/ prjHTMLPageLayout* pHTMLPageLayout;
		HRESULT retValue;
	};

	STDMETHOD(get_DefaultHTMLPageLayout)(
		/*[out,retval]*/ prjHTMLPageLayout* pHTMLPageLayout)
	{
		VSL_DEFINE_MOCK_METHOD(get_DefaultHTMLPageLayout)

		VSL_SET_VALIDVALUE(pHTMLPageLayout);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DefaultHTMLPageLayoutValidValues
	{
		/*[in]*/ prjHTMLPageLayout htmlPageLayout;
		HRESULT retValue;
	};

	STDMETHOD(put_DefaultHTMLPageLayout)(
		/*[in]*/ prjHTMLPageLayout htmlPageLayout)
	{
		VSL_DEFINE_MOCK_METHOD(put_DefaultHTMLPageLayout)

		VSL_CHECK_VALIDVALUE(htmlPageLayout);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_FileNameValidValues
	{
		/*[out,retval]*/ BSTR* pbstrFileName;
		HRESULT retValue;
	};

	STDMETHOD(get_FileName)(
		/*[out,retval]*/ BSTR* pbstrFileName)
	{
		VSL_DEFINE_MOCK_METHOD(get_FileName)

		VSL_SET_VALIDVALUE_BSTR(pbstrFileName);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_FileNameValidValues
	{
		/*[in]*/ BSTR bstrFileName;
		HRESULT retValue;
	};

	STDMETHOD(put_FileName)(
		/*[in]*/ BSTR bstrFileName)
	{
		VSL_DEFINE_MOCK_METHOD(put_FileName)

		VSL_CHECK_VALIDVALUE_BSTR(bstrFileName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_FullPathValidValues
	{
		/*[out,retval]*/ BSTR* pbstrFullPath;
		HRESULT retValue;
	};

	STDMETHOD(get_FullPath)(
		/*[out,retval]*/ BSTR* pbstrFullPath)
	{
		VSL_DEFINE_MOCK_METHOD(get_FullPath)

		VSL_SET_VALIDVALUE_BSTR(pbstrFullPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_LocalPathValidValues
	{
		/*[out,retval]*/ BSTR* pbstrLocalPath;
		HRESULT retValue;
	};

	STDMETHOD(get_LocalPath)(
		/*[out,retval]*/ BSTR* pbstrLocalPath)
	{
		VSL_DEFINE_MOCK_METHOD(get_LocalPath)

		VSL_SET_VALIDVALUE_BSTR(pbstrLocalPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_URLValidValues
	{
		/*[out,retval]*/ BSTR* pbstrURL;
		HRESULT retValue;
	};

	STDMETHOD(get_URL)(
		/*[out,retval]*/ BSTR* pbstrURL)
	{
		VSL_DEFINE_MOCK_METHOD(get_URL)

		VSL_SET_VALIDVALUE_BSTR(pbstrURL);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ActiveConfigurationSettingsValidValues
	{
		/*[out,retval]*/ ProjectConfigurationProperties** ppVBProjConfigProps;
		HRESULT retValue;
	};

	STDMETHOD(get_ActiveConfigurationSettings)(
		/*[out,retval]*/ ProjectConfigurationProperties** ppVBProjConfigProps)
	{
		VSL_DEFINE_MOCK_METHOD(get_ActiveConfigurationSettings)

		VSL_SET_VALIDVALUE_INTERFACE(ppVBProjConfigProps);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderValidValues
	{
		/*[in]*/ BSTR ExtenderName;
		/*[out,retval]*/ IDispatch** Extender;
		HRESULT retValue;
	};

	STDMETHOD(get_Extender)(
		/*[in]*/ BSTR ExtenderName,
		/*[out,retval]*/ IDispatch** Extender)
	{
		VSL_DEFINE_MOCK_METHOD(get_Extender)

		VSL_CHECK_VALIDVALUE_BSTR(ExtenderName);

		VSL_SET_VALIDVALUE_INTERFACE(Extender);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderNamesValidValues
	{
		/*[out,retval]*/ VARIANT* ExtenderNames;
		HRESULT retValue;
	};

	STDMETHOD(get_ExtenderNames)(
		/*[out,retval]*/ VARIANT* ExtenderNames)
	{
		VSL_DEFINE_MOCK_METHOD(get_ExtenderNames)

		VSL_SET_VALIDVALUE_VARIANT(ExtenderNames);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderCATIDValidValues
	{
		/*[out,retval]*/ BSTR* pRetval;
		HRESULT retValue;
	};

	STDMETHOD(get_ExtenderCATID)(
		/*[out,retval]*/ BSTR* pRetval)
	{
		VSL_DEFINE_MOCK_METHOD(get_ExtenderCATID)

		VSL_SET_VALIDVALUE_BSTR(pRetval);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ApplicationIconValidValues
	{
		/*[out,retval]*/ BSTR* pbstrApplicationIcon;
		HRESULT retValue;
	};

	STDMETHOD(get_ApplicationIcon)(
		/*[out,retval]*/ BSTR* pbstrApplicationIcon)
	{
		VSL_DEFINE_MOCK_METHOD(get_ApplicationIcon)

		VSL_SET_VALIDVALUE_BSTR(pbstrApplicationIcon);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_ApplicationIconValidValues
	{
		/*[in]*/ BSTR bstrApplicationIcon;
		HRESULT retValue;
	};

	STDMETHOD(put_ApplicationIcon)(
		/*[in]*/ BSTR bstrApplicationIcon)
	{
		VSL_DEFINE_MOCK_METHOD(put_ApplicationIcon)

		VSL_CHECK_VALIDVALUE_BSTR(bstrApplicationIcon);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_OptionStrictValidValues
	{
		/*[out,retval]*/ prjOptionStrict* pOptionStrict;
		HRESULT retValue;
	};

	STDMETHOD(get_OptionStrict)(
		/*[out,retval]*/ prjOptionStrict* pOptionStrict)
	{
		VSL_DEFINE_MOCK_METHOD(get_OptionStrict)

		VSL_SET_VALIDVALUE(pOptionStrict);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_OptionStrictValidValues
	{
		/*[in]*/ prjOptionStrict optionStrict;
		HRESULT retValue;
	};

	STDMETHOD(put_OptionStrict)(
		/*[in]*/ prjOptionStrict optionStrict)
	{
		VSL_DEFINE_MOCK_METHOD(put_OptionStrict)

		VSL_CHECK_VALIDVALUE(optionStrict);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ReferencePathValidValues
	{
		/*[out,retval]*/ BSTR* pbstrReferencePath;
		HRESULT retValue;
	};

	STDMETHOD(get_ReferencePath)(
		/*[out,retval]*/ BSTR* pbstrReferencePath)
	{
		VSL_DEFINE_MOCK_METHOD(get_ReferencePath)

		VSL_SET_VALIDVALUE_BSTR(pbstrReferencePath);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_ReferencePathValidValues
	{
		/*[in]*/ BSTR bstrReferencePath;
		HRESULT retValue;
	};

	STDMETHOD(put_ReferencePath)(
		/*[in]*/ BSTR bstrReferencePath)
	{
		VSL_DEFINE_MOCK_METHOD(put_ReferencePath)

		VSL_CHECK_VALIDVALUE_BSTR(bstrReferencePath);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_OutputFileNameValidValues
	{
		/*[out,retval]*/ BSTR* pbstrOutputFileName;
		HRESULT retValue;
	};

	STDMETHOD(get_OutputFileName)(
		/*[out,retval]*/ BSTR* pbstrOutputFileName)
	{
		VSL_DEFINE_MOCK_METHOD(get_OutputFileName)

		VSL_SET_VALIDVALUE_BSTR(pbstrOutputFileName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_AbsoluteProjectDirectoryValidValues
	{
		/*[out,retval]*/ BSTR* pbstrDir;
		HRESULT retValue;
	};

	STDMETHOD(get_AbsoluteProjectDirectory)(
		/*[out,retval]*/ BSTR* pbstrDir)
	{
		VSL_DEFINE_MOCK_METHOD(get_AbsoluteProjectDirectory)

		VSL_SET_VALIDVALUE_BSTR(pbstrDir);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_OptionExplicitValidValues
	{
		/*[out,retval]*/ prjOptionExplicit* pOptionExplicit;
		HRESULT retValue;
	};

	STDMETHOD(get_OptionExplicit)(
		/*[out,retval]*/ prjOptionExplicit* pOptionExplicit)
	{
		VSL_DEFINE_MOCK_METHOD(get_OptionExplicit)

		VSL_SET_VALIDVALUE(pOptionExplicit);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_OptionExplicitValidValues
	{
		/*[in]*/ prjOptionExplicit optionExplicit;
		HRESULT retValue;
	};

	STDMETHOD(put_OptionExplicit)(
		/*[in]*/ prjOptionExplicit optionExplicit)
	{
		VSL_DEFINE_MOCK_METHOD(put_OptionExplicit)

		VSL_CHECK_VALIDVALUE(optionExplicit);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_OptionCompareValidValues
	{
		/*[out,retval]*/ prjCompare* pOptionCompare;
		HRESULT retValue;
	};

	STDMETHOD(get_OptionCompare)(
		/*[out,retval]*/ prjCompare* pOptionCompare)
	{
		VSL_DEFINE_MOCK_METHOD(get_OptionCompare)

		VSL_SET_VALIDVALUE(pOptionCompare);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_OptionCompareValidValues
	{
		/*[in]*/ prjCompare optionCompare;
		HRESULT retValue;
	};

	STDMETHOD(put_OptionCompare)(
		/*[in]*/ prjCompare optionCompare)
	{
		VSL_DEFINE_MOCK_METHOD(put_OptionCompare)

		VSL_CHECK_VALIDVALUE(optionCompare);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ProjectTypeValidValues
	{
		/*[out,retval]*/ prjProjectType* pProjectType;
		HRESULT retValue;
	};

	STDMETHOD(get_ProjectType)(
		/*[out,retval]*/ prjProjectType* pProjectType)
	{
		VSL_DEFINE_MOCK_METHOD(get_ProjectType)

		VSL_SET_VALIDVALUE(pProjectType);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DefaultNamespaceValidValues
	{
		/*[out,retval]*/ BSTR* pbstrRootNamespace;
		HRESULT retValue;
	};

	STDMETHOD(get_DefaultNamespace)(
		/*[out,retval]*/ BSTR* pbstrRootNamespace)
	{
		VSL_DEFINE_MOCK_METHOD(get_DefaultNamespace)

		VSL_SET_VALIDVALUE_BSTR(pbstrRootNamespace);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DefaultNamespaceValidValues
	{
		/*[in]*/ BSTR bstrRootNamespace;
		HRESULT retValue;
	};

	STDMETHOD(put_DefaultNamespace)(
		/*[in]*/ BSTR bstrRootNamespace)
	{
		VSL_DEFINE_MOCK_METHOD(put_DefaultNamespace)

		VSL_CHECK_VALIDVALUE_BSTR(bstrRootNamespace);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // PROJECTPROPERTIES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockProjectProperties2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef PROJECTPROPERTIES2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define PROJECTPROPERTIES2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vslangproj2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ProjectProperties2NotImpl :
	public ProjectProperties2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ProjectProperties2NotImpl)

public:

	typedef ProjectProperties2 Interface;

	STDMETHOD(get_PreBuildEvent)(
		/*[out,retval]*/ BSTR* /*pbstrOut*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_PreBuildEvent)(
		/*[in]*/ BSTR /*bstrIn*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_PostBuildEvent)(
		/*[out,retval]*/ BSTR* /*pbstrOut*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_PostBuildEvent)(
		/*[in]*/ BSTR /*bstrIn*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_RunPostBuildEvent)(
		/*[out,retval]*/ prjRunPostBuildEvent* /*pOut*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_RunPostBuildEvent)(
		/*[in]*/ prjRunPostBuildEvent /*run*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_AspnetVersion)(
		/*[out,retval]*/ BSTR* /*pOut*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get___id)(
		/*[out,retval]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get___project)(
		/*[out,retval]*/ IUnknown** /*ppUnk*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_StartupObject)(
		/*[out,retval]*/ BSTR* /*pbstrStartupObject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_StartupObject)(
		/*[in]*/ BSTR /*bstrStartupObject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_OutputType)(
		/*[out,retval]*/ prjOutputType* /*pOutputType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_OutputType)(
		/*[in]*/ prjOutputType /*outputType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_RootNamespace)(
		/*[out,retval]*/ BSTR* /*pbstrRootNamespace*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_RootNamespace)(
		/*[in]*/ BSTR /*bstrRootNamespace*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_AssemblyName)(
		/*[out,retval]*/ BSTR* /*pbstrAssemblyName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_AssemblyName)(
		/*[in]*/ BSTR /*bstrAssemblyName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_AssemblyOriginatorKeyFile)(
		/*[out,retval]*/ BSTR* /*pbstrOriginatorKeyFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_AssemblyOriginatorKeyFile)(
		/*[in]*/ BSTR /*bstrOriginatorKeyFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_AssemblyKeyContainerName)(
		/*[out,retval]*/ BSTR* /*pbstrKeyContainerName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_AssemblyKeyContainerName)(
		/*[in]*/ BSTR /*bstrKeyContainerName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_AssemblyOriginatorKeyMode)(
		/*[out,retval]*/ prjOriginatorKeyMode* /*pOriginatorKeyMode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_AssemblyOriginatorKeyMode)(
		/*[in]*/ prjOriginatorKeyMode /*originatorKeyMode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DelaySign)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbDelaySign*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DelaySign)(
		/*[in]*/ VARIANT_BOOL /*bDelaySign*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_WebServer)(
		/*[out,retval]*/ BSTR* /*pbstrWebServer*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_WebServerVersion)(
		/*[out,retval]*/ BSTR* /*pbstrWebServerVersion*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ServerExtensionsVersion)(
		/*[out,retval]*/ BSTR* /*pbstrServerExtensionsVersion*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_LinkRepair)(
		/*[out,retval]*/ VARIANT_BOOL* /*pLinkRepair*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_LinkRepair)(
		/*[in]*/ VARIANT_BOOL /*linkRepair*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_OfflineURL)(
		/*[out,retval]*/ BSTR* /*pbstrOfflineURL*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_FileSharePath)(
		/*[out,retval]*/ BSTR* /*pbstrFileSharePath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_FileSharePath)(
		/*[in]*/ BSTR /*bstrFileSharePath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ActiveFileSharePath)(
		/*[out,retval]*/ BSTR* /*pbstrFileSharePath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_WebAccessMethod)(
		/*[out,retval]*/ prjWebAccessMethod* /*pWebAccessMethod*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_WebAccessMethod)(
		/*[in]*/ prjWebAccessMethod /*authoringAccessMethod*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ActiveWebAccessMethod)(
		/*[out,retval]*/ prjWebAccessMethod* /*pActiveWebAccessMethod*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DefaultClientScript)(
		/*[out,retval]*/ prjScriptLanguage* /*pScriptLanguage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DefaultClientScript)(
		/*[in]*/ prjScriptLanguage /*scriptLanguage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DefaultTargetSchema)(
		/*[out,retval]*/ prjTargetSchema* /*pTargetSchema*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DefaultTargetSchema)(
		/*[in]*/ prjTargetSchema /*htmlPlatform*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DefaultHTMLPageLayout)(
		/*[out,retval]*/ prjHTMLPageLayout* /*pHTMLPageLayout*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DefaultHTMLPageLayout)(
		/*[in]*/ prjHTMLPageLayout /*htmlPageLayout*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_FileName)(
		/*[out,retval]*/ BSTR* /*pbstrFileName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_FileName)(
		/*[in]*/ BSTR /*bstrFileName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_FullPath)(
		/*[out,retval]*/ BSTR* /*pbstrFullPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_LocalPath)(
		/*[out,retval]*/ BSTR* /*pbstrLocalPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_URL)(
		/*[out,retval]*/ BSTR* /*pbstrURL*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ActiveConfigurationSettings)(
		/*[out,retval]*/ ProjectConfigurationProperties** /*ppVBProjConfigProps*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Extender)(
		/*[in]*/ BSTR /*ExtenderName*/,
		/*[out,retval]*/ IDispatch** /*Extender*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ExtenderNames)(
		/*[out,retval]*/ VARIANT* /*ExtenderNames*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ExtenderCATID)(
		/*[out,retval]*/ BSTR* /*pRetval*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ApplicationIcon)(
		/*[out,retval]*/ BSTR* /*pbstrApplicationIcon*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_ApplicationIcon)(
		/*[in]*/ BSTR /*bstrApplicationIcon*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_OptionStrict)(
		/*[out,retval]*/ prjOptionStrict* /*pOptionStrict*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_OptionStrict)(
		/*[in]*/ prjOptionStrict /*optionStrict*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ReferencePath)(
		/*[out,retval]*/ BSTR* /*pbstrReferencePath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_ReferencePath)(
		/*[in]*/ BSTR /*bstrReferencePath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_OutputFileName)(
		/*[out,retval]*/ BSTR* /*pbstrOutputFileName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_AbsoluteProjectDirectory)(
		/*[out,retval]*/ BSTR* /*pbstrDir*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_OptionExplicit)(
		/*[out,retval]*/ prjOptionExplicit* /*pOptionExplicit*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_OptionExplicit)(
		/*[in]*/ prjOptionExplicit /*optionExplicit*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_OptionCompare)(
		/*[out,retval]*/ prjCompare* /*pOptionCompare*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_OptionCompare)(
		/*[in]*/ prjCompare /*optionCompare*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ProjectType)(
		/*[out,retval]*/ prjProjectType* /*pProjectType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DefaultNamespace)(
		/*[out,retval]*/ BSTR* /*pbstrRootNamespace*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DefaultNamespace)(
		/*[in]*/ BSTR /*bstrRootNamespace*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class ProjectProperties2MockImpl :
	public ProjectProperties2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ProjectProperties2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ProjectProperties2MockImpl)

	typedef ProjectProperties2 Interface;
	struct get_PreBuildEventValidValues
	{
		/*[out,retval]*/ BSTR* pbstrOut;
		HRESULT retValue;
	};

	STDMETHOD(get_PreBuildEvent)(
		/*[out,retval]*/ BSTR* pbstrOut)
	{
		VSL_DEFINE_MOCK_METHOD(get_PreBuildEvent)

		VSL_SET_VALIDVALUE_BSTR(pbstrOut);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_PreBuildEventValidValues
	{
		/*[in]*/ BSTR bstrIn;
		HRESULT retValue;
	};

	STDMETHOD(put_PreBuildEvent)(
		/*[in]*/ BSTR bstrIn)
	{
		VSL_DEFINE_MOCK_METHOD(put_PreBuildEvent)

		VSL_CHECK_VALIDVALUE_BSTR(bstrIn);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_PostBuildEventValidValues
	{
		/*[out,retval]*/ BSTR* pbstrOut;
		HRESULT retValue;
	};

	STDMETHOD(get_PostBuildEvent)(
		/*[out,retval]*/ BSTR* pbstrOut)
	{
		VSL_DEFINE_MOCK_METHOD(get_PostBuildEvent)

		VSL_SET_VALIDVALUE_BSTR(pbstrOut);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_PostBuildEventValidValues
	{
		/*[in]*/ BSTR bstrIn;
		HRESULT retValue;
	};

	STDMETHOD(put_PostBuildEvent)(
		/*[in]*/ BSTR bstrIn)
	{
		VSL_DEFINE_MOCK_METHOD(put_PostBuildEvent)

		VSL_CHECK_VALIDVALUE_BSTR(bstrIn);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_RunPostBuildEventValidValues
	{
		/*[out,retval]*/ prjRunPostBuildEvent* pOut;
		HRESULT retValue;
	};

	STDMETHOD(get_RunPostBuildEvent)(
		/*[out,retval]*/ prjRunPostBuildEvent* pOut)
	{
		VSL_DEFINE_MOCK_METHOD(get_RunPostBuildEvent)

		VSL_SET_VALIDVALUE(pOut);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_RunPostBuildEventValidValues
	{
		/*[in]*/ prjRunPostBuildEvent run;
		HRESULT retValue;
	};

	STDMETHOD(put_RunPostBuildEvent)(
		/*[in]*/ prjRunPostBuildEvent run)
	{
		VSL_DEFINE_MOCK_METHOD(put_RunPostBuildEvent)

		VSL_CHECK_VALIDVALUE(run);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_AspnetVersionValidValues
	{
		/*[out,retval]*/ BSTR* pOut;
		HRESULT retValue;
	};

	STDMETHOD(get_AspnetVersion)(
		/*[out,retval]*/ BSTR* pOut)
	{
		VSL_DEFINE_MOCK_METHOD(get_AspnetVersion)

		VSL_SET_VALIDVALUE_BSTR(pOut);

		VSL_RETURN_VALIDVALUES();
	}
	struct get___idValidValues
	{
		/*[out,retval]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(get___id)(
		/*[out,retval]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(get___id)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get___projectValidValues
	{
		/*[out,retval]*/ IUnknown** ppUnk;
		HRESULT retValue;
	};

	STDMETHOD(get___project)(
		/*[out,retval]*/ IUnknown** ppUnk)
	{
		VSL_DEFINE_MOCK_METHOD(get___project)

		VSL_SET_VALIDVALUE_INTERFACE(ppUnk);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_StartupObjectValidValues
	{
		/*[out,retval]*/ BSTR* pbstrStartupObject;
		HRESULT retValue;
	};

	STDMETHOD(get_StartupObject)(
		/*[out,retval]*/ BSTR* pbstrStartupObject)
	{
		VSL_DEFINE_MOCK_METHOD(get_StartupObject)

		VSL_SET_VALIDVALUE_BSTR(pbstrStartupObject);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_StartupObjectValidValues
	{
		/*[in]*/ BSTR bstrStartupObject;
		HRESULT retValue;
	};

	STDMETHOD(put_StartupObject)(
		/*[in]*/ BSTR bstrStartupObject)
	{
		VSL_DEFINE_MOCK_METHOD(put_StartupObject)

		VSL_CHECK_VALIDVALUE_BSTR(bstrStartupObject);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_OutputTypeValidValues
	{
		/*[out,retval]*/ prjOutputType* pOutputType;
		HRESULT retValue;
	};

	STDMETHOD(get_OutputType)(
		/*[out,retval]*/ prjOutputType* pOutputType)
	{
		VSL_DEFINE_MOCK_METHOD(get_OutputType)

		VSL_SET_VALIDVALUE(pOutputType);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_OutputTypeValidValues
	{
		/*[in]*/ prjOutputType outputType;
		HRESULT retValue;
	};

	STDMETHOD(put_OutputType)(
		/*[in]*/ prjOutputType outputType)
	{
		VSL_DEFINE_MOCK_METHOD(put_OutputType)

		VSL_CHECK_VALIDVALUE(outputType);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_RootNamespaceValidValues
	{
		/*[out,retval]*/ BSTR* pbstrRootNamespace;
		HRESULT retValue;
	};

	STDMETHOD(get_RootNamespace)(
		/*[out,retval]*/ BSTR* pbstrRootNamespace)
	{
		VSL_DEFINE_MOCK_METHOD(get_RootNamespace)

		VSL_SET_VALIDVALUE_BSTR(pbstrRootNamespace);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_RootNamespaceValidValues
	{
		/*[in]*/ BSTR bstrRootNamespace;
		HRESULT retValue;
	};

	STDMETHOD(put_RootNamespace)(
		/*[in]*/ BSTR bstrRootNamespace)
	{
		VSL_DEFINE_MOCK_METHOD(put_RootNamespace)

		VSL_CHECK_VALIDVALUE_BSTR(bstrRootNamespace);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_AssemblyNameValidValues
	{
		/*[out,retval]*/ BSTR* pbstrAssemblyName;
		HRESULT retValue;
	};

	STDMETHOD(get_AssemblyName)(
		/*[out,retval]*/ BSTR* pbstrAssemblyName)
	{
		VSL_DEFINE_MOCK_METHOD(get_AssemblyName)

		VSL_SET_VALIDVALUE_BSTR(pbstrAssemblyName);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_AssemblyNameValidValues
	{
		/*[in]*/ BSTR bstrAssemblyName;
		HRESULT retValue;
	};

	STDMETHOD(put_AssemblyName)(
		/*[in]*/ BSTR bstrAssemblyName)
	{
		VSL_DEFINE_MOCK_METHOD(put_AssemblyName)

		VSL_CHECK_VALIDVALUE_BSTR(bstrAssemblyName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_AssemblyOriginatorKeyFileValidValues
	{
		/*[out,retval]*/ BSTR* pbstrOriginatorKeyFile;
		HRESULT retValue;
	};

	STDMETHOD(get_AssemblyOriginatorKeyFile)(
		/*[out,retval]*/ BSTR* pbstrOriginatorKeyFile)
	{
		VSL_DEFINE_MOCK_METHOD(get_AssemblyOriginatorKeyFile)

		VSL_SET_VALIDVALUE_BSTR(pbstrOriginatorKeyFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_AssemblyOriginatorKeyFileValidValues
	{
		/*[in]*/ BSTR bstrOriginatorKeyFile;
		HRESULT retValue;
	};

	STDMETHOD(put_AssemblyOriginatorKeyFile)(
		/*[in]*/ BSTR bstrOriginatorKeyFile)
	{
		VSL_DEFINE_MOCK_METHOD(put_AssemblyOriginatorKeyFile)

		VSL_CHECK_VALIDVALUE_BSTR(bstrOriginatorKeyFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_AssemblyKeyContainerNameValidValues
	{
		/*[out,retval]*/ BSTR* pbstrKeyContainerName;
		HRESULT retValue;
	};

	STDMETHOD(get_AssemblyKeyContainerName)(
		/*[out,retval]*/ BSTR* pbstrKeyContainerName)
	{
		VSL_DEFINE_MOCK_METHOD(get_AssemblyKeyContainerName)

		VSL_SET_VALIDVALUE_BSTR(pbstrKeyContainerName);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_AssemblyKeyContainerNameValidValues
	{
		/*[in]*/ BSTR bstrKeyContainerName;
		HRESULT retValue;
	};

	STDMETHOD(put_AssemblyKeyContainerName)(
		/*[in]*/ BSTR bstrKeyContainerName)
	{
		VSL_DEFINE_MOCK_METHOD(put_AssemblyKeyContainerName)

		VSL_CHECK_VALIDVALUE_BSTR(bstrKeyContainerName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_AssemblyOriginatorKeyModeValidValues
	{
		/*[out,retval]*/ prjOriginatorKeyMode* pOriginatorKeyMode;
		HRESULT retValue;
	};

	STDMETHOD(get_AssemblyOriginatorKeyMode)(
		/*[out,retval]*/ prjOriginatorKeyMode* pOriginatorKeyMode)
	{
		VSL_DEFINE_MOCK_METHOD(get_AssemblyOriginatorKeyMode)

		VSL_SET_VALIDVALUE(pOriginatorKeyMode);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_AssemblyOriginatorKeyModeValidValues
	{
		/*[in]*/ prjOriginatorKeyMode originatorKeyMode;
		HRESULT retValue;
	};

	STDMETHOD(put_AssemblyOriginatorKeyMode)(
		/*[in]*/ prjOriginatorKeyMode originatorKeyMode)
	{
		VSL_DEFINE_MOCK_METHOD(put_AssemblyOriginatorKeyMode)

		VSL_CHECK_VALIDVALUE(originatorKeyMode);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DelaySignValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbDelaySign;
		HRESULT retValue;
	};

	STDMETHOD(get_DelaySign)(
		/*[out,retval]*/ VARIANT_BOOL* pbDelaySign)
	{
		VSL_DEFINE_MOCK_METHOD(get_DelaySign)

		VSL_SET_VALIDVALUE(pbDelaySign);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DelaySignValidValues
	{
		/*[in]*/ VARIANT_BOOL bDelaySign;
		HRESULT retValue;
	};

	STDMETHOD(put_DelaySign)(
		/*[in]*/ VARIANT_BOOL bDelaySign)
	{
		VSL_DEFINE_MOCK_METHOD(put_DelaySign)

		VSL_CHECK_VALIDVALUE(bDelaySign);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_WebServerValidValues
	{
		/*[out,retval]*/ BSTR* pbstrWebServer;
		HRESULT retValue;
	};

	STDMETHOD(get_WebServer)(
		/*[out,retval]*/ BSTR* pbstrWebServer)
	{
		VSL_DEFINE_MOCK_METHOD(get_WebServer)

		VSL_SET_VALIDVALUE_BSTR(pbstrWebServer);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_WebServerVersionValidValues
	{
		/*[out,retval]*/ BSTR* pbstrWebServerVersion;
		HRESULT retValue;
	};

	STDMETHOD(get_WebServerVersion)(
		/*[out,retval]*/ BSTR* pbstrWebServerVersion)
	{
		VSL_DEFINE_MOCK_METHOD(get_WebServerVersion)

		VSL_SET_VALIDVALUE_BSTR(pbstrWebServerVersion);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ServerExtensionsVersionValidValues
	{
		/*[out,retval]*/ BSTR* pbstrServerExtensionsVersion;
		HRESULT retValue;
	};

	STDMETHOD(get_ServerExtensionsVersion)(
		/*[out,retval]*/ BSTR* pbstrServerExtensionsVersion)
	{
		VSL_DEFINE_MOCK_METHOD(get_ServerExtensionsVersion)

		VSL_SET_VALIDVALUE_BSTR(pbstrServerExtensionsVersion);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_LinkRepairValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pLinkRepair;
		HRESULT retValue;
	};

	STDMETHOD(get_LinkRepair)(
		/*[out,retval]*/ VARIANT_BOOL* pLinkRepair)
	{
		VSL_DEFINE_MOCK_METHOD(get_LinkRepair)

		VSL_SET_VALIDVALUE(pLinkRepair);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_LinkRepairValidValues
	{
		/*[in]*/ VARIANT_BOOL linkRepair;
		HRESULT retValue;
	};

	STDMETHOD(put_LinkRepair)(
		/*[in]*/ VARIANT_BOOL linkRepair)
	{
		VSL_DEFINE_MOCK_METHOD(put_LinkRepair)

		VSL_CHECK_VALIDVALUE(linkRepair);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_OfflineURLValidValues
	{
		/*[out,retval]*/ BSTR* pbstrOfflineURL;
		HRESULT retValue;
	};

	STDMETHOD(get_OfflineURL)(
		/*[out,retval]*/ BSTR* pbstrOfflineURL)
	{
		VSL_DEFINE_MOCK_METHOD(get_OfflineURL)

		VSL_SET_VALIDVALUE_BSTR(pbstrOfflineURL);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_FileSharePathValidValues
	{
		/*[out,retval]*/ BSTR* pbstrFileSharePath;
		HRESULT retValue;
	};

	STDMETHOD(get_FileSharePath)(
		/*[out,retval]*/ BSTR* pbstrFileSharePath)
	{
		VSL_DEFINE_MOCK_METHOD(get_FileSharePath)

		VSL_SET_VALIDVALUE_BSTR(pbstrFileSharePath);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_FileSharePathValidValues
	{
		/*[in]*/ BSTR bstrFileSharePath;
		HRESULT retValue;
	};

	STDMETHOD(put_FileSharePath)(
		/*[in]*/ BSTR bstrFileSharePath)
	{
		VSL_DEFINE_MOCK_METHOD(put_FileSharePath)

		VSL_CHECK_VALIDVALUE_BSTR(bstrFileSharePath);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ActiveFileSharePathValidValues
	{
		/*[out,retval]*/ BSTR* pbstrFileSharePath;
		HRESULT retValue;
	};

	STDMETHOD(get_ActiveFileSharePath)(
		/*[out,retval]*/ BSTR* pbstrFileSharePath)
	{
		VSL_DEFINE_MOCK_METHOD(get_ActiveFileSharePath)

		VSL_SET_VALIDVALUE_BSTR(pbstrFileSharePath);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_WebAccessMethodValidValues
	{
		/*[out,retval]*/ prjWebAccessMethod* pWebAccessMethod;
		HRESULT retValue;
	};

	STDMETHOD(get_WebAccessMethod)(
		/*[out,retval]*/ prjWebAccessMethod* pWebAccessMethod)
	{
		VSL_DEFINE_MOCK_METHOD(get_WebAccessMethod)

		VSL_SET_VALIDVALUE(pWebAccessMethod);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_WebAccessMethodValidValues
	{
		/*[in]*/ prjWebAccessMethod authoringAccessMethod;
		HRESULT retValue;
	};

	STDMETHOD(put_WebAccessMethod)(
		/*[in]*/ prjWebAccessMethod authoringAccessMethod)
	{
		VSL_DEFINE_MOCK_METHOD(put_WebAccessMethod)

		VSL_CHECK_VALIDVALUE(authoringAccessMethod);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ActiveWebAccessMethodValidValues
	{
		/*[out,retval]*/ prjWebAccessMethod* pActiveWebAccessMethod;
		HRESULT retValue;
	};

	STDMETHOD(get_ActiveWebAccessMethod)(
		/*[out,retval]*/ prjWebAccessMethod* pActiveWebAccessMethod)
	{
		VSL_DEFINE_MOCK_METHOD(get_ActiveWebAccessMethod)

		VSL_SET_VALIDVALUE(pActiveWebAccessMethod);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DefaultClientScriptValidValues
	{
		/*[out,retval]*/ prjScriptLanguage* pScriptLanguage;
		HRESULT retValue;
	};

	STDMETHOD(get_DefaultClientScript)(
		/*[out,retval]*/ prjScriptLanguage* pScriptLanguage)
	{
		VSL_DEFINE_MOCK_METHOD(get_DefaultClientScript)

		VSL_SET_VALIDVALUE(pScriptLanguage);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DefaultClientScriptValidValues
	{
		/*[in]*/ prjScriptLanguage scriptLanguage;
		HRESULT retValue;
	};

	STDMETHOD(put_DefaultClientScript)(
		/*[in]*/ prjScriptLanguage scriptLanguage)
	{
		VSL_DEFINE_MOCK_METHOD(put_DefaultClientScript)

		VSL_CHECK_VALIDVALUE(scriptLanguage);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DefaultTargetSchemaValidValues
	{
		/*[out,retval]*/ prjTargetSchema* pTargetSchema;
		HRESULT retValue;
	};

	STDMETHOD(get_DefaultTargetSchema)(
		/*[out,retval]*/ prjTargetSchema* pTargetSchema)
	{
		VSL_DEFINE_MOCK_METHOD(get_DefaultTargetSchema)

		VSL_SET_VALIDVALUE(pTargetSchema);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DefaultTargetSchemaValidValues
	{
		/*[in]*/ prjTargetSchema htmlPlatform;
		HRESULT retValue;
	};

	STDMETHOD(put_DefaultTargetSchema)(
		/*[in]*/ prjTargetSchema htmlPlatform)
	{
		VSL_DEFINE_MOCK_METHOD(put_DefaultTargetSchema)

		VSL_CHECK_VALIDVALUE(htmlPlatform);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DefaultHTMLPageLayoutValidValues
	{
		/*[out,retval]*/ prjHTMLPageLayout* pHTMLPageLayout;
		HRESULT retValue;
	};

	STDMETHOD(get_DefaultHTMLPageLayout)(
		/*[out,retval]*/ prjHTMLPageLayout* pHTMLPageLayout)
	{
		VSL_DEFINE_MOCK_METHOD(get_DefaultHTMLPageLayout)

		VSL_SET_VALIDVALUE(pHTMLPageLayout);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DefaultHTMLPageLayoutValidValues
	{
		/*[in]*/ prjHTMLPageLayout htmlPageLayout;
		HRESULT retValue;
	};

	STDMETHOD(put_DefaultHTMLPageLayout)(
		/*[in]*/ prjHTMLPageLayout htmlPageLayout)
	{
		VSL_DEFINE_MOCK_METHOD(put_DefaultHTMLPageLayout)

		VSL_CHECK_VALIDVALUE(htmlPageLayout);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_FileNameValidValues
	{
		/*[out,retval]*/ BSTR* pbstrFileName;
		HRESULT retValue;
	};

	STDMETHOD(get_FileName)(
		/*[out,retval]*/ BSTR* pbstrFileName)
	{
		VSL_DEFINE_MOCK_METHOD(get_FileName)

		VSL_SET_VALIDVALUE_BSTR(pbstrFileName);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_FileNameValidValues
	{
		/*[in]*/ BSTR bstrFileName;
		HRESULT retValue;
	};

	STDMETHOD(put_FileName)(
		/*[in]*/ BSTR bstrFileName)
	{
		VSL_DEFINE_MOCK_METHOD(put_FileName)

		VSL_CHECK_VALIDVALUE_BSTR(bstrFileName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_FullPathValidValues
	{
		/*[out,retval]*/ BSTR* pbstrFullPath;
		HRESULT retValue;
	};

	STDMETHOD(get_FullPath)(
		/*[out,retval]*/ BSTR* pbstrFullPath)
	{
		VSL_DEFINE_MOCK_METHOD(get_FullPath)

		VSL_SET_VALIDVALUE_BSTR(pbstrFullPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_LocalPathValidValues
	{
		/*[out,retval]*/ BSTR* pbstrLocalPath;
		HRESULT retValue;
	};

	STDMETHOD(get_LocalPath)(
		/*[out,retval]*/ BSTR* pbstrLocalPath)
	{
		VSL_DEFINE_MOCK_METHOD(get_LocalPath)

		VSL_SET_VALIDVALUE_BSTR(pbstrLocalPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_URLValidValues
	{
		/*[out,retval]*/ BSTR* pbstrURL;
		HRESULT retValue;
	};

	STDMETHOD(get_URL)(
		/*[out,retval]*/ BSTR* pbstrURL)
	{
		VSL_DEFINE_MOCK_METHOD(get_URL)

		VSL_SET_VALIDVALUE_BSTR(pbstrURL);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ActiveConfigurationSettingsValidValues
	{
		/*[out,retval]*/ ProjectConfigurationProperties** ppVBProjConfigProps;
		HRESULT retValue;
	};

	STDMETHOD(get_ActiveConfigurationSettings)(
		/*[out,retval]*/ ProjectConfigurationProperties** ppVBProjConfigProps)
	{
		VSL_DEFINE_MOCK_METHOD(get_ActiveConfigurationSettings)

		VSL_SET_VALIDVALUE_INTERFACE(ppVBProjConfigProps);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderValidValues
	{
		/*[in]*/ BSTR ExtenderName;
		/*[out,retval]*/ IDispatch** Extender;
		HRESULT retValue;
	};

	STDMETHOD(get_Extender)(
		/*[in]*/ BSTR ExtenderName,
		/*[out,retval]*/ IDispatch** Extender)
	{
		VSL_DEFINE_MOCK_METHOD(get_Extender)

		VSL_CHECK_VALIDVALUE_BSTR(ExtenderName);

		VSL_SET_VALIDVALUE_INTERFACE(Extender);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderNamesValidValues
	{
		/*[out,retval]*/ VARIANT* ExtenderNames;
		HRESULT retValue;
	};

	STDMETHOD(get_ExtenderNames)(
		/*[out,retval]*/ VARIANT* ExtenderNames)
	{
		VSL_DEFINE_MOCK_METHOD(get_ExtenderNames)

		VSL_SET_VALIDVALUE_VARIANT(ExtenderNames);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderCATIDValidValues
	{
		/*[out,retval]*/ BSTR* pRetval;
		HRESULT retValue;
	};

	STDMETHOD(get_ExtenderCATID)(
		/*[out,retval]*/ BSTR* pRetval)
	{
		VSL_DEFINE_MOCK_METHOD(get_ExtenderCATID)

		VSL_SET_VALIDVALUE_BSTR(pRetval);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ApplicationIconValidValues
	{
		/*[out,retval]*/ BSTR* pbstrApplicationIcon;
		HRESULT retValue;
	};

	STDMETHOD(get_ApplicationIcon)(
		/*[out,retval]*/ BSTR* pbstrApplicationIcon)
	{
		VSL_DEFINE_MOCK_METHOD(get_ApplicationIcon)

		VSL_SET_VALIDVALUE_BSTR(pbstrApplicationIcon);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_ApplicationIconValidValues
	{
		/*[in]*/ BSTR bstrApplicationIcon;
		HRESULT retValue;
	};

	STDMETHOD(put_ApplicationIcon)(
		/*[in]*/ BSTR bstrApplicationIcon)
	{
		VSL_DEFINE_MOCK_METHOD(put_ApplicationIcon)

		VSL_CHECK_VALIDVALUE_BSTR(bstrApplicationIcon);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_OptionStrictValidValues
	{
		/*[out,retval]*/ prjOptionStrict* pOptionStrict;
		HRESULT retValue;
	};

	STDMETHOD(get_OptionStrict)(
		/*[out,retval]*/ prjOptionStrict* pOptionStrict)
	{
		VSL_DEFINE_MOCK_METHOD(get_OptionStrict)

		VSL_SET_VALIDVALUE(pOptionStrict);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_OptionStrictValidValues
	{
		/*[in]*/ prjOptionStrict optionStrict;
		HRESULT retValue;
	};

	STDMETHOD(put_OptionStrict)(
		/*[in]*/ prjOptionStrict optionStrict)
	{
		VSL_DEFINE_MOCK_METHOD(put_OptionStrict)

		VSL_CHECK_VALIDVALUE(optionStrict);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ReferencePathValidValues
	{
		/*[out,retval]*/ BSTR* pbstrReferencePath;
		HRESULT retValue;
	};

	STDMETHOD(get_ReferencePath)(
		/*[out,retval]*/ BSTR* pbstrReferencePath)
	{
		VSL_DEFINE_MOCK_METHOD(get_ReferencePath)

		VSL_SET_VALIDVALUE_BSTR(pbstrReferencePath);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_ReferencePathValidValues
	{
		/*[in]*/ BSTR bstrReferencePath;
		HRESULT retValue;
	};

	STDMETHOD(put_ReferencePath)(
		/*[in]*/ BSTR bstrReferencePath)
	{
		VSL_DEFINE_MOCK_METHOD(put_ReferencePath)

		VSL_CHECK_VALIDVALUE_BSTR(bstrReferencePath);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_OutputFileNameValidValues
	{
		/*[out,retval]*/ BSTR* pbstrOutputFileName;
		HRESULT retValue;
	};

	STDMETHOD(get_OutputFileName)(
		/*[out,retval]*/ BSTR* pbstrOutputFileName)
	{
		VSL_DEFINE_MOCK_METHOD(get_OutputFileName)

		VSL_SET_VALIDVALUE_BSTR(pbstrOutputFileName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_AbsoluteProjectDirectoryValidValues
	{
		/*[out,retval]*/ BSTR* pbstrDir;
		HRESULT retValue;
	};

	STDMETHOD(get_AbsoluteProjectDirectory)(
		/*[out,retval]*/ BSTR* pbstrDir)
	{
		VSL_DEFINE_MOCK_METHOD(get_AbsoluteProjectDirectory)

		VSL_SET_VALIDVALUE_BSTR(pbstrDir);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_OptionExplicitValidValues
	{
		/*[out,retval]*/ prjOptionExplicit* pOptionExplicit;
		HRESULT retValue;
	};

	STDMETHOD(get_OptionExplicit)(
		/*[out,retval]*/ prjOptionExplicit* pOptionExplicit)
	{
		VSL_DEFINE_MOCK_METHOD(get_OptionExplicit)

		VSL_SET_VALIDVALUE(pOptionExplicit);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_OptionExplicitValidValues
	{
		/*[in]*/ prjOptionExplicit optionExplicit;
		HRESULT retValue;
	};

	STDMETHOD(put_OptionExplicit)(
		/*[in]*/ prjOptionExplicit optionExplicit)
	{
		VSL_DEFINE_MOCK_METHOD(put_OptionExplicit)

		VSL_CHECK_VALIDVALUE(optionExplicit);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_OptionCompareValidValues
	{
		/*[out,retval]*/ prjCompare* pOptionCompare;
		HRESULT retValue;
	};

	STDMETHOD(get_OptionCompare)(
		/*[out,retval]*/ prjCompare* pOptionCompare)
	{
		VSL_DEFINE_MOCK_METHOD(get_OptionCompare)

		VSL_SET_VALIDVALUE(pOptionCompare);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_OptionCompareValidValues
	{
		/*[in]*/ prjCompare optionCompare;
		HRESULT retValue;
	};

	STDMETHOD(put_OptionCompare)(
		/*[in]*/ prjCompare optionCompare)
	{
		VSL_DEFINE_MOCK_METHOD(put_OptionCompare)

		VSL_CHECK_VALIDVALUE(optionCompare);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ProjectTypeValidValues
	{
		/*[out,retval]*/ prjProjectType* pProjectType;
		HRESULT retValue;
	};

	STDMETHOD(get_ProjectType)(
		/*[out,retval]*/ prjProjectType* pProjectType)
	{
		VSL_DEFINE_MOCK_METHOD(get_ProjectType)

		VSL_SET_VALIDVALUE(pProjectType);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DefaultNamespaceValidValues
	{
		/*[out,retval]*/ BSTR* pbstrRootNamespace;
		HRESULT retValue;
	};

	STDMETHOD(get_DefaultNamespace)(
		/*[out,retval]*/ BSTR* pbstrRootNamespace)
	{
		VSL_DEFINE_MOCK_METHOD(get_DefaultNamespace)

		VSL_SET_VALIDVALUE_BSTR(pbstrRootNamespace);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DefaultNamespaceValidValues
	{
		/*[in]*/ BSTR bstrRootNamespace;
		HRESULT retValue;
	};

	STDMETHOD(put_DefaultNamespace)(
		/*[in]*/ BSTR bstrRootNamespace)
	{
		VSL_DEFINE_MOCK_METHOD(put_DefaultNamespace)

		VSL_CHECK_VALIDVALUE_BSTR(bstrRootNamespace);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // PROJECTPROPERTIES2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockReference.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef REFERENCE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define REFERENCE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vslangproj.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ReferenceNotImpl :
	public Reference
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ReferenceNotImpl)

public:

	typedef Reference Interface;

	STDMETHOD(get_DTE)(
		/*[out,retval]*/ DTE** /*ppDTE*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Collection)(
		/*[out,retval]*/ References** /*ppProjectReferences*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ContainingProject)(
		/*[out,retval]*/ Project** /*ppProject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Remove)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Name)(
		/*[out,retval]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Type)(
		/*[out,retval]*/ prjReferenceType* /*pType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Identity)(
		/*[out,retval]*/ BSTR* /*pbstrIdentity*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Path)(
		/*[out,retval]*/ BSTR* /*pbstrPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Description)(
		/*[out,retval]*/ BSTR* /*pbstrDesc*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Culture)(
		/*[out,retval]*/ BSTR* /*pbstrCulture*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_MajorVersion)(
		/*[out,retval]*/ long* /*plMajorVer*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_MinorVersion)(
		/*[out,retval]*/ long* /*plMinorVer*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_RevisionNumber)(
		/*[out,retval]*/ long* /*plRevNo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_BuildNumber)(
		/*[out,retval]*/ long* /*plBuildNo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_StrongName)(
		/*[out,retval]*/ VARIANT_BOOL* /*pfStrongName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_SourceProject)(
		/*[out,retval]*/ Project** /*ppProject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_CopyLocal)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbCopyLocal*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_CopyLocal)(
		/*[in]*/ VARIANT_BOOL /*bCopyLocal*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Extender)(
		/*[in]*/ BSTR /*ExtenderName*/,
		/*[out,retval]*/ IDispatch** /*Extender*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ExtenderNames)(
		/*[out,retval]*/ VARIANT* /*ExtenderNames*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ExtenderCATID)(
		/*[out,retval]*/ BSTR* /*pRetval*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_PublicKeyToken)(
		/*[out,retval]*/ BSTR* /*pbstrPublicKeyToken*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Version)(
		/*[out,retval]*/ BSTR* /*pbstrVersion*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class ReferenceMockImpl :
	public Reference,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ReferenceMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ReferenceMockImpl)

	typedef Reference Interface;
	struct get_DTEValidValues
	{
		/*[out,retval]*/ DTE** ppDTE;
		HRESULT retValue;
	};

	STDMETHOD(get_DTE)(
		/*[out,retval]*/ DTE** ppDTE)
	{
		VSL_DEFINE_MOCK_METHOD(get_DTE)

		VSL_SET_VALIDVALUE(ppDTE);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CollectionValidValues
	{
		/*[out,retval]*/ References** ppProjectReferences;
		HRESULT retValue;
	};

	STDMETHOD(get_Collection)(
		/*[out,retval]*/ References** ppProjectReferences)
	{
		VSL_DEFINE_MOCK_METHOD(get_Collection)

		VSL_SET_VALIDVALUE_INTERFACE(ppProjectReferences);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ContainingProjectValidValues
	{
		/*[out,retval]*/ Project** ppProject;
		HRESULT retValue;
	};

	STDMETHOD(get_ContainingProject)(
		/*[out,retval]*/ Project** ppProject)
	{
		VSL_DEFINE_MOCK_METHOD(get_ContainingProject)

		VSL_SET_VALIDVALUE(ppProject);

		VSL_RETURN_VALIDVALUES();
	}
	struct RemoveValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Remove)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Remove)

		VSL_RETURN_VALIDVALUES();
	}
	struct get_NameValidValues
	{
		/*[out,retval]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(get_Name)(
		/*[out,retval]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(get_Name)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_TypeValidValues
	{
		/*[out,retval]*/ prjReferenceType* pType;
		HRESULT retValue;
	};

	STDMETHOD(get_Type)(
		/*[out,retval]*/ prjReferenceType* pType)
	{
		VSL_DEFINE_MOCK_METHOD(get_Type)

		VSL_SET_VALIDVALUE(pType);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_IdentityValidValues
	{
		/*[out,retval]*/ BSTR* pbstrIdentity;
		HRESULT retValue;
	};

	STDMETHOD(get_Identity)(
		/*[out,retval]*/ BSTR* pbstrIdentity)
	{
		VSL_DEFINE_MOCK_METHOD(get_Identity)

		VSL_SET_VALIDVALUE_BSTR(pbstrIdentity);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_PathValidValues
	{
		/*[out,retval]*/ BSTR* pbstrPath;
		HRESULT retValue;
	};

	STDMETHOD(get_Path)(
		/*[out,retval]*/ BSTR* pbstrPath)
	{
		VSL_DEFINE_MOCK_METHOD(get_Path)

		VSL_SET_VALIDVALUE_BSTR(pbstrPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DescriptionValidValues
	{
		/*[out,retval]*/ BSTR* pbstrDesc;
		HRESULT retValue;
	};

	STDMETHOD(get_Description)(
		/*[out,retval]*/ BSTR* pbstrDesc)
	{
		VSL_DEFINE_MOCK_METHOD(get_Description)

		VSL_SET_VALIDVALUE_BSTR(pbstrDesc);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CultureValidValues
	{
		/*[out,retval]*/ BSTR* pbstrCulture;
		HRESULT retValue;
	};

	STDMETHOD(get_Culture)(
		/*[out,retval]*/ BSTR* pbstrCulture)
	{
		VSL_DEFINE_MOCK_METHOD(get_Culture)

		VSL_SET_VALIDVALUE_BSTR(pbstrCulture);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_MajorVersionValidValues
	{
		/*[out,retval]*/ long* plMajorVer;
		HRESULT retValue;
	};

	STDMETHOD(get_MajorVersion)(
		/*[out,retval]*/ long* plMajorVer)
	{
		VSL_DEFINE_MOCK_METHOD(get_MajorVersion)

		VSL_SET_VALIDVALUE(plMajorVer);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_MinorVersionValidValues
	{
		/*[out,retval]*/ long* plMinorVer;
		HRESULT retValue;
	};

	STDMETHOD(get_MinorVersion)(
		/*[out,retval]*/ long* plMinorVer)
	{
		VSL_DEFINE_MOCK_METHOD(get_MinorVersion)

		VSL_SET_VALIDVALUE(plMinorVer);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_RevisionNumberValidValues
	{
		/*[out,retval]*/ long* plRevNo;
		HRESULT retValue;
	};

	STDMETHOD(get_RevisionNumber)(
		/*[out,retval]*/ long* plRevNo)
	{
		VSL_DEFINE_MOCK_METHOD(get_RevisionNumber)

		VSL_SET_VALIDVALUE(plRevNo);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_BuildNumberValidValues
	{
		/*[out,retval]*/ long* plBuildNo;
		HRESULT retValue;
	};

	STDMETHOD(get_BuildNumber)(
		/*[out,retval]*/ long* plBuildNo)
	{
		VSL_DEFINE_MOCK_METHOD(get_BuildNumber)

		VSL_SET_VALIDVALUE(plBuildNo);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_StrongNameValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pfStrongName;
		HRESULT retValue;
	};

	STDMETHOD(get_StrongName)(
		/*[out,retval]*/ VARIANT_BOOL* pfStrongName)
	{
		VSL_DEFINE_MOCK_METHOD(get_StrongName)

		VSL_SET_VALIDVALUE(pfStrongName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_SourceProjectValidValues
	{
		/*[out,retval]*/ Project** ppProject;
		HRESULT retValue;
	};

	STDMETHOD(get_SourceProject)(
		/*[out,retval]*/ Project** ppProject)
	{
		VSL_DEFINE_MOCK_METHOD(get_SourceProject)

		VSL_SET_VALIDVALUE(ppProject);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CopyLocalValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbCopyLocal;
		HRESULT retValue;
	};

	STDMETHOD(get_CopyLocal)(
		/*[out,retval]*/ VARIANT_BOOL* pbCopyLocal)
	{
		VSL_DEFINE_MOCK_METHOD(get_CopyLocal)

		VSL_SET_VALIDVALUE(pbCopyLocal);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_CopyLocalValidValues
	{
		/*[in]*/ VARIANT_BOOL bCopyLocal;
		HRESULT retValue;
	};

	STDMETHOD(put_CopyLocal)(
		/*[in]*/ VARIANT_BOOL bCopyLocal)
	{
		VSL_DEFINE_MOCK_METHOD(put_CopyLocal)

		VSL_CHECK_VALIDVALUE(bCopyLocal);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderValidValues
	{
		/*[in]*/ BSTR ExtenderName;
		/*[out,retval]*/ IDispatch** Extender;
		HRESULT retValue;
	};

	STDMETHOD(get_Extender)(
		/*[in]*/ BSTR ExtenderName,
		/*[out,retval]*/ IDispatch** Extender)
	{
		VSL_DEFINE_MOCK_METHOD(get_Extender)

		VSL_CHECK_VALIDVALUE_BSTR(ExtenderName);

		VSL_SET_VALIDVALUE_INTERFACE(Extender);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderNamesValidValues
	{
		/*[out,retval]*/ VARIANT* ExtenderNames;
		HRESULT retValue;
	};

	STDMETHOD(get_ExtenderNames)(
		/*[out,retval]*/ VARIANT* ExtenderNames)
	{
		VSL_DEFINE_MOCK_METHOD(get_ExtenderNames)

		VSL_SET_VALIDVALUE_VARIANT(ExtenderNames);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderCATIDValidValues
	{
		/*[out,retval]*/ BSTR* pRetval;
		HRESULT retValue;
	};

	STDMETHOD(get_ExtenderCATID)(
		/*[out,retval]*/ BSTR* pRetval)
	{
		VSL_DEFINE_MOCK_METHOD(get_ExtenderCATID)

		VSL_SET_VALIDVALUE_BSTR(pRetval);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_PublicKeyTokenValidValues
	{
		/*[out,retval]*/ BSTR* pbstrPublicKeyToken;
		HRESULT retValue;
	};

	STDMETHOD(get_PublicKeyToken)(
		/*[out,retval]*/ BSTR* pbstrPublicKeyToken)
	{
		VSL_DEFINE_MOCK_METHOD(get_PublicKeyToken)

		VSL_SET_VALIDVALUE_BSTR(pbstrPublicKeyToken);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_VersionValidValues
	{
		/*[out,retval]*/ BSTR* pbstrVersion;
		HRESULT retValue;
	};

	STDMETHOD(get_Version)(
		/*[out,retval]*/ BSTR* pbstrVersion)
	{
		VSL_DEFINE_MOCK_METHOD(get_Version)

		VSL_SET_VALIDVALUE_BSTR(pbstrVersion);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // REFERENCE_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockReferences.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef REFERENCES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define REFERENCES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vslangproj.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class ReferencesNotImpl :
	public References
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ReferencesNotImpl)

public:

	typedef References Interface;

	STDMETHOD(get_DTE)(
		/*[out,retval]*/ DTE** /*ppDTE*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Parent)(
		/*[out,retval]*/ IDispatch** /*ppdispParent*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ContainingProject)(
		/*[out,retval]*/ Project** /*ppProject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Count)(
		/*[out,retval]*/ long* /*plCount*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Item)(
		/*[in]*/ VARIANT /*index*/,
		/*[out,retval]*/ Reference** /*ppProjectReference*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(_NewEnum)(
		/*[out,retval]*/ IUnknown** /*ppiuReturn*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Find)(
		/*[in]*/ BSTR /*bstrIdentity*/,
		/*[out,retval]*/ Reference** /*ppProjectReference*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Add)(
		/*[in]*/ BSTR /*bstrPath*/,
		/*[out,retval]*/ Reference** /*ppProjectReference*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddActiveX)(
		/*[in]*/ BSTR /*bstrTypeLibGuid*/,
		/*[in,defaultvalue(0)]*/ long /*lMajorVer*/,
		/*[in,defaultvalue(0)]*/ long /*lMinorVer*/,
		/*[in,defaultvalue(0)]*/ long /*lLocaleId*/,
		/*[in,defaultvalue("")]*/ BSTR /*bstrWrapperTool*/,
		/*[out,retval]*/ Reference** /*ppProjectReference*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddProject)(
		/*[in]*/ Project* /*pProject*/,
		/*[out,retval]*/ Reference** /*ppProjectReference*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class ReferencesMockImpl :
	public References,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(ReferencesMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(ReferencesMockImpl)

	typedef References Interface;
	struct get_DTEValidValues
	{
		/*[out,retval]*/ DTE** ppDTE;
		HRESULT retValue;
	};

	STDMETHOD(get_DTE)(
		/*[out,retval]*/ DTE** ppDTE)
	{
		VSL_DEFINE_MOCK_METHOD(get_DTE)

		VSL_SET_VALIDVALUE(ppDTE);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ParentValidValues
	{
		/*[out,retval]*/ IDispatch** ppdispParent;
		HRESULT retValue;
	};

	STDMETHOD(get_Parent)(
		/*[out,retval]*/ IDispatch** ppdispParent)
	{
		VSL_DEFINE_MOCK_METHOD(get_Parent)

		VSL_SET_VALIDVALUE_INTERFACE(ppdispParent);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ContainingProjectValidValues
	{
		/*[out,retval]*/ Project** ppProject;
		HRESULT retValue;
	};

	STDMETHOD(get_ContainingProject)(
		/*[out,retval]*/ Project** ppProject)
	{
		VSL_DEFINE_MOCK_METHOD(get_ContainingProject)

		VSL_SET_VALIDVALUE(ppProject);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CountValidValues
	{
		/*[out,retval]*/ long* plCount;
		HRESULT retValue;
	};

	STDMETHOD(get_Count)(
		/*[out,retval]*/ long* plCount)
	{
		VSL_DEFINE_MOCK_METHOD(get_Count)

		VSL_SET_VALIDVALUE(plCount);

		VSL_RETURN_VALIDVALUES();
	}
	struct ItemValidValues
	{
		/*[in]*/ VARIANT index;
		/*[out,retval]*/ Reference** ppProjectReference;
		HRESULT retValue;
	};

	STDMETHOD(Item)(
		/*[in]*/ VARIANT index,
		/*[out,retval]*/ Reference** ppProjectReference)
	{
		VSL_DEFINE_MOCK_METHOD(Item)

		VSL_CHECK_VALIDVALUE(index);

		VSL_SET_VALIDVALUE_INTERFACE(ppProjectReference);

		VSL_RETURN_VALIDVALUES();
	}
	struct _NewEnumValidValues
	{
		/*[out,retval]*/ IUnknown** ppiuReturn;
		HRESULT retValue;
	};

	STDMETHOD(_NewEnum)(
		/*[out,retval]*/ IUnknown** ppiuReturn)
	{
		VSL_DEFINE_MOCK_METHOD(_NewEnum)

		VSL_SET_VALIDVALUE_INTERFACE(ppiuReturn);

		VSL_RETURN_VALIDVALUES();
	}
	struct FindValidValues
	{
		/*[in]*/ BSTR bstrIdentity;
		/*[out,retval]*/ Reference** ppProjectReference;
		HRESULT retValue;
	};

	STDMETHOD(Find)(
		/*[in]*/ BSTR bstrIdentity,
		/*[out,retval]*/ Reference** ppProjectReference)
	{
		VSL_DEFINE_MOCK_METHOD(Find)

		VSL_CHECK_VALIDVALUE_BSTR(bstrIdentity);

		VSL_SET_VALIDVALUE_INTERFACE(ppProjectReference);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddValidValues
	{
		/*[in]*/ BSTR bstrPath;
		/*[out,retval]*/ Reference** ppProjectReference;
		HRESULT retValue;
	};

	STDMETHOD(Add)(
		/*[in]*/ BSTR bstrPath,
		/*[out,retval]*/ Reference** ppProjectReference)
	{
		VSL_DEFINE_MOCK_METHOD(Add)

		VSL_CHECK_VALIDVALUE_BSTR(bstrPath);

		VSL_SET_VALIDVALUE_INTERFACE(ppProjectReference);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddActiveXValidValues
	{
		/*[in]*/ BSTR bstrTypeLibGuid;
		/*[in,defaultvalue(0)]*/ long lMajorVer;
		/*[in,defaultvalue(0)]*/ long lMinorVer;
		/*[in,defaultvalue(0)]*/ long lLocaleId;
		/*[in,defaultvalue("")]*/ BSTR bstrWrapperTool;
		/*[out,retval]*/ Reference** ppProjectReference;
		HRESULT retValue;
	};

	STDMETHOD(AddActiveX)(
		/*[in]*/ BSTR bstrTypeLibGuid,
		/*[in,defaultvalue(0)]*/ long lMajorVer,
		/*[in,defaultvalue(0)]*/ long lMinorVer,
		/*[in,defaultvalue(0)]*/ long lLocaleId,
		/*[in,defaultvalue("")]*/ BSTR bstrWrapperTool,
		/*[out,retval]*/ Reference** ppProjectReference)
	{
		VSL_DEFINE_MOCK_METHOD(AddActiveX)

		VSL_CHECK_VALIDVALUE_BSTR(bstrTypeLibGuid);

		VSL_CHECK_VALIDVALUE(lMajorVer);

		VSL_CHECK_VALIDVALUE(lMinorVer);

		VSL_CHECK_VALIDVALUE(lLocaleId);

		VSL_CHECK_VALIDVALUE_BSTR(bstrWrapperTool);

		VSL_SET_VALIDVALUE_INTERFACE(ppProjectReference);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddProjectValidValues
	{
		/*[in]*/ Project* pProject;
		/*[out,retval]*/ Reference** ppProjectReference;
		HRESULT retValue;
	};

	STDMETHOD(AddProject)(
		/*[in]*/ Project* pProject,
		/*[out,retval]*/ Reference** ppProjectReference)
	{
		VSL_DEFINE_MOCK_METHOD(AddProject)

		VSL_CHECK_VALIDVALUE_POINTER(pProject);

		VSL_SET_VALIDVALUE_INTERFACE(ppProjectReference);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // REFERENCES_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockVBPackageSettings.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef VBPACKAGESETTINGS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define VBPACKAGESETTINGS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vslangproj2.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class VBPackageSettingsNotImpl :
	public VBPackageSettings
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(VBPackageSettingsNotImpl)

public:

	typedef VBPackageSettings Interface;

	STDMETHOD(get_OptionExplicit)(
		/*[out,retval]*/ pkgOptionExplicit* /*pOptionExplicit*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_OptionExplicit)(
		/*[in]*/ pkgOptionExplicit /*optionExplicit*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_OptionCompare)(
		/*[out,retval]*/ pkgCompare* /*pOptionCompare*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_OptionCompare)(
		/*[in]*/ pkgCompare /*optionCompare*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_OptionStrict)(
		/*[out,retval]*/ pkgOptionStrict* /*pOptionStrict*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_OptionStrict)(
		/*[in]*/ pkgOptionStrict /*optionStrict*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class VBPackageSettingsMockImpl :
	public VBPackageSettings,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(VBPackageSettingsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(VBPackageSettingsMockImpl)

	typedef VBPackageSettings Interface;
	struct get_OptionExplicitValidValues
	{
		/*[out,retval]*/ pkgOptionExplicit* pOptionExplicit;
		HRESULT retValue;
	};

	STDMETHOD(get_OptionExplicit)(
		/*[out,retval]*/ pkgOptionExplicit* pOptionExplicit)
	{
		VSL_DEFINE_MOCK_METHOD(get_OptionExplicit)

		VSL_SET_VALIDVALUE(pOptionExplicit);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_OptionExplicitValidValues
	{
		/*[in]*/ pkgOptionExplicit optionExplicit;
		HRESULT retValue;
	};

	STDMETHOD(put_OptionExplicit)(
		/*[in]*/ pkgOptionExplicit optionExplicit)
	{
		VSL_DEFINE_MOCK_METHOD(put_OptionExplicit)

		VSL_CHECK_VALIDVALUE(optionExplicit);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_OptionCompareValidValues
	{
		/*[out,retval]*/ pkgCompare* pOptionCompare;
		HRESULT retValue;
	};

	STDMETHOD(get_OptionCompare)(
		/*[out,retval]*/ pkgCompare* pOptionCompare)
	{
		VSL_DEFINE_MOCK_METHOD(get_OptionCompare)

		VSL_SET_VALIDVALUE(pOptionCompare);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_OptionCompareValidValues
	{
		/*[in]*/ pkgCompare optionCompare;
		HRESULT retValue;
	};

	STDMETHOD(put_OptionCompare)(
		/*[in]*/ pkgCompare optionCompare)
	{
		VSL_DEFINE_MOCK_METHOD(put_OptionCompare)

		VSL_CHECK_VALIDVALUE(optionCompare);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_OptionStrictValidValues
	{
		/*[out,retval]*/ pkgOptionStrict* pOptionStrict;
		HRESULT retValue;
	};

	STDMETHOD(get_OptionStrict)(
		/*[out,retval]*/ pkgOptionStrict* pOptionStrict)
	{
		VSL_DEFINE_MOCK_METHOD(get_OptionStrict)

		VSL_SET_VALIDVALUE(pOptionStrict);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_OptionStrictValidValues
	{
		/*[in]*/ pkgOptionStrict optionStrict;
		HRESULT retValue;
	};

	STDMETHOD(put_OptionStrict)(
		/*[in]*/ pkgOptionStrict optionStrict)
	{
		VSL_DEFINE_MOCK_METHOD(put_OptionStrict)

		VSL_CHECK_VALIDVALUE(optionStrict);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // VBPACKAGESETTINGS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockVBProjectProperties3.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef VBPROJECTPROPERTIES3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define VBPROJECTPROPERTIES3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vslangproj80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class VBProjectProperties3NotImpl :
	public VBProjectProperties3
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(VBProjectProperties3NotImpl)

public:

	typedef VBProjectProperties3 Interface;

	STDMETHOD(get_MyApplication)(
		/*[out,retval]*/ IDispatch** /*ppdispMyApplication*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_MyType)(
		/*[out,retval]*/ BSTR* /*pbstrMyType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_MyType)(
		/*[in]*/ BSTR /*MyType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Title)(
		/*[out,retval]*/ BSTR* /*pbstrTitle*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_Title)(
		/*[in]*/ BSTR /*Title*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Description)(
		/*[out,retval]*/ BSTR* /*pbstrDescription*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_Description)(
		/*[in]*/ BSTR /*Description*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Company)(
		/*[out,retval]*/ BSTR* /*pbstrCompany*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_Company)(
		/*[in]*/ BSTR /*Company*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Product)(
		/*[out,retval]*/ BSTR* /*pbstrProduct*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_Product)(
		/*[in]*/ BSTR /*Product*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Copyright)(
		/*[out,retval]*/ BSTR* /*pbstrCopyright*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_Copyright)(
		/*[in]*/ BSTR /*Copyright*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Trademark)(
		/*[out,retval]*/ BSTR* /*pbstrTrademark*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_Trademark)(
		/*[in]*/ BSTR /*Trademark*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_AssemblyType)(
		/*[out,retval]*/ prjAssemblyType* /*pAssemblyType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_AssemblyType)(
		/*[in]*/ prjAssemblyType /*AssemblyType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_TypeComplianceDiagnostics)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbTypeComplianceDiagnostics*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_TypeComplianceDiagnostics)(
		/*[in]*/ VARIANT_BOOL /*TypeComplianceDiagnostics*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Win32ResourceFile)(
		/*[out,retval]*/ BSTR* /*pbstrW32ResourceFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_Win32ResourceFile)(
		/*[in]*/ BSTR /*Win32ResourceFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_AssemblyKeyProviderName)(
		/*[out,retval]*/ BSTR* /*pbstrKeyProviderName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_AssemblyKeyProviderName)(
		/*[in]*/ BSTR /*KeyProviderName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_AssemblyOriginatorKeyFileType)(
		/*[out,retval]*/ DWORD* /*pdwOriginatorKeyFileType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_AssemblyOriginatorKeyFileType)(
		/*[in]*/ DWORD /*OriginatorKeyFileType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_AssemblyVersion)(
		/*[out,retval]*/ BSTR* /*pbstrAssemblyVersion*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_AssemblyVersion)(
		/*[in]*/ BSTR /*AssemblyVersion*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_AssemblyFileVersion)(
		/*[out,retval]*/ BSTR* /*pbstrAssemblyFileVersion*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_AssemblyFileVersion)(
		/*[in]*/ BSTR /*AssemblyFileVersion*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_GenerateManifests)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbGenerateManifests*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_GenerateManifests)(
		/*[in]*/ VARIANT_BOOL /*GenerateManifests*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_EnableSecurityDebugging)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbEnableSecurityDebugging*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_EnableSecurityDebugging)(
		/*[in]*/ VARIANT_BOOL /*EnableSecurityDebugging*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DebugSecurityZoneURL)(
		/*[out,retval]*/ BSTR* /*pbstrSecurityURL*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DebugSecurityZoneURL)(
		/*[in]*/ BSTR /*SecurityURL*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Publish)(
		/*[out,retval]*/ IDispatch** /*ppdispPublish*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ComVisible)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbComVisible*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_ComVisible)(
		/*[in]*/ VARIANT_BOOL /*ComVisible*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_AssemblyGuid)(
		/*[out,retval]*/ BSTR* /*pbstrAssemblyGuid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_AssemblyGuid)(
		/*[in]*/ BSTR /*AssemblyGuid*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_NeutralResourcesLanguage)(
		/*[out,retval]*/ BSTR* /*pbstrNeutralResourcesLanguage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_NeutralResourcesLanguage)(
		/*[in]*/ BSTR /*NeutralResourcesLanguage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_SignAssembly)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbSignAssembly*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_SignAssembly)(
		/*[in]*/ VARIANT_BOOL /*SignAssembly*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_SignManifests)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbSignManifests*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_SignManifests)(
		/*[in]*/ VARIANT_BOOL /*bSignManifests*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_TargetZone)(
		/*[out,retval]*/ BSTR* /*pbstrTargetZone*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_TargetZone)(
		/*[in]*/ BSTR /*TargetZone*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ExcludedPermissions)(
		/*[out,retval]*/ BSTR* /*pbstrExcludedPermissions*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_ExcludedPermissions)(
		/*[in]*/ BSTR /*ExcludedPermissions*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ManifestCertificateThumbprint)(
		/*[out,retval]*/ BSTR* /*pbstrManifestCertificateThumbprint*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_ManifestCertificateThumbprint)(
		/*[in]*/ BSTR /*ManifestCertificateThumbprint*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ManifestKeyFile)(
		/*[out,retval]*/ BSTR* /*pbstrManifestKeyFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_ManifestKeyFile)(
		/*[in]*/ BSTR /*ManifestKeyFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ManifestTimestampUrl)(
		/*[out,retval]*/ BSTR* /*pbstrManifestTimestampUrl*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_ManifestTimestampUrl)(
		/*[in]*/ BSTR /*ManifestTimestampUrl*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_PreBuildEvent)(
		/*[out,retval]*/ BSTR* /*pbstrOut*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_PreBuildEvent)(
		/*[in]*/ BSTR /*bstrIn*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_PostBuildEvent)(
		/*[out,retval]*/ BSTR* /*pbstrOut*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_PostBuildEvent)(
		/*[in]*/ BSTR /*bstrIn*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_RunPostBuildEvent)(
		/*[out,retval]*/ prjRunPostBuildEvent* /*pOut*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_RunPostBuildEvent)(
		/*[in]*/ prjRunPostBuildEvent /*run*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_AspnetVersion)(
		/*[out,retval]*/ BSTR* /*pOut*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get___id)(
		/*[out,retval]*/ BSTR* /*pbstrName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get___project)(
		/*[out,retval]*/ IUnknown** /*ppUnk*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_StartupObject)(
		/*[out,retval]*/ BSTR* /*pbstrStartupObject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_StartupObject)(
		/*[in]*/ BSTR /*bstrStartupObject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_OutputType)(
		/*[out,retval]*/ prjOutputType* /*pOutputType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_OutputType)(
		/*[in]*/ prjOutputType /*outputType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_RootNamespace)(
		/*[out,retval]*/ BSTR* /*pbstrRootNamespace*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_RootNamespace)(
		/*[in]*/ BSTR /*bstrRootNamespace*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_AssemblyName)(
		/*[out,retval]*/ BSTR* /*pbstrAssemblyName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_AssemblyName)(
		/*[in]*/ BSTR /*bstrAssemblyName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_AssemblyOriginatorKeyFile)(
		/*[out,retval]*/ BSTR* /*pbstrOriginatorKeyFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_AssemblyOriginatorKeyFile)(
		/*[in]*/ BSTR /*bstrOriginatorKeyFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_AssemblyKeyContainerName)(
		/*[out,retval]*/ BSTR* /*pbstrKeyContainerName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_AssemblyKeyContainerName)(
		/*[in]*/ BSTR /*bstrKeyContainerName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_AssemblyOriginatorKeyMode)(
		/*[out,retval]*/ prjOriginatorKeyMode* /*pOriginatorKeyMode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_AssemblyOriginatorKeyMode)(
		/*[in]*/ prjOriginatorKeyMode /*originatorKeyMode*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DelaySign)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbDelaySign*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DelaySign)(
		/*[in]*/ VARIANT_BOOL /*bDelaySign*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_WebServer)(
		/*[out,retval]*/ BSTR* /*pbstrWebServer*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_WebServerVersion)(
		/*[out,retval]*/ BSTR* /*pbstrWebServerVersion*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ServerExtensionsVersion)(
		/*[out,retval]*/ BSTR* /*pbstrServerExtensionsVersion*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_LinkRepair)(
		/*[out,retval]*/ VARIANT_BOOL* /*pLinkRepair*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_LinkRepair)(
		/*[in]*/ VARIANT_BOOL /*linkRepair*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_OfflineURL)(
		/*[out,retval]*/ BSTR* /*pbstrOfflineURL*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_FileSharePath)(
		/*[out,retval]*/ BSTR* /*pbstrFileSharePath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_FileSharePath)(
		/*[in]*/ BSTR /*bstrFileSharePath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ActiveFileSharePath)(
		/*[out,retval]*/ BSTR* /*pbstrFileSharePath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_WebAccessMethod)(
		/*[out,retval]*/ prjWebAccessMethod* /*pWebAccessMethod*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_WebAccessMethod)(
		/*[in]*/ prjWebAccessMethod /*authoringAccessMethod*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ActiveWebAccessMethod)(
		/*[out,retval]*/ prjWebAccessMethod* /*pActiveWebAccessMethod*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DefaultClientScript)(
		/*[out,retval]*/ prjScriptLanguage* /*pScriptLanguage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DefaultClientScript)(
		/*[in]*/ prjScriptLanguage /*scriptLanguage*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DefaultTargetSchema)(
		/*[out,retval]*/ prjTargetSchema* /*pTargetSchema*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DefaultTargetSchema)(
		/*[in]*/ prjTargetSchema /*htmlPlatform*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DefaultHTMLPageLayout)(
		/*[out,retval]*/ prjHTMLPageLayout* /*pHTMLPageLayout*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DefaultHTMLPageLayout)(
		/*[in]*/ prjHTMLPageLayout /*htmlPageLayout*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_FileName)(
		/*[out,retval]*/ BSTR* /*pbstrFileName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_FileName)(
		/*[in]*/ BSTR /*bstrFileName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_FullPath)(
		/*[out,retval]*/ BSTR* /*pbstrFullPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_LocalPath)(
		/*[out,retval]*/ BSTR* /*pbstrLocalPath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_URL)(
		/*[out,retval]*/ BSTR* /*pbstrURL*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ActiveConfigurationSettings)(
		/*[out,retval]*/ ProjectConfigurationProperties** /*ppVBProjConfigProps*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Extender)(
		/*[in]*/ BSTR /*ExtenderName*/,
		/*[out,retval]*/ IDispatch** /*Extender*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ExtenderNames)(
		/*[out,retval]*/ VARIANT* /*ExtenderNames*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ExtenderCATID)(
		/*[out,retval]*/ BSTR* /*pRetval*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ApplicationIcon)(
		/*[out,retval]*/ BSTR* /*pbstrApplicationIcon*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_ApplicationIcon)(
		/*[in]*/ BSTR /*bstrApplicationIcon*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_OptionStrict)(
		/*[out,retval]*/ prjOptionStrict* /*pOptionStrict*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_OptionStrict)(
		/*[in]*/ prjOptionStrict /*optionStrict*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ReferencePath)(
		/*[out,retval]*/ BSTR* /*pbstrReferencePath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_ReferencePath)(
		/*[in]*/ BSTR /*bstrReferencePath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_OutputFileName)(
		/*[out,retval]*/ BSTR* /*pbstrOutputFileName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_AbsoluteProjectDirectory)(
		/*[out,retval]*/ BSTR* /*pbstrDir*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_OptionExplicit)(
		/*[out,retval]*/ prjOptionExplicit* /*pOptionExplicit*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_OptionExplicit)(
		/*[in]*/ prjOptionExplicit /*optionExplicit*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_OptionCompare)(
		/*[out,retval]*/ prjCompare* /*pOptionCompare*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_OptionCompare)(
		/*[in]*/ prjCompare /*optionCompare*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ProjectType)(
		/*[out,retval]*/ prjProjectType* /*pProjectType*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DefaultNamespace)(
		/*[out,retval]*/ BSTR* /*pbstrRootNamespace*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_DefaultNamespace)(
		/*[in]*/ BSTR /*bstrRootNamespace*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class VBProjectProperties3MockImpl :
	public VBProjectProperties3,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(VBProjectProperties3MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(VBProjectProperties3MockImpl)

	typedef VBProjectProperties3 Interface;
	struct get_MyApplicationValidValues
	{
		/*[out,retval]*/ IDispatch** ppdispMyApplication;
		HRESULT retValue;
	};

	STDMETHOD(get_MyApplication)(
		/*[out,retval]*/ IDispatch** ppdispMyApplication)
	{
		VSL_DEFINE_MOCK_METHOD(get_MyApplication)

		VSL_SET_VALIDVALUE_INTERFACE(ppdispMyApplication);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_MyTypeValidValues
	{
		/*[out,retval]*/ BSTR* pbstrMyType;
		HRESULT retValue;
	};

	STDMETHOD(get_MyType)(
		/*[out,retval]*/ BSTR* pbstrMyType)
	{
		VSL_DEFINE_MOCK_METHOD(get_MyType)

		VSL_SET_VALIDVALUE_BSTR(pbstrMyType);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_MyTypeValidValues
	{
		/*[in]*/ BSTR MyType;
		HRESULT retValue;
	};

	STDMETHOD(put_MyType)(
		/*[in]*/ BSTR MyType)
	{
		VSL_DEFINE_MOCK_METHOD(put_MyType)

		VSL_CHECK_VALIDVALUE_BSTR(MyType);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_TitleValidValues
	{
		/*[out,retval]*/ BSTR* pbstrTitle;
		HRESULT retValue;
	};

	STDMETHOD(get_Title)(
		/*[out,retval]*/ BSTR* pbstrTitle)
	{
		VSL_DEFINE_MOCK_METHOD(get_Title)

		VSL_SET_VALIDVALUE_BSTR(pbstrTitle);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_TitleValidValues
	{
		/*[in]*/ BSTR Title;
		HRESULT retValue;
	};

	STDMETHOD(put_Title)(
		/*[in]*/ BSTR Title)
	{
		VSL_DEFINE_MOCK_METHOD(put_Title)

		VSL_CHECK_VALIDVALUE_BSTR(Title);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DescriptionValidValues
	{
		/*[out,retval]*/ BSTR* pbstrDescription;
		HRESULT retValue;
	};

	STDMETHOD(get_Description)(
		/*[out,retval]*/ BSTR* pbstrDescription)
	{
		VSL_DEFINE_MOCK_METHOD(get_Description)

		VSL_SET_VALIDVALUE_BSTR(pbstrDescription);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DescriptionValidValues
	{
		/*[in]*/ BSTR Description;
		HRESULT retValue;
	};

	STDMETHOD(put_Description)(
		/*[in]*/ BSTR Description)
	{
		VSL_DEFINE_MOCK_METHOD(put_Description)

		VSL_CHECK_VALIDVALUE_BSTR(Description);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CompanyValidValues
	{
		/*[out,retval]*/ BSTR* pbstrCompany;
		HRESULT retValue;
	};

	STDMETHOD(get_Company)(
		/*[out,retval]*/ BSTR* pbstrCompany)
	{
		VSL_DEFINE_MOCK_METHOD(get_Company)

		VSL_SET_VALIDVALUE_BSTR(pbstrCompany);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_CompanyValidValues
	{
		/*[in]*/ BSTR Company;
		HRESULT retValue;
	};

	STDMETHOD(put_Company)(
		/*[in]*/ BSTR Company)
	{
		VSL_DEFINE_MOCK_METHOD(put_Company)

		VSL_CHECK_VALIDVALUE_BSTR(Company);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ProductValidValues
	{
		/*[out,retval]*/ BSTR* pbstrProduct;
		HRESULT retValue;
	};

	STDMETHOD(get_Product)(
		/*[out,retval]*/ BSTR* pbstrProduct)
	{
		VSL_DEFINE_MOCK_METHOD(get_Product)

		VSL_SET_VALIDVALUE_BSTR(pbstrProduct);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_ProductValidValues
	{
		/*[in]*/ BSTR Product;
		HRESULT retValue;
	};

	STDMETHOD(put_Product)(
		/*[in]*/ BSTR Product)
	{
		VSL_DEFINE_MOCK_METHOD(put_Product)

		VSL_CHECK_VALIDVALUE_BSTR(Product);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_CopyrightValidValues
	{
		/*[out,retval]*/ BSTR* pbstrCopyright;
		HRESULT retValue;
	};

	STDMETHOD(get_Copyright)(
		/*[out,retval]*/ BSTR* pbstrCopyright)
	{
		VSL_DEFINE_MOCK_METHOD(get_Copyright)

		VSL_SET_VALIDVALUE_BSTR(pbstrCopyright);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_CopyrightValidValues
	{
		/*[in]*/ BSTR Copyright;
		HRESULT retValue;
	};

	STDMETHOD(put_Copyright)(
		/*[in]*/ BSTR Copyright)
	{
		VSL_DEFINE_MOCK_METHOD(put_Copyright)

		VSL_CHECK_VALIDVALUE_BSTR(Copyright);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_TrademarkValidValues
	{
		/*[out,retval]*/ BSTR* pbstrTrademark;
		HRESULT retValue;
	};

	STDMETHOD(get_Trademark)(
		/*[out,retval]*/ BSTR* pbstrTrademark)
	{
		VSL_DEFINE_MOCK_METHOD(get_Trademark)

		VSL_SET_VALIDVALUE_BSTR(pbstrTrademark);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_TrademarkValidValues
	{
		/*[in]*/ BSTR Trademark;
		HRESULT retValue;
	};

	STDMETHOD(put_Trademark)(
		/*[in]*/ BSTR Trademark)
	{
		VSL_DEFINE_MOCK_METHOD(put_Trademark)

		VSL_CHECK_VALIDVALUE_BSTR(Trademark);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_AssemblyTypeValidValues
	{
		/*[out,retval]*/ prjAssemblyType* pAssemblyType;
		HRESULT retValue;
	};

	STDMETHOD(get_AssemblyType)(
		/*[out,retval]*/ prjAssemblyType* pAssemblyType)
	{
		VSL_DEFINE_MOCK_METHOD(get_AssemblyType)

		VSL_SET_VALIDVALUE(pAssemblyType);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_AssemblyTypeValidValues
	{
		/*[in]*/ prjAssemblyType AssemblyType;
		HRESULT retValue;
	};

	STDMETHOD(put_AssemblyType)(
		/*[in]*/ prjAssemblyType AssemblyType)
	{
		VSL_DEFINE_MOCK_METHOD(put_AssemblyType)

		VSL_CHECK_VALIDVALUE(AssemblyType);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_TypeComplianceDiagnosticsValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbTypeComplianceDiagnostics;
		HRESULT retValue;
	};

	STDMETHOD(get_TypeComplianceDiagnostics)(
		/*[out,retval]*/ VARIANT_BOOL* pbTypeComplianceDiagnostics)
	{
		VSL_DEFINE_MOCK_METHOD(get_TypeComplianceDiagnostics)

		VSL_SET_VALIDVALUE(pbTypeComplianceDiagnostics);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_TypeComplianceDiagnosticsValidValues
	{
		/*[in]*/ VARIANT_BOOL TypeComplianceDiagnostics;
		HRESULT retValue;
	};

	STDMETHOD(put_TypeComplianceDiagnostics)(
		/*[in]*/ VARIANT_BOOL TypeComplianceDiagnostics)
	{
		VSL_DEFINE_MOCK_METHOD(put_TypeComplianceDiagnostics)

		VSL_CHECK_VALIDVALUE(TypeComplianceDiagnostics);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_Win32ResourceFileValidValues
	{
		/*[out,retval]*/ BSTR* pbstrW32ResourceFile;
		HRESULT retValue;
	};

	STDMETHOD(get_Win32ResourceFile)(
		/*[out,retval]*/ BSTR* pbstrW32ResourceFile)
	{
		VSL_DEFINE_MOCK_METHOD(get_Win32ResourceFile)

		VSL_SET_VALIDVALUE_BSTR(pbstrW32ResourceFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_Win32ResourceFileValidValues
	{
		/*[in]*/ BSTR Win32ResourceFile;
		HRESULT retValue;
	};

	STDMETHOD(put_Win32ResourceFile)(
		/*[in]*/ BSTR Win32ResourceFile)
	{
		VSL_DEFINE_MOCK_METHOD(put_Win32ResourceFile)

		VSL_CHECK_VALIDVALUE_BSTR(Win32ResourceFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_AssemblyKeyProviderNameValidValues
	{
		/*[out,retval]*/ BSTR* pbstrKeyProviderName;
		HRESULT retValue;
	};

	STDMETHOD(get_AssemblyKeyProviderName)(
		/*[out,retval]*/ BSTR* pbstrKeyProviderName)
	{
		VSL_DEFINE_MOCK_METHOD(get_AssemblyKeyProviderName)

		VSL_SET_VALIDVALUE_BSTR(pbstrKeyProviderName);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_AssemblyKeyProviderNameValidValues
	{
		/*[in]*/ BSTR KeyProviderName;
		HRESULT retValue;
	};

	STDMETHOD(put_AssemblyKeyProviderName)(
		/*[in]*/ BSTR KeyProviderName)
	{
		VSL_DEFINE_MOCK_METHOD(put_AssemblyKeyProviderName)

		VSL_CHECK_VALIDVALUE_BSTR(KeyProviderName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_AssemblyOriginatorKeyFileTypeValidValues
	{
		/*[out,retval]*/ DWORD* pdwOriginatorKeyFileType;
		HRESULT retValue;
	};

	STDMETHOD(get_AssemblyOriginatorKeyFileType)(
		/*[out,retval]*/ DWORD* pdwOriginatorKeyFileType)
	{
		VSL_DEFINE_MOCK_METHOD(get_AssemblyOriginatorKeyFileType)

		VSL_SET_VALIDVALUE(pdwOriginatorKeyFileType);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_AssemblyOriginatorKeyFileTypeValidValues
	{
		/*[in]*/ DWORD OriginatorKeyFileType;
		HRESULT retValue;
	};

	STDMETHOD(put_AssemblyOriginatorKeyFileType)(
		/*[in]*/ DWORD OriginatorKeyFileType)
	{
		VSL_DEFINE_MOCK_METHOD(put_AssemblyOriginatorKeyFileType)

		VSL_CHECK_VALIDVALUE(OriginatorKeyFileType);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_AssemblyVersionValidValues
	{
		/*[out,retval]*/ BSTR* pbstrAssemblyVersion;
		HRESULT retValue;
	};

	STDMETHOD(get_AssemblyVersion)(
		/*[out,retval]*/ BSTR* pbstrAssemblyVersion)
	{
		VSL_DEFINE_MOCK_METHOD(get_AssemblyVersion)

		VSL_SET_VALIDVALUE_BSTR(pbstrAssemblyVersion);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_AssemblyVersionValidValues
	{
		/*[in]*/ BSTR AssemblyVersion;
		HRESULT retValue;
	};

	STDMETHOD(put_AssemblyVersion)(
		/*[in]*/ BSTR AssemblyVersion)
	{
		VSL_DEFINE_MOCK_METHOD(put_AssemblyVersion)

		VSL_CHECK_VALIDVALUE_BSTR(AssemblyVersion);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_AssemblyFileVersionValidValues
	{
		/*[out,retval]*/ BSTR* pbstrAssemblyFileVersion;
		HRESULT retValue;
	};

	STDMETHOD(get_AssemblyFileVersion)(
		/*[out,retval]*/ BSTR* pbstrAssemblyFileVersion)
	{
		VSL_DEFINE_MOCK_METHOD(get_AssemblyFileVersion)

		VSL_SET_VALIDVALUE_BSTR(pbstrAssemblyFileVersion);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_AssemblyFileVersionValidValues
	{
		/*[in]*/ BSTR AssemblyFileVersion;
		HRESULT retValue;
	};

	STDMETHOD(put_AssemblyFileVersion)(
		/*[in]*/ BSTR AssemblyFileVersion)
	{
		VSL_DEFINE_MOCK_METHOD(put_AssemblyFileVersion)

		VSL_CHECK_VALIDVALUE_BSTR(AssemblyFileVersion);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_GenerateManifestsValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbGenerateManifests;
		HRESULT retValue;
	};

	STDMETHOD(get_GenerateManifests)(
		/*[out,retval]*/ VARIANT_BOOL* pbGenerateManifests)
	{
		VSL_DEFINE_MOCK_METHOD(get_GenerateManifests)

		VSL_SET_VALIDVALUE(pbGenerateManifests);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_GenerateManifestsValidValues
	{
		/*[in]*/ VARIANT_BOOL GenerateManifests;
		HRESULT retValue;
	};

	STDMETHOD(put_GenerateManifests)(
		/*[in]*/ VARIANT_BOOL GenerateManifests)
	{
		VSL_DEFINE_MOCK_METHOD(put_GenerateManifests)

		VSL_CHECK_VALIDVALUE(GenerateManifests);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_EnableSecurityDebuggingValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbEnableSecurityDebugging;
		HRESULT retValue;
	};

	STDMETHOD(get_EnableSecurityDebugging)(
		/*[out,retval]*/ VARIANT_BOOL* pbEnableSecurityDebugging)
	{
		VSL_DEFINE_MOCK_METHOD(get_EnableSecurityDebugging)

		VSL_SET_VALIDVALUE(pbEnableSecurityDebugging);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_EnableSecurityDebuggingValidValues
	{
		/*[in]*/ VARIANT_BOOL EnableSecurityDebugging;
		HRESULT retValue;
	};

	STDMETHOD(put_EnableSecurityDebugging)(
		/*[in]*/ VARIANT_BOOL EnableSecurityDebugging)
	{
		VSL_DEFINE_MOCK_METHOD(put_EnableSecurityDebugging)

		VSL_CHECK_VALIDVALUE(EnableSecurityDebugging);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DebugSecurityZoneURLValidValues
	{
		/*[out,retval]*/ BSTR* pbstrSecurityURL;
		HRESULT retValue;
	};

	STDMETHOD(get_DebugSecurityZoneURL)(
		/*[out,retval]*/ BSTR* pbstrSecurityURL)
	{
		VSL_DEFINE_MOCK_METHOD(get_DebugSecurityZoneURL)

		VSL_SET_VALIDVALUE_BSTR(pbstrSecurityURL);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DebugSecurityZoneURLValidValues
	{
		/*[in]*/ BSTR SecurityURL;
		HRESULT retValue;
	};

	STDMETHOD(put_DebugSecurityZoneURL)(
		/*[in]*/ BSTR SecurityURL)
	{
		VSL_DEFINE_MOCK_METHOD(put_DebugSecurityZoneURL)

		VSL_CHECK_VALIDVALUE_BSTR(SecurityURL);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_PublishValidValues
	{
		/*[out,retval]*/ IDispatch** ppdispPublish;
		HRESULT retValue;
	};

	STDMETHOD(get_Publish)(
		/*[out,retval]*/ IDispatch** ppdispPublish)
	{
		VSL_DEFINE_MOCK_METHOD(get_Publish)

		VSL_SET_VALIDVALUE_INTERFACE(ppdispPublish);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ComVisibleValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbComVisible;
		HRESULT retValue;
	};

	STDMETHOD(get_ComVisible)(
		/*[out,retval]*/ VARIANT_BOOL* pbComVisible)
	{
		VSL_DEFINE_MOCK_METHOD(get_ComVisible)

		VSL_SET_VALIDVALUE(pbComVisible);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_ComVisibleValidValues
	{
		/*[in]*/ VARIANT_BOOL ComVisible;
		HRESULT retValue;
	};

	STDMETHOD(put_ComVisible)(
		/*[in]*/ VARIANT_BOOL ComVisible)
	{
		VSL_DEFINE_MOCK_METHOD(put_ComVisible)

		VSL_CHECK_VALIDVALUE(ComVisible);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_AssemblyGuidValidValues
	{
		/*[out,retval]*/ BSTR* pbstrAssemblyGuid;
		HRESULT retValue;
	};

	STDMETHOD(get_AssemblyGuid)(
		/*[out,retval]*/ BSTR* pbstrAssemblyGuid)
	{
		VSL_DEFINE_MOCK_METHOD(get_AssemblyGuid)

		VSL_SET_VALIDVALUE_BSTR(pbstrAssemblyGuid);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_AssemblyGuidValidValues
	{
		/*[in]*/ BSTR AssemblyGuid;
		HRESULT retValue;
	};

	STDMETHOD(put_AssemblyGuid)(
		/*[in]*/ BSTR AssemblyGuid)
	{
		VSL_DEFINE_MOCK_METHOD(put_AssemblyGuid)

		VSL_CHECK_VALIDVALUE_BSTR(AssemblyGuid);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_NeutralResourcesLanguageValidValues
	{
		/*[out,retval]*/ BSTR* pbstrNeutralResourcesLanguage;
		HRESULT retValue;
	};

	STDMETHOD(get_NeutralResourcesLanguage)(
		/*[out,retval]*/ BSTR* pbstrNeutralResourcesLanguage)
	{
		VSL_DEFINE_MOCK_METHOD(get_NeutralResourcesLanguage)

		VSL_SET_VALIDVALUE_BSTR(pbstrNeutralResourcesLanguage);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_NeutralResourcesLanguageValidValues
	{
		/*[in]*/ BSTR NeutralResourcesLanguage;
		HRESULT retValue;
	};

	STDMETHOD(put_NeutralResourcesLanguage)(
		/*[in]*/ BSTR NeutralResourcesLanguage)
	{
		VSL_DEFINE_MOCK_METHOD(put_NeutralResourcesLanguage)

		VSL_CHECK_VALIDVALUE_BSTR(NeutralResourcesLanguage);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_SignAssemblyValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbSignAssembly;
		HRESULT retValue;
	};

	STDMETHOD(get_SignAssembly)(
		/*[out,retval]*/ VARIANT_BOOL* pbSignAssembly)
	{
		VSL_DEFINE_MOCK_METHOD(get_SignAssembly)

		VSL_SET_VALIDVALUE(pbSignAssembly);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_SignAssemblyValidValues
	{
		/*[in]*/ VARIANT_BOOL SignAssembly;
		HRESULT retValue;
	};

	STDMETHOD(put_SignAssembly)(
		/*[in]*/ VARIANT_BOOL SignAssembly)
	{
		VSL_DEFINE_MOCK_METHOD(put_SignAssembly)

		VSL_CHECK_VALIDVALUE(SignAssembly);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_SignManifestsValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbSignManifests;
		HRESULT retValue;
	};

	STDMETHOD(get_SignManifests)(
		/*[out,retval]*/ VARIANT_BOOL* pbSignManifests)
	{
		VSL_DEFINE_MOCK_METHOD(get_SignManifests)

		VSL_SET_VALIDVALUE(pbSignManifests);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_SignManifestsValidValues
	{
		/*[in]*/ VARIANT_BOOL bSignManifests;
		HRESULT retValue;
	};

	STDMETHOD(put_SignManifests)(
		/*[in]*/ VARIANT_BOOL bSignManifests)
	{
		VSL_DEFINE_MOCK_METHOD(put_SignManifests)

		VSL_CHECK_VALIDVALUE(bSignManifests);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_TargetZoneValidValues
	{
		/*[out,retval]*/ BSTR* pbstrTargetZone;
		HRESULT retValue;
	};

	STDMETHOD(get_TargetZone)(
		/*[out,retval]*/ BSTR* pbstrTargetZone)
	{
		VSL_DEFINE_MOCK_METHOD(get_TargetZone)

		VSL_SET_VALIDVALUE_BSTR(pbstrTargetZone);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_TargetZoneValidValues
	{
		/*[in]*/ BSTR TargetZone;
		HRESULT retValue;
	};

	STDMETHOD(put_TargetZone)(
		/*[in]*/ BSTR TargetZone)
	{
		VSL_DEFINE_MOCK_METHOD(put_TargetZone)

		VSL_CHECK_VALIDVALUE_BSTR(TargetZone);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExcludedPermissionsValidValues
	{
		/*[out,retval]*/ BSTR* pbstrExcludedPermissions;
		HRESULT retValue;
	};

	STDMETHOD(get_ExcludedPermissions)(
		/*[out,retval]*/ BSTR* pbstrExcludedPermissions)
	{
		VSL_DEFINE_MOCK_METHOD(get_ExcludedPermissions)

		VSL_SET_VALIDVALUE_BSTR(pbstrExcludedPermissions);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_ExcludedPermissionsValidValues
	{
		/*[in]*/ BSTR ExcludedPermissions;
		HRESULT retValue;
	};

	STDMETHOD(put_ExcludedPermissions)(
		/*[in]*/ BSTR ExcludedPermissions)
	{
		VSL_DEFINE_MOCK_METHOD(put_ExcludedPermissions)

		VSL_CHECK_VALIDVALUE_BSTR(ExcludedPermissions);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ManifestCertificateThumbprintValidValues
	{
		/*[out,retval]*/ BSTR* pbstrManifestCertificateThumbprint;
		HRESULT retValue;
	};

	STDMETHOD(get_ManifestCertificateThumbprint)(
		/*[out,retval]*/ BSTR* pbstrManifestCertificateThumbprint)
	{
		VSL_DEFINE_MOCK_METHOD(get_ManifestCertificateThumbprint)

		VSL_SET_VALIDVALUE_BSTR(pbstrManifestCertificateThumbprint);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_ManifestCertificateThumbprintValidValues
	{
		/*[in]*/ BSTR ManifestCertificateThumbprint;
		HRESULT retValue;
	};

	STDMETHOD(put_ManifestCertificateThumbprint)(
		/*[in]*/ BSTR ManifestCertificateThumbprint)
	{
		VSL_DEFINE_MOCK_METHOD(put_ManifestCertificateThumbprint)

		VSL_CHECK_VALIDVALUE_BSTR(ManifestCertificateThumbprint);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ManifestKeyFileValidValues
	{
		/*[out,retval]*/ BSTR* pbstrManifestKeyFile;
		HRESULT retValue;
	};

	STDMETHOD(get_ManifestKeyFile)(
		/*[out,retval]*/ BSTR* pbstrManifestKeyFile)
	{
		VSL_DEFINE_MOCK_METHOD(get_ManifestKeyFile)

		VSL_SET_VALIDVALUE_BSTR(pbstrManifestKeyFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_ManifestKeyFileValidValues
	{
		/*[in]*/ BSTR ManifestKeyFile;
		HRESULT retValue;
	};

	STDMETHOD(put_ManifestKeyFile)(
		/*[in]*/ BSTR ManifestKeyFile)
	{
		VSL_DEFINE_MOCK_METHOD(put_ManifestKeyFile)

		VSL_CHECK_VALIDVALUE_BSTR(ManifestKeyFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ManifestTimestampUrlValidValues
	{
		/*[out,retval]*/ BSTR* pbstrManifestTimestampUrl;
		HRESULT retValue;
	};

	STDMETHOD(get_ManifestTimestampUrl)(
		/*[out,retval]*/ BSTR* pbstrManifestTimestampUrl)
	{
		VSL_DEFINE_MOCK_METHOD(get_ManifestTimestampUrl)

		VSL_SET_VALIDVALUE_BSTR(pbstrManifestTimestampUrl);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_ManifestTimestampUrlValidValues
	{
		/*[in]*/ BSTR ManifestTimestampUrl;
		HRESULT retValue;
	};

	STDMETHOD(put_ManifestTimestampUrl)(
		/*[in]*/ BSTR ManifestTimestampUrl)
	{
		VSL_DEFINE_MOCK_METHOD(put_ManifestTimestampUrl)

		VSL_CHECK_VALIDVALUE_BSTR(ManifestTimestampUrl);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_PreBuildEventValidValues
	{
		/*[out,retval]*/ BSTR* pbstrOut;
		HRESULT retValue;
	};

	STDMETHOD(get_PreBuildEvent)(
		/*[out,retval]*/ BSTR* pbstrOut)
	{
		VSL_DEFINE_MOCK_METHOD(get_PreBuildEvent)

		VSL_SET_VALIDVALUE_BSTR(pbstrOut);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_PreBuildEventValidValues
	{
		/*[in]*/ BSTR bstrIn;
		HRESULT retValue;
	};

	STDMETHOD(put_PreBuildEvent)(
		/*[in]*/ BSTR bstrIn)
	{
		VSL_DEFINE_MOCK_METHOD(put_PreBuildEvent)

		VSL_CHECK_VALIDVALUE_BSTR(bstrIn);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_PostBuildEventValidValues
	{
		/*[out,retval]*/ BSTR* pbstrOut;
		HRESULT retValue;
	};

	STDMETHOD(get_PostBuildEvent)(
		/*[out,retval]*/ BSTR* pbstrOut)
	{
		VSL_DEFINE_MOCK_METHOD(get_PostBuildEvent)

		VSL_SET_VALIDVALUE_BSTR(pbstrOut);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_PostBuildEventValidValues
	{
		/*[in]*/ BSTR bstrIn;
		HRESULT retValue;
	};

	STDMETHOD(put_PostBuildEvent)(
		/*[in]*/ BSTR bstrIn)
	{
		VSL_DEFINE_MOCK_METHOD(put_PostBuildEvent)

		VSL_CHECK_VALIDVALUE_BSTR(bstrIn);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_RunPostBuildEventValidValues
	{
		/*[out,retval]*/ prjRunPostBuildEvent* pOut;
		HRESULT retValue;
	};

	STDMETHOD(get_RunPostBuildEvent)(
		/*[out,retval]*/ prjRunPostBuildEvent* pOut)
	{
		VSL_DEFINE_MOCK_METHOD(get_RunPostBuildEvent)

		VSL_SET_VALIDVALUE(pOut);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_RunPostBuildEventValidValues
	{
		/*[in]*/ prjRunPostBuildEvent run;
		HRESULT retValue;
	};

	STDMETHOD(put_RunPostBuildEvent)(
		/*[in]*/ prjRunPostBuildEvent run)
	{
		VSL_DEFINE_MOCK_METHOD(put_RunPostBuildEvent)

		VSL_CHECK_VALIDVALUE(run);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_AspnetVersionValidValues
	{
		/*[out,retval]*/ BSTR* pOut;
		HRESULT retValue;
	};

	STDMETHOD(get_AspnetVersion)(
		/*[out,retval]*/ BSTR* pOut)
	{
		VSL_DEFINE_MOCK_METHOD(get_AspnetVersion)

		VSL_SET_VALIDVALUE_BSTR(pOut);

		VSL_RETURN_VALIDVALUES();
	}
	struct get___idValidValues
	{
		/*[out,retval]*/ BSTR* pbstrName;
		HRESULT retValue;
	};

	STDMETHOD(get___id)(
		/*[out,retval]*/ BSTR* pbstrName)
	{
		VSL_DEFINE_MOCK_METHOD(get___id)

		VSL_SET_VALIDVALUE_BSTR(pbstrName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get___projectValidValues
	{
		/*[out,retval]*/ IUnknown** ppUnk;
		HRESULT retValue;
	};

	STDMETHOD(get___project)(
		/*[out,retval]*/ IUnknown** ppUnk)
	{
		VSL_DEFINE_MOCK_METHOD(get___project)

		VSL_SET_VALIDVALUE_INTERFACE(ppUnk);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_StartupObjectValidValues
	{
		/*[out,retval]*/ BSTR* pbstrStartupObject;
		HRESULT retValue;
	};

	STDMETHOD(get_StartupObject)(
		/*[out,retval]*/ BSTR* pbstrStartupObject)
	{
		VSL_DEFINE_MOCK_METHOD(get_StartupObject)

		VSL_SET_VALIDVALUE_BSTR(pbstrStartupObject);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_StartupObjectValidValues
	{
		/*[in]*/ BSTR bstrStartupObject;
		HRESULT retValue;
	};

	STDMETHOD(put_StartupObject)(
		/*[in]*/ BSTR bstrStartupObject)
	{
		VSL_DEFINE_MOCK_METHOD(put_StartupObject)

		VSL_CHECK_VALIDVALUE_BSTR(bstrStartupObject);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_OutputTypeValidValues
	{
		/*[out,retval]*/ prjOutputType* pOutputType;
		HRESULT retValue;
	};

	STDMETHOD(get_OutputType)(
		/*[out,retval]*/ prjOutputType* pOutputType)
	{
		VSL_DEFINE_MOCK_METHOD(get_OutputType)

		VSL_SET_VALIDVALUE(pOutputType);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_OutputTypeValidValues
	{
		/*[in]*/ prjOutputType outputType;
		HRESULT retValue;
	};

	STDMETHOD(put_OutputType)(
		/*[in]*/ prjOutputType outputType)
	{
		VSL_DEFINE_MOCK_METHOD(put_OutputType)

		VSL_CHECK_VALIDVALUE(outputType);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_RootNamespaceValidValues
	{
		/*[out,retval]*/ BSTR* pbstrRootNamespace;
		HRESULT retValue;
	};

	STDMETHOD(get_RootNamespace)(
		/*[out,retval]*/ BSTR* pbstrRootNamespace)
	{
		VSL_DEFINE_MOCK_METHOD(get_RootNamespace)

		VSL_SET_VALIDVALUE_BSTR(pbstrRootNamespace);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_RootNamespaceValidValues
	{
		/*[in]*/ BSTR bstrRootNamespace;
		HRESULT retValue;
	};

	STDMETHOD(put_RootNamespace)(
		/*[in]*/ BSTR bstrRootNamespace)
	{
		VSL_DEFINE_MOCK_METHOD(put_RootNamespace)

		VSL_CHECK_VALIDVALUE_BSTR(bstrRootNamespace);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_AssemblyNameValidValues
	{
		/*[out,retval]*/ BSTR* pbstrAssemblyName;
		HRESULT retValue;
	};

	STDMETHOD(get_AssemblyName)(
		/*[out,retval]*/ BSTR* pbstrAssemblyName)
	{
		VSL_DEFINE_MOCK_METHOD(get_AssemblyName)

		VSL_SET_VALIDVALUE_BSTR(pbstrAssemblyName);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_AssemblyNameValidValues
	{
		/*[in]*/ BSTR bstrAssemblyName;
		HRESULT retValue;
	};

	STDMETHOD(put_AssemblyName)(
		/*[in]*/ BSTR bstrAssemblyName)
	{
		VSL_DEFINE_MOCK_METHOD(put_AssemblyName)

		VSL_CHECK_VALIDVALUE_BSTR(bstrAssemblyName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_AssemblyOriginatorKeyFileValidValues
	{
		/*[out,retval]*/ BSTR* pbstrOriginatorKeyFile;
		HRESULT retValue;
	};

	STDMETHOD(get_AssemblyOriginatorKeyFile)(
		/*[out,retval]*/ BSTR* pbstrOriginatorKeyFile)
	{
		VSL_DEFINE_MOCK_METHOD(get_AssemblyOriginatorKeyFile)

		VSL_SET_VALIDVALUE_BSTR(pbstrOriginatorKeyFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_AssemblyOriginatorKeyFileValidValues
	{
		/*[in]*/ BSTR bstrOriginatorKeyFile;
		HRESULT retValue;
	};

	STDMETHOD(put_AssemblyOriginatorKeyFile)(
		/*[in]*/ BSTR bstrOriginatorKeyFile)
	{
		VSL_DEFINE_MOCK_METHOD(put_AssemblyOriginatorKeyFile)

		VSL_CHECK_VALIDVALUE_BSTR(bstrOriginatorKeyFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_AssemblyKeyContainerNameValidValues
	{
		/*[out,retval]*/ BSTR* pbstrKeyContainerName;
		HRESULT retValue;
	};

	STDMETHOD(get_AssemblyKeyContainerName)(
		/*[out,retval]*/ BSTR* pbstrKeyContainerName)
	{
		VSL_DEFINE_MOCK_METHOD(get_AssemblyKeyContainerName)

		VSL_SET_VALIDVALUE_BSTR(pbstrKeyContainerName);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_AssemblyKeyContainerNameValidValues
	{
		/*[in]*/ BSTR bstrKeyContainerName;
		HRESULT retValue;
	};

	STDMETHOD(put_AssemblyKeyContainerName)(
		/*[in]*/ BSTR bstrKeyContainerName)
	{
		VSL_DEFINE_MOCK_METHOD(put_AssemblyKeyContainerName)

		VSL_CHECK_VALIDVALUE_BSTR(bstrKeyContainerName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_AssemblyOriginatorKeyModeValidValues
	{
		/*[out,retval]*/ prjOriginatorKeyMode* pOriginatorKeyMode;
		HRESULT retValue;
	};

	STDMETHOD(get_AssemblyOriginatorKeyMode)(
		/*[out,retval]*/ prjOriginatorKeyMode* pOriginatorKeyMode)
	{
		VSL_DEFINE_MOCK_METHOD(get_AssemblyOriginatorKeyMode)

		VSL_SET_VALIDVALUE(pOriginatorKeyMode);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_AssemblyOriginatorKeyModeValidValues
	{
		/*[in]*/ prjOriginatorKeyMode originatorKeyMode;
		HRESULT retValue;
	};

	STDMETHOD(put_AssemblyOriginatorKeyMode)(
		/*[in]*/ prjOriginatorKeyMode originatorKeyMode)
	{
		VSL_DEFINE_MOCK_METHOD(put_AssemblyOriginatorKeyMode)

		VSL_CHECK_VALIDVALUE(originatorKeyMode);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DelaySignValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbDelaySign;
		HRESULT retValue;
	};

	STDMETHOD(get_DelaySign)(
		/*[out,retval]*/ VARIANT_BOOL* pbDelaySign)
	{
		VSL_DEFINE_MOCK_METHOD(get_DelaySign)

		VSL_SET_VALIDVALUE(pbDelaySign);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DelaySignValidValues
	{
		/*[in]*/ VARIANT_BOOL bDelaySign;
		HRESULT retValue;
	};

	STDMETHOD(put_DelaySign)(
		/*[in]*/ VARIANT_BOOL bDelaySign)
	{
		VSL_DEFINE_MOCK_METHOD(put_DelaySign)

		VSL_CHECK_VALIDVALUE(bDelaySign);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_WebServerValidValues
	{
		/*[out,retval]*/ BSTR* pbstrWebServer;
		HRESULT retValue;
	};

	STDMETHOD(get_WebServer)(
		/*[out,retval]*/ BSTR* pbstrWebServer)
	{
		VSL_DEFINE_MOCK_METHOD(get_WebServer)

		VSL_SET_VALIDVALUE_BSTR(pbstrWebServer);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_WebServerVersionValidValues
	{
		/*[out,retval]*/ BSTR* pbstrWebServerVersion;
		HRESULT retValue;
	};

	STDMETHOD(get_WebServerVersion)(
		/*[out,retval]*/ BSTR* pbstrWebServerVersion)
	{
		VSL_DEFINE_MOCK_METHOD(get_WebServerVersion)

		VSL_SET_VALIDVALUE_BSTR(pbstrWebServerVersion);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ServerExtensionsVersionValidValues
	{
		/*[out,retval]*/ BSTR* pbstrServerExtensionsVersion;
		HRESULT retValue;
	};

	STDMETHOD(get_ServerExtensionsVersion)(
		/*[out,retval]*/ BSTR* pbstrServerExtensionsVersion)
	{
		VSL_DEFINE_MOCK_METHOD(get_ServerExtensionsVersion)

		VSL_SET_VALIDVALUE_BSTR(pbstrServerExtensionsVersion);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_LinkRepairValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pLinkRepair;
		HRESULT retValue;
	};

	STDMETHOD(get_LinkRepair)(
		/*[out,retval]*/ VARIANT_BOOL* pLinkRepair)
	{
		VSL_DEFINE_MOCK_METHOD(get_LinkRepair)

		VSL_SET_VALIDVALUE(pLinkRepair);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_LinkRepairValidValues
	{
		/*[in]*/ VARIANT_BOOL linkRepair;
		HRESULT retValue;
	};

	STDMETHOD(put_LinkRepair)(
		/*[in]*/ VARIANT_BOOL linkRepair)
	{
		VSL_DEFINE_MOCK_METHOD(put_LinkRepair)

		VSL_CHECK_VALIDVALUE(linkRepair);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_OfflineURLValidValues
	{
		/*[out,retval]*/ BSTR* pbstrOfflineURL;
		HRESULT retValue;
	};

	STDMETHOD(get_OfflineURL)(
		/*[out,retval]*/ BSTR* pbstrOfflineURL)
	{
		VSL_DEFINE_MOCK_METHOD(get_OfflineURL)

		VSL_SET_VALIDVALUE_BSTR(pbstrOfflineURL);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_FileSharePathValidValues
	{
		/*[out,retval]*/ BSTR* pbstrFileSharePath;
		HRESULT retValue;
	};

	STDMETHOD(get_FileSharePath)(
		/*[out,retval]*/ BSTR* pbstrFileSharePath)
	{
		VSL_DEFINE_MOCK_METHOD(get_FileSharePath)

		VSL_SET_VALIDVALUE_BSTR(pbstrFileSharePath);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_FileSharePathValidValues
	{
		/*[in]*/ BSTR bstrFileSharePath;
		HRESULT retValue;
	};

	STDMETHOD(put_FileSharePath)(
		/*[in]*/ BSTR bstrFileSharePath)
	{
		VSL_DEFINE_MOCK_METHOD(put_FileSharePath)

		VSL_CHECK_VALIDVALUE_BSTR(bstrFileSharePath);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ActiveFileSharePathValidValues
	{
		/*[out,retval]*/ BSTR* pbstrFileSharePath;
		HRESULT retValue;
	};

	STDMETHOD(get_ActiveFileSharePath)(
		/*[out,retval]*/ BSTR* pbstrFileSharePath)
	{
		VSL_DEFINE_MOCK_METHOD(get_ActiveFileSharePath)

		VSL_SET_VALIDVALUE_BSTR(pbstrFileSharePath);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_WebAccessMethodValidValues
	{
		/*[out,retval]*/ prjWebAccessMethod* pWebAccessMethod;
		HRESULT retValue;
	};

	STDMETHOD(get_WebAccessMethod)(
		/*[out,retval]*/ prjWebAccessMethod* pWebAccessMethod)
	{
		VSL_DEFINE_MOCK_METHOD(get_WebAccessMethod)

		VSL_SET_VALIDVALUE(pWebAccessMethod);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_WebAccessMethodValidValues
	{
		/*[in]*/ prjWebAccessMethod authoringAccessMethod;
		HRESULT retValue;
	};

	STDMETHOD(put_WebAccessMethod)(
		/*[in]*/ prjWebAccessMethod authoringAccessMethod)
	{
		VSL_DEFINE_MOCK_METHOD(put_WebAccessMethod)

		VSL_CHECK_VALIDVALUE(authoringAccessMethod);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ActiveWebAccessMethodValidValues
	{
		/*[out,retval]*/ prjWebAccessMethod* pActiveWebAccessMethod;
		HRESULT retValue;
	};

	STDMETHOD(get_ActiveWebAccessMethod)(
		/*[out,retval]*/ prjWebAccessMethod* pActiveWebAccessMethod)
	{
		VSL_DEFINE_MOCK_METHOD(get_ActiveWebAccessMethod)

		VSL_SET_VALIDVALUE(pActiveWebAccessMethod);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DefaultClientScriptValidValues
	{
		/*[out,retval]*/ prjScriptLanguage* pScriptLanguage;
		HRESULT retValue;
	};

	STDMETHOD(get_DefaultClientScript)(
		/*[out,retval]*/ prjScriptLanguage* pScriptLanguage)
	{
		VSL_DEFINE_MOCK_METHOD(get_DefaultClientScript)

		VSL_SET_VALIDVALUE(pScriptLanguage);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DefaultClientScriptValidValues
	{
		/*[in]*/ prjScriptLanguage scriptLanguage;
		HRESULT retValue;
	};

	STDMETHOD(put_DefaultClientScript)(
		/*[in]*/ prjScriptLanguage scriptLanguage)
	{
		VSL_DEFINE_MOCK_METHOD(put_DefaultClientScript)

		VSL_CHECK_VALIDVALUE(scriptLanguage);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DefaultTargetSchemaValidValues
	{
		/*[out,retval]*/ prjTargetSchema* pTargetSchema;
		HRESULT retValue;
	};

	STDMETHOD(get_DefaultTargetSchema)(
		/*[out,retval]*/ prjTargetSchema* pTargetSchema)
	{
		VSL_DEFINE_MOCK_METHOD(get_DefaultTargetSchema)

		VSL_SET_VALIDVALUE(pTargetSchema);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DefaultTargetSchemaValidValues
	{
		/*[in]*/ prjTargetSchema htmlPlatform;
		HRESULT retValue;
	};

	STDMETHOD(put_DefaultTargetSchema)(
		/*[in]*/ prjTargetSchema htmlPlatform)
	{
		VSL_DEFINE_MOCK_METHOD(put_DefaultTargetSchema)

		VSL_CHECK_VALIDVALUE(htmlPlatform);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DefaultHTMLPageLayoutValidValues
	{
		/*[out,retval]*/ prjHTMLPageLayout* pHTMLPageLayout;
		HRESULT retValue;
	};

	STDMETHOD(get_DefaultHTMLPageLayout)(
		/*[out,retval]*/ prjHTMLPageLayout* pHTMLPageLayout)
	{
		VSL_DEFINE_MOCK_METHOD(get_DefaultHTMLPageLayout)

		VSL_SET_VALIDVALUE(pHTMLPageLayout);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DefaultHTMLPageLayoutValidValues
	{
		/*[in]*/ prjHTMLPageLayout htmlPageLayout;
		HRESULT retValue;
	};

	STDMETHOD(put_DefaultHTMLPageLayout)(
		/*[in]*/ prjHTMLPageLayout htmlPageLayout)
	{
		VSL_DEFINE_MOCK_METHOD(put_DefaultHTMLPageLayout)

		VSL_CHECK_VALIDVALUE(htmlPageLayout);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_FileNameValidValues
	{
		/*[out,retval]*/ BSTR* pbstrFileName;
		HRESULT retValue;
	};

	STDMETHOD(get_FileName)(
		/*[out,retval]*/ BSTR* pbstrFileName)
	{
		VSL_DEFINE_MOCK_METHOD(get_FileName)

		VSL_SET_VALIDVALUE_BSTR(pbstrFileName);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_FileNameValidValues
	{
		/*[in]*/ BSTR bstrFileName;
		HRESULT retValue;
	};

	STDMETHOD(put_FileName)(
		/*[in]*/ BSTR bstrFileName)
	{
		VSL_DEFINE_MOCK_METHOD(put_FileName)

		VSL_CHECK_VALIDVALUE_BSTR(bstrFileName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_FullPathValidValues
	{
		/*[out,retval]*/ BSTR* pbstrFullPath;
		HRESULT retValue;
	};

	STDMETHOD(get_FullPath)(
		/*[out,retval]*/ BSTR* pbstrFullPath)
	{
		VSL_DEFINE_MOCK_METHOD(get_FullPath)

		VSL_SET_VALIDVALUE_BSTR(pbstrFullPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_LocalPathValidValues
	{
		/*[out,retval]*/ BSTR* pbstrLocalPath;
		HRESULT retValue;
	};

	STDMETHOD(get_LocalPath)(
		/*[out,retval]*/ BSTR* pbstrLocalPath)
	{
		VSL_DEFINE_MOCK_METHOD(get_LocalPath)

		VSL_SET_VALIDVALUE_BSTR(pbstrLocalPath);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_URLValidValues
	{
		/*[out,retval]*/ BSTR* pbstrURL;
		HRESULT retValue;
	};

	STDMETHOD(get_URL)(
		/*[out,retval]*/ BSTR* pbstrURL)
	{
		VSL_DEFINE_MOCK_METHOD(get_URL)

		VSL_SET_VALIDVALUE_BSTR(pbstrURL);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ActiveConfigurationSettingsValidValues
	{
		/*[out,retval]*/ ProjectConfigurationProperties** ppVBProjConfigProps;
		HRESULT retValue;
	};

	STDMETHOD(get_ActiveConfigurationSettings)(
		/*[out,retval]*/ ProjectConfigurationProperties** ppVBProjConfigProps)
	{
		VSL_DEFINE_MOCK_METHOD(get_ActiveConfigurationSettings)

		VSL_SET_VALIDVALUE_INTERFACE(ppVBProjConfigProps);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderValidValues
	{
		/*[in]*/ BSTR ExtenderName;
		/*[out,retval]*/ IDispatch** Extender;
		HRESULT retValue;
	};

	STDMETHOD(get_Extender)(
		/*[in]*/ BSTR ExtenderName,
		/*[out,retval]*/ IDispatch** Extender)
	{
		VSL_DEFINE_MOCK_METHOD(get_Extender)

		VSL_CHECK_VALIDVALUE_BSTR(ExtenderName);

		VSL_SET_VALIDVALUE_INTERFACE(Extender);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderNamesValidValues
	{
		/*[out,retval]*/ VARIANT* ExtenderNames;
		HRESULT retValue;
	};

	STDMETHOD(get_ExtenderNames)(
		/*[out,retval]*/ VARIANT* ExtenderNames)
	{
		VSL_DEFINE_MOCK_METHOD(get_ExtenderNames)

		VSL_SET_VALIDVALUE_VARIANT(ExtenderNames);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ExtenderCATIDValidValues
	{
		/*[out,retval]*/ BSTR* pRetval;
		HRESULT retValue;
	};

	STDMETHOD(get_ExtenderCATID)(
		/*[out,retval]*/ BSTR* pRetval)
	{
		VSL_DEFINE_MOCK_METHOD(get_ExtenderCATID)

		VSL_SET_VALIDVALUE_BSTR(pRetval);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ApplicationIconValidValues
	{
		/*[out,retval]*/ BSTR* pbstrApplicationIcon;
		HRESULT retValue;
	};

	STDMETHOD(get_ApplicationIcon)(
		/*[out,retval]*/ BSTR* pbstrApplicationIcon)
	{
		VSL_DEFINE_MOCK_METHOD(get_ApplicationIcon)

		VSL_SET_VALIDVALUE_BSTR(pbstrApplicationIcon);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_ApplicationIconValidValues
	{
		/*[in]*/ BSTR bstrApplicationIcon;
		HRESULT retValue;
	};

	STDMETHOD(put_ApplicationIcon)(
		/*[in]*/ BSTR bstrApplicationIcon)
	{
		VSL_DEFINE_MOCK_METHOD(put_ApplicationIcon)

		VSL_CHECK_VALIDVALUE_BSTR(bstrApplicationIcon);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_OptionStrictValidValues
	{
		/*[out,retval]*/ prjOptionStrict* pOptionStrict;
		HRESULT retValue;
	};

	STDMETHOD(get_OptionStrict)(
		/*[out,retval]*/ prjOptionStrict* pOptionStrict)
	{
		VSL_DEFINE_MOCK_METHOD(get_OptionStrict)

		VSL_SET_VALIDVALUE(pOptionStrict);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_OptionStrictValidValues
	{
		/*[in]*/ prjOptionStrict optionStrict;
		HRESULT retValue;
	};

	STDMETHOD(put_OptionStrict)(
		/*[in]*/ prjOptionStrict optionStrict)
	{
		VSL_DEFINE_MOCK_METHOD(put_OptionStrict)

		VSL_CHECK_VALIDVALUE(optionStrict);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ReferencePathValidValues
	{
		/*[out,retval]*/ BSTR* pbstrReferencePath;
		HRESULT retValue;
	};

	STDMETHOD(get_ReferencePath)(
		/*[out,retval]*/ BSTR* pbstrReferencePath)
	{
		VSL_DEFINE_MOCK_METHOD(get_ReferencePath)

		VSL_SET_VALIDVALUE_BSTR(pbstrReferencePath);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_ReferencePathValidValues
	{
		/*[in]*/ BSTR bstrReferencePath;
		HRESULT retValue;
	};

	STDMETHOD(put_ReferencePath)(
		/*[in]*/ BSTR bstrReferencePath)
	{
		VSL_DEFINE_MOCK_METHOD(put_ReferencePath)

		VSL_CHECK_VALIDVALUE_BSTR(bstrReferencePath);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_OutputFileNameValidValues
	{
		/*[out,retval]*/ BSTR* pbstrOutputFileName;
		HRESULT retValue;
	};

	STDMETHOD(get_OutputFileName)(
		/*[out,retval]*/ BSTR* pbstrOutputFileName)
	{
		VSL_DEFINE_MOCK_METHOD(get_OutputFileName)

		VSL_SET_VALIDVALUE_BSTR(pbstrOutputFileName);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_AbsoluteProjectDirectoryValidValues
	{
		/*[out,retval]*/ BSTR* pbstrDir;
		HRESULT retValue;
	};

	STDMETHOD(get_AbsoluteProjectDirectory)(
		/*[out,retval]*/ BSTR* pbstrDir)
	{
		VSL_DEFINE_MOCK_METHOD(get_AbsoluteProjectDirectory)

		VSL_SET_VALIDVALUE_BSTR(pbstrDir);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_OptionExplicitValidValues
	{
		/*[out,retval]*/ prjOptionExplicit* pOptionExplicit;
		HRESULT retValue;
	};

	STDMETHOD(get_OptionExplicit)(
		/*[out,retval]*/ prjOptionExplicit* pOptionExplicit)
	{
		VSL_DEFINE_MOCK_METHOD(get_OptionExplicit)

		VSL_SET_VALIDVALUE(pOptionExplicit);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_OptionExplicitValidValues
	{
		/*[in]*/ prjOptionExplicit optionExplicit;
		HRESULT retValue;
	};

	STDMETHOD(put_OptionExplicit)(
		/*[in]*/ prjOptionExplicit optionExplicit)
	{
		VSL_DEFINE_MOCK_METHOD(put_OptionExplicit)

		VSL_CHECK_VALIDVALUE(optionExplicit);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_OptionCompareValidValues
	{
		/*[out,retval]*/ prjCompare* pOptionCompare;
		HRESULT retValue;
	};

	STDMETHOD(get_OptionCompare)(
		/*[out,retval]*/ prjCompare* pOptionCompare)
	{
		VSL_DEFINE_MOCK_METHOD(get_OptionCompare)

		VSL_SET_VALIDVALUE(pOptionCompare);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_OptionCompareValidValues
	{
		/*[in]*/ prjCompare optionCompare;
		HRESULT retValue;
	};

	STDMETHOD(put_OptionCompare)(
		/*[in]*/ prjCompare optionCompare)
	{
		VSL_DEFINE_MOCK_METHOD(put_OptionCompare)

		VSL_CHECK_VALIDVALUE(optionCompare);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ProjectTypeValidValues
	{
		/*[out,retval]*/ prjProjectType* pProjectType;
		HRESULT retValue;
	};

	STDMETHOD(get_ProjectType)(
		/*[out,retval]*/ prjProjectType* pProjectType)
	{
		VSL_DEFINE_MOCK_METHOD(get_ProjectType)

		VSL_SET_VALIDVALUE(pProjectType);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DefaultNamespaceValidValues
	{
		/*[out,retval]*/ BSTR* pbstrRootNamespace;
		HRESULT retValue;
	};

	STDMETHOD(get_DefaultNamespace)(
		/*[out,retval]*/ BSTR* pbstrRootNamespace)
	{
		VSL_DEFINE_MOCK_METHOD(get_DefaultNamespace)

		VSL_SET_VALIDVALUE_BSTR(pbstrRootNamespace);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_DefaultNamespaceValidValues
	{
		/*[in]*/ BSTR bstrRootNamespace;
		HRESULT retValue;
	};

	STDMETHOD(put_DefaultNamespace)(
		/*[in]*/ BSTR bstrRootNamespace)
	{
		VSL_DEFINE_MOCK_METHOD(put_DefaultNamespace)

		VSL_CHECK_VALIDVALUE_BSTR(bstrRootNamespace);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // VBPROJECTPROPERTIES3_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockVSProject2.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef VSPROJECT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define VSPROJECT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vslangproj80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class VSProject2NotImpl :
	public VSProject2
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(VSProject2NotImpl)

public:

	typedef VSProject2 Interface;

	STDMETHOD(get_PublishManager)(
		/*[out,retval]*/ IDispatch** /*ppPublishManager*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Events2)(
		/*[out,retval]*/ VSProjectEvents2** /*ppEvents*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_References)(
		/*[out,retval]*/ References** /*ppRefs*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_BuildManager)(
		/*[out,retval]*/ BuildManager** /*ppBuildMgr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DTE)(
		/*[out,retval]*/ DTE** /*ppDTE*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Project)(
		/*[out,retval]*/ Project** /*ppProject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateWebReferencesFolder)(
		/*[out,retval]*/ ProjectItem** /*ppProjectItem*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_WebReferencesFolder)(
		/*[out,retval]*/ ProjectItem** /*ppProjectItem*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddWebReference)(
		/*[in]*/ BSTR /*bstrUrl*/,
		/*[out,retval]*/ ProjectItem** /*ppProjectItem*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_TemplatePath)(
		/*[out,retval]*/ BSTR* /*pbstrTemplatePath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Refresh)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_WorkOffline)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbWorkOffline*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_WorkOffline)(
		/*[in]*/ VARIANT_BOOL /*bWorkOffline*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Imports)(
		/*[out,retval]*/ Imports** /*ppImports*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Events)(
		/*[out,retval]*/ VSProjectEvents** /*ppEvents*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CopyProject)(
		/*[in]*/ BSTR /*bstrDestFolder*/,
		/*[in]*/ BSTR /*bstrDestUNCPath*/,
		/*[in]*/ prjCopyProjectOption /*copyProjectOption*/,
		/*[in]*/ BSTR /*bstrUsername*/,
		/*[in]*/ BSTR /*bstrPassword*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Exec)(
		/*[in]*/ prjExecCommand /*command*/,
		/*[in]*/ BOOL /*bSuppressUI*/,
		/*[in]*/ VARIANT /*varIn*/,
		/*[out]*/ VARIANT* /*pVarOut*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GenerateKeyPairFiles)(
		/*[in]*/ BSTR /*strPublicPrivateFile*/,
		/*[in,defaultvalue(NULL)]*/ BSTR /*strPublicOnlyFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetUniqueFilename)(
		/*[in]*/ IDispatch* /*pDispatch*/,
		/*[in]*/ BSTR /*bstrRoot*/,
		/*[in]*/ BSTR /*bstrDesiredExt*/,
		/*[out,retval]*/ BSTR* /*pbstrFileName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class VSProject2MockImpl :
	public VSProject2,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(VSProject2MockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(VSProject2MockImpl)

	typedef VSProject2 Interface;
	struct get_PublishManagerValidValues
	{
		/*[out,retval]*/ IDispatch** ppPublishManager;
		HRESULT retValue;
	};

	STDMETHOD(get_PublishManager)(
		/*[out,retval]*/ IDispatch** ppPublishManager)
	{
		VSL_DEFINE_MOCK_METHOD(get_PublishManager)

		VSL_SET_VALIDVALUE_INTERFACE(ppPublishManager);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_Events2ValidValues
	{
		/*[out,retval]*/ VSProjectEvents2** ppEvents;
		HRESULT retValue;
	};

	STDMETHOD(get_Events2)(
		/*[out,retval]*/ VSProjectEvents2** ppEvents)
	{
		VSL_DEFINE_MOCK_METHOD(get_Events2)

		VSL_SET_VALIDVALUE(ppEvents);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ReferencesValidValues
	{
		/*[out,retval]*/ References** ppRefs;
		HRESULT retValue;
	};

	STDMETHOD(get_References)(
		/*[out,retval]*/ References** ppRefs)
	{
		VSL_DEFINE_MOCK_METHOD(get_References)

		VSL_SET_VALIDVALUE_INTERFACE(ppRefs);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_BuildManagerValidValues
	{
		/*[out,retval]*/ BuildManager** ppBuildMgr;
		HRESULT retValue;
	};

	STDMETHOD(get_BuildManager)(
		/*[out,retval]*/ BuildManager** ppBuildMgr)
	{
		VSL_DEFINE_MOCK_METHOD(get_BuildManager)

		VSL_SET_VALIDVALUE_INTERFACE(ppBuildMgr);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DTEValidValues
	{
		/*[out,retval]*/ DTE** ppDTE;
		HRESULT retValue;
	};

	STDMETHOD(get_DTE)(
		/*[out,retval]*/ DTE** ppDTE)
	{
		VSL_DEFINE_MOCK_METHOD(get_DTE)

		VSL_SET_VALIDVALUE(ppDTE);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ProjectValidValues
	{
		/*[out,retval]*/ Project** ppProject;
		HRESULT retValue;
	};

	STDMETHOD(get_Project)(
		/*[out,retval]*/ Project** ppProject)
	{
		VSL_DEFINE_MOCK_METHOD(get_Project)

		VSL_SET_VALIDVALUE(ppProject);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateWebReferencesFolderValidValues
	{
		/*[out,retval]*/ ProjectItem** ppProjectItem;
		HRESULT retValue;
	};

	STDMETHOD(CreateWebReferencesFolder)(
		/*[out,retval]*/ ProjectItem** ppProjectItem)
	{
		VSL_DEFINE_MOCK_METHOD(CreateWebReferencesFolder)

		VSL_SET_VALIDVALUE(ppProjectItem);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_WebReferencesFolderValidValues
	{
		/*[out,retval]*/ ProjectItem** ppProjectItem;
		HRESULT retValue;
	};

	STDMETHOD(get_WebReferencesFolder)(
		/*[out,retval]*/ ProjectItem** ppProjectItem)
	{
		VSL_DEFINE_MOCK_METHOD(get_WebReferencesFolder)

		VSL_SET_VALIDVALUE(ppProjectItem);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddWebReferenceValidValues
	{
		/*[in]*/ BSTR bstrUrl;
		/*[out,retval]*/ ProjectItem** ppProjectItem;
		HRESULT retValue;
	};

	STDMETHOD(AddWebReference)(
		/*[in]*/ BSTR bstrUrl,
		/*[out,retval]*/ ProjectItem** ppProjectItem)
	{
		VSL_DEFINE_MOCK_METHOD(AddWebReference)

		VSL_CHECK_VALIDVALUE_BSTR(bstrUrl);

		VSL_SET_VALIDVALUE(ppProjectItem);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_TemplatePathValidValues
	{
		/*[out,retval]*/ BSTR* pbstrTemplatePath;
		HRESULT retValue;
	};

	STDMETHOD(get_TemplatePath)(
		/*[out,retval]*/ BSTR* pbstrTemplatePath)
	{
		VSL_DEFINE_MOCK_METHOD(get_TemplatePath)

		VSL_SET_VALIDVALUE_BSTR(pbstrTemplatePath);

		VSL_RETURN_VALIDVALUES();
	}
	struct RefreshValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Refresh)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Refresh)

		VSL_RETURN_VALIDVALUES();
	}
	struct get_WorkOfflineValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbWorkOffline;
		HRESULT retValue;
	};

	STDMETHOD(get_WorkOffline)(
		/*[out,retval]*/ VARIANT_BOOL* pbWorkOffline)
	{
		VSL_DEFINE_MOCK_METHOD(get_WorkOffline)

		VSL_SET_VALIDVALUE(pbWorkOffline);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_WorkOfflineValidValues
	{
		/*[in]*/ VARIANT_BOOL bWorkOffline;
		HRESULT retValue;
	};

	STDMETHOD(put_WorkOffline)(
		/*[in]*/ VARIANT_BOOL bWorkOffline)
	{
		VSL_DEFINE_MOCK_METHOD(put_WorkOffline)

		VSL_CHECK_VALIDVALUE(bWorkOffline);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ImportsValidValues
	{
		/*[out,retval]*/ Imports** ppImports;
		HRESULT retValue;
	};

	STDMETHOD(get_Imports)(
		/*[out,retval]*/ Imports** ppImports)
	{
		VSL_DEFINE_MOCK_METHOD(get_Imports)

		VSL_SET_VALIDVALUE_INTERFACE(ppImports);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_EventsValidValues
	{
		/*[out,retval]*/ VSProjectEvents** ppEvents;
		HRESULT retValue;
	};

	STDMETHOD(get_Events)(
		/*[out,retval]*/ VSProjectEvents** ppEvents)
	{
		VSL_DEFINE_MOCK_METHOD(get_Events)

		VSL_SET_VALIDVALUE(ppEvents);

		VSL_RETURN_VALIDVALUES();
	}
	struct CopyProjectValidValues
	{
		/*[in]*/ BSTR bstrDestFolder;
		/*[in]*/ BSTR bstrDestUNCPath;
		/*[in]*/ prjCopyProjectOption copyProjectOption;
		/*[in]*/ BSTR bstrUsername;
		/*[in]*/ BSTR bstrPassword;
		HRESULT retValue;
	};

	STDMETHOD(CopyProject)(
		/*[in]*/ BSTR bstrDestFolder,
		/*[in]*/ BSTR bstrDestUNCPath,
		/*[in]*/ prjCopyProjectOption copyProjectOption,
		/*[in]*/ BSTR bstrUsername,
		/*[in]*/ BSTR bstrPassword)
	{
		VSL_DEFINE_MOCK_METHOD(CopyProject)

		VSL_CHECK_VALIDVALUE_BSTR(bstrDestFolder);

		VSL_CHECK_VALIDVALUE_BSTR(bstrDestUNCPath);

		VSL_CHECK_VALIDVALUE(copyProjectOption);

		VSL_CHECK_VALIDVALUE_BSTR(bstrUsername);

		VSL_CHECK_VALIDVALUE_BSTR(bstrPassword);

		VSL_RETURN_VALIDVALUES();
	}
	struct ExecValidValues
	{
		/*[in]*/ prjExecCommand command;
		/*[in]*/ BOOL bSuppressUI;
		/*[in]*/ VARIANT varIn;
		/*[out]*/ VARIANT* pVarOut;
		HRESULT retValue;
	};

	STDMETHOD(Exec)(
		/*[in]*/ prjExecCommand command,
		/*[in]*/ BOOL bSuppressUI,
		/*[in]*/ VARIANT varIn,
		/*[out]*/ VARIANT* pVarOut)
	{
		VSL_DEFINE_MOCK_METHOD(Exec)

		VSL_CHECK_VALIDVALUE(command);

		VSL_CHECK_VALIDVALUE(bSuppressUI);

		VSL_CHECK_VALIDVALUE(varIn);

		VSL_SET_VALIDVALUE_VARIANT(pVarOut);

		VSL_RETURN_VALIDVALUES();
	}
	struct GenerateKeyPairFilesValidValues
	{
		/*[in]*/ BSTR strPublicPrivateFile;
		/*[in,defaultvalue(NULL)]*/ BSTR strPublicOnlyFile;
		HRESULT retValue;
	};

	STDMETHOD(GenerateKeyPairFiles)(
		/*[in]*/ BSTR strPublicPrivateFile,
		/*[in,defaultvalue(NULL)]*/ BSTR strPublicOnlyFile)
	{
		VSL_DEFINE_MOCK_METHOD(GenerateKeyPairFiles)

		VSL_CHECK_VALIDVALUE_BSTR(strPublicPrivateFile);

		VSL_CHECK_VALIDVALUE_BSTR(strPublicOnlyFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetUniqueFilenameValidValues
	{
		/*[in]*/ IDispatch* pDispatch;
		/*[in]*/ BSTR bstrRoot;
		/*[in]*/ BSTR bstrDesiredExt;
		/*[out,retval]*/ BSTR* pbstrFileName;
		HRESULT retValue;
	};

	STDMETHOD(GetUniqueFilename)(
		/*[in]*/ IDispatch* pDispatch,
		/*[in]*/ BSTR bstrRoot,
		/*[in]*/ BSTR bstrDesiredExt,
		/*[out,retval]*/ BSTR* pbstrFileName)
	{
		VSL_DEFINE_MOCK_METHOD(GetUniqueFilename)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDispatch);

		VSL_CHECK_VALIDVALUE_BSTR(bstrRoot);

		VSL_CHECK_VALIDVALUE_BSTR(bstrDesiredExt);

		VSL_SET_VALIDVALUE_BSTR(pbstrFileName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // VSPROJECT2_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockVSProjectItem.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef VSPROJECTITEM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define VSPROJECTITEM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vslangproj.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class VSProjectItemNotImpl :
	public VSProjectItem
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(VSProjectItemNotImpl)

public:

	typedef VSProjectItem Interface;

	STDMETHOD(get_DTE)(
		/*[out,retval]*/ DTE** /*ppDTE*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ProjectItem)(
		/*[out,retval]*/ ProjectItem** /*ppProjectItem*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_ContainingProject)(
		/*[out,retval]*/ Project** /*ppProject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(RunCustomTool)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class VSProjectItemMockImpl :
	public VSProjectItem,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(VSProjectItemMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(VSProjectItemMockImpl)

	typedef VSProjectItem Interface;
	struct get_DTEValidValues
	{
		/*[out,retval]*/ DTE** ppDTE;
		HRESULT retValue;
	};

	STDMETHOD(get_DTE)(
		/*[out,retval]*/ DTE** ppDTE)
	{
		VSL_DEFINE_MOCK_METHOD(get_DTE)

		VSL_SET_VALIDVALUE(ppDTE);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ProjectItemValidValues
	{
		/*[out,retval]*/ ProjectItem** ppProjectItem;
		HRESULT retValue;
	};

	STDMETHOD(get_ProjectItem)(
		/*[out,retval]*/ ProjectItem** ppProjectItem)
	{
		VSL_DEFINE_MOCK_METHOD(get_ProjectItem)

		VSL_SET_VALIDVALUE(ppProjectItem);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ContainingProjectValidValues
	{
		/*[out,retval]*/ Project** ppProject;
		HRESULT retValue;
	};

	STDMETHOD(get_ContainingProject)(
		/*[out,retval]*/ Project** ppProject)
	{
		VSL_DEFINE_MOCK_METHOD(get_ContainingProject)

		VSL_SET_VALIDVALUE(ppProject);

		VSL_RETURN_VALIDVALUES();
	}
	struct RunCustomToolValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(RunCustomTool)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(RunCustomTool)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // VSPROJECTITEM_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockWebSettings.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef WEBSETTINGS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define WEBSETTINGS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vslangproj.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class WebSettingsNotImpl :
	public WebSettings
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(WebSettingsNotImpl)

public:

	typedef WebSettings Interface;

	STDMETHOD(get_AuthoringAccess)(
		/*[out,retval]*/ webPrjAuthoringAccess* /*pAccessMethod*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_AuthoringAccess)(
		/*[in]*/ webPrjAuthoringAccess /*AccessMethod*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_RepairLinks)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbRepairLinks*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_RepairLinks)(
		/*[in]*/ VARIANT_BOOL /*bRepairLinks*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_WebProjectCacheDirectory)(
		/*[out,retval]*/ BSTR* /*pbstrDirectory*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_WebProjectCacheDirectory)(
		/*[in]*/ BSTR /*bstrDirectory*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(SetDefaultWebProjectCacheDirectory)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class WebSettingsMockImpl :
	public WebSettings,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(WebSettingsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(WebSettingsMockImpl)

	typedef WebSettings Interface;
	struct get_AuthoringAccessValidValues
	{
		/*[out,retval]*/ webPrjAuthoringAccess* pAccessMethod;
		HRESULT retValue;
	};

	STDMETHOD(get_AuthoringAccess)(
		/*[out,retval]*/ webPrjAuthoringAccess* pAccessMethod)
	{
		VSL_DEFINE_MOCK_METHOD(get_AuthoringAccess)

		VSL_SET_VALIDVALUE(pAccessMethod);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_AuthoringAccessValidValues
	{
		/*[in]*/ webPrjAuthoringAccess AccessMethod;
		HRESULT retValue;
	};

	STDMETHOD(put_AuthoringAccess)(
		/*[in]*/ webPrjAuthoringAccess AccessMethod)
	{
		VSL_DEFINE_MOCK_METHOD(put_AuthoringAccess)

		VSL_CHECK_VALIDVALUE(AccessMethod);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_RepairLinksValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbRepairLinks;
		HRESULT retValue;
	};

	STDMETHOD(get_RepairLinks)(
		/*[out,retval]*/ VARIANT_BOOL* pbRepairLinks)
	{
		VSL_DEFINE_MOCK_METHOD(get_RepairLinks)

		VSL_SET_VALIDVALUE(pbRepairLinks);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_RepairLinksValidValues
	{
		/*[in]*/ VARIANT_BOOL bRepairLinks;
		HRESULT retValue;
	};

	STDMETHOD(put_RepairLinks)(
		/*[in]*/ VARIANT_BOOL bRepairLinks)
	{
		VSL_DEFINE_MOCK_METHOD(put_RepairLinks)

		VSL_CHECK_VALIDVALUE(bRepairLinks);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_WebProjectCacheDirectoryValidValues
	{
		/*[out,retval]*/ BSTR* pbstrDirectory;
		HRESULT retValue;
	};

	STDMETHOD(get_WebProjectCacheDirectory)(
		/*[out,retval]*/ BSTR* pbstrDirectory)
	{
		VSL_DEFINE_MOCK_METHOD(get_WebProjectCacheDirectory)

		VSL_SET_VALIDVALUE_BSTR(pbstrDirectory);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_WebProjectCacheDirectoryValidValues
	{
		/*[in]*/ BSTR bstrDirectory;
		HRESULT retValue;
	};

	STDMETHOD(put_WebProjectCacheDirectory)(
		/*[in]*/ BSTR bstrDirectory)
	{
		VSL_DEFINE_MOCK_METHOD(put_WebProjectCacheDirectory)

		VSL_CHECK_VALIDVALUE_BSTR(bstrDirectory);

		VSL_RETURN_VALIDVALUES();
	}
	struct SetDefaultWebProjectCacheDirectoryValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(SetDefaultWebProjectCacheDirectory)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(SetDefaultWebProjectCacheDirectory)

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // WEBSETTINGS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMock_BuildManagerEvents.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef _BUILDMANAGEREVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define _BUILDMANAGEREVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vslangproj.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class _BuildManagerEventsNotImpl :
	public _BuildManagerEvents
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(_BuildManagerEventsNotImpl)

public:

	typedef _BuildManagerEvents Interface;

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class _BuildManagerEventsMockImpl :
	public _BuildManagerEvents,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(_BuildManagerEventsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(_BuildManagerEventsMockImpl)

	typedef _BuildManagerEvents Interface;
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // _BUILDMANAGEREVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMockVSProject.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef VSPROJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define VSPROJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vslangproj.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class VSProjectNotImpl :
	public VSProject
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(VSProjectNotImpl)

public:

	typedef VSProject Interface;

	STDMETHOD(get_References)(
		/*[out,retval]*/ References** /*ppRefs*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_BuildManager)(
		/*[out,retval]*/ BuildManager** /*ppBuildMgr*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_DTE)(
		/*[out,retval]*/ DTE** /*ppDTE*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Project)(
		/*[out,retval]*/ Project** /*ppProject*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CreateWebReferencesFolder)(
		/*[out,retval]*/ ProjectItem** /*ppProjectItem*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_WebReferencesFolder)(
		/*[out,retval]*/ ProjectItem** /*ppProjectItem*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(AddWebReference)(
		/*[in]*/ BSTR /*bstrUrl*/,
		/*[out,retval]*/ ProjectItem** /*ppProjectItem*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_TemplatePath)(
		/*[out,retval]*/ BSTR* /*pbstrTemplatePath*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Refresh)()VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_WorkOffline)(
		/*[out,retval]*/ VARIANT_BOOL* /*pbWorkOffline*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(put_WorkOffline)(
		/*[in]*/ VARIANT_BOOL /*bWorkOffline*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Imports)(
		/*[out,retval]*/ Imports** /*ppImports*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(get_Events)(
		/*[out,retval]*/ VSProjectEvents** /*ppEvents*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(CopyProject)(
		/*[in]*/ BSTR /*bstrDestFolder*/,
		/*[in]*/ BSTR /*bstrDestUNCPath*/,
		/*[in]*/ prjCopyProjectOption /*copyProjectOption*/,
		/*[in]*/ BSTR /*bstrUsername*/,
		/*[in]*/ BSTR /*bstrPassword*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Exec)(
		/*[in]*/ prjExecCommand /*command*/,
		/*[in]*/ BOOL /*bSuppressUI*/,
		/*[in]*/ VARIANT /*varIn*/,
		/*[out]*/ VARIANT* /*pVarOut*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GenerateKeyPairFiles)(
		/*[in]*/ BSTR /*strPublicPrivateFile*/,
		/*[in,defaultvalue(NULL)]*/ BSTR /*strPublicOnlyFile*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetUniqueFilename)(
		/*[in]*/ IDispatch* /*pDispatch*/,
		/*[in]*/ BSTR /*bstrRoot*/,
		/*[in]*/ BSTR /*bstrDesiredExt*/,
		/*[out,retval]*/ BSTR* /*pbstrFileName*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class VSProjectMockImpl :
	public VSProject,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(VSProjectMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(VSProjectMockImpl)

	typedef VSProject Interface;
	struct get_ReferencesValidValues
	{
		/*[out,retval]*/ References** ppRefs;
		HRESULT retValue;
	};

	STDMETHOD(get_References)(
		/*[out,retval]*/ References** ppRefs)
	{
		VSL_DEFINE_MOCK_METHOD(get_References)

		VSL_SET_VALIDVALUE_INTERFACE(ppRefs);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_BuildManagerValidValues
	{
		/*[out,retval]*/ BuildManager** ppBuildMgr;
		HRESULT retValue;
	};

	STDMETHOD(get_BuildManager)(
		/*[out,retval]*/ BuildManager** ppBuildMgr)
	{
		VSL_DEFINE_MOCK_METHOD(get_BuildManager)

		VSL_SET_VALIDVALUE_INTERFACE(ppBuildMgr);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_DTEValidValues
	{
		/*[out,retval]*/ DTE** ppDTE;
		HRESULT retValue;
	};

	STDMETHOD(get_DTE)(
		/*[out,retval]*/ DTE** ppDTE)
	{
		VSL_DEFINE_MOCK_METHOD(get_DTE)

		VSL_SET_VALIDVALUE(ppDTE);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ProjectValidValues
	{
		/*[out,retval]*/ Project** ppProject;
		HRESULT retValue;
	};

	STDMETHOD(get_Project)(
		/*[out,retval]*/ Project** ppProject)
	{
		VSL_DEFINE_MOCK_METHOD(get_Project)

		VSL_SET_VALIDVALUE(ppProject);

		VSL_RETURN_VALIDVALUES();
	}
	struct CreateWebReferencesFolderValidValues
	{
		/*[out,retval]*/ ProjectItem** ppProjectItem;
		HRESULT retValue;
	};

	STDMETHOD(CreateWebReferencesFolder)(
		/*[out,retval]*/ ProjectItem** ppProjectItem)
	{
		VSL_DEFINE_MOCK_METHOD(CreateWebReferencesFolder)

		VSL_SET_VALIDVALUE(ppProjectItem);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_WebReferencesFolderValidValues
	{
		/*[out,retval]*/ ProjectItem** ppProjectItem;
		HRESULT retValue;
	};

	STDMETHOD(get_WebReferencesFolder)(
		/*[out,retval]*/ ProjectItem** ppProjectItem)
	{
		VSL_DEFINE_MOCK_METHOD(get_WebReferencesFolder)

		VSL_SET_VALIDVALUE(ppProjectItem);

		VSL_RETURN_VALIDVALUES();
	}
	struct AddWebReferenceValidValues
	{
		/*[in]*/ BSTR bstrUrl;
		/*[out,retval]*/ ProjectItem** ppProjectItem;
		HRESULT retValue;
	};

	STDMETHOD(AddWebReference)(
		/*[in]*/ BSTR bstrUrl,
		/*[out,retval]*/ ProjectItem** ppProjectItem)
	{
		VSL_DEFINE_MOCK_METHOD(AddWebReference)

		VSL_CHECK_VALIDVALUE_BSTR(bstrUrl);

		VSL_SET_VALIDVALUE(ppProjectItem);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_TemplatePathValidValues
	{
		/*[out,retval]*/ BSTR* pbstrTemplatePath;
		HRESULT retValue;
	};

	STDMETHOD(get_TemplatePath)(
		/*[out,retval]*/ BSTR* pbstrTemplatePath)
	{
		VSL_DEFINE_MOCK_METHOD(get_TemplatePath)

		VSL_SET_VALIDVALUE_BSTR(pbstrTemplatePath);

		VSL_RETURN_VALIDVALUES();
	}
	struct RefreshValidValues
	{
		HRESULT retValue;
	};

	STDMETHOD(Refresh)()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS(Refresh)

		VSL_RETURN_VALIDVALUES();
	}
	struct get_WorkOfflineValidValues
	{
		/*[out,retval]*/ VARIANT_BOOL* pbWorkOffline;
		HRESULT retValue;
	};

	STDMETHOD(get_WorkOffline)(
		/*[out,retval]*/ VARIANT_BOOL* pbWorkOffline)
	{
		VSL_DEFINE_MOCK_METHOD(get_WorkOffline)

		VSL_SET_VALIDVALUE(pbWorkOffline);

		VSL_RETURN_VALIDVALUES();
	}
	struct put_WorkOfflineValidValues
	{
		/*[in]*/ VARIANT_BOOL bWorkOffline;
		HRESULT retValue;
	};

	STDMETHOD(put_WorkOffline)(
		/*[in]*/ VARIANT_BOOL bWorkOffline)
	{
		VSL_DEFINE_MOCK_METHOD(put_WorkOffline)

		VSL_CHECK_VALIDVALUE(bWorkOffline);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_ImportsValidValues
	{
		/*[out,retval]*/ Imports** ppImports;
		HRESULT retValue;
	};

	STDMETHOD(get_Imports)(
		/*[out,retval]*/ Imports** ppImports)
	{
		VSL_DEFINE_MOCK_METHOD(get_Imports)

		VSL_SET_VALIDVALUE_INTERFACE(ppImports);

		VSL_RETURN_VALIDVALUES();
	}
	struct get_EventsValidValues
	{
		/*[out,retval]*/ VSProjectEvents** ppEvents;
		HRESULT retValue;
	};

	STDMETHOD(get_Events)(
		/*[out,retval]*/ VSProjectEvents** ppEvents)
	{
		VSL_DEFINE_MOCK_METHOD(get_Events)

		VSL_SET_VALIDVALUE(ppEvents);

		VSL_RETURN_VALIDVALUES();
	}
	struct CopyProjectValidValues
	{
		/*[in]*/ BSTR bstrDestFolder;
		/*[in]*/ BSTR bstrDestUNCPath;
		/*[in]*/ prjCopyProjectOption copyProjectOption;
		/*[in]*/ BSTR bstrUsername;
		/*[in]*/ BSTR bstrPassword;
		HRESULT retValue;
	};

	STDMETHOD(CopyProject)(
		/*[in]*/ BSTR bstrDestFolder,
		/*[in]*/ BSTR bstrDestUNCPath,
		/*[in]*/ prjCopyProjectOption copyProjectOption,
		/*[in]*/ BSTR bstrUsername,
		/*[in]*/ BSTR bstrPassword)
	{
		VSL_DEFINE_MOCK_METHOD(CopyProject)

		VSL_CHECK_VALIDVALUE_BSTR(bstrDestFolder);

		VSL_CHECK_VALIDVALUE_BSTR(bstrDestUNCPath);

		VSL_CHECK_VALIDVALUE(copyProjectOption);

		VSL_CHECK_VALIDVALUE_BSTR(bstrUsername);

		VSL_CHECK_VALIDVALUE_BSTR(bstrPassword);

		VSL_RETURN_VALIDVALUES();
	}
	struct ExecValidValues
	{
		/*[in]*/ prjExecCommand command;
		/*[in]*/ BOOL bSuppressUI;
		/*[in]*/ VARIANT varIn;
		/*[out]*/ VARIANT* pVarOut;
		HRESULT retValue;
	};

	STDMETHOD(Exec)(
		/*[in]*/ prjExecCommand command,
		/*[in]*/ BOOL bSuppressUI,
		/*[in]*/ VARIANT varIn,
		/*[out]*/ VARIANT* pVarOut)
	{
		VSL_DEFINE_MOCK_METHOD(Exec)

		VSL_CHECK_VALIDVALUE(command);

		VSL_CHECK_VALIDVALUE(bSuppressUI);

		VSL_CHECK_VALIDVALUE(varIn);

		VSL_SET_VALIDVALUE_VARIANT(pVarOut);

		VSL_RETURN_VALIDVALUES();
	}
	struct GenerateKeyPairFilesValidValues
	{
		/*[in]*/ BSTR strPublicPrivateFile;
		/*[in,defaultvalue(NULL)]*/ BSTR strPublicOnlyFile;
		HRESULT retValue;
	};

	STDMETHOD(GenerateKeyPairFiles)(
		/*[in]*/ BSTR strPublicPrivateFile,
		/*[in,defaultvalue(NULL)]*/ BSTR strPublicOnlyFile)
	{
		VSL_DEFINE_MOCK_METHOD(GenerateKeyPairFiles)

		VSL_CHECK_VALIDVALUE_BSTR(strPublicPrivateFile);

		VSL_CHECK_VALIDVALUE_BSTR(strPublicOnlyFile);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetUniqueFilenameValidValues
	{
		/*[in]*/ IDispatch* pDispatch;
		/*[in]*/ BSTR bstrRoot;
		/*[in]*/ BSTR bstrDesiredExt;
		/*[out,retval]*/ BSTR* pbstrFileName;
		HRESULT retValue;
	};

	STDMETHOD(GetUniqueFilename)(
		/*[in]*/ IDispatch* pDispatch,
		/*[in]*/ BSTR bstrRoot,
		/*[in]*/ BSTR bstrDesiredExt,
		/*[out,retval]*/ BSTR* pbstrFileName)
	{
		VSL_DEFINE_MOCK_METHOD(GetUniqueFilename)

		VSL_CHECK_VALIDVALUE_INTERFACEPOINTER(pDispatch);

		VSL_CHECK_VALIDVALUE_BSTR(bstrRoot);

		VSL_CHECK_VALIDVALUE_BSTR(bstrDesiredExt);

		VSL_SET_VALIDVALUE_BSTR(pbstrFileName);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // VSPROJECT_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMock_ImportsEvents.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef _IMPORTSEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define _IMPORTSEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vslangproj.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class _ImportsEventsNotImpl :
	public _ImportsEvents
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(_ImportsEventsNotImpl)

public:

	typedef _ImportsEvents Interface;

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class _ImportsEventsMockImpl :
	public _ImportsEvents,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(_ImportsEventsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(_ImportsEventsMockImpl)

	typedef _ImportsEvents Interface;
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // _IMPORTSEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMock_VSLangProjWebReferencesEvents.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef _VSLANGPROJWEBREFERENCESEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define _VSLANGPROJWEBREFERENCESEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vslangproj80.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class _VSLangProjWebReferencesEventsNotImpl :
	public _VSLangProjWebReferencesEvents
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(_VSLangProjWebReferencesEventsNotImpl)

public:

	typedef _VSLangProjWebReferencesEvents Interface;

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class _VSLangProjWebReferencesEventsMockImpl :
	public _VSLangProjWebReferencesEvents,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(_VSLangProjWebReferencesEventsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(_VSLangProjWebReferencesEventsMockImpl)

	typedef _VSLangProjWebReferencesEvents Interface;
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // _VSLANGPROJWEBREFERENCESEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\UnitTest\CommandTarget\CommandId.cpp ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#include "stdafx.h"

#include "CommandId.h"

// Initialize the static variables for CommandIdTest
const GUID  CommandIdTest::s_guidTest = {0x6558b1c8, 0x4257, 0x45c1, {0xb0, 0x49, 0x62, 0xce, 0x32, 0xeb, 0x6b, 0x15}};
const DWORD CommandIdTest::s_dwTestId = 42;

CommandIdTest::CommandIdTest(const char* const szTestName) :
	VSL::UnitTestBase(szTestName)
{
	VSL::CommandId commandID1(s_guidTest, s_dwTestId);
	CheckCommandID(commandID1);
	VSL::CommandId commandID2(commandID1);
	CheckCommandID(commandID2);
	UTCHKEX(commandID1 == commandID2, L"CommandId::operator== returned an unexpected value.");
	UTCHKEX(!(commandID1 != commandID2), L"CommandId::operator== returned an unexpected value.");
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\MockInterfaces\VSLMock_ReferencesEvents.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#ifndef _REFERENCESEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
#define _REFERENCESEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5

#if _MSC_VER > 1000
#pragma once
#endif

#include "vslangproj.h"

#pragma warning(push)
#pragma warning(disable : 4510) // default constructor could not be generated
#pragma warning(disable : 4610) // can never be instantiated - user defined constructor required
#pragma warning(disable : 4512) // assignment operator could not be generated
#pragma warning(disable : 6011) // Dereferencing NULL pointer (a NULL derference is just another kind of failure for a unit test

namespace VSL
{

class _ReferencesEventsNotImpl :
	public _ReferencesEvents
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(_ReferencesEventsNotImpl)

public:

	typedef _ReferencesEvents Interface;

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* /*pctinfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT /*iTInfo*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out]*/ ITypeInfo** /*ppTInfo*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID /*riid*/,
		/*[in,size_is(cNames)]*/ LPOLESTR* /*rgszNames*/,
		/*[in]*/ UINT /*cNames*/,
		/*[in]*/ LCID /*lcid*/,
		/*[out,size_is(cNames)]*/ DISPID* /*rgDispId*/)VSL_STDMETHOD_NOTIMPL

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID /*dispIdMember*/,
		/*[in]*/ REFIID /*riid*/,
		/*[in]*/ LCID /*lcid*/,
		/*[in]*/ WORD /*wFlags*/,
		/*[in,out]*/ DISPPARAMS* /*pDispParams*/,
		/*[out]*/ VARIANT* /*pVarResult*/,
		/*[out]*/ EXCEPINFO* /*pExcepInfo*/,
		/*[out]*/ UINT* /*puArgErr*/)VSL_STDMETHOD_NOTIMPL
};

class _ReferencesEventsMockImpl :
	public _ReferencesEvents,
	public MockBase
{

VSL_DECLARE_NONINSTANTIABLE_BASE_CLASS(_ReferencesEventsMockImpl)

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(_ReferencesEventsMockImpl)

	typedef _ReferencesEvents Interface;
	struct GetTypeInfoCountValidValues
	{
		/*[out]*/ UINT* pctinfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfoCount)(
		/*[out]*/ UINT* pctinfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfoCount)

		VSL_SET_VALIDVALUE(pctinfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetTypeInfoValidValues
	{
		/*[in]*/ UINT iTInfo;
		/*[in]*/ LCID lcid;
		/*[out]*/ ITypeInfo** ppTInfo;
		HRESULT retValue;
	};

	STDMETHOD(GetTypeInfo)(
		/*[in]*/ UINT iTInfo,
		/*[in]*/ LCID lcid,
		/*[out]*/ ITypeInfo** ppTInfo)
	{
		VSL_DEFINE_MOCK_METHOD(GetTypeInfo)

		VSL_CHECK_VALIDVALUE(iTInfo);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_INTERFACE(ppTInfo);

		VSL_RETURN_VALIDVALUES();
	}
	struct GetIDsOfNamesValidValues
	{
		/*[in]*/ REFIID riid;
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames;
		/*[in]*/ UINT cNames;
		/*[in]*/ LCID lcid;
		/*[out,size_is(cNames)]*/ DISPID* rgDispId;
		HRESULT retValue;
	};

	STDMETHOD(GetIDsOfNames)(
		/*[in]*/ REFIID riid,
		/*[in,size_is(cNames)]*/ LPOLESTR* rgszNames,
		/*[in]*/ UINT cNames,
		/*[in]*/ LCID lcid,
		/*[out,size_is(cNames)]*/ DISPID* rgDispId)
	{
		VSL_DEFINE_MOCK_METHOD(GetIDsOfNames)

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE_MEMCMP(rgszNames, cNames*sizeof(rgszNames[0]), validValues.cNames*sizeof(validValues.rgszNames[0]));

		VSL_CHECK_VALIDVALUE(cNames);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_SET_VALIDVALUE_MEMCPY(rgDispId, cNames*sizeof(rgDispId[0]), validValues.cNames*sizeof(validValues.rgDispId[0]));

		VSL_RETURN_VALIDVALUES();
	}
	struct InvokeValidValues
	{
		/*[in]*/ DISPID dispIdMember;
		/*[in]*/ REFIID riid;
		/*[in]*/ LCID lcid;
		/*[in]*/ WORD wFlags;
		/*[in,out]*/ DISPPARAMS* pDispParams;
		/*[out]*/ VARIANT* pVarResult;
		/*[out]*/ EXCEPINFO* pExcepInfo;
		/*[out]*/ UINT* puArgErr;
		HRESULT retValue;
	};

	STDMETHOD(Invoke)(
		/*[in]*/ DISPID dispIdMember,
		/*[in]*/ REFIID riid,
		/*[in]*/ LCID lcid,
		/*[in]*/ WORD wFlags,
		/*[in,out]*/ DISPPARAMS* pDispParams,
		/*[out]*/ VARIANT* pVarResult,
		/*[out]*/ EXCEPINFO* pExcepInfo,
		/*[out]*/ UINT* puArgErr)
	{
		VSL_DEFINE_MOCK_METHOD(Invoke)

		VSL_CHECK_VALIDVALUE(dispIdMember);

		VSL_CHECK_VALIDVALUE(riid);

		VSL_CHECK_VALIDVALUE(lcid);

		VSL_CHECK_VALIDVALUE(wFlags);

		VSL_SET_VALIDVALUE(pDispParams);

		VSL_SET_VALIDVALUE_VARIANT(pVarResult);

		VSL_SET_VALIDVALUE(pExcepInfo);

		VSL_SET_VALIDVALUE(puArgErr);

		VSL_RETURN_VALIDVALUES();
	}
};


} // namespace VSL

#pragma warning(pop)

#endif // _REFERENCESEVENTS_H_10C49CA1_2F46_11D3_A504_00C04F5E0BA5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\UnitTest\CommandTarget\CommandHandler.cpp ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#include "StdAfx.h"

#include "CommandHandler.h"

static const GUID  guidTest1 = {0x8e00c93c, 0x827f, 0x4bb5, {0xb5, 0xd7, 0x48, 0x08, 0xba, 0xa0, 0xf7, 0x29}};
static const DWORD dwTestId1 = 21;

HandlerTestProperties::HandlerTestProperties(const char* const szTestName) :
	VSL::UnitTestBase(szTestName)
{
	// Create a CommandId for this command handler.
	VSL::CommandId testId(guidTest1, dwTestId1);

	// Check the default values.
	{   // Create the command handler via first constructor
		VSL::CommandHandlerBase<HandlerTestProperties> handler(testId);
		CheckDefaultValues(handler, testId);
	}
	{   // Create the command handler via second constructor
		VSL::CommandHandlerBase<HandlerTestProperties> handler(testId.GetGuid(), testId.GetId());
		CheckDefaultValues(handler, testId);
	}

	// Check the status properties when set from the constructor
	{   
		// Create the command handler with only the supported flag set.
		VSL::CommandHandlerBase<HandlerTestProperties> handler(testId, NULL, NULL, OLECMDF_SUPPORTED);
		CheckSupportedWasSet(handler, testId);
	}
	{   
		// Create the command handler with only the supported flag set.
		VSL::CommandHandlerBase<HandlerTestProperties> handler(testId.GetGuid(), testId.GetId(), NULL, NULL, OLECMDF_SUPPORTED);
		CheckSupportedWasSet(handler, testId);
	}
	DWORD dwVariousFlags = OLECMDF_ENABLED | OLECMDF_INVISIBLE | OLECMDF_LATCHED;
	{   
		// Create the command handler.
		VSL::CommandHandlerBase<HandlerTestProperties> handler(testId, NULL, NULL, dwVariousFlags);
		CheckVariousFlagsSet(handler, testId, dwVariousFlags);
	}
	{   
		// Create the command handler.
		VSL::CommandHandlerBase<HandlerTestProperties> handler(testId.GetGuid(), testId.GetId(), NULL, NULL, dwVariousFlags);
		CheckVariousFlagsSet(handler, testId, dwVariousFlags);
	}

	// Check that the properties are set correctly by the setter methods.
	{
		// Create a command handler with the default settings.
		VSL::CommandHandlerBase<HandlerTestProperties> handler(testId);
		CheckSetters(handler);
	}
	{
		// Create a command handler with the default settings.
		VSL::CommandHandlerBase<HandlerTestProperties> handler(testId.GetGuid(), testId.GetId());
		CheckSetters(handler);
	}

	// Check that the Text property is set correctly by the constructor and setter method.
	const wchar_t szText[] = L"Original Text";
	{
		VSL::CommandHandlerBase<HandlerTestProperties> handler(testId, NULL, NULL, OLECMDF_ENABLED | OLECMDF_SUPPORTED, szText);
		CheckText(handler, szText);
	}
	{
		VSL::CommandHandlerBase<HandlerTestProperties> handler(testId.GetGuid(), testId.GetId(), NULL, NULL, OLECMDF_ENABLED | OLECMDF_SUPPORTED, szText);
		CheckText(handler, szText);
	}
}


HandlerTestStandardMethods::HandlerTestStandardMethods(const char* const szTestName) :
	VSL::UnitTestBase(szTestName)
{
	// Create a CommandId for this command handler.
	VSL::CommandId testId(guidTest1, dwTestId1);

	// Test the standard HandlerTestStandardMethods (no callback).
	{
		VSL::CommandHandlerBase<HandlerTestStandardMethods> handler(testId);
		handler.Exec(NULL, 0, NULL, NULL);

		// QueryStatus
		VSL_STDMETHODTRY {

		handler.QueryStatus(this, NULL, NULL);

		}VSL_STDMETHODCATCH()
		UTCHKEX(E_POINTER==VSL_GET_STDMETHOD_HRESULT(), L"E_POINTER expected from CommandHandlerBase::QueryStatus if there is no OLECMD.");

		OLECMD oleCmd;
		handler.QueryStatus(this, &oleCmd, NULL);
		UTCHKEX((OLECMDF_ENABLED|OLECMDF_SUPPORTED) == oleCmd.cmdf, L"Unexpected OLECMD returned by CommandHandlerBase::QueryStatus.");

		// Define a buffer big enough for the OLECMDTEXT structure with a text of stringLen wchars; notice that when we allocate
		// the buffer we reduce the len of the string by one because the first char is defined inside the structure.
		const size_t stringSize = 11;
		const size_t bufferSize = sizeof(OLECMDTEXT)+ ((stringSize-1)*sizeof(wchar_t)) + 1;
		const BYTE testValue = 7;
		BYTE buffer[bufferSize];
		buffer[bufferSize-1] = testValue; // set a value right after the end of the buffer used by OLECMDTEXT so that we can catch
		                                  // off by 1 errors.
		OLECMDTEXT* pOleText = (OLECMDTEXT*)buffer;
		// Set the flags to 0 so that the QueryStatus does not try to set the text field.
		pOleText->cmdtextf = 0;
		pOleText->cwActual = 0;
		pOleText->cwBuf = stringSize;
		pOleText->rgwz[0] = 309;	// Set some random number so that we can check that it is not changed by QueryStatus.
		handler.QueryStatus(this, &oleCmd, pOleText);
		UTCHKEX(309==pOleText->rgwz[0], L"CommandHandlerBase::QueryStatus has changed the OLECMDTEXT structure without the OLECMDTEXTF_NAME flag set.");
		UTCHKEX(testValue==buffer[bufferSize-1], L"CommandHandlerBase::QueryStatus har corrupted the memory around OLECMDTEXT.");

		// Now check that the text is set to an empty string.
		pOleText->cmdtextf = OLECMDTEXTF_NAME;
		handler.QueryStatus(this, &oleCmd, pOleText);
		UTCHKEX(0==pOleText->rgwz[0], L"CommandHandlerBase::QueryStatus has not set the OLETEXT;");
		UTCHKEX(testValue==buffer[bufferSize-1], L"CommandHandlerBase::QueryStatus har corrupted the memory around OLECMDTEXT.");

		// Check that the text is set for a not empty string.
		const wchar_t szText[] = L"Test";
		handler.GetText() = szText;
		handler.QueryStatus(this, &oleCmd, pOleText);
		UTCHKEX(0 == wcscmp(szText, pOleText->rgwz), L"Wrong text set by CommandHandlerBase::QueryStatus");
		UTCHKEX(wcslen(szText)==pOleText->cwActual, L"Wrong buffer size set by CommandHandlerBase::QueryStatus");
		UTCHKEX(testValue==buffer[bufferSize-1], L"CommandHandlerBase::QueryStatus har corrupted the memory around OLECMDTEXT.");

		#define BIG_STRING_BASE L"0123456789"
		// Check the result if the command text is as big as the string in OLECMDTEXT.
		handler.GetText() = BIG_STRING_BASE;
		handler.QueryStatus(this, &oleCmd, pOleText);
		UTCHKEX(0 == wcsncmp(BIG_STRING_BASE, pOleText->rgwz, stringSize), L"Wrong text set by CommandHandlerBase::QueryStatus");
		UTCHKEX(stringSize-1==pOleText->cwActual, L"Wrong buffer size set by CommandHandlerBase::QueryStatus");
		UTCHKEX(testValue==buffer[bufferSize-1], L"CommandHandlerBase::QueryStatus har corrupted the memory around OLECMDTEXT.");

		// Check the result if the command text is bigger than the string in OLECMDTEXT.
		handler.GetText() = BIG_STRING_BASE BIG_STRING_BASE;
		handler.QueryStatus(this, &oleCmd, pOleText);
		UTCHKEX(0 == wcsncmp(BIG_STRING_BASE, pOleText->rgwz, stringSize), L"Wrong text set by CommandHandlerBase::QueryStatus");
		UTCHKEX(stringSize-1==pOleText->cwActual, L"Wrong buffer size set by CommandHandlerBase::QueryStatus");
		UTCHKEX(testValue==buffer[bufferSize-1], L"CommandHandlerBase::QueryStatus har corrupted the memory around OLECMDTEXT.");
	}
}

// HandlerTestCallbacks
HandlerTestCallbacks::HandlerTestCallbacks(const char* const szTestName) :
	VSL::UnitTestBase(szTestName)
{
	// Create a CommandId for this command handler.
	VSL::CommandId testId(guidTest1, dwTestId1);

	// Test the callbacks.
	{
		CommandHandler handler(testId, CommandHandler::QueryStatusHandler(&HandlerTestCallbacks::QueryStatus), CommandHandler::ExecHandler(&HandlerTestCallbacks::Exec));

		// The Exec callback should not be called if there is no target.
		fCallbackCalled = false;
		HRESULT VSL_STDMETHOD_HRESULT = VSL_STDMETHOD_HRESULT_INIT;
		try{

		handler.Exec(NULL, 0, NULL, NULL);

		}VSL_STDMETHODCATCH()
		UTCHKEX(E_POINTER==VSL_GET_STDMETHOD_HRESULT(), L"E_POINTER expected from CommandHandlerBase::Exec if there is no target.");
		UTCHKEX(false==fCallbackCalled, L"CommandHandlerBase::Exec invoked the callback when not expected.");

		// Check that the callback is called.
		fCallbackCalled = false;
		handler.Exec(this, 0, NULL, NULL);
		UTCHKEX(true==fCallbackCalled, L"Callback not invoked from CommandHandlerBase::Exec.");

		// The QueryStatus callback should not be invoked if there is not target
		fCallbackCalled = false;
		OLECMD oleCmd;

		VSL_STDMETHOD_HRESULT = VSL_STDMETHOD_HRESULT_INIT;
		try{

		handler.QueryStatus(NULL, &oleCmd, NULL);
		
		}VSL_STDMETHODCATCH()
		UTCHKEX(E_POINTER==VSL_GET_STDMETHOD_HRESULT(), L"E_POINTER expected from CommandHandlerBase::QueryStatus if there is no target.");
		UTCHKEX(false==fCallbackCalled, L"CommandHandlerBase::QueryStatus invoked the callback when not expected.");

		// Check that the callback is called.
		fCallbackCalled = false;
		handler.QueryStatus(this, &oleCmd, NULL);
		UTCHKEX(true==fCallbackCalled, L"Callback not invoked from CommandHandlerBase::QUeryStatus.");
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\UnitTest\CommandTarget\commandhandler.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#include <VSLUnitTest.h>
#include <VSLCommandTarget.h>
#include <VSLShortNameDefines.h>

class HandlerTestProperties :
	public VSL::UnitTestBase
{
private:
	void CheckDefaultValues(
		const VSL::CommandHandlerBase<HandlerTestProperties>& rHandler, 
		const VSL::CommandId& rID)
	{
		// Check the ID for the command.
		UTCHKEX(rID == rHandler.GetId(), L"CommandHandlerBase::GetId returned an unexpected value.");
		// The text should be NULL or empty.
		const wchar_t* szText = rHandler.GetText();
		UTCHKEX((NULL==szText) || (0==wcslen(szText)), L"CommandHandlerBase::GetText should return NULL.");
		// Check the status properties.
		UTCHKEX(false == rHandler.GetChecked(), L"CommandHandlerBase::GetChecked should return false.");
		UTCHKEX(rHandler.GetEnabled(), L"CommandHandlerBase::GetEnabled should return true.");
		UTCHKEX(rHandler.GetSupported(), L"CommandHandlerBase::GetSupported should return true.");
		UTCHKEX(rHandler.GetVisible(), L"CommandHandlerBase::GetVisible should return true.");
	}

	void CheckSupportedWasSet(
		const VSL::CommandHandlerBase<HandlerTestProperties>& rHandler, 
		const VSL::CommandId& rID)
	{
		// Check the ID for the command.
		UTCHKEX(rID == rHandler.GetId(), L"CommandHandlerBase::GetId returned an unexpected value.");
		// The text should be NULL or empty.
		const wchar_t* szText = rHandler.GetText();
		UTCHKEX((NULL==szText) || (0==wcslen(szText)), L"CommandHandlerBase::GetText should return NULL.");
		// Check the status properties.
		UTCHKEX(false == rHandler.GetChecked(), L"CommandHandlerBase::GetChecked should return false.");
		UTCHKEX(false == rHandler.GetEnabled(), L"CommandHandlerBase::GetEnabled should return false.");
		UTCHKEX(rHandler.GetSupported(), L"CommandHandlerBase::GetSupported should return true.");
		UTCHKEX(rHandler.GetVisible(), L"CommandHandlerBase::GetVisible should return true.");
		UTCHKEX(OLECMDF_SUPPORTED == rHandler.GetFlags(), L"CommandHandlerBase::GetFlags returned an unexpected value.");
	}

	void CheckVariousFlagsSet(
		const VSL::CommandHandlerBase<HandlerTestProperties>& rHandler, 
		const VSL::CommandId& rID,
		DWORD dwFlags)
	{
		// Check the ID for the command.
		UTCHKEX(rID == rHandler.GetId(), L"CommandHandlerBase::GetId returned an unexpected value.");
		// The text should be NULL or empty.
		const wchar_t* szText = rHandler.GetText();
		UTCHKEX((NULL==szText) || (0==wcslen(szText)), L"CommandHandlerBase::GetText should return NULL.");
		// Check the status properties.
		UTCHKEX(rHandler.GetChecked(), L"CommandHandlerBase::GetChecked should return true.");
		UTCHKEX(rHandler.GetEnabled(), L"CommandHandlerBase::GetEnabled should return true.");
		UTCHKEX(false == rHandler.GetSupported(), L"CommandHandlerBase::GetSupported should return false.");
		UTCHKEX(false == rHandler.GetVisible(), L"CommandHandlerBase::GetVisible should return false.");
		UTCHKEX(dwFlags == rHandler.GetFlags(), L"CommandHandlerBase::GetFlags returned an unexpected value.");
	}

	void CheckSetters(VSL::CommandHandlerBase<HandlerTestProperties>& rHandler)
	{
		// Enable the Checked property.
		rHandler.SetChecked(true);
		UTCHKEX(rHandler.GetChecked(), L"CommandHandlerBase::GetChecked should return true.");
		UTCHKEX(rHandler.GetEnabled(), L"CommandHandlerBase::GetEnabled should return true.");
		UTCHKEX(rHandler.GetSupported(), L"CommandHandlerBase::GetSupported should return true.");
		UTCHKEX(rHandler.GetVisible(), L"CommandHandlerBase::GetVisible should return true.");
		// Enable the Visible property (it was setted before, so nothing should change).
		rHandler.SetVisible(true);
		UTCHKEX(rHandler.GetChecked(), L"CommandHandlerBase::GetChecked should return true.");
		UTCHKEX(rHandler.GetEnabled(), L"CommandHandlerBase::GetEnabled should return true.");
		UTCHKEX(rHandler.GetSupported(), L"CommandHandlerBase::GetSupported should return true.");
		UTCHKEX(rHandler.GetVisible(), L"CommandHandlerBase::GetVisible should return true.");
		// Disable the Visible property.
		rHandler.SetVisible(false);
		UTCHKEX(rHandler.GetChecked(), L"CommandHandlerBase::GetChecked should return true.");
		UTCHKEX(rHandler.GetEnabled(), L"CommandHandlerBase::GetEnabled should return true.");
		UTCHKEX(rHandler.GetSupported(), L"CommandHandlerBase::GetSupported should return true.");
		UTCHKEX(false == rHandler.GetVisible(), L"CommandHandlerBase::GetVisible should return false.");
		// Disable the Enable property.
		rHandler.SetEnabled(false);
		UTCHKEX(rHandler.GetChecked(), L"CommandHandlerBase::GetChecked should return true.");
		UTCHKEX(false == rHandler.GetEnabled(), L"CommandHandlerBase::GetEnabled should return false.");
		UTCHKEX(rHandler.GetSupported(), L"CommandHandlerBase::GetSupported should return true.");
		UTCHKEX(false == rHandler.GetVisible(), L"CommandHandlerBase::GetVisible should return false.");
		// Disable the Supported property.
		rHandler.SetSupported(false);
		UTCHKEX(rHandler.GetChecked(), L"CommandHandlerBase::GetChecked should return true.");
		UTCHKEX(false == rHandler.GetEnabled(), L"CommandHandlerBase::GetEnabled should return false.");
		UTCHKEX(false == rHandler.GetSupported(), L"CommandHandlerBase::GetSupported should return false.");
		UTCHKEX(false == rHandler.GetVisible(), L"CommandHandlerBase::GetVisible should return false.");
	}

	void CheckText(VSL::CommandHandlerBase<HandlerTestProperties>& rHandler, const wchar_t* const szText)
	{
		const VSL::CommandHandlerBase<HandlerTestProperties>& crHandler = rHandler;
		UTCHKEX(0 == wcscmp(szText, crHandler.GetText()), L"The text was not set correctly by the constructor.");
		const wchar_t szNewText[] = L"New Text";
		rHandler.GetText() = szNewText;
		UTCHKEX(0 == wcscmp(szNewText, crHandler.GetText()), L"The text was not set correctly by the constructor.");
	}

public:
	typedef VSL::CommandHandlerBase<HandlerTestProperties> CommandHandler;

	HandlerTestProperties(_In_opt_ const char* const szTestName);

	void QueryStatusDefault(const CommandHandler& pSender, OLECMD* oleCmd, OLECMDTEXT* oleText)
	{
		CommandHandler::QueryStatusDefault(pSender, oleCmd, oleText);
	}
};

class HandlerTestStandardMethods :
	public VSL::UnitTestBase
{
public:
	typedef VSL::CommandHandlerBase<HandlerTestStandardMethods> CommandHandler;

	HandlerTestStandardMethods(_In_opt_ const char* const szTestName);

	void QueryStatusDefault(const CommandHandler& pSender, OLECMD* oleCmd, OLECMDTEXT* oleText)
	{
		CommandHandler::QueryStatusDefault(pSender, oleCmd, oleText);
	}
};

class HandlerTestCallbacks :
	public VSL::UnitTestBase
{
public:
	HandlerTestCallbacks(_In_opt_ const char* const szTestName);
	typedef VSL::CommandHandlerBase<HandlerTestCallbacks> CommandHandler;

	void QueryStatusDefault(const CommandHandler& pSender, OLECMD* oleCmd, OLECMDTEXT* oleText)
	{
		CommandHandler::QueryStatusDefault(pSender, oleCmd, oleText);
	}
private:
	bool fCallbackCalled;

	void Exec(CommandHandler* caller, DWORD /*flags*/, VARIANT* /*pvIn*/, VARIANT* /*pvOut*/) 
	{
		UTCHKEX(NULL != caller, L"Exec callback called with NULL caller.");
		fCallbackCalled = true;
	}
	void QueryStatus(const CommandHandler& /*caller*/, OLECMD* /*oleCmd*/, OLECMDTEXT* /*oleText*/)
	{
		fCallbackCalled = true; 
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\UnitTest\CommandTarget\CommandTarget.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#include <VSLUnitTest.h>
#include <VSLShortNameDefines.h>

class TargetTest :
	public VSL::UnitTestBase
{
public:
	TargetTest(_In_opt_ const char* const szTestName);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\UnitTest\CommandTarget\CommandId.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#include <VSLUnitTest.h>
#include <VSLCommandTarget.h>
#include <VSLShortNameDefines.h>

class CommandIdTest :
	public VSL::UnitTestBase
{
private:
	static const GUID	s_guidTest;
	static const DWORD	s_dwTestId;

	void CheckCommandID(const VSL::CommandId& rCommandId)
	{
		// Check that GetGuid returns the expected value.
		UTCHKEX(s_guidTest == rCommandId.GetGuid(), L"CommandId::GetGuid() returned an unexpected value.");
		// Check that GetId() returns the expected value.
		UTCHKEX(s_dwTestId == rCommandId.GetId(), L"CommandId::GetId() returned an unexpected value.");
		UTCHKEX(0xe90ff436 == static_cast<ULONG_PTR>(rCommandId), L"CommandId::operator ULONG_PTR() didn't hash correctly.");
	}
public:
	CommandIdTest(_In_opt_ const char* const szTestName);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\UnitTest\CommandTarget\CommandTarget.cpp ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#include "StdAfx.h"

#include "CommandTarget.h"
#include <VSLCommandTarget.h>
#include <VSLMockSystemInterfaces.h>

static const GUID guidCmdSet1 = {0xbe604d71, 0x9569, 0x4abc, {0xba, 0x6b, 0xab, 0x68, 0xc7, 0x65, 0x32, 0xb5}};
static const GUID guidCmdSet2 = {0x11770c63, 0xc2f5, 0x4149, {0x99, 0x0b, 0xd6, 0x99, 0x74, 0x06, 0x07, 0xb3}};

class TestEmptyMap :
	public VSL::IOleCommandTargetImpl<TestEmptyMap>
{
public:
	TestEmptyMap() {};

	VSL_DEFINE_IUNKNOWN_NOTIMPL

	VSL_BEGIN_COMMAND_MAP()
	VSL_END_VSCOMMAND_MAP()
};

class DefaultCommand :
	public VSL::IOleCommandTargetImpl<DefaultCommand>
{
public:
	DefaultCommand() {};

	VSL_DEFINE_IUNKNOWN_NOTIMPL

	VSL_BEGIN_COMMAND_MAP()
		VSL_COMMAND_MAP_ENTRY(guidCmdSet1, 1, NULL, NULL)
	VSL_END_VSCOMMAND_MAP()
};

class DerivedCommand :
	public VSL::IOleCommandTargetImpl<DerivedCommand>
{
private:
	class MyCommand : public CommandHandler
	{
	private:
		CStringW m_str;
	public:
		MyCommand(VSL::CommandId id, const wchar_t* text) :
			CommandHandler(id, NULL, NULL, OLECMDF_SUPPORTED | OLECMDF_ENABLED, text),
			m_str(s_strDerivedText)
		{
		}

		const CStringW& GetText() const { return m_str; }
	};

public:
	static const wchar_t* s_strBaseText;
	static const wchar_t* s_strDerivedText;

	DerivedCommand() {};

	VSL_DEFINE_IUNKNOWN_NOTIMPL

	VSL_BEGIN_COMMAND_MAP()
		VSL_COMMAND_MAP_CLASS_ENTRY(MyCommand, (VSL::CommandId(guidCmdSet1, 1), s_strBaseText))
	VSL_END_VSCOMMAND_MAP()
};

const wchar_t* DerivedCommand::s_strBaseText = L"Base string";
const wchar_t* DerivedCommand::s_strDerivedText = L"Derived string";


TargetTest::TargetTest(const char* const szTestName) :
	VSL::UnitTestBase(szTestName)
{
	// Create a command target without any command.
	TestEmptyMap testEmptyMap;
	IOleCommandTarget* target = static_cast<IOleCommandTarget*>(&testEmptyMap);

	// Check that Exec returns E_POINTER if the pointer to the GUID is null.
	UTCHKEX(E_POINTER==target->Exec(NULL, 0, 0, NULL, NULL), L"Unexpected value returned by Exec.");
	// Check that Exec returns NOTSUPPORTED for any command.
	UTCHKEX(OLECMDERR_E_NOTSUPPORTED==target->Exec(&guidCmdSet1, 1, 0, NULL, NULL), L"Unexpected value returned by Exec.");

	// Check that QueryStatus can handle NULL arguments.
	UTCHKEX(E_POINTER==target->QueryStatus(NULL, 0, NULL, NULL), L"Unexpected value returned by QueryStatus.");
	UTCHKEX(E_POINTER==target->QueryStatus(&guidCmdSet1, 1, NULL, NULL), L"Unexpected value returned by QueryStatus.");
	OLECMD oleCmd;
	UTCHKEX(E_INVALIDARG==target->QueryStatus(&guidCmdSet1, 0, &oleCmd, NULL), L"Unexpected value returned by QueryStatus.");
	UTCHKEX(E_INVALIDARG==target->QueryStatus(&guidCmdSet1, 3, &oleCmd, NULL), L"Unexpected value returned by QueryStatus.");
	UTCHKEX(OLECMDERR_E_NOTSUPPORTED==target->QueryStatus(&guidCmdSet1, 1, &oleCmd, NULL), L"Unexpected value returned by QueryStatus.");

	// Create a command target with default commands
	DefaultCommand defaultCommand;
	target = static_cast<IOleCommandTarget*>(&defaultCommand);

	UTCHK(OLECMDERR_E_NOTSUPPORTED==target->Exec(&guidCmdSet1, 10, 0, NULL, NULL));
	UTCHK(OLECMDERR_E_NOTSUPPORTED==target->Exec(&guidCmdSet2, 1, 0, NULL, NULL));
	UTCHK(S_OK==target->Exec(&guidCmdSet1, 1, 0, NULL, NULL));

	oleCmd.cmdf = 0;
	oleCmd.cmdID = 10;
	UTCHK(OLECMDERR_E_NOTSUPPORTED==target->QueryStatus(&guidCmdSet1, 1, &oleCmd, NULL));
	oleCmd.cmdID = 1;
	UTCHK(OLECMDERR_E_NOTSUPPORTED==target->QueryStatus(&guidCmdSet2, 1, &oleCmd, NULL));
	UTCHK(S_OK==target->QueryStatus(&guidCmdSet1, 1, &oleCmd, NULL));
	UTCHK((OLECMDF_SUPPORTED|OLECMDF_ENABLED) == oleCmd.cmdf);

	// Check that query status correctly retrieves the text passed in to custom constructor on the map.
	DerivedCommand derivedCommand;
	target = static_cast<IOleCommandTarget*>(&derivedCommand);
	const size_t stringSize = 20;
	const size_t bufferSize = sizeof(OLECMDTEXT)+ ((stringSize-1)*sizeof(wchar_t));
	BYTE buffer[bufferSize];
	OLECMDTEXT* pOleText = (OLECMDTEXT*)buffer;
	pOleText->cmdtextf = OLECMDTEXTF_NAME;
	pOleText->cwActual = 0;
	pOleText->cwBuf = stringSize;
	oleCmd.cmdID = 10;
	oleCmd.cmdID = 1;
	UTCHK(S_OK==target->QueryStatus(&guidCmdSet1, 1, &oleCmd, pOleText));
	UTCHK(0 == wcscmp(DerivedCommand::s_strBaseText, pOleText->rgwz));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\UnitTest\CommandTarget\main.cpp ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#include "StdAfx.h"

#include "VSLUnitTest.h"

#include "CommandId.h"
#include "CommandHandler.h"
#include "CommandTarget.h"

int _cdecl wmain()
{
	VSL_UTRUN(CommandIdTest);
	VSL_UTRUN(HandlerTestProperties);
	VSL_UTRUN(HandlerTestStandardMethods);
	VSL_UTRUN(HandlerTestCallbacks);
	VSL_UTRUN(TargetTest);
	return VSL::FailureCounter::Get();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\UnitTest\ErrorAndExceptionHandling\stdafx.cpp ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\UnitTest\CommandTarget\stdafx.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#pragma once

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#define NOMINMAX

#include <atlbase.h>
#include <atlcom.h>
#include <atlstr.h>
#include <limits>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\UnitTest\MockInterfaces\stdafx.cpp ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\UnitTest\ErrorAndExceptionHandling\stdafx.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#pragma once

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <atlbase.h>
#include <atlcom.h>
#include <atlstr.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\UnitTest\CommandTarget\stdafx.cpp ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\UnitTest\ErrorAndExceptionHandling\ErrorAndExceptionHandling.cpp ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#include "stdafx.h"

#define VSL_ASSERT _ASSERTE
#define VSL_ASSERTEX(exp, szMsg) _ASSERT_BASE(exp, szMsg)
#define VSL_TRACE ATLTRACE

#include "VSLUnitTest.h"
#include "VSLShortNameDefines.h"
#include "VSLExceptions.h"
#include "VSLExceptionHandlers.h"
#include "VSLErrorHandlers.h"

using namespace VSL;

static const TCHAR g_szExpression[] = L"test exp";
static const TCHAR g_szFilename[] = L"test.cpp";
static const TCHAR g_iLineNumber = 1;
static const TCHAR g_szExtra[] = L"test message";
static const HANDLE g_hNotNull = reinterpret_cast<HANDLE>(1);

/*******************************************************************************
Validate VSLExceptions.h
*******************************************************************************/

class ExceptionBaseHasVirtualDestructorTestHelper :
	public VirtualDestructorUnitTestHelper<ExceptionBase>
{
public:
	virtual ~ExceptionBaseHasVirtualDestructorTestHelper() {}

	virtual HRESULT GetHRESULT() const
	{
		return HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
	}
};

class ExceptionBaseBaseTest :
	public UnitTestBase
{
protected:
	void TestExceptionBase(const ExceptionBase& toTest)
	{
		UTCHK(toTest.GetHRESULT() == HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY));
		UTCHK(static_cast<HRESULT>(toTest) == HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY));
		UTCHK(toTest.GetWin32Error() == ERROR_OUTOFMEMORY);
		UTCHK(static_cast<DWORD>(toTest) == ERROR_OUTOFMEMORY);
		// TODO - test ReportError
	}

public:
	ExceptionBaseBaseTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
	}
};

class ExceptionBaseTest :
	public ExceptionBaseBaseTest
{
public:
	ExceptionBaseTest(_In_opt_ const char* const szTestName):
		ExceptionBaseBaseTest(szTestName)
	{
		ExceptionBaseHasVirtualDestructorTestHelper testObj;
		TestExceptionBase(testObj);
	}
};

class unknown_exception : public std::exception
{
public:
	unknown_exception(const char *_Message = "bad exception")
		_THROW0()
		: exception(_Message)
		{	// construct from message string
		}
	virtual ~unknown_exception() _THROW0()
		{	// destroy the object
		}
};

template <class Exception_T, ExceptionStd::TypeID customTypeID, HRESULT hrExpected>
class ExceptionStdConstructorTest :
	UnitTestBase
{
public:
	void ValidateObject(const ExceptionStd& rToValidate, const TCHAR* szTestStep)
	{
		UTCHKEX(rToValidate.GetStdExceptionTypeID() == customTypeID, szTestStep);
		UTCHKEX(rToValidate.GetHRESULT() == hrExpected, szTestStep);
	}

	ExceptionStdConstructorTest(const char* const szTestName):
		UnitTestBase(szTestName)
	{
		Exception_T parm1("test message");

		ExceptionStd testObj(parm1);
		ValidateObject(testObj, _T("Test the \"const std::exception&\" constructor"));

		ExceptionStd testCopyObj = testObj;
		ValidateObject(testCopyObj, _T("Test the copy constructor"));
	}
};

#define ADD_CEXCEPTIONSTD_TEST(exception, typeID, hr) UnitTestList<UnitTestWrapper<ExceptionStdConstructorTest<exception, typeID, hr> >,

typedef 
	ADD_CEXCEPTIONSTD_TEST(unknown_exception, ExceptionStd::UNKNOWN, DISP_E_EXCEPTION)
	ADD_CEXCEPTIONSTD_TEST(std::exception, ExceptionStd::EXCEPTION, DISP_E_EXCEPTION)
	ADD_CEXCEPTIONSTD_TEST(std::bad_exception, ExceptionStd::BAD_EXCEPTION, DISP_E_EXCEPTION)
	ADD_CEXCEPTIONSTD_TEST(std::bad_alloc, ExceptionStd::BAD_ALLOC, E_OUTOFMEMORY)
	ADD_CEXCEPTIONSTD_TEST(std::bad_cast, ExceptionStd::BAD_CAST, DISP_E_EXCEPTION)
	ADD_CEXCEPTIONSTD_TEST(std::bad_typeid, ExceptionStd::BAD_TYPEID, DISP_E_EXCEPTION)
	ADD_CEXCEPTIONSTD_TEST(std::__non_rtti_object, ExceptionStd::__NON_RTTI_OBJECT, DISP_E_EXCEPTION)
	ADD_CEXCEPTIONSTD_TEST(std::logic_error, ExceptionStd::LOGIC_ERROR, DISP_E_EXCEPTION)
	ADD_CEXCEPTIONSTD_TEST(std::domain_error, ExceptionStd::DOMAIN_ERROR, DISP_E_EXCEPTION)
	ADD_CEXCEPTIONSTD_TEST(std::invalid_argument, ExceptionStd::INVALID_ARGUMENT, DISP_E_EXCEPTION)
	ADD_CEXCEPTIONSTD_TEST(std::length_error, ExceptionStd::LENGTH_ERROR, DISP_E_EXCEPTION)
	ADD_CEXCEPTIONSTD_TEST(std::out_of_range, ExceptionStd::OUT_OF_RANGE, DISP_E_EXCEPTION)
	ADD_CEXCEPTIONSTD_TEST(std::runtime_error, ExceptionStd::RUNTIME_ERROR, DISP_E_EXCEPTION)
	ADD_CEXCEPTIONSTD_TEST(std::range_error, ExceptionStd::RANGE_ERROR, DISP_E_EXCEPTION)
	ADD_CEXCEPTIONSTD_TEST(std::overflow_error, ExceptionStd::OVERFLOW_ERROR, DISP_E_EXCEPTION)
	ADD_CEXCEPTIONSTD_TEST(std::underflow_error, ExceptionStd::UNDERFLOW_ERROR, DISP_E_EXCEPTION)
	ADD_CEXCEPTIONSTD_TEST(std::ios_base::failure, ExceptionStd::IOS_BASE_FAILURE, DISP_E_EXCEPTION)
	UnitTestListTerminator> > > > > > > > > > > > > > > > >
		ExceptionStdUnitTestList;

// This will fail to compile if the number of entries above does not match
// the number of enums
_STATIC_ASSERT(ExceptionStdUnitTestList::NumTests == ExceptionStd::NUM_EXCEPTION_TYPES);

#if 0 // Add back if corresponding class is added back
class ExtraTypeContainerStringTest :
	public UnitTestBase
{
public:
	ExtraTypeContainerStringTest(const char* const szTestName):
		UnitTestBase(szTestName)
	{
		ExtraDataTypeContainerString::Type szDefault = ExtraDataTypeContainerString::DefaultValue();
		UTCHKEX(szDefault == NULL, NULL);
	}
};
#endif

// TODO - test ErrorMessageFromResource and ExtraDataTypeContainerResourceString

class ErrorVirtualDestructorTestHelper :
	public VirtualDestructorUnitTestHelperBase,
	public ExceptionExImpl<HRESULT>
{
public:
	typedef ExceptionExImpl<HRESULT> BaseClass;

	ErrorVirtualDestructorTestHelper():
		VirtualDestructorUnitTestHelperBase(),
		BaseClass(
			HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY),
			g_szExpression,
			g_szFilename,
			g_iLineNumber)
	{
		++(GetRefcount());
	}

	ErrorVirtualDestructorTestHelper(const ErrorVirtualDestructorTestHelper& rToCopy):
		VirtualDestructorUnitTestHelperBase(rToCopy),
		BaseClass(rToCopy)
	{
	}

	virtual ~ErrorVirtualDestructorTestHelper()
	{
		--(GetRefcount());
	}

	virtual HRESULT GetHRESULT() const
	{
		return m_expValue;
	}
};

class CErrorBaseTest :
	public ExceptionBaseBaseTest
{
protected:

	template<class ExceptionExImplSpec_T>
	void TestCErrorObject(const ExceptionExImplSpec_T& rToTest)
	{
		TestExceptionBase(rToTest);
		UTCHK(0 == ::memcmp(rToTest.GetExpressionString(), g_szExpression, ARRAYSIZE(g_szExpression)));
		UTCHK(0 == ::memcmp(rToTest.GetExpressionStringTyped(), g_szExpression, ARRAYSIZE(g_szExpression)));
		UTCHK(0 == ::memcmp(rToTest.GetSourceFilenamePath(), g_szFilename, ARRAYSIZE(g_szFilename)));
		UTCHK(0 == ::memcmp(rToTest.GetSourceFilenamePathTyped(), g_szFilename, ARRAYSIZE(g_szFilename)));
		UTCHK(rToTest.GetSourceLinenumber() == g_iLineNumber);
		UTCHK(CString(rToTest.GetErrorString()) == CString(ExceptionExImplSpec_T::ExtraDataTypeContainer::DefaultString()));
		UTCHK(rToTest.GetExtraData() == ExceptionExImplSpec_T::ExtraDataTypeContainer::DefaultValue());
	}

	template<class CErrorDerived_T>
	void TestCError()
	{
		CErrorDerived_T testObj;
		TestCErrorObject<CErrorDerived_T::BaseClass>(testObj);
		CErrorDerived_T testObjCopy(testObj);
		TestCErrorObject<CErrorDerived_T::BaseClass>(testObjCopy);
	}

public:
	CErrorBaseTest(_In_opt_ const char* const szTestName):
		ExceptionBaseBaseTest(szTestName)
	{
	}
};

class ExceptionExImplTest :
	public CErrorBaseTest
{
public:
	ExceptionExImplTest(_In_opt_ const char* const szTestName):
		CErrorBaseTest(szTestName)
	{
		TestCError<ErrorVirtualDestructorTestHelper>();
	}
};

class ExceptionHRESULTVirtualDestructorTestHelper :
	public VirtualDestructorUnitTestHelperBase,
	public ExceptionHRESULT<>
{
public:
	typedef ExceptionHRESULT<> BaseClass_T_t;

	ExceptionHRESULTVirtualDestructorTestHelper():
		BaseClass_T_t(
			HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY),
			g_szExpression,
			g_szFilename,
			g_iLineNumber)
	{
		++(GetRefcount());
	}

	virtual ~ExceptionHRESULTVirtualDestructorTestHelper()
	{
		--(GetRefcount());
	}
};

class ExceptionHRESULTTest :
	public ExceptionExImplTest
{
public:
	ExceptionHRESULTTest(_In_opt_ const char* const szTestName):
		ExceptionExImplTest(szTestName)
	{
		TestCError<ExceptionHRESULTVirtualDestructorTestHelper>();
	}
};

class ExceptionWin32VirtualDestructorTestHelper :
	public VirtualDestructorUnitTestHelperBase,
	public ExceptionWin32<>
{
public:
	typedef ExceptionWin32<> BaseClass_T_t;

	ExceptionWin32VirtualDestructorTestHelper():
		BaseClass_T_t(
			ERROR_OUTOFMEMORY,
			g_szExpression,
			g_szFilename,
			g_iLineNumber)
	{
		++(GetRefcount());
	}

	virtual ~ExceptionWin32VirtualDestructorTestHelper()
	{
		--(GetRefcount());
	}
};

class ExceptionWin32Test :
	public ExceptionExImplTest
{
public:
	ExceptionWin32Test(_In_opt_ const char* const szTestName):
		ExceptionExImplTest(szTestName)
	{
		TestCError<ExceptionWin32VirtualDestructorTestHelper>();
	}
};

/*******************************************************************************
Validate VSLExceptionHandlers.h
*******************************************************************************/

class VSL_STDMETHODTest :
	public UnitTestBase
{
protected:

	HRESULT Test_STDMETHOD_EX()
	{
		VSL_STDMETHODTRY_EX(E_FAIL)
		{
			UTCHK(VSL_GET_STDMETHOD_HRESULT() == E_FAIL);
			VSL_SET_STDMETHOD_HRESULT(S_OK);
			UTCHK(VSL_GET_STDMETHOD_HRESULT() == S_OK);
			throw 0; // Doesn't matter what is thrown so long as it isn't derived from VSL::ExceptionBase or std::exception
		}
		VSL_STDMETHODCATCH_EX(VSL_STDMETHOD_ON_CATCH_CEXCEPTION, VSL_STDMETHOD_ON_CATCH_STDEXCEPTION, VSL_STDMETHOD_ON_CATCH_ALL)
		return VSL_GET_STDMETHOD_HRESULT();
	}

	HRESULT Test_STDMETHOD()
	{
		VSL_STDMETHODTRY
		{
			UTCHK(VSL_GET_STDMETHOD_HRESULT() == S_OK);
			VSL_SET_STDMETHOD_HRESULT(E_FAIL);
			UTCHK(VSL_GET_STDMETHOD_HRESULT() == E_FAIL);
			throw 0; // Doesn't matter what is thrown so long as it isn't derived from VSL::ExceptionBase or std::exception
		}
		VSL_STDMETHODCATCH()
		return VSL_GET_STDMETHOD_HRESULT();
	}

	HRESULT Test_STDMETHODCATCH_CErrorHRESULT()
	{
		VSL_STDMETHODTRY
		{
			throw ExceptionHRESULT<>(E_FAIL, g_szExpression, g_szFilename, g_iLineNumber);
		}
		VSL_STDMETHODCATCH()
		return VSL_GET_STDMETHOD_HRESULT();
	}

	HRESULT Test_STDMETHODCATCH_CErrorWin32Code()
	{
		VSL_STDMETHODTRY
		{
			throw ExceptionWin32<>(ERROR_OUTOFMEMORY, g_szExpression, g_szFilename, g_iLineNumber);
		}
		VSL_STDMETHODCATCH()
		return VSL_GET_STDMETHOD_HRESULT();
	}

	HRESULT Test_STDMETHODCATCH_ExceptionStd()
	{
		VSL_STDMETHODTRY
		{
			throw ExceptionStd(std::bad_alloc());
		}
		VSL_STDMETHODCATCH()
		return VSL_GET_STDMETHOD_HRESULT();
	}

	HRESULT Test_STDMETHODCATCH_CAtlException()
	{
		VSL_STDMETHODTRY
		{
			throw CAtlException(E_UNEXPECTED);
		}
		VSL_STDMETHODCATCH()
		return VSL_GET_STDMETHOD_HRESULT();
	}

public:
	VSL_STDMETHODTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
		UTCHK(Test_STDMETHOD_EX() == E_UNEXPECTED);
		UTCHK(Test_STDMETHOD() == E_UNEXPECTED);
		UTCHK(Test_STDMETHODCATCH_CErrorHRESULT() == E_FAIL);
		UTCHK(Test_STDMETHODCATCH_CErrorWin32Code() == HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY));
		UTCHK(Test_STDMETHODCATCH_ExceptionStd() == E_OUTOFMEMORY);
		UTCHK(Test_STDMETHODCATCH_CAtlException() == E_UNEXPECTED);
	}
};

/*******************************************************************************
Validate VSLErrorHandlers.h
*******************************************************************************/

#include "VSLErrorHandlersBase.h"

class EvaluatorsTest :
	public UnitTestBase
{
protected:
	template <class EVALUATOR_T, typename EVALUATOR_T::ExpressionType EXPVALUE_T>
	void TestEvaluator()
	{
		EVALUATOR_T::ExpressionType testExp = EXPVALUE_T;
		UTCHK(EVALUATOR_T::Evaluate(testExp));
	}
public:
	EvaluatorsTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
		TestEvaluator<BooleanEvaluator, false>();
		TestEvaluator<BOOLEvaluator, FALSE>();
		TestEvaluator<DWORDIsZeroEvaluator, 0>();
		TestEvaluator<HANDLEIsNullEvaluator, NULL>();
		TestEvaluator<HANDLEIsInvalidEvaluator, INVALID_HANDLE_VALUE>();
		TestEvaluator<HRESULTEvaluator, E_FAIL>();
		TestEvaluator<Win32Evaluator, ERROR_OUTOFMEMORY>();
	}
};

class OverridesTest :
	public UnitTestBase
{
public:
	OverridesTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
		typedef DefaultOverride<HRESULT> DefaultExpressionValueOverride;
		DefaultExpressionValueOverride::OverrideType hr = 
			DefaultExpressionValueOverride::Override(E_FAIL);
		UTCHK(hr == E_FAIL);

		typedef ConstantOverride<HRESULT, bool, false> ConstantExpressionValueOverride;
		ConstantExpressionValueOverride::OverrideType b = 
			ConstantExpressionValueOverride::Override(E_FAIL);
		UTCHK(b == false);

		typedef GetLastErrorOverride<HRESULT> GLEExpressionValueOverride;
		::SetLastError(ERROR_OUTOFMEMORY);
		GLEExpressionValueOverride::OverrideType dw = 
			GLEExpressionValueOverride::Override(E_FAIL);
		UTCHK(dw == ERROR_OUTOFMEMORY);

		typedef DefaultHRESULTOverride x;
		typedef DefaultWin32Override y;

		UTCHK(VSL_OVERRIDE_HRESULT_CONSTANT(bool, E_FAIL)::Override(true) == E_FAIL);
	}
};

class ProcessorsTest :
	public UnitTestBase
{
protected:

	HRESULT Test_HRESULTProcessor()
	{
		VSL_STDMETHODTRY
		{
			HRESULTProcessor::ProcessError(VSL::ExceptionHRESULT<>(E_FAIL, g_szExpression, g_szFilename, g_iLineNumber));
		}
		VSL_STDMETHODCATCH()
		return VSL_GET_STDMETHOD_HRESULT();
	}

	HRESULT Test_Win32Processor()
	{
		VSL_STDMETHODTRY
		{
			Win32Processor::ProcessError(VSL::ExceptionWin32<>(ERROR_OUTOFMEMORY, g_szExpression, g_szFilename, g_iLineNumber));
		}
		VSL_STDMETHODCATCH()
		return VSL_GET_STDMETHOD_HRESULT();
	}

public:
	ProcessorsTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
		UTCHK(Test_HRESULTProcessor() == E_FAIL);
		UTCHK(Test_Win32Processor() == HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY));
	}
};

template <class TRAITS_T>
void CompileTraits()
{
	typedef TRAITS_T::ExpressionEvaluator ExpressionEvaluator;
	typedef TRAITS_T::ExpressionType ExpressionType;
	typedef TRAITS_T::ExpressionValueOverride ExpressionValueOverride;
	typedef TRAITS_T::Exception Exception;
	typedef TRAITS_T::ExtraDataType ExtraDataType;
	typedef TRAITS_T::ExtraDataTypeContainer ExtraDataTypeContainer;
	typedef TRAITS_T::StringType StringType;
	typedef TRAITS_T::ErrorProcessor ErrorProcessor;
}

class CreateAndProcessErrorTest :
	public UnitTestBase
{
protected:
	void Test_VSL_CREATE_ERROR_EX()
	{
		bool bCaught = false;
		try
		{
			VSL_CREATE_ERROR_EX(HRESULTTraits, E_FAIL, g_szExtra);
		}
		catch(const HRESULTTraits::Exception& rException)
		{
			bCaught = true;
			UTCHK(rException.GetHRESULT() == E_FAIL);
			if(UTCHK(rException.GetExtraData() != NULL))
			{
				UTCHKEX(0 == ::memcmp(rException.GetExtraData(), g_szExtra, ARRAYSIZE(g_szExtra)), NULL);
			}
		}
		UTCHKEX(bCaught, _T("Exception not caught!"));
	}

	void Test_CREATE_ERROR()
	{
		bool bCaught = false;
		try
		{
			VSL_CREATE_ERROR(HRESULTTraits, E_FAIL);
		}
		catch(const HRESULTTraits::Exception& rException)
		{
			bCaught = true;
			UTCHKEX(rException.GetHRESULT() == E_FAIL, NULL);
			UTCHKEX(rException.GetExtraData() == NULL, NULL);
		}
		UTCHKEX(bCaught, _T("Exception not caught!"));
	}

public:
	CreateAndProcessErrorTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
		Test_VSL_CREATE_ERROR_EX();
		Test_CREATE_ERROR();
	}
};

class FailOnErrorTest :
	public UnitTestBase
{
protected:
	void Test_CHECKEXP_EX()
	{
		bool bCaught = false;
		try
		{
			VSL_CHECKEXPRESSION_EX(HRESULTTraits, S_OK, g_szExtra); // this shouldn't throw
			VSL_CHECKEXPRESSION_EX(HRESULTTraits, E_FAIL, g_szExtra);
		}
		catch(const HRESULTTraits::Exception& rException)
		{
			bCaught = true;
			UTCHK(rException.GetHRESULT() == E_FAIL);
			if(UTCHK(rException.GetExtraData() != NULL))
			{
				UTCHK(0 == ::memcmp(rException.GetExtraData(), g_szExtra, ARRAYSIZE(g_szExtra)));
			}
		}
		UTCHKEX(bCaught, _T("Exception not caught!"));
	}

	void Test_CHECKEXP()
	{
		bool bCaught = false;
		try
		{
			VSL_CHECKEXPRESSION(HRESULTTraits, S_OK); // this shouldn't throw
			VSL_CHECKEXPRESSION(HRESULTTraits, E_FAIL);
		}
		catch(const HRESULTTraits::Exception& rException)
		{
			bCaught = true;
			UTCHK(rException.GetHRESULT() == E_FAIL);
			UTCHK(rException.GetExtraData() == NULL);
		}
		UTCHKEX(bCaught, _T("Exception not caught!"));
	}

public:
	FailOnErrorTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
		Test_CHECKEXP_EX();
		Test_CHECKEXP();
	}
};

/*******************************************************************************
Validate VSLBOOLErrorHandlers.h
*******************************************************************************/

class VSL_CHECKBOOLEANTest :
	public UnitTestBase
{
protected:

	HRESULT Test_VSL_CHECKBOOLEAN_EX()
	{
		VSL_STDMETHODTRY
		{
			CHKEX(true, S_OK, g_szExtra);  // this shouldn't throw
			CHKEX(false, E_FAIL, g_szExtra);
		}
		VSL_STDMETHODCATCH()
		return VSL_GET_STDMETHOD_HRESULT();
	}

	HRESULT Test_VSL_CHECKBOOLEAN()
	{
		VSL_STDMETHODTRY
		{
			CHK(true, S_OK);  // this shouldn't throw
			CHK(false, E_FAIL);
		}
		VSL_STDMETHODCATCH()
		return VSL_GET_STDMETHOD_HRESULT();
	}

public:
	VSL_CHECKBOOLEANTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
		typedef VSL_CHECKBOOLEAN_TRAITS(E_FAIL) VSL_CHECKBOOLEAN_TRAITS_t;
		UTCHK(Test_VSL_CHECKBOOLEAN_EX() == E_FAIL);
		UTCHK(Test_VSL_CHECKBOOLEAN() == E_FAIL);
	}
};

class VSL_CHECKBOOLTest :
	public UnitTestBase
{
protected:

	HRESULT Test_VSL_CHECKBOOL_EX()
	{
		VSL_STDMETHODTRY
		{
			CHKBOOLEX(TRUE, S_OK, g_szExtra);  // this shouldn't throw
			CHKBOOLEX(FALSE, E_FAIL, g_szExtra);
		}
		VSL_STDMETHODCATCH()
		return VSL_GET_STDMETHOD_HRESULT();
	}

	HRESULT Test_VSL_CHECKBOOL()
	{
		VSL_STDMETHODTRY
		{
			CHKBOOL(TRUE, S_OK);  // this shouldn't throw
			CHKBOOL(FALSE, E_FAIL);
		}
		VSL_STDMETHODCATCH()
		return VSL_GET_STDMETHOD_HRESULT();
	}

public:
	VSL_CHECKBOOLTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
		typedef VSL_CHECKBOOL_TRAITS(E_FAIL) VSL_CHECKBOOL_TRAITS_t;
		UTCHK(Test_VSL_CHECKBOOL_EX() == E_FAIL);
		UTCHK(Test_VSL_CHECKBOOL() == E_FAIL);
	}
};

class VSL_CHECKBOOL_GLETest :
	public UnitTestBase
{
protected:

	HRESULT Test_VSL_CHECKBOOL_GLE_EX()
	{
		VSL_STDMETHODTRY
		{
			::SetLastError(ERROR_SUCCESS);
			CHKBOOLGLEEX(TRUE, g_szExtra);  // this shouldn't throw
			::SetLastError(ERROR_OUTOFMEMORY);
			CHKBOOLGLEEX(FALSE, g_szExtra);
		}
		VSL_STDMETHODCATCH()
		return VSL_GET_STDMETHOD_HRESULT();
	}

	HRESULT Test_VSL_CHECKBOOL_GLE()
	{
		VSL_STDMETHODTRY
		{
			::SetLastError(ERROR_SUCCESS);
			CHKBOOLGLE(TRUE);  // this shouldn't throw
			::SetLastError(ERROR_OUTOFMEMORY);
			CHKBOOLGLE(FALSE);
		}
		VSL_STDMETHODCATCH()
		return VSL_GET_STDMETHOD_HRESULT();
	}

public:
	VSL_CHECKBOOL_GLETest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
		typedef VSL_CHECKBOOL_GLE_TRAITS VSL_CHECKBOOL_GLE_TRAITS_t;
		UTCHK(Test_VSL_CHECKBOOL_GLE_EX() == HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY));
		UTCHK(Test_VSL_CHECKBOOL_GLE() == HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY));
	}
};

/*******************************************************************************
Validate VSLHANDLEErrorHandlers.h
*******************************************************************************/

class VSL_CHECKHANDLE_GLETest :
	public UnitTestBase
{
protected:

	HRESULT Test_VSL_CHECKHANDLE_GLE_EX()
	{
		VSL_STDMETHODTRY
		{
			::SetLastError(ERROR_SUCCESS);
			CHKHANDLEGLEEX(g_hNotNull, g_szExtra);  // this shouldn't throw
			::SetLastError(ERROR_OUTOFMEMORY);
			CHKHANDLEGLEEX(NULL, g_szExtra);
		}
		VSL_STDMETHODCATCH()
		return VSL_GET_STDMETHOD_HRESULT();
	}

	HRESULT Test_VSL_CHECKHANDLE_GLE()
	{
		VSL_STDMETHODTRY
		{
			::SetLastError(ERROR_SUCCESS);
			CHKHANDLEGLE(g_hNotNull);  // this shouldn't throw
			::SetLastError(ERROR_OUTOFMEMORY);
			CHKHANDLEGLE(NULL);
		}
		VSL_STDMETHODCATCH()
		return VSL_GET_STDMETHOD_HRESULT();
	}

public:
	VSL_CHECKHANDLE_GLETest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
		typedef VSL_CHECKHANDLE_GLE_TRAITS VSL_CHECKHANDLE_GLE_TRAITS_t;
		UTCHK(Test_VSL_CHECKHANDLE_GLE_EX() == HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY));
		UTCHK(Test_VSL_CHECKHANDLE_GLE() == HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY));
	}
};

/*******************************************************************************
Validate VSLHRESULTErrorHandlers.h
*******************************************************************************/

class VSL_CHECKHRESULTTest :
	public UnitTestBase
{
protected:

	HRESULT Test_VSL_CHECKHRESULT_EX()
	{
		VSL_STDMETHODTRY
		{
			CHKHREX(S_OK, g_szExtra);  // this shouldn't throw
			CHKHREX(E_FAIL, g_szExtra);
		}
		VSL_STDMETHODCATCH()
		return VSL_GET_STDMETHOD_HRESULT();
	}

	HRESULT Test_VSL_CHECKHRESULT()
	{
		VSL_STDMETHODTRY
		{
			CHKHR(S_OK);  // this shouldn't throw
			CHKHR(E_FAIL);
		}
		VSL_STDMETHODCATCH()
		return VSL_GET_STDMETHOD_HRESULT();
	}

	HRESULT Test_VSL_CREATE_ERROR_HRESULT_EX()
	{
		VSL_STDMETHODTRY
		{
			ERRHREX(E_FAIL, g_szExtra);
		}
		VSL_STDMETHODCATCH()
		return VSL_GET_STDMETHOD_HRESULT();
	}

	HRESULT Test_VSL_CREATE_ERROR_HRESULT()
	{
		VSL_STDMETHODTRY
		{
			ERRHR(E_FAIL);
		}
		VSL_STDMETHODCATCH()
		return VSL_GET_STDMETHOD_HRESULT();
	}

public:
	VSL_CHECKHRESULTTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
		typedef VSL_CHECKHRESULT_TRAITS VSL_CHECKHRESULT_TRAITS_t;
		UTCHK(Test_VSL_CHECKHRESULT_EX() == E_FAIL);
		UTCHK(Test_VSL_CHECKHRESULT() == E_FAIL);
		typedef VSL_CREATE_ERROR_HRESULT_TRAITS VSL_CREATE_ERROR_HRESULT_TRAITS_t;
		UTCHK(Test_VSL_CREATE_ERROR_HRESULT_EX() == E_FAIL);
		UTCHK(Test_VSL_CREATE_ERROR_HRESULT() == E_FAIL);
	}
};

/*******************************************************************************
Validate VSLWin32ErrorHandlers.h
*******************************************************************************/

class VSL_CHECKWIN32Test :
	public UnitTestBase
{
protected:

	HRESULT Test_VSL_CHECKWIN32_EX()
	{
		VSL_STDMETHODTRY
		{
			CHKW32EX(ERROR_SUCCESS, g_szExtra);  // this shouldn't throw
			CHKW32EX(ERROR_OUTOFMEMORY, g_szExtra);
		}
		VSL_STDMETHODCATCH()
		return VSL_GET_STDMETHOD_HRESULT();
	}

	HRESULT Test_VSL_CHECKWIN32()
	{
		VSL_STDMETHODTRY
		{
			CHKW32(ERROR_SUCCESS);  // this shouldn't throw
			CHKW32(ERROR_OUTOFMEMORY);
		}
		VSL_STDMETHODCATCH()
		return VSL_GET_STDMETHOD_HRESULT();
	}

	HRESULT Test_VSL_CREATE_ERROR_WIN32_EX()
	{
		VSL_STDMETHODTRY
		{
			ERRW32EX(ERROR_OUTOFMEMORY, g_szExtra);
		}
		VSL_STDMETHODCATCH()
		return VSL_GET_STDMETHOD_HRESULT();
	}

	HRESULT Test_VSL_CREATE_ERROR_WIN32()
	{
		VSL_STDMETHODTRY
		{
			ERRW32(ERROR_OUTOFMEMORY);
		}
		VSL_STDMETHODCATCH()
		return VSL_GET_STDMETHOD_HRESULT();
	}

public:
	VSL_CHECKWIN32Test(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
		typedef VSL_CHECKWIN32_TRAITS VSL_CHECKWIN32_TRAITS_t;
		UTCHK(Test_VSL_CHECKWIN32_EX() == HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY));
		UTCHK(Test_VSL_CHECKWIN32() == HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY));
		typedef VSL_CREATE_ERROR_WIN32_TRAITS VSL_CREATE_ERROR_WIN32_TRAITS_t;
		UTCHK(Test_VSL_CREATE_ERROR_WIN32_EX() == HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY));
		UTCHK(Test_VSL_CREATE_ERROR_WIN32() == HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY));
	}
};

/*******************************************************************************
Validate VSL_CHECKPOINTER_DEFAULT
*******************************************************************************/

class VSL_CHECKPOINTER_DEFAULTTest :
	public UnitTestBase
{
public:

	VSL_CHECKPOINTER_DEFAULTTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
		HRESULT VSL_STDMETHOD_HRESULT = VSL_STDMETHOD_HRESULT_INIT;
		try{

		VSL_CHECKPOINTER_DEFAULT(reinterpret_cast<void*>(0));

		}VSL_STDMETHODCATCH()

		UTCHK(VSL_GET_STDMETHOD_HRESULT() == E_POINTER);

		VSL_CHECKPOINTER_DEFAULT(reinterpret_cast<void*>(1));
	}
};

int _cdecl _tmain()
{
	UTRUN(BaseClassHasVirtualDestructorUnitTest<ExceptionBaseHasVirtualDestructorTestHelper>);
	UTRUN(ExceptionBaseTest);
	ExceptionStdUnitTestList exceptionStdUnitTestList;
#if 0 // Add back if unit test is brought back
	UTRUN(ExtraTypeContainerStringTest);
#endif
	UTRUN(BaseClassHasVirtualDestructorUnitTest<ErrorVirtualDestructorTestHelper>);
	UTRUN(ExceptionExImplTest);
	UTRUN(ExceptionHRESULTTest);
	UTRUN(ExceptionWin32Test);
	UTRUN(VSL_STDMETHODTest);
	UTRUN(EvaluatorsTest);
	UTRUN(OverridesTest);
	UTRUN(ProcessorsTest);
	CompileTraits<HRESULTTraits>();
	CompileTraits<Win32Traits>();
	CompileTraits<BOOLGetLastErrorTraits>();
	CompileTraits<HANDLEGetLastErrorTraits>();
	UTRUN(CreateAndProcessErrorTest);
	UTRUN(FailOnErrorTest);
	UTRUN(VSL_CHECKBOOLTest);
	UTRUN(VSL_CHECKBOOL_GLETest);
	UTRUN(VSL_CHECKBOOLEANTest);
	UTRUN(VSL_CHECKHANDLE_GLETest);
	UTRUN(VSL_CHECKHRESULTTest);
	UTRUN(VSL_CHECKWIN32Test);
	UTRUN(VSL_CHECKPOINTER_DEFAULTTest);
	return VSL::FailureCounter::Get();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\UnitTest\Hierarchy\stdafx.cpp ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\UnitTest\MockInterfaces\MockInterfaces.cpp ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#include "stdafx.h"

#define VSLASSERT _ASSERTE
#define VSLASSERTEX(exp, szMsg) _ASSERT_BASE(exp, szMsg)
#define VSL_TRACE ATLTRACE

// We need to explicitly test that the destructor throws, so we suppress this
#define VSL_UNIT_TEST_AddRefAndReleaseMockBase_Destructor_Supress_Assert

#include "VSLUnitTest.h"
#include "VSLExceptionHandlers.h"
#include "VSLMockSystemInterfaces.h"
#include "VSLMockVisualStudioInterfaces.h"
#include "VSLContainers.h"
#include "VSLShortNameDefines.h"

#include "MockInterfaces.h"

using namespace VSL;

class NullBase {};

#include "System.h"
#include "VisualStudio.h"


int _cdecl _tmain()
{
	VSL_UTRUN_BASE_CLASS_HAS_VIRTUAL_DESTRUCTOR(AddRefAndReleaseMockNullBase);
	UTRUN(AddRefAndReleaseMockTest);
	UTRUN(IUnknownInterfaceListTerminatorDefaultTest);
	UTRUN(InterfaceListTest);
	VSL_UTRUN_BASE_CLASS_HAS_VIRTUAL_DESTRUCTOR(QueryInterfaceMockBase);
	UTRUN(QueryInterfaceMockBaseTest);
	// TODO - make this fail correctly if destructor isn't virtual
	UTRUN(COMMockBaseTest);
	UTRUN(ISimpleAndDerivedInterfaceListTest);
	UTRUN(I2MethodsPartialImplTest);
	UTRUN(I2MethodsFullImplTest);
	UTRUN(AtlIServiceProviderMockTest);
	UTRUN(IServiceProviderImplMockTest);
	VSL_UTRUN_BASE_CLASS_HAS_VIRTUAL_DESTRUCTOR(IVsShellNotImplMock);
	UTRUN(IVsShellNotImplTest);
	UTRUN(StaticArrayTest);
	UTRUN(IVsUIShellNotImplTest);
	UTRUN(IVsOutputWindowPaneNotImplTest);
	UTRUN(IVsWindowFrameNotImplTest);
	UTRUN(IVsWindowFrame2NotImplTest);
	UTRUN(IProfferServiceNotImplTest);
	return VSL::FailureCounter::Get();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\UnitTest\MockInterfaces\stdafx.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#pragma once

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

// REVIEW - some or all of these /analyze warnings in the
// common headers should be fixed for RTM, re-enable the
// ones that are
#pragma warning(push)
#pragma warning(disable : 6011 6054 6309 6387 6535 6387)

#include <atlbase.h>
#include <atlcom.h>
#include <atlstr.h>

#pragma warning(pop)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\UnitTest\Package\stdafx.cpp ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\UnitTest\Package\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Package.rc
//
#define IDS_E_ERRORMESSAGE              101
#define IDS_SOURCENAME1                 102
#define IDS_SOURCENAME2                 103
#define IDS_TESTTEXT                    104

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\UnitTest\Hierarchy\Hierarchy.cpp ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#include "stdafx.h"

#include "VSLHierarchy.h"
#include "VSLHierarchyNode.h"

using namespace VSL;

VSL_DEFINE_SERVICE_MOCK(IVsShellServiceMock, IVsShellNotImpl);
VSL_DEFINE_SERVICE_MOCK(IVsUIShellServiceMock, IVsUIShellNotImpl);

typedef ServiceList<IVsShellServiceMock, ServiceList<IVsUIShellServiceMock, ServiceListTerminator> > IServiceProviderServiceList;
typedef InterfaceImplList<VSL::IServiceProviderImpl<IServiceProviderServiceList>, IUnknownInterfaceListTerminator<IServiceProvider> > IServiceProviderMockInterfaceList;

VSL_DECLARE_COM_MOCK(IServiceProviderMock, IServiceProviderMockInterfaceList){};

template <class Base_T = VsUIHierarchyItemBase<> >
class TestItem : public Base_T
{

VSL_DECLARE_NOT_COPYABLE(TestItem)

protected:
	TestItem()
	{
	}

public:
	typedef typename Base_T Base;
	typedef typename Base_T::ItemInterface ItemInterface;

	TestItem(ItemInterface* p):
		Base_T(p)
	{
	}

	TestItem(Base_T& rParent):
		Base_T(*static_cast<Base_T::BaseClass*>(&rParent))
	{
	}

	virtual const ATL::CComBSTR& GetCanonicalName() const
	{
		static CComBSTR bstr = __WFILE__;
		return bstr;
	}

	virtual VSITEMID ParseCanonicalName(_In_ LPCOLESTR pszName) const
	{
		(pszName);
		return VSITEMID_NIL;
	}

	virtual IOleCommandTarget* GetIOleCommandTarget()
	{
		return NULL;
	}

	virtual IDispatch* GetIDispatch()
	{
		return NULL;
	}

	virtual const GUID& GetTypeGuid() const
	{
		return CLSID_ManualResetEvent;
	}

	virtual const GUID& GetCmdUIGuid() const
	{
		return CLSID_StdEvent;
	}

	virtual const ATL::CComBSTR& GetCaption() const
	{
		static CComBSTR bstr = __WFILE__;
		return bstr;
	}

	virtual const ATL::CComBSTR& GetEditLabel() const
	{
		static CComBSTR bstr = __WFILE__;
		return bstr;
	}

	virtual void SetEditLabel(BSTR bstrEditLabel)
	{
		VSL_CHECKBOOLEAN(CComBSTR(__WFILE__) == bstrEditLabel, E_FAIL);		
	}

	virtual const ATL::CComBSTR& GetName() const
	{
		static CComBSTR bstr = __WFILE__;
		return bstr;
	}
};

class TestRoot : public VsHierarchyRootItemBase<TestItem<> >
{

VSL_DECLARE_NOT_COPYABLE(TestRoot)

public:

#pragma warning(push)
#pragma warning(disable : 4355) // 'this' : used in base member initializer list
	TestRoot():
		VsHierarchyRootItemBase<TestItem<> >(this)
	{
		SetSelection(this);
	}
#pragma warning(pop)

	void SetSelectionToItem(TestItem& item)
	{
		SetSelection(&item);
	}

	virtual bool IsExpandedByDefault() const
	{
		return true;
	}

	virtual ImageListWin32Control& GetIconImageList()
	{
		static ImageListWin32Control control;
		return control;
	}
};

template <
	class Base_T = TestItem<IVsUIHierarchyItem > >
class VsUIHierarchyItemMock :
	public Base_T,
	public IOleCommandTargetMockImpl
{
public:

VSL_DEFINE_IUNKNOWN_NOTIMPL

	typedef HierarchyNode<HierarchyNodeTraits<typename Base_T::ItemInterface*> > HierarchyNode;

	virtual const GUID& GetGuidProperty(_In_ VSHPROPID propid) const
	{
		(propid);
		return CLSID_ManualResetEvent;
	}

	virtual void SetGuidProperty(_In_ VSHPROPID propid,	_In_ REFGUID rguid)
	{
		(propid, rguid);
		VSL_CHECKBOOLEAN(CLSID_SynchronizeContainer == rguid, E_FAIL);
	}

	virtual void GetProperty(_In_ VSHPROPID propid, _Out_ VARIANT* pVar)
	{
		(propid);
		CComVariant var = E_UNEXPECTED;
		var.Detach(pVar);
	}

	virtual void SetProperty(_In_ VSHPROPID propid, _In_ VARIANT& rVar)
	{
		(propid);
		VSL_CHECKBOOLEAN(S_FALSE == rVar.lVal, E_FAIL);		
	}

	virtual const CComBSTR& GetCanonicalName() const
	{
		static CComBSTR bstr = __WFILE__;
		return bstr;
	}

	virtual VSITEMID ParseCanonicalName(_In_ LPCOLESTR pszName) const
	{
		VSL_CHECKBOOLEAN(CString(__WFILE__) == CString(pszName), E_FAIL);		
		return VSITEMID_SELECTION;
	}

	virtual VSITEMID GetVSITEMID() const
	{
		return reinterpret_cast<VSITEMID>(static_cast<const Base_T::ItemInterface* const>(this));
	}

	static bool& GetIOleCommandTargetReturnsNull()
	{
		static bool b = true;
		return b;
	}

	virtual IOleCommandTarget* GetIOleCommandTarget()
	{
		if(GetIOleCommandTargetReturnsNull())
		{
			return NULL;
		}
		else
		{
			return this;
		}
	}

	virtual bool IsVisible() const
	{
		return true;
	}

	HierarchyNode* m_pNode;

	virtual HIMAGELIST GetIconImageList() const
	{
		VSL_CREATE_ERROR_HRESULT(DISP_E_MEMBERNOTFOUND); // indicates that Visual Studio should supply the image list if possible
		return NULL;
	}

	virtual UINT GetIconIndex() const
	{
		// indicates that Visual Studio should supply the image index from it's own image list if possible
		VSL_CREATE_ERROR_HRESULT(DISP_E_MEMBERNOTFOUND);
		return 0;
	}

	virtual UINT GetOpenFolderIconIndex() const
	{
		// indicates that Visual Studio should supply the image index from it's own image list if possible
		VSL_CREATE_ERROR_HRESULT(DISP_E_MEMBERNOTFOUND);
		return 0;
	}

	virtual UINT GetStateIconIndex() const
	{
		// indicates that Visual Studio should supply the image index from it's own image list if possible
		VSL_CREATE_ERROR_HRESULT(DISP_E_MEMBERNOTFOUND);
		return 0;
	}

	virtual bool IsExpandable() const
	{
		return true;
	}

	virtual bool IsExpandedByDefault() const
	{
		return false;
	}

	virtual ISelectionContainer* GetISelectionContainer()
	{
		return NULL;
	}

	virtual IDispatch* GetIDispatch()
	{
		return NULL;
	}

	virtual IVsUserContext* GetIVsUserContext()
	{
		return NULL;
	}
};

class VsUIHierarchyRootItemMock :
	public VsUIHierarchyItemMock<>,
	public CComObjectRootEx<CComSingleThreadModel>
{
public:

	VsUIHierarchyRootItemMock()
	{
	}

	static HRESULT CreateInstance(VsUIHierarchyRootItemMock** pp)
	{
		VsUIHierarchyRootItemMock* pRootItem = NULL;
		HRESULT hRes = E_OUTOFMEMORY;
		ATLTRY(pRootItem = new VsUIHierarchyRootItemMock())
		if (pRootItem != NULL)
		{
			pRootItem->SetVoid(NULL);
			pRootItem->InternalFinalConstructAddRef();
			hRes = pRootItem->_AtlInitialConstruct();
			if (SUCCEEDED(hRes))
				hRes = pRootItem->FinalConstruct();
			if (SUCCEEDED(hRes))
				hRes = pRootItem->_AtlFinalConstruct();
			pRootItem->InternalFinalConstructRelease();
			if (hRes != S_OK)
			{
				delete pRootItem;
				pRootItem = NULL;
			}
		}
		VSL_CHECKHRESULT(hRes);
		*pp = pRootItem;
		return S_OK;
	}

	bool IsValidVSITEMID(_In_ VSITEMID itemid)
	{
		return (VSITEMID_SELECTION == itemid);
	}

	virtual IVsHierarchyEvents* GetIVsHierarchyEvents()
	{
		// Derived class needs to implement this properly
		VSL_CREATE_ERROR_HRESULT(E_UNEXPECTED);
		return NULL;
	}

	ItemInterface& GetItem(_In_ VSITEMID itemid)
	{
		VSL_CHECKBOOLEAN(IsValidVSITEMID(itemid), E_INVALIDARG);
		return *this;
	}

	virtual const GUID& GetGuidProperty(_In_ VSITEMID itemid, _In_ VSHPROPID propid) const
	{
		(itemid, propid);
		return CLSID_ManualResetEvent;
	}

	virtual void SetGuidProperty(_In_ VSITEMID itemid, _In_ VSHPROPID propid,	_In_ REFGUID rguid)
	{
		(itemid, propid, rguid);
		VSL_CHECKBOOLEAN(CLSID_SynchronizeContainer == rguid, E_FAIL);
	}

	virtual void GetProperty(_In_ VSITEMID itemid, _In_ VSHPROPID propid, _Out_ VARIANT* pVar) const
	{
		(itemid, propid);
		CComVariant var = E_UNEXPECTED;
		var.Detach(pVar);
	}

	virtual void SetProperty(_In_ VSITEMID itemid, _In_ VSHPROPID propid, _In_ VARIANT& rVar)
	{
		(itemid, propid);
		VSL_CHECKBOOLEAN(S_FALSE == rVar.lVal, E_FAIL);		
	}

	virtual ImageListWin32Control& GetIconImageList()
	{
		static ImageListWin32Control control;
		return control;
	}

	virtual HICON GetIconHandle() const
	{
		return NULL;
	}

	virtual HICON GetOpenFolderIconHandle() const
	{
		return GetIconHandle();
	}

	virtual bool IsExpanded() const
	{
		return false;
	}

	virtual void SetExpanded(bool bExpanded)
	{
		(bExpanded);
	}

	void Dispose()
	{
	}
};

class IVsUIHierarchyImplTest :
	public UnitTestBase,
	public IVsUIHierarchyImpl<IVsUIHierarchyImplTest, VsUIHierarchyRootItemMock, IVsHierarchyImpl<IVsUIHierarchyImplTest, VsUIHierarchyRootItemMock, IVsUIHierarchy> >
{
public:

VSL_DEFINE_IUNKNOWN_NOTIMPL

	IVsUIHierarchyImplTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
		IVsHierarchy* pIVsHierarchy = static_cast<IVsHierarchy*>(static_cast<IVsHierarchyImpl*>(this));

		IServiceProviderMock mock;
		CComQIPtr<IServiceProvider> spIServiceProvider = mock.GetIUnknownNoAddRef();

		// IVsHierarchy methods
		UTCHK(S_OK == pIVsHierarchy->SetSite(spIServiceProvider));

		{
		CComPtr<IServiceProvider> spRetrieved;
		UTCHK(S_OK == pIVsHierarchy->GetSite(&spRetrieved));
		UTCHK(spRetrieved == spIServiceProvider);
		}

		{
		GUID guid;
		UTCHK(E_INVALIDARG == pIVsHierarchy->GetGuidProperty(VSITEMID_SELECTION, VSHPROPID_Name, NULL));
		UTCHK(E_INVALIDARG == pIVsHierarchy->GetGuidProperty(VSITEMID_SELECTION, VSHPROPID_NIL, &guid));
		UTCHK(E_INVALIDARG == pIVsHierarchy->GetGuidProperty(VSITEMID_SELECTION, VSHPROPID_LAST+1, &guid));
		UTCHK(E_INVALIDARG == pIVsHierarchy->GetGuidProperty(VSITEMID_SELECTION, VSHPROPID_FIRST2-1, &guid));
		UTCHK(S_OK == pIVsHierarchy->GetGuidProperty(VSITEMID_SELECTION, VSHPROPID_Name, &guid));
		UTCHK(guid == CLSID_ManualResetEvent);
		}

		{
		UTCHK(E_INVALIDARG == pIVsHierarchy->SetGuidProperty(VSITEMID_SELECTION, VSHPROPID_NIL, CLSID_SynchronizeContainer));
		UTCHK(E_INVALIDARG == pIVsHierarchy->SetGuidProperty(VSITEMID_SELECTION, VSHPROPID_LAST+1, CLSID_SynchronizeContainer));
		UTCHK(E_INVALIDARG == pIVsHierarchy->SetGuidProperty(VSITEMID_SELECTION, VSHPROPID_FIRST2-1, CLSID_SynchronizeContainer));
		UTCHK(S_OK == pIVsHierarchy->SetGuidProperty(VSITEMID_SELECTION, VSHPROPID_Name, CLSID_SynchronizeContainer));
		}

		{
		CComVariant var;
		UTCHK(E_INVALIDARG == pIVsHierarchy->GetProperty(VSITEMID_SELECTION, VSHPROPID_Name, NULL));
		UTCHK(E_INVALIDARG == pIVsHierarchy->GetProperty(VSITEMID_SELECTION, VSHPROPID_NIL, &var));
		UTCHK(E_INVALIDARG == pIVsHierarchy->GetProperty(VSITEMID_SELECTION, VSHPROPID_LAST+1, &var));
		UTCHK(E_INVALIDARG == pIVsHierarchy->GetProperty(VSITEMID_SELECTION, VSHPROPID_FIRST2-1, &var));
		UTCHK(S_OK == pIVsHierarchy->GetProperty(VSITEMID_SELECTION, VSHPROPID_Name, &var));
		UTCHK(var.lVal == E_UNEXPECTED);
		}

		{
		CComVariant var = S_FALSE;
		UTCHK(E_INVALIDARG == pIVsHierarchy->SetProperty(VSITEMID_SELECTION, VSHPROPID_NIL, var));
		UTCHK(E_INVALIDARG == pIVsHierarchy->SetProperty(VSITEMID_SELECTION, VSHPROPID_LAST+1, var));
		UTCHK(E_INVALIDARG == pIVsHierarchy->SetProperty(VSITEMID_SELECTION, VSHPROPID_FIRST2-1, var));
		UTCHK(S_OK == pIVsHierarchy->SetProperty(VSITEMID_SELECTION, VSHPROPID_Name, var));
		}

		{
		VSITEMID itemId;
		UTCHK(E_NOTIMPL == pIVsHierarchy->GetNestedHierarchy(VSITEMID_SELECTION, GUID_NULL, NULL, &itemId));
		}
		
#ifdef VSL_TEST_HIERARCHY_METHODS_CALLED
		{
		CComBSTR bstr;
		UTCHK(E_INVALIDARG == pIVsHierarchy->GetCanonicalName(VSITEMID_SELECTION, NULL));
		UTCHK(S_OK == pIVsHierarchy->GetCanonicalName(VSITEMID_SELECTION, &bstr));
		UTCHK(bstr == __WFILE__);
		}
#else // VSL_TEST_HIERARCHY_METHODS_CALLED
		{
		CComBSTR bstr;
		UTCHK(E_INVALIDARG == pIVsHierarchy->GetCanonicalName(VSITEMID_SELECTION, NULL));
		UTCHK(E_NOTIMPL == pIVsHierarchy->GetCanonicalName(VSITEMID_SELECTION, &bstr));
		}
#endif // VSL_TEST_HIERARCHY_METHODS_CALLED

#ifdef VSL_TEST_HIERARCHY_METHODS_CALLED
		{
		VSITEMID itemId;
		UTCHK(E_INVALIDARG == pIVsHierarchy->ParseCanonicalName(NULL, NULL));
		UTCHK(E_INVALIDARG == pIVsHierarchy->ParseCanonicalName(L"", &itemId));
		UTCHK(S_OK == pIVsHierarchy->ParseCanonicalName(__WFILE__, &itemId));
		UTCHK(itemId == VSITEMID_SELECTION);
		}
#else // VSL_TEST_HIERARCHY_METHODS_CALLED
		{
		VSITEMID itemId;
		UTCHK(E_INVALIDARG == pIVsHierarchy->ParseCanonicalName(NULL, NULL));
		UTCHK(E_INVALIDARG == pIVsHierarchy->ParseCanonicalName(L"", &itemId));
		UTCHK(E_NOTIMPL == pIVsHierarchy->ParseCanonicalName(__WFILE__, &itemId));
		}
#endif // VSL_TEST_HIERARCHY_METHODS_CALLED

		{
		IVsHierarchyEvents *pEventSink = reinterpret_cast<IVsHierarchyEvents *>(-1);
		VSCOOKIE cookie1;
		UTCHK(S_OK == pIVsHierarchy->AdviseHierarchyEvents(pEventSink, &cookie1));
		VSCOOKIE cookie2;
		UTCHK(S_OK == pIVsHierarchy->AdviseHierarchyEvents(pEventSink, &cookie2));
		VSCOOKIE cookie3;
		UTCHK(S_OK == pIVsHierarchy->AdviseHierarchyEvents(pEventSink, &cookie3));
		UTCHK(cookie1 != cookie2);
		UTCHK(cookie2 != cookie3);
		UTCHK(cookie1 != cookie3);
		UTCHK(S_OK == pIVsHierarchy->UnadviseHierarchyEvents(cookie1));
		UTCHK(S_OK == pIVsHierarchy->UnadviseHierarchyEvents(cookie2));
		UTCHK(S_OK == pIVsHierarchy->UnadviseHierarchyEvents(cookie3));
		}

		// IVsUIHierarchy methods
		IVsUIHierarchy* pIVsUIHierarchy = static_cast<IVsUIHierarchy*>(static_cast<IVsUIHierarchyImpl*>(this));

		// The mock starts with IOleCommandTarget not supported
		UTCHK(OLECMDERR_E_NOTSUPPORTED == pIVsUIHierarchy->QueryStatusCommand(VSITEMID_SELECTION, NULL, 0, NULL, NULL));
		UTCHK(WASCALLED(IOleCommandTarget, QueryStatus, 0));
		UTCHK(OLECMDERR_E_NOTSUPPORTED == pIVsUIHierarchy->ExecCommand(VSITEMID_SELECTION, NULL, 0, 0, NULL, NULL));
		UTCHK(WASCALLED(IOleCommandTarget, Exec, 0));

		// Now switch to the mock to support it.
		VsUIHierarchyRootItemMock::GetIOleCommandTargetReturnsNull() = false;

		// Have the mock method return S_FALSE to ensure that QueryStatusCommand is returning the
		// methods return value rather then it's default S_OK
		STARTVV(IOleCommandTarget, QueryStatus)
			NULL, 0, NULL, NULL, S_FALSE
		ENDVVPUSH()
		UTCHK(S_FALSE == pIVsUIHierarchy->QueryStatusCommand(VSITEMID_SELECTION, NULL, 0, NULL, NULL));
		UTCHK(WASCALLED(IOleCommandTarget, QueryStatus, 1));

		// ^Ditto
		STARTVV(IOleCommandTarget, Exec)
			NULL, 0, 0, NULL, NULL, S_FALSE
		ENDVVPUSH()
		UTCHK(S_FALSE == pIVsUIHierarchy->ExecCommand(VSITEMID_SELECTION, NULL, 0, 0, NULL, NULL));
		UTCHK(WASCALLED(IOleCommandTarget, Exec, 1));

		// Remainder of IVsHierarchy methods

		BOOL bCanClose = FALSE;
		UTCHK(S_OK == pIVsHierarchy->QueryClose(&bCanClose));
		UTCHK(bCanClose == TRUE);

		UTCHK(S_OK == pIVsHierarchy->Close());
	}
};

class HierarchyNodeStackNodesTest :
	public UnitTestBase
{
private:

	typedef HierarchyNodeTraits<unsigned int, unsigned int, HierarchyNodeTraitStackNodes> HierarchyNodeStackNodesTraits;
	typedef HierarchyNode<HierarchyNodeStackNodesTraits> Node;

	void TestNodeNotFound(unsigned int iItem, Node& rNode)
	{
		unsigned int itemNotFound = iItem;
		Node::FindInfo findInfo = {itemNotFound};
		UTCHK(false == rNode.FindIterator(findInfo));
		UTCHK(NULL == rNode.FindItemContainer(iItem));
	}

	void TestNotFound(Node& rNode)
	{
		TestNodeNotFound(0, rNode);
		TestNodeNotFound(2, rNode);
		TestNodeNotFound(312, rNode);
		TestNodeNotFound(9999999, rNode);
		TestNodeNotFound(0xFFFFFFFF, rNode);
	}

	void TestNodeFound(Node& rFindOn, Node& rToFind)
	{
		Node::FindInfo findInfo = {*rToFind};
		UTCHK(true == rFindOn.FindIterator(findInfo));
		UTCHK(&((*findInfo.rFound)->GetParent()->GetDescendantContainer()) == findInfo.pContainer);
		UTCHK(&rToFind == *(findInfo.rFound));
		UTCHK(*rToFind == *(rFindOn.FindItemContainer(*rToFind)));
	}

	void TestNodeIsNodeToFind(Node& rNode)
	{
		TestNotFound(rNode);
		Node::FindInfo findInfo = {*rNode};
		UTCHK(true == rNode.FindIterator(findInfo));
		UTCHK(NULL == findInfo.pContainer);
		UTCHK(*rNode == *(rNode.FindItemContainer(*rNode)));
	}

public:

	HierarchyNodeStackNodesTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{

		// Setup a hiearchy
		unsigned int item1 = 1;
		Node node1(NULL, item1);
			unsigned int item11 = 11;
			Node node11(&node1, item11);
				unsigned int item111 = 111;
				Node node111(&node11, item111);
				unsigned int item211 = 211;
				Node node211(&node11, item211);
					unsigned int item1211 = 1211;
					Node node1211(&node211, item1211);
				unsigned int item311 = 311;
				Node node311(&node11, item311);
			unsigned int item21 = 21;
			Node node21(&node1, item21);

		// Test that each node has the correct parent and item
		UTCHK(NULL == node1.GetParent());
		UTCHK(item1 == *node1);
			UTCHK(&node1 == node11.GetParent());
			UTCHK(item11 == *node11);
				UTCHK(&node11 == node111.GetParent());
				UTCHK(item111 == *node111);
				UTCHK(&node11 == node211.GetParent());
				UTCHK(item211 == *node211);
					UTCHK(&node211 == node1211.GetParent());
					UTCHK(item1211 == *node1211);
				UTCHK(&node11 == node311.GetParent());
				UTCHK(item311 == *node311);
			UTCHK(&node1 == node21.GetParent());
			UTCHK(item21 == *node21);

		// Test that each node has the correct descendants
		Node::DescendantContainer& rContainer1 = node1.GetDescendantContainer();
		Node::iterator i1 = rContainer1.begin();
		UTCHK(&node11 == *i1);
		UTCHK(item11 == ***i1);
			Node::DescendantContainer& rContainer11 = node11.GetDescendantContainer();
			Node::iterator i11 = rContainer11.begin();
			UTCHK(&node111 == *i11);
			UTCHK(item111 == ***i11);
			++i11;
			UTCHK(&node211 == *i11);
			UTCHK(item211 == ***i11);
				Node::DescendantContainer& rContainer211 = node211.GetDescendantContainer();
				Node::iterator i211 = rContainer211.begin();
				UTCHK(&node1211 == *i211);
				UTCHK(item1211 == ***i211);
			++i11;
			UTCHK(&node311 == *i11);
			UTCHK(item311 == ***i11);
		++i1;
		UTCHK(&node21 == *i1);
		UTCHK(item21 == ***i1);

		// Test find methods on node1
		TestNodeIsNodeToFind(node1);
			TestNodeFound(node1, node11);
				TestNodeFound(node1, node111);
				TestNodeFound(node1, node211);
					TestNodeFound(node1, node1211);
				TestNodeFound(node1, node311);
			TestNodeFound(node1, node21);

		// Test find methods on node11
		TestNodeIsNodeToFind(node11);
			TestNodeFound(node11, node111);
			TestNodeFound(node11, node211);
				TestNodeFound(node11, node1211);
			TestNodeFound(node11, node311);

		// Test find methods on node111
		TestNodeIsNodeToFind(node111);

		// Test find methods on node211
		TestNodeIsNodeToFind(node211);
			TestNodeFound(node211, node1211);

		// Test find methods on node1211
		TestNodeIsNodeToFind(node1211);

		// Test find methods on node311
		TestNodeIsNodeToFind(node311);

		// Test find methods on node21
		TestNodeIsNodeToFind(node21);
	}

};

class HierarchyNodeHeapNodesTest :
	public UnitTestBase
{
public:

	HierarchyNodeHeapNodesTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
		typedef HierarchyNodeTraits<unsigned int, unsigned int, HierarchyNodeTraitHeapNodes> HierarchyNodeHeapNodesTraits;

		// Setup a hiearchy
		unsigned int item1 = 1;
		HierarchyNode<HierarchyNodeHeapNodesTraits> node1(item1);
		HierarchyNode<HierarchyNodeHeapNodesTraits>* pNode1 = &node1;
			unsigned int item11 = 11;
			HierarchyNode<HierarchyNodeHeapNodesTraits>* pNode11 = pNode1->AddDescendant(item11);
				unsigned int item111 = 111;
				HierarchyNode<HierarchyNodeHeapNodesTraits>* pNode111 = pNode11->AddDescendant(item111);
				unsigned int item211 = 211;
				HierarchyNode<HierarchyNodeHeapNodesTraits>* pNode211 = pNode11->AddDescendant(item211);
					unsigned int item1211 = 1211;
					HierarchyNode<HierarchyNodeHeapNodesTraits>* pNode1211 = pNode211->AddDescendant(item1211);
				unsigned int item311 = 311;
				HierarchyNode<HierarchyNodeHeapNodesTraits>* pNode311 = pNode11->AddDescendant(item311);
			unsigned int item21 = 21;
			HierarchyNode<HierarchyNodeHeapNodesTraits>* pNode21 = pNode1->AddDescendant(item21);

		// Test that each node has the correct parent and item
		UTCHK(NULL == pNode1->GetParent());
		UTCHK(item1 == **pNode1);
			UTCHK(pNode1 == pNode11->GetParent());
			UTCHK(item11 == **pNode11);
				UTCHK(pNode11 == pNode111->GetParent());
				UTCHK(item111 == **pNode111);
				UTCHK(pNode11 == pNode211->GetParent());
				UTCHK(item211 == **pNode211);
					UTCHK(pNode211 == pNode1211->GetParent());
					UTCHK(item1211 == **pNode1211);
				UTCHK(pNode11 == pNode311->GetParent());
				UTCHK(item311 == **pNode311);
			UTCHK(pNode1 == pNode21->GetParent());
			UTCHK(item21 == **pNode21);

		// Test that each node has the correct descendants
		HierarchyNode<HierarchyNodeHeapNodesTraits>::DescendantContainer& rContainer1 = pNode1->GetDescendantContainer();
		HierarchyNode<HierarchyNodeHeapNodesTraits>::iterator i1 = rContainer1.begin();
		UTCHK(pNode11 == *i1);
		UTCHK(item11 == ***i1);
			HierarchyNode<HierarchyNodeHeapNodesTraits>::DescendantContainer& rContainer11 = pNode11->GetDescendantContainer();
			HierarchyNode<HierarchyNodeHeapNodesTraits>::iterator i11 = rContainer11.begin();
			UTCHK(pNode111 == *i11);
			UTCHK(item111 == ***i11);
			++i11;
			UTCHK(pNode211 == *i11);
			UTCHK(item211 == ***i11);
				HierarchyNode<HierarchyNodeHeapNodesTraits>::DescendantContainer& rContainer211 = pNode211->GetDescendantContainer();
				HierarchyNode<HierarchyNodeHeapNodesTraits>::iterator i211 = rContainer211.begin();
				UTCHK(pNode1211 == *i211);
				UTCHK(item1211 == ***i211);
			++i11;
			UTCHK(pNode311 == *i11);
			UTCHK(item311 == ***i11);
		++i1;
		UTCHK(pNode21 == *i1);
		UTCHK(item21 == ***i1);
	}
};

class VsHierarchyRootItemBaseTest :
	public UnitTestBase
{
public:

	VsHierarchyRootItemBaseTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
		typedef TestRoot HierarchyRoot;
		typedef TestItem<> HierarchyItem;

		HierarchyRoot root;
		HierarchyItem::Base& rRootBase = root;
		HierarchyItem item11(rRootBase);
		VSITEMID itemId11 = reinterpret_cast<VSITEMID>(static_cast<HierarchyItem::ItemInterface*>(&item11));
		HierarchyItem item21(rRootBase);
		VSITEMID itemId21 = reinterpret_cast<VSITEMID>(static_cast<HierarchyItem::ItemInterface*>(&item21));
		
		// Get VsHierarchyRootItemBase::GetItem
		HRESULT VSL_STDMETHOD_HRESULT = VSL_STDMETHOD_HRESULT_INIT;
		try{

		UTCHK(static_cast<HierarchyRoot::ItemInterface*>(&root) == &root.GetItem(VSITEMID_NIL));

		}VSL_STDMETHODCATCH()
		UTCHK(VSL_GET_STDMETHOD_HRESULT() == E_INVALIDARG);

		UTCHK(static_cast<HierarchyRoot::ItemInterface*>(&root) == &root.GetItem(VSITEMID_ROOT));
		UTCHK(static_cast<HierarchyRoot::ItemInterface*>(&root) == &root.GetItem(VSITEMID_SELECTION));
		UTCHK(static_cast<HierarchyRoot::ItemInterface*>(&item11) == &root.GetItem(itemId11));

		root.SetSelectionToItem(item11);

		UTCHK(static_cast<HierarchyRoot::ItemInterface*>(&root) == &root.GetItem(VSITEMID_ROOT));
		UTCHK(static_cast<HierarchyRoot::ItemInterface*>(&item11) == &root.GetItem(VSITEMID_SELECTION));
		UTCHK(static_cast<HierarchyRoot::ItemInterface*>(&item11) == &root.GetItem(itemId11));

		// Get VsHierarchyRootItemBase::GetGuidProperty
		VSL_STDMETHOD_HRESULT = VSL_STDMETHOD_HRESULT_INIT;
		try{

		root.GetGuidProperty(VSITEMID_ROOT, VSHPROPID_ProjectIDGuid);

		}VSL_STDMETHODCATCH()
		UTCHK(VSL_GET_STDMETHOD_HRESULT() == E_NOTIMPL);

		// Get VsHierarchyRootItemBase::SetGuidProperty
		VSL_STDMETHOD_HRESULT = VSL_STDMETHOD_HRESULT_INIT;
		try{

		root.SetGuidProperty(VSITEMID_ROOT, VSHPROPID_Name, CLSID_SynchronizeContainer);

		}VSL_STDMETHODCATCH()
		UTCHK(VSL_GET_STDMETHOD_HRESULT() == E_UNEXPECTED);

		// Get VsHierarchyRootItemBase::GetProperty - VSHPROPID_Root
		{
		CComVariant var;
		root.GetProperty(VSITEMID_ROOT, VSHPROPID_Root, &var);
		UTCHK(static_cast<VSITEMID>(var.intVal) == VSITEMID_ROOT);
		}

		// Get VsHierarchyRootItemBase::GetProperty - VSHPROPID_NextSibling
		VSL_STDMETHOD_HRESULT = VSL_STDMETHOD_HRESULT_INIT;
		try{

		CComVariant var;
		root.GetProperty(VSITEMID_ROOT, VSHPROPID_NextSibling, &var);

		}VSL_STDMETHODCATCH()
		UTCHK(VSL_GET_STDMETHOD_HRESULT() == E_INVALIDARG);

		root.SetSelectionToItem(root);

		VSL_STDMETHOD_HRESULT = VSL_STDMETHOD_HRESULT_INIT;
		try{

		CComVariant var;
		root.GetProperty(VSITEMID_SELECTION, VSHPROPID_NextSibling, &var);

		}VSL_STDMETHODCATCH()
		UTCHK(VSL_GET_STDMETHOD_HRESULT() == E_INVALIDARG);

		root.SetSelectionToItem(item11);

		{
		CComVariant var;
		root.GetProperty(VSITEMID_SELECTION, VSHPROPID_NextSibling, &var);
		UTCHK(static_cast<VSITEMID>(var.intVal) == itemId21);
		}

		{
		CComVariant var;
		root.GetProperty(itemId11, VSHPROPID_NextSibling, &var);
		UTCHK(static_cast<VSITEMID>(var.intVal) == itemId21);
		}

		// Get VsHierarchyRootItemBase::GetProperty - VSHPROPID_NextVisibleSibling
		VSL_STDMETHOD_HRESULT = VSL_STDMETHOD_HRESULT_INIT;
		try{

		CComVariant var;
		root.GetProperty(VSITEMID_ROOT, VSHPROPID_NextVisibleSibling, &var);

		}VSL_STDMETHODCATCH()
		UTCHK(VSL_GET_STDMETHOD_HRESULT() == E_INVALIDARG);

		root.SetSelectionToItem(root);

		VSL_STDMETHOD_HRESULT = VSL_STDMETHOD_HRESULT_INIT;
		try{

		CComVariant var;
		root.GetProperty(VSITEMID_SELECTION, VSHPROPID_NextVisibleSibling, &var);

		}VSL_STDMETHODCATCH()
		UTCHK(VSL_GET_STDMETHOD_HRESULT() == E_INVALIDARG);

		root.SetSelectionToItem(item11);

		{
		CComVariant var;
		root.GetProperty(VSITEMID_SELECTION, VSHPROPID_NextVisibleSibling, &var);
		UTCHK(static_cast<VSITEMID>(var.intVal) == itemId21);
		}

		{
		CComVariant var;
		root.GetProperty(itemId11, VSHPROPID_NextVisibleSibling, &var);
		UTCHK(static_cast<VSITEMID>(var.intVal) == itemId21);
		}

		// Get VsHierarchyRootItemBase::GetProperty - VSHPROPID_IconImgList
		{
		CComVariant var;
		root.GetProperty(itemId11, VSHPROPID_IconImgList, &var);
		UTCHK(static_cast<VSITEMID>(var.intVal) != NULL);
		}

		// Get VsHierarchyRootItemBase::SetProperty
		VSL_STDMETHOD_HRESULT = VSL_STDMETHOD_HRESULT_INIT;
		try{

		CComVariant var = S_FALSE;
		root.SetProperty(VSITEMID_ROOT, VSHPROPID_Name, var);

		}VSL_STDMETHODCATCH()
		UTCHK(VSL_GET_STDMETHOD_HRESULT() == E_NOTIMPL);
	}
};

class VsHierarchyItemBaseTest :
	public UnitTestBase
{
public:

	typedef TestRoot HierarchyRoot;
	typedef TestItem<> HierarchyItem;

	void TestGetGuidPropertyFailed(HierarchyItem& rItem, VSHPROPID propid, HRESULT hr)
	{
		HRESULT VSL_STDMETHOD_HRESULT = VSL_STDMETHOD_HRESULT_INIT;
		try{

		rItem.GetGuidProperty(propid);

		}VSL_STDMETHODCATCH()
		UTCHK(VSL_GET_STDMETHOD_HRESULT() == hr);
	}

	void TestSetGuidPropertyFailed(HierarchyItem& rItem, VSHPROPID propid, HRESULT hr)
	{
		HRESULT VSL_STDMETHOD_HRESULT = VSL_STDMETHOD_HRESULT_INIT;
		try{

		rItem.SetGuidProperty(propid, GUID_NULL);

		}VSL_STDMETHODCATCH()
		UTCHK(VSL_GET_STDMETHOD_HRESULT() == hr);
	}

	void TestGetPropertyFailed(HierarchyItem& rItem, VSHPROPID propid, HRESULT hr)
	{
		HRESULT VSL_STDMETHOD_HRESULT = VSL_STDMETHOD_HRESULT_INIT;
		try{

		CComVariant var;
		rItem.GetProperty(propid, &var);

		}VSL_STDMETHODCATCH()
		UTCHK(VSL_GET_STDMETHOD_HRESULT() == hr);
	}

	void TestSetPropertyFailed(HierarchyItem& rItem, VSHPROPID propid, HRESULT hr)
	{
		HRESULT VSL_STDMETHOD_HRESULT = VSL_STDMETHOD_HRESULT_INIT;
		try{

		CComVariant var;
		rItem.SetProperty(propid, var);

		}VSL_STDMETHODCATCH()
		UTCHK(VSL_GET_STDMETHOD_HRESULT() == hr);
	}
	VsHierarchyItemBaseTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{

		HierarchyRoot root;
		HierarchyItem::Base& rRootBase = root;
		HierarchyItem& item1 = root; 
		HierarchyItem item11(rRootBase);
		HierarchyItem::Base& ritem11Base = item11;
		VSITEMID itemId11 = reinterpret_cast<VSITEMID>(static_cast<HierarchyItem::ItemInterface*>(&item11));
		HierarchyItem item211(ritem11Base);
		VSITEMID itemId211 = reinterpret_cast<VSITEMID>(static_cast<HierarchyItem::ItemInterface*>(&item211));

// VsHierarchyItemBase::GetGuidProperty

		// VsHierarchyItemBase::GetGuidProperty - VSHPROPID_Parent
		TestGetGuidPropertyFailed(item1, VSHPROPID_Parent, E_UNEXPECTED);

		// VsHierarchyItemBase::GetGuidProperty - VSHPROPID_TypeGuid
#ifdef VSL_TEST_HIERARCHY_METHODS_CALLED
		UTCHK(CLSID_ManualResetEvent == item1.GetGuidProperty(VSHPROPID_TypeGuid));
#else // VSL_TEST_HIERARCHY_METHODS_CALLED
		TestGetGuidPropertyFailed(item1, VSHPROPID_TypeGuid, E_NOTIMPL);
#endif // VSL_TEST_HIERARCHY_METHODS_CALLED

		// VsHierarchyItemBase::GetGuidProperty - VSHPROPID_SaveName
		TestGetGuidPropertyFailed(item1, VSHPROPID_SaveName, E_UNEXPECTED);

		// VsHierarchyItemBase::GetGuidProperty - VSHPROPID_CmdUIGuid
		UTCHK(CLSID_StdEvent == item1.GetGuidProperty(VSHPROPID_CmdUIGuid));

		// VsHierarchyItemBase::GetGuidProperty - VSHPROPID_SelContainer
		TestGetGuidPropertyFailed(item1, VSHPROPID_SelContainer, E_UNEXPECTED);

		// VsHierarchyItemBase::GetGuidProperty - VSHPROPID_PreferredLanguageSID
		TestGetGuidPropertyFailed(item1, VSHPROPID_PreferredLanguageSID, E_NOTIMPL);
		
		// VsHierarchyItemBase::GetGuidProperty - VSHPROPID_ShowProjInSolutionPage
		TestGetGuidPropertyFailed(item1, VSHPROPID_ShowProjInSolutionPage, E_UNEXPECTED);

		// VsHierarchyItemBase::GetGuidProperty - VSHPROPID_ProjectIDGuid
		TestGetGuidPropertyFailed(item1, VSHPROPID_ProjectIDGuid, E_NOTIMPL);
		
		// VsHierarchyItemBase::GetGuidProperty - VSHPROPID_DesignerVariableNaming
		TestGetGuidPropertyFailed(item1, VSHPROPID_DesignerVariableNaming, E_UNEXPECTED);

// VsHierarchyItemBase::SetGuidProperty

		// VsHierarchyItemBase::SetGuidProperty - VSHPROPID_Parent
		TestSetGuidPropertyFailed(item1, VSHPROPID_Parent, E_UNEXPECTED);

		// VsHierarchyItemBase::SetGuidProperty - VSHPROPID_TypeGuid
		TestSetGuidPropertyFailed(item1, VSHPROPID_TypeGuid, E_NOTIMPL);

		// VsHierarchyItemBase::SetGuidProperty - VSHPROPID_SaveName
		TestSetGuidPropertyFailed(item1, VSHPROPID_SaveName, E_UNEXPECTED);

		// VsHierarchyItemBase::SetGuidProperty - VSHPROPID_CmdUIGuid
		TestSetGuidPropertyFailed(item1, VSHPROPID_CmdUIGuid, E_NOTIMPL);

		// VsHierarchyItemBase::SetGuidProperty - VSHPROPID_SelContainer
		TestSetGuidPropertyFailed(item1, VSHPROPID_SelContainer, E_UNEXPECTED);

		// VsHierarchyItemBase::SetGuidProperty - VSHPROPID_PreferredLanguageSID
		TestSetGuidPropertyFailed(item1, VSHPROPID_PreferredLanguageSID, E_NOTIMPL);
		
		// VsHierarchyItemBase::SetGuidProperty - VSHPROPID_ShowProjInSolutionPage
		TestSetGuidPropertyFailed(item1, VSHPROPID_ShowProjInSolutionPage, E_UNEXPECTED);

		// VsHierarchyItemBase::SetGuidProperty - VSHPROPID_ProjectIDGuid
		TestSetGuidPropertyFailed(item1, VSHPROPID_ProjectIDGuid, E_NOTIMPL);
		
		// VsHierarchyItemBase::SetGuidProperty - VSHPROPID_DesignerVariableNaming
		TestSetGuidPropertyFailed(item1, VSHPROPID_DesignerVariableNaming, E_UNEXPECTED);

// VsHierarchyItemBase::GetProperty

		// VsHierarchyItemBase::GetProperty - VSHPROPID_Parent
		{
		CComVariant var;
		item11.GetProperty(VSHPROPID_Parent, &var);
		UTCHK(static_cast<VSITEMID>(var.intVal) == VSITEMID_ROOT);
		}

		{
		CComVariant var;
		item211.GetProperty(VSHPROPID_Parent, &var);
		UTCHK(static_cast<VSITEMID>(var.intVal) == itemId11);
		}

		// VsHierarchyItemBase::GetProperty - VSHPROPID_FirstChild
		{
		CComVariant var;
		item1.GetProperty(VSHPROPID_FirstChild, &var);
		UTCHK(static_cast<VSITEMID>(var.intVal) == itemId11);
		}

		{
		CComVariant var;
		item11.GetProperty(VSHPROPID_FirstChild, &var);
		UTCHK(static_cast<VSITEMID>(var.intVal) == itemId211);
		}
		
		// VsHierarchyItemBase::GetProperty - VSHPROPID_TypeGuid
		TestGetPropertyFailed(item1, VSHPROPID_TypeGuid, E_UNEXPECTED);
		
		// VsHierarchyItemBase::GetProperty - VSHPROPID_SaveName
		TestGetPropertyFailed(item1, VSHPROPID_SaveName, E_NOTIMPL);
		
		// VsHierarchyItemBase::GetProperty - VSHPROPID_Caption
		{
		CComVariant var;
		item1.GetProperty(VSHPROPID_Caption, &var);
		UTCHK(CComBSTR(__WFILE__) == var.bstrVal);
		}

		// VsHierarchyItemBase::GetProperty - VSHPROPID_IconImgList
		TestGetPropertyFailed(item1, VSHPROPID_IconImgList, E_UNEXPECTED);

		// VsHierarchyItemBase::GetProperty - VSHPROPID_IconIndex
		TestGetPropertyFailed(item1, VSHPROPID_IconIndex, DISP_E_MEMBERNOTFOUND);

		// VsHierarchyItemBase::GetProperty - VSHPROPID_Expandable
		{
		CComVariant var;
		item1.GetProperty(VSHPROPID_Expandable, &var);
		UTCHK(var.boolVal == VARIANT_TRUE);
		}

		{
		CComVariant var;
		item11.GetProperty(VSHPROPID_Expandable, &var);
		UTCHK(var.boolVal == VARIANT_TRUE);
		}

		{
		CComVariant var;
		item211.GetProperty(VSHPROPID_Expandable, &var);
		UTCHK(var.boolVal == VARIANT_FALSE);
		}

		// VsHierarchyItemBase::GetProperty - VSHPROPID_ExpandByDefault
		{
		CComVariant var;
		item1.GetProperty(VSHPROPID_ExpandByDefault, &var);
		UTCHK(var.boolVal == VARIANT_TRUE);
		}

		{
		CComVariant var;
		item11.GetProperty(VSHPROPID_ExpandByDefault, &var);
		UTCHK(var.boolVal == VARIANT_FALSE);
		}

		{
		CComVariant var;
		item211.GetProperty(VSHPROPID_ExpandByDefault, &var);
		UTCHK(var.boolVal == VARIANT_FALSE);
		}

		// VsHierarchyItemBase::GetProperty - VSHPROPID_Name
#ifdef VSL_TEST_HIERARCHY_METHODS_CALLED
		{
		CComVariant var;
		item1.GetProperty(VSHPROPID_Name, &var);
		UTCHK(CComBSTR(__WFILE__) == var.bstrVal);
		}
#else // VSL_TEST_HIERARCHY_METHODS_CALLED
		TestGetPropertyFailed(item1, VSHPROPID_Name, E_NOTIMPL);
#endif // VSL_TEST_HIERARCHY_METHODS_CALLED

		// VsHierarchyItemBase::GetProperty - VSHPROPID_IconHandle
		TestGetPropertyFailed(item1, VSHPROPID_IconHandle, DISP_E_MEMBERNOTFOUND);

		// VsHierarchyItemBase::GetProperty - VSHPROPID_OpenFolderIconHandle
		TestGetPropertyFailed(item1, VSHPROPID_OpenFolderIconHandle, DISP_E_MEMBERNOTFOUND);

		// VsHierarchyItemBase::GetProperty - VSHPROPID_CmdUIGuid
		TestGetPropertyFailed(item1, VSHPROPID_CmdUIGuid, E_UNEXPECTED);

		// VsHierarchyItemBase::GetProperty - VSHPROPID_SelContainer
		TestGetPropertyFailed(item1, VSHPROPID_SelContainer, E_NOTIMPL);

		// VsHierarchyItemBase::GetProperty - VSHPROPID_BrowseObject
		TestGetPropertyFailed(item1, VSHPROPID_BrowseObject, E_NOTIMPL);

		// VsHierarchyItemBase::GetProperty - VSHPROPID_UserContext
		TestGetPropertyFailed(item1, VSHPROPID_UserContext, E_NOTIMPL);

		// VsHierarchyItemBase::GetProperty - VSHPROPID_EditLabel
#ifdef VSL_TEST_HIERARCHY_METHODS_CALLED
		{
		CComVariant var;
		item1.GetProperty(VSHPROPID_EditLabel, &var);
		UTCHK(CComBSTR(__WFILE__) == var.bstrVal);
		}
#else // VSL_TEST_HIERARCHY_METHODS_CALLED
		TestGetPropertyFailed(item1, VSHPROPID_EditLabel, E_NOTIMPL);
#endif // VSL_TEST_HIERARCHY_METHODS_CALLED
		
		// VsHierarchyItemBase::GetProperty - VSHPROPID_ExtObject
		TestGetPropertyFailed(item1, VSHPROPID_ExtObject, E_NOTIMPL);
		
		// VsHierarchyItemBase::GetProperty - VSHPROPID_ExtSelectedItem
		TestGetPropertyFailed(item1, VSHPROPID_ExtSelectedItem, E_NOTIMPL);

		// VsHierarchyItemBase::GetProperty - VSHPROPID_FirstVisibleChild
		{
		CComVariant var;
		item1.GetProperty(VSHPROPID_FirstVisibleChild, &var);
		UTCHK(static_cast<VSITEMID>(var.intVal) == itemId11);
		}

		{
		CComVariant var;
		item11.GetProperty(VSHPROPID_FirstVisibleChild, &var);
		UTCHK(static_cast<VSITEMID>(var.intVal) == itemId211);
		}

		// VsHierarchyItemBase::GetProperty - VSHPROPID_IsHiddenItem
		{
		CComVariant var;
		item11.GetProperty(VSHPROPID_IsHiddenItem, &var);
		UTCHK(var.boolVal == VARIANT_FALSE);
		}
		
		// VsHierarchyItemBase::GetProperty - VSHPROPID_IsNonMemberItem
		TestGetPropertyFailed(item1, VSHPROPID_IsNonMemberItem, E_NOTIMPL);

		// VsHierarchyItemBase::GetProperty - VSHPROPID_PreferredLanguageSID
		TestGetPropertyFailed(item1, VSHPROPID_PreferredLanguageSID, E_UNEXPECTED);

		// VsHierarchyItemBase::GetProperty - VSHPROPID_ShowProjInSolutionPage
		TestGetPropertyFailed(item1, VSHPROPID_ShowProjInSolutionPage, E_NOTIMPL);

		// VsHierarchyItemBase::GetProperty - VSHPROPID_ProjectIDGuid
		TestGetPropertyFailed(item1, VSHPROPID_ProjectIDGuid, E_UNEXPECTED);

		// VsHierarchyItemBase::GetProperty - VSHPROPID_DesignerVariableNaming
		TestGetPropertyFailed(item1, VSHPROPID_DesignerVariableNaming, E_NOTIMPL);

// VsHierarchyItemBase::SetProperty

		// VsHierarchyItemBase::SetProperty - VSHPROPID_Parent
		TestSetPropertyFailed(item1, VSHPROPID_Parent, E_NOTIMPL);

		// VsHierarchyItemBase::SetProperty - VSHPROPID_TypeGuid
		TestSetPropertyFailed(item1, VSHPROPID_TypeGuid, E_UNEXPECTED);

		// VsHierarchyItemBase::SetProperty - VSHPROPID_SaveName
		TestSetPropertyFailed(item1, VSHPROPID_SaveName, E_NOTIMPL);

		// VsHierarchyItemBase::SetProperty - VSHPROPID_CmdUIGuid
		TestSetPropertyFailed(item1, VSHPROPID_CmdUIGuid, E_UNEXPECTED);

		// VsHierarchyItemBase::SetProperty - VSHPROPID_SelContainer
		TestSetPropertyFailed(item1, VSHPROPID_SelContainer, E_NOTIMPL);

		// VsHierarchyItemBase::SetProperty - VSHPROPID_EditLabel
#ifdef VSL_TEST_HIERARCHY_METHODS_CALLED
		{
		CComVariant var(__WFILE__);
		item1.SetProperty(VSHPROPID_EditLabel, var);
		}
#else // VSL_TEST_HIERARCHY_METHODS_CALLED
		TestSetPropertyFailed(item1, VSHPROPID_EditLabel, E_NOTIMPL);
#endif // VSL_TEST_HIERARCHY_METHODS_CALLED

		// VsHierarchyItemBase::SetProperty - VSHPROPID_ExtObject
		TestSetPropertyFailed(item1, VSHPROPID_ExtObject, E_NOTIMPL);

		// VsHierarchyItemBase::SetProperty - VSHPROPID_PreferredLanguageSID
		TestSetPropertyFailed(item1, VSHPROPID_PreferredLanguageSID, E_UNEXPECTED);

		// VsHierarchyItemBase::SetProperty - VSHPROPID_ShowProjInSolutionPage
		TestSetPropertyFailed(item1, VSHPROPID_ShowProjInSolutionPage, E_NOTIMPL);

		// VsHierarchyItemBase::SetProperty - VSHPROPID_ProjectIDGuid
		TestSetPropertyFailed(item1, VSHPROPID_ProjectIDGuid, E_UNEXPECTED);

		// VsHierarchyItemBase::SetProperty - VSHPROPID_DesignerVariableNaming
		TestSetPropertyFailed(item1, VSHPROPID_DesignerVariableNaming, E_NOTIMPL);
	}
};

int _cdecl _tmain()
{
	UTRUN(IVsUIHierarchyImplTest);
	UTRUN(HierarchyNodeStackNodesTest);
	UTRUN(HierarchyNodeHeapNodesTest);
	UTRUN(VsHierarchyRootItemBaseTest);
	UTRUN(VsHierarchyItemBaseTest);
	return VSL::FailureCounter::Get();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\UnitTest\WindowsAndControls\stdafx.cpp ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\UnitTest\Hierarchy\stdafx.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#pragma once

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#pragma warning(disable : 6001 6540 6309 6387)

#define _ATL_NO_HOSTING

#include <atlbase.h>
#include <atlcom.h>
#include <atlstr.h>
#include <atlwin.h>
#include <commctrl.h>

#include <VsShellInterfaces.h>

#define VSLASSERT _ASSERTE
#define VSLASSERTEX(exp, szMsg) _ASSERT_BASE(exp, szMsg)
#define VSLTRACE ATLTRACE

#include "VSLUnitTest.h"
#include "VSLMockSystemInterfaces.h"
#include "VSLMockVisualStudioInterfaces.h"
#include "VSLShortNameDefines.h"
#include <VSLMockIOleCommandTarget.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\UnitTest\MockInterfaces\VisualStudio.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#pragma warning(push)
#pragma warning(disable : 4239) // warning C4239: nonstandard extension used : 'argument' : conversion from <struct> to <struct &>

typedef InterfaceImplList<IVsShellNotImpl, IUnknownInterfaceListTerminatorDefault> IVsShellNotImplInterfaceList;

class IVsShellNotImplMock :
	public COMMockBase<IVsShellNotImplInterfaceList, IVsShellNotImplMock>
{
};

// TODO - this isn't testing that IVsShellNotImpl has a virtual destructor correctly
VSL_DEFINE_VIRTUAL_DESTRUCTOR_TEST_HELPER(IVsShellNotImplMock);

class IVsShellNotImplTest :
	public UnitTestBase
{
public:

	IVsShellNotImplTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
		IVsShellNotImplMock mock;
		IUnknown* pIUnknown = mock.GetIUnknownNoAddRef();
		IVsShell* pIVsShell = NULL;
		UTCHKEX(pIUnknown->QueryInterface(SID_SVsShell, reinterpret_cast<void**>(&pIVsShell)) == S_OK, _T(""));
		UTCHKEX(mock.GetRefCount() == 1, _T("Check AddRef was called before returning IVsShell"));
		UTCHKEX(pIVsShell != NULL, _T("Check pIVsShell isn't still NULL"));

		// TODO - determine if IntelliSense/Class View APIs be used to autogenerate this 
		// (IVsShellNotImpl itself if possible as well)
		if(pIVsShell != NULL)
		{
			UTCHKEX(pIVsShell->GetPackageEnum(0) == E_NOTIMPL, _T(""));
			UTCHKEX(pIVsShell->GetProperty(VSSPROPID(), 0) == E_NOTIMPL, _T(""));
			UTCHKEX(pIVsShell->SetProperty(VSSPROPID(), VARIANT()) == E_NOTIMPL, _T(""));
			UTCHKEX(pIVsShell->AdviseBroadcastMessages(0, 0) == E_NOTIMPL, _T(""));
			UTCHKEX(pIVsShell->UnadviseBroadcastMessages(VSCOOKIE()) == E_NOTIMPL, _T(""));
			UTCHKEX(pIVsShell->AdviseShellPropertyChanges(0, 0) == E_NOTIMPL, _T(""));
			UTCHKEX(pIVsShell->UnadviseShellPropertyChanges(VSCOOKIE()) == E_NOTIMPL, _T(""));
			UTCHKEX(pIVsShell->LoadPackage(GUID(), 0) == E_NOTIMPL, _T(""));
			UTCHKEX(pIVsShell->LoadPackageString(GUID(), 0, 0) == E_NOTIMPL, _T(""));
			UTCHKEX(pIVsShell->LoadUILibrary(GUID(), 0, 0) == E_NOTIMPL, _T(""));
			UTCHKEX(pIVsShell->IsPackageInstalled(GUID(), 0) == E_NOTIMPL, _T(""));
			UTCHKEX(pIVsShell->IsPackageLoaded(GUID(), 0) == E_NOTIMPL, _T(""));
		}

		mock.SetRefCount(0);
	}
};


// TODO - create a unit test just for containers

class StaticArrayTest :
	public UnitTestBase
{
public:

	template <class StaticArray_T>
	void VerifyElementValues(const StaticArray_T& rArray)
	{
		// Since StaticArray isn't designed to be robust against overruns
		// we don't test against that here.
		for(StaticArray_T::Type i = 0; i < StaticArray_T::NumberOfElements; ++i)
		{
			// const Type_T& operator[](size_t i) const
			UTCHKEX(rArray[i] == i+1, _T(""));
		}
	}

	StaticArrayTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
		// default constructor
		StaticArray<int, 2> defaultArray;
		// Type_T& operator[](size_t i)
		defaultArray[0] = 1;
		defaultArray[1] = 2;

		VerifyElementValues(defaultArray);

		// Don't test copy construction, as it isn't intended to be utilized; however,
		// the copy constructor can't be declared private and still allow initialization 
		// via aggregation.

		// Don't test direct access of the public member, as it isn't intended to be
		// utilized; however, member must be public inorder to allow initialization via
		// aggregation

		StaticArray<int, 3> initializedArray =
		{
			{
				1,
				2,
				3
			}
		};

		VerifyElementValues(initializedArray);

	}
};

typedef InterfaceImplList<IVsUIShellNotImpl, IUnknownInterfaceListTerminatorDefault> IVsUIShellNotImplInterfaceList;

VSL_DECLARE_COM_MOCK(IVsUIShellNotImplMock, IVsUIShellNotImplInterfaceList){};

class IVsUIShellNotImplTest :
	public UnitTestBase
{
public:

	IVsUIShellNotImplTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
		IVsUIShellNotImplMock mock;
		IUnknown* pIUnknown = mock.GetIUnknownNoAddRef();
		IVsUIShell* pIVsUIShell = NULL;
		UTCHK(pIUnknown->QueryInterface(__uuidof(IVsUIShell), reinterpret_cast<void**>(&pIVsUIShell)) == S_OK);
		UTCHKEX(mock.GetRefCount() == 1, _T("Check AddRef was called before returning IVsUIShell"));
		UTCHKEX(pIVsUIShell != NULL, _T("Check pIVsUIShell isn't still NULL"));

		if(pIVsUIShell != NULL)
		{
			UTCHK(pIVsUIShell->GetToolWindowEnum(
				NULL) == E_NOTIMPL);

			UTCHK(pIVsUIShell->GetDocumentWindowEnum(
				NULL) == E_NOTIMPL);

			UTCHK(pIVsUIShell->FindToolWindow(
				VSFINDTOOLWIN(),
				GUID(),
				NULL) == E_NOTIMPL);

			UTCHK(pIVsUIShell->CreateToolWindow(
				VSCREATETOOLWIN(),
				DWORD(),
				NULL,
				GUID(),
				GUID(),
				GUID(),
				NULL,
				LPCOLESTR(),
				NULL,
				NULL) == E_NOTIMPL);

			UTCHK(pIVsUIShell->CreateDocumentWindow(
				VSCREATEDOCWIN(),
				LPCOLESTR(),
				NULL,
				VSITEMID(),
				NULL,
				NULL,
				GUID(),
				LPCOLESTR(),
				GUID(),
				NULL,
				LPCOLESTR(),
				LPCOLESTR(),
				NULL,
				NULL) == E_NOTIMPL);

			UTCHK(pIVsUIShell->SetErrorInfo(
				HRESULT(),
				LPCOLESTR(),
				DWORD(),
				LPCOLESTR(),
				LPCOLESTR()) == E_NOTIMPL);

			UTCHK(pIVsUIShell->ReportErrorInfo(
				HRESULT()) == E_NOTIMPL);

			UTCHK(pIVsUIShell->GetDialogOwnerHwnd(
				NULL) == E_NOTIMPL);

			UTCHK(pIVsUIShell->EnableModeless(
				BOOL()) == E_NOTIMPL);

			UTCHK(pIVsUIShell->SaveDocDataToFile(
				VSSAVEFLAGS(),
				NULL,
				LPCOLESTR(),
				NULL,
				NULL) == E_NOTIMPL);

			UTCHK(pIVsUIShell->SetupToolbar(
				HWND(),
				NULL,
				NULL) == E_NOTIMPL);

			UTCHK(pIVsUIShell->SetForegroundWindow() == E_NOTIMPL);

			UTCHK(pIVsUIShell->TranslateAcceleratorAsACmd(
				LPMSG()) == E_NOTIMPL);

			UTCHK(pIVsUIShell->UpdateCommandUI(
				BOOL()) == E_NOTIMPL);

			UTCHK(pIVsUIShell->UpdateDocDataIsDirtyFeedback(
				VSCOOKIE(),
				BOOL()) == E_NOTIMPL);

			UTCHK(pIVsUIShell->RefreshPropertyBrowser(
				DISPID()) == E_NOTIMPL);

			UTCHK(pIVsUIShell->SetWaitCursor() == E_NOTIMPL);

			UTCHK(pIVsUIShell->PostExecCommand(
				NULL,
				DWORD(),
				DWORD(),
				NULL) == E_NOTIMPL);

			UTCHK(pIVsUIShell->ShowContextMenu(
				DWORD(),
				GUID(),
				LONG(),
				POINTS(),
				NULL) == E_NOTIMPL);

			UTCHK(pIVsUIShell->ShowMessageBox(
				DWORD(),
				GUID(),
				LPOLESTR(),
				LPOLESTR(),
				LPOLESTR(),
				DWORD(),
				OLEMSGBUTTON(),
				OLEMSGDEFBUTTON(),
				OLEMSGICON(),
				BOOL(),
				NULL) == E_NOTIMPL);

			UTCHK(pIVsUIShell->SetMRUComboText(
				NULL,
				DWORD(),
				LPSTR(),
				BOOL()) == E_NOTIMPL);

			UTCHK(pIVsUIShell->SetToolbarVisibleInFullScreen(
				NULL,
				DWORD(),
				BOOL()) == E_NOTIMPL);

			UTCHK(pIVsUIShell->FindToolWindowEx(
				VSFINDTOOLWIN(),
				GUID(),
				DWORD(),
				NULL) == E_NOTIMPL);

			UTCHK(pIVsUIShell->GetAppName(
				NULL) == E_NOTIMPL);

			UTCHK(pIVsUIShell->GetVSSysColor(
				VSSYSCOLOR(),
				NULL) == E_NOTIMPL);

			UTCHK(pIVsUIShell->SetMRUComboTextW(
				NULL,
				DWORD(),
				LPWSTR(),
				BOOL()) == E_NOTIMPL);

			UTCHK(pIVsUIShell->PostSetFocusMenuCommand(
				NULL,
				DWORD()) == E_NOTIMPL);

			UTCHK(pIVsUIShell->GetCurrentBFNavigationItem(
				NULL,
				NULL,
				NULL) == E_NOTIMPL);

			UTCHK(pIVsUIShell->AddNewBFNavigationItem(
				NULL,
				BSTR(),
				NULL,
				BOOL()) == E_NOTIMPL);

			UTCHK(pIVsUIShell->OnModeChange(
				DBGMODE()) == E_NOTIMPL);

			UTCHK(pIVsUIShell->GetErrorInfo(
				NULL) == E_NOTIMPL);

			UTCHK(pIVsUIShell->GetOpenFileNameViaDlg(
				NULL) == E_NOTIMPL);

			UTCHK(pIVsUIShell->GetSaveFileNameViaDlg(
				NULL) == E_NOTIMPL);

			UTCHK(pIVsUIShell->GetDirectoryViaBrowseDlg(
				NULL) == E_NOTIMPL);

			UTCHK(pIVsUIShell->CenterDialogOnWindow(
				HWND(),
				HWND()) == E_NOTIMPL);

			UTCHK(pIVsUIShell->GetPreviousBFNavigationItem(
				NULL,
				NULL,
				NULL) == E_NOTIMPL);

			UTCHK(pIVsUIShell->GetNextBFNavigationItem(
				NULL,
				NULL,
				NULL) == E_NOTIMPL);

			UTCHK(pIVsUIShell->GetURLViaDlg(
				LPCOLESTR(),
				LPCOLESTR(),
				LPCOLESTR(),
				NULL) == E_NOTIMPL);

			UTCHK(pIVsUIShell->RemoveAdjacentBFNavigationItem(
				RemoveBFDirection()) == E_NOTIMPL);

			UTCHK(pIVsUIShell->RemoveCurrentNavigationDupes(
				RemoveBFDirection()) == E_NOTIMPL);
		}

		mock.SetRefCount(0);
	}
};

// Test the mock object for IVsOutputWindowPane

typedef InterfaceImplList<IVsOutputWindowPaneNotImpl, IUnknownInterfaceListTerminatorDefault> IVsOutputWindowPaneNotImplInterfaceList;

class IVsOutputWindowPaneNotImplMock :
	public COMMockBase<IVsOutputWindowPaneNotImplInterfaceList, IVsOutputWindowPaneNotImplMock>
{
};

VSL_DEFINE_VIRTUAL_DESTRUCTOR_TEST_HELPER(IVsOutputWindowPaneNotImplMock);

class IVsOutputWindowPaneNotImplTest :
	public UnitTestBase
{
public:

	IVsOutputWindowPaneNotImplTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
        IVsOutputWindowPaneNotImplMock mock;
        {
	        IUnknown* pIUnknown = mock.GetIUnknownNoAddRef();
            CComPtr<IVsOutputWindowPane> srpOutputWindow;
            // Check the implementation of IUnknown.
            UTCHK(SUCCEEDED(pIUnknown->QueryInterface(__uuidof(IVsOutputWindowPane), (void**)&srpOutputWindow)));
            UTCHK(1 == mock.GetRefCount());
            UTCHK(srpOutputWindow);
            if (srpOutputWindow)
            {
                // Now check that every method returns E_NOTIMPL;
                UTCHK(E_NOTIMPL == srpOutputWindow->Activate());
                UTCHK(E_NOTIMPL == srpOutputWindow->Clear());
                UTCHK(E_NOTIMPL == srpOutputWindow->FlushToTaskList());
                UTCHK(E_NOTIMPL == srpOutputWindow->GetName(NULL));
                UTCHK(E_NOTIMPL == srpOutputWindow->Hide());
                UTCHK(E_NOTIMPL == srpOutputWindow->OutputString(NULL));
                UTCHK(E_NOTIMPL == srpOutputWindow->OutputStringThreadSafe(NULL));
                UTCHK(E_NOTIMPL == srpOutputWindow->OutputTaskItemString(NULL, (VSTASKPRIORITY)0, (VSTASKCATEGORY)0, NULL, 0, NULL, 0, NULL));
                UTCHK(E_NOTIMPL == srpOutputWindow->OutputTaskItemStringEx(NULL, (VSTASKPRIORITY)0, (VSTASKCATEGORY)0, NULL, 0, NULL, 0, NULL, NULL));
                UTCHK(E_NOTIMPL == srpOutputWindow->SetName(NULL));
            }
        }
    }
};

typedef InterfaceImplList<IVsWindowFrameNotImpl, IUnknownInterfaceListTerminatorDefault> IVsWindowFrameNotImplInterfaceList;

VSL_DECLARE_COM_MOCK(IVsWindowFrameNotImplMock, IVsWindowFrameNotImplInterfaceList){};

class IVsWindowFrameNotImplTest :
	public UnitTestBase
{
public:

	IVsWindowFrameNotImplTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
		IVsWindowFrameNotImplMock mock;
		IUnknown* pIUnknown = mock.GetIUnknownNoAddRef();
		IVsWindowFrame* pIVsWindowFrame = NULL;
		UTCHK(pIUnknown->QueryInterface(__uuidof(IVsWindowFrame), reinterpret_cast<void**>(&pIVsWindowFrame)) == S_OK);
		UTCHKEX(mock.GetRefCount() == 1, _T("Check AddRef was called before returning IVsWindowFrame"));
		UTCHKEX(pIVsWindowFrame != NULL, _T("Check pIVsWindowFrame isn't still NULL"));

		if(pIVsWindowFrame != NULL)
		{
			UTCHK(pIVsWindowFrame->Show() == E_NOTIMPL);
		    
			UTCHK(pIVsWindowFrame->Hide() == E_NOTIMPL);
		    
			UTCHK(pIVsWindowFrame->IsVisible() == E_NOTIMPL);
		    
			UTCHK(pIVsWindowFrame->ShowNoActivate() == E_NOTIMPL);
		    
			UTCHK(pIVsWindowFrame->CloseFrame(FRAMECLOSE()) == E_NOTIMPL);
		    
			UTCHK(pIVsWindowFrame->SetFramePos( 
				VSSETFRAMEPOS(),
				GUID_NULL,
				0,
				0,
				0,
				0) == E_NOTIMPL);
		    
			UTCHK(pIVsWindowFrame->GetFramePos( 
				NULL,
				NULL,
				NULL,
				NULL,
				NULL,
				NULL) == E_NOTIMPL);
		    
			UTCHK(pIVsWindowFrame->GetProperty( 
				VSFPROPID(),
				NULL) == E_NOTIMPL);
		    
			UTCHK(pIVsWindowFrame->SetProperty( 
				VSFPROPID(),
				VARIANT()) == E_NOTIMPL);
		    
			UTCHK(pIVsWindowFrame->GetGuidProperty( 
				VSFPROPID(),
				NULL) == E_NOTIMPL);
		    
			UTCHK(pIVsWindowFrame->SetGuidProperty( 
				VSFPROPID(),
				GUID_NULL) == E_NOTIMPL);
		    
			UTCHK(pIVsWindowFrame->QueryViewInterface( 
				GUID_NULL,
				NULL) == E_NOTIMPL);
		    
			UTCHK(pIVsWindowFrame->IsOnScreen( 
				NULL) == E_NOTIMPL);
		}

		mock.SetRefCount(0);
	}
};

typedef InterfaceImplList<IVsWindowFrame2NotImpl, IUnknownInterfaceListTerminatorDefault> IVsWindowFrame2NotImplInterfaceList;
VSL_DECLARE_COM_MOCK(IVsWindowFrame2NotImplMock, IVsWindowFrame2NotImplInterfaceList){};

class IVsWindowFrame2NotImplTest :
	public UnitTestBase
{
public:

	IVsWindowFrame2NotImplTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
		IVsWindowFrame2NotImplMock mock;
		IUnknown* pIUnknown = mock.GetIUnknownNoAddRef();
		CComPtr<IVsWindowFrame2> spIVsWindowFrame = NULL;
		UTCHK(pIUnknown->QueryInterface(__uuidof(IVsWindowFrame2), reinterpret_cast<void**>(&spIVsWindowFrame)) == S_OK);
		UTCHKEX(mock.GetRefCount() == 1, _T("Check AddRef was called before returning IVsWindowFrame"));
		UTCHKEX(spIVsWindowFrame != NULL, _T("Check pIVsWindowFrame isn't still NULL"));

		if(spIVsWindowFrame != NULL)
		{
			UTCHK(E_NOTIMPL == spIVsWindowFrame->Advise(NULL, NULL));
			UTCHK(E_NOTIMPL == spIVsWindowFrame->Unadvise(0));
			UTCHK(E_NOTIMPL == spIVsWindowFrame->ActivateOwnerDockedWindow());
		}
	}
};

class IProfferServiceNotImplTest :
	public IProfferServiceNotImpl,
	public UnitTestBase
{
public:

VSL_DEFINE_IUNKNOWN_NOTIMPL

	IProfferServiceNotImplTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
		UTCHK(E_NOTIMPL == ProfferService(GUID_NULL, NULL, NULL));
		UTCHK(E_NOTIMPL == RevokeService(0));
	}
};

#pragma warning(pop)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\UnitTest\Package\Package.cpp ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#include "stdafx.h"
#include "resource.h"

#include "VSLShortNameDefines.h"
#include "VSLPackage.h"
// TODO - 3/2/2006 - make a better home the automation unit tests
#include "VSLAutomation.h"

#include "Package.h"

using namespace VSL;

EXTERN_C const GUID g_FakeServiceGUID;
EXTERN_C const CComBSTR g_FakeString;

typedef PointerWithNullDefault<void> VoidPointerWithNullDefault;

class PointerWithNullDefaultTest :
	public UnitTestBase
{
public:
	PointerWithNullDefaultTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
		VoidPointerWithNullDefault::Type pVoid = VoidPointerWithNullDefault::GetDefault();
		UTCHKEX(pVoid == NULL, L"pVoid is NULL after being set to the default");
	}
};

template <class Cache_T>
class CacheTestBase :
	public UnitTestBase
{
protected:
	void CheckCacheValue(Cache_T &cache, void* pVoid)
	{
		const Cache_T& rCache = cache;
		const Cache_T::CachedType& crpVoid = rCache.Get();
		UTCHK(crpVoid == pVoid);
		Cache_T::CachedType& rpVoid = cache.Get();
		UTCHK(rpVoid == pVoid);
	}
public:
	CacheTestBase(const char* const szTestName):
		UnitTestBase(szTestName)
	{
	}
};

typedef LocalCache<VoidPointerWithNullDefault> LocalCacheOfVoidPointer;
class LocalCacheTest :
	public CacheTestBase<LocalCacheOfVoidPointer>
{
public:
	LocalCacheTest(_In_opt_ const char* const szTestName):
		CacheTestBase(szTestName)
	{
		LocalCacheOfVoidPointer cache;
		CheckCacheValue(cache, NULL);
		void* pVoid = reinterpret_cast<void*>(1);
		cache.Set(pVoid);
		CheckCacheValue(cache, pVoid);

		// Make sure the cache is not global
		LocalCacheOfVoidPointer cache2;
		CheckCacheValue(cache2, NULL);
	}
};

typedef GlobalCache<VoidPointerWithNullDefault> GlobalCacheOfVoidPointer;
class GlobalCacheTest :
	public CacheTestBase<GlobalCacheOfVoidPointer>
{
public:
	GlobalCacheTest(_In_opt_ const char* const szTestName):
		CacheTestBase(szTestName)
	{
		GlobalCacheOfVoidPointer cache;
		CheckCacheValue(cache, NULL);
		void* pVoid = reinterpret_cast<void*>(1);
		cache.Set(pVoid);
		CheckCacheValue(cache, pVoid);

		// Make sure the cache is global
		GlobalCacheOfVoidPointer cache2;
		CheckCacheValue(cache2, pVoid);
	}
};

class GlobalRefCountTest :
	public UnitTestBase
{
public:
	GlobalRefCountTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
		UTCHK(GlobalRefCount<int>::Get() == 0);
		UTCHK(GlobalRefCount<int>::CanIncrement() == true);
		UTCHK(GlobalRefCount<int>::CanDecrement() == false);
		++GlobalRefCount<int>::Get();
		UTCHK(GlobalRefCount<int>::Get() == 1);
		GlobalRefCount<int>::Count& iCount = GlobalRefCount<int>::Get();
		iCount -= 2;
		UTCHK(GlobalRefCount<int>::CanIncrement() == false);
		UTCHK(GlobalRefCount<int>::CanDecrement() == true);
		// Now make sure the values are unique by type
		UTCHK(GlobalRefCount<long>::Get() == 0);

		VSL_STDMETHODTRY{

		GlobalRefCount<int>::ErrorIfCanNotIncrement();

		}VSL_STDMETHODCATCH()

		UTCHK(VSL_GET_STDMETHOD_HRESULT() == E_UNEXPECTED);
	}
};

class IVsPackageEnumsCompileTest :
	public UnitTestBase
{
public:
	IVsPackageEnumsCompileTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
		IVsPackageEnums::SetSiteResult values[] =
		{
			IVsPackageEnums::NothingCached,
			IVsPackageEnums::Cached,
			IVsPackageEnums::AlreadyCached,
			IVsPackageEnums::Cleared
		};
		C_ASSERT(ARRAYSIZE(values) == IVsPackageEnums::Cleared+1);
		(values);
	}
};

// NOTE - Unit tests for IServiceProviderRefCountGlobal and IServiceProviderRefCountNotImplemented
// are ommited, as they have trivial implementations and are fully tested by the unit tests for 
// IServiceProviderLocalCache and IServiceProviderGlobalCache

VSL_DEFINE_SERVICE_MOCK(IVsShellServiceMock, IVsShellNotImpl);
VSL_DEFINE_SERVICE_MOCK(IVsUIShellServiceMock, IVsUIShellNotImpl);

typedef ServiceList<IVsShellServiceMock, ServiceList<IVsUIShellServiceMock, ServiceListTerminator> > IServiceProviderServiceList;
typedef InterfaceImplList<VSL::IServiceProviderImpl<IServiceProviderServiceList>, IUnknownInterfaceListTerminator<IServiceProvider> > IServiceProviderMockInterfaceList;

VSL_DECLARE_COM_MOCK(IServiceProviderMock, IServiceProviderMockInterfaceList){};

class IServiceProviderLocalCacheTest :
	public UnitTestBase
{
private:
	void CycleStates(IServiceProviderLocalCache& cache)
	{
		IServiceProviderMock mock;
		CComQIPtr<IServiceProvider> spIServiceProvider = mock.GetIUnknownNoAddRef();
		UTCHKEX(cache.SetSite(NULL) == IVsPackageEnums::NothingCached, NULL);
		UTCHKEX(cache.SetSite(spIServiceProvider) == IVsPackageEnums::Cached, NULL);
		UTCHKEX(cache.SetSite(spIServiceProvider) == IVsPackageEnums::AlreadyCached, NULL);
		UTCHKEX(cache.SetSite(NULL) == IVsPackageEnums::Cleared, NULL);
	}
public:
	IServiceProviderLocalCacheTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
		// This needs to come before the cache decleration, so they get destructed in the correct order
		IServiceProviderMock mock;

		IServiceProviderLocalCache cache;
		// Cycle the states twice to make sure it doesn't break after just one cycle
		CycleStates(cache);
		CycleStates(cache);

		// Test the destructor, which should release this
		// (if not IServiceProviderMock's parent's destructor will complain)
		CComQIPtr<IServiceProvider> spIServiceProvider = mock.GetIUnknownNoAddRef();
		UTCHKEX(cache.SetSite(spIServiceProvider) == IVsPackageEnums::Cached, NULL);
	}
};

class IServiceProviderGlobalCacheTest :
	public UnitTestBase
{
private:
	void CycleStates(IServiceProviderGlobalCache& cache)
	{
		IServiceProviderMock mock;
		CComQIPtr<IServiceProvider> spIServiceProvider = mock.GetIUnknownNoAddRef();
		UTCHK(cache.SetSite(NULL) == IVsPackageEnums::NothingCached);
		UTCHK(cache.SetSite(spIServiceProvider) == IVsPackageEnums::Cached);
		UTCHK(cache.SetSite(spIServiceProvider) == IVsPackageEnums::AlreadyCached);
		UTCHK(cache.SetSite(NULL) == IVsPackageEnums::NothingCached);
		UTCHK(cache.SetSite(NULL) == IVsPackageEnums::Cleared);
	}

	void CycleStates2(IServiceProviderGlobalCache& cache1, IServiceProviderGlobalCache& cache2)
	{
		IServiceProviderMock mock;
		CComQIPtr<IServiceProvider> spIServiceProvider = mock.GetIUnknownNoAddRef();
		UTCHK(cache1.SetSite(NULL) == IVsPackageEnums::NothingCached);
		UTCHK(cache2.SetSite(spIServiceProvider) == IVsPackageEnums::Cached);
		UTCHK(cache1.SetSite(spIServiceProvider) == IVsPackageEnums::AlreadyCached);
		UTCHK(cache2.SetSite(NULL) == IVsPackageEnums::NothingCached);
		UTCHK(cache1.SetSite(NULL) == IVsPackageEnums::Cleared);
	}
public:
	IServiceProviderGlobalCacheTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
		IServiceProviderGlobalCache cache;
		// Cycle the states twice to make sure it doesn't break after just one cycle
		CycleStates(cache);
		CycleStates(cache);

		// Now introduce a second cache, and cycle the states using both instances
		// but swap the roles the second time through.  Repeat the process twice,
		// just to make sure.
		IServiceProviderGlobalCache cache2;
		CycleStates2(cache, cache2);
		CycleStates2(cache2, cache);
		CycleStates2(cache, cache2);
		CycleStates2(cache2, cache);
	}
};

// NOTE - Unit tests for CommonServiceCacheGlobal and CommonServiceCacheLocal are ommited, as they
// are fully tested by the unit tests for VsSiteCacheTestGlobal and VsSiteCacheTestLocal

class GeneralServiceCacheLocalNotImplementedTest :
	public UnitTestBase
{
public:
	GeneralServiceCacheLocalNotImplementedTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
		GeneralServiceCacheNotImplemented cache;

		IServiceProviderMock mock;
		CComQIPtr<IVsShell> spIVsShell = mock.GetIUnknownNoAddRef();

		__if_exists(GeneralServiceCacheNotImplemented::Put)
		{
			C_ASSERT(false); // Should not implement Put
		}
		UTCHK((cache.Get<IVsShell, SID_SVsShell>() == NULL));
		cache.Clear();
	}
};


template <class VSSiteCache_T>
class VsSiteCacheTest :
	public UnitTestBase
{
protected:

	void CheckUnsited(VSSiteCache_T& cache)
	{
		UTCHK(cache.GetSite() == NULL);

		CComPtr<IVsShell> spIVsShell;
		UTCHK(cache.QueryService(SID_SVsShell, &spIVsShell) == E_UNEXPECTED);

		CComPtr<IVsShell> spIVsShellCached;
		UTCHK((cache.QueryCachedService<IVsShell, SID_SVsShell>(&spIVsShellCached) == E_UNEXPECTED));
		UTCHK((spIVsShellCached == NULL));
		UTCHK((cache.GetCachedService<IVsShell, SID_SVsShell>() == NULL));
	}

	template <class Interface_T, REFGUID Service_T>
	void CheckQS(VSSiteCache_T& cache)
	{
		CComPtr<Interface_T> spInterface;
		UTCHK(cache.QueryService(Service_T, &spInterface) == S_OK);
		UTCHK(spInterface != NULL);
		
		spInterface.Release();
		UTCHK(SUCCEEDED((cache.QueryCachedService<Interface_T, Service_T>(&spInterface))));
		UTCHK(spInterface != NULL);
		UTCHK((spInterface = cache.GetCachedService<Interface_T, Service_T>()) != NULL);
	}

	void CheckAlreadySited(VSSiteCache_T& cache, IServiceProvider* pServiceProvider)
	{
		UTCHK(cache.GetSite() == pServiceProvider);

		IUnknown* pIUnknown;
		UTCHK(cache.QueryService(g_FakeServiceGUID, &pIUnknown) == E_NOINTERFACE);

		IUnknown* pIUnknownCached;
		UTCHK((cache.QueryCachedService<IUnknown, GUID_NULL>(&pIUnknownCached) == E_NOINTERFACE));
		UTCHK((pIUnknownCached == NULL));
		UTCHK((cache.GetCachedService<IUnknown, GUID_NULL>() == NULL));

		CheckQS<IVsShell, SID_SVsShell>(cache);
		CheckQS<IVsUIShell, SID_SVsUIShell>(cache);
	}

	void CheckSited(VSSiteCache_T& cache)
	{
		IServiceProviderMock mock;
		CComQIPtr<IServiceProvider> spIServiceProvider = mock.GetIUnknownNoAddRef();

		cache.SetSite(spIServiceProvider);

		CheckAlreadySited(cache, spIServiceProvider);

		cache.SetSite(NULL);
	}

public:
	VsSiteCacheTest(const char* const szTestName):
		UnitTestBase(szTestName)
	{
		VSSiteCache_T cache;
		CheckUnsited(cache);
		cache.SetSite(NULL);
		CheckUnsited(cache);

		// Cycle the state twice to make sure it doesn't breack after just one cycle
		CheckSited(cache);
		CheckUnsited(cache);
		CheckSited(cache);
		CheckUnsited(cache);
	}
};

class VsSiteCacheGlobalTest :
	public VsSiteCacheTest<VsSiteCacheGlobal>
{
public:
	VsSiteCacheGlobalTest(_In_opt_ const char* const szTestName):
		VsSiteCacheTest(szTestName)
	{
		VsSiteCacheGlobal cache1;

		VsSiteCacheGlobal cache2;
		IServiceProviderMock mock;
		CComQIPtr<IServiceProvider> spIServiceProvider = mock.GetIUnknownNoAddRef();
		cache2.SetSite(spIServiceProvider);
		CheckAlreadySited(cache2, spIServiceProvider);

		// Make sure a the first global cache, which was not sited, is sited after the second is sited
		CheckAlreadySited(cache1, spIServiceProvider);

		// Make sure a new third global cache is sited after the second is sited
		VsSiteCacheGlobal cache3;
		CheckAlreadySited(cache3, spIServiceProvider);

		// Unsite through the third
		cache3.SetSite(NULL);

		// Make sure all three are now unsited
		CheckUnsited(cache1);
		CheckUnsited(cache2);
		CheckUnsited(cache3);
	}
};

class VsSiteCacheLocalTest :
	public VsSiteCacheTest<VsSiteCacheLocal>
{
public:
	VsSiteCacheLocalTest(_In_opt_ const char* const szTestName):
		VsSiteCacheTest(szTestName)
	{
		VsSiteCacheLocal cache1;

		VsSiteCacheLocal cache2;
		IServiceProviderMock mock;
		CComQIPtr<IServiceProvider> spIServiceProvider = mock.GetIUnknownNoAddRef();
		cache2.SetSite(spIServiceProvider);
		CheckAlreadySited(cache2, spIServiceProvider);

		// Make sure the first Local cache, which was not sited, is still not sited after the second is sited
		CheckUnsited(cache1);

		// Make sure a new third Local cache is not sited now that one is sited
		VsSiteCacheLocal cache3;
		CheckUnsited(cache3);

		// Unsite the second
		cache2.SetSite(NULL);
		CheckUnsited(cache2);
	}
};

class VsIServiceProviderUtilitiesTest :
	public UnitTestBase
{
	void CheckUnsited()
	{
		CComPtr<IVsShell> spIVsShell;
		UTCHK(VsIServiceProviderUtilities<>::QueryService(
			SID_SVsShell,
			&spIVsShell) == E_UNEXPECTED);
		CComPtr<IVsShell> spIVsShellCached;
		UTCHK((VsIServiceProviderUtilities<>::QueryCachedService<IVsShell, SID_SVsShell>(&spIVsShellCached) == E_UNEXPECTED));
		UTCHK((spIVsShellCached == NULL));
		UTCHK((VsIServiceProviderUtilities<>::GetCachedService<IVsShell, SID_SVsShell>() == NULL));
	}
	template <class Interface_T, REFGUID Service_T>
	void CheckQS()
	{
		CComPtr<Interface_T> spInterface;
		UTCHK(VsIServiceProviderUtilities<>::QueryService(
			__uuidof(Interface_T),
			&spInterface) == S_OK);
		UTCHK(spInterface != NULL);
		
		spInterface.Release();
		UTCHK(SUCCEEDED((VsIServiceProviderUtilities<>::QueryCachedService<Interface_T, Service_T>(&spInterface))));
		UTCHK(spInterface != NULL);
		UTCHK((spInterface = VsIServiceProviderUtilities<>::GetCachedService<Interface_T, Service_T>()) != NULL);

		spInterface = NULL;
		UTCHK(VSQS(
			__uuidof(Interface_T),
			&spInterface) == S_OK);
		UTCHK(spInterface != NULL);
		spInterface.Release();
		UTCHK(SUCCEEDED((VSQCS(Service_T, Interface_T, &spInterface))));
		UTCHK(spInterface != NULL);
	}
public:
	VsIServiceProviderUtilitiesTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
		CheckUnsited();

		VsSiteCacheGlobal cache;
		IServiceProviderMock mock;
		CComQIPtr<IServiceProvider> spIServiceProvider = mock.GetIUnknownNoAddRef();
		cache.SetSite(spIServiceProvider);

		CheckQS<IVsShell, SID_SVsShell>();
		CheckQS<IVsUIShell, SID_SVsUIShell>();

		cache.SetSite(NULL);
		CheckUnsited();
	}
};

#define RegPartSoftware L"Software"
#define RegPartMicrosoft L"Microsoft"
#define RegPartVisualStudio L"VisualStudio"
#define RegPartConfiguration L"Configuration"
#define MockRegRoot RegPartSoftware L"\\" RegPartMicrosoft L"\\" RegPartVisualStudio

class VsRegistryUtilitiesTest :
	public UnitTestBase
{
public:
	static const CComBSTR& GetRootBeginControlValue(bool isRanu = false)
	{
		static const CComBSTR bstr = 
			L" NoRemove " RegPartSoftware L"\n{\n"
			L" NoRemove " RegPartMicrosoft L"\n{\n"
			L" NoRemove " RegPartVisualStudio L"\n{\n";
		static const CComBSTR bstrRanu = 
			L" NoRemove " RegPartSoftware L"\n{\n"
			L" NoRemove " RegPartMicrosoft L"\n{\n"
			L" NoRemove " RegPartVisualStudio L"\n{\n"
			L" NoRemove " RegPartConfiguration L"\n{\n";
		if(isRanu)
		{
			return bstrRanu;
		}
		else
		{
			return bstr;
		}
	}
	static const CComBSTR& GetRootEndControlValue(bool isRanu = false)
	{
		static const CComBSTR bstr = L"\n}\n" L"\n}\n" L"\n}\n";
		static const CComBSTR bstrRanu = L"\n}\n" L"\n}\n" L"\n}\n" L"\n}\n";
		if(isRanu)
		{
			return bstrRanu;
		}
		else
		{
			return bstr;
		}
	}
private:
	void CheckGetRegHiveString()
	{
		CComBSTR bstrRegHive;
		VsRegistryUtilities::GetRegHiveString(bstrRegHive);
		UTCHK(bstrRegHive == L"HKCU");
	}
	void CheckGetRegRootStrings(bool isRanu = false)
	{
		CComBSTR bstrRootBegin;
		CComBSTR bstrRootEnd;
		VsRegistryUtilities::GetRegRootStrings(bstrRootBegin, bstrRootEnd);
		UTCHK(bstrRootBegin == GetRootBeginControlValue(isRanu));
		UTCHK(bstrRootEnd == GetRootEndControlValue(isRanu));
	}
	void CheckGetRegDefaultResourceStrings()
	{
		CComBSTR bstrResDllPath;
		CComBSTR bstrResDllName;
		VsRegistryUtilities::GetRegDefaultResourceStrings(bstrResDllPath, bstrResDllName);

		// bstrResDllName should be in the form of *UI.* where * does not have any colons or 
		// slashes
		CStringW szResDllName(bstrResDllName);
		UTCHK(szResDllName.FindOneOf(L"\\/:") == -1);
		bool bUIFound = false;
		if(bstrResDllPath)
		{
			for(wchar_t* psz = bstrResDllName; *psz != L'\0'; ++psz)
			{
				wchar_t character = *psz;
				if(character == L'.' && *(psz-1) == L'I' && *(psz-2) == L'U' && // find "UI."
					// Make sure there is at least one character on either side of "UI."
					*(psz+1) != L'\0' && (psz - static_cast<wchar_t*>(bstrResDllName)) >= 3)
				{
					bUIFound = true;
				}
			}
		}
		UTCHKEX(bUIFound, L"\"UI.\" not found in bstrResDllName");

		// bstrResDllPath should be a full path without the filename, so it should contain
		// at least one slash, and it should not end in bstrResDllName
		CStringW szResDllPath(bstrResDllPath);
		UTCHK(szResDllPath.FindOneOf(L"\\/") >= 0);
		UTCHK(szResDllPath.Find(bstrResDllName) == -1);
	}
public:
	VsRegistryUtilitiesTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
		HRESULT VSL_STDMETHOD_HRESULT = VSL_STDMETHOD_HRESULT_INIT;
		try{

		CheckGetRegRootStrings();

		}VSL_STDMETHODCATCH()

		UTCHKEX(VSL_GET_STDMETHOD_HRESULT() == E_UNEXPECTED, 
			_T("VsRegistryUtilities::GetRegRootStrings didn't handle reg root not being set yet"));

		VSL_STDMETHOD_HRESULT = VSL_STDMETHOD_HRESULT_INIT;
		try{

		CheckGetRegDefaultResourceStrings();

		}VSL_STDMETHODCATCH()

		UTCHKEX(VSL_GET_STDMETHOD_HRESULT() == VSL_STDMETHOD_HRESULT_INIT,
			_T("VsRegistryUtilities::GetRegDefaultResourceStrings failed with reg root being NULL"));

		VSL_STDMETHOD_HRESULT = VSL_STDMETHOD_HRESULT_INIT;
		try{

		VsRegistryUtilities::SetRegRoot(NULL);

		}VSL_STDMETHODCATCH()

		UTCHKEX(VSL_GET_STDMETHOD_HRESULT() == E_POINTER,
			_T("VsRegistryUtilities::SetRegRoot failed to detect NULL arg"));

		VSL_STDMETHOD_HRESULT = VSL_STDMETHOD_HRESULT_INIT;
		try{

		VsRegistryUtilities::SetRegRoot(L"");

		}VSL_STDMETHODCATCH()

		UTCHKEX(VSL_GET_STDMETHOD_HRESULT() == E_INVALIDARG,
			_T("VsRegistryUtilities::SetRegRoot failed to detect bad (empty string) arg"));

		VSL_STDMETHOD_HRESULT = VSL_STDMETHOD_HRESULT_INIT;
		try{

		//                                   10        20        30        40        50        60
		wchar_t* sz65Characters = L"12345678901234567890123456789012345678901234567890123456789012345";
		VsRegistryUtilities::SetRegRoot(sz65Characters);
		CheckGetRegRootStrings();

		}VSL_STDMETHODCATCH()

		UTCHKEX(VSL_GET_STDMETHOD_HRESULT() == E_INVALIDARG,
			_T("VsRegistryUtilities::GetRegRootStrings failed to detect excessively long string"));

		VSL_STDMETHOD_HRESULT = VSL_STDMETHOD_HRESULT_INIT;
		try{

		wchar_t* szBadRegPath = L" \\\\";
		VsRegistryUtilities::SetRegRoot(szBadRegPath);
		CheckGetRegRootStrings();

		}VSL_STDMETHODCATCH()

		UTCHKEX(VSL_GET_STDMETHOD_HRESULT() == E_INVALIDARG,
			_T("VsRegistryUtilities::GetRegRootStrings failed to detect bad reg path"));

		VsRegistryUtilities::SetRegRoot(MockRegRoot);
		CheckGetRegRootStrings();
		CheckGetRegDefaultResourceStrings();

		//Test that the HKCU hive is set in the RANU case
		VsRegistryUtilities::SetRegRoot(MockRegRoot, true);
		CheckGetRegRootStrings(true);
		CheckGetRegHiveString();
		CheckGetRegDefaultResourceStrings();

		VsRegistryUtilities::SetRegRoot(MockRegRoot L"\\");
		CheckGetRegRootStrings();
		CheckGetRegDefaultResourceStrings();
	}
};

class RegistryMacrosTest;

template <class Implementation_T>
class AtlModuleMock
{
public:

	HRESULT UpdateRegistryFromResourceS(
		UINT nResID,
		BOOL bRegister,
		struct _ATL_REGMAP_ENTRY* pMapEntries)
	{
		return Implementation_T::GetInstance()->UpdateRegistryFromResourceS(nResID, bRegister, pMapEntries);
	}
};

static AtlModuleMock<RegistryMacrosTest> _Module;

#define FAKEPLK 5
#define FAKEPLKASSTRING L"5"
#define EXP_TO_STRING(exp) L#exp

#define FAKESTRID 6
#define FAKESTRIDASSTRING L"#6"
#define FAKESTRING L"Test"

class RegistryMacrosTest :
	public UnitTestBase
{
public:

	enum
	{
		ExpectedMapEntries = 11,
		FakeResourceID = 100,
	};

	HRESULT UpdateRegistryFromResourceS(
		UINT nResID,
		BOOL bRegister,
		struct _ATL_REGMAP_ENTRY* pMapEntries)
	{
		UTCHK(nResID == FakeResourceID);
		UTCHK(bRegister == m_bRegister);
		for(size_t i = 0; i < ExpectedMapEntries; ++i)
		{
			if(pMapEntries[i].szData == NULL || pMapEntries[i].szKey == NULL)
			{
				UTCHKEX(i == ExpectedMapEntries-1, _T("NULL value found before expected end of map"));
				break;
			}
			if(i == ExpectedMapEntries-1)
			{
			}
			switch(i)
			{
			case 0:
				UTCHK(::wcscmp(pMapEntries[i].szKey, _VSL_SZ_REGROOTBEGIN) == 0);
				UTCHK(::wcscmp(pMapEntries[i].szData, VsRegistryUtilitiesTest::GetRootBeginControlValue()) == 0);
				break;
			case 1:
				UTCHK(::wcscmp(pMapEntries[i].szKey, _VSL_SZ_REGROOTEND) == 0);
				UTCHK(::wcscmp(pMapEntries[i].szData, VsRegistryUtilitiesTest::GetRootEndControlValue()) == 0);
				break;
			case 2:
				UTCHK(::wcscmp(pMapEntries[i].szKey, _VSL_SZ_REGHIVE) == 0);
				UTCHK(::wcscmp(pMapEntries[i].szData, L"HKLM") == 0);
				break;
			case 3:
				UTCHK(::wcscmp(pMapEntries[i].szKey, _VSL_SZ_RESOURCE_PATH) == 0);
				UTCHK(pMapEntries[i].szData[0] != L'\0'); // TODO - better test
				break;
			case 4:
				UTCHK(::wcscmp(pMapEntries[i].szKey, _VSL_SZ_RESOURCE_DLL) == 0);
				UTCHK(pMapEntries[i].szData[0] != L'\0'); // TODO - better test
				break;
			case 5:
				UTCHK(::wcscmp(pMapEntries[i].szKey, EXP_TO_STRING(g_FakeServiceGUID)) == 0);
				UTCHK(CComBSTR(pMapEntries[i].szData) == CComBSTR(g_FakeServiceGUID));
				break;
			case 6:
				UTCHK(::wcscmp(pMapEntries[i].szKey, EXP_TO_STRING(FAKEPLK)) == 0);
				UTCHK(::wcscmp(pMapEntries[i].szData, FAKEPLKASSTRING) == 0);
				break;
			case 7:
				{
				UTCHK(::wcscmp(pMapEntries[i].szKey, EXP_TO_STRING(IDS_SOURCENAME1)) == 0);
				CStringW strSourceName1;
				UTCHK(strSourceName1.LoadString(IDS_SOURCENAME1) == TRUE);
				UTCHK(::wcscmp(pMapEntries[i].szData, strSourceName1) == 0);
				}
				break;
			case 8:
				UTCHK(::wcscmp(pMapEntries[i].szKey, EXP_TO_STRING(FAKESTRID)) == 0);
				UTCHK(::wcscmp(pMapEntries[i].szData, FAKESTRIDASSTRING) == 0);
				break;
			case 9:
				UTCHK(::wcscmp(pMapEntries[i].szKey, EXP_TO_STRING(g_FakeString)) == 0);
				UTCHK(CComBSTR(pMapEntries[i].szData) == CComBSTR(g_FakeString));
				break;
			case ExpectedMapEntries-1:
				UTCHKEX(pMapEntries[i].szData == NULL && pMapEntries[i].szKey == NULL, _T("NULL values not found at end of map"));
				break;
			default:
				VSLASSERT(false); // should never happen
			}
		}
		return S_OK;
	}

	static RegistryMacrosTest*& GetInstance()
	{
		static RegistryMacrosTest* p = NULL;
		return p;
	}

	class ExTest
	{
	public:
	VSL_BEGIN_REGISTRY_MAP_EX(FakeResourceID)
		VSL_REGISTRY_MAP_REGROOT_ENTRY()
		VSL_REGISTRY_MAP_RESOURCEDLL_ENTRY()
		VSL_REGISTRY_MAP_GUID_ENTRY(g_FakeServiceGUID)
		VSL_REGISTRY_MAP_NUMBER_ENTRY(FAKEPLK)
		VSL_REGISTRY_RESOURCE_STRING_ENTRY(IDS_SOURCENAME1)
		VSL_REGISTRY_RESOURCEID_ENTRY(FAKESTRID)
		VSL_REGISTRY_MAP_STRING_ENTRY(g_FakeString)
	// NOTE - this has two implementations based on the presence of _Module
	// The _Module exists path is test here, and the other is tested in
	// the Package reference sample.
	VSL_END_REGISTRY_MAP() 
	};

	class SimpleTest
	{
	public:
	VSL_BEGIN_REGISTRY_MAP(FakeResourceID)
		VSL_REGISTRY_MAP_GUID_ENTRY(g_FakeServiceGUID)
		VSL_REGISTRY_MAP_NUMBER_ENTRY(FAKEPLK)
		VSL_REGISTRY_RESOURCE_STRING_ENTRY(IDS_SOURCENAME1)
		VSL_REGISTRY_RESOURCEID_ENTRY(FAKESTRID)
		VSL_REGISTRY_MAP_STRING_ENTRY(g_FakeString)
	// NOTE - this has two implementations based on the presence of _Module
	// The _Module exists path is test here, and the other is tested in
	// the Package reference sample.
	VSL_END_REGISTRY_MAP() 
	};

	RegistryMacrosTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName),
		m_bRegister(TRUE)
	{
		GetInstance() = this;

		VsRegistryUtilities::SetRegRoot(MockRegRoot);

		ExTest::UpdateRegistry(m_bRegister);
		m_bRegister = FALSE;
		ExTest::UpdateRegistry(m_bRegister);

		m_bRegister = TRUE;
		SimpleTest::UpdateRegistry(m_bRegister);
		m_bRegister = FALSE;
		SimpleTest::UpdateRegistry(m_bRegister);
	}
private:
	BOOL m_bRegister;
};

typedef InterfaceImplList<IVsShellMockImpl, IUnknownInterfaceListTerminatorDefault> IVsShellLoadUILibraryMockInterfaceList;

VSL_DECLARE_COM_MOCK(IVsShellLoadUILibraryMock, IVsShellLoadUILibraryMockInterfaceList){};

class VsShellUtilitiesTest :
	public UnitTestBase
{
private:
	HMODULE GetSystemDll()
	{
		static HMODULE hDll = ::LoadLibraryExW(L"ksuser.dll", NULL, LOAD_LIBRARY_AS_DATAFILE);
		CHKHANDLEGLE(hDll);
		return hDll;
	}
	void CheckResourceInstance(HINSTANCE hModule)
	{
        HINSTANCE hResource = _AtlBaseModule.GetResourceInstance();
		UTCHK(hResource == hModule);
	}
public:
	VsShellUtilitiesTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
		// Verify calling UnloadUILibrary before LoadUILibrary is safe
		CheckResourceInstance(_AtlBaseModule.GetModuleInstance());
		VsShellUtilities::UnloadUILibrary();
		CheckResourceInstance(_AtlBaseModule.GetModuleInstance());

		// Verify that passing a NULL IVsShell* is handled
		HRESULT VSL_STDMETHOD_HRESULT = VSL_STDMETHOD_HRESULT_INIT;
		try{

		VsShellUtilities invalid(NULL);

		}VSL_STDMETHODCATCH()
		UTCHK(VSL_GET_STDMETHOD_HRESULT() == E_POINTER);

		IVsShellLoadUILibraryMock mock;
		CComQIPtr<IVsShell> spIVsShell = mock.GetIUnknownNoAddRef();
		VsShellUtilities util(spIVsShell);

		// Verify that creating a instance has no global effect
		CheckResourceInstance(_AtlBaseModule.GetModuleInstance());
		VsShellUtilities::UnloadUILibrary();
		CheckResourceInstance(_AtlBaseModule.GetModuleInstance());

		// Verify that LoadUILibrary handles VS failure properly
		PushIVsShellLoadUILibrary(g_FakeServiceGUID, NULL, E_FAIL);
		UTCHK(util.LoadUILibrary(g_FakeServiceGUID) == E_FAIL);
		CheckResourceInstance(_AtlBaseModule.GetModuleInstance());

		// Verify that LoadUILibrary handles VS returning NULL without failing
		DWORD_PTR pdwMock = NULL;
		PushIVsShellLoadUILibrary(g_FakeServiceGUID, &pdwMock);
		UTCHK(util.LoadUILibrary(g_FakeServiceGUID) == E_UNEXPECTED);
		CheckResourceInstance(_AtlBaseModule.GetModuleInstance());

		// Verify that LoadUILibrary works
		pdwMock = reinterpret_cast<DWORD_PTR>(GetSystemDll());
		PushIVsShellLoadUILibrary(g_FakeServiceGUID, &pdwMock);
		UTCHK(util.LoadUILibrary(g_FakeServiceGUID) == S_OK);
		CheckResourceInstance(GetSystemDll());

		// Verify that UnloadUILibrary throws if
		// _AtlBaseModule.GetResourceInstance() == _AtlBaseModule.GetModuleInstance()
		_AtlBaseModule.SetResourceInstance(_AtlBaseModule.GetModuleInstance());
		VSL_STDMETHOD_HRESULT = VSL_STDMETHOD_HRESULT_INIT;
		try{

		VsShellUtilities::UnloadUILibrary();

		}VSL_STDMETHODCATCH()
		UTCHK(VSL_GET_STDMETHOD_HRESULT() == E_UNEXPECTED);
		_AtlBaseModule.SetResourceInstance(GetSystemDll());

		// Verify that LoadUILibrary can be called again
		UTCHK(util.LoadUILibrary(g_FakeServiceGUID) == S_OK);
		CheckResourceInstance(GetSystemDll());

		// Verify that UnloadUILibrary will not unload if the still ref counted
		VsShellUtilities::UnloadUILibrary();
		CheckResourceInstance(GetSystemDll());

		// Verify that UnloadUILibrary will unload on last decrement of ref count
		VsShellUtilities::UnloadUILibrary();
		CheckResourceInstance(_AtlBaseModule.GetModuleInstance());
	}
};

typedef InterfaceImplList<IVsUIShellMockImpl, IUnknownInterfaceListTerminatorDefault> IVsUIShellMockInterfaceList;

VSL_DECLARE_COM_MOCK(IVsUIShellMock, IVsUIShellMockInterfaceList){};

// TODO move this to ErrorAndExceptionHandling
// Update it to reflect current design.
class VsReportErrorUtilitiesTest :
	public UnitTestBase
{
public:
	VsReportErrorUtilitiesTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
		IVsUIShellMock mock;
		CComQIPtr<IVsUIShell> spIVsUIShell = mock.GetIUnknownNoAddRef();

		CREATEVV(IVsUIShell, SetErrorInfo, values)
		{
			E_FAIL,
			VVNOT0(LPCOLESTR),
			0,
			NULL,
			NULL,
			E_FAIL
		};
		SETVV(values);

		SETVV2(IVsUIShell, ReportErrorInfo, E_FAIL, S_OK);

		const UINT iBogusResourceID = 300000000;

		// Test that passing a NULL IVsUIShell* is handled without crashing
		VsReportErrorUtilities<> invalid(NULL);
		invalid.ReportExtendedError(E_FAIL, iBogusResourceID);
		UTCHK(WASCALLED(IVsUIShell, ReportErrorInfo, 0));
		invalid.ReportStandardError(values.hr);
		UTCHK(WASCALLED(IVsUIShell, ReportErrorInfo, 0));

		// Now test a it when properly initialized
		VsReportErrorUtilities<> util(spIVsUIShell);

		// Test that iErrorMessageID not being found is handled
		util.ReportExtendedError(E_FAIL, iBogusResourceID, true);
		UTCHK(WASCALLED(IVsUIShell, ReportErrorInfo, 1));

		// Test that iSourceID not being found is handled
		CStringW szErrorMessage;
		UTCHK(szErrorMessage.LoadString(IDS_E_ERRORMESSAGE) == TRUE);
		values.pszDescription = szErrorMessage;

		util.ReportExtendedError(E_FAIL, IDS_E_ERRORMESSAGE, true, NULL, iBogusResourceID);
		UTCHK(WASCALLED(IVsUIShell, ReportErrorInfo, 1));

		// Test that IVsUIShell::SetErrorInfo failing is handled
		util.ReportExtendedError(values.hr, IDS_E_ERRORMESSAGE, true);
		UTCHK(WASCALLED(IVsUIShell, ReportErrorInfo, 1));

		// Test that IVsUIShell::ReportErrorInfo failing is handled
		values.retValue = S_OK;
		SETVV2(IVsUIShell, ReportErrorInfo, E_FAIL, E_UNEXPECTED);

		util.ReportExtendedError(values.hr, IDS_E_ERRORMESSAGE, true);
		UTCHK(WASCALLED(IVsUIShell, ReportErrorInfo, 1));

		// Test the 2 parameter success case
		values.retValue = S_OK;

		util.ReportExtendedError(values.hr, IDS_E_ERRORMESSAGE, true);
		UTCHK(WASCALLED(IVsUIShell, ReportErrorInfo, 1));

		// Test the 3 parameter success case
		values.pszHelpKeyword = L"TestKeyWord";
		util.ReportExtendedError(values.hr, IDS_E_ERRORMESSAGE, true, values.pszHelpKeyword);
		UTCHK(WASCALLED(IVsUIShell, ReportErrorInfo, 1));

		// Test the 4 parameter success case
		CStringW szSourceName1;
		UTCHK(szSourceName1.LoadString(IDS_SOURCENAME1) == TRUE);
		values.pszSource = szSourceName1;
		util.ReportExtendedError(values.hr, IDS_E_ERRORMESSAGE, true, values.pszHelpKeyword, IDS_SOURCENAME1);
		UTCHK(WASCALLED(IVsUIShell, ReportErrorInfo, 1));

		// Test the 3 parameter, non-default template parameter success case
		VsReportErrorUtilities<IDS_SOURCENAME2> util2(spIVsUIShell);
		CStringW szSourceName2;
		UTCHK(szSourceName2.LoadString(IDS_SOURCENAME2) == TRUE);
		values.pszSource = szSourceName2;
		util2.ReportExtendedError(values.hr, IDS_E_ERRORMESSAGE, true, values.pszHelpKeyword);
		UTCHK(WASCALLED(IVsUIShell, ReportErrorInfo, 1));

		// Set the system error info
		ICreateErrorInfo *pICreateErrorInfo = NULL;
		UTCHK(S_OK == ::CreateErrorInfo(&pICreateErrorInfo));
		CComQIPtr<IErrorInfo> spIErrorInfo = pICreateErrorInfo;
		UTCHK(spIErrorInfo != NULL);
		UTCHK(S_OK == ::SetErrorInfo(0, spIErrorInfo));

		// Test ReportStandardError and ensure it calls IVsUIShell::ReportErrorInfo
		util2.ReportStandardError(values.hr, true);
		UTCHK(WASCALLED(IVsUIShell, ReportErrorInfo, 1));

		// Make sure that the system error info was cleared
		IErrorInfo *pIErrorInfo = NULL;
		++pIErrorInfo;
		UTCHK(S_FALSE == ::GetErrorInfo(0, &pIErrorInfo));
		UTCHK(pIErrorInfo == NULL);
	}
};

VSL_DEFINE_SERVICE_MOCK(IVsShellServiceMockImpl, IVsShellMockImpl);
VSL_DEFINE_SERVICE_MOCK(IVsUIShellErrorsServiceMock, IVsUIShellMockImpl);

typedef ServiceList<IVsShellServiceMockImpl, ServiceList<IVsUIShellErrorsServiceMock, ServiceListTerminator> > IServiceProviderVsUIShellErrorsServiceList;
typedef InterfaceImplList<VSL::IServiceProviderImpl<IServiceProviderVsUIShellErrorsServiceList>, IUnknownInterfaceListTerminator<IServiceProvider> > IServiceProviderVsUIShellErrorsMockInterfaceList;

VSL_DECLARE_COM_MOCK(IServiceProviderVsUIShellErrorsMock, IServiceProviderVsUIShellErrorsMockInterfaceList){};

class LoadUILibraryRequiredTest :
	public UnitTestBase
{
private:
	HMODULE GetSystemDll()
	{
		static HMODULE hDll = ::LoadLibraryExW(L"ksuser.dll", NULL, LOAD_LIBRARY_AS_DATAFILE);
		CHKHANDLEGLE(hDll);
		return hDll;
	}
public:
	LoadUILibraryRequiredTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
		IServiceProviderVsUIShellErrorsMock mock;
		VsSiteCacheGlobal cache;
		CComQIPtr<IServiceProvider> spIServiceProvider = mock.GetIUnknownNoAddRef();
		cache.SetSite(spIServiceProvider);

		CComPtr<IVsUIShell> spIVsUIShell = cache.GetCachedService<IVsUIShell, SID_SVsUIShell>();

		ExtendedErrorInfo errorInfo(IDS_E_ERRORMESSAGE);

		// Test the failure case
		CStringW szErrorMessage;
		UTCHK(szErrorMessage.LoadString(IDS_E_ERRORMESSAGE) == TRUE);

		CREATEVV(IVsUIShell, SetErrorInfo, values)
		{
			E_FAIL,
			VVNOT0(LPCOLESTR),
			0,
			NULL,
			NULL,
			E_FAIL
		};
		SETVV(values);

		SETVV2(IVsUIShell, ReportErrorInfo, E_FAIL, S_OK);

		PushIVsShellLoadUILibrary(g_FakeServiceGUID, NULL, E_FAIL);

		typedef LoadUILibraryRequired<
			&g_FakeServiceGUID, 
			VsSiteCacheGlobal, 
			VsShellUtilities, 
			VsReportErrorUtilities<> > LoaderFail;

		VSL_STDMETHODTRY
		{

		LoaderFail::LoadUILibrary(cache, errorInfo);

		}VSL_STDMETHODCATCH()
		UTCHK(VSL_GET_STDMETHOD_HRESULT() == E_FAIL);

		LoaderFail::UnloadUILibrary();

		DWORD_PTR pdwMock = reinterpret_cast<DWORD_PTR>(GetSystemDll());
		PushIVsShellLoadUILibrary(g_FakeServiceGUID, &pdwMock, S_OK);

		// Test the success case
		typedef LoadUILibraryRequired<
			&g_FakeServiceGUID, 
			VsSiteCacheGlobal, 
			VsShellUtilities, 
			VsReportErrorUtilities<> > Loader;

		Loader::LoadUILibrary(cache, errorInfo);
		Loader::UnloadUILibrary();

		cache.SetSite(NULL);
	}
};

// NOTE LoadUILibraryNoop is not unit tested as it does nothing and it's ability to compile is 
// validated by IVsPackageImplLoadUILibraryNoopTest

class LoadUILibraryRequiredMock
{

	VSL_DECLARE_NOT_COPYABLE(LoadUILibraryRequiredMock)

public:

	typedef ExtendedErrorInfo ExtendedErrorInfo;

	typedef GlobalRefCount<IServiceProviderRefCountGlobal, int> RefCount;

	LoadUILibraryRequiredMock(IVsShell* pIVsShell)
	{
		CHK(pIVsShell != NULL, E_POINTER);
	}

	static UnitTestBase*& GetUnitTestBase()
	{
		static UnitTestBase* pUnitTestBase = NULL;
		return pUnitTestBase;
	}

	static void LoadUILibrary(
		const VsSiteCacheGlobal& rVsSiteCache,
		const ExtendedErrorInfo& rExtendedErrorInfo)
	{
		CComPtr<IVsShell> spIVsShell = rVsSiteCache.GetCachedService<IVsShell, SID_SVsShell>();
		UTHCHK((spIVsShell != NULL), GetUnitTestBase());
		CComPtr<IVsUIShell> spIVsUIShell = rVsSiteCache.GetCachedService<IVsUIShell, SID_SVsUIShell>();
		UTHCHK((spIVsUIShell != NULL), GetUnitTestBase());
		UTHCHK((rExtendedErrorInfo.GetDescriptionID() == IDS_E_ERRORMESSAGE), GetUnitTestBase());
#if 0 - FUTURE
		UTHCHK((rExtendedErrorInfo.GetHelpKeyword() == NULL), GetUnitTestBase());
		UTHCHK((rExtendedErrorInfo.GetSourceID() == 0), GetUnitTestBase());
#endif
		++RefCount::Get();
	}

	static void UnloadUILibrary()
	{
		--RefCount::Get();
	}
};

template <class DeriveClass_T, class LoadUILibrary_T>
class IVsPackageImplTestBase :
	public UnitTestBase
{
protected:

	virtual ~IVsPackageImplTestBase() {}

	void Test()
	{
		__if_exists(DeriveClass_T::GetLoadUILibraryErrorInfo)
		{
			LoadUILibrary_T::GetUnitTestBase() = this;
		}

		IVsPackage* pIVsPackage = dynamic_cast<IVsPackage*>(this);
		UTCHK(pIVsPackage->SetSite(NULL) == S_OK);

		IServiceProviderMock mock;
		CComQIPtr<IServiceProvider> spIServiceProvider = mock.GetIUnknownNoAddRef();

		UTCHK(pIVsPackage->SetSite(spIServiceProvider) == S_OK);
		__if_exists(DeriveClass_T::GetLoadUILibraryErrorInfo)
		{
			UTCHK(LoadUILibrary_T::RefCount::Get() == 1);
		}

		DeriveClass_T::VsSiteCache& rVsSiteCache = dynamic_cast<DeriveClass_T*>(this)->GetVsSiteCache();
		CComPtr<IServiceProvider> spCachedIServiceProvider = rVsSiteCache.GetSite();
		UTCHK(spCachedIServiceProvider == spIServiceProvider);

		UTCHK(pIVsPackage->QueryClose(NULL) == E_POINTER);
		BOOL bCanClose = FALSE;
		UTCHK(pIVsPackage->QueryClose(&bCanClose) == S_OK);
		UTCHK(bCanClose == TRUE);

		UTCHK(pIVsPackage->GetAutomationObject(NULL, NULL) == E_POINTER);
		IDispatch* pDispatch = NULL;
		++pDispatch;
		UTCHK(pIVsPackage->GetAutomationObject(NULL, &pDispatch) == E_NOTIMPL);
		UTCHK(pDispatch == NULL);

		UTCHK(pIVsPackage->CreateTool(g_FakeServiceGUID) == E_NOTIMPL);
		UTCHK(pIVsPackage->ResetDefaults(0) == E_NOTIMPL);
		VSPROPSHEETPAGE page;
		UTCHK(pIVsPackage->GetPropertyPage(g_FakeServiceGUID, &page) == E_NOTIMPL);

		UTCHK(pIVsPackage->Close() == S_OK);
		__if_exists(DeriveClass_T::GetLoadUILibraryErrorInfo)
		{
		UTCHK(LoadUILibrary_T::RefCount::Get() == 0);
		}

		UTCHK(pIVsPackage->Close() == E_UNEXPECTED);
		__if_exists(DeriveClass_T::GetLoadUILibraryErrorInfo)
		{
		UTCHK(LoadUILibrary_T::RefCount::Get() == 0);
		}

		UTCHK(pIVsPackage->SetSite(NULL) == E_UNEXPECTED);
		__if_exists(DeriveClass_T::GetLoadUILibraryErrorInfo)
		{
		UTCHK(LoadUILibrary_T::RefCount::Get() == 0);
		}
	}
public:
	IVsPackageImplTestBase(const char* const szTestName):
		UnitTestBase(szTestName)
	{
	}
};

class IVsPackageImplTest :
	public IVsPackageImplTestBase<IVsPackageImplTest, LoadUILibraryRequiredMock>,
	public IVsPackageImpl<IVsPackageImplTest, &g_FakeServiceGUID, VsSiteCacheGlobal, LoadUILibraryRequiredMock>
{
public:

VSL_DEFINE_IUNKNOWN_NOTIMPL

	static const LoadUILibrary::ExtendedErrorInfo& GetLoadUILibraryErrorInfo()
	{
		static LoadUILibrary::ExtendedErrorInfo errorInfo(IDS_E_ERRORMESSAGE);
		return errorInfo;
	}

	IVsPackageImplTest(_In_opt_ const char* const szTestName):
		IVsPackageImplTestBase(szTestName)
	{
		Test();
	}
};

class IVsPackageImplLoadUILibraryNoopTest :
	public IVsPackageImplTestBase<IVsPackageImplLoadUILibraryNoopTest, LoadUILibraryNoop<VsSiteCacheGlobal> >,
	public IVsPackageImpl<IVsPackageImplLoadUILibraryNoopTest, &g_FakeServiceGUID, VsSiteCacheGlobal, LoadUILibraryNoop<VsSiteCacheGlobal> >
{
public:

VSL_DEFINE_IUNKNOWN_NOTIMPL

	IVsPackageImplLoadUILibraryNoopTest(_In_opt_ const char* const szTestName):
		IVsPackageImplTestBase(szTestName)
	{
		Test();
	}
};

class IVsPackageImplSetSiteEventsTest :
	public IVsPackageImpl<IVsPackageImplSetSiteEventsTest, &g_FakeServiceGUID, VsSiteCacheGlobal, LoadUILibraryNoop<VsSiteCacheGlobal> >,
	public UnitTestBase
{
public:

VSL_DEFINE_IUNKNOWN_NOTIMPL

	IVsPackageImplSetSiteEventsTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName),
		m_bPostSitedCalled(false)
	{
		// Test that PostSited is called when SetSite is called and that the
		// parameter is the one expected.
		IVsPackage* pPackage = static_cast<IVsPackage*>(this);
		IServiceProviderMock mock;
		CComQIPtr<IServiceProvider> spIServiceProvider = mock.GetIUnknownNoAddRef();

		m_SetSiteResultExpected = IVsPackageEnums::NothingCached;
		UTCHK(S_OK == pPackage->SetSite(NULL));
		UTCHK(!m_bPostSitedCalled);

		m_SetSiteResultExpected = IVsPackageEnums::Cached;
		m_bPostSitedCalled = false;
		UTCHK(S_OK == pPackage->SetSite(spIServiceProvider));
		UTCHK(m_bPostSitedCalled);

		m_SetSiteResultExpected = IVsPackageEnums::AlreadyCached;
		m_bPostSitedCalled = false;
		UTCHK(S_OK == pPackage->SetSite(spIServiceProvider));
		UTCHK(m_bPostSitedCalled);

		m_SetSiteResultExpected = IVsPackageEnums::NothingCached;
		m_bPostSitedCalled = false;
		UTCHK(S_OK == pPackage->SetSite(NULL));
		UTCHK(!m_bPostSitedCalled);

		m_SetSiteResultExpected = IVsPackageEnums::Cleared;
		m_bPostSitedCalled = false;
		UTCHK(S_OK == pPackage->SetSite(NULL));
		UTCHK(!m_bPostSitedCalled);
	}

	void PostSited(IVsPackageEnums::SetSiteResult result)
	{
		m_bPostSitedCalled = true;
		UTCHK(result == m_SetSiteResultExpected);
	}
private:
	bool m_bPostSitedCalled;
	IVsPackageEnums::SetSiteResult m_SetSiteResultExpected;
};

#define FAKE_RESOURCE 34567

class IVsInstalledProductImplTest :
	public UnitTestBase,
	public IVsInstalledProductImpl<IDS_E_ERRORMESSAGE, IDS_E_ERRORMESSAGE, IDS_E_ERRORMESSAGE, FAKE_RESOURCE>
{
public:

VSL_DEFINE_IUNKNOWN_NOTIMPL

	IVsInstalledProductImplTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
		// Test bad NULL arg case
		UTCHK(get_OfficialName(NULL) == E_POINTER);
		UTCHK(get_ProductID(NULL) == E_POINTER);
		UTCHK(get_ProductDetails(NULL) == E_POINTER);
		UTCHK(get_IdIcoLogoForAboutbox(NULL) == E_POINTER);
		UTCHK(get_IdBmpSplash(NULL) == E_POINTER);

		// Test success case
		CComBSTR bstrOfficialName;
		UTCHK(get_OfficialName(&bstrOfficialName) == S_OK);
		CStringW szOfficialName;
		UTCHK(TRUE == szOfficialName.LoadString(IDS_E_ERRORMESSAGE));
		UTCHK(bstrOfficialName == static_cast<LPCOLESTR>(szOfficialName));

		CComBSTR bstrProductID;
		UTCHK(get_ProductID(&bstrProductID) == S_OK);
		CStringW szProductID;
		UTCHK(TRUE == szProductID.LoadString(IDS_E_ERRORMESSAGE));
		UTCHK(bstrProductID == static_cast<LPCOLESTR>(szProductID));

		CComBSTR bstrProductDetails;
		UTCHK(get_ProductDetails(&bstrProductDetails) == S_OK);
		CStringW szProductDetails;
		UTCHK(TRUE == szProductDetails.LoadString(IDS_E_ERRORMESSAGE));
		UTCHK(bstrProductDetails == static_cast<LPCOLESTR>(szProductDetails));

		UINT iIdIcoLogoForAboutbox = 0;
		UTCHK(get_IdIcoLogoForAboutbox(&iIdIcoLogoForAboutbox) == S_OK);
		UTCHK(iIdIcoLogoForAboutbox == FAKE_RESOURCE);
	}
};

class IVsInstalledProductImplBadTemplateArgsTest :
	public UnitTestBase,
	public IVsInstalledProductImpl<FAKE_RESOURCE, FAKE_RESOURCE, FAKE_RESOURCE, FAKE_RESOURCE>
{
public:

VSL_DEFINE_IUNKNOWN_NOTIMPL

	IVsInstalledProductImplBadTemplateArgsTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
		CComBSTR bstrOfficialName;
		UTCHK(get_OfficialName(&bstrOfficialName) == HRESULT_FROM_WIN32(ERROR_RESOURCE_NAME_NOT_FOUND));
		UTCHK(bstrOfficialName == L'\0');

		CComBSTR bstrProductID;
		UTCHK(get_ProductID(&bstrProductID) == HRESULT_FROM_WIN32(ERROR_RESOURCE_NAME_NOT_FOUND));
		UTCHK(bstrProductID == L'\0');

		CComBSTR bstrProductDetails;
		UTCHK(get_ProductDetails(&bstrProductDetails) == HRESULT_FROM_WIN32(ERROR_RESOURCE_NAME_NOT_FOUND));
		UTCHK(bstrProductDetails == L'\0');

		// Skip get_IdIcoLogoForAboutbox since it just parrots the template arg
	}
};

class AtlModuleEntryPointMock
{
public:
    BOOL WINAPI DllMain(DWORD /*dwReason*/, LPVOID /*lpReserved*/)
	{
		return TRUE;
	}
	HRESULT DllCanUnloadNow()
	{
		return S_OK;
	}

	HRESULT GetClassObject(REFCLSID /*rclsid*/, REFIID /*riid*/, LPVOID* /*ppv*/)
	{
		return S_OK;
	}

	HRESULT RegisterServer(BOOL bRegTypeLib = TRUE)
	{
		VSL_CHECKBOOLEAN(bRegTypeLib == FALSE, E_INVALIDARG);
		return S_OK;
	}

	HRESULT UnregisterServer(BOOL bUnRegTypeLib = TRUE)
	{
		VSL_CHECKBOOLEAN(bUnRegTypeLib == FALSE, E_INVALIDARG);
		return S_OK;
	}

};

AtlModuleEntryPointMock _AtlModule;

#define DEFAULT_REGISTRY_ROOT LREGKEY_VISUALSTUDIOROOT L"Exp"

// Must come after decleration of _AtlModule and DEFAULT_REGISTRY_ROOT
#include <VSLPackageDllEntryPoints.cpp>

class DllEntryPointsTest :
	public UnitTestBase
{
public:
	DllEntryPointsTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
		UTCHK(::DllMain(NULL, 0 , NULL) == TRUE);
		UTCHK(DllCanUnloadNow() == S_OK);
		UTCHK(DllGetClassObject(GUID_NULL, GUID_NULL, NULL) == S_OK);
		UTCHK(VSDllRegisterServer(NULL) == S_OK);
		UTCHK(VSDllRegisterServer(L"") == E_INVALIDARG);
		UTCHK(VSDllUnregisterServer(NULL) == S_OK);
		UTCHK(VSDllUnregisterServer(L"") == E_INVALIDARG);

		UTCHK(VSDllRegisterServerUser(NULL) == S_OK);
		UTCHK(VSDllRegisterServerUser(L"") == E_INVALIDARG);
		UTCHK(VSDllUnregisterServerUser(NULL) == S_OK);
		UTCHK(VSDllUnregisterServerUser(L"") == E_INVALIDARG);
		
		UTCHK(DllRegisterServer() == S_OK);
		UTCHK(DllUnregisterServer() == S_OK);
	}
};

typedef InterfaceImplList<IOleComponentUIManagerMockImpl, IUnknownInterfaceListTerminatorDefault> IOleComponentUIManagerMockImplList;
VSL_DEFINE_SERVICE_MOCK_EX(IOleComponentUIManagerServiceMock, IOleComponentUIManagerMockImplList, SID_SOleComponentUIManager);

typedef ServiceList<IOleComponentUIManagerServiceMock, ServiceList<IVsShellServiceMock, ServiceList<IVsUIShellServiceMock, ServiceListTerminator> > > IOleComponentUIManagerProviderServiceList;
typedef InterfaceImplList<VSL::IServiceProviderImpl<IOleComponentUIManagerProviderServiceList>, IUnknownInterfaceListTerminator<IServiceProvider> > IOleComponentUIManagerProviderMockInterfaceList;

VSL_DECLARE_COM_MOCK(IOleComponentUIManagerProviderMock, IOleComponentUIManagerProviderMockInterfaceList){};

class OleComponentUIManagerUtilitiesGlobalTest :
	public UnitTestBase
{
public:
	OleComponentUIManagerUtilitiesGlobalTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
		IOleComponentUIManagerProviderMock serviceProviderMock;
		VsSiteCacheGlobal cache;
		cache.SetSite(&serviceProviderMock);

	// ShowMessage

		LONG nResult = IDYES;
		CREATEVV(IOleComponentUIManager, ShowMessage, values)
		{
			OLEROLE_TOPLEVELCOMPONENT, //* [in] */ DWORD dwCompRole,
			GUID_NULL, //* [in] */ REFCLSID rclsidComp,
			L"Test Title", //* [in] */ LPOLESTR pszTitle,
			L"Test Text", //* [in] */ LPOLESTR pszText,
			NULL, //* [in] */ LPOLESTR pszHelpFile,
			NULL, //* [in] */ DWORD dwHelpContextID,
			OLEMSGBUTTON_OK, //* [in] */ OLEMSGBUTTON msgbtn,
			OLEMSGDEFBUTTON_FIRST, //* [in] */ OLEMSGDEFBUTTON msgdefbtn,
			OLEMSGICON_CRITICAL, //* [in] */ OLEMSGICON msgicon,
			FALSE, //* [in] */ BOOL fSysAlert,
			&nResult, //* [retval][out] */ LONG *pnResult) = 0;
			E_UNEXPECTED
		};

		SETVV(values);
		
		HRESULT VSL_STDMETHOD_HRESULT = VSL_STDMETHOD_HRESULT_INIT;
		try{

		OleComponentUIManagerUtilities<>::ShowMessage(
			values.pszTitle, 
			values.pszText);

		}VSL_STDMETHODCATCH()

		UTCHK(VSL_GET_STDMETHOD_HRESULT() == E_UNEXPECTED);

		VSL_STDMETHOD_HRESULT = VSL_STDMETHOD_HRESULT_INIT;
		try{

		OleComponentUIManagerUtilities<>::ShowMessage(
			values.pszTitle, 
			IDS_TESTTEXT);

		}VSL_STDMETHODCATCH()

		UTCHK(VSL_GET_STDMETHOD_HRESULT() == E_UNEXPECTED);

		values.retValue = S_OK;

		UTCHK(nResult == OleComponentUIManagerUtilities<>::ShowMessage(
			values.pszTitle, 
			values.pszText));

		UTCHK(nResult == OleComponentUIManagerUtilities<>::ShowMessage(
			values.pszTitle, 
			IDS_TESTTEXT));

		values.msgbtn = OLEMSGBUTTON_OKCANCEL;
		values.msgdefbtn = OLEMSGDEFBUTTON_SECOND;
		values.msgicon = OLEMSGICON_QUERY;
		values.fSysAlert = TRUE;

		UTCHK(nResult == OleComponentUIManagerUtilities<>::ShowMessage(
			values.pszTitle, 
			values.pszText,
			values.msgbtn,
			values.msgdefbtn,
			values.msgicon,
			values.fSysAlert));

		UTCHK(nResult == OleComponentUIManagerUtilities<>::ShowMessage(
			values.pszTitle, 
			IDS_TESTTEXT,
			values.msgbtn,
			values.msgdefbtn,
			values.msgicon,
			values.fSysAlert));

	// ShowContextMenu

		POINTS pts = {0, 0};
		CREATEVV(IOleComponentUIManager, ShowContextMenu, valuesShowContextMenu)
		{
            0, //* [in] */ DWORD dwCompRole,
            GUID_NULL, //* [in] */ REFCLSID rclsidActive,
            0, //* [in] */ LONG nMenuId,
            pts, //* [in] */ REFPOINTS pos,
            NULL, //* [in] */ IOleCommandTarget *pCmdTrgtActive) = 0;
			E_UNEXPECTED
		};

		SETVV(valuesShowContextMenu);

		VSL_STDMETHOD_HRESULT = VSL_STDMETHOD_HRESULT_INIT;
		try{

		OleComponentUIManagerUtilities<>::ShowContextMenu(
			0, 
			GUID_NULL,
			0,
			pts,
			NULL);

		}VSL_STDMETHODCATCH()

		UTCHK(VSL_GET_STDMETHOD_HRESULT() == E_UNEXPECTED);

		cache.SetSite(NULL);
	}
};

class OleComponentUIManagerUtilitiesLocalTest :
	public UnitTestBase
{
public:
	OleComponentUIManagerUtilitiesLocalTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
		IOleComponentUIManagerProviderMock serviceProviderMock;
		VsSiteCacheLocal cache;
		cache.SetSite(&serviceProviderMock);

		LONG nResult = IDYES;
		CREATEVV(IOleComponentUIManager, ShowMessage, values)
		{
			OLEROLE_TOPLEVELCOMPONENT, //* [in] */ DWORD dwCompRole,
			GUID_NULL, //* [in] */ REFCLSID rclsidComp,
			L"Test Title", //* [in] */ LPOLESTR pszTitle,
			L"Test Text", //* [in] */ LPOLESTR pszText,
			NULL, //* [in] */ LPOLESTR pszHelpFile,
			NULL, //* [in] */ DWORD dwHelpContextID,
			OLEMSGBUTTON_OK, //* [in] */ OLEMSGBUTTON msgbtn,
			OLEMSGDEFBUTTON_FIRST, //* [in] */ OLEMSGDEFBUTTON msgdefbtn,
			OLEMSGICON_CRITICAL, //* [in] */ OLEMSGICON msgicon,
			FALSE, //* [in] */ BOOL fSysAlert,
			&nResult, //* [retval][out] */ LONG *pnResult) = 0;
			E_UNEXPECTED
		};

		SETVV(values);

		OleComponentUIManagerUtilities<VsUtilityLocalSiteControl> util;
		util.SetSite(cache);
		
		HRESULT VSL_STDMETHOD_HRESULT = VSL_STDMETHOD_HRESULT_INIT;
		try{

		util.ShowMessage(
			values.pszTitle, 
			values.pszText);

		}VSL_STDMETHODCATCH()

		UTCHK(VSL_GET_STDMETHOD_HRESULT() == E_UNEXPECTED);

		VSL_STDMETHOD_HRESULT = VSL_STDMETHOD_HRESULT_INIT;
		try{

		util.ShowMessage(
			values.pszTitle, 
			IDS_TESTTEXT);

		}VSL_STDMETHODCATCH()

		UTCHK(VSL_GET_STDMETHOD_HRESULT() == E_UNEXPECTED);

		values.retValue = S_OK;

		UTCHK(nResult == util.ShowMessage(
			values.pszTitle, 
			values.pszText));

		UTCHK(nResult == util.ShowMessage(
			values.pszTitle, 
			IDS_TESTTEXT));

		values.msgbtn = OLEMSGBUTTON_OKCANCEL;
		values.msgdefbtn = OLEMSGDEFBUTTON_SECOND;
		values.msgicon = OLEMSGICON_QUERY;
		values.fSysAlert = TRUE;

		UTCHK(nResult == util.ShowMessage(
			values.pszTitle, 
			values.pszText,
			values.msgbtn,
			values.msgdefbtn,
			values.msgicon,
			values.fSysAlert));

		UTCHK(nResult == util.ShowMessage(
			values.pszTitle, 
			IDS_TESTTEXT,
			values.msgbtn,
			values.msgdefbtn,
			values.msgicon,
			values.fSysAlert));

		CComPtr<IOleComponentUIManager> spIOleComponentUIManager;
		cache.QueryCachedService<IOleComponentUIManager, SID_SOleComponentUIManager>(&spIOleComponentUIManager);
		OleComponentUIManagerUtilities<VsUtilityLocalSiteControl> util2(spIOleComponentUIManager);

		UTCHK(nResult == util2.ShowMessage(
			values.pszTitle, 
			IDS_TESTTEXT,
			values.msgbtn,
			values.msgdefbtn,
			values.msgicon,
			values.fSysAlert));

		cache.SetSite(NULL);
	}
};

// TODO - 1/17/2006 - this unit test needs to move elsewhere, and could stand improvment

void Method()
{
	ERRHR(E_NOTIMPL);
}

static const int iMethod0Return = 53;
int Method0()
{
	return iMethod0Return;
}

int Method1(int i)
{
	return i;
}

int Method2(int i, int j)
{
	return i+j;
}

int Method3(int i, int j, int k)
{
	return i+j+k;
}

class StaticMethods
{
public:
	static Delegate<void ()>* m_spDelegate;
	static FunctionPointerFunctor<CallingConventionDefault, void ()>* m_spFunctorToRemove1;
	static FunctionPointerFunctor<CallingConventionDefault, void ()>* m_spFunctorToRemove2;
	static FunctionPointerFunctor<CallingConventionDefault, void ()>* m_spFunctorToRemove3;

	static void RemoveFromDelegate1()
	{
		*m_spDelegate -= m_spFunctorToRemove1;
	}

	static void RemoveFromDelegate2()
	{
		*m_spDelegate -= m_spFunctorToRemove2;
	}

	static void RemoveFromDelegate3()
	{
		*m_spDelegate -= m_spFunctorToRemove3;
	}

	static void Method()
	{
		ERRHR(E_FAIL);
	}

	static int Method0()
	{
		return iMethod0Return;
	}

	static int Method1(int i)
	{
		return i+1;
	}

	static int Method2(int i, int j)
	{
		return i+j+1;
	}

	static int Method3(int i, int j, int k)
	{
		return i+j+k+1;
	}
};

Delegate<void ()>* StaticMethods::m_spDelegate;
FunctionPointerFunctor<CallingConventionDefault, void ()>* StaticMethods::m_spFunctorToRemove1;
FunctionPointerFunctor<CallingConventionDefault, void ()>* StaticMethods::m_spFunctorToRemove2;
FunctionPointerFunctor<CallingConventionDefault, void ()>* StaticMethods::m_spFunctorToRemove3;

class Methods
{
public:
	void Method()
	{
		ERRHR(E_UNEXPECTED);
	}
	int Method0()
	{
		return iMethod0Return;
	}
	int Method1(int i)
	{
		return i+2;
	}
	int Method2(int i, int j)
	{
		return i+j+2;
	}
	int Method3(int i, int j, int k)
	{
		return i+j+k+2;
	}
};

class FunctorTest :
	public UnitTestBase
{
public:

	void TestRemoveWhenCalled()
	{
		Delegate<void ()> functorContainter;
		StaticMethods::m_spDelegate = &functorContainter;

		FunctionPointerFunctor<CallingConventionDefault, void ()> staticMethodFunctor1(&StaticMethods::RemoveFromDelegate1);
		functorContainter += &staticMethodFunctor1;
		StaticMethods::m_spFunctorToRemove1 = &staticMethodFunctor1;

		FunctionPointerFunctor<CallingConventionDefault, void ()> staticMethodFunctor2(&StaticMethods::RemoveFromDelegate2);
		functorContainter += &staticMethodFunctor2;
		StaticMethods::m_spFunctorToRemove2 = &staticMethodFunctor2;

		FunctionPointerFunctor<CallingConventionDefault, void ()> staticMethodFunctor3(&StaticMethods::RemoveFromDelegate3);
		functorContainter += &staticMethodFunctor3;
		StaticMethods::m_spFunctorToRemove3 = &staticMethodFunctor3;

		functorContainter();

		HRESULT VSL_STDMETHOD_HRESULT = VSL_STDMETHOD_HRESULT_INIT;
		try{

		functorContainter();

		}VSL_STDMETHODCATCH()

		// Container should be empty now
		UTCHK(VSL_GET_STDMETHOD_HRESULT() == E_UNEXPECTED);
	}

	void TestVoid()
	{
		Delegate<void ()> functorContainter;
		FunctionPointerFunctor<CallingConventionDefault, void ()> functionFunctor(&Method);
		functorContainter += &functionFunctor;

		HRESULT VSL_STDMETHOD_HRESULT = VSL_STDMETHOD_HRESULT_INIT;
		try{

		functorContainter();

		}VSL_STDMETHODCATCH()

		UTCHK(VSL_GET_STDMETHOD_HRESULT() == E_NOTIMPL);

		FunctionPointerFunctor<CallingConventionDefault, void ()> staticMethodFunctor(&StaticMethods::Method);
		functorContainter += &staticMethodFunctor;

		VSL_STDMETHOD_HRESULT = VSL_STDMETHOD_HRESULT_INIT;
		try{

		functorContainter();

		}VSL_STDMETHODCATCH()

		UTCHK(VSL_GET_STDMETHOD_HRESULT() == E_NOTIMPL);

		Methods instance;
		MemberFunctionPointerFunctor<Methods, CallingConventionDefault, void ()> memberFunctionFuntor(&instance, &Methods::Method);
		functorContainter += &memberFunctionFuntor;

		VSL_STDMETHOD_HRESULT = VSL_STDMETHOD_HRESULT_INIT;
		try{

		functorContainter();

		}VSL_STDMETHODCATCH()

		UTCHK(VSL_GET_STDMETHOD_HRESULT() == E_NOTIMPL);
	}

	void Test0Parameter()
	{
		Delegate<int ()> functorContainter;
		FunctionPointerFunctor<CallingConventionDefault, int ()> functionFunctor(&Method0);
		functorContainter += &functionFunctor;

		int i = functorContainter();
		UTCHK(i == iMethod0Return);

		FunctionPointerFunctor<CallingConventionDefault, int ()> staticMethodFunctor(&StaticMethods::Method0);
		functorContainter += &staticMethodFunctor;

		i = functorContainter();
		UTCHK(i == iMethod0Return);

		Methods instance;
		MemberFunctionPointerFunctor<Methods, CallingConventionDefault, int ()> memberMethodFunctor(&instance, &Methods::Method0);
		functorContainter += &memberMethodFunctor;

		i = functorContainter();
		UTCHK(i == iMethod0Return);
	}

	void Test1Parameter()
	{
		Delegate<int (int)> functorContainter;
		const int iExpected = 1;

		FunctionPointerFunctor<CallingConventionDefault, int (int)> functionFunctor(&Method1);
		functorContainter += &functionFunctor;

		int i = functorContainter(iExpected);
		UTCHK(i == iExpected);

		FunctionPointerFunctor<CallingConventionDefault, int (int)> staticMethodfunctor(&StaticMethods::Method1);
		functorContainter += &staticMethodfunctor;

		i = functorContainter(iExpected);
		UTCHK(i == iExpected+1);

		Methods instance;
		MemberFunctionPointerFunctor<Methods, CallingConventionDefault, int (int)> memberMethodfunctor(&instance, &Methods::Method1);
		functorContainter += &memberMethodfunctor;

		i = functorContainter(iExpected);
		UTCHK(i == iExpected+2);

		functorContainter -= &memberMethodfunctor;

		i = functorContainter(iExpected);
		UTCHK(i == iExpected+1);

		functorContainter -= &staticMethodfunctor;

		i = functorContainter(iExpected);
		UTCHK(i == iExpected);
	}

	void Test2Parameter()
	{
		Delegate<int (int, int)> functorContainter;
		const int a = 1;
		const int b = 2;
		const int iExpected = a+b;

		FunctionPointerFunctor<CallingConventionDefault, int (int, int)> functionFunctor(&Method2);
		functorContainter += &functionFunctor;

		int i = functorContainter(a, b);
		UTCHK(i == iExpected);

		FunctionPointerFunctor<CallingConventionDefault, int (int, int)> staticMethodfunctor(&StaticMethods::Method2);
		functorContainter += &staticMethodfunctor;

		i = functorContainter(a, b);
		UTCHK(i == iExpected+1);

		Methods instance;
		MemberFunctionPointerFunctor<Methods, CallingConventionDefault, int (int, int)> memberMethodfunctor(&instance, &Methods::Method2);
		functorContainter += &memberMethodfunctor;

		i = functorContainter(a, b);
		UTCHK(i == iExpected+2);

		functorContainter -= &memberMethodfunctor;

		i = functorContainter(a, b);
		UTCHK(i == iExpected+1);

		functorContainter -= &staticMethodfunctor;

		i = functorContainter(a, b);
		UTCHK(i == iExpected);
	}

	void Test3Parameter()
	{
		Delegate<int (int, int, int)> functorContainter;
		const int a = 1;
		const int b = 2;
		const int c = 3;
		const int iExpected = a+b+c;

		FunctionPointerFunctor<CallingConventionDefault, int (int, int, int)> functionFunctor(&Method3);
		functorContainter += &functionFunctor;

		int i = functorContainter(a, b, c);
		UTCHK(i == iExpected);

		FunctionPointerFunctor<CallingConventionDefault, int (int, int, int)> staticMethodfunctor(&StaticMethods::Method3);
		functorContainter += &staticMethodfunctor;

		i = functorContainter(a, b, c);
		UTCHK(i == iExpected+1);

		Methods instance;
		MemberFunctionPointerFunctor<Methods, CallingConventionDefault, int (int, int, int)> memberMethodfunctor(&instance, &Methods::Method3);
		functorContainter += &memberMethodfunctor;

		i = functorContainter(a, b, c);
		UTCHK(i == iExpected+2);

		functorContainter -= &memberMethodfunctor;

		i = functorContainter(a, b, c);
		UTCHK(i == iExpected+1);

		functorContainter -= &staticMethodfunctor;

		i = functorContainter(a, b, c);
		UTCHK(i == iExpected);
	}

	FunctorTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
		TestRemoveWhenCalled();
		TestVoid();
		Test0Parameter();
		Test1Parameter();
		Test2Parameter();
		Test3Parameter();
	}
};

class IExtensibleObjectImplTestHelper :
	public IExtensibleObjectImpl<IExtensibleObjectImplTestHelper>
{
public:

VSL_DEFINE_IUNKNOWN_NOTIMPL

	IUnknown* _GetRawUnknown() throw()
	{
		return this;
	}

	IDispatch* GetNamedAutomationObject(BSTR /*bstrName*/)
	{
		return reinterpret_cast<IDispatch*>(this);
	}
};

class IExtensibleObjectImplTest :
	public UnitTestBase,
	public IExtensibleObjectSite, // TODO - 2/1/2006 - determine why the mock interface for this is missing
	public MockBase
{
public:

	typedef IExtensibleObjectImplTest IExtensibleObjectImplTestMockImpl;

VSL_DEFINE_MOCK_CLASS_TYPDEFS(IExtensibleObjectImplTest)

VSL_DEFINE_IUNKNOWN_NOTIMPL

	struct NotifyDeleteValidValues
	{
		IUnknown* pIUnknown;
		HRESULT retValue;
	};

	STDMETHOD(NotifyDelete)(IUnknown* pIUnknown)
	{
		VSL_DEFINE_MOCK_METHOD(NotifyDelete);

		UTCHK(pIUnknown == validValues.pIUnknown);

		VSL_RETURN_VALIDVALUES();
	}

	IExtensibleObjectImplTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
		{
		IExtensibleObjectImplTestHelper helper;
		UTCHK(E_INVALIDARG == helper.GetAutomationObject(NULL, NULL, NULL));
		IDispatch* pIDispatch = NULL;
		UTCHK(S_OK == helper.GetAutomationObject(NULL, NULL, &pIDispatch));
		UTCHK(pIDispatch == reinterpret_cast<IDispatch*>(&helper));
		pIDispatch = NULL;
		UTCHK(S_OK == helper.GetAutomationObject(NULL, static_cast<IExtensibleObjectSite*>(this), &pIDispatch));
		UTCHK(pIDispatch == reinterpret_cast<IDispatch*>(&helper));
		// Call it again, since this can be called repeatedly
		UTCHK(S_OK == helper.GetAutomationObject(NULL, static_cast<IExtensibleObjectSite*>(this), &pIDispatch));
		UTCHK(pIDispatch == reinterpret_cast<IDispatch*>(&helper));
		PUSHVV2(IExtensibleObjectImplTest, NotifyDelete, static_cast<IUnknown*>(static_cast<IExtensibleObject*>(&helper)), S_OK);
		}
		UTCHK(WASCALLED0(IExtensibleObjectImplTest, NotifyDelete, 1));
		{
		IExtensibleObjectImplTestHelper helper;
		}
		UTCHK(WASCALLED0(IExtensibleObjectImplTest, NotifyDelete, 0));
	}
};

int _cdecl _tmain()
{
	UTRUN(PointerWithNullDefaultTest);
	UTRUN(LocalCacheTest);
	UTRUN(GlobalCacheTest);
	UTRUN(GlobalRefCountTest);
	UTRUN(IVsPackageEnumsCompileTest);
	UTRUN(IServiceProviderLocalCacheTest);
	UTRUN(IServiceProviderGlobalCacheTest);
	UTRUN(GeneralServiceCacheLocalNotImplementedTest);
	UTRUN(VsSiteCacheGlobalTest);
	UTRUN(VsSiteCacheLocalTest);
	UTRUN(VsIServiceProviderUtilitiesTest);
	UTRUN(VsRegistryUtilitiesTest);
	UTRUN(RegistryMacrosTest);
	UTRUN(VsShellUtilitiesTest);
	UTRUN(VsReportErrorUtilitiesTest);
	UTRUN(LoadUILibraryRequiredTest);
	UTRUN(IVsPackageImplTest);
	UTRUN(IVsPackageImplLoadUILibraryNoopTest);
	UTRUN(IVsPackageImplSetSiteEventsTest);
	UTRUN(IVsInstalledProductImplTest);
	UTRUN(IVsInstalledProductImplBadTemplateArgsTest);
	UTRUN(DllEntryPointsTest);
	UTRUN(OleComponentUIManagerUtilitiesGlobalTest);
	UTRUN(OleComponentUIManagerUtilitiesLocalTest);
	UTRUN(FunctorTest);
	return VSL::FailureCounter::Get();
}

EXTERN_C const GUID DECLSPEC_SELECTANY g_FakeServiceGUID = // {25CACC6E-BDC0-47e8-883C-8A5E9581428F}
	{ 0x25cacc6e, 0xbdc0, 0x47e8, { 0x88, 0x3c, 0x8a, 0x5e, 0x95, 0x81, 0x42, 0x8f } };
EXTERN_C const CComBSTR DECLSPEC_SELECTANY g_FakeString = L"Test";
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\UnitTest\MockInterfaces\System.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

typedef AddRefAndReleaseMockBase<NullBase> AddRefAndReleaseMockNullBase;

VSL_DEFINE_VIRTUAL_DESTRUCTOR_TEST_HELPER(AddRefAndReleaseMockNullBase);

class AddRefAndReleaseMockTest :
	public UnitTestBase
{
private:

	void BasicTest()
	{
		AddRefAndReleaseMockBase<NullBase> mock;
		UTCHKEX(mock.GetRefCount() == 0, _T("after construction"));
		ULONG iRefCount = mock.AddRef();
		UTCHKEX(iRefCount == 1, _T("after AddRef"));
		UTCHKEX(mock.GetRefCount() == 1, _T("after AddRef"));
		iRefCount = mock.Release();
		UTCHKEX(iRefCount == 0, _T("after Release"));
		UTCHKEX(mock.GetRefCount() == 0, _T("after Release"));
	}

	void DestructorTest()
	{
		VSL_STDMETHODTRY
		{
			AddRefAndReleaseMockBase<NullBase> mock;
			mock.AddRef();
		}
		VSL_STDMETHODCATCH()
		UTCHKEX(VSL_GET_STDMETHOD_HRESULT() == E_FAIL, _T("Destruction did not throw"));
	}

	void AddRefAfterFinalReleaseTest()
	{
		VSL_STDMETHODTRY
		{
			AddRefAndReleaseMockBase<NullBase> mock;
			mock.AddRef();
			mock.Release();
			mock.AddRef();
		}
		VSL_STDMETHODCATCH()
		UTCHKEX(VSL_GET_STDMETHOD_HRESULT() == E_FAIL, _T("AddRef after final Release did not throw"));
	}

	void AddRefWrapAroundTest()
	{
// BUGBUG - the CRT chokes on the exception thrown by AddRef here, but the above works fine
// Try again with a recent VS build and open a bug if it still repros.
#if 0
		VSL_STDMETHODTRY
		{
			AddRefAndReleaseMockBase<NullBase> mock;
			mock.SetRefCount(LONG_MAX);
			mock.AddRef();
		}
		VSL_STDMETHODCATCH()
		UTCHKEX(VSL_GET_STDMETHOD_HRESULT() == E_FAIL, _T("AddRef that would wrap ref count did not throw"));
#endif
	}

	void ExtraReleaseTest()
	{
		VSL_STDMETHODTRY
		{
			AddRefAndReleaseMockBase<NullBase> mock;
			mock.AddRef();
			mock.Release();
			mock.Release();
		}
		VSL_STDMETHODCATCH()
		UTCHKEX(VSL_GET_STDMETHOD_HRESULT() == E_FAIL, _T("Extra Release call did not throw"));
	}

public:

	AddRefAndReleaseMockTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
		BasicTest();
		DestructorTest();
		AddRefAfterFinalReleaseTest();
		AddRefWrapAroundTest();
		ExtraReleaseTest();
	}
};

template <class BaseClass_T = ISimple>
class SimpleCOMMock :
	public AddRefAndReleaseMockBase<BaseClass_T>
{

VSL_DECLARE_NOT_COPYABLE(SimpleCOMMock)

public:

	SimpleCOMMock() {}

	STDMETHOD(QueryInterface)(REFIID /*iid*/, void** /*ppObject*/)
	{
		return E_NOTIMPL;
	}
};

class Supported
{
public:
	static HRESULT TestQueryInterface()
	{
		return S_OK;
	}
	static bool TestPointer(void* pVoid)
	{
		return pVoid != NULL;
	}
	static bool TestRefCount(LONG iCurrentRefCount, LONG iLastRefCount)
	{
		return iCurrentRefCount == iLastRefCount + 1;
	}
};

class NotSupported
{
public:
	static HRESULT TestQueryInterface()
	{
		return E_NOINTERFACE;
	}
	static bool TestPointer(void* pVoid)
	{
		return pVoid == NULL;
	}
	static bool TestRefCount(LONG iCurrentRefCount, LONG iLastRefCount)
	{
		return iCurrentRefCount == iLastRefCount;
	}
};

template <class Mock_T, class InterfaceList_T>
class InternalQueryInterfaceTestBase :
	public UnitTestBase
{
public:

	template <class Interface_T, class Test_T>
	void TestForInterface(Mock_T &mock)
	{
		void* pVoid = NULL;
		LONG iLastRefCount = mock.GetRefCount();
		UTCHKEX(InterfaceList_T::InternalQueryInterface(&mock, __uuidof(Interface_T), &pVoid) == Test_T::TestQueryInterface(), _T(""));
		UTCHKEX(Test_T::TestPointer(pVoid), _T(""));
		UTCHKEX(Test_T::TestRefCount(mock.GetRefCount(), iLastRefCount), _T(""));
	}

	InternalQueryInterfaceTestBase(const char* const szTestName):
		UnitTestBase(szTestName)
	{
	}
};

class IUnknownInterfaceListTerminatorDefaultTest :
	public InternalQueryInterfaceTestBase<SimpleCOMMock<>, IUnknownInterfaceListTerminatorDefault>
{
private:

public:
	IUnknownInterfaceListTerminatorDefaultTest(_In_opt_ const char* const szTestName):
		InternalQueryInterfaceTestBase(szTestName)
	{
		// compile time test
		C_ASSERT(IUnknownInterfaceListTerminatorDefault::NumberOfInterfaces == 1);

		// runtime tests
		SimpleCOMMock<> mock;
		TestForInterface<IUnknown, Supported>(mock);
		TestForInterface<IDispatch, NotSupported>(mock);
		mock.SetRefCount(0);
	}
};

class NullInterfaceListTerminator
{

VSL_DECLARE_NOT_COPYABLE(NullInterfaceListTerminator)

public:

	NullInterfaceListTerminator() {}

	~NullInterfaceListTerminator()	{} // This should not be virtual, or it will cause a false positive

	enum { NumberOfInterfaces = 0 };

	template<typename This_T>
	static HRESULT InternalQueryInterface(This_T* /*pThis*/, REFIID /*iid*/, void** /*ppObject*/)
	{
		return E_NOINTERFACE;
	}
};

typedef InterfaceList<ISimple, IUnknownInterfaceListTerminatorDefault> SimpleInterfaceList;
typedef SimpleCOMMock<SimpleInterfaceList > SimpleMockInterfaceList;

class InterfaceListTest :
	public InternalQueryInterfaceTestBase<SimpleCOMMock<>, SimpleMockInterfaceList>
{
protected:

public:
	InterfaceListTest(_In_opt_ const char* const szTestName):
		InternalQueryInterfaceTestBase(szTestName)
	{
		// compile time test
		SimpleMockInterfaceList obj1;
		C_ASSERT(SimpleMockInterfaceList::NumberOfInterfaces == 2);

		// runtime tests
		SimpleCOMMock<> mock;
		TestForInterface<IUnknown, Supported>(mock);
		TestForInterface<ISimple, Supported>(mock);
		TestForInterface<IDispatch, NotSupported>(mock);
		mock.SetRefCount(0);
	}
};

template <class ISimpleMock_T>
class ISimpleMockTestBase :
	public UnitTestBase
{
public:
	template <class Interface_T, class Test_T>
	void TestForInterface(ISimpleMock_T &mock)
	{
		void* pVoid = NULL;
		LONG iLastRefCount = mock.GetRefCount();
		UTCHKEX(mock.QueryInterface(__uuidof(Interface_T), &pVoid) == Test_T::TestQueryInterface(), _T(""));
		UTCHKEX(Test_T::TestPointer(pVoid), _T(""));
		UTCHKEX(Test_T::TestRefCount(mock.GetRefCount(), iLastRefCount), _T(""));
	}

	ISimpleMockTestBase(const char* const szTestName):
		UnitTestBase(szTestName)
	{
		ISimpleMock_T mock;
		TestForInterface<IUnknown, Supported>(mock);
		TestForInterface<ISimple, Supported>(mock);
		TestForInterface<IDispatch, NotSupported>(mock);
		UTCHKEX(mock.QueryInterface(__uuidof(IUnknown), NULL) == E_POINTER, _T(""));
		UTCHKEX(mock.GetRefCount() == 2, _T("Ensure AddRef was not called after failing to pass in the out pointer"));
		mock.SetRefCount(0);
	}
};

class QueryInterfaceMockBaseHasVirtualDestructorTestHelper :
	public VirtualDestructorUnitTestHelper<QueryInterfaceMockBase<NullInterfaceListTerminator, QueryInterfaceMockBaseHasVirtualDestructorTestHelper> >
{
public:
	virtual ~QueryInterfaceMockBaseHasVirtualDestructorTestHelper() {}
};

class ISimpleImpl :
	public AddRefAndReleaseMockBase<QueryInterfaceMockBase<SimpleInterfaceList, ISimpleImpl> >
{
};

class QueryInterfaceMockBaseTest :
	public ISimpleMockTestBase<ISimpleImpl>
{
public:
	QueryInterfaceMockBaseTest(_In_opt_ const char* const szTestName):
		ISimpleMockTestBase(szTestName)
	{
	}
};

class ISimpleImpl2 :
	public COMMockBase<SimpleInterfaceList, ISimpleImpl2>
{
};

class COMMockBaseTest :
	public ISimpleMockTestBase<ISimpleImpl2>
{
public:
	COMMockBaseTest(_In_opt_ const char* const szTestName):
		ISimpleMockTestBase(szTestName)
	{
	}
};

typedef 
	InterfaceList<ISimple3, 
	InterfaceList<ISimple2, 
	InterfaceList<ISimple, IUnknownInterfaceListTerminator<ISimple2>, ISimple2> > >
		ISimpleAndDerivedInterfaceList;

VSL_DECLARE_COM_MOCK(ISimpleAndDerivedImpl, ISimpleAndDerivedInterfaceList){};

class ISimpleAndDerivedInterfaceListTest :
	public ISimpleMockTestBase<ISimpleAndDerivedImpl>
{
public:
	ISimpleAndDerivedInterfaceListTest(_In_opt_ const char* const szTestName):
		ISimpleMockTestBase(szTestName)
	{
	}
};

class I2MethodsNotImpl :
	public I2Methods
{
public:

	typedef I2Methods Interface;

	// Allow use of compiler generated copy constructors, destructor, and assignment operator

	STDMETHOD(Method1)()VSL_STDMETHOD_NOTIMPL
	STDMETHOD(Method2)()VSL_STDMETHOD_NOTIMPL

};

template <class Base_T = I2MethodsNotImpl>
class I2MethodsMethod1Impl :
	public Base_T
{
public:

	// Allow use of compiler generated copy constructors, destructor, and assignment operator

	STDMETHOD(Method1)()
	{
		return S_OK;
	}
};

template <class Base_T = I2MethodsNotImpl>
class I2MethodsMethod2Impl :
	public Base_T
{
public:

	// Allow use of compiler generated copy constructors, destructor, and assignment operator

	STDMETHOD(Method2)()
	{
		return S_OK;
	}
};

typedef InterfaceImplList<I2MethodsMethod1Impl<>, IUnknownInterfaceListTerminatorDefault> I2MethodsInterfaceList;

VSL_DECLARE_COM_MOCK(I2MethodsPartialImpl, I2MethodsInterfaceList){};

template <class Mock_T>
class GetInterfaceFromMockTestBase :
	public UnitTestBase
{
public:
	template <class Interface_T>
	Interface_T* GetInterfaceFromMock(Mock_T &mock)
	{
		IUnknown* pIUnknown = mock.GetIUnknownNoAddRef();

		Interface_T* pInterface = NULL;
		LONG iLastRefCount = mock.GetRefCount();
		UTCHKEX(pIUnknown->QueryInterface(__uuidof(Interface_T), reinterpret_cast<void**>(&pInterface)) == Supported::TestQueryInterface(), _T(""));
		UTCHKEX(Supported::TestPointer(pInterface), _T(""));
		UTCHKEX(Supported::TestRefCount(mock.GetRefCount(), iLastRefCount), _T(""));
		return pInterface;
	}

	GetInterfaceFromMockTestBase(const char* const szTestName):
		UnitTestBase(szTestName)
	{
	}
};

class I2MethodsPartialImplTest :
	public GetInterfaceFromMockTestBase<I2MethodsPartialImpl>
{
public:
	I2MethodsPartialImplTest(_In_opt_ const char* const szTestName):
		GetInterfaceFromMockTestBase(szTestName)
	{
		I2MethodsPartialImpl mock;

		I2Methods* pI2Methods = GetInterfaceFromMock<I2Methods>(mock);

		UTCHKEX(pI2Methods->Method1() == S_OK, _T(""));
		UTCHKEX(pI2Methods->Method2() == E_NOTIMPL, _T(""));

		mock.SetRefCount(0);
	}
};

typedef InterfaceImplList<I2MethodsMethod2Impl<I2MethodsMethod1Impl<> >, IUnknownInterfaceListTerminatorDefault > I2MethodsInterfaceListFullImpl;

VSL_DECLARE_COM_MOCK(I2MethodsFullImpl, I2MethodsInterfaceListFullImpl){};

class I2MethodsFullImplTest :
	public GetInterfaceFromMockTestBase<I2MethodsFullImpl>
{
public:
	I2MethodsFullImplTest (_In_opt_ const char* const szTestName):
		GetInterfaceFromMockTestBase(szTestName)
	{
		I2MethodsFullImpl mock;

		I2Methods* pI2Methods = GetInterfaceFromMock<I2Methods>(mock);

		UTCHKEX(pI2Methods->Method1() == S_OK, _T(""));
		UTCHKEX(pI2Methods->Method2() == S_OK, _T(""));

		mock.SetRefCount(0);
	}
};

class AtlIServiceProviderImplAdaptorMock;

// TODO - test that AtlIServiceProviderImplAdaptor has a virtual destructor

typedef InterfaceImplList<AtlIServiceProviderImplAdaptor<AtlIServiceProviderImplAdaptorMock>, InterfaceImplList<I2MethodsMethod2Impl<I2MethodsMethod1Impl<> >, IUnknownInterfaceListTerminator<IServiceProvider> > > AtlIServiceProviderImplAdaptorMockInterfaceList;

VSL_DECLARE_COM_MOCK(AtlIServiceProviderImplAdaptorMock, AtlIServiceProviderImplAdaptorMockInterfaceList)
{

BEGIN_SERVICE_MAP(AtlIServiceProviderImplAdaptorMock)
	SERVICE_ENTRY(__uuidof(I2Methods))
END_SERVICE_MAP()

};

class AtlIServiceProviderMockTest :
	public GetInterfaceFromMockTestBase<AtlIServiceProviderImplAdaptorMock>
{
public:
	AtlIServiceProviderMockTest(_In_opt_ const char* const szTestName):
		GetInterfaceFromMockTestBase(szTestName)
	{
		AtlIServiceProviderImplAdaptorMock mock;

		IServiceProvider* pIServiceProvider = GetInterfaceFromMock<IServiceProvider>(mock);

		I2Methods* pI2Methods;
		UTCHKEX(pIServiceProvider->QueryService(__uuidof(I2Methods), __uuidof(I2Methods), reinterpret_cast<void**>(&pI2Methods)) == S_OK, _T(""));
		UTCHKEX(mock.GetRefCount() == 2, _T("Ensure AddRef was called before returning I2Methods"));
		UTCHKEX(pI2Methods != NULL, _T(""));
		if(pI2Methods != NULL)
		{
			UTCHKEX(pI2Methods->Method1() == S_OK, _T(""));
			UTCHKEX(pI2Methods->Method2() == S_OK, _T(""));
		}

		mock.SetRefCount(0);
	}
};

VSL_DEFINE_SERVICE_MOCK(I2MethodsServiceProvider, I2MethodsMethod2Impl<I2MethodsMethod1Impl<> >);

typedef ServiceList<I2MethodsServiceProvider, ServiceListTerminator> IServiceProviderImplServiceList;
typedef InterfaceImplList<VSL::IServiceProviderImpl<IServiceProviderImplServiceList>, IUnknownInterfaceListTerminator<IServiceProvider> > IServiceProviderImplMockInterfaceList;

VSL_DECLARE_COM_MOCK(IServiceProviderImplMock, IServiceProviderImplMockInterfaceList){};

class IServiceProviderImplMockTest :
	public GetInterfaceFromMockTestBase<IServiceProviderImplMock>
{
public:
	IServiceProviderImplMockTest(_In_opt_ const char* const szTestName):
		GetInterfaceFromMockTestBase(szTestName)
	{
		IServiceProviderImplMock mock;

		IServiceProvider* pIServiceProvider = GetInterfaceFromMock<IServiceProvider>(mock);

		CComPtr<I2Methods> pI2Methods;
		UTCHKEX(pIServiceProvider->QueryService(__uuidof(I2Methods), __uuidof(I2Methods), reinterpret_cast<void**>(&pI2Methods)) == S_OK, _T(""));
		UTCHKEX(pI2Methods != NULL, _T(""));
		UTCHKEX(pI2Methods->Method1() == S_OK, _T(""));
		UTCHKEX(pI2Methods->Method2() == S_OK, _T(""));

		mock.SetRefCount(0);
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\UnitTest\Package\stdafx.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#pragma once

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#define NOMINMAX

// REVIEW - some or all of these /analyze warnings in the
// common headers should be fixed for RTM, re-enable the
// ones that are
#pragma warning(push)
#pragma warning(disable : 6011 6054 6309 6387 6535 6387)

#include <atlbase.h>
#include <atlcom.h>
#include <atlstr.h>
#include <limits>

#pragma warning(pop)

#define VSLASSERT _ASSERTE
#define VSLASSERTEX(exp, szMsg) _ASSERT_BASE(exp, szMsg)
#define VSL_TRACE ATLTRACE

#include "VSLUnitTest.h"
#include "VSLExceptionHandlers.h"
#include "VSLMockSystemInterfaces.h"
#include "VSLMockVisualStudioInterfaces.h"
#include "VSLMockIOleComponentUIManager.h"
#include "VSLContainers.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\UnitTest\WindowsAndControls\stdafx.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#pragma once

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#pragma warning(push)

// REVIEW - some or all of these /analyze warnings in the
// common headers should be fixed for RTM, re-enable the
// ones that are
#pragma warning(disable : 6011 6054 6309 6387 6535 6387 4505)

#define _ATL_NO_HOSTING

#include <atlbase.h>
#include <atlcom.h>
#include <atlstr.h>
#include <atlwin.h>
#include <atlfile.h>
#include <atlsafe.h> // Used by the font unit test
#include <DTE.h>
#include <queue>

#pragma warning(pop)

#include <VsShellInterfaces.h>
#include <fpstfmt.h> // for IPersistFileFormat
#include <IVsQueryEditQuerySave2.h> // for IVsQueryEditQuerySave2
#include <TextFind.h> // for IVsFindTarget

#define VSLASSERT _ASSERTE
#define VSLASSERTEX(exp, szMsg) _ASSERT_BASE(exp, szMsg)
#define VSLTRACE ATLTRACE

#include "VSLUnitTest.h"
#include "VSLMockSystemInterfaces.h"
#include "VSLMockVisualStudioInterfaces.h"
#include "VSLPackage.h"
#include "VSLShortNameDefines.h"
#include <VSLMockIVsQueryEditQuerySave2.h>
#include <VSLMockIVsFileChangeEx.h>
#include <VSLMockIVsRunningDocumentTable.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\UnitTest\WindowsAndControls\WindowFrameEventSinkTest.h ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

class WindowFrameEventsSinkTest :
	public VSL::UnitTestBase
{
public:
	WindowFrameEventsSinkTest(_In_opt_ const char* const szTestName);

private:
	void CheckSubscribeUnsubscribe();
	void CheckEvents();
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\UnitTest\WindowsAndControls\WindowFrameEventSinkTest.cpp ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#include "stdafx.h"

#include "WindowFrameEventSinkTest.h"
#include <VSLWindows.h>

using namespace VSL;

typedef VSL::AddRefAndReleaseMockBase<TypeNull> RefCountedBase;

template <class Derived_T>
class TestSinkBase :
	public VSL::VsWindowFrameEventSink<Derived_T>,
	public RefCountedBase
{
public:
	virtual ULONG _stdcall AddRef() { return RefCountedBase::AddRef(); }
    virtual ULONG _stdcall Release() { return RefCountedBase::Release(); }
	STDMETHOD(QueryInterface)(REFGUID iid, void** ppOut)
	{
		if (NULL == ppOut)
		{
			return E_POINTER;
		}
		*ppOut = NULL;
		if ((IID_IUnknown == iid) || (IID_IVsWindowFrameNotify == iid))
		{
			*ppOut = static_cast<IVsWindowFrameNotify*>(this);
		}
		else if (IID_IVsWindowFrameNotify3 == iid)
		{
			*ppOut = static_cast<IVsWindowFrameNotify3*>(this);
		}
		else
		{
			return E_NOINTERFACE;
		}
		AddRef();
		return S_OK;
	}
};

class TestSinkNoEvents :
	public TestSinkBase<TestSinkNoEvents>
{
};

class TestSinkWithEvents :
	public TestSinkBase<TestSinkWithEvents>
{
public:
	enum EventType
	{
		OnShowEvent,
		OnMoveEvent,
		OnSizeEvent,
		OnDockableChangeEvent,
		OnCloseEvent
	};

	template <EventType event_T>
	bool& IsCalled()
	{
		static bool bIsCalled = false;
		return bIsCalled;
	}

	void OnFrameShow(FRAMESHOW2 /*fShow*/)
	{
		IsCalled<OnShowEvent>() = true;
	}

	void OnFrameMove(int /*x*/, int /*y*/, int /*w*/, int /*h*/)
	{
		IsCalled<OnMoveEvent>() = true;
	}

	void OnFrameSize(int /*x*/, int /*y*/, int /*w*/, int /*h*/)
	{
		IsCalled<OnSizeEvent>() = true;
	}

	void OnFrameDockableChange(BOOL /*fDockable*/, int /*x*/, int /*y*/, int /*w*/, int /*h*/)
	{
		IsCalled<OnDockableChangeEvent>() = true;
	}

	void OnFrameClose(FRAMECLOSE* /*pgrfSaveOptions*/)
	{
		IsCalled<OnCloseEvent>() = true;
	}
};

class WindowFrameServiceProvider :
	public VSL::IVsWindowFrameNotImpl,
	public VSL::IVsWindowFrame2NotImpl,
	public ATL::IServiceProviderImpl<WindowFrameServiceProvider>,
	public VSL::IVsShellNotImpl,
	public VSL::IVsUIShellNotImpl
{
public:

	BEGIN_SERVICE_MAP(WindowFrameServiceProvider)
		SERVICE_ENTRY(SID_SVsWindowFrame)
		SERVICE_ENTRY(SID_SVsShell)
		SERVICE_ENTRY(SID_SVsUIShell)
	END_SERVICE_MAP()

	virtual ULONG _stdcall AddRef() 
	{
		return ++m_uiRefCount;
	}
    virtual ULONG _stdcall Release() 
	{ 
		VSL_CHECKBOOL(0 < m_uiRefCount, E_FAIL);
		return --m_uiRefCount; 
	}
	STDMETHOD(QueryInterface)(REFGUID iid, void** ppOut)
	{
		if (NULL == ppOut)
		{
			return E_POINTER;
		}
		*ppOut = NULL;
		if ((IID_IUnknown == iid) || (IID_IVsWindowFrame == iid))
		{
			*ppOut = static_cast<IVsWindowFrame*>(this);
		}
		else if (IID_IVsWindowFrame2 == iid)
		{
			*ppOut = static_cast<IVsWindowFrame2*>(this);
		}
		else if (__uuidof(IVsShell) == iid)
		{
			*ppOut = static_cast<IVsShell*>(this);
		}
		else if (__uuidof(IVsUIShell) == iid)
		{
			*ppOut = static_cast<IVsUIShell*>(this);
		}
		else
		{
			return E_NOINTERFACE;
		}
		AddRef();
		return S_OK;
	}

	WindowFrameServiceProvider() :
		m_uiNextCookie(0),
		m_uiRefCount(0)
	{
	}

	~WindowFrameServiceProvider()
	{
		VSL_CHECKBOOL(0 == m_uiRefCount, E_FAIL);
		for (int i=0; i<s_MaxSubscriptions; ++i)
			VSL_CHECKBOOL(m_srpCallbacks[i]==NULL, E_FAIL);
	}

	STDMETHOD(CloseFrame)(FRAMECLOSE /*grfSaveOptions*/)
	{
		for (int i=0; i<s_MaxSubscriptions; ++i)
		{
			CComPtr<IVsWindowFrameNotify3> srpNotify;
			if ( (m_srpCallbacks[i] != NULL) && 
				 SUCCEEDED(m_srpCallbacks[i]->QueryInterface(IID_IVsWindowFrameNotify3, (void**)&srpNotify)) )
			{
				VSL_CHECKHRESULT(srpNotify->OnClose(0));
			}
		}
		return S_OK;
	}

	STDMETHOD(Advise)(IVsWindowFrameNotify* pNotify, VSCOOKIE* pdwCookie)
	{
		VSL_CHECKBOOL(NULL != pdwCookie, E_POINTER);
		m_srpCallbacks[m_uiNextCookie] = pNotify;
		++m_uiNextCookie;
		// Disable warning 6011 because prefast doesn't realize that VSL_CHECKBOOL will throw
		// if NULL == pdwCookie
		#pragma warning(push)
		#pragma warning(disable:6011)
		*pdwCookie = m_uiNextCookie;
		#pragma warning(pop)
		return S_OK;
	}
	STDMETHOD(Unadvise)(VSCOOKIE dwCookie)
	{
		UINT dwSubscription = (UINT)dwCookie;
		VSL_CHECKBOOL(dwSubscription <= s_MaxSubscriptions, E_UNEXPECTED);
		VSL_CHECKBOOL(dwSubscription > 0, E_UNEXPECTED);
		// Disable warning 6386 because prefast does not realize that an exception is thrown
		// if any of the previous tests fail.
		#pragma warning(push)
		#pragma warning(disable:6386)
		VSL_CHECKBOOL(m_srpCallbacks[dwSubscription-1]!=NULL, E_UNEXPECTED);
		m_srpCallbacks[dwSubscription-1].Release();
		#pragma warning(pop)
		return S_OK;
	}

private:
	UINT m_uiNextCookie;
	UINT m_uiRefCount;
	static const size_t s_MaxSubscriptions = 8; // 8 is arbitrary; this test will use at most 2 subscriptions.
	CComPtr<IVsWindowFrameNotify> m_srpCallbacks[s_MaxSubscriptions]; 
};

void WindowFrameEventsSinkTest::CheckSubscribeUnsubscribe()
{
// TODO - fix up the mock provider, so this will actually work
// Need to have the above use the standard mock infrastructure.
#if 0
	// Create the service provider that contains the window frame.
	WindowFrameServiceProvider providerWithWindowFrame;
	IServiceProvider* pProvider = static_cast<IServiceProvider*>(&providerWithWindowFrame);
	{
		CComPtr<IVsWindowFrame> spFrame;
		VSL_CHECKHRESULT(pProvider->QueryService(SID_SVsWindowFrame, IID_IVsWindowFrame, (void**)&spFrame));
		// Create the event sink
		TestSinkNoEvents sink;
		CComPtr<IVsWindowFrameNotify> spFrameNotify;
		VSL_CHECKHRESULT(sink.QueryInterface(IID_IVsWindowFrameNotify, (void**)&spFrameNotify));
		VsSiteCache<> cache;
		cache.SetSite(pProvider);
		// Check that calling it again will release the previous subscription.
		sink.SetSite(cache);
		spFrame->CloseFrame(0);
	}
#endif
}

void WindowFrameEventsSinkTest::CheckEvents()
{
	TestSinkWithEvents sink;
	// Get a pointer to the old interface.
	CComPtr<IVsWindowFrameNotify> spOldNotify;
	VSL_CHECKHRESULT(sink.QueryInterface(IID_IVsWindowFrameNotify, (void**)&spOldNotify));

	// Check that the methods specific of the old callback interface returns E_NOTIMPL.
	VSL_CHECKBOOL(E_NOTIMPL == spOldNotify->OnMove(), E_FAIL);
	VSL_CHECKBOOL(!sink.IsCalled<TestSinkWithEvents::OnMoveEvent>(), E_FAIL);

	VSL_CHECKBOOL(E_NOTIMPL == spOldNotify->OnSize(), E_FAIL);
	VSL_CHECKBOOL(!sink.IsCalled<TestSinkWithEvents::OnSizeEvent>(), E_FAIL);

	VSL_CHECKBOOL(E_NOTIMPL == spOldNotify->OnDockableChange(TRUE), E_FAIL);
	VSL_CHECKBOOL(!sink.IsCalled<TestSinkWithEvents::OnDockableChangeEvent>(), E_FAIL);

	// Now check that the method that is common to the two interfaces have the same effect.
	VSL_CHECKHRESULT(spOldNotify->OnShow(0));
	VSL_CHECKBOOL(sink.IsCalled<TestSinkWithEvents::OnShowEvent>(), E_FAIL);
	sink.IsCalled<TestSinkWithEvents::OnShowEvent>() = false;

	// Get the pointer to the new version of the interface.
	CComPtr<IVsWindowFrameNotify3> spNewNotify;
	VSL_CHECKHRESULT(sink.QueryInterface(IID_IVsWindowFrameNotify3, (void**)&spNewNotify));

	VSL_CHECKHRESULT(spNewNotify->OnShow(0));
	VSL_CHECKBOOL(sink.IsCalled<TestSinkWithEvents::OnShowEvent>(), E_FAIL);

	VSL_CHECKHRESULT(spNewNotify->OnMove(0, 0, 0, 0));
	VSL_CHECKBOOL(sink.IsCalled<TestSinkWithEvents::OnMoveEvent>(), E_FAIL);

	VSL_CHECKHRESULT(spNewNotify->OnSize(0, 0, 0, 0));
	VSL_CHECKBOOL(sink.IsCalled<TestSinkWithEvents::OnSizeEvent>(), E_FAIL);

	VSL_CHECKHRESULT(spNewNotify->OnDockableChange(TRUE, 0, 0, 0, 0));
	VSL_CHECKBOOL(sink.IsCalled<TestSinkWithEvents::OnDockableChangeEvent>(), E_FAIL);

	VSL_CHECKHRESULT(spNewNotify->OnDockableChange(TRUE, 0, 0, 0, 0));
	VSL_CHECKBOOL(sink.IsCalled<TestSinkWithEvents::OnDockableChangeEvent>(), E_FAIL);

	FRAMECLOSE frameClose = 0;
	VSL_CHECKHRESULT(spNewNotify->OnClose(&frameClose));
	VSL_CHECKBOOL(sink.IsCalled<TestSinkWithEvents::OnCloseEvent>(), E_FAIL);
}

WindowFrameEventsSinkTest::WindowFrameEventsSinkTest(const char* const szTestName) :
	VSL::UnitTestBase(szTestName)
{
	CheckSubscribeUnsubscribe();
	CheckEvents();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CPP\VSL\UnitTest\WindowsAndControls\WindowsAndControls.cpp ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

This code is a part of the Visual Studio Library.

***************************************************************************/

#include "stdafx.h"

#include "VSLWindows.h"
#include "WindowFrameEventSinkTest.h"

// Disable these warnings inorder to test the failure runtime failure handling
#pragma warning(disable : 6309) // Argument '1' is null: this does not adhere to function specification of
#pragma warning(disable : 6387) // 'argument 1' might be '0': this does not adhere to the specification for the function

using namespace VSL;

// NOTE - ListViewWin32Control and Win32ControlContainer are unit tested in the course of unit testing the Tool Window reference sample.
// NOTE - RichEditWin32Control and Win32ControlContainer are unit tested in the course of unit testing the Single View Editor reference sample.

VSL_DEFINE_SERVICE_MOCK(IVsUIShellServiceMock, IVsUIShellMockImpl);
VSL_DEFINE_SERVICE_MOCK(IVsShellServiceMock, IVsShellNotImpl);

typedef ServiceList<IVsShellServiceMock, ServiceList<IVsUIShellServiceMock, ServiceListTerminator> > PackageIServiceProviderServiceList;
typedef InterfaceImplList<VSL::IServiceProviderImpl<PackageIServiceProviderServiceList>, IUnknownInterfaceListTerminator<IServiceProvider> > PackageIServiceProviderInterfaceList;

VSL_DECLARE_COM_MOCK(PackageIServiceProviderMock, PackageIServiceProviderInterfaceList){};

class TestToolWindow :
	public ToolWindowBase<TestToolWindow, VsSiteCacheLocal, VsSiteCacheLocal>,
	public MockBase
{
public:

	typedef void (TestToolWindow::*CalledMethod)();

private:

public:

	bool HasIVsWindowFrame() const
	{
		return (GetIVsWindowFrame() != NULL);
	}

	TestToolWindow(const PackageVsSiteCache& rPackageVsSiteCache):
		ToolWindowBase(rPackageVsSiteCache)
	{
	}

	VSCREATETOOLWIN GetCreationFlags() const
	{
		return CTW_fInitNew;
	}

	REFCLSID GetToolWindowGuid() const
	{
		return GUID_NULL;
	}

	const wchar_t* const GetCaption() const
	{
		return L"";
	}

	void PreCreate()
	{
		Called<CalledMethod, &TestToolWindow::PreCreate>(true);
	}

	void PostCreate()
	{
		Called<CalledMethod, &TestToolWindow::PostCreate>(true);
	}

	void PreShowActivate()
	{
		Called<CalledMethod, &TestToolWindow::PreShowActivate>(true);
	}

	void PreShowNoActivate()
	{
		Called<CalledMethod, &TestToolWindow::PreShowNoActivate>(true);
	}

	void PreShow(bool bActivate)
	{
		bActivate ? PreShowActivate() : PreShowNoActivate();
	}

	void PostShowActivate()
	{
		Called<CalledMethod, &TestToolWindow::PostShowActivate>(true);
	}

	void PostShowNoActivate()
	{
		Called<CalledMethod, &TestToolWindow::PostShowNoActivate>(true);
	}

	void PostShow(bool bActivate)
	{
		bActivate ? PostShowActivate() : PostShowNoActivate();
	}
};

class TestToolWindow2Controls
{
public:
class ControlViewObject { enum { ViewObject	}; };

class ControlViewCLSID { enum { ViewCLSID }; };
};

template <class Control_T>
class TestToolWindow2 :
	public ToolWindowBase<TestToolWindow2<Control_T>, VsSiteCacheLocal, VsSiteCacheLocal>
{
public:

	bool HasIVsWindowFrame() const
	{
		return (GetIVsWindowFrame() != NULL);
	}

	static IVsUIShellMockImpl::CreateToolWindowValidValues& GetValidValues()
	{
	__if_exists(Control_T::ViewCLSID)
	{
	}
		static BOOL fDefaultPosition = FALSE;
		static IVsWindowFrame* pWindowFrame = NULL;
		static IVsUIShellMockImpl::CreateToolWindowValidValues values =
		{
			CTW_fInitNew, // VSCREATETOOLWIN grfCTW;
			1, // DWORD dwToolWindowId;

			__if_exists(Control_T::ViewObject)
			{
			reinterpret_cast<IUnknown*>(1), // IUnknown* punkTool;
			}
			__if_not_exists(Control_T::ViewObject)
			{
			NULL, // IUnknown* punkTool;
			}

			__if_exists(Control_T::ViewCLSID)
			{
			__uuidof(IUnknown), // REFCLSID rclsidTool;
			}
			__if_not_exists(Control_T::ViewCLSID)
			{
			GUID_NULL, // REFCLSID rclsidTool;
			}

			__uuidof(IUnknown), // REFGUID rguidPersistenceSlot;
			GUID_NULL, // REFGUID rguidAutoActivate;
			reinterpret_cast<IServiceProvider*>(1), // IServiceProvider* pSP;
			L"", // LPCOLESTR pszCaption;
			&fDefaultPosition, // BOOL* pfDefaultPosition;
			&pWindowFrame, // IVsWindowFrame** ppWindowFrame;
			S_OK // HRESULT hr;
		};
		return values;
	}

	TestToolWindow2(const PackageVsSiteCache& rPackageVsSiteCache):
		ToolWindowBase(rPackageVsSiteCache)
	{
	}

	VSCREATETOOLWIN GetCreationFlags() const
	{
		return GetValidValues().grfCTW;
	}

	REFCLSID GetToolWindowGuid() const
	{
		return GetValidValues().rguidPersistenceSlot;
	}

	const wchar_t* const GetCaption() const
	{
		return GetValidValues().pszCaption;
	}

	DWORD GetInstanceID() const 
	{
		return GetValidValues().dwToolWindowId;
	}

	__if_exists(Control_T::ViewObject)
	{

	IUnknown* GetViewObject() const
	{
		return GetValidValues().punkTool;
	}

	}

	__if_exists(Control_T::ViewCLSID)
	{

	REFCLSID GetLocalRegistryCLSIDViewObject() const
	{
		return GetValidValues().rclsidTool;
	}

	}

	IServiceProvider* GetToolWindowServiceProvider() const
	{
		return GetValidValues().pSP;
	}
};

class VsServiceProvider
{
public:
	static IServiceProvider* GetServiceProvider()
	{
		static PackageIServiceProviderMock packageIServiceProviderMock;
		static CComQIPtr<IServiceProvider> spIServiceProvider = packageIServiceProviderMock.GetIUnknownNoAddRef();
		static CComPtr<IVsShell> spIVsShell;
		if(spIVsShell == NULL)
		{
			spIServiceProvider->QueryService(SID_SVsShell, &spIVsShell);
		}
		static CComPtr<IVsUIShell> spIVsUIShell;
		if(spIVsUIShell == NULL)
		{
			spIServiceProvider->QueryService(SID_SVsUIShell, &spIVsUIShell);
		}
		return spIServiceProvider;
	}
};

typedef InterfaceImplList<IVsWindowFrameMockImpl, IUnknownInterfaceListTerminator<> > IVsWindowFrameInterfaceList;

VSL_DECLARE_COM_MOCK(IVsWindowFrameMock, IVsWindowFrameInterfaceList){};

class ToolWindowBaseTest :
	public UnitTestBase
{
private:

	template <class ToolWindow_T>
	void CheckCreated(const ToolWindow_T& testToolWindow, const VsSiteCacheLocal& siteCache, bool bCreated = false)
	{
		UTCHK(testToolWindow.HasBeenCreated() == bCreated);
		// Should have the same site cache that was passed in
		const VsSiteCacheLocal& rSiteCache = testToolWindow.GetPackageVsSiteCache();
		UTCHK(&rSiteCache == &siteCache);
		UTCHK((testToolWindow.GetVsSiteCache().GetSite() != NULL) == bCreated);
		UTCHK(testToolWindow.HasIVsWindowFrame() == bCreated);
	}

	void CheckCreate(int iPreCreateNTimes = 0, int iPostCreateNTimes = 0)
	{
		UTCHK((TestToolWindow::WasMethodCalled<TestToolWindow::CalledMethod, &TestToolWindow::PreCreate>(iPreCreateNTimes)));
		UTCHK((TestToolWindow::WasMethodCalled<TestToolWindow::CalledMethod, &TestToolWindow::PostCreate>(iPostCreateNTimes)));
	}

	void CheckShow(int iActivateNTimes = 0, int iNoActivateNTimes = 0)
	{
		UTCHK((TestToolWindow::WasMethodCalled<TestToolWindow::CalledMethod, &TestToolWindow::PreShowActivate>(iActivateNTimes)));
		UTCHK((TestToolWindow::WasMethodCalled<TestToolWindow::CalledMethod, &TestToolWindow::PostShowActivate>(iActivateNTimes)));
		UTCHK((TestToolWindow::WasMethodCalled<TestToolWindow::CalledMethod, &TestToolWindow::PreShowNoActivate>(iNoActivateNTimes)));
		UTCHK((TestToolWindow::WasMethodCalled<TestToolWindow::CalledMethod, &TestToolWindow::PostShowNoActivate>(iNoActivateNTimes)));
	}

	void TestCreateAndShowActivate(TestToolWindow& testToolWindow)
	{
		testToolWindow.CreateAndShow(true);
		CheckShow(true);
		UTCHK(testToolWindow.HasBeenCreated() == true);
	}

	void TestCreateAndShowNoActivate(TestToolWindow& testToolWindow)
	{
		testToolWindow.CreateAndShow(false);
		CheckShow(false, true);
		UTCHK(testToolWindow.HasBeenCreated() == true);
	}

	void CheckShowAlreadyCreated(
		TestToolWindow& testToolWindow, 
		const VsSiteCacheLocal& siteCache, 
		bool bActivate = false, 
		bool bNoActivate = false)
	{
		CheckCreate();
		CheckCreated(testToolWindow, siteCache, true);
		CheckShow(bActivate, bNoActivate);
	}

	void SetCreateToolWindowValidValues(const TestToolWindow& testToolWindow, IVsWindowFrame** ppWindowFrame, HRESULT retValue = S_OK)
	{
		static BOOL fDefaultPosition = TRUE;
		CREATEVV(IVsUIShell, CreateToolWindow, values)
		{
			testToolWindow.GetCreationFlags(), // VSCREATETOOLWIN grfCTW;
			0, // DWORD dwToolWindowId;
			NULL, // IUnknown* punkTool;
			GUID_NULL, // REFCLSID rclsidTool;
			testToolWindow.GetToolWindowGuid(), // REFGUID rguidPersistenceSlot;
			GUID_NULL, // REFGUID rguidAutoActivate;
			NULL, // IServiceProvider* pSP;
			testToolWindow.GetCaption(), // LPCOLESTR pszCaption;
			&fDefaultPosition, // BOOL* pfDefaultPosition;
			ppWindowFrame, // IVsWindowFrame** ppWindowFrame;
			retValue // HRESULT hr;
		};

		PUSHVV(values);
	}

public:
	ToolWindowBaseTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
		// This need to be declared before testToolWindow, so it will get destroyed after,
		// so that testToolWindow will have the chance to release it before it is destroyed.
		IVsWindowFrameMock mockIVsWindowFrame;
		CComQIPtr<IVsWindowFrame> spIVsWindowFrame = mockIVsWindowFrame.GetIUnknownNoAddRef();

		// Create the tool window with an uninitialized site cache
		VsSiteCacheLocal siteCache;

		SETVV1(IVsWindowFrame, ShowNoActivate, S_OK);
		SETVV1(IVsWindowFrame, Show, S_OK);

		CComVariant varServiceProvider(VsServiceProvider::GetServiceProvider());
		SETVV3(IVsWindowFrame, GetProperty, VSFPROPID_SPFrame, &varServiceProvider, S_OK);

		{
		TestToolWindow testToolWindow(siteCache);
		CheckCreated(testToolWindow, siteCache);

		// Initialize the site cache
		siteCache.SetSite(VsServiceProvider::GetServiceProvider());
		CheckCreated(testToolWindow, siteCache);
		UTCHK(testToolWindow.GetPackageVsSiteCache().GetSite() != NULL);

		// Fail the Create method and Show calls.
		IVsWindowFrame* pWindowFrame = NULL;
		SetCreateToolWindowValidValues(testToolWindow, &pWindowFrame, E_FAIL);

		HRESULT VSL_STDMETHOD_HRESULT = VSL_STDMETHOD_HRESULT_INIT;
		try{

		testToolWindow.Create();

		}VSL_STDMETHODCATCH()
		UTCHK(VSL_GET_STDMETHOD_HRESULT() == E_FAIL);
		CheckCreate(true);
		CheckCreated(testToolWindow, siteCache);
		CheckShow();

		VSL_STDMETHOD_HRESULT = VSL_STDMETHOD_HRESULT_INIT;
		try{

		testToolWindow.Show(true);

		}VSL_STDMETHODCATCH()
		UTCHK(VSL_GET_STDMETHOD_HRESULT() == E_UNEXPECTED);
		CheckCreate();
		CheckCreated(testToolWindow, siteCache);
		CheckShow();

		VSL_STDMETHOD_HRESULT = VSL_STDMETHOD_HRESULT_INIT;
		try{

		testToolWindow.Show(false);

		}VSL_STDMETHODCATCH()
		UTCHK(VSL_GET_STDMETHOD_HRESULT() == E_UNEXPECTED);
		CheckCreate();
		CheckCreated(testToolWindow, siteCache);
		CheckShow();

		// Have CreateToolWindow pass so that Create will not throw.
		SetCreateToolWindowValidValues(testToolWindow, &(spIVsWindowFrame.p));

		// Test Create succeeding
		UTCHK(testToolWindow.Create() == true);
		CheckCreate(true, true);
		CheckCreated(testToolWindow, siteCache, true);

		// Test that Create fails now
		VSL_STDMETHOD_HRESULT = VSL_STDMETHOD_HRESULT_INIT;
		try{

		testToolWindow.Create();

		}VSL_STDMETHODCATCH()
		UTCHK(VSL_GET_STDMETHOD_HRESULT() == E_UNEXPECTED);
		CheckCreate();
		CheckCreated(testToolWindow, siteCache, true);
		CheckShow();

		// Test Show no activate succeeding
		testToolWindow.Show(false);
		CheckShowAlreadyCreated(testToolWindow, siteCache, false, true);

		// Test Show activate succeeding
		testToolWindow.Show();
		CheckShowAlreadyCreated(testToolWindow, siteCache, true);

		// Test CreateAndShow no activate succeeding
		testToolWindow.CreateAndShow(false);
		CheckShowAlreadyCreated(testToolWindow, siteCache, false, true);

		// Test CreateAndShow activate succeeding
		testToolWindow.CreateAndShow();
		CheckShowAlreadyCreated(testToolWindow, siteCache, true);

		}

		// Test CreateAndShow
		{
		TestToolWindow testToolWindow(siteCache);
		SetCreateToolWindowValidValues(testToolWindow, &(spIVsWindowFrame.p));
		CheckCreated(testToolWindow, siteCache);
		TestCreateAndShowActivate(testToolWindow);
		CheckCreate(true, true);
		CheckCreated(testToolWindow, siteCache, true);
		TestCreateAndShowNoActivate(testToolWindow);
		CheckCreate();
		CheckCreated(testToolWindow, siteCache, true);
		}

		// Test CreateAndShow again in reverse order
		{
		TestToolWindow testToolWindow(siteCache);
		SetCreateToolWindowValidValues(testToolWindow, &(spIVsWindowFrame.p));
		CheckCreated(testToolWindow, siteCache);
		TestCreateAndShowNoActivate(testToolWindow);
		CheckCreate(true, true);
		CheckCreated(testToolWindow, siteCache, true);
		TestCreateAndShowActivate(testToolWindow);
		CheckCreate();
		CheckCreated(testToolWindow, siteCache, true);
		}

		// Test that the various optional methods are made use of  by Create
		// ViewObject and ViewCLSID are mutually exclusive, test the former here
		{
		typedef TestToolWindow2<TestToolWindow2Controls::ControlViewObject> TestToolWindow2Specialized;
		TestToolWindow2Specialized::GetValidValues().ppWindowFrame = &(spIVsWindowFrame.p);
		IVsUIShellMockImpl::PushValidValues(TestToolWindow2Specialized::GetValidValues());

		TestToolWindow2Specialized testToolWindow(siteCache);
		CheckCreated(testToolWindow, siteCache);
		UTCHK(testToolWindow.Create() == false);
		CheckCreated(testToolWindow, siteCache, true);
		}

		// Test that the various optional methods are made use of  by Create
		// ViewObject and ViewCLSID are mutually exclusive, test the later here
		{
		typedef TestToolWindow2<TestToolWindow2Controls::ControlViewCLSID> TestToolWindow2Specialized;
		TestToolWindow2Specialized::GetValidValues().ppWindowFrame = &(spIVsWindowFrame.p);
		IVsUIShellMockImpl::PushValidValues(TestToolWindow2Specialized::GetValidValues());

		TestToolWindow2Specialized testToolWindow(siteCache);
		CheckCreated(testToolWindow, siteCache);
		UTCHK(testToolWindow.Create() == false);
		CheckCreated(testToolWindow, siteCache, true);
		}

		siteCache.SetSite(NULL);
	}
};

#define FAKE_DIALOG_RESOURCE_STRING 121
class VsWindowPaneFromResourceMockImpl :
	public VsWindowPaneFromResource<VsWindowPaneFromResourceMockImpl, FAKE_DIALOG_RESOURCE_STRING, WindowMock, IVsWindowPaneImpl<VsWindowPaneFromResourceMockImpl> >,
	public UnitTestBase
{

VSL_DEFINE_IUNKNOWN_NOTIMPL

public:

VSL_DEFINE_MOCK_CLASS_TYPDEFS(VsWindowPaneFromResourceMockImpl)

private:

	void IsSited(bool bSited)
	{
		UTCHK((GetVsSiteCache().GetSite() != NULL) == bSited);
	}

	void IsCreated(bool bCreated)
	{
		UTCHK((GetHWND() != NULL) == bCreated);
	}

	void CheckConstantReturnValues()
	{
		UTCHK(GetDefaultSize(NULL) == E_NOTIMPL);
		UTCHK(ClosePane() == S_OK);
		UTCHK(LoadViewState(NULL) == E_NOTIMPL);
		UTCHK(SaveViewState(NULL) == E_NOTIMPL);
	}

	void GetMethodsCalled(int /*iCalledNTimes*/)
	{
//		UTCHK(WASCALLED0(VsWindowPaneFromResource, GetDialogProc, iCalledNTimes));
//		UTCHK(WASCALLED0(VsWindowPaneFromResource, GetDialogInitParam, iCalledNTimes));
	}


	struct PostSitedValidValues
	{
		// In
		IVsPackageEnums::SetSiteResult result;
	};

public:
	void PostSited(IVsPackageEnums::SetSiteResult result)
	{
		VSL_DEFINE_MOCK_METHOD(PostSited);

		VSL_CHECK_VALIDVALUE(result);
	}

	DLGPROC GetDialogProc()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS_NORETURN(GetDialogProc);

		return reinterpret_cast<DLGPROC>(reinterpret_cast<void*>(10101));
	}

	LPARAM GetDialogInitParam()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS_NORETURN(GetDialogInitParam);

		return reinterpret_cast<LPARAM>(reinterpret_cast<void*>(10102));
	}

	VsWindowPaneFromResourceMockImpl(_In_opt_ const char* const szTestName):
		VsWindowPaneFromResource(),
		UnitTestBase(szTestName)
	{
		// Check unsited and uncreated
		IsSited(false);
		CheckConstantReturnValues();
		UTCHK(TranslateAccelerator(NULL) == E_UNEXPECTED);
		UTCHK(GetHWND() == NULL);

		{

		// Improperly site it
		UTCHK(SetSite(NULL) == S_OK);
		IsSited(false);
		UTCHK(WASCALLED(VsWindowPaneFromResource, PostSited, 0));
		CheckConstantReturnValues();
		UTCHK(TranslateAccelerator(NULL) == E_UNEXPECTED);

		// Site it
		PUSHVV1(VsWindowPaneFromResource, PostSited, IVsPackageEnums::Cached);
		UTCHK(SetSite(VsServiceProvider::GetServiceProvider()) == S_OK);
		IsSited(true);
		UTCHK(WASCALLED(VsWindowPaneFromResource, PostSited, 1));
		CheckConstantReturnValues();
		UTCHK(TranslateAccelerator(NULL) == E_UNEXPECTED);

		// Site it again
		PUSHVV1(VsWindowPaneFromResource, PostSited, IVsPackageEnums::AlreadyCached);
		UTCHK(SetSite(VsServiceProvider::GetServiceProvider()) == S_OK);
		IsSited(true);
		UTCHK(WASCALLED(VsWindowPaneFromResource, PostSited, 1));
		CheckConstantReturnValues();
		UTCHK(TranslateAccelerator(NULL) == E_UNEXPECTED);

		}

		{

		// Reset the call counter after the calls to setup the mock above.
		GetMethodsCalled(1);

		SETVV2(VsWindowPaneFromResource, InternalCreate, NULL, ERROR_OUTOFMEMORY);

		CREATEVV(VsWindowPaneFromResource, MoveWindow, moveWindowValidValues)
		{
			5,
			6,
			7,
			8,
			TRUE,
			TRUE,
		};

		SETVV(moveWindowValidValues);

		SETVV1(VsWindowPaneFromResource, ShowWindow, SW_SHOW);

		// Test handling of phwnd being NULL
		UTCHK(CreatePaneWindow(
			reinterpret_cast<HWND>(2),
			moveWindowValidValues.x,
			moveWindowValidValues.y,
			moveWindowValidValues.nWidth,
			moveWindowValidValues.nHeight,
			NULL)
				== E_POINTER);
		IsCreated(false);
		GetMethodsCalled(0);
		IsSited(true);
		CheckConstantReturnValues();
		UTCHK(TranslateAccelerator(NULL) == E_UNEXPECTED);

		// Test CreateDialogParam failing
		HWND hwnd = reinterpret_cast<HWND>(1077);
		UTCHK(CreatePaneWindow(
			reinterpret_cast<HWND>(2),
			moveWindowValidValues.x,
			moveWindowValidValues.y,
			moveWindowValidValues.nWidth,
			moveWindowValidValues.nHeight,
			&hwnd)
				== HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY));
		IsCreated(false);
		UTCHK(hwnd == NULL);
		GetMethodsCalled(1);
		IsSited(true);
		CheckConstantReturnValues();
		UTCHK(TranslateAccelerator(NULL) == E_UNEXPECTED);

		// Create it successfully
		SETVV2(VsWindowPaneFromResource, InternalCreate, (HWND)1, ERROR_SUCCESS);
		UTCHK(CreatePaneWindow(
			reinterpret_cast<HWND>(2),
			moveWindowValidValues.x,
			moveWindowValidValues.y,
			moveWindowValidValues.nWidth,
			moveWindowValidValues.nHeight,
			&hwnd)
				== S_OK);
		IsCreated(true);
		UTCHK(GetHWND() == hwnd);
		GetMethodsCalled(1);
		IsSited(true);
		CheckConstantReturnValues();

		PUSHVV2(IVsUIShell, TranslateAcceleratorAsACmd, NULL, E_NOTIMPL);

		// E_NOTIMPL is returned by IVsUIShell::TranslateAcceleratorAsACmd as we haven't provided 
		// an implementation for it here, that is tested below
		UTCHK(TranslateAccelerator(NULL) == E_NOTIMPL);

		}

		// TODO - test unsited case for TranslateAccelerator and TranslateAcceleratorAsACmd returning S_FALSE
	}
};

// TODO - unit test the selection contain impl class
#if 0
class SingleSelectionContainerTest :
	public UnitTestBase
{
public:
	SingleSelectionContainerTest(const char* const szTestName):
		UnitTestBase(szTestName)
	{
		CComPtr<ISelectionContainer> pISelectionContainer;
		UTCHK((SingleSelectionContainer<&GUID_NULL, VxDTE::SelectedItem>::CreateInstance(&pISelectionContainer) == S_OK));
		UTCHK(pISelectionContainer != NULL);
		if(pISelectionContainer != NULL)
		{

		}
	}
};
#endif


class IVsEditorFactoryImplTest :
	public UnitTestBase,
	public IVsEditorFactoryImpl<IVsEditorFactoryImplTest>
{
public:

VSL_DEFINE_IUNKNOWN_NOTIMPL

#pragma warning(push)
#pragma warning(disable : 4480) // // warning C4480: nonstandard extension used: specifying underlying type for enum
	enum PhysicalViewId : unsigned int
	{
		Unsupported,
		Primary
	};
#pragma warning(pop)

	PhysicalViewId GetPhysicalViewId(LPCOLESTR szPhysicalView)
	{
		// pszPhysicalView being NULL indicates the primary physical view
		if(szPhysicalView == NULL)
		{
			return Primary;
		}

		return Unsupported;
	}

	PhysicalViewId GetPhysicalViewId(REFGUID rguidLogicalView)
	{
		if(rguidLogicalView == LOGVIEWID_Primary)
		{
			return Primary;
		}

		return Unsupported;
	}

	BSTR GetPhysicalViewBSTR(PhysicalViewId physicalViewId)
	{
		UTCHK(physicalViewId == Primary);
		return NULL;
	}

	bool CanShareBuffer(PhysicalViewId /*physicalViewId*/)
	{
		return true;
	}

	IUnknown* GetDataObject()
	{
		return static_cast<IUnknown*>(this);
	}

	IUnknown* GetViewObject()
	{
		return static_cast<IUnknown*>(this);
	}

	wchar_t* GetCaption()
	{
		return L"Test Catpion";
	}

	const GUID* GetGUID()
	{
		return &__uuidof(IUnknown);
	}

	VSEDITORCREATEDOCWIN GetUI()
	{
		return ECDW_UserCanceled;
	}

	typedef const GUID* PGUID;

	void CreateDataAndViewObjects(
		PhysicalViewId physicalViewId, 
		CComPtr<IUnknown>& rspDataObject, 
		CComPtr<IUnknown>& rspViewObject, 
		CComBSTR& rbstrEditorCaption, 
		PGUID& rpguidCommandUI, 
		VSEDITORCREATEDOCWIN& rCreateDocumentWindowUI)
	{
		UTCHK(physicalViewId == Primary);
		rspDataObject = GetDataObject();
		rspViewObject = GetViewObject();
		rbstrEditorCaption = GetCaption();
		rpguidCommandUI = GetGUID();
		rCreateDocumentWindowUI = GetUI();
	}

	IVsEditorFactoryImplTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
		UTCHK(E_INVALIDARG == CreateEditorInstance(
			0,
			NULL,
			NULL,
			NULL,
			0,
			NULL,
			NULL,
			NULL,
			NULL,
			NULL,
			NULL));

		UTCHK(E_INVALIDARG == CreateEditorInstance(
			CEF_OPENFILE,
			NULL,
			NULL,
			NULL,
			0,
			NULL,
			NULL,
			NULL,
			NULL,
			NULL,
			NULL));

		IUnknown* punkDocView;
		IUnknown* punkDocData;
		BSTR bstrEditorCaption;
		GUID guidCmdUI;
		VSEDITORCREATEDOCWIN grfCDW;

		UTCHK(E_INVALIDARG == CreateEditorInstance(
			CEF_OPENFILE,
			NULL,
			NULL,
			NULL,
			0,
			NULL,
			&punkDocView,
			NULL,
			NULL,
			NULL,
			NULL));

		UTCHK(E_INVALIDARG == CreateEditorInstance(
			CEF_OPENFILE,
			NULL,
			NULL,
			NULL,
			0,
			NULL,
			&punkDocView,
			&punkDocData,
			NULL,
			NULL,
			NULL));

		UTCHK(E_INVALIDARG == CreateEditorInstance(
			CEF_OPENFILE,
			NULL,
			NULL,
			NULL,
			0,
			NULL,
			&punkDocView,
			&punkDocData,
			&bstrEditorCaption,
			NULL,
			NULL));

		UTCHK(E_INVALIDARG == CreateEditorInstance(
			CEF_OPENFILE,
			NULL,
			NULL,
			NULL,
			0,
			NULL,
			&punkDocView,
			&punkDocData,
			&bstrEditorCaption,
			&guidCmdUI,
			NULL));

		// NOTE - returning VS_E_INCOMPATIBLEDOCDATA when punkDocDataExisting is not NULL
		// is tested by the sample unit test for SingleViewEditorFactory
		UTCHK(S_OK == CreateEditorInstance(
			CEF_OPENFILE,
			NULL,
			NULL,
			NULL,
			0,
			GetDataObject(), // simulate punkDocDataExisting not being NULL, value doesn't matter
			&punkDocView,
			&punkDocData,
			&bstrEditorCaption,
			&guidCmdUI,
			&grfCDW));

		UTCHK(punkDocView == GetDataObject());
		UTCHK(punkDocData == GetViewObject());
		UTCHK(CComBSTR(bstrEditorCaption) == CComBSTR(GetCaption()));
		UTCHK(guidCmdUI == *(GetGUID()));
		UTCHK(grfCDW == GetUI());

		UTCHK(S_OK == CreateEditorInstance(
			CEF_OPENFILE,
			NULL,
			NULL,
			NULL,
			0,
			NULL,
			&punkDocView,
			&punkDocData,
			&bstrEditorCaption,
			&guidCmdUI,
			&grfCDW));

		UTCHK(punkDocView == GetDataObject());
		UTCHK(punkDocData == GetViewObject());
		UTCHK(CComBSTR(bstrEditorCaption) == CComBSTR(GetCaption()));
		UTCHK(guidCmdUI == *(GetGUID()));
		UTCHK(grfCDW == GetUI());

		// NOTE - we test grfCDW being NULLed with the sample unit test for SingleViewEditorFactory

		// NOTE - we test the case of Derived_T providing CreateSingelViewObject rather then
		// CreateDataAndViewObjects with the sample unit test for SingleViewEditorFactory

		// NOTE - we skip SetSite as this is provided by IVsEditorFactoryImpl  inheriting from 
		// VsSiteBaseImpl

		// Check bad args are handled correctly
		UTCHK(E_INVALIDARG == MapLogicalView(LOGVIEWID_Designer, NULL));

		BSTR bstrPhysicalView;
		UTCHK(E_NOTIMPL == MapLogicalView(LOGVIEWID_Designer, &bstrPhysicalView));
		UTCHK(S_OK == MapLogicalView(LOGVIEWID_Primary, &bstrPhysicalView));
		UTCHK(bstrPhysicalView == NULL);

		// NOTE - we test the case of Derived_T not providing GetPhysicalViewBSTR
		// with the sample unit test for SingleViewEditorFactory

		// Check calling work methods after Close fails correctly
		Close();
		UTCHK(E_UNEXPECTED == MapLogicalView(LOGVIEWID_Designer, &bstrPhysicalView));
		UTCHK(E_UNEXPECTED == CreateEditorInstance(
			CEF_OPENFILE,
			NULL,
			NULL,
			NULL,
			0,
			NULL,
			&punkDocView,
			&punkDocData,
			&bstrEditorCaption,
			&guidCmdUI,
			&grfCDW));
	}
};

#include "VSLFindAndReplace.h"

class IVsFindTargetImplTest :
	public UnitTestBase,
	public IVsFindTargetImpl<IVsFindTargetImplTest>
{
public:

VSL_DEFINE_IUNKNOWN_NOTIMPL

	IVsFindTargetImplTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
		UTCHK(E_INVALIDARG == IVsFindTargetImpl::GetFindState(NULL));

		CComPtr<IUnknown> spIUnknown;
		UTCHK(S_OK == IVsFindTargetImpl::GetFindState(&spIUnknown));
		// Should start out NULL
		UTCHK(!spIUnknown);

		UTCHK(S_OK == IVsFindTargetImpl::SetFindState(NULL));

		UTCHK(S_OK == IVsFindTargetImpl::GetFindState(&spIUnknown));
		// Should still be NULL
		UTCHK(!spIUnknown);

		// It doesn't matter what type this, just that it get's AddRef'ed, Released, and returned properly
		IVsWindowFrameMock mock;
		CComPtr<IUnknown> spMock = mock.GetIUnknownNoAddRef();

		UTCHK(S_OK == IVsFindTargetImpl::SetFindState(spMock));
		UTCHK(S_OK == IVsFindTargetImpl::GetFindState(&spIUnknown));
		// Now should be equal to the mock
		UTCHK(spIUnknown == spMock);

		spIUnknown.Release();

		UTCHK(S_OK == IVsFindTargetImpl::SetFindState(NULL));
		UTCHK(S_OK == IVsFindTargetImpl::GetFindState(&spIUnknown));
		// Should be NULL again
		UTCHK(!spIUnknown);
	}

	STDMETHOD(GetProperty)( 
		/* [in] */ VSFTPROPID ,
		/* [out]*/ VARIANT *)VSL_STDMETHOD_NOTIMPL
	STDMETHOD(Find)(    
		/* [in] */ LPCOLESTR ,
		/* [in] */ VSFINDOPTIONS ,
		/* [in] */ BOOL ,
		/* [in] */ IVsFindHelper * ,
		/* [out]*/ VSFINDRESULT * )VSL_STDMETHOD_NOTIMPL
	STDMETHOD(Replace)(  
		/* [in] */ LPCOLESTR ,
		/* [in] */ LPCOLESTR ,
		/* [in] */ VSFINDOPTIONS ,
		/* [in] */ BOOL ,
		/* [in] */ IVsFindHelper * ,
		/* [out]*/ BOOL * )VSL_STDMETHOD_NOTIMPL
	STDMETHOD(GetMatchRect)(
		/* [out]*/ PRECT )VSL_STDMETHOD_NOTIMPL
	STDMETHOD(NavigateTo)(
		/* [in] */ const TextSpan * )VSL_STDMETHOD_NOTIMPL
	STDMETHOD(GetCurrentSpan)(
		/* [out]*/ TextSpan * )VSL_STDMETHOD_NOTIMPL
	STDMETHOD(NotifyFindTarget)(
		/* [in] */ VSFTNOTIFY )VSL_STDMETHOD_NOTIMPL
	STDMETHOD(MarkSpan)( 
		/* [in] */ const TextSpan __RPC_FAR *)VSL_STDMETHOD_NOTIMPL

	IUnknown* _GetRawUnknown() throw()
	{
		return NULL;
	}

	DWORD GetCapabilityOptions()
	{
		return 0;
	}
};

class VSLMessageMapTest :
	public UnitTestBase
{
public:

VSL_BEGIN_MSG_MAP(VSLMessageMapTest)
	throw CAtlException(E_UNEXPECTED);
VSL_END_MSG_MAP()

	VSLMessageMapTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
		LRESULT lResult = 0;
		UTCHK(FALSE == ProcessWindowMessage(NULL, 0, 0, 0, lResult));
	}
};

// TODO - 1/27/2006 - make a File unit test for the following
#include "VSLFile.h"

typedef InterfaceImplList<IVsQueryEditQuerySave2MockImpl, IUnknownInterfaceListTerminatorDefault> IVsQueryEditQuerySave2MockImplList;
VSL_DEFINE_SERVICE_MOCK_EX(IVsQueryEditQuerySave2ServiceMock, IVsQueryEditQuerySave2MockImplList, SID_SVsQueryEditQuerySave);
typedef InterfaceImplList<IVsFileChangeExMockImpl, IUnknownInterfaceListTerminatorDefault> IVsFileChangeExMockImplList;
VSL_DEFINE_SERVICE_MOCK_EX(IVsFileChangeExServiceMock, IVsFileChangeExMockImplList, SID_SVsFileChangeEx);
typedef InterfaceImplList<IVsRunningDocumentTableMockImpl, IUnknownInterfaceListTerminatorDefault> IVsRunningDocumentTableMockImplList;
VSL_DEFINE_SERVICE_MOCK_EX(IVsRunningDocumentTableMock, IVsRunningDocumentTableMockImplList, SID_SVsRunningDocumentTable);

typedef ServiceList<IVsRunningDocumentTableMock, ServiceList<IVsFileChangeExServiceMock, ServiceList<IVsQueryEditQuerySave2ServiceMock, ServiceList<IVsShellServiceMock, ServiceList<IVsUIShellServiceMock, ServiceListTerminator> > > > > IVsQueryEditQuerySave2ProviderServiceList;
typedef InterfaceImplList<VSL::IServiceProviderImpl<IVsQueryEditQuerySave2ProviderServiceList>, IUnknownInterfaceListTerminator<IServiceProvider> > IVsQueryEditQuerySave2ProviderMockInterfaceList;

VSL_DECLARE_COM_MOCK(IVsQueryEditQuerySave2ProviderMock, IVsQueryEditQuerySave2ProviderMockInterfaceList){};

class DocumentPersistanceBaseTest :
	public UnitTestBase,
	public MockBase,
	public DocumentPersistanceBase<DocumentPersistanceBaseTest, FileMock>
{
public:

	typedef VsSiteCacheLocal VsSiteCache;

	const VsSiteCache& GetVsSiteCache() const
	{
		return m_VsSiteCache;
	}

	// Makes the convinience macros happy
	typedef DocumentPersistanceBaseTest DocumentPersistanceBaseTestMockImpl;

	VSL_DEFINE_MOCK_CLASS_TYPDEFS(DocumentPersistanceBaseTest);
	
	VSL_DEFINE_IUNKNOWN_NOTIMPL

	void OnFileChangedSetTimer()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS_NORETURN(OnFileChangedSetTimer);
	}

	struct PostSetReadOnlyValidValues
	{
		bool bIsFileReadOnly;
	};

	void PostSetReadOnly()
	{
		VSL_DEFINE_MOCK_METHOD_NOARGS_NORETURN(PostSetReadOnly);
	}

	bool IsValidFormat(DWORD dwFormatIndex)
	{
		return DEF_FORMAT_INDEX == dwFormatIndex;
	}

	const GUID& GetEditorTypeGuid() const
	{
		// {442EAB59-08D8-4a68-B16C-B741760D4750}
		static const GUID guid = { 0x442eab59, 0x8d8, 0x4a68, { 0xb1, 0x6c, 0xb7, 0x41, 0x76, 0xd, 0x47, 0x50 } };
		return guid;
	}

	void GetFormatListString(ATL::CStringW& rstrFormatList)
	{
		VSL_NOTE_METHOD_WAS_CALLED(GetFormatListString);
		rstrFormatList = m_strFormatList;
	}

    HRESULT ReadData(HANDLE hFile, BOOL fInsert, DWORD& rdwFormatIndex)
	{
		// TODO - improve this further after it's refactored
		VSL_NOTE_METHOD_WAS_CALLED(ReadData);
		(hFile, fInsert);
		rdwFormatIndex = DEF_FORMAT_INDEX;
		return S_OK;
	}

    HRESULT WriteData(HANDLE hFile, DWORD dwFormatIndex = DEF_FORMAT_INDEX)
	{
		VSL_NOTE_METHOD_WAS_CALLED(WriteData);
		(hFile, dwFormatIndex);
		// TODO - 1/30/2006 - improve this further after it's refactored
		return S_OK;
	}


	void PostSetDirty()
	{
		// TODO - 1/30/2006 - better mock for this
	}

	void TestServiceDependentMethods()
	{
		IVsQueryEditQuerySave2ProviderMock serviceProviderMock;
		m_VsSiteCache.SetSite(&serviceProviderMock);

		ResetFileState();
		SetFileName(NULL);

		// IPersistFileFormat::Load
		SETVV1(IVsUIShell, SetWaitCursor, S_OK);
		SETVV1(File, IsFileReadOnly, false);

		UTCHK(E_INVALIDARG == Load(NULL, 0, FALSE));
		UTCHK(WASCALLED0(IVsUIShell, SetWaitCursor, 0));
		UTCHK(WASCALLED(DocumentPersistanceBaseTest, ReadData, 0));

		PUSHVV1(File, GetFileType, FILE_TYPE_PIPE);

		UTCHK(HRESULT_FROM_WIN32(ERROR_INVALID_NAME) == Load(m_strFileName, 0, FALSE));
		UTCHK(WASCALLED0(IVsUIShell, SetWaitCursor, 1));
		UTCHK(WASCALLED(DocumentPersistanceBaseTest, ReadData, 0));

		PUSHVV1(File, GetFileType, FILE_TYPE_DISK);
		PUSHVV1(File, IsZeroLength, true);

		VSCOOKIE cookie = 57;
		CREATEVV(IVsFileChangeEx, AdviseFileChange, valuesAdviseFileChange)
		{
			m_strFileName,
			VSFILECHG_Attr | VSFILECHG_Time | VSFILECHG_Size,
			static_cast<IVsFileChangeEvents*>(this),
			&cookie,
			S_OK
		};
		PUSHVV(valuesAdviseFileChange);

		VSDOCCOOKIE docCookie = 77;
		STARTVV(IVsRunningDocumentTable, FindAndLockDocument)
			RDT_ReadLock,
			m_strFileName,
			NULL,
			NULL,
			0,
			&docCookie,
			S_OK
		ENDVVPUSH()

		PUSHVV3(IVsRunningDocumentTable, NotifyDocumentChanged, docCookie, RDTA_DocDataReloaded, S_OK);
		PUSHVV3(IVsRunningDocumentTable, UnlockDocument, RDT_ReadLock, docCookie, S_OK);

		UTCHK(S_OK == Load(m_strFileName, 0, FALSE));
		UTCHK(WASCALLED(DocumentPersistanceBaseTest, ReadData, 0));
		UTCHK(WASCALLED(IVsFileChangeEx, AdviseFileChange, 1));
		// TODO - verify state

		PUSHVV1(File, GetFileType, FILE_TYPE_DISK);
		PUSHVV1(File, IsZeroLength, false);

		UTCHK(S_OK == Load(m_strFileName, 0, FALSE));
		UTCHK(WASCALLED(DocumentPersistanceBaseTest, ReadData, 1));
		// TODO - verify state

		// IVsPersistDocData::LoadDocData
		UTCHK(E_INVALIDARG == LoadDocData(NULL));
		UTCHK(WASCALLED(IVsUIShell, SetWaitCursor, 0));
		UTCHK(WASCALLED(DocumentPersistanceBaseTest, ReadData, 0));

		PUSHVV1(File, GetFileType, FILE_TYPE_DISK);
		PUSHVV1(File, IsZeroLength, true);

		UTCHK(S_OK == LoadDocData(m_strFileName));
		UTCHK(WASCALLED(DocumentPersistanceBaseTest, ReadData, 0));
		// TODO - verify state

		PUSHVV1(File, GetFileType, FILE_TYPE_DISK);
		PUSHVV1(File, IsZeroLength, false);

		UTCHK(S_OK == LoadDocData(m_strFileName));
		UTCHK(WASCALLED(DocumentPersistanceBaseTest, ReadData, 1));
		// TODO - verify state

		// IPersistFileFormat::Save
		PUSHVV2(IVsFileChangeEx, UnadviseFileChange, cookie, S_OK); 
		SetFileName(NULL);
		UTCHK(E_INVALIDARG == Save(NULL, FALSE, DEF_FORMAT_INDEX+1));

		// NULL is valid for the first parameter, if the filename has been set already
		// but it has not, so NULL isn't valid
		UTCHK(E_INVALIDARG == Save(NULL, FALSE, DEF_FORMAT_INDEX));
		UTCHK(WASCALLED(DocumentPersistanceBaseTest, WriteData, 0));

		CREATEVV(IVsFileChangeEx, IgnoreFile, valuesIgnoreFile)
		{
			NULL,
			m_strFileName,
			TRUE,
			S_OK
		};
		PUSHVV(valuesIgnoreFile);

		PUSHVV2(IVsFileChangeEx, SyncFile, m_strFileName, S_OK);
		valuesIgnoreFile.fIgnore = FALSE;
		PUSHVV(valuesIgnoreFile);

		// Test the "Save" case, so set filename first
		GetFile().GetFullPathName() = m_strFileName;
		UTCHK(S_OK == Save(NULL, FALSE, DEF_FORMAT_INDEX));
		UTCHK(WASCALLED(DocumentPersistanceBaseTest, WriteData, 1));
		UTCHK(WASCALLED(IVsFileChangeEx, IgnoreFile, 2));

		valuesIgnoreFile.fIgnore = TRUE;
		PUSHVV(valuesIgnoreFile);
		PUSHVV2(IVsFileChangeEx, SyncFile, m_strFileName, S_OK);
		valuesIgnoreFile.fIgnore = FALSE;
		PUSHVV(valuesIgnoreFile);

		// Test the "Save" case, that looks like a "Save As", but has the same filename, so set filename first
		UTCHK(S_OK == Save(m_strFileName, TRUE, DEF_FORMAT_INDEX));
		UTCHK(WASCALLED(DocumentPersistanceBaseTest, WriteData, 1));
		UTCHK(WASCALLED(IVsFileChangeEx, IgnoreFile, 2));

		LPCOLESTR szFileName = L"NotTheSameFileName";

		// Test the "Save Copy As" case
		UTCHK(S_OK == Save(szFileName, FALSE, DEF_FORMAT_INDEX));
		UTCHK(WASCALLED(DocumentPersistanceBaseTest, WriteData, 1));

		cookie = 57;
		valuesAdviseFileChange.pszMkDocument = szFileName;
		PUSHVV(valuesAdviseFileChange);

		// Test the "Save As" case
		UTCHK(S_OK == Save(szFileName, TRUE, DEF_FORMAT_INDEX));
		UTCHK(WASCALLED(DocumentPersistanceBaseTest, WriteData, 1));
		UTCHK(WASCALLED(IVsFileChangeEx, AdviseFileChange, 1));

		// IVsPersistDocData::SaveDocData
		PUSHVV2(IVsFileChangeEx, UnadviseFileChange, cookie, S_OK); 
		SetFileName(NULL);

		UTCHK(E_INVALIDARG == SaveDocData(static_cast<VSSAVEFLAGS>(-1), NULL, NULL));

		BSTR bstrMkDocumentNew = reinterpret_cast<LPOLESTR>(-1);
		BOOL bSaveCanceled = 55;
		UTCHK(E_INVALIDARG == SaveDocData(static_cast<VSSAVEFLAGS>(-1), &bstrMkDocumentNew, NULL));
		UTCHK(E_UNEXPECTED == SaveDocData(static_cast<VSSAVEFLAGS>(-1), &bstrMkDocumentNew, &bSaveCanceled));
		GetFile().GetFullPathName() = m_strFileName;
		UTCHK(E_INVALIDARG == SaveDocData(static_cast<VSSAVEFLAGS>(-1), &bstrMkDocumentNew, &bSaveCanceled));

		VSQuerySaveResult result = QSR_NoSave_UserCanceled;
		STARTVV(IVsQueryEditQuerySave2, QuerySaveFile)
			m_strFileName,
			0,
			NULL,
			&result
		ENDVVSET();

		UTCHK(S_OK == SaveDocData(VSSAVE_Save, &bstrMkDocumentNew, &bSaveCanceled));
		UTCHK(TRUE == bSaveCanceled);
		UTCHK(WASCALLED(IVsUIShell, SaveDocDataToFile, 0));

		bSaveCanceled = 55;
		result = QSR_NoSave_Continue;

		UTCHK(S_OK == SaveDocData(VSSAVE_Save, &bstrMkDocumentNew, &bSaveCanceled));
		UTCHK(FALSE == bSaveCanceled);
		UTCHK(WASCALLED(IVsUIShell, SaveDocDataToFile, 0));

		bSaveCanceled = 55;
		result = QSR_ForceSaveAs;

		CComBSTR bstrDocumentNew = m_strFileName;
		BOOL fCanceled = FALSE;
		CREATEVV(IVsUIShell, SaveDocDataToFile, valuesSaveDocDataToFile)
		{
			VSSAVE_SaveAs,
			static_cast<IPersistFileFormat*>(this),
			m_strFileName,
			&bstrDocumentNew,
			&fCanceled,
			S_OK
		};
		PUSHVV(valuesSaveDocDataToFile);

		UTCHK(S_OK == SaveDocData(VSSAVE_Save, &bstrMkDocumentNew, &bSaveCanceled));
		UTCHK(FALSE == bSaveCanceled);
		UTCHK(WASCALLED(IVsUIShell, SaveDocDataToFile, 1));

		bSaveCanceled = 55;
		result = QSR_SaveOK;
		valuesSaveDocDataToFile.grfSave = VSSAVE_Save;
		PUSHVV(valuesSaveDocDataToFile);

		UTCHK(S_OK == SaveDocData(VSSAVE_Save, &bstrMkDocumentNew, &bSaveCanceled));
		UTCHK(FALSE == bSaveCanceled);
		UTCHK(WASCALLED(IVsUIShell, SaveDocDataToFile, 1));

		bSaveCanceled = 55;
		valuesSaveDocDataToFile.grfSave = VSSAVE_SaveAs;
		PUSHVV(valuesSaveDocDataToFile);

		UTCHK(S_OK == SaveDocData(VSSAVE_SaveAs, &bstrMkDocumentNew, &bSaveCanceled));
		UTCHK(FALSE == bSaveCanceled);
		UTCHK(WASCALLED(IVsUIShell, SaveDocDataToFile, 1));

		bSaveCanceled = 55;
		valuesSaveDocDataToFile.grfSave = VSSAVE_SaveCopyAs;
		PUSHVV(valuesSaveDocDataToFile);

		UTCHK(S_OK == SaveDocData(VSSAVE_SaveCopyAs, &bstrMkDocumentNew, &bSaveCanceled));
		UTCHK(FALSE == bSaveCanceled);
		UTCHK(WASCALLED(IVsUIShell, SaveDocDataToFile, 1));

		// IVsPersistDocData::ReloadDocData
		UTCHK(E_INVALIDARG == ReloadDocData(RDD_IgnoreNextFileChange));

		PUSHVV1(File, GetFileType, FILE_TYPE_DISK);
		PUSHVV1(File, IsZeroLength, true);

		UTCHK(S_OK == ReloadDocData(0));
		UTCHK(WASCALLED(DocumentPersistanceBaseTest, ReadData, 0));

		// IVsFileBackup methods
		ResetFileState();
		UTCHK(E_INVALIDARG == IsBackupFileObsolete(NULL));
		BOOL bObsolete = 55;
		UTCHK(S_OK == IsBackupFileObsolete(&bObsolete));
		// Since the state is clear, it isn't dirty, so no need for a backup
		UTCHK(FALSE == bObsolete);

		SetFileDirty(true);

		bObsolete = 55;
		UTCHK(S_OK == IsBackupFileObsolete(&bObsolete));
		// Now the state is dirty, so there need for a backup
		UTCHK(TRUE == bObsolete);

		UTCHK(E_INVALIDARG == BackupFile(NULL));
		UTCHK(WASCALLED(DocumentPersistanceBaseTest, WriteData, 0));
		UTCHK(S_OK == BackupFile(L"\\Test\\Backup\\z7891.rtf"));
		UTCHK(WASCALLED(DocumentPersistanceBaseTest, WriteData, 1));

		bObsolete = 55;
		UTCHK(S_OK == IsBackupFileObsolete(&bObsolete));
		// Since a backup has been made, and no state changes have occured since,
		// there is now no need for a backup.
		UTCHK(FALSE == bObsolete);

		SetFileDirty(true);

		bObsolete = 55;
		UTCHK(S_OK == IsBackupFileObsolete(&bObsolete));
		// Now the state is dirty, so there need for a backup
		UTCHK(TRUE == bObsolete);

		// Do a normal Save
		valuesIgnoreFile.fIgnore = TRUE;
		PUSHVV(valuesIgnoreFile);
		PUSHVV2(IVsFileChangeEx, SyncFile, m_strFileName, S_OK);
		valuesIgnoreFile.fIgnore = FALSE;
		PUSHVV(valuesIgnoreFile);
		GetFile().GetFullPathName() = m_strFileName;
		UTCHK(S_OK == Save(NULL, FALSE, DEF_FORMAT_INDEX));
		UTCHK(WASCALLED(DocumentPersistanceBaseTest, WriteData, 1));
		UTCHK(WASCALLED(IVsFileChangeEx, IgnoreFile, 2));

		bObsolete = 55;
		UTCHK(S_OK == IsBackupFileObsolete(&bObsolete));
		// Since a Save has occured, and no state changes have occured since,
		// there is now no need for a backup.
		UTCHK(FALSE == bObsolete);

		// Clean up
		PUSHVV2(IVsFileChangeEx, UnadviseFileChange, cookie, S_OK); 
		OnDocumentClose();

		m_VsSiteCache.SetSite(NULL);
	}

	void TestIVsPersistDocData()
	{
		// Test IPersist
		{
		UTCHK(E_INVALIDARG == GetClassID(NULL));
		CLSID clsid = GUID_NULL;
		UTCHK(S_OK == GetClassID(&clsid));
		UTCHK(GetEditorTypeGuid() == clsid);
		}

		// Test IVsPersistDocData
		{
		UTCHK(E_INVALIDARG == GetGuidEditorType(NULL));
		CLSID clsid = GUID_NULL;
		UTCHK(S_OK == GetGuidEditorType(&clsid));
		UTCHK(GetEditorTypeGuid() == clsid);
		}

		{
		UTCHK(E_INVALIDARG == IsDocDataDirty(NULL));

		// Set the state is dirty
		ResetFileState();
		SetFileDirty(true);
		BOOL bDirty = FALSE;
		UTCHK(S_OK == IsDocDataDirty(&bDirty));
		// Make sure we got dirty
		UTCHK(TRUE == bDirty);

		// Reset the state, to clear dirty
		ResetFileState();
		UTCHK(S_OK == IsDocDataDirty(&bDirty));
		// Make sure we are not dirty now
		UTCHK(FALSE == bDirty);
		}

		{
		// Parameter is ignored 
		ResetFileState();
		UTCHK(S_OK == SetUntitledDocPath(NULL));
		ResetFileState();
		UTCHK(S_OK == SetUntitledDocPath(L""));
		ResetFileState();
		UTCHK(S_OK == SetUntitledDocPath(L"\\Directory\\Directory"));
		}

		// LoadDocData and SaveDocData are tested in TestServiceDependentMethods

		// These just returns S_OK in all cases
		UTCHK(S_OK == Close());
		UTCHK(S_OK == OnRegisterDocData(0, NULL, 0));
		UTCHK(S_OK == OnRegisterDocData(55, reinterpret_cast<IVsHierarchy*>(NULL+1), 56));
		UTCHK(S_OK == RenameDocData(0, NULL, 0, NULL));
		UTCHK(S_OK == RenameDocData(55, reinterpret_cast<IVsHierarchy*>(NULL+1), 56, L""));
		UTCHK(S_OK == RenameDocData(55, reinterpret_cast<IVsHierarchy*>(NULL+1), 56, L"\\Test\\Test.rtf"));

		{
		UTCHK(E_INVALIDARG == IsDocDataReloadable(NULL));
		BOOL bReloadable;
		UTCHK(S_OK == IsDocDataReloadable(&bReloadable));
		// Always indicates it's reloadable
		UTCHK(TRUE == bReloadable);
		}

		// ReloadDocData is tested in TestServiceDependentMethods
	}

	void TestIPersistFileFormat()
	{
		{
		UTCHK(E_INVALIDARG == IsDirty(NULL));

		// Set the state is dirty
		ResetFileState();
		SetFileDirty(true);
		BOOL bDirty = FALSE;
		UTCHK(S_OK == IsDirty(&bDirty));
		// Make sure we got dirty
		UTCHK(TRUE == bDirty);

		// Reset the state, to clear dirty
		ResetFileState();
		UTCHK(S_OK == IsDirty(&bDirty));
		// Make sure we are not dirty now
		UTCHK(FALSE == bDirty);
		}

		{
		ResetFileState();
		UTCHK(E_INVALIDARG == InitNew(1));
		ResetFileState();
		UTCHK(S_OK == InitNew(DEF_FORMAT_INDEX));
		}

		// Load and Save are tested in TestServiceDependentMethods

		// This just returns S_OK in all cases
		UTCHK(S_OK == SaveCompleted(NULL));
		UTCHK(S_OK == SaveCompleted(L""));
		UTCHK(S_OK == SaveCompleted(L"\\Directory\\Directory"));

		// Clear the file name
		SetFileName(NULL);
		UTCHK(E_INVALIDARG == GetCurFile(NULL, NULL));

		LPOLESTR szFilename = reinterpret_cast<LPOLESTR>(-1);
		DWORD dwFormatIndex = 0xFFFFFFFF;
		UTCHK(E_INVALIDARG == GetCurFile(&szFilename, NULL));

		UTCHK(S_OK == GetCurFile(&szFilename, &dwFormatIndex));
		// szFilename should be NULL, since the filename has been cleared
		UTCHK(NULL == szFilename);
		// Can only be DEF_FORMAT_INDEX for this test
		UTCHK(DEF_FORMAT_INDEX == dwFormatIndex);

		GetFile().GetFullPathName() = m_strFileName;

		UTCHK(S_OK == GetCurFile(&szFilename, &dwFormatIndex));
		// Okay, now the file has been set, so szFilename should match it now
		UTCHK(szFilename != NULL);
		if(szFilename)
		{
			UTCHK(0 == m_strFileName.Compare(szFilename));
		}
		UTCHK(DEF_FORMAT_INDEX == dwFormatIndex);
		::CoTaskMemFree(szFilename);

		UTCHK(E_INVALIDARG == GetFormatList(NULL));
		UTCHK(WASCALLED(DocumentPersistanceBaseTest, GetFormatListString, 0));

		LPOLESTR szFormatList = reinterpret_cast<LPOLESTR>(-1);
		UTCHK(S_OK == GetFormatList(&szFormatList));
		UTCHK(WASCALLED(DocumentPersistanceBaseTest, GetFormatListString, 1));
		UTCHK(0 == m_strFormatList.Compare(szFormatList));
		::CoTaskMemFree(szFormatList);
	}

	void TestFileChangeRelated()
	{
		// Test IVsFileChangeEvents and IVsDocDataFileChangeControl methods
		const DWORD iFileChanges = 2;
		LPCOLESTR changedFileNames[iFileChanges] =
		{
			L"\\Directory\\NotMyFile.rtf",
			m_strFileName,
		};
		VSFILECHANGEFLAGS changeFlags[iFileChanges] =
		{
			VSFILECHG_Time | VSFILECHG_Size,
			VSFILECHG_Attr | VSFILECHG_Time | VSFILECHG_Size,
		};
		UTCHK(E_INVALIDARG == FilesChanged(0, NULL, NULL));
		UTCHK(E_INVALIDARG == FilesChanged(iFileChanges, NULL, NULL));
		UTCHK(E_INVALIDARG == FilesChanged(iFileChanges, changedFileNames, NULL));

		// Clear call count
		WASCALLED(DocumentPersistanceBaseTest, PostSetReadOnly, 0);
		UTCHK(WASCALLED0(DocumentPersistanceBaseTest, OnFileChangedSetTimer, 0));

		UTCHK(S_OK == FilesChanged(iFileChanges, changedFileNames, changeFlags));
		// Since the filename hasn't been set yet, these should not be called
		UTCHK(WASCALLED(DocumentPersistanceBaseTest, PostSetReadOnly, 0));
		UTCHK(WASCALLED0(DocumentPersistanceBaseTest, OnFileChangedSetTimer, 0));

		// Now set the filename
		GetFile().GetFullPathName() = m_strFileName;

		// Test the read-only case
		SETVV1(File, IsFileReadOnly, true);
		SETVV1(DocumentPersistanceBaseTest, PostSetReadOnly, true);

		UTCHK(S_OK == FilesChanged(iFileChanges, changedFileNames, changeFlags));
		// Now both of these should be called
		UTCHK(WASCALLED0(DocumentPersistanceBaseTest, PostSetReadOnly, 1));
		UTCHK(WASCALLED0(DocumentPersistanceBaseTest, OnFileChangedSetTimer, 1));

		// Now reverse the read-only case
		SETVV1(File, IsFileReadOnly, false);
		SETVV1(DocumentPersistanceBaseTest, PostSetReadOnly, false);

		UTCHK(S_OK == FilesChanged(iFileChanges, changedFileNames, changeFlags));
		UTCHK(WASCALLED0(DocumentPersistanceBaseTest, PostSetReadOnly, 1));
		// Now this shouldn't be called since NotifyFileChangedTimerHandled hasn't been called yet.
		UTCHK(WASCALLED0(DocumentPersistanceBaseTest, OnFileChangedSetTimer, 0));

		// Now remove the attribute change
		changeFlags[1] = VSFILECHG_Time | VSFILECHG_Size;

		UTCHK(S_OK == FilesChanged(iFileChanges, changedFileNames, changeFlags));
		// Now both shouldn't be called
		UTCHK(WASCALLED0(DocumentPersistanceBaseTest, PostSetReadOnly, 0));
		UTCHK(WASCALLED0(DocumentPersistanceBaseTest, OnFileChangedSetTimer, 0));

		NotifyFileChangedTimerHandled();

		UTCHK(S_OK == FilesChanged(iFileChanges, changedFileNames, changeFlags));
		UTCHK(WASCALLED0(DocumentPersistanceBaseTest, PostSetReadOnly, 0));
		// Now this should be called since NotifyFileChangedTimerHandled was called
		UTCHK(WASCALLED0(DocumentPersistanceBaseTest, OnFileChangedSetTimer, 1));

		// Enable these to be called again
		changeFlags[1] = VSFILECHG_Attr | VSFILECHG_Time | VSFILECHG_Size;
		NotifyFileChangedTimerHandled();

		UTCHK(S_OK == IgnoreFileChanges(TRUE));
		UTCHK(S_OK == FilesChanged(iFileChanges, changedFileNames, changeFlags));
		// but they shouldn't be called since IgnoreFileChanges has been called with TRUE and 
		// not balanced with an equal number of calls with FALSE
		UTCHK(WASCALLED0(DocumentPersistanceBaseTest, PostSetReadOnly, 0));
		UTCHK(WASCALLED0(DocumentPersistanceBaseTest, OnFileChangedSetTimer, 0));
		UTCHK(S_OK == IgnoreFileChanges(TRUE));
		UTCHK(S_OK == FilesChanged(iFileChanges, changedFileNames, changeFlags));
		// still not balanced
		UTCHK(WASCALLED0(DocumentPersistanceBaseTest, PostSetReadOnly, 0));
		UTCHK(WASCALLED0(DocumentPersistanceBaseTest, OnFileChangedSetTimer, 0));
		UTCHK(S_OK == IgnoreFileChanges(FALSE));
		UTCHK(S_OK == FilesChanged(iFileChanges, changedFileNames, changeFlags));
		// still not balanced
		UTCHK(WASCALLED0(DocumentPersistanceBaseTest, PostSetReadOnly, 0));
		UTCHK(WASCALLED0(DocumentPersistanceBaseTest, OnFileChangedSetTimer, 0));
		UTCHK(S_OK == IgnoreFileChanges(FALSE));
		UTCHK(S_OK == FilesChanged(iFileChanges, changedFileNames, changeFlags));
		// Balanced, now should get called.
		UTCHK(WASCALLED0(DocumentPersistanceBaseTest, PostSetReadOnly, 1));
		UTCHK(WASCALLED0(DocumentPersistanceBaseTest, OnFileChangedSetTimer, 1));

		// This just returns S_OK in all cases
		UTCHK(S_OK == DirectoryChanged(NULL));
		UTCHK(S_OK == DirectoryChanged(L""));
		UTCHK(S_OK == DirectoryChanged(L"\\Directory\\Directory"));
	}

	DocumentPersistanceBaseTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName),
		m_strFileName(L"\\Test\\Test.rtf"),
		m_strFormatList(L"Test Format List")
	{
		TestFileChangeRelated();
		TestIVsPersistDocData();
		TestIPersistFileFormat();
		TestServiceDependentMethods();
	}
private:
	CStringW m_strFileName;
	CStringW m_strFormatList;
	VsSiteCacheLocal m_VsSiteCache;
};

// TODO - 1/27/2006 - make a Font unit test for the following
#include "VSLFont.h"
#include "VSLContainers.h" // for StaticArray

class VsFontCommandHandlingTest :
	public UnitTestBase
{
public:

	VsFontCommandHandlingTest(_In_opt_ const char* const szTestName):
		UnitTestBase(szTestName)
	{
		std::vector<wchar_t*> emptyVector;
		{
		VSL_STDMETHODTRY{		
		VsFontCommandHandling::FontContainerToVariant(emptyVector, NULL);
		}VSL_STDMETHODCATCH()
		UTCHK(E_INVALIDARG == VSL_GET_STDMETHOD_HRESULT());
		}

		ATL::CComVariant var;
		{
		VSL_STDMETHODTRY{		
		VsFontCommandHandling::FontContainerToVariant(emptyVector, &var);
		}VSL_STDMETHODCATCH()
		UTCHK(E_FAIL == VSL_GET_STDMETHOD_HRESULT());
		}

		StaticArray<wchar_t*, 3> szFontSizeStrings =
		{
			{ 
				_T("8"), 
				_T("10"), 
				_T("12"), 
			}
		};

		{
		VSL_STDMETHODTRY{		
		VsFontCommandHandling::FontContainerToVariant(szFontSizeStrings, NULL);
		}VSL_STDMETHODCATCH()
		UTCHK(E_INVALIDARG == VSL_GET_STDMETHOD_HRESULT());
		}

		VsFontCommandHandling::FontContainerToVariant(szFontSizeStrings, &var);
		UTCHK(var.vt == (VT_ARRAY|VT_BSTR));
		ATL::CComSafeArray<BSTR> safeArray(var.parray);
		UTCHK(3 == safeArray.GetCount());
		UTCHK(safeArray[0] == szFontSizeStrings[0]);
		UTCHK(safeArray[1] == szFontSizeStrings[1]);
		UTCHK(safeArray[2] == szFontSizeStrings[2]);

		// PopulateFontNameContainer is test by the Single View Editor Sample
		// although it could be more precisely tested here.
	}
};

int _cdecl _tmain()
{
	UTRUN(ToolWindowBaseTest);
	UTRUN(VsWindowPaneFromResourceMockImpl);
#if 0
	UTRUN(SingleSelectionContainerTest);
#endif
	UTRUN(WindowFrameEventsSinkTest);
	UTRUN(IVsEditorFactoryImplTest);
	UTRUN(IVsFindTargetImplTest);
	UTRUN(VSLMessageMapTest);
	UTRUN(DocumentPersistanceBaseTest);
	UTRUN(VsFontCommandHandlingTest);
	return VSL::FailureCounter::Get();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Babel\Declaration.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.Collections.Generic;

namespace Babel
{
	public struct Declaration
	{
		public Declaration(string description, string displayText, int glyph, string name)
		{
			this.Description = description;
			this.DisplayText = displayText;
			this.Glyph = glyph;
			this.Name = name;
		}

		public string Description;
		public string DisplayText;
		public int Glyph;
		public string Name;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Babel\AuthoringScope.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.Collections.Generic;
using Microsoft.VisualStudio;
using Microsoft.VisualStudio.TextManager.Interop;
using Microsoft.VisualStudio.Package;

namespace Babel
{
	public class AuthoringScope : Microsoft.VisualStudio.Package.AuthoringScope
	{
		public AuthoringScope(object parseResult)
		{
			this.parseResult = parseResult;
		
			// how should this be set?
			this.resolver = new Resolver();
		}

		object parseResult;
		IASTResolver resolver;

		// ParseReason.QuickInfo
		public override string GetDataTipText(int line, int col, out TextSpan span)
		{
			span = new TextSpan();
			return null;
		}

		// ParseReason.CompleteWord
		// ParseReason.DisplayMemberList
		// ParseReason.MemberSelect
		// ParseReason.MemberSelectAndHilightBraces
		public override Microsoft.VisualStudio.Package.Declarations GetDeclarations(IVsTextView view, int line, int col, TokenInfo info, ParseReason reason)
		{
			IList<Declaration> declarations;
			switch (reason)
			{
				case ParseReason.CompleteWord:
					declarations = resolver.FindCompletions(parseResult, line, col);
					break;
				case ParseReason.DisplayMemberList:
				case ParseReason.MemberSelect:
				case ParseReason.MemberSelectAndHighlightBraces:
					declarations = resolver.FindMembers(parseResult, line, col);
					break;
				default:
					throw new ArgumentException("reason");
			}

			return new Declarations(declarations);
		}

		// ParseReason.GetMethods
		public override Microsoft.VisualStudio.Package.Methods GetMethods(int line, int col, string name)
		{
			return new Methods(resolver.FindMethods(parseResult, line, col, name));
		}

		// ParseReason.Goto
		public override string Goto(VSConstants.VSStd97CmdID cmd, IVsTextView textView, int line, int col, out TextSpan span)
		{
			// throw new System.NotImplementedException();
			span = new TextSpan();
			return null;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Babel\IASTResolver.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.Collections.Generic;

namespace Babel
{
	interface IASTResolver
	{
		IList<Declaration> FindCompletions(object result, int line, int col);
		IList<Declaration> FindMembers(object result, int line, int col);
		string FindQuickInfo(object result, int line, int col);
		IList<Method> FindMethods(object result, int line, int col, string name);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Babel\Declarations.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.VisualStudio.TextManager.Interop;
using Microsoft.VisualStudio.Package;

namespace Babel
{
	public class Declarations : Microsoft.VisualStudio.Package.Declarations
	{
		IList<Declaration> declarations;
		public Declarations(IList<Declaration> declarations)
		{
			this.declarations = declarations;
		}

		public override int GetCount()
		{
			return declarations.Count;
		}

		public override string GetDescription(int index)
		{
			return declarations[index].Description;
		}

		public override string GetDisplayText(int index)
		{
			return declarations[index].DisplayText;
		}

		public override int GetGlyph(int index)
		{
			return declarations[index].Glyph;
		}

		public override string GetName(int index)
		{
			if (index >= 0)
				return declarations[index].Name;

			return null;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Babel\Method.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.Collections.Generic;

namespace Babel
{
	public struct Method
	{
		public string Name;
		public string Description;
		public string Type;
		public IList<Parameter> Parameters;
	}

	public struct Parameter
	{
		public string Name;
		public string Display;
		public string Description;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Babel\Configuration.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.Collections.Generic;
using Microsoft.VisualStudio.Package;
using Babel.Parser;
using Microsoft.VisualStudio.TextManager.Interop;

namespace Babel
{
	public static partial class Configuration
	{
		static List<Microsoft.VisualStudio.TextManager.Interop.IVsColorableItem> colorableItems = new List<Microsoft.VisualStudio.TextManager.Interop.IVsColorableItem>();
		public static IList<Microsoft.VisualStudio.TextManager.Interop.IVsColorableItem> ColorableItems
		{
			get { return colorableItems; }
		}

		public static TokenColor CreateColor(string name, COLORINDEX foreground, COLORINDEX background)
		{
			return CreateColor(name, foreground, background, false, false);
		}

		public static TokenColor CreateColor(string name, COLORINDEX foreground, COLORINDEX background, bool bold, bool strikethrough)
		{
			colorableItems.Add(new ColorableItem(name, foreground, background, bold, strikethrough));
			return (TokenColor) colorableItems.Count;
		}

		public static void ColorToken(int token, TokenType type, TokenColor color, TokenTriggers trigger)
		{
			definitions[token] = new TokenDefinition(type, color, trigger);
		}

		public static TokenDefinition GetDefinition(int token)
		{
			TokenDefinition result;
			return definitions.TryGetValue(token, out result) ? result : defaultDefinition;
		}

		private static TokenDefinition defaultDefinition = new TokenDefinition(TokenType.Text, TokenColor.Text, TokenTriggers.None);
		private static Dictionary<int, TokenDefinition> definitions = new Dictionary<int, TokenDefinition>();

		public struct TokenDefinition
		{
			public TokenDefinition(TokenType type, TokenColor color, TokenTriggers triggers)
			{
				this.TokenType = type;
				this.TokenColor = color;
				this.TokenTriggers = triggers;
			}

			public TokenType TokenType;
			public TokenColor TokenColor;
			public TokenTriggers TokenTriggers;
		}
	}

	public class ColorableItem : Microsoft.VisualStudio.TextManager.Interop.IVsColorableItem
	{
		private string displayName;
		private COLORINDEX background;
		private COLORINDEX foreground;
		private uint fontFlags = (uint) FONTFLAGS.FF_DEFAULT;

		public ColorableItem(string displayName, COLORINDEX foreground, COLORINDEX background, bool bold, bool strikethrough)
		{
			this.displayName = displayName;
			this.background = background;
			this.foreground = foreground;

			if (bold)
				this.fontFlags = this.fontFlags | (uint)FONTFLAGS.FF_BOLD;
			if (strikethrough)
				this.fontFlags = this.fontFlags | (uint)FONTFLAGS.FF_STRIKETHROUGH;
		}

		#region IVsColorableItem Members
		public int GetDefaultColors(COLORINDEX[] piForeground, COLORINDEX[] piBackground)
		{
			if (null == piForeground)
			{
				throw new ArgumentNullException("piForeground");
			}
			if (0 == piForeground.Length)
			{
				throw new ArgumentOutOfRangeException("piForeground");
			}
			piForeground[0] = foreground;

			if (null == piBackground)
			{
				throw new ArgumentNullException("piBackground");
			}
			if (0 == piBackground.Length)
			{
				throw new ArgumentOutOfRangeException("piBackground");
			}
			piBackground[0] = background;

			return Microsoft.VisualStudio.VSConstants.S_OK;
		}

		public int GetDefaultFontFlags(out uint pdwFontFlags)
		{
			pdwFontFlags = this.fontFlags;
			return Microsoft.VisualStudio.VSConstants.S_OK;
		}

		public int GetDisplayName(out string pbstrName)
		{
			pbstrName = displayName;
			return Microsoft.VisualStudio.VSConstants.S_OK;
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Babel\Package.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.Collections.Generic;
using System.Text;
using System.Runtime.InteropServices;
using Microsoft.VisualStudio.OLE.Interop;
using MPF = Microsoft.VisualStudio.Package;
using System.Compo